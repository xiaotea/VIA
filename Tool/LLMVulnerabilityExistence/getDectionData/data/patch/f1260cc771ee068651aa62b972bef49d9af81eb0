{
    "glance/api/authorization.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             raise exception.Forbidden(message"
            },
            "1": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                                       % self.image.image_id)"
            },
            "2": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         if (self.context.is_admin or"
            },
            "6": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                 self.context.owner == image_member.member_id):"
            },
            "7": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.member_repo.save(image_member)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            self.member_repo.save(image_member, from_state=from_state)"
            },
            "9": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "             message = _(\"You cannot update image member %s\")"
            },
            "11": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             raise exception.Forbidden(message % image_member.member_id)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "",
            "",
            "def is_image_mutable(context, image):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if image.owner is None or context.owner is None:",
            "        return False",
            "",
            "    return image.owner == context.owner",
            "",
            "",
            "def proxy_image(context, image):",
            "    if is_image_mutable(context, image):",
            "        return ImageProxy(image, context)",
            "    else:",
            "        return ImmutableImageProxy(image, context)",
            "",
            "",
            "def is_member_mutable(context, member):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return member.member_id == context.owner",
            "",
            "",
            "def proxy_member(context, member):",
            "    if is_member_mutable(context, member):",
            "        return member",
            "    else:",
            "        return ImmutableMemberProxy(member)",
            "",
            "",
            "def is_task_mutable(context, task):",
            "    \"\"\"Return True if the task is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task.owner == context.owner",
            "",
            "",
            "def proxy_task(context, task):",
            "    if is_task_mutable(context, task):",
            "        return task",
            "    else:",
            "        return ImmutableTaskProxy(task)",
            "",
            "",
            "def proxy_task_details(context, task, task_details):",
            "    if is_task_mutable(context, task):",
            "        return task_details",
            "    else:",
            "        return ImmutableTaskDetailsProxy(task_details)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context):",
            "        self.context = context",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        image = self.image_repo.get(image_id)",
            "        return proxy_image(self.context, image)",
            "",
            "    def list(self, *args, **kwargs):",
            "        images = self.image_repo.list(*args, **kwargs)",
            "        return [proxy_image(self.context, i) for i in images]",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, image, context):",
            "        self.member_repo = member_repo",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageMemberRepoProxy, self).__init__(member_repo)",
            "",
            "    def get(self, member_id):",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner or",
            "                self.context.owner == member_id):",
            "            member = self.member_repo.get(member_id)",
            "            return proxy_member(self.context, member)",
            "        else:",
            "            message = _(\"You cannot get image member for %s\")",
            "            raise exception.Forbidden(message % member_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        members = self.member_repo.list(*args, **kwargs)",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner):",
            "            return [proxy_member(self.context, m) for m in members]",
            "        for member in members:",
            "            if member.member_id == self.context.owner:",
            "                return [proxy_member(self.context, member)]",
            "        message = _(\"You cannot get image member for %s\")",
            "        raise exception.Forbidden(message % self.image.image_id)",
            "",
            "    def remove(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.remove(image_member)",
            "        else:",
            "            message = _(\"You cannot delete image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def add(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.add(image_member)",
            "        else:",
            "            message = _(\"You cannot add image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def save(self, image_member):",
            "        if (self.context.is_admin or",
            "                self.context.owner == image_member.member_id):",
            "            self.member_repo.save(image_member)",
            "        else:",
            "            message = _(\"You cannot update image member %s\")",
            "            raise exception.Forbidden(message % image_member.member_id)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        kwargs = {'context': self.context}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create images \"",
            "                            \"owned by '%s'.\")",
            "                raise exception.Forbidden(message % owner)",
            "",
            "        return super(ImageFactoryProxy, self).new_image(owner=owner, **kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(object):",
            "",
            "    def __init__(self, image_member_factory, context):",
            "        self.image_member_factory = image_member_factory",
            "        self.context = context",
            "",
            "    def new_image_member(self, image, member_id):",
            "        owner = image.owner",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create image members \"",
            "                            \"for the image.\")",
            "                raise exception.Forbidden(message)",
            "",
            "        if image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "",
            "        return self.image_member_factory.new_image_member(image, member_id)",
            "",
            "",
            "def _immutable_attr(target, attr, proxy=None):",
            "",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        if proxy is not None:",
            "            value = proxy(value)",
            "        return value",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        resource = getattr(self, 'resource_name', 'resource')",
            "        message = _(\"You are not permitted to modify '%(attr)s' on this \"",
            "                    \"%(resource)s.\")",
            "        raise exception.Forbidden(message % {'attr': attr,",
            "                                             'resource': resource})",
            "",
            "    return property(get_attr, forbidden, forbidden)",
            "",
            "",
            "class ImmutableLocations(list):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify locations \"",
            "                    \"for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def __deepcopy__(self, memo):",
            "        return ImmutableLocations(copy.deepcopy(list(self), memo))",
            "",
            "    append = forbidden",
            "    extend = forbidden",
            "    insert = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    reverse = forbidden",
            "    sort = forbidden",
            "    __delitem__ = forbidden",
            "    __delslice__ = forbidden",
            "    __iadd__ = forbidden",
            "    __imul__ = forbidden",
            "    __setitem__ = forbidden",
            "    __setslice__ = forbidden",
            "",
            "",
            "class ImmutableProperties(dict):",
            "    def forbidden_key(self, key, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify '%s' on this image.\")",
            "        raise exception.Forbidden(message % key)",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    __delitem__ = forbidden_key",
            "    __setitem__ = forbidden_key",
            "    pop = forbidden",
            "    popitem = forbidden",
            "    setdefault = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableTags(set):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify tags on this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    add = forbidden",
            "    clear = forbidden",
            "    difference_update = forbidden",
            "    intersection_update = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    symmetric_difference_update = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableImageProxy(object):",
            "    def __init__(self, base, context):",
            "        self.base = base",
            "        self.context = context",
            "        self.resource_name = 'image'",
            "",
            "    name = _immutable_attr('base', 'name')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    name = _immutable_attr('base', 'name')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    min_disk = _immutable_attr('base', 'min_disk')",
            "    min_ram = _immutable_attr('base', 'min_ram')",
            "    protected = _immutable_attr('base', 'protected')",
            "    locations = _immutable_attr('base', 'locations', proxy=ImmutableLocations)",
            "    checksum = _immutable_attr('base', 'checksum')",
            "    owner = _immutable_attr('base', 'owner')",
            "    disk_format = _immutable_attr('base', 'disk_format')",
            "    container_format = _immutable_attr('base', 'container_format')",
            "    size = _immutable_attr('base', 'size')",
            "    virtual_size = _immutable_attr('base', 'virtual_size')",
            "    extra_properties = _immutable_attr('base', 'extra_properties',",
            "                                       proxy=ImmutableProperties)",
            "    tags = _immutable_attr('base', 'tags', proxy=ImmutableTags)",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = self.base.get_member_repo()",
            "        return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "    def get_data(self):",
            "        return self.base.get_data()",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to upload data for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableMemberProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'image member'",
            "",
            "    id = _immutable_attr('base', 'id')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    member_id = _immutable_attr('base', 'member_id')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImmutableTaskProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def succeed(self, result):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def fail(self, message):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableTaskDetailsProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    input = _immutable_attr('base', 'input')",
            "    message = _immutable_attr('base', 'message')",
            "    result = _immutable_attr('base', 'result')",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context):",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        if self.image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "        else:",
            "            member_repo = self.image.get_member_repo(**kwargs)",
            "            return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task):",
            "        self.task = task",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details):",
            "        self.task_details = task_details",
            "        super(TaskDetailsProxy, self).__init__(task_details)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_details_proxy_class=TaskDetailsProxy)",
            "",
            "    def new_task(self, **kwargs):",
            "        owner = kwargs.get('owner', self.context.owner)",
            "",
            "        #NOTE(nikhil): Unlike Images, Tasks are expected to have owner.",
            "        # We currently do not allow even admins to set the owner to None.",
            "        if owner is not None and (owner == self.context.owner",
            "                                  or self.context.is_admin):",
            "            return super(TaskFactoryProxy, self).new_task(**kwargs)",
            "        else:",
            "            message = _(\"You are not permitted to create this task with \"",
            "                        \"owner as: %s\")",
            "            raise exception.Forbidden(message % owner)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        super(TaskRepoProxy, self).__init__(task_repo)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        task, task_details = self.task_repo.get_task_and_details(task_id)",
            "        return proxy_task(self.context, task), proxy_task_details(self.context,",
            "                                                                  task,",
            "                                                                  task_details)",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        tasks = self.task_repo.list_tasks(*args, **kwargs)",
            "        return [proxy_task(self.context, t) for t in tasks]"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "",
            "",
            "def is_image_mutable(context, image):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if image.owner is None or context.owner is None:",
            "        return False",
            "",
            "    return image.owner == context.owner",
            "",
            "",
            "def proxy_image(context, image):",
            "    if is_image_mutable(context, image):",
            "        return ImageProxy(image, context)",
            "    else:",
            "        return ImmutableImageProxy(image, context)",
            "",
            "",
            "def is_member_mutable(context, member):",
            "    \"\"\"Return True if the image is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return member.member_id == context.owner",
            "",
            "",
            "def proxy_member(context, member):",
            "    if is_member_mutable(context, member):",
            "        return member",
            "    else:",
            "        return ImmutableMemberProxy(member)",
            "",
            "",
            "def is_task_mutable(context, task):",
            "    \"\"\"Return True if the task is mutable in this context.\"\"\"",
            "    if context.is_admin:",
            "        return True",
            "",
            "    if context.owner is None:",
            "        return False",
            "",
            "    return task.owner == context.owner",
            "",
            "",
            "def proxy_task(context, task):",
            "    if is_task_mutable(context, task):",
            "        return task",
            "    else:",
            "        return ImmutableTaskProxy(task)",
            "",
            "",
            "def proxy_task_details(context, task, task_details):",
            "    if is_task_mutable(context, task):",
            "        return task_details",
            "    else:",
            "        return ImmutableTaskDetailsProxy(task_details)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context):",
            "        self.context = context",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        image = self.image_repo.get(image_id)",
            "        return proxy_image(self.context, image)",
            "",
            "    def list(self, *args, **kwargs):",
            "        images = self.image_repo.list(*args, **kwargs)",
            "        return [proxy_image(self.context, i) for i in images]",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, image, context):",
            "        self.member_repo = member_repo",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageMemberRepoProxy, self).__init__(member_repo)",
            "",
            "    def get(self, member_id):",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner or",
            "                self.context.owner == member_id):",
            "            member = self.member_repo.get(member_id)",
            "            return proxy_member(self.context, member)",
            "        else:",
            "            message = _(\"You cannot get image member for %s\")",
            "            raise exception.Forbidden(message % member_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        members = self.member_repo.list(*args, **kwargs)",
            "        if (self.context.is_admin or",
            "                self.context.owner == self.image.owner):",
            "            return [proxy_member(self.context, m) for m in members]",
            "        for member in members:",
            "            if member.member_id == self.context.owner:",
            "                return [proxy_member(self.context, member)]",
            "        message = _(\"You cannot get image member for %s\")",
            "        raise exception.Forbidden(message % self.image.image_id)",
            "",
            "    def remove(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.remove(image_member)",
            "        else:",
            "            message = _(\"You cannot delete image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def add(self, image_member):",
            "        if (self.image.owner == self.context.owner or",
            "                self.context.is_admin):",
            "            self.member_repo.add(image_member)",
            "        else:",
            "            message = _(\"You cannot add image member for %s\")",
            "            raise exception.Forbidden(message",
            "                                      % self.image.image_id)",
            "",
            "    def save(self, image_member, from_state=None):",
            "        if (self.context.is_admin or",
            "                self.context.owner == image_member.member_id):",
            "            self.member_repo.save(image_member, from_state=from_state)",
            "        else:",
            "            message = _(\"You cannot update image member %s\")",
            "            raise exception.Forbidden(message % image_member.member_id)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        kwargs = {'context': self.context}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        owner = kwargs.pop('owner', self.context.owner)",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create images \"",
            "                            \"owned by '%s'.\")",
            "                raise exception.Forbidden(message % owner)",
            "",
            "        return super(ImageFactoryProxy, self).new_image(owner=owner, **kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(object):",
            "",
            "    def __init__(self, image_member_factory, context):",
            "        self.image_member_factory = image_member_factory",
            "        self.context = context",
            "",
            "    def new_image_member(self, image, member_id):",
            "        owner = image.owner",
            "",
            "        if not self.context.is_admin:",
            "            if owner is None or owner != self.context.owner:",
            "                message = _(\"You are not permitted to create image members \"",
            "                            \"for the image.\")",
            "                raise exception.Forbidden(message)",
            "",
            "        if image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "",
            "        return self.image_member_factory.new_image_member(image, member_id)",
            "",
            "",
            "def _immutable_attr(target, attr, proxy=None):",
            "",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        if proxy is not None:",
            "            value = proxy(value)",
            "        return value",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        resource = getattr(self, 'resource_name', 'resource')",
            "        message = _(\"You are not permitted to modify '%(attr)s' on this \"",
            "                    \"%(resource)s.\")",
            "        raise exception.Forbidden(message % {'attr': attr,",
            "                                             'resource': resource})",
            "",
            "    return property(get_attr, forbidden, forbidden)",
            "",
            "",
            "class ImmutableLocations(list):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify locations \"",
            "                    \"for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def __deepcopy__(self, memo):",
            "        return ImmutableLocations(copy.deepcopy(list(self), memo))",
            "",
            "    append = forbidden",
            "    extend = forbidden",
            "    insert = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    reverse = forbidden",
            "    sort = forbidden",
            "    __delitem__ = forbidden",
            "    __delslice__ = forbidden",
            "    __iadd__ = forbidden",
            "    __imul__ = forbidden",
            "    __setitem__ = forbidden",
            "    __setslice__ = forbidden",
            "",
            "",
            "class ImmutableProperties(dict):",
            "    def forbidden_key(self, key, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify '%s' on this image.\")",
            "        raise exception.Forbidden(message % key)",
            "",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    __delitem__ = forbidden_key",
            "    __setitem__ = forbidden_key",
            "    pop = forbidden",
            "    popitem = forbidden",
            "    setdefault = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableTags(set):",
            "    def forbidden(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to modify tags on this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    add = forbidden",
            "    clear = forbidden",
            "    difference_update = forbidden",
            "    intersection_update = forbidden",
            "    pop = forbidden",
            "    remove = forbidden",
            "    symmetric_difference_update = forbidden",
            "    update = forbidden",
            "",
            "",
            "class ImmutableImageProxy(object):",
            "    def __init__(self, base, context):",
            "        self.base = base",
            "        self.context = context",
            "        self.resource_name = 'image'",
            "",
            "    name = _immutable_attr('base', 'name')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    name = _immutable_attr('base', 'name')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "    visibility = _immutable_attr('base', 'visibility')",
            "    min_disk = _immutable_attr('base', 'min_disk')",
            "    min_ram = _immutable_attr('base', 'min_ram')",
            "    protected = _immutable_attr('base', 'protected')",
            "    locations = _immutable_attr('base', 'locations', proxy=ImmutableLocations)",
            "    checksum = _immutable_attr('base', 'checksum')",
            "    owner = _immutable_attr('base', 'owner')",
            "    disk_format = _immutable_attr('base', 'disk_format')",
            "    container_format = _immutable_attr('base', 'container_format')",
            "    size = _immutable_attr('base', 'size')",
            "    virtual_size = _immutable_attr('base', 'virtual_size')",
            "    extra_properties = _immutable_attr('base', 'extra_properties',",
            "                                       proxy=ImmutableProperties)",
            "    tags = _immutable_attr('base', 'tags', proxy=ImmutableTags)",
            "",
            "    def delete(self):",
            "        message = _(\"You are not permitted to delete this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = self.base.get_member_repo()",
            "        return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "    def get_data(self):",
            "        return self.base.get_data()",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        message = _(\"You are not permitted to upload data for this image.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableMemberProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'image member'",
            "",
            "    id = _immutable_attr('base', 'id')",
            "    image_id = _immutable_attr('base', 'image_id')",
            "    member_id = _immutable_attr('base', 'member_id')",
            "    status = _immutable_attr('base', 'status')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "",
            "class ImmutableTaskProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "        self.resource_name = 'task'",
            "",
            "    task_id = _immutable_attr('base', 'task_id')",
            "    type = _immutable_attr('base', 'type')",
            "    status = _immutable_attr('base', 'status')",
            "    owner = _immutable_attr('base', 'owner')",
            "    expires_at = _immutable_attr('base', 'expires_at')",
            "    created_at = _immutable_attr('base', 'created_at')",
            "    updated_at = _immutable_attr('base', 'updated_at')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def succeed(self, result):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "    def fail(self, message):",
            "        message = _(\"You are not permitted to set status on this task.\")",
            "        raise exception.Forbidden(message)",
            "",
            "",
            "class ImmutableTaskDetailsProxy(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    input = _immutable_attr('base', 'input')",
            "    message = _immutable_attr('base', 'message')",
            "    result = _immutable_attr('base', 'result')",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context):",
            "        self.image = image",
            "        self.context = context",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        if self.image.visibility == 'public':",
            "            message = _(\"Public images do not have members.\")",
            "            raise exception.Forbidden(message)",
            "        else:",
            "            member_repo = self.image.get_member_repo(**kwargs)",
            "            return ImageMemberRepoProxy(member_repo, self, self.context)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task):",
            "        self.task = task",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details):",
            "        self.task_details = task_details",
            "        super(TaskDetailsProxy, self).__init__(task_details)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_details_proxy_class=TaskDetailsProxy)",
            "",
            "    def new_task(self, **kwargs):",
            "        owner = kwargs.get('owner', self.context.owner)",
            "",
            "        #NOTE(nikhil): Unlike Images, Tasks are expected to have owner.",
            "        # We currently do not allow even admins to set the owner to None.",
            "        if owner is not None and (owner == self.context.owner",
            "                                  or self.context.is_admin):",
            "            return super(TaskFactoryProxy, self).new_task(**kwargs)",
            "        else:",
            "            message = _(\"You are not permitted to create this task with \"",
            "                        \"owner as: %s\")",
            "            raise exception.Forbidden(message % owner)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        super(TaskRepoProxy, self).__init__(task_repo)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        task, task_details = self.task_repo.get_task_and_details(task_id)",
            "        return proxy_task(self.context, task), proxy_task_details(self.context,",
            "                                                                  task,",
            "                                                                  task_details)",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        tasks = self.task_repo.list_tasks(*args, **kwargs)",
            "        return [proxy_task(self.context, t) for t in tasks]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "150": [
                "ImageMemberRepoProxy",
                "save"
            ],
            "153": [
                "ImageMemberRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/api/policy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_images', {})"
            },
            "1": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         return super(ImageRepoProxy, self).list(*args, **kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         self.policy.enforce(self.context, 'modify_image', {})"
            },
            "6": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return super(ImageRepoProxy, self).save(image)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        return super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "8": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     def add(self, image):"
            },
            "10": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         self.policy.enforce(self.context, 'add_image', {})"
            },
            "11": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_member', {})"
            },
            "12": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         return self.member_repo.get(member_id)"
            },
            "13": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, member):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+    def save(self, member, from_state=None):"
            },
            "16": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         self.policy.enforce(self.context, 'modify_member', {})"
            },
            "17": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.member_repo.save(member)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        self.member_repo.save(member, from_state=from_state)"
            },
            "19": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     def list(self, *args, **kwargs):"
            },
            "21": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         self.policy.enforce(self.context, 'get_members', {})"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2011 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Policy Engine For Glance\"\"\"",
            "",
            "import copy",
            "import os.path",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance.openstack.common import jsonutils",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import policy",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "policy_opts = [",
            "    cfg.StrOpt('policy_file', default='policy.json',",
            "               help=_('The location of the policy file.')),",
            "    cfg.StrOpt('policy_default_rule', default='default',",
            "               help=_('The default policy to use.')),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(policy_opts)",
            "",
            "",
            "DEFAULT_RULES = {",
            "    'context_is_admin': policy.RoleCheck('role', 'admin'),",
            "    'default': policy.TrueCheck(),",
            "    'manage_image_cache': policy.RoleCheck('role', 'admin'),",
            "}",
            "",
            "",
            "class Enforcer(object):",
            "    \"\"\"Responsible for loading and enforcing rules\"\"\"",
            "",
            "    def __init__(self):",
            "        self.default_rule = CONF.policy_default_rule",
            "        self.policy_path = self._find_policy_file()",
            "        self.policy_file_mtime = None",
            "        self.policy_file_contents = None",
            "        self.load_rules()",
            "",
            "    def set_rules(self, rules):",
            "        \"\"\"Create a new Rules object based on the provided dict of rules\"\"\"",
            "        rules_obj = policy.Rules(rules, self.default_rule)",
            "        policy.set_rules(rules_obj)",
            "",
            "    def add_rules(self, rules):",
            "        \"\"\"Add new rules to the Rules object\"\"\"",
            "        if policy._rules:",
            "            rules_obj = policy.Rules(rules)",
            "            policy._rules.update(rules_obj)",
            "        else:",
            "            self.set_rules(rules)",
            "",
            "    def load_rules(self):",
            "        \"\"\"Set the rules found in the json file on disk\"\"\"",
            "        if self.policy_path:",
            "            rules = self._read_policy_file()",
            "            rule_type = \"\"",
            "        else:",
            "            rules = DEFAULT_RULES",
            "            rule_type = \"default \"",
            "",
            "        text_rules = dict((k, str(v)) for k, v in rules.items())",
            "        msg = (_('Loaded %(rule_type)spolicy rules: %(text_rules)s') %",
            "               {'rule_type': rule_type, 'text_rules': text_rules})",
            "        LOG.debug(msg)",
            "",
            "        self.set_rules(rules)",
            "",
            "    @staticmethod",
            "    def _find_policy_file():",
            "        \"\"\"Locate the policy json data file\"\"\"",
            "        policy_file = CONF.find_file(CONF.policy_file)",
            "        if policy_file:",
            "            return policy_file",
            "        else:",
            "            LOG.warn(_('Unable to find policy file'))",
            "            return None",
            "",
            "    def _read_policy_file(self):",
            "        \"\"\"Read contents of the policy file",
            "",
            "        This re-caches policy data if the file has been changed.",
            "        \"\"\"",
            "        mtime = os.path.getmtime(self.policy_path)",
            "        if not self.policy_file_contents or mtime != self.policy_file_mtime:",
            "            LOG.debug(_(\"Loading policy from %s\") % self.policy_path)",
            "            with open(self.policy_path) as fap:",
            "                raw_contents = fap.read()",
            "                rules_dict = jsonutils.loads(raw_contents)",
            "                self.policy_file_contents = dict(",
            "                    (k, policy.parse_rule(v))",
            "                    for k, v in rules_dict.items())",
            "            self.policy_file_mtime = mtime",
            "        return self.policy_file_contents",
            "",
            "    def _check(self, context, rule, target, *args, **kwargs):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param rule: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "",
            "        return policy.check(rule, target, credentials, *args, **kwargs)",
            "",
            "    def enforce(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        return self._check(context, action, target,",
            "                           exception.Forbidden, action=action)",
            "",
            "    def check(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        return self._check(context, action, target)",
            "",
            "    def check_is_admin(self, context):",
            "        \"\"\"Check if the given context is associated with an admin role,",
            "           as defined via the 'context_is_admin' RBAC rule.",
            "",
            "           :param context: Glance request context",
            "           :returns: A non-False value if context role is admin.",
            "        \"\"\"",
            "        target = context.to_dict()",
            "        return self.check(context, 'context_is_admin', target)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        self.policy.enforce(self.context, 'get_image', {})",
            "        return super(ImageRepoProxy, self).get(image_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_images', {})",
            "        return super(ImageRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, image):",
            "        self.policy.enforce(self.context, 'modify_image', {})",
            "        return super(ImageRepoProxy, self).save(image)",
            "",
            "    def add(self, image):",
            "        self.policy.enforce(self.context, 'add_image', {})",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, policy):",
            "        self.image = image",
            "        self.context = context",
            "        self.policy = policy",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    @property",
            "    def visibility(self):",
            "        return self.image.visibility",
            "",
            "    @visibility.setter",
            "    def visibility(self, value):",
            "        if value == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        self.image.visibility = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return ImageLocationsProxy(self.image.locations,",
            "                                   self.context, self.policy)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        if not isinstance(value, (list, ImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "        self.policy.enforce(self.context, 'set_image_location', {})",
            "        new_locations = list(value)",
            "        if (set([loc['url'] for loc in self.image.locations]) -",
            "                set([loc['url'] for loc in new_locations])):",
            "            self.policy.enforce(self.context, 'delete_image_location', {})",
            "        self.image.locations = new_locations",
            "",
            "    def delete(self):",
            "        self.policy.enforce(self.context, 'delete_image', {})",
            "        return self.image.delete()",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'download_image', {})",
            "        return self.image.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'upload_image', {})",
            "        return self.image.set_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        member_repo = self.image.get_member_repo(**kwargs)",
            "        return ImageMemberRepoProxy(member_repo, self.context, self.policy)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context, policy):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        if kwargs.get('visibility') == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, policy):",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={'context': context, 'policy': policy})",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, context, policy):",
            "        self.member_repo = member_repo",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def add(self, member):",
            "        self.policy.enforce(self.context, 'add_member', {})",
            "        self.member_repo.add(member)",
            "",
            "    def get(self, member_id):",
            "        self.policy.enforce(self.context, 'get_member', {})",
            "        return self.member_repo.get(member_id)",
            "",
            "    def save(self, member):",
            "        self.policy.enforce(self.context, 'modify_member', {})",
            "        self.member_repo.save(member)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_members', {})",
            "        return self.member_repo.list(*args, **kwargs)",
            "",
            "    def remove(self, member):",
            "        self.policy.enforce(self.context, 'delete_member', {})",
            "        self.member_repo.remove(member)",
            "",
            "",
            "class ImageLocationsProxy(object):",
            "",
            "    __hash__ = None",
            "",
            "    def __init__(self, locations, context, policy):",
            "        self.locations = locations",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.locations, self.context, self.policy)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        return type(self)(copy.deepcopy(self.locations, memo),",
            "                          self.context, self.policy)",
            "",
            "    def _get_checker(action, func_name):",
            "        def _checker(self, *args, **kwargs):",
            "            self.policy.enforce(self.context, action, {})",
            "            assert hasattr(self.locations, func_name)",
            "            method = getattr(self.locations, func_name)",
            "            return method(*args, **kwargs)",
            "        return _checker",
            "",
            "    count = _get_checker('get_image_location', 'count')",
            "    index = _get_checker('get_image_location', 'index')",
            "    __getitem__ = _get_checker('get_image_location', '__getitem__')",
            "    __contains__ = _get_checker('get_image_location', '__contains__')",
            "    __len__ = _get_checker('get_image_location', '__len__')",
            "    __cast = _get_checker('get_image_location', '__cast')",
            "    __cmp__ = _get_checker('get_image_location', '__cmp__')",
            "    __iter__ = _get_checker('get_image_location', '__iter__')",
            "",
            "    append = _get_checker('set_image_location', 'append')",
            "    extend = _get_checker('set_image_location', 'extend')",
            "    insert = _get_checker('set_image_location', 'insert')",
            "    reverse = _get_checker('set_image_location', 'reverse')",
            "    __iadd__ = _get_checker('set_image_location', '__iadd__')",
            "    __setitem__ = _get_checker('set_image_location', '__setitem__')",
            "",
            "    pop = _get_checker('delete_image_location', 'pop')",
            "    remove = _get_checker('delete_image_location', 'remove')",
            "    __delitem__ = _get_checker('delete_image_location', '__delitem__')",
            "    __delslice__ = _get_checker('delete_image_location', '__delslice__')",
            "",
            "    del _get_checker",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, policy):",
            "        self.task = task",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details, context, policy):",
            "        self.task_details = task_details",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskDetailsProxy, self).__init__(task_details)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_repo = task_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskRepoProxy,",
            "              self).__init__(task_repo,",
            "                             task_proxy_class=TaskProxy,",
            "                             task_proxy_kwargs=proxy_kwargs,",
            "                             task_details_proxy_class=TaskDetailsProxy,",
            "                             task_details_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        self.policy.enforce(self.context, 'get_task', {})",
            "        return super(TaskRepoProxy, self).get_task_and_details(task_id)",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_tasks', {})",
            "        return super(TaskRepoProxy, self).list_tasks(*args, **kwargs)",
            "",
            "    def add(self, task, task_details=None):",
            "        self.policy.enforce(self.context, 'add_task', {})",
            "        super(TaskRepoProxy, self).add(task, task_details)",
            "",
            "    def save(self, task, task_details=None):",
            "        self.policy.enforce(self.context, 'modify_task', {})",
            "        super(TaskRepoProxy, self).save(task, task_details)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context, policy):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=proxy_kwargs,",
            "            task_details_proxy_class=TaskDetailsProxy,",
            "            task_details_proxy_kwargs=proxy_kwargs)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2011 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Policy Engine For Glance\"\"\"",
            "",
            "import copy",
            "import os.path",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "from glance.openstack.common import jsonutils",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import policy",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "policy_opts = [",
            "    cfg.StrOpt('policy_file', default='policy.json',",
            "               help=_('The location of the policy file.')),",
            "    cfg.StrOpt('policy_default_rule', default='default',",
            "               help=_('The default policy to use.')),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(policy_opts)",
            "",
            "",
            "DEFAULT_RULES = {",
            "    'context_is_admin': policy.RoleCheck('role', 'admin'),",
            "    'default': policy.TrueCheck(),",
            "    'manage_image_cache': policy.RoleCheck('role', 'admin'),",
            "}",
            "",
            "",
            "class Enforcer(object):",
            "    \"\"\"Responsible for loading and enforcing rules\"\"\"",
            "",
            "    def __init__(self):",
            "        self.default_rule = CONF.policy_default_rule",
            "        self.policy_path = self._find_policy_file()",
            "        self.policy_file_mtime = None",
            "        self.policy_file_contents = None",
            "        self.load_rules()",
            "",
            "    def set_rules(self, rules):",
            "        \"\"\"Create a new Rules object based on the provided dict of rules\"\"\"",
            "        rules_obj = policy.Rules(rules, self.default_rule)",
            "        policy.set_rules(rules_obj)",
            "",
            "    def add_rules(self, rules):",
            "        \"\"\"Add new rules to the Rules object\"\"\"",
            "        if policy._rules:",
            "            rules_obj = policy.Rules(rules)",
            "            policy._rules.update(rules_obj)",
            "        else:",
            "            self.set_rules(rules)",
            "",
            "    def load_rules(self):",
            "        \"\"\"Set the rules found in the json file on disk\"\"\"",
            "        if self.policy_path:",
            "            rules = self._read_policy_file()",
            "            rule_type = \"\"",
            "        else:",
            "            rules = DEFAULT_RULES",
            "            rule_type = \"default \"",
            "",
            "        text_rules = dict((k, str(v)) for k, v in rules.items())",
            "        msg = (_('Loaded %(rule_type)spolicy rules: %(text_rules)s') %",
            "               {'rule_type': rule_type, 'text_rules': text_rules})",
            "        LOG.debug(msg)",
            "",
            "        self.set_rules(rules)",
            "",
            "    @staticmethod",
            "    def _find_policy_file():",
            "        \"\"\"Locate the policy json data file\"\"\"",
            "        policy_file = CONF.find_file(CONF.policy_file)",
            "        if policy_file:",
            "            return policy_file",
            "        else:",
            "            LOG.warn(_('Unable to find policy file'))",
            "            return None",
            "",
            "    def _read_policy_file(self):",
            "        \"\"\"Read contents of the policy file",
            "",
            "        This re-caches policy data if the file has been changed.",
            "        \"\"\"",
            "        mtime = os.path.getmtime(self.policy_path)",
            "        if not self.policy_file_contents or mtime != self.policy_file_mtime:",
            "            LOG.debug(_(\"Loading policy from %s\") % self.policy_path)",
            "            with open(self.policy_path) as fap:",
            "                raw_contents = fap.read()",
            "                rules_dict = jsonutils.loads(raw_contents)",
            "                self.policy_file_contents = dict(",
            "                    (k, policy.parse_rule(v))",
            "                    for k, v in rules_dict.items())",
            "            self.policy_file_mtime = mtime",
            "        return self.policy_file_contents",
            "",
            "    def _check(self, context, rule, target, *args, **kwargs):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param rule: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        credentials = {",
            "            'roles': context.roles,",
            "            'user': context.user,",
            "            'tenant': context.tenant,",
            "        }",
            "",
            "        return policy.check(rule, target, credentials, *args, **kwargs)",
            "",
            "    def enforce(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :raises: `glance.common.exception.Forbidden`",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        return self._check(context, action, target,",
            "                           exception.Forbidden, action=action)",
            "",
            "    def check(self, context, action, target):",
            "        \"\"\"Verifies that the action is valid on the target in this context.",
            "",
            "           :param context: Glance request context",
            "           :param action: String representing the action to be checked",
            "           :param object: Dictionary representing the object of the action.",
            "           :returns: A non-False value if access is allowed.",
            "        \"\"\"",
            "        return self._check(context, action, target)",
            "",
            "    def check_is_admin(self, context):",
            "        \"\"\"Check if the given context is associated with an admin role,",
            "           as defined via the 'context_is_admin' RBAC rule.",
            "",
            "           :param context: Glance request context",
            "           :returns: A non-False value if context role is admin.",
            "        \"\"\"",
            "        target = context.to_dict()",
            "        return self.check(context, 'context_is_admin', target)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, policy):",
            "        self.context = context",
            "        self.policy = policy",
            "        self.image_repo = image_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get(self, image_id):",
            "        self.policy.enforce(self.context, 'get_image', {})",
            "        return super(ImageRepoProxy, self).get(image_id)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_images', {})",
            "        return super(ImageRepoProxy, self).list(*args, **kwargs)",
            "",
            "    def save(self, image, from_state=None):",
            "        self.policy.enforce(self.context, 'modify_image', {})",
            "        return super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "",
            "    def add(self, image):",
            "        self.policy.enforce(self.context, 'add_image', {})",
            "        return super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, policy):",
            "        self.image = image",
            "        self.context = context",
            "        self.policy = policy",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    @property",
            "    def visibility(self):",
            "        return self.image.visibility",
            "",
            "    @visibility.setter",
            "    def visibility(self, value):",
            "        if value == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        self.image.visibility = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return ImageLocationsProxy(self.image.locations,",
            "                                   self.context, self.policy)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        if not isinstance(value, (list, ImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "        self.policy.enforce(self.context, 'set_image_location', {})",
            "        new_locations = list(value)",
            "        if (set([loc['url'] for loc in self.image.locations]) -",
            "                set([loc['url'] for loc in new_locations])):",
            "            self.policy.enforce(self.context, 'delete_image_location', {})",
            "        self.image.locations = new_locations",
            "",
            "    def delete(self):",
            "        self.policy.enforce(self.context, 'delete_image', {})",
            "        return self.image.delete()",
            "",
            "    def get_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'download_image', {})",
            "        return self.image.get_data(*args, **kwargs)",
            "",
            "    def set_data(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'upload_image', {})",
            "        return self.image.set_data(*args, **kwargs)",
            "",
            "    def get_member_repo(self, **kwargs):",
            "        member_repo = self.image.get_member_repo(**kwargs)",
            "        return ImageMemberRepoProxy(member_repo, self.context, self.policy)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "",
            "    def __init__(self, image_factory, context, policy):",
            "        self.image_factory = image_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(ImageFactoryProxy, self).__init__(image_factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        if kwargs.get('visibility') == 'public':",
            "            self.policy.enforce(self.context, 'publicize_image', {})",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, policy):",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={'context': context, 'policy': policy})",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, member_repo, context, policy):",
            "        self.member_repo = member_repo",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def add(self, member):",
            "        self.policy.enforce(self.context, 'add_member', {})",
            "        self.member_repo.add(member)",
            "",
            "    def get(self, member_id):",
            "        self.policy.enforce(self.context, 'get_member', {})",
            "        return self.member_repo.get(member_id)",
            "",
            "    def save(self, member, from_state=None):",
            "        self.policy.enforce(self.context, 'modify_member', {})",
            "        self.member_repo.save(member, from_state=from_state)",
            "",
            "    def list(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_members', {})",
            "        return self.member_repo.list(*args, **kwargs)",
            "",
            "    def remove(self, member):",
            "        self.policy.enforce(self.context, 'delete_member', {})",
            "        self.member_repo.remove(member)",
            "",
            "",
            "class ImageLocationsProxy(object):",
            "",
            "    __hash__ = None",
            "",
            "    def __init__(self, locations, context, policy):",
            "        self.locations = locations",
            "        self.context = context",
            "        self.policy = policy",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.locations, self.context, self.policy)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        return type(self)(copy.deepcopy(self.locations, memo),",
            "                          self.context, self.policy)",
            "",
            "    def _get_checker(action, func_name):",
            "        def _checker(self, *args, **kwargs):",
            "            self.policy.enforce(self.context, action, {})",
            "            assert hasattr(self.locations, func_name)",
            "            method = getattr(self.locations, func_name)",
            "            return method(*args, **kwargs)",
            "        return _checker",
            "",
            "    count = _get_checker('get_image_location', 'count')",
            "    index = _get_checker('get_image_location', 'index')",
            "    __getitem__ = _get_checker('get_image_location', '__getitem__')",
            "    __contains__ = _get_checker('get_image_location', '__contains__')",
            "    __len__ = _get_checker('get_image_location', '__len__')",
            "    __cast = _get_checker('get_image_location', '__cast')",
            "    __cmp__ = _get_checker('get_image_location', '__cmp__')",
            "    __iter__ = _get_checker('get_image_location', '__iter__')",
            "",
            "    append = _get_checker('set_image_location', 'append')",
            "    extend = _get_checker('set_image_location', 'extend')",
            "    insert = _get_checker('set_image_location', 'insert')",
            "    reverse = _get_checker('set_image_location', 'reverse')",
            "    __iadd__ = _get_checker('set_image_location', '__iadd__')",
            "    __setitem__ = _get_checker('set_image_location', '__setitem__')",
            "",
            "    pop = _get_checker('delete_image_location', 'pop')",
            "    remove = _get_checker('delete_image_location', 'remove')",
            "    __delitem__ = _get_checker('delete_image_location', '__delitem__')",
            "    __delslice__ = _get_checker('delete_image_location', '__delslice__')",
            "",
            "    del _get_checker",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, policy):",
            "        self.task = task",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details, context, policy):",
            "        self.task_details = task_details",
            "        self.context = context",
            "        self.policy = policy",
            "        super(TaskDetailsProxy, self).__init__(task_details)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, task_policy):",
            "        self.context = context",
            "        self.policy = task_policy",
            "        self.task_repo = task_repo",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskRepoProxy,",
            "              self).__init__(task_repo,",
            "                             task_proxy_class=TaskProxy,",
            "                             task_proxy_kwargs=proxy_kwargs,",
            "                             task_details_proxy_class=TaskDetailsProxy,",
            "                             task_details_proxy_kwargs=proxy_kwargs)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        self.policy.enforce(self.context, 'get_task', {})",
            "        return super(TaskRepoProxy, self).get_task_and_details(task_id)",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        self.policy.enforce(self.context, 'get_tasks', {})",
            "        return super(TaskRepoProxy, self).list_tasks(*args, **kwargs)",
            "",
            "    def add(self, task, task_details=None):",
            "        self.policy.enforce(self.context, 'add_task', {})",
            "        super(TaskRepoProxy, self).add(task, task_details)",
            "",
            "    def save(self, task, task_details=None):",
            "        self.policy.enforce(self.context, 'modify_task', {})",
            "        super(TaskRepoProxy, self).save(task, task_details)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "",
            "    def __init__(self, task_factory, context, policy):",
            "        self.task_factory = task_factory",
            "        self.context = context",
            "        self.policy = policy",
            "        proxy_kwargs = {'context': self.context, 'policy': self.policy}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=proxy_kwargs,",
            "            task_details_proxy_class=TaskDetailsProxy,",
            "            task_details_proxy_kwargs=proxy_kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "185": [
                "ImageRepoProxy",
                "save"
            ],
            "187": [
                "ImageRepoProxy",
                "save"
            ],
            "286": [
                "ImageMemberRepoProxy",
                "save"
            ],
            "288": [
                "ImageMemberRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/api/v1/upload_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         update_data = {'checksum': checksum,"
            },
            "1": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "                        'size': size}"
            },
            "2": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         try:"
            },
            "3": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            image_meta = registry.update_image_metadata(req.context,"
            },
            "4": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        image_id,"
            },
            "5": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        update_data,"
            },
            "6": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                        from_state='saving')"
            },
            "7": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "8": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except exception.NotFound as e:"
            },
            "9": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = _(\"Image %s could not be found after upload. The image may \""
            },
            "10": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"have been deleted during the upload.\") % image_id"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            try:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                state = 'saving'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                image_meta = registry.update_image_metadata(req.context,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                                                            image_id,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                                                            update_data,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                                                            from_state=state)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            except exception.Duplicate:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                image = registry.get_image_metadata(req.context, image_id)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                if image['status'] == 'deleted':"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                    raise exception.NotFound()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                else:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                    raise"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        except exception.NotFound:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            msg = _(\"Image %s could not be found after upload. The image may\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                    \" have been deleted during the upload.\") % image_id"
            },
            "26": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             LOG.info(msg)"
            },
            "27": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             # NOTE(jculp): we need to clean up the datastore if an image"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "import webob.exc",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.db",
            "from glance.openstack.common import excutils",
            "import glance.openstack.common.log as logging",
            "import glance.registry.client.v1.api as registry",
            "import glance.store",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def initiate_deletion(req, location, id, delayed_delete=False):",
            "    \"\"\"",
            "    Deletes image data from the backend store.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param location: URL to the image data in a data store",
            "    :param image_id: Opaque image identifier",
            "    :param delayed_delete: whether data deletion will be delayed",
            "    \"\"\"",
            "    if delayed_delete:",
            "        glance.store.schedule_delayed_delete_from_backend(req.context,",
            "                                                          location, id)",
            "    else:",
            "        glance.store.safe_delete_from_backend(req.context, location, id)",
            "",
            "",
            "def _kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Marks the image status to `killed`.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    # TODO(dosaboy): http://docs.openstack.org/developer/glance/statuses.html",
            "    # needs updating to reflect the fact that queued->killed and saving->killed",
            "    # are both allowed.",
            "    registry.update_image_metadata(req.context, image_id,",
            "                                   {'status': 'killed'},",
            "                                   from_state=from_state)",
            "",
            "",
            "def safe_kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Mark image killed without raising exceptions if it fails.",
            "",
            "    Since _kill is meant to be called from exceptions handlers, it should",
            "    not raise itself, rather it should just log its error.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    try:",
            "        _kill(req, image_id, from_state)",
            "    except Exception:",
            "        LOG.exception(_(\"Unable to kill image %(id)s: \") % {'id': image_id})",
            "",
            "",
            "def upload_data_to_store(req, image_meta, image_data, store, notifier):",
            "    \"\"\"",
            "    Upload image data to specified store.",
            "",
            "    Upload image data to the store and cleans up on error.",
            "    \"\"\"",
            "    image_id = image_meta['id']",
            "",
            "    db_api = glance.db.get_api()",
            "    image_size = image_meta.get('size')",
            "",
            "    try:",
            "        remaining = glance.api.common.check_quota(",
            "            req.context, image_size, db_api, image_id=image_id)",
            "        if remaining is not None:",
            "            image_data = utils.LimitingReader(image_data, remaining)",
            "",
            "        (location,",
            "         size,",
            "         checksum,",
            "         locations_metadata) = glance.store.store_add_to_backend(",
            "             image_meta['id'],",
            "             utils.CooperativeReader(image_data),",
            "             image_meta['size'],",
            "             store)",
            "",
            "        try:",
            "            # recheck the quota in case there were simultaneous uploads that",
            "            # did not provide the size",
            "            glance.api.common.check_quota(",
            "                req.context, size, db_api, image_id=image_id)",
            "        except exception.StorageQuotaFull:",
            "            LOG.info(_('Cleaning up %s after exceeding the quota') % image_id)",
            "            glance.store.safe_delete_from_backend(",
            "                location, req.context, image_meta['id'])",
            "            raise",
            "",
            "        def _kill_mismatched(image_meta, attr, actual):",
            "            supplied = image_meta.get(attr)",
            "            if supplied and supplied != actual:",
            "                msg = (_(\"Supplied %(attr)s (%(supplied)s) and \"",
            "                         \"%(attr)s generated from uploaded image \"",
            "                         \"(%(actual)s) did not match. Setting image \"",
            "                         \"status to 'killed'.\") % {'attr': attr,",
            "                                                   'supplied': supplied,",
            "                                                   'actual': actual})",
            "                LOG.error(msg)",
            "                safe_kill(req, image_id, 'saving')",
            "                initiate_deletion(req, location, image_id, CONF.delayed_delete)",
            "                raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                               content_type=\"text/plain\",",
            "                                               request=req)",
            "",
            "        # Verify any supplied size/checksum value matches size/checksum",
            "        # returned from store when adding image",
            "        _kill_mismatched(image_meta, 'size', size)",
            "        _kill_mismatched(image_meta, 'checksum', checksum)",
            "",
            "        # Update the database with the checksum returned",
            "        # from the backend store",
            "        LOG.debug(_(\"Updating image %(image_id)s data. \"",
            "                  \"Checksum set to %(checksum)s, size set \"",
            "                  \"to %(size)d\"), {'image_id': image_id,",
            "                                   'checksum': checksum,",
            "                                   'size': size})",
            "        update_data = {'checksum': checksum,",
            "                       'size': size}",
            "        try:",
            "            image_meta = registry.update_image_metadata(req.context,",
            "                                                        image_id,",
            "                                                        update_data,",
            "                                                        from_state='saving')",
            "",
            "        except exception.NotFound as e:",
            "            msg = _(\"Image %s could not be found after upload. The image may \"",
            "                    \"have been deleted during the upload.\") % image_id",
            "            LOG.info(msg)",
            "",
            "            # NOTE(jculp): we need to clean up the datastore if an image",
            "            # resource is deleted while the image data is being uploaded",
            "            #",
            "            # We get \"location\" from above call to store.add(), any",
            "            # exceptions that occur there handle this same issue internally,",
            "            # Since this is store-agnostic, should apply to all stores.",
            "            initiate_deletion(req, location, image_id, CONF.delayed_delete)",
            "            raise webob.exc.HTTPPreconditionFailed(explanation=msg,",
            "                                                   request=req,",
            "                                                   content_type='text/plain')",
            "",
            "    except exception.Duplicate as e:",
            "        msg = u\"Attempt to upload duplicate image: %s\" % e",
            "        LOG.debug(msg)",
            "        # NOTE(dosaboy): do not delete the image since it is likely that this",
            "        # conflict is a result of another concurrent upload that will be",
            "        # successful.",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPConflict(explanation=msg,",
            "                                     request=req,",
            "                                     content_type=\"text/plain\")",
            "",
            "    except exception.Forbidden as e:",
            "        msg = u\"Forbidden upload attempt: %s\" % e",
            "        LOG.debug(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPForbidden(explanation=msg,",
            "                                      request=req,",
            "                                      content_type=\"text/plain\")",
            "",
            "    except exception.StorageFull as e:",
            "        msg = _(\"Image storage media is full: %s\") % e",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageWriteDenied as e:",
            "        msg = _(\"Insufficient permissions on image storage media: %s\") % e",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                               request=req,",
            "                                               content_type='text/plain')",
            "",
            "    except exception.ImageSizeLimitExceeded as e:",
            "        msg = (_(\"Denying attempt to upload image larger than %d bytes.\")",
            "               % CONF.image_size_cap)",
            "        LOG.info(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageQuotaFull as e:",
            "        msg = (_(\"Denying attempt to upload image because it exceeds the .\"",
            "                 \"quota: %s\") % e)",
            "        LOG.info(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except webob.exc.HTTPError:",
            "        #NOTE(bcwaldon): Ideally, we would just call 'raise' here,",
            "        # but something in the above function calls is affecting the",
            "        # exception context and we must explicitly re-raise the",
            "        # caught exception.",
            "        msg = _(\"Received HTTP error while uploading image %s\") % image_id",
            "        notifier.error('image.upload', msg)",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.exception(msg)",
            "            safe_kill(req, image_id, 'saving')",
            "",
            "    except (ValueError, IOError) as e:",
            "        msg = _(\"Client disconnected before sending all data to backend\")",
            "        LOG.debug(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                       content_type=\"text/plain\",",
            "                                       request=req)",
            "",
            "    except Exception as e:",
            "        msg = _(\"Failed to upload image %s\") % image_id",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPInternalServerError(explanation=msg,",
            "                                                request=req,",
            "                                                content_type='text/plain')",
            "",
            "    return image_meta, location, locations_metadata"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "import webob.exc",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.db",
            "from glance.openstack.common import excutils",
            "import glance.openstack.common.log as logging",
            "import glance.registry.client.v1.api as registry",
            "import glance.store",
            "",
            "",
            "CONF = cfg.CONF",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def initiate_deletion(req, location, id, delayed_delete=False):",
            "    \"\"\"",
            "    Deletes image data from the backend store.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param location: URL to the image data in a data store",
            "    :param image_id: Opaque image identifier",
            "    :param delayed_delete: whether data deletion will be delayed",
            "    \"\"\"",
            "    if delayed_delete:",
            "        glance.store.schedule_delayed_delete_from_backend(req.context,",
            "                                                          location, id)",
            "    else:",
            "        glance.store.safe_delete_from_backend(req.context, location, id)",
            "",
            "",
            "def _kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Marks the image status to `killed`.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    # TODO(dosaboy): http://docs.openstack.org/developer/glance/statuses.html",
            "    # needs updating to reflect the fact that queued->killed and saving->killed",
            "    # are both allowed.",
            "    registry.update_image_metadata(req.context, image_id,",
            "                                   {'status': 'killed'},",
            "                                   from_state=from_state)",
            "",
            "",
            "def safe_kill(req, image_id, from_state):",
            "    \"\"\"",
            "    Mark image killed without raising exceptions if it fails.",
            "",
            "    Since _kill is meant to be called from exceptions handlers, it should",
            "    not raise itself, rather it should just log its error.",
            "",
            "    :param req: The WSGI/Webob Request object",
            "    :param image_id: Opaque image identifier",
            "    :param from_state: Permitted current status for transition to 'killed'",
            "    \"\"\"",
            "    try:",
            "        _kill(req, image_id, from_state)",
            "    except Exception:",
            "        LOG.exception(_(\"Unable to kill image %(id)s: \") % {'id': image_id})",
            "",
            "",
            "def upload_data_to_store(req, image_meta, image_data, store, notifier):",
            "    \"\"\"",
            "    Upload image data to specified store.",
            "",
            "    Upload image data to the store and cleans up on error.",
            "    \"\"\"",
            "    image_id = image_meta['id']",
            "",
            "    db_api = glance.db.get_api()",
            "    image_size = image_meta.get('size')",
            "",
            "    try:",
            "        remaining = glance.api.common.check_quota(",
            "            req.context, image_size, db_api, image_id=image_id)",
            "        if remaining is not None:",
            "            image_data = utils.LimitingReader(image_data, remaining)",
            "",
            "        (location,",
            "         size,",
            "         checksum,",
            "         locations_metadata) = glance.store.store_add_to_backend(",
            "             image_meta['id'],",
            "             utils.CooperativeReader(image_data),",
            "             image_meta['size'],",
            "             store)",
            "",
            "        try:",
            "            # recheck the quota in case there were simultaneous uploads that",
            "            # did not provide the size",
            "            glance.api.common.check_quota(",
            "                req.context, size, db_api, image_id=image_id)",
            "        except exception.StorageQuotaFull:",
            "            LOG.info(_('Cleaning up %s after exceeding the quota') % image_id)",
            "            glance.store.safe_delete_from_backend(",
            "                location, req.context, image_meta['id'])",
            "            raise",
            "",
            "        def _kill_mismatched(image_meta, attr, actual):",
            "            supplied = image_meta.get(attr)",
            "            if supplied and supplied != actual:",
            "                msg = (_(\"Supplied %(attr)s (%(supplied)s) and \"",
            "                         \"%(attr)s generated from uploaded image \"",
            "                         \"(%(actual)s) did not match. Setting image \"",
            "                         \"status to 'killed'.\") % {'attr': attr,",
            "                                                   'supplied': supplied,",
            "                                                   'actual': actual})",
            "                LOG.error(msg)",
            "                safe_kill(req, image_id, 'saving')",
            "                initiate_deletion(req, location, image_id, CONF.delayed_delete)",
            "                raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                               content_type=\"text/plain\",",
            "                                               request=req)",
            "",
            "        # Verify any supplied size/checksum value matches size/checksum",
            "        # returned from store when adding image",
            "        _kill_mismatched(image_meta, 'size', size)",
            "        _kill_mismatched(image_meta, 'checksum', checksum)",
            "",
            "        # Update the database with the checksum returned",
            "        # from the backend store",
            "        LOG.debug(_(\"Updating image %(image_id)s data. \"",
            "                  \"Checksum set to %(checksum)s, size set \"",
            "                  \"to %(size)d\"), {'image_id': image_id,",
            "                                   'checksum': checksum,",
            "                                   'size': size})",
            "        update_data = {'checksum': checksum,",
            "                       'size': size}",
            "        try:",
            "            try:",
            "                state = 'saving'",
            "                image_meta = registry.update_image_metadata(req.context,",
            "                                                            image_id,",
            "                                                            update_data,",
            "                                                            from_state=state)",
            "            except exception.Duplicate:",
            "                image = registry.get_image_metadata(req.context, image_id)",
            "                if image['status'] == 'deleted':",
            "                    raise exception.NotFound()",
            "                else:",
            "                    raise",
            "        except exception.NotFound:",
            "            msg = _(\"Image %s could not be found after upload. The image may\"",
            "                    \" have been deleted during the upload.\") % image_id",
            "            LOG.info(msg)",
            "",
            "            # NOTE(jculp): we need to clean up the datastore if an image",
            "            # resource is deleted while the image data is being uploaded",
            "            #",
            "            # We get \"location\" from above call to store.add(), any",
            "            # exceptions that occur there handle this same issue internally,",
            "            # Since this is store-agnostic, should apply to all stores.",
            "            initiate_deletion(req, location, image_id, CONF.delayed_delete)",
            "            raise webob.exc.HTTPPreconditionFailed(explanation=msg,",
            "                                                   request=req,",
            "                                                   content_type='text/plain')",
            "",
            "    except exception.Duplicate as e:",
            "        msg = u\"Attempt to upload duplicate image: %s\" % e",
            "        LOG.debug(msg)",
            "        # NOTE(dosaboy): do not delete the image since it is likely that this",
            "        # conflict is a result of another concurrent upload that will be",
            "        # successful.",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPConflict(explanation=msg,",
            "                                     request=req,",
            "                                     content_type=\"text/plain\")",
            "",
            "    except exception.Forbidden as e:",
            "        msg = u\"Forbidden upload attempt: %s\" % e",
            "        LOG.debug(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPForbidden(explanation=msg,",
            "                                      request=req,",
            "                                      content_type=\"text/plain\")",
            "",
            "    except exception.StorageFull as e:",
            "        msg = _(\"Image storage media is full: %s\") % e",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageWriteDenied as e:",
            "        msg = _(\"Insufficient permissions on image storage media: %s\") % e",
            "        LOG.error(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                               request=req,",
            "                                               content_type='text/plain')",
            "",
            "    except exception.ImageSizeLimitExceeded as e:",
            "        msg = (_(\"Denying attempt to upload image larger than %d bytes.\")",
            "               % CONF.image_size_cap)",
            "        LOG.info(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except exception.StorageQuotaFull as e:",
            "        msg = (_(\"Denying attempt to upload image because it exceeds the .\"",
            "                 \"quota: %s\") % e)",
            "        LOG.info(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                  request=req,",
            "                                                  content_type='text/plain')",
            "",
            "    except webob.exc.HTTPError:",
            "        #NOTE(bcwaldon): Ideally, we would just call 'raise' here,",
            "        # but something in the above function calls is affecting the",
            "        # exception context and we must explicitly re-raise the",
            "        # caught exception.",
            "        msg = _(\"Received HTTP error while uploading image %s\") % image_id",
            "        notifier.error('image.upload', msg)",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.exception(msg)",
            "            safe_kill(req, image_id, 'saving')",
            "",
            "    except (ValueError, IOError) as e:",
            "        msg = _(\"Client disconnected before sending all data to backend\")",
            "        LOG.debug(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        raise webob.exc.HTTPBadRequest(explanation=msg,",
            "                                       content_type=\"text/plain\",",
            "                                       request=req)",
            "",
            "    except Exception as e:",
            "        msg = _(\"Failed to upload image %s\") % image_id",
            "        LOG.exception(msg)",
            "        safe_kill(req, image_id, 'saving')",
            "        notifier.error('image.upload', msg)",
            "        raise webob.exc.HTTPInternalServerError(explanation=msg,",
            "                                                request=req,",
            "                                                content_type='text/plain')",
            "",
            "    return image_meta, location, locations_metadata"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "149": [
                "upload_data_to_store"
            ],
            "150": [
                "upload_data_to_store"
            ],
            "151": [
                "upload_data_to_store"
            ],
            "152": [
                "upload_data_to_store"
            ],
            "153": [
                "upload_data_to_store"
            ],
            "154": [
                "upload_data_to_store"
            ],
            "155": [
                "upload_data_to_store"
            ],
            "156": [
                "upload_data_to_store"
            ]
        },
        "addLocation": []
    },
    "glance/api/v2/image_data.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import glance.db"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import glance.gateway"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import glance.notifier"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from glance.openstack.common import excutils"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import glance.openstack.common.log as logging"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " import glance.store"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             try:"
            },
            "8": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "                 image_repo.save(image)"
            },
            "9": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                 image.set_data(data, size)"
            },
            "10": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                image_repo.save(image)"
            },
            "11": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except exception.NotFound as e:"
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = (_(\"Image %(id)s could not be found after upload.\""
            },
            "13": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         \"The image may have been deleted during the upload: \""
            },
            "14": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         \"%(error)s Cleaning up the chunks uploaded\") %"
            },
            "15": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       {'id': image_id,"
            },
            "16": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'error': e})"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                image_repo.save(image, from_state='saving')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            except (exception.NotFound, exception.Conflict):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                msg = (_(\"Image %s could not be found after upload. \""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                         \"The image may have been deleted during the \""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                         \"upload, cleaning up the chunks uploaded.\") %"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                       image_id)"
            },
            "23": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "                 LOG.warn(msg)"
            },
            "24": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "                 # NOTE(sridevi): Cleaning up the uploaded chunks."
            },
            "25": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "                 try:"
            },
            "26": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             raise webob.exc.HTTPServiceUnavailable(explanation=msg,"
            },
            "27": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                                                    request=req)"
            },
            "28": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        except webob.exc.HTTPGone as e:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+            with excutils.save_and_reraise_exception():"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                LOG.error(_(\"Failed to upload image data due to HTTP error\"))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         except webob.exc.HTTPError as e:"
            },
            "34": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "             LOG.error(_(\"Failed to upload image data due to HTTP error\"))"
            },
            "35": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "             self._restore(image_repo, image)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import webob.exc",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "from glance.common import utils",
            "from glance.common import wsgi",
            "import glance.db",
            "import glance.gateway",
            "import glance.notifier",
            "import glance.openstack.common.log as logging",
            "import glance.store",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class ImageDataController(object):",
            "    def __init__(self, db_api=None, store_api=None,",
            "                 policy_enforcer=None, notifier=None,",
            "                 gateway=None):",
            "        if gateway is None:",
            "            db_api = db_api or glance.db.get_api()",
            "            store_api = store_api or glance.store",
            "            policy = policy_enforcer or glance.api.policy.Enforcer()",
            "            notifier = notifier or glance.notifier.Notifier()",
            "            gateway = glance.gateway.Gateway(db_api, store_api,",
            "                                             notifier, policy)",
            "        self.gateway = gateway",
            "",
            "    def _restore(self, image_repo, image):",
            "        \"\"\"",
            "        Restore the image to queued status.",
            "",
            "        :param image_repo: The instance of ImageRepo",
            "        :param image: The image will be restored",
            "        \"\"\"",
            "        try:",
            "            if image_repo and image:",
            "                image.status = 'queued'",
            "                image_repo.save(image)",
            "        except Exception as e:",
            "            msg = _(\"Unable to restore image %(image_id)s: %(e)s\") % \\",
            "                {'image_id': image.image_id, 'e': unicode(e)}",
            "            LOG.exception(msg)",
            "",
            "    @utils.mutating",
            "    def upload(self, req, image_id, data, size):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            image.status = 'saving'",
            "            try:",
            "                image_repo.save(image)",
            "                image.set_data(data, size)",
            "                image_repo.save(image)",
            "            except exception.NotFound as e:",
            "                msg = (_(\"Image %(id)s could not be found after upload.\"",
            "                         \"The image may have been deleted during the upload: \"",
            "                         \"%(error)s Cleaning up the chunks uploaded\") %",
            "                       {'id': image_id,",
            "                        'error': e})",
            "                LOG.warn(msg)",
            "                # NOTE(sridevi): Cleaning up the uploaded chunks.",
            "                try:",
            "                    image.delete()",
            "                except exception.NotFound:",
            "                    # NOTE(sridevi): Ignore this exception",
            "                    pass",
            "                raise webob.exc.HTTPGone(explanation=msg,",
            "                                         request=req,",
            "                                         content_type='text/plain')",
            "",
            "        except ValueError as e:",
            "            LOG.debug(\"Cannot save data for image %s: %s\", image_id, e)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPBadRequest(explanation=unicode(e))",
            "",
            "        except exception.InvalidImageStatusTransition as e:",
            "            msg = unicode(e)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)",
            "",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %s\") %",
            "                   image_id)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg, request=req)",
            "",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "",
            "        except exception.StorageFull as e:",
            "            msg = _(\"Image storage media is full: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageQuotaFull as e:",
            "            msg = _(\"Image exceeds the storage quota: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.ImageSizeLimitExceeded as e:",
            "            msg = _(\"The incoming image is too large: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageWriteDenied as e:",
            "            msg = _(\"Insufficient permissions on image storage media: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                                   request=req)",
            "",
            "        except webob.exc.HTTPError as e:",
            "            LOG.error(_(\"Failed to upload image data due to HTTP error\"))",
            "            self._restore(image_repo, image)",
            "            raise",
            "",
            "        except Exception as e:",
            "            LOG.exception(_(\"Failed to upload image data due to \"",
            "                            \"internal error\"))",
            "            self._restore(image_repo, image)",
            "            raise",
            "",
            "    def download(self, req, image_id):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            if not image.locations:",
            "                raise exception.ImageDataNotFound()",
            "        except exception.ImageDataNotFound as e:",
            "            raise webob.exc.HTTPNoContent(explanation=e.msg)",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "",
            "        return image",
            "",
            "",
            "class RequestDeserializer(wsgi.JSONRequestDeserializer):",
            "    def upload(self, request):",
            "        try:",
            "            request.get_content_type(('application/octet-stream',))",
            "        except exception.InvalidContentType as e:",
            "            raise webob.exc.HTTPUnsupportedMediaType(explanation=e.msg)",
            "",
            "        image_size = request.content_length or None",
            "        return {'size': image_size, 'data': request.body_file}",
            "",
            "",
            "class ResponseSerializer(wsgi.JSONResponseSerializer):",
            "    def download(self, response, image):",
            "        response.headers['Content-Type'] = 'application/octet-stream'",
            "        try:",
            "            # NOTE(markwash): filesystem store (and maybe others?) cause a",
            "            # problem with the caching middleware if they are not wrapped in",
            "            # an iterator very strange",
            "            response.app_iter = iter(image.get_data())",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "        #NOTE(saschpe): \"response.app_iter = ...\" currently resets Content-MD5",
            "        # (https://github.com/Pylons/webob/issues/86), so it should be set",
            "        # afterwards for the time being.",
            "        if image.checksum:",
            "            response.headers['Content-MD5'] = image.checksum",
            "        #NOTE(markwash): \"response.app_iter = ...\" also erroneously resets the",
            "        # content-length",
            "        response.headers['Content-Length'] = str(image.size)",
            "",
            "    def upload(self, response, result):",
            "        response.status_int = 204",
            "",
            "",
            "def create_resource():",
            "    \"\"\"Image data resource factory method\"\"\"",
            "    deserializer = RequestDeserializer()",
            "    serializer = ResponseSerializer()",
            "    controller = ImageDataController()",
            "    return wsgi.Resource(controller, deserializer, serializer)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import webob.exc",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "from glance.common import utils",
            "from glance.common import wsgi",
            "import glance.db",
            "import glance.gateway",
            "import glance.notifier",
            "from glance.openstack.common import excutils",
            "import glance.openstack.common.log as logging",
            "import glance.store",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class ImageDataController(object):",
            "    def __init__(self, db_api=None, store_api=None,",
            "                 policy_enforcer=None, notifier=None,",
            "                 gateway=None):",
            "        if gateway is None:",
            "            db_api = db_api or glance.db.get_api()",
            "            store_api = store_api or glance.store",
            "            policy = policy_enforcer or glance.api.policy.Enforcer()",
            "            notifier = notifier or glance.notifier.Notifier()",
            "            gateway = glance.gateway.Gateway(db_api, store_api,",
            "                                             notifier, policy)",
            "        self.gateway = gateway",
            "",
            "    def _restore(self, image_repo, image):",
            "        \"\"\"",
            "        Restore the image to queued status.",
            "",
            "        :param image_repo: The instance of ImageRepo",
            "        :param image: The image will be restored",
            "        \"\"\"",
            "        try:",
            "            if image_repo and image:",
            "                image.status = 'queued'",
            "                image_repo.save(image)",
            "        except Exception as e:",
            "            msg = _(\"Unable to restore image %(image_id)s: %(e)s\") % \\",
            "                {'image_id': image.image_id, 'e': unicode(e)}",
            "            LOG.exception(msg)",
            "",
            "    @utils.mutating",
            "    def upload(self, req, image_id, data, size):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            image.status = 'saving'",
            "            try:",
            "                image_repo.save(image)",
            "                image.set_data(data, size)",
            "                image_repo.save(image, from_state='saving')",
            "            except (exception.NotFound, exception.Conflict):",
            "                msg = (_(\"Image %s could not be found after upload. \"",
            "                         \"The image may have been deleted during the \"",
            "                         \"upload, cleaning up the chunks uploaded.\") %",
            "                       image_id)",
            "                LOG.warn(msg)",
            "                # NOTE(sridevi): Cleaning up the uploaded chunks.",
            "                try:",
            "                    image.delete()",
            "                except exception.NotFound:",
            "                    # NOTE(sridevi): Ignore this exception",
            "                    pass",
            "                raise webob.exc.HTTPGone(explanation=msg,",
            "                                         request=req,",
            "                                         content_type='text/plain')",
            "",
            "        except ValueError as e:",
            "            LOG.debug(\"Cannot save data for image %s: %s\", image_id, e)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPBadRequest(explanation=unicode(e))",
            "",
            "        except exception.InvalidImageStatusTransition as e:",
            "            msg = unicode(e)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPConflict(explanation=e.msg, request=req)",
            "",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %s\") %",
            "                   image_id)",
            "            LOG.debug(msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg, request=req)",
            "",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "",
            "        except exception.StorageFull as e:",
            "            msg = _(\"Image storage media is full: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageQuotaFull as e:",
            "            msg = _(\"Image exceeds the storage quota: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.ImageSizeLimitExceeded as e:",
            "            msg = _(\"The incoming image is too large: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg,",
            "                                                      request=req)",
            "",
            "        except exception.StorageWriteDenied as e:",
            "            msg = _(\"Insufficient permissions on image storage media: %s\") % e",
            "            LOG.error(msg)",
            "            self._restore(image_repo, image)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg,",
            "                                                   request=req)",
            "",
            "        except webob.exc.HTTPGone as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_(\"Failed to upload image data due to HTTP error\"))",
            "",
            "        except webob.exc.HTTPError as e:",
            "            LOG.error(_(\"Failed to upload image data due to HTTP error\"))",
            "            self._restore(image_repo, image)",
            "            raise",
            "",
            "        except Exception as e:",
            "            LOG.exception(_(\"Failed to upload image data due to \"",
            "                            \"internal error\"))",
            "            self._restore(image_repo, image)",
            "            raise",
            "",
            "    def download(self, req, image_id):",
            "        image_repo = self.gateway.get_repo(req.context)",
            "        try:",
            "            image = image_repo.get(image_id)",
            "            if not image.locations:",
            "                raise exception.ImageDataNotFound()",
            "        except exception.ImageDataNotFound as e:",
            "            raise webob.exc.HTTPNoContent(explanation=e.msg)",
            "        except exception.NotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.msg)",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "",
            "        return image",
            "",
            "",
            "class RequestDeserializer(wsgi.JSONRequestDeserializer):",
            "    def upload(self, request):",
            "        try:",
            "            request.get_content_type(('application/octet-stream',))",
            "        except exception.InvalidContentType as e:",
            "            raise webob.exc.HTTPUnsupportedMediaType(explanation=e.msg)",
            "",
            "        image_size = request.content_length or None",
            "        return {'size': image_size, 'data': request.body_file}",
            "",
            "",
            "class ResponseSerializer(wsgi.JSONResponseSerializer):",
            "    def download(self, response, image):",
            "        response.headers['Content-Type'] = 'application/octet-stream'",
            "        try:",
            "            # NOTE(markwash): filesystem store (and maybe others?) cause a",
            "            # problem with the caching middleware if they are not wrapped in",
            "            # an iterator very strange",
            "            response.app_iter = iter(image.get_data())",
            "        except exception.Forbidden as e:",
            "            raise webob.exc.HTTPForbidden(explanation=e.msg)",
            "        #NOTE(saschpe): \"response.app_iter = ...\" currently resets Content-MD5",
            "        # (https://github.com/Pylons/webob/issues/86), so it should be set",
            "        # afterwards for the time being.",
            "        if image.checksum:",
            "            response.headers['Content-MD5'] = image.checksum",
            "        #NOTE(markwash): \"response.app_iter = ...\" also erroneously resets the",
            "        # content-length",
            "        response.headers['Content-Length'] = str(image.size)",
            "",
            "    def upload(self, response, result):",
            "        response.status_int = 204",
            "",
            "",
            "def create_resource():",
            "    \"\"\"Image data resource factory method\"\"\"",
            "    deserializer = RequestDeserializer()",
            "    serializer = ResponseSerializer()",
            "    controller = ImageDataController()",
            "    return wsgi.Resource(controller, deserializer, serializer)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "ImageDataController",
                "upload"
            ],
            "70": [
                "ImageDataController",
                "upload"
            ],
            "71": [
                "ImageDataController",
                "upload"
            ],
            "72": [
                "ImageDataController",
                "upload"
            ],
            "73": [
                "ImageDataController",
                "upload"
            ],
            "74": [
                "ImageDataController",
                "upload"
            ],
            "75": [
                "ImageDataController",
                "upload"
            ]
        },
        "addLocation": []
    },
    "glance/db/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         image.created_at = new_values['created_at']"
            },
            "1": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         image.updated_at = new_values['updated_at']"
            },
            "2": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         image_values = self._format_image_to_db(image)"
            },
            "6": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         if image_values['size'] > CONF.image_size_cap:"
            },
            "7": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             raise exception.ImageSizeLimitExceeded"
            },
            "8": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         try:"
            },
            "9": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             new_values = self.db_api.image_update(self.context,"
            },
            "10": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                                                   image.image_id,"
            },
            "11": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                                                   image_values,"
            },
            "12": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                  purge_props=True)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                                                  purge_props=True,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                                                  from_state=from_state)"
            },
            "15": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         except (exception.NotFound, exception.Forbidden):"
            },
            "16": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "             msg = _(\"No image found with ID %s\") % image.image_id"
            },
            "17": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             raise exception.NotFound(msg)"
            },
            "18": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "             msg = _(\"The specified member %s could not be found\")"
            },
            "19": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "             raise exception.NotFound(msg % image_member.id)"
            },
            "20": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 266,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "23": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         image_member_values = self._format_image_member_to_db(image_member)"
            },
            "24": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         try:"
            },
            "25": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "             new_values = self.db_api.image_member_update(self.context,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_size_cap', 'glance.common.config')",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            tags = self.db_api.image_tag_get_all(self.context,",
            "                                                 db_api_image['id'])",
            "            image = self._format_image_from_db(dict(db_api_image), tags)",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = db_image['locations']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_decrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_encrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_details_from_db(self, db_task):",
            "        return glance.domain.TaskDetails(",
            "            task_id=db_task['id'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task, task_details=None):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': None,",
            "                'result': None,",
            "                'owner': task.owner,",
            "                'message': None,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at}",
            "",
            "        if task_details is not None:",
            "            task.update({",
            "                'input': task_details.input,",
            "                'result': task_details.result,",
            "                'message': task_details.message,",
            "            })",
            "",
            "        return task",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get_task_and_details(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return (self._format_task_from_db(db_api_task),",
            "                self._format_task_details_from_db(db_api_task))",
            "",
            "    def list_tasks(self,",
            "                   marker=None,",
            "                   limit=None,",
            "                   sort_key='created_at',",
            "                   sort_dir='desc',",
            "                   filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# Copyright 2010-2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "",
            "from glance.common import crypt",
            "from glance.common import exception",
            "from glance.common import location_strategy",
            "import glance.domain",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_size_cap', 'glance.common.config')",
            "CONF.import_opt('metadata_encryption_key', 'glance.common.config')",
            "",
            "",
            "def get_api():",
            "    api = importutils.import_module(CONF.data_api)",
            "    if hasattr(api, 'configure'):",
            "        api.configure()",
            "    return api",
            "",
            "",
            "def unwrap(db_api):",
            "    return db_api",
            "",
            "",
            "# attributes common to all models",
            "BASE_MODEL_ATTRS = set(['id', 'created_at', 'updated_at', 'deleted_at',",
            "                        'deleted'])",
            "",
            "",
            "IMAGE_ATTRS = BASE_MODEL_ATTRS | set(['name', 'status', 'size', 'virtual_size',",
            "                                      'disk_format', 'container_format',",
            "                                      'min_disk', 'min_ram', 'is_public',",
            "                                      'locations', 'checksum', 'owner',",
            "                                      'protected'])",
            "",
            "",
            "class ImageRepo(object):",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get(self, image_id):",
            "        try:",
            "            db_api_image = dict(self.db_api.image_get(self.context, image_id))",
            "            assert not db_api_image['deleted']",
            "        except (exception.NotFound, exception.Forbidden, AssertionError):",
            "            msg = _(\"No image found with ID %s\") % image_id",
            "            raise exception.NotFound(msg)",
            "        tags = self.db_api.image_tag_get_all(self.context, image_id)",
            "        image = self._format_image_from_db(db_api_image, tags)",
            "        return ImageProxy(image, self.context, self.db_api)",
            "",
            "    def list(self, marker=None, limit=None, sort_key='created_at',",
            "             sort_dir='desc', filters=None, member_status='accepted'):",
            "        db_api_images = self.db_api.image_get_all(",
            "            self.context, filters=filters, marker=marker, limit=limit,",
            "            sort_key=sort_key, sort_dir=sort_dir,",
            "            member_status=member_status)",
            "        images = []",
            "        for db_api_image in db_api_images:",
            "            tags = self.db_api.image_tag_get_all(self.context,",
            "                                                 db_api_image['id'])",
            "            image = self._format_image_from_db(dict(db_api_image), tags)",
            "            images.append(image)",
            "        return images",
            "",
            "    def _format_image_from_db(self, db_image, db_tags):",
            "        visibility = 'public' if db_image['is_public'] else 'private'",
            "        properties = {}",
            "        for prop in db_image.pop('properties'):",
            "            # NOTE(markwash) db api requires us to filter deleted",
            "            if not prop['deleted']:",
            "                properties[prop['name']] = prop['value']",
            "        locations = db_image['locations']",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_decrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return glance.domain.Image(",
            "            image_id=db_image['id'],",
            "            name=db_image['name'],",
            "            status=db_image['status'],",
            "            created_at=db_image['created_at'],",
            "            updated_at=db_image['updated_at'],",
            "            visibility=visibility,",
            "            min_disk=db_image['min_disk'],",
            "            min_ram=db_image['min_ram'],",
            "            protected=db_image['protected'],",
            "            locations=location_strategy.get_ordered_locations(locations),",
            "            checksum=db_image['checksum'],",
            "            owner=db_image['owner'],",
            "            disk_format=db_image['disk_format'],",
            "            container_format=db_image['container_format'],",
            "            size=db_image['size'],",
            "            virtual_size=db_image['virtual_size'],",
            "            extra_properties=properties,",
            "            tags=db_tags",
            "        )",
            "",
            "    def _format_image_to_db(self, image):",
            "        locations = image.locations",
            "        if CONF.metadata_encryption_key:",
            "            key = CONF.metadata_encryption_key",
            "            ld = []",
            "            for l in locations:",
            "                url = crypt.urlsafe_encrypt(key, l['url'])",
            "                ld.append({'url': url, 'metadata': l['metadata']})",
            "            locations = ld",
            "        return {",
            "            'id': image.image_id,",
            "            'name': image.name,",
            "            'status': image.status,",
            "            'created_at': image.created_at,",
            "            'min_disk': image.min_disk,",
            "            'min_ram': image.min_ram,",
            "            'protected': image.protected,",
            "            'locations': locations,",
            "            'checksum': image.checksum,",
            "            'owner': image.owner,",
            "            'disk_format': image.disk_format,",
            "            'container_format': image.container_format,",
            "            'size': image.size,",
            "            'virtual_size': image.virtual_size,",
            "            'is_public': image.visibility == 'public',",
            "            'properties': dict(image.extra_properties),",
            "        }",
            "",
            "    def add(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        # the updated_at value is not set in the _format_image_to_db",
            "        # function since it is specific to image create",
            "        image_values['updated_at'] = image.updated_at",
            "        new_values = self.db_api.image_create(self.context, image_values)",
            "        self.db_api.image_tag_set_all(self.context,",
            "                                      image.image_id, image.tags)",
            "        image.created_at = new_values['created_at']",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def save(self, image, from_state=None):",
            "        image_values = self._format_image_to_db(image)",
            "        if image_values['size'] > CONF.image_size_cap:",
            "            raise exception.ImageSizeLimitExceeded",
            "        try:",
            "            new_values = self.db_api.image_update(self.context,",
            "                                                  image.image_id,",
            "                                                  image_values,",
            "                                                  purge_props=True,",
            "                                                  from_state=from_state)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        self.db_api.image_tag_set_all(self.context, image.image_id,",
            "                                      image.tags)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "    def remove(self, image):",
            "        image_values = self._format_image_to_db(image)",
            "        try:",
            "            self.db_api.image_update(self.context, image.image_id,",
            "                                     image_values, purge_props=True)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"No image found with ID %s\") % image.image_id",
            "            raise exception.NotFound(msg)",
            "        # NOTE(markwash): don't update tags?",
            "        new_values = self.db_api.image_destroy(self.context, image.image_id)",
            "        image.updated_at = new_values['updated_at']",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def get_member_repo(self):",
            "        member_repo = ImageMemberRepo(self.context, self.db_api,",
            "                                      self.image)",
            "        return member_repo",
            "",
            "",
            "class ImageMemberRepo(object):",
            "",
            "    def __init__(self, context, db_api, image):",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.image = image",
            "",
            "    def _format_image_member_from_db(self, db_image_member):",
            "        return glance.domain.ImageMembership(",
            "            id=db_image_member['id'],",
            "            image_id=db_image_member['image_id'],",
            "            member_id=db_image_member['member'],",
            "            status=db_image_member['status'],",
            "            created_at=db_image_member['created_at'],",
            "            updated_at=db_image_member['updated_at']",
            "        )",
            "",
            "    def _format_image_member_to_db(self, image_member):",
            "        image_member = {'image_id': self.image.image_id,",
            "                        'member': image_member.member_id,",
            "                        'status': image_member.status,",
            "                        'created_at': image_member.created_at}",
            "        return image_member",
            "",
            "    def list(self):",
            "        db_members = self.db_api.image_member_find(",
            "            self.context, image_id=self.image.image_id)",
            "        image_members = []",
            "        for db_member in db_members:",
            "            image_members.append(self._format_image_member_from_db(db_member))",
            "        return image_members",
            "",
            "    def add(self, image_member):",
            "        try:",
            "            self.get(image_member.member_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('The target member %(member_id)s is already '",
            "                    'associated with image %(image_id)s.') % {",
            "                        'member_id': image_member.member_id,",
            "                        'image_id': self.image.image_id}",
            "            raise exception.Duplicate(msg)",
            "",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        new_values = self.db_api.image_member_create(self.context,",
            "                                                     image_member_values)",
            "        image_member.created_at = new_values['created_at']",
            "        image_member.updated_at = new_values['updated_at']",
            "        image_member.id = new_values['id']",
            "",
            "    def remove(self, image_member):",
            "        try:",
            "            self.db_api.image_member_delete(self.context, image_member.id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _(\"The specified member %s could not be found\")",
            "            raise exception.NotFound(msg % image_member.id)",
            "",
            "    def save(self, image_member, from_state=None):",
            "        image_member_values = self._format_image_member_to_db(image_member)",
            "        try:",
            "            new_values = self.db_api.image_member_update(self.context,",
            "                                                         image_member.id,",
            "                                                         image_member_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "        image_member.updated_at = new_values['updated_at']",
            "",
            "    def get(self, member_id):",
            "        try:",
            "            db_api_image_member = self.db_api.image_member_find(",
            "                self.context,",
            "                self.image.image_id,",
            "                member_id)",
            "            if not db_api_image_member:",
            "                raise exception.NotFound()",
            "        except (exception.NotFound, exception.Forbidden):",
            "            raise exception.NotFound()",
            "",
            "        image_member = self._format_image_member_from_db(",
            "            db_api_image_member[0])",
            "        return image_member",
            "",
            "",
            "class TaskRepo(object):",
            "",
            "    def _format_task_from_db(self, db_task):",
            "        return glance.domain.Task(",
            "            task_id=db_task['id'],",
            "            task_type=db_task['type'],",
            "            status=db_task['status'],",
            "            owner=db_task['owner'],",
            "            expires_at=db_task['expires_at'],",
            "            created_at=db_task['created_at'],",
            "            updated_at=db_task['updated_at'],",
            "        )",
            "",
            "    def _format_task_details_from_db(self, db_task):",
            "        return glance.domain.TaskDetails(",
            "            task_id=db_task['id'],",
            "            task_input=db_task['input'],",
            "            result=db_task['result'],",
            "            message=db_task['message'],",
            "        )",
            "",
            "    def _format_task_to_db(self, task, task_details=None):",
            "        task = {'id': task.task_id,",
            "                'type': task.type,",
            "                'status': task.status,",
            "                'input': None,",
            "                'result': None,",
            "                'owner': task.owner,",
            "                'message': None,",
            "                'expires_at': task.expires_at,",
            "                'created_at': task.created_at,",
            "                'updated_at': task.updated_at}",
            "",
            "        if task_details is not None:",
            "            task.update({",
            "                'input': task_details.input,",
            "                'result': task_details.result,",
            "                'message': task_details.message,",
            "            })",
            "",
            "        return task",
            "",
            "    def __init__(self, context, db_api):",
            "        self.context = context",
            "        self.db_api = db_api",
            "",
            "    def get_task_and_details(self, task_id):",
            "        try:",
            "            db_api_task = self.db_api.task_get(self.context, task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task_id",
            "            raise exception.NotFound(msg)",
            "        return (self._format_task_from_db(db_api_task),",
            "                self._format_task_details_from_db(db_api_task))",
            "",
            "    def list_tasks(self,",
            "                   marker=None,",
            "                   limit=None,",
            "                   sort_key='created_at',",
            "                   sort_dir='desc',",
            "                   filters=None):",
            "        db_api_tasks = self.db_api.task_get_all(self.context,",
            "                                                filters=filters,",
            "                                                marker=marker,",
            "                                                limit=limit,",
            "                                                sort_key=sort_key,",
            "                                                sort_dir=sort_dir)",
            "        return [self._format_task_from_db(task) for task in db_api_tasks]",
            "",
            "    def save(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        try:",
            "            updated_values = self.db_api.task_update(self.context,",
            "                                                     task.task_id,",
            "                                                     task_values)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def add(self, task, task_details=None):",
            "        task_values = self._format_task_to_db(task, task_details)",
            "        updated_values = self.db_api.task_create(self.context, task_values)",
            "        task.created_at = updated_values['created_at']",
            "        task.updated_at = updated_values['updated_at']",
            "",
            "    def remove(self, task):",
            "        task_values = self._format_task_to_db(task)",
            "        try:",
            "            self.db_api.task_update(self.context, task.task_id, task_values)",
            "            updated_values = self.db_api.task_delete(self.context,",
            "                                                     task.task_id)",
            "        except (exception.NotFound, exception.Forbidden):",
            "            msg = _('Could not find task %s') % task.task_id",
            "            raise exception.NotFound(msg)",
            "        task.updated_at = updated_values['updated_at']",
            "        task.deleted_at = updated_values['deleted_at']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "165": [
                "ImageRepo",
                "save"
            ],
            "173": [
                "ImageRepo",
                "save"
            ],
            "266": [
                "ImageMemberRepo",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/domain/proxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         result = self.base.add(base_item)"
            },
            "1": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         return self.helper.proxy(result)"
            },
            "2": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, item):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    def save(self, item, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         base_item = self.helper.unproxy(item)"
            },
            "6": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result = self.base.save(base_item)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        result = self.base.save(base_item, from_state=from_state)"
            },
            "8": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         return self.helper.proxy(result)"
            },
            "9": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def remove(self, item):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "",
            "def _proxy(target, attr):",
            "    def get_attr(self):",
            "        return getattr(getattr(self, target), attr)",
            "",
            "    def set_attr(self, value):",
            "        return setattr(getattr(self, target), attr, value)",
            "",
            "    def del_attr(self):",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class Helper(object):",
            "    def __init__(self, proxy_class=None, proxy_kwargs=None):",
            "        self.proxy_class = proxy_class",
            "        self.proxy_kwargs = proxy_kwargs or {}",
            "",
            "    def proxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return self.proxy_class(obj, **self.proxy_kwargs)",
            "",
            "    def unproxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return obj.base",
            "",
            "",
            "class TaskRepo(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None, task_proxy_kwargs=None,",
            "                 task_details_proxy_class=None,",
            "                 task_details_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_proxy_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.task_details_proxy_helper = Helper(task_details_proxy_class,",
            "                                                task_details_proxy_kwargs)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        task, task_details = self.base.get_task_and_details(task_id)",
            "        return (self.task_proxy_helper.proxy(task),",
            "                self.task_details_proxy_helper.proxy(task_details))",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        tasks = self.base.list_tasks(*args, **kwargs)",
            "        return [self.task_proxy_helper.proxy(task) for task in tasks]",
            "",
            "    def add(self, task, task_details=None):",
            "        self.base.add(self.task_proxy_helper.unproxy(task),",
            "                      self.task_details_proxy_helper.unproxy(task_details))",
            "",
            "    def save(self, task, task_details=None):",
            "        self.base.save(self.task_proxy_helper.unproxy(task),",
            "                       self.task_details_proxy_helper.unproxy(task_details))",
            "",
            "    def remove(self, task):",
            "        base_task = self.task_proxy_helper.unproxy(task)",
            "        self.base.remove(base_task)",
            "",
            "",
            "class Repo(object):",
            "    def __init__(self, base, item_proxy_class=None, item_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(item_proxy_class, item_proxy_kwargs)",
            "",
            "    def get(self, item_id):",
            "        return self.helper.proxy(self.base.get(item_id))",
            "",
            "    def list(self, *args, **kwargs):",
            "        items = self.base.list(*args, **kwargs)",
            "        return [self.helper.proxy(item) for item in items]",
            "",
            "    def add(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.add(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def save(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.save(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def remove(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "",
            "class ImageFactory(object):",
            "    def __init__(self, base, proxy_class=None, proxy_kwargs=None):",
            "        self.helper = Helper(proxy_class, proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_image(self, **kwargs):",
            "        return self.helper.proxy(self.base.new_image(**kwargs))",
            "",
            "",
            "class ImageMembershipFactory(object):",
            "    def __init__(self, base, image_proxy_class=None, image_proxy_kwargs=None,",
            "                 member_proxy_class=None, member_proxy_kwargs=None):",
            "        self.base = base",
            "        self.image_helper = Helper(image_proxy_class, image_proxy_kwargs)",
            "        self.member_helper = Helper(member_proxy_class, member_proxy_kwargs)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        base_image = self.image_helper.unproxy(image)",
            "        member = self.base.new_image_member(base_image, member_id)",
            "        return self.member_helper.proxy(member)",
            "",
            "",
            "class Image(object):",
            "    def __init__(self, base, member_repo_proxy_class=None,",
            "                 member_repo_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(member_repo_proxy_class,",
            "                             member_repo_proxy_kwargs)",
            "",
            "    name = _proxy('base', 'name')",
            "    image_id = _proxy('base', 'image_id')",
            "    name = _proxy('base', 'name')",
            "    status = _proxy('base', 'status')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    visibility = _proxy('base', 'visibility')",
            "    min_disk = _proxy('base', 'min_disk')",
            "    min_ram = _proxy('base', 'min_ram')",
            "    protected = _proxy('base', 'protected')",
            "    locations = _proxy('base', 'locations')",
            "    checksum = _proxy('base', 'checksum')",
            "    owner = _proxy('base', 'owner')",
            "    disk_format = _proxy('base', 'disk_format')",
            "    container_format = _proxy('base', 'container_format')",
            "    size = _proxy('base', 'size')",
            "    virtual_size = _proxy('base', 'virtual_size')",
            "    extra_properties = _proxy('base', 'extra_properties')",
            "    tags = _proxy('base', 'tags')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "    def set_data(self, data, size=None):",
            "        self.base.set_data(data, size)",
            "",
            "    def get_data(self):",
            "        return self.base.get_data()",
            "",
            "    def get_member_repo(self):",
            "        return self.helper.proxy(self.base.get_member_repo())",
            "",
            "",
            "class Task(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        self.base.begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.base.succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.base.fail(message)",
            "",
            "",
            "class TaskDetails(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    input = _proxy('base', 'input')",
            "    result = _proxy('base', 'result')",
            "    message = _proxy('base', 'message')",
            "",
            "",
            "class TaskFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None,",
            "                 task_proxy_kwargs=None,",
            "                 task_details_proxy_class=None,",
            "                 task_details_proxy_kwargs=None):",
            "        self.task_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.task_details_helper = Helper(task_details_proxy_class,",
            "                                          task_details_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_task(self, **kwargs):",
            "        t = self.base.new_task(**kwargs)",
            "        return self.task_helper.proxy(t)",
            "",
            "    def new_task_details(self, task_id, task_input, message=None, result=None):",
            "        td = self.base.new_task_details(task_id, task_input, message, result)",
            "        return self.task_details_helper.proxy(td)"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "",
            "def _proxy(target, attr):",
            "    def get_attr(self):",
            "        return getattr(getattr(self, target), attr)",
            "",
            "    def set_attr(self, value):",
            "        return setattr(getattr(self, target), attr, value)",
            "",
            "    def del_attr(self):",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class Helper(object):",
            "    def __init__(self, proxy_class=None, proxy_kwargs=None):",
            "        self.proxy_class = proxy_class",
            "        self.proxy_kwargs = proxy_kwargs or {}",
            "",
            "    def proxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return self.proxy_class(obj, **self.proxy_kwargs)",
            "",
            "    def unproxy(self, obj):",
            "        if obj is None or self.proxy_class is None:",
            "            return obj",
            "        return obj.base",
            "",
            "",
            "class TaskRepo(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None, task_proxy_kwargs=None,",
            "                 task_details_proxy_class=None,",
            "                 task_details_proxy_kwargs=None):",
            "        self.base = base",
            "        self.task_proxy_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.task_details_proxy_helper = Helper(task_details_proxy_class,",
            "                                                task_details_proxy_kwargs)",
            "",
            "    def get_task_and_details(self, task_id):",
            "        task, task_details = self.base.get_task_and_details(task_id)",
            "        return (self.task_proxy_helper.proxy(task),",
            "                self.task_details_proxy_helper.proxy(task_details))",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        tasks = self.base.list_tasks(*args, **kwargs)",
            "        return [self.task_proxy_helper.proxy(task) for task in tasks]",
            "",
            "    def add(self, task, task_details=None):",
            "        self.base.add(self.task_proxy_helper.unproxy(task),",
            "                      self.task_details_proxy_helper.unproxy(task_details))",
            "",
            "    def save(self, task, task_details=None):",
            "        self.base.save(self.task_proxy_helper.unproxy(task),",
            "                       self.task_details_proxy_helper.unproxy(task_details))",
            "",
            "    def remove(self, task):",
            "        base_task = self.task_proxy_helper.unproxy(task)",
            "        self.base.remove(base_task)",
            "",
            "",
            "class Repo(object):",
            "    def __init__(self, base, item_proxy_class=None, item_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(item_proxy_class, item_proxy_kwargs)",
            "",
            "    def get(self, item_id):",
            "        return self.helper.proxy(self.base.get(item_id))",
            "",
            "    def list(self, *args, **kwargs):",
            "        items = self.base.list(*args, **kwargs)",
            "        return [self.helper.proxy(item) for item in items]",
            "",
            "    def add(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.add(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "    def save(self, item, from_state=None):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.save(base_item, from_state=from_state)",
            "        return self.helper.proxy(result)",
            "",
            "    def remove(self, item):",
            "        base_item = self.helper.unproxy(item)",
            "        result = self.base.remove(base_item)",
            "        return self.helper.proxy(result)",
            "",
            "",
            "class ImageFactory(object):",
            "    def __init__(self, base, proxy_class=None, proxy_kwargs=None):",
            "        self.helper = Helper(proxy_class, proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_image(self, **kwargs):",
            "        return self.helper.proxy(self.base.new_image(**kwargs))",
            "",
            "",
            "class ImageMembershipFactory(object):",
            "    def __init__(self, base, image_proxy_class=None, image_proxy_kwargs=None,",
            "                 member_proxy_class=None, member_proxy_kwargs=None):",
            "        self.base = base",
            "        self.image_helper = Helper(image_proxy_class, image_proxy_kwargs)",
            "        self.member_helper = Helper(member_proxy_class, member_proxy_kwargs)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        base_image = self.image_helper.unproxy(image)",
            "        member = self.base.new_image_member(base_image, member_id)",
            "        return self.member_helper.proxy(member)",
            "",
            "",
            "class Image(object):",
            "    def __init__(self, base, member_repo_proxy_class=None,",
            "                 member_repo_proxy_kwargs=None):",
            "        self.base = base",
            "        self.helper = Helper(member_repo_proxy_class,",
            "                             member_repo_proxy_kwargs)",
            "",
            "    name = _proxy('base', 'name')",
            "    image_id = _proxy('base', 'image_id')",
            "    name = _proxy('base', 'name')",
            "    status = _proxy('base', 'status')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "    visibility = _proxy('base', 'visibility')",
            "    min_disk = _proxy('base', 'min_disk')",
            "    min_ram = _proxy('base', 'min_ram')",
            "    protected = _proxy('base', 'protected')",
            "    locations = _proxy('base', 'locations')",
            "    checksum = _proxy('base', 'checksum')",
            "    owner = _proxy('base', 'owner')",
            "    disk_format = _proxy('base', 'disk_format')",
            "    container_format = _proxy('base', 'container_format')",
            "    size = _proxy('base', 'size')",
            "    virtual_size = _proxy('base', 'virtual_size')",
            "    extra_properties = _proxy('base', 'extra_properties')",
            "    tags = _proxy('base', 'tags')",
            "",
            "    def delete(self):",
            "        self.base.delete()",
            "",
            "    def set_data(self, data, size=None):",
            "        self.base.set_data(data, size)",
            "",
            "    def get_data(self):",
            "        return self.base.get_data()",
            "",
            "    def get_member_repo(self):",
            "        return self.helper.proxy(self.base.get_member_repo())",
            "",
            "",
            "class Task(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    type = _proxy('base', 'type')",
            "    status = _proxy('base', 'status')",
            "    owner = _proxy('base', 'owner')",
            "    expires_at = _proxy('base', 'expires_at')",
            "    created_at = _proxy('base', 'created_at')",
            "    updated_at = _proxy('base', 'updated_at')",
            "",
            "    def run(self, executor):",
            "        self.base.run(executor)",
            "",
            "    def begin_processing(self):",
            "        self.base.begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.base.succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.base.fail(message)",
            "",
            "",
            "class TaskDetails(object):",
            "    def __init__(self, base):",
            "        self.base = base",
            "",
            "    task_id = _proxy('base', 'task_id')",
            "    input = _proxy('base', 'input')",
            "    result = _proxy('base', 'result')",
            "    message = _proxy('base', 'message')",
            "",
            "",
            "class TaskFactory(object):",
            "    def __init__(self,",
            "                 base,",
            "                 task_proxy_class=None,",
            "                 task_proxy_kwargs=None,",
            "                 task_details_proxy_class=None,",
            "                 task_details_proxy_kwargs=None):",
            "        self.task_helper = Helper(task_proxy_class, task_proxy_kwargs)",
            "        self.task_details_helper = Helper(task_details_proxy_class,",
            "                                          task_details_proxy_kwargs)",
            "        self.base = base",
            "",
            "    def new_task(self, **kwargs):",
            "        t = self.base.new_task(**kwargs)",
            "        return self.task_helper.proxy(t)",
            "",
            "    def new_task_details(self, task_id, task_input, message=None, result=None):",
            "        td = self.base.new_task_details(task_id, task_input, message, result)",
            "        return self.task_details_helper.proxy(td)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "97": [
                "Repo",
                "save"
            ],
            "99": [
                "Repo",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/notifier.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                                              item_proxy_class=ImageProxy,"
            },
            "1": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "                                              item_proxy_kwargs=proxy_kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super(ImageRepoProxy, self).save(image)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "7": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         self.notifier.info('image.update',"
            },
            "8": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                            format_image_notification(image))"
            },
            "9": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2011, OpenStack Foundation",
            "# Copyright 2012, Red Hat, Inc.",
            "# Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "from oslo import messaging",
            "import webob",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import timeutils",
            "",
            "notifier_opts = [",
            "    cfg.StrOpt('notifier_strategy', default='default',",
            "               help=_('Notifications can be sent when images are create, '",
            "                      'updated or deleted. There are three methods of sending '",
            "                      'notifications, logging (via the log_file directive), '",
            "                      'rabbit (via a rabbitmq queue), qpid (via a Qpid '",
            "                      'message queue), or noop (no notifications sent, the '",
            "                      'default). (DEPRECATED)')),",
            "",
            "    cfg.StrOpt('default_publisher_id', default=\"image.localhost\",",
            "               help='Default publisher_id for outgoing notifications.'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(notifier_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "_STRATEGY_ALIASES = {",
            "    \"logging\": \"log\",",
            "    \"rabbit\": \"messaging\",",
            "    \"qpid\": \"messaging\",",
            "    \"noop\": \"noop\",",
            "    \"default\": \"noop\",",
            "}",
            "",
            "_ALIASES = {",
            "    'glance.openstack.common.rpc.impl_kombu': 'rabbit',",
            "    'glance.openstack.common.rpc.impl_qpid': 'qpid',",
            "    'glance.openstack.common.rpc.impl_zmq': 'zmq',",
            "}",
            "",
            "",
            "class Notifier(object):",
            "    \"\"\"Uses a notification strategy to send out messages about events.\"\"\"",
            "",
            "    def __init__(self, strategy=None):",
            "",
            "        _driver = None",
            "        _strategy = strategy",
            "",
            "        if CONF.notifier_strategy != 'default':",
            "            msg = _(\"notifier_strategy was deprecated in \"",
            "                    \"favor of `notification_driver`\")",
            "            LOG.warn(msg)",
            "",
            "            # NOTE(flaper87): Use this to keep backwards",
            "            # compatibility. We'll try to get an oslo.messaging",
            "            # driver from the specified strategy.",
            "            _strategy = strategy or CONF.notifier_strategy",
            "            _driver = _STRATEGY_ALIASES.get(_strategy)",
            "",
            "        publisher_id = CONF.default_publisher_id",
            "",
            "        try:",
            "            # NOTE(flaper87): Assume the user has configured",
            "            # the transport url.",
            "            self._transport = messaging.get_transport(CONF,",
            "                                                      aliases=_ALIASES)",
            "        except messaging.DriverLoadFailure:",
            "            # NOTE(flaper87): Catch driver load failures and re-raise",
            "            # them *just* if the `transport_url` option was set. This",
            "            # step is intended to keep backwards compatibility and avoid",
            "            # weird behaviors (like exceptions on missing dependencies)",
            "            # when the old notifier options are used.",
            "            if CONF.transport_url is not None:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception(_('Error loading the notifier'))",
            "",
            "        # NOTE(flaper87): This needs to be checked",
            "        # here because the `get_transport` call",
            "        # registers `transport_url` into ConfigOpts.",
            "        if not CONF.transport_url:",
            "            # NOTE(flaper87): The next 3 lines help",
            "            # with the migration to oslo.messaging.",
            "            # Without them, gate tests won't know",
            "            # what driver should be loaded.",
            "            # Once this patch lands, devstack will be",
            "            # updated and then these lines will be removed.",
            "            url = None",
            "            if _strategy in ['rabbit', 'qpid']:",
            "                url = _strategy + '://'",
            "            self._transport = messaging.get_transport(CONF, url,",
            "                                                      aliases=_ALIASES)",
            "",
            "        self._notifier = messaging.Notifier(self._transport,",
            "                                            driver=_driver,",
            "                                            publisher_id=publisher_id)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notifier.warn({}, event_type, payload)",
            "",
            "    def info(self, event_type, payload):",
            "        self._notifier.info({}, event_type, payload)",
            "",
            "    def error(self, event_type, payload):",
            "        self._notifier.error({}, event_type, payload)",
            "",
            "",
            "def format_image_notification(image):",
            "    \"\"\"",
            "    Given a glance.domain.Image object, return a dictionary of relevant",
            "    notification information. We purposely do not include 'location'",
            "    as it may contain credentials.",
            "    \"\"\"",
            "    return {",
            "        'id': image.image_id,",
            "        'name': image.name,",
            "        'status': image.status,",
            "        'created_at': timeutils.isotime(image.created_at),",
            "        'updated_at': timeutils.isotime(image.updated_at),",
            "        'min_disk': image.min_disk,",
            "        'min_ram': image.min_ram,",
            "        'protected': image.protected,",
            "        'checksum': image.checksum,",
            "        'owner': image.owner,",
            "        'disk_format': image.disk_format,",
            "        'container_format': image.container_format,",
            "        'size': image.size,",
            "        'is_public': image.visibility == 'public',",
            "        'properties': dict(image.extra_properties),",
            "        'tags': list(image.tags),",
            "        'deleted': False,",
            "        'deleted_at': None,",
            "    }",
            "",
            "",
            "def format_task_notification(task):",
            "    # NOTE(nikhil): input is not passed to the notifier payload as it may",
            "    # contain sensitive info.",
            "    return {'id': task.task_id,",
            "            'type': task.type,",
            "            'status': task.status,",
            "            'result': None,",
            "            'owner': task.owner,",
            "            'message': None,",
            "            'expires_at': timeutils.isotime(task.expires_at),",
            "            'created_at': timeutils.isotime(task.created_at),",
            "            'updated_at': timeutils.isotime(task.updated_at),",
            "            'deleted': False,",
            "            'deleted_at': None,",
            "            }",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, notifier):",
            "        self.image_repo = image_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def save(self, image):",
            "        super(ImageRepoProxy, self).save(image)",
            "        self.notifier.info('image.update',",
            "                           format_image_notification(image))",
            "",
            "    def add(self, image):",
            "        super(ImageRepoProxy, self).add(image)",
            "        self.notifier.info('image.create',",
            "                           format_image_notification(image))",
            "",
            "    def remove(self, image):",
            "        super(ImageRepoProxy, self).remove(image)",
            "        payload = format_image_notification(image)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('image.delete', payload)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, notifier):",
            "        self.image = image",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def _format_image_send(self, bytes_sent):",
            "        return {",
            "            'bytes_sent': bytes_sent,",
            "            'image_id': self.image.image_id,",
            "            'owner_id': self.image.owner,",
            "            'receiver_tenant_id': self.context.tenant,",
            "            'receiver_user_id': self.context.user,",
            "        }",
            "",
            "    def get_data(self):",
            "        sent = 0",
            "        for chunk in self.image.get_data():",
            "            yield chunk",
            "            sent += len(chunk)",
            "",
            "        if sent != self.image.size:",
            "            notify = self.notifier.error",
            "        else:",
            "            notify = self.notifier.info",
            "",
            "        try:",
            "            notify('image.send',",
            "                   self._format_image_send(sent))",
            "        except Exception as err:",
            "            msg = (_(\"An error occurred during image.send\"",
            "                     \" notification: %(err)s\") % {'err': err})",
            "            LOG.error(msg)",
            "",
            "    def set_data(self, data, size=None):",
            "        payload = format_image_notification(self.image)",
            "        self.notifier.info('image.prepare', payload)",
            "        try:",
            "            self.image.set_data(data, size)",
            "        except exception.StorageFull as e:",
            "            msg = (_(\"Image storage media is full: %s\") % e)",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg)",
            "        except exception.StorageWriteDenied as e:",
            "            msg = (_(\"Insufficient permissions on image storage media: %s\")",
            "                   % e)",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg)",
            "        except ValueError as e:",
            "            msg = (_(\"Cannot save data for image %(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPBadRequest(explanation=unicode(e))",
            "        except exception.Duplicate as e:",
            "            msg = (_(\"Unable to upload duplicate image data for image\"",
            "                     \"%(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPConflict(explanation=msg)",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %(image_id)s:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "        except exception.NotFound as e:",
            "            msg = (_(\"Image %(image_id)s could not be found after upload.\"",
            "                     \" The image may have been deleted during the upload:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPNotFound(explanation=unicode(e))",
            "        except webob.exc.HTTPError as e:",
            "            msg = (_(\"Failed to upload image data for image %(image_id)s\"",
            "                     \" due to HTTP error: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise",
            "        except Exception as e:",
            "            msg = (_(\"Failed to upload image data for image %(image_id)s \"",
            "                     \"due to internal error: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise",
            "        else:",
            "            payload = format_image_notification(self.image)",
            "            self.notifier.info('image.upload', payload)",
            "            self.notifier.info('image.activate', payload)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, notifier):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskRepoProxy, self) \\",
            "            .__init__(task_repo,",
            "                      task_proxy_class=TaskProxy,",
            "                      task_proxy_kwargs=proxy_kwargs,",
            "                      task_details_proxy_class=TaskDetailsProxy,",
            "                      task_details_proxy_kwargs=proxy_kwargs)",
            "",
            "    def add(self, task, task_details=None):",
            "        self.notifier.info('task.create',",
            "                           format_task_notification(task))",
            "        super(TaskRepoProxy, self).add(task, task_details)",
            "",
            "    def remove(self, task):",
            "        payload = format_task_notification(task)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('task.delete', payload)",
            "        super(TaskRepoProxy, self).remove(task)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "    def __init__(self, task_factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=kwargs,",
            "            task_details_proxy_class=TaskDetailsProxy,",
            "            task_details_proxy_kwargs=kwargs)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def run(self, executor):",
            "        self.notifier.info('task.run',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).run(executor)",
            "",
            "    def begin_processing(self):",
            "        self.notifier.info(",
            "            'task.processing',",
            "            format_task_notification(self.task)",
            "        )",
            "        return super(TaskProxy, self).begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.notifier.info('task.success',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.notifier.info('task.failure',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).fail(message)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details, context, notifier):",
            "        self.task_details = task_details",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskDetailsProxy, self).__init__(task_details)"
        ],
        "afterPatchFile": [
            "# Copyright 2011, OpenStack Foundation",
            "# Copyright 2012, Red Hat, Inc.",
            "# Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from oslo.config import cfg",
            "from oslo import messaging",
            "import webob",
            "",
            "from glance.common import exception",
            "import glance.domain.proxy",
            "import glance.openstack.common.log as logging",
            "from glance.openstack.common import timeutils",
            "",
            "notifier_opts = [",
            "    cfg.StrOpt('notifier_strategy', default='default',",
            "               help=_('Notifications can be sent when images are create, '",
            "                      'updated or deleted. There are three methods of sending '",
            "                      'notifications, logging (via the log_file directive), '",
            "                      'rabbit (via a rabbitmq queue), qpid (via a Qpid '",
            "                      'message queue), or noop (no notifications sent, the '",
            "                      'default). (DEPRECATED)')),",
            "",
            "    cfg.StrOpt('default_publisher_id', default=\"image.localhost\",",
            "               help='Default publisher_id for outgoing notifications.'),",
            "]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(notifier_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "_STRATEGY_ALIASES = {",
            "    \"logging\": \"log\",",
            "    \"rabbit\": \"messaging\",",
            "    \"qpid\": \"messaging\",",
            "    \"noop\": \"noop\",",
            "    \"default\": \"noop\",",
            "}",
            "",
            "_ALIASES = {",
            "    'glance.openstack.common.rpc.impl_kombu': 'rabbit',",
            "    'glance.openstack.common.rpc.impl_qpid': 'qpid',",
            "    'glance.openstack.common.rpc.impl_zmq': 'zmq',",
            "}",
            "",
            "",
            "class Notifier(object):",
            "    \"\"\"Uses a notification strategy to send out messages about events.\"\"\"",
            "",
            "    def __init__(self, strategy=None):",
            "",
            "        _driver = None",
            "        _strategy = strategy",
            "",
            "        if CONF.notifier_strategy != 'default':",
            "            msg = _(\"notifier_strategy was deprecated in \"",
            "                    \"favor of `notification_driver`\")",
            "            LOG.warn(msg)",
            "",
            "            # NOTE(flaper87): Use this to keep backwards",
            "            # compatibility. We'll try to get an oslo.messaging",
            "            # driver from the specified strategy.",
            "            _strategy = strategy or CONF.notifier_strategy",
            "            _driver = _STRATEGY_ALIASES.get(_strategy)",
            "",
            "        publisher_id = CONF.default_publisher_id",
            "",
            "        try:",
            "            # NOTE(flaper87): Assume the user has configured",
            "            # the transport url.",
            "            self._transport = messaging.get_transport(CONF,",
            "                                                      aliases=_ALIASES)",
            "        except messaging.DriverLoadFailure:",
            "            # NOTE(flaper87): Catch driver load failures and re-raise",
            "            # them *just* if the `transport_url` option was set. This",
            "            # step is intended to keep backwards compatibility and avoid",
            "            # weird behaviors (like exceptions on missing dependencies)",
            "            # when the old notifier options are used.",
            "            if CONF.transport_url is not None:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception(_('Error loading the notifier'))",
            "",
            "        # NOTE(flaper87): This needs to be checked",
            "        # here because the `get_transport` call",
            "        # registers `transport_url` into ConfigOpts.",
            "        if not CONF.transport_url:",
            "            # NOTE(flaper87): The next 3 lines help",
            "            # with the migration to oslo.messaging.",
            "            # Without them, gate tests won't know",
            "            # what driver should be loaded.",
            "            # Once this patch lands, devstack will be",
            "            # updated and then these lines will be removed.",
            "            url = None",
            "            if _strategy in ['rabbit', 'qpid']:",
            "                url = _strategy + '://'",
            "            self._transport = messaging.get_transport(CONF, url,",
            "                                                      aliases=_ALIASES)",
            "",
            "        self._notifier = messaging.Notifier(self._transport,",
            "                                            driver=_driver,",
            "                                            publisher_id=publisher_id)",
            "",
            "    def warn(self, event_type, payload):",
            "        self._notifier.warn({}, event_type, payload)",
            "",
            "    def info(self, event_type, payload):",
            "        self._notifier.info({}, event_type, payload)",
            "",
            "    def error(self, event_type, payload):",
            "        self._notifier.error({}, event_type, payload)",
            "",
            "",
            "def format_image_notification(image):",
            "    \"\"\"",
            "    Given a glance.domain.Image object, return a dictionary of relevant",
            "    notification information. We purposely do not include 'location'",
            "    as it may contain credentials.",
            "    \"\"\"",
            "    return {",
            "        'id': image.image_id,",
            "        'name': image.name,",
            "        'status': image.status,",
            "        'created_at': timeutils.isotime(image.created_at),",
            "        'updated_at': timeutils.isotime(image.updated_at),",
            "        'min_disk': image.min_disk,",
            "        'min_ram': image.min_ram,",
            "        'protected': image.protected,",
            "        'checksum': image.checksum,",
            "        'owner': image.owner,",
            "        'disk_format': image.disk_format,",
            "        'container_format': image.container_format,",
            "        'size': image.size,",
            "        'is_public': image.visibility == 'public',",
            "        'properties': dict(image.extra_properties),",
            "        'tags': list(image.tags),",
            "        'deleted': False,",
            "        'deleted_at': None,",
            "    }",
            "",
            "",
            "def format_task_notification(task):",
            "    # NOTE(nikhil): input is not passed to the notifier payload as it may",
            "    # contain sensitive info.",
            "    return {'id': task.task_id,",
            "            'type': task.type,",
            "            'status': task.status,",
            "            'result': None,",
            "            'owner': task.owner,",
            "            'message': None,",
            "            'expires_at': timeutils.isotime(task.expires_at),",
            "            'created_at': timeutils.isotime(task.created_at),",
            "            'updated_at': timeutils.isotime(task.updated_at),",
            "            'deleted': False,",
            "            'deleted_at': None,",
            "            }",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, notifier):",
            "        self.image_repo = image_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def save(self, image, from_state=None):",
            "        super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "        self.notifier.info('image.update',",
            "                           format_image_notification(image))",
            "",
            "    def add(self, image):",
            "        super(ImageRepoProxy, self).add(image)",
            "        self.notifier.info('image.create',",
            "                           format_image_notification(image))",
            "",
            "    def remove(self, image):",
            "        super(ImageRepoProxy, self).remove(image)",
            "        payload = format_image_notification(image)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('image.delete', payload)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=kwargs)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, notifier):",
            "        self.image = image",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def _format_image_send(self, bytes_sent):",
            "        return {",
            "            'bytes_sent': bytes_sent,",
            "            'image_id': self.image.image_id,",
            "            'owner_id': self.image.owner,",
            "            'receiver_tenant_id': self.context.tenant,",
            "            'receiver_user_id': self.context.user,",
            "        }",
            "",
            "    def get_data(self):",
            "        sent = 0",
            "        for chunk in self.image.get_data():",
            "            yield chunk",
            "            sent += len(chunk)",
            "",
            "        if sent != self.image.size:",
            "            notify = self.notifier.error",
            "        else:",
            "            notify = self.notifier.info",
            "",
            "        try:",
            "            notify('image.send',",
            "                   self._format_image_send(sent))",
            "        except Exception as err:",
            "            msg = (_(\"An error occurred during image.send\"",
            "                     \" notification: %(err)s\") % {'err': err})",
            "            LOG.error(msg)",
            "",
            "    def set_data(self, data, size=None):",
            "        payload = format_image_notification(self.image)",
            "        self.notifier.info('image.prepare', payload)",
            "        try:",
            "            self.image.set_data(data, size)",
            "        except exception.StorageFull as e:",
            "            msg = (_(\"Image storage media is full: %s\") % e)",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPRequestEntityTooLarge(explanation=msg)",
            "        except exception.StorageWriteDenied as e:",
            "            msg = (_(\"Insufficient permissions on image storage media: %s\")",
            "                   % e)",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPServiceUnavailable(explanation=msg)",
            "        except ValueError as e:",
            "            msg = (_(\"Cannot save data for image %(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPBadRequest(explanation=unicode(e))",
            "        except exception.Duplicate as e:",
            "            msg = (_(\"Unable to upload duplicate image data for image\"",
            "                     \"%(image_id)s: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPConflict(explanation=msg)",
            "        except exception.Forbidden as e:",
            "            msg = (_(\"Not allowed to upload image data for image %(image_id)s:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "        except exception.NotFound as e:",
            "            msg = (_(\"Image %(image_id)s could not be found after upload.\"",
            "                     \" The image may have been deleted during the upload:\"",
            "                     \" %(error)s\") % {'image_id': self.image.image_id,",
            "                                      'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise webob.exc.HTTPNotFound(explanation=unicode(e))",
            "        except webob.exc.HTTPError as e:",
            "            msg = (_(\"Failed to upload image data for image %(image_id)s\"",
            "                     \" due to HTTP error: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise",
            "        except Exception as e:",
            "            msg = (_(\"Failed to upload image data for image %(image_id)s \"",
            "                     \"due to internal error: %(error)s\") %",
            "                   {'image_id': self.image.image_id,",
            "                    'error': e})",
            "            self.notifier.error('image.upload', msg)",
            "            raise",
            "        else:",
            "            payload = format_image_notification(self.image)",
            "            self.notifier.info('image.upload', payload)",
            "            self.notifier.info('image.activate', payload)",
            "",
            "",
            "class TaskRepoProxy(glance.domain.proxy.TaskRepo):",
            "",
            "    def __init__(self, task_repo, context, notifier):",
            "        self.task_repo = task_repo",
            "        self.context = context",
            "        self.notifier = notifier",
            "        proxy_kwargs = {'context': self.context, 'notifier': self.notifier}",
            "        super(TaskRepoProxy, self) \\",
            "            .__init__(task_repo,",
            "                      task_proxy_class=TaskProxy,",
            "                      task_proxy_kwargs=proxy_kwargs,",
            "                      task_details_proxy_class=TaskDetailsProxy,",
            "                      task_details_proxy_kwargs=proxy_kwargs)",
            "",
            "    def add(self, task, task_details=None):",
            "        self.notifier.info('task.create',",
            "                           format_task_notification(task))",
            "        super(TaskRepoProxy, self).add(task, task_details)",
            "",
            "    def remove(self, task):",
            "        payload = format_task_notification(task)",
            "        payload['deleted'] = True",
            "        payload['deleted_at'] = timeutils.isotime()",
            "        self.notifier.info('task.delete', payload)",
            "        super(TaskRepoProxy, self).remove(task)",
            "",
            "",
            "class TaskFactoryProxy(glance.domain.proxy.TaskFactory):",
            "    def __init__(self, task_factory, context, notifier):",
            "        kwargs = {'context': context, 'notifier': notifier}",
            "        super(TaskFactoryProxy, self).__init__(",
            "            task_factory,",
            "            task_proxy_class=TaskProxy,",
            "            task_proxy_kwargs=kwargs,",
            "            task_details_proxy_class=TaskDetailsProxy,",
            "            task_details_proxy_kwargs=kwargs)",
            "",
            "",
            "class TaskProxy(glance.domain.proxy.Task):",
            "",
            "    def __init__(self, task, context, notifier):",
            "        self.task = task",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskProxy, self).__init__(task)",
            "",
            "    def run(self, executor):",
            "        self.notifier.info('task.run',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).run(executor)",
            "",
            "    def begin_processing(self):",
            "        self.notifier.info(",
            "            'task.processing',",
            "            format_task_notification(self.task)",
            "        )",
            "        return super(TaskProxy, self).begin_processing()",
            "",
            "    def succeed(self, result):",
            "        self.notifier.info('task.success',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).succeed(result)",
            "",
            "    def fail(self, message):",
            "        self.notifier.info('task.failure',",
            "                           format_task_notification(self.task))",
            "        return super(TaskProxy, self).fail(message)",
            "",
            "",
            "class TaskDetailsProxy(glance.domain.proxy.TaskDetails):",
            "",
            "    def __init__(self, task_details, context, notifier):",
            "        self.task_details = task_details",
            "        self.context = context",
            "        self.notifier = notifier",
            "        super(TaskDetailsProxy, self).__init__(task_details)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "181": [
                "ImageRepoProxy",
                "save"
            ],
            "182": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/quota/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             raise exception.ImagePropertyLimitExceeded(attempted=attempted,"
            },
            "1": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "                                                        maximum=maximum)"
            },
            "2": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         self._enforce_image_property_quota(image)"
            },
            "6": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super(ImageRepoProxy, self).save(image)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        return super(ImageRepoProxy, self).save(image, from_state=from_state)"
            },
            "8": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     def add(self, image):"
            },
            "10": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self._enforce_image_property_quota(image)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from oslo.config import cfg",
            "",
            "import glance.api.common",
            "import glance.common.exception as exception",
            "from glance.common import utils",
            "import glance.domain",
            "import glance.domain.proxy",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_member_quota', 'glance.common.config')",
            "CONF.import_opt('image_property_quota', 'glance.common.config')",
            "CONF.import_opt('image_tag_quota', 'glance.common.config')",
            "",
            "",
            "def _enforce_image_tag_quota(tags):",
            "    if CONF.image_tag_quota < 0:",
            "        # If value is negative, allow unlimited number of tags",
            "        return",
            "",
            "    if not tags:",
            "        return",
            "",
            "    if len(tags) > CONF.image_tag_quota:",
            "        raise exception.ImageTagLimitExceeded(attempted=len(tags),",
            "                                              maximum=CONF.image_tag_quota)",
            "",
            "",
            "def _calc_required_size(context, image, locations):",
            "    required_size = None",
            "    if image.size:",
            "        required_size = image.size * len(locations)",
            "    else:",
            "        for location in locations:",
            "            size_from_backend = None",
            "            try:",
            "                size_from_backend = glance.store.get_size_from_backend(",
            "                    context, location['url'])",
            "            except (exception.UnknownScheme, exception.NotFound):",
            "                pass",
            "            if size_from_backend:",
            "                required_size = size_from_backend * len(locations)",
            "                break",
            "    return required_size",
            "",
            "",
            "def _enforce_image_location_quota(image, locations, is_setter=False):",
            "    if CONF.image_location_quota < 0:",
            "        # If value is negative, allow unlimited number of locations",
            "        return",
            "",
            "    attempted = len(image.locations) + len(locations)",
            "    attempted = attempted if not is_setter else len(locations)",
            "    maximum = CONF.image_location_quota",
            "    if attempted > maximum:",
            "        raise exception.ImageLocationLimitExceeded(attempted=attempted,",
            "                                                   maximum=maximum)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, db_api):",
            "        self.image_repo = image_repo",
            "        self.db_api = db_api",
            "        proxy_kwargs = {'db_api': db_api, 'context': context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_property_quota(self, image):",
            "        if CONF.image_property_quota < 0:",
            "            # If value is negative, allow unlimited number of properties",
            "            return",
            "",
            "        attempted = len(image.extra_properties)",
            "        maximum = CONF.image_property_quota",
            "        if attempted > maximum:",
            "            raise exception.ImagePropertyLimitExceeded(attempted=attempted,",
            "                                                       maximum=maximum)",
            "",
            "    def save(self, image):",
            "        self._enforce_image_property_quota(image)",
            "        super(ImageRepoProxy, self).save(image)",
            "",
            "    def add(self, image):",
            "        self._enforce_image_property_quota(image)",
            "        super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, db_api):",
            "        proxy_kwargs = {'db_api': db_api, 'context': context}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        tags = kwargs.pop('tags', set([]))",
            "",
            "        _enforce_image_tag_quota(tags)",
            "        return super(ImageFactoryProxy, self).new_image(tags=tags, **kwargs)",
            "",
            "",
            "class QuotaImageTagsProxy(object):",
            "",
            "    def __init__(self, orig_set):",
            "        if orig_set is None:",
            "            orig_set = set([])",
            "        self.tags = orig_set",
            "",
            "    def add(self, item):",
            "        self.tags.add(item)",
            "        _enforce_image_tag_quota(self.tags)",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.tags.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.tags.__contains__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.tags == other",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.tags.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.tags.__len__(*args, **kwargs)",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self.tags, name)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, db_api):",
            "        self.db_api = db_api",
            "        self.context = context",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={})",
            "",
            "    def _enforce_image_member_quota(self, image):",
            "        if CONF.image_member_quota < 0:",
            "            # If value is negative, allow unlimited number of members",
            "            return",
            "",
            "        current_member_count = self.db_api.image_member_count(self.context,",
            "                                                              image.image_id)",
            "        attempted = current_member_count + 1",
            "        maximum = CONF.image_member_quota",
            "        if attempted > maximum:",
            "            raise exception.ImageMemberLimitExceeded(attempted=attempted,",
            "                                                     maximum=maximum)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self._enforce_image_member_quota(image)",
            "        return super(ImageMemberFactoryProxy, self).new_image_member(image,",
            "                                                                     member_id)",
            "",
            "",
            "class QuotaImageLocationsProxy(object):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.locations = image.locations",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.locations.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.locations.__contains__(*args, **kwargs)",
            "",
            "    def __delitem__(self, *args, **kwargs):",
            "        return self.locations.__delitem__(*args, **kwargs)",
            "",
            "    def __delslice__(self, *args, **kwargs):",
            "        return self.locations.__delslice__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.locations == other",
            "",
            "    def __getitem__(self, *args, **kwargs):",
            "        return self.locations.__getitem__(*args, **kwargs)",
            "",
            "    def __iadd__(self, other):",
            "        if not hasattr(other, '__iter__'):",
            "            raise TypeError()",
            "        self._check_user_storage_quota(other)",
            "        return self.locations.__iadd__(other)",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.locations.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.locations.__len__(*args, **kwargs)",
            "",
            "    def __setitem__(self, key, value):",
            "        return self.locations.__setitem__(key, value)",
            "",
            "    def count(self, *args, **kwargs):",
            "        return self.locations.count(*args, **kwargs)",
            "",
            "    def index(self, *args, **kwargs):",
            "        return self.locations.index(*args, **kwargs)",
            "",
            "    def pop(self, *args, **kwargs):",
            "        return self.locations.pop(*args, **kwargs)",
            "",
            "    def remove(self, *args, **kwargs):",
            "        return self.locations.remove(*args, **kwargs)",
            "",
            "    def reverse(self, *args, **kwargs):",
            "        return self.locations.reverse(*args, **kwargs)",
            "",
            "    def _check_user_storage_quota(self, locations):",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            locations)",
            "        glance.api.common.check_quota(self.context,",
            "                                      required_size,",
            "                                      self.db_api)",
            "        _enforce_image_location_quota(self.image, locations)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        self.image.locations = copy.deepcopy(self.locations, memo)",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def append(self, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.append(object)",
            "",
            "    def insert(self, index, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.insert(index, object)",
            "",
            "    def extend(self, iter):",
            "        self._check_user_storage_quota(iter)",
            "        return self.locations.extend(iter)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def set_data(self, data, size=None):",
            "        remaining = glance.api.common.check_quota(",
            "            self.context, size, self.db_api, image_id=self.image.image_id)",
            "        if remaining is not None:",
            "            # NOTE(jbresnah) we are trying to enforce a quota, put a limit",
            "            # reader on the data",
            "            data = utils.LimitingReader(data, remaining)",
            "        try:",
            "            self.image.set_data(data, size=size)",
            "        except exception.ImageSizeLimitExceeded:",
            "            raise exception.StorageQuotaFull(image_size=size,",
            "                                             remaining=remaining)",
            "",
            "        # NOTE(jbresnah) If two uploads happen at the same time and neither",
            "        # properly sets the size attribute[1] then there is a race condition",
            "        # that will allow for the quota to be broken[2].  Thus we must recheck",
            "        # the quota after the upload and thus after we know the size.",
            "        #",
            "        # Also, when an upload doesn't set the size properly then the call to",
            "        # check_quota above returns None and so utils.LimitingReader is not",
            "        # used above. Hence the store (e.g.  filesystem store) may have to",
            "        # download the entire file before knowing the actual file size.  Here",
            "        # also we need to check for the quota again after the image has been",
            "        # downloaded to the store.",
            "        #",
            "        # [1] For e.g. when using chunked transfers the 'Content-Length'",
            "        #     header is not set.",
            "        # [2] For e.g.:",
            "        #       - Upload 1 does not exceed quota but upload 2 exceeds quota.",
            "        #         Both uploads are to different locations",
            "        #       - Upload 2 completes before upload 1 and writes image.size.",
            "        #       - Immediately, upload 1 completes and (over)writes image.size",
            "        #         with the smaller size.",
            "        #       - Now, to glance, image has not exceeded quota but, in",
            "        #         reality, the quota has been exceeded.",
            "",
            "        try:",
            "            glance.api.common.check_quota(",
            "                self.context, self.image.size, self.db_api,",
            "                image_id=self.image.image_id)",
            "        except exception.StorageQuotaFull:",
            "            LOG.info(_('Cleaning up %s after exceeding the quota.')",
            "                     % self.image.image_id)",
            "            location = self.image.locations[0]['url']",
            "            glance.store.safe_delete_from_backend(",
            "                self.context, location, self.image.image_id)",
            "            raise",
            "",
            "    @property",
            "    def tags(self):",
            "        return QuotaImageTagsProxy(self.image.tags)",
            "",
            "    @tags.setter",
            "    def tags(self, value):",
            "        _enforce_image_tag_quota(value)",
            "        self.image.tags = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return QuotaImageLocationsProxy(self.image,",
            "                                        self.context,",
            "                                        self.db_api)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        _enforce_image_location_quota(self.image, value, is_setter=True)",
            "",
            "        if not isinstance(value, (list, QuotaImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            value)",
            "",
            "        glance.api.common.check_quota(",
            "            self.context, required_size, self.db_api,",
            "            image_id=self.image.image_id)",
            "        self.image.locations = value"
        ],
        "afterPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "from oslo.config import cfg",
            "",
            "import glance.api.common",
            "import glance.common.exception as exception",
            "from glance.common import utils",
            "import glance.domain",
            "import glance.domain.proxy",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "CONF = cfg.CONF",
            "CONF.import_opt('image_member_quota', 'glance.common.config')",
            "CONF.import_opt('image_property_quota', 'glance.common.config')",
            "CONF.import_opt('image_tag_quota', 'glance.common.config')",
            "",
            "",
            "def _enforce_image_tag_quota(tags):",
            "    if CONF.image_tag_quota < 0:",
            "        # If value is negative, allow unlimited number of tags",
            "        return",
            "",
            "    if not tags:",
            "        return",
            "",
            "    if len(tags) > CONF.image_tag_quota:",
            "        raise exception.ImageTagLimitExceeded(attempted=len(tags),",
            "                                              maximum=CONF.image_tag_quota)",
            "",
            "",
            "def _calc_required_size(context, image, locations):",
            "    required_size = None",
            "    if image.size:",
            "        required_size = image.size * len(locations)",
            "    else:",
            "        for location in locations:",
            "            size_from_backend = None",
            "            try:",
            "                size_from_backend = glance.store.get_size_from_backend(",
            "                    context, location['url'])",
            "            except (exception.UnknownScheme, exception.NotFound):",
            "                pass",
            "            if size_from_backend:",
            "                required_size = size_from_backend * len(locations)",
            "                break",
            "    return required_size",
            "",
            "",
            "def _enforce_image_location_quota(image, locations, is_setter=False):",
            "    if CONF.image_location_quota < 0:",
            "        # If value is negative, allow unlimited number of locations",
            "        return",
            "",
            "    attempted = len(image.locations) + len(locations)",
            "    attempted = attempted if not is_setter else len(locations)",
            "    maximum = CONF.image_location_quota",
            "    if attempted > maximum:",
            "        raise exception.ImageLocationLimitExceeded(attempted=attempted,",
            "                                                   maximum=maximum)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, db_api):",
            "        self.image_repo = image_repo",
            "        self.db_api = db_api",
            "        proxy_kwargs = {'db_api': db_api, 'context': context}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _enforce_image_property_quota(self, image):",
            "        if CONF.image_property_quota < 0:",
            "            # If value is negative, allow unlimited number of properties",
            "            return",
            "",
            "        attempted = len(image.extra_properties)",
            "        maximum = CONF.image_property_quota",
            "        if attempted > maximum:",
            "            raise exception.ImagePropertyLimitExceeded(attempted=attempted,",
            "                                                       maximum=maximum)",
            "",
            "    def save(self, image, from_state=None):",
            "        self._enforce_image_property_quota(image)",
            "        return super(ImageRepoProxy, self).save(image, from_state=from_state)",
            "",
            "    def add(self, image):",
            "        self._enforce_image_property_quota(image)",
            "        super(ImageRepoProxy, self).add(image)",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, db_api):",
            "        proxy_kwargs = {'db_api': db_api, 'context': context}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        tags = kwargs.pop('tags', set([]))",
            "",
            "        _enforce_image_tag_quota(tags)",
            "        return super(ImageFactoryProxy, self).new_image(tags=tags, **kwargs)",
            "",
            "",
            "class QuotaImageTagsProxy(object):",
            "",
            "    def __init__(self, orig_set):",
            "        if orig_set is None:",
            "            orig_set = set([])",
            "        self.tags = orig_set",
            "",
            "    def add(self, item):",
            "        self.tags.add(item)",
            "        _enforce_image_tag_quota(self.tags)",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.tags.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.tags.__contains__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.tags == other",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.tags.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.tags.__len__(*args, **kwargs)",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self.tags, name)",
            "",
            "",
            "class ImageMemberFactoryProxy(glance.domain.proxy.ImageMembershipFactory):",
            "",
            "    def __init__(self, member_factory, context, db_api):",
            "        self.db_api = db_api",
            "        self.context = context",
            "        super(ImageMemberFactoryProxy, self).__init__(",
            "            member_factory,",
            "            image_proxy_class=ImageProxy,",
            "            image_proxy_kwargs={})",
            "",
            "    def _enforce_image_member_quota(self, image):",
            "        if CONF.image_member_quota < 0:",
            "            # If value is negative, allow unlimited number of members",
            "            return",
            "",
            "        current_member_count = self.db_api.image_member_count(self.context,",
            "                                                              image.image_id)",
            "        attempted = current_member_count + 1",
            "        maximum = CONF.image_member_quota",
            "        if attempted > maximum:",
            "            raise exception.ImageMemberLimitExceeded(attempted=attempted,",
            "                                                     maximum=maximum)",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self._enforce_image_member_quota(image)",
            "        return super(ImageMemberFactoryProxy, self).new_image_member(image,",
            "                                                                     member_id)",
            "",
            "",
            "class QuotaImageLocationsProxy(object):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        self.locations = image.locations",
            "",
            "    def __cast__(self, *args, **kwargs):",
            "        return self.locations.__cast__(*args, **kwargs)",
            "",
            "    def __contains__(self, *args, **kwargs):",
            "        return self.locations.__contains__(*args, **kwargs)",
            "",
            "    def __delitem__(self, *args, **kwargs):",
            "        return self.locations.__delitem__(*args, **kwargs)",
            "",
            "    def __delslice__(self, *args, **kwargs):",
            "        return self.locations.__delslice__(*args, **kwargs)",
            "",
            "    def __eq__(self, other):",
            "        return self.locations == other",
            "",
            "    def __getitem__(self, *args, **kwargs):",
            "        return self.locations.__getitem__(*args, **kwargs)",
            "",
            "    def __iadd__(self, other):",
            "        if not hasattr(other, '__iter__'):",
            "            raise TypeError()",
            "        self._check_user_storage_quota(other)",
            "        return self.locations.__iadd__(other)",
            "",
            "    def __iter__(self, *args, **kwargs):",
            "        return self.locations.__iter__(*args, **kwargs)",
            "",
            "    def __len__(self, *args, **kwargs):",
            "        return self.locations.__len__(*args, **kwargs)",
            "",
            "    def __setitem__(self, key, value):",
            "        return self.locations.__setitem__(key, value)",
            "",
            "    def count(self, *args, **kwargs):",
            "        return self.locations.count(*args, **kwargs)",
            "",
            "    def index(self, *args, **kwargs):",
            "        return self.locations.index(*args, **kwargs)",
            "",
            "    def pop(self, *args, **kwargs):",
            "        return self.locations.pop(*args, **kwargs)",
            "",
            "    def remove(self, *args, **kwargs):",
            "        return self.locations.remove(*args, **kwargs)",
            "",
            "    def reverse(self, *args, **kwargs):",
            "        return self.locations.reverse(*args, **kwargs)",
            "",
            "    def _check_user_storage_quota(self, locations):",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            locations)",
            "        glance.api.common.check_quota(self.context,",
            "                                      required_size,",
            "                                      self.db_api)",
            "        _enforce_image_location_quota(self.image, locations)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        self.image.locations = copy.deepcopy(self.locations, memo)",
            "        return type(self)(self.image, self.context, self.db_api)",
            "",
            "    def append(self, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.append(object)",
            "",
            "    def insert(self, index, object):",
            "        self._check_user_storage_quota([object])",
            "        return self.locations.insert(index, object)",
            "",
            "    def extend(self, iter):",
            "        self._check_user_storage_quota(iter)",
            "        return self.locations.extend(iter)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    def __init__(self, image, context, db_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.db_api = db_api",
            "        super(ImageProxy, self).__init__(image)",
            "",
            "    def set_data(self, data, size=None):",
            "        remaining = glance.api.common.check_quota(",
            "            self.context, size, self.db_api, image_id=self.image.image_id)",
            "        if remaining is not None:",
            "            # NOTE(jbresnah) we are trying to enforce a quota, put a limit",
            "            # reader on the data",
            "            data = utils.LimitingReader(data, remaining)",
            "        try:",
            "            self.image.set_data(data, size=size)",
            "        except exception.ImageSizeLimitExceeded:",
            "            raise exception.StorageQuotaFull(image_size=size,",
            "                                             remaining=remaining)",
            "",
            "        # NOTE(jbresnah) If two uploads happen at the same time and neither",
            "        # properly sets the size attribute[1] then there is a race condition",
            "        # that will allow for the quota to be broken[2].  Thus we must recheck",
            "        # the quota after the upload and thus after we know the size.",
            "        #",
            "        # Also, when an upload doesn't set the size properly then the call to",
            "        # check_quota above returns None and so utils.LimitingReader is not",
            "        # used above. Hence the store (e.g.  filesystem store) may have to",
            "        # download the entire file before knowing the actual file size.  Here",
            "        # also we need to check for the quota again after the image has been",
            "        # downloaded to the store.",
            "        #",
            "        # [1] For e.g. when using chunked transfers the 'Content-Length'",
            "        #     header is not set.",
            "        # [2] For e.g.:",
            "        #       - Upload 1 does not exceed quota but upload 2 exceeds quota.",
            "        #         Both uploads are to different locations",
            "        #       - Upload 2 completes before upload 1 and writes image.size.",
            "        #       - Immediately, upload 1 completes and (over)writes image.size",
            "        #         with the smaller size.",
            "        #       - Now, to glance, image has not exceeded quota but, in",
            "        #         reality, the quota has been exceeded.",
            "",
            "        try:",
            "            glance.api.common.check_quota(",
            "                self.context, self.image.size, self.db_api,",
            "                image_id=self.image.image_id)",
            "        except exception.StorageQuotaFull:",
            "            LOG.info(_('Cleaning up %s after exceeding the quota.')",
            "                     % self.image.image_id)",
            "            location = self.image.locations[0]['url']",
            "            glance.store.safe_delete_from_backend(",
            "                self.context, location, self.image.image_id)",
            "            raise",
            "",
            "    @property",
            "    def tags(self):",
            "        return QuotaImageTagsProxy(self.image.tags)",
            "",
            "    @tags.setter",
            "    def tags(self, value):",
            "        _enforce_image_tag_quota(value)",
            "        self.image.tags = value",
            "",
            "    @property",
            "    def locations(self):",
            "        return QuotaImageLocationsProxy(self.image,",
            "                                        self.context,",
            "                                        self.db_api)",
            "",
            "    @locations.setter",
            "    def locations(self, value):",
            "        _enforce_image_location_quota(self.image, value, is_setter=True)",
            "",
            "        if not isinstance(value, (list, QuotaImageLocationsProxy)):",
            "            raise exception.Invalid(_('Invalid locations: %s') % value)",
            "",
            "        required_size = _calc_required_size(self.context,",
            "                                            self.image,",
            "                                            value)",
            "",
            "        glance.api.common.check_quota(",
            "            self.context, required_size, self.db_api,",
            "            image_id=self.image.image_id)",
            "        self.image.locations = value"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "99": [
                "ImageRepoProxy",
                "save"
            ],
            "101": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/store/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "         self._set_acls(image)"
            },
            "1": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "         return result"
            },
            "2": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "         result = super(ImageRepoProxy, self).save(image)"
            },
            "6": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "         self._set_acls(image)"
            },
            "7": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "         return result"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"",
            "    Check if an image location uri is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "    is_ok = True",
            "    try:",
            "        size = store_api.get_size_from_backend(context, uri)",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = size > 0",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        raise exception.BadStoreUri(_('Invalid location: %s') % uri)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "afterPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image, from_state=None):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"",
            "    Check if an image location uri is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "    is_ok = True",
            "    try:",
            "        size = store_api.get_size_from_backend(context, uri)",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = size > 0",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        raise exception.BadStoreUri(_('Invalid location: %s') % uri)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "449": [
                "ImageRepoProxy",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_domain_proxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         self._test_method('add', 'snuff', 'enough')"
            },
            "1": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def test_save(self):"
            },
            "3": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method('save', 'snuff', 'enough')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        self._test_method('save', 'snuff', 'enough', from_state=None)"
            },
            "5": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     def test_remove(self):"
            },
            "7": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         self._test_method('add', None, 'flying')"
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             self.assertEqual(results[i].args, tuple())"
            },
            "9": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "             self.assertEqual(results[i].kwargs, {'a': 1})"
            },
            "10": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _test_method_with_proxied_argument(self, name, result):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    def _test_method_with_proxied_argument(self, name, result, **kwargs):"
            },
            "13": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         self.fake_repo.result = result"
            },
            "14": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         item = FakeProxy('snoop')"
            },
            "15": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         method = getattr(self.proxy_repo, name)"
            },
            "16": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         proxy_result = method(item)"
            },
            "17": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(self.fake_repo.args, ('snoop',))"
            },
            "19": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(self.fake_repo.kwargs, {})"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        self.assertEqual(('snoop',), self.fake_repo.args)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        self.assertEqual(kwargs, self.fake_repo.kwargs)"
            },
            "22": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         if result is None:"
            },
            "24": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             self.assertTrue(proxy_result is None)"
            },
            "25": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self._test_method_with_proxied_argument('add', None)"
            },
            "26": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     def test_save(self):"
            },
            "28": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method_with_proxied_argument('save', 'dog')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        self._test_method_with_proxied_argument('save', 'dog',"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                                                from_state=None)"
            },
            "31": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     def test_save_with_no_result(self):"
            },
            "33": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._test_method_with_proxied_argument('save', None)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        self._test_method_with_proxied_argument('save', None,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                                                from_state=None)"
            },
            "36": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     def test_remove(self):"
            },
            "38": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         self._test_method_with_proxied_argument('remove', 'dog')"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 OpenStack Foundation.",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from six.moves import xrange",
            "",
            "from glance.domain import proxy",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class FakeProxy(object):",
            "    def __init__(self, base, *args, **kwargs):",
            "        self.base = base",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "",
            "class FakeRepo(object):",
            "    def __init__(self, result=None):",
            "        self.args = None",
            "        self.kwargs = None",
            "        self.result = result",
            "",
            "    def fake_method(self, *args, **kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "    get = fake_method",
            "    list = fake_method",
            "    add = fake_method",
            "    save = fake_method",
            "    remove = fake_method",
            "",
            "",
            "class TestProxyRepoPlain(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoPlain, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo)",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertEqual(proxy_result, base_result)",
            "        self.assertEqual(self.fake_repo.args, args)",
            "        self.assertEqual(self.fake_repo.kwargs, kwargs)",
            "",
            "    def test_get(self):",
            "        self._test_method('get', 'snarf', 'abcd')",
            "",
            "    def test_list(self):",
            "        self._test_method('list', ['sniff', 'snarf'], 2, filter='^sn')",
            "",
            "    def test_add(self):",
            "        self._test_method('add', 'snuff', 'enough')",
            "",
            "    def test_save(self):",
            "        self._test_method('save', 'snuff', 'enough')",
            "",
            "    def test_remove(self):",
            "        self._test_method('add', None, 'flying')",
            "",
            "",
            "class TestProxyRepoWrapping(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoWrapping, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo,",
            "                                     item_proxy_class=FakeProxy,",
            "                                     item_proxy_kwargs={'a': 1})",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertIsInstance(proxy_result, FakeProxy)",
            "        self.assertEqual(proxy_result.base, base_result)",
            "        self.assertEqual(len(proxy_result.args), 0)",
            "        self.assertEqual(proxy_result.kwargs, {'a': 1})",
            "        self.assertEqual(self.fake_repo.args, args)",
            "        self.assertEqual(self.fake_repo.kwargs, kwargs)",
            "",
            "    def test_get(self):",
            "        self.fake_repo.result = 'snarf'",
            "        result = self.proxy_repo.get('some-id')",
            "        self.assertIsInstance(result, FakeProxy)",
            "        self.assertEqual(self.fake_repo.args, ('some-id',))",
            "        self.assertEqual(self.fake_repo.kwargs, {})",
            "        self.assertEqual(result.base, 'snarf')",
            "        self.assertEqual(result.args, tuple())",
            "        self.assertEqual(result.kwargs, {'a': 1})",
            "",
            "    def test_list(self):",
            "        self.fake_repo.result = ['scratch', 'sniff']",
            "        results = self.proxy_repo.list(2, prefix='s')",
            "        self.assertEqual(self.fake_repo.args, (2,))",
            "        self.assertEqual(self.fake_repo.kwargs, {'prefix': 's'})",
            "        self.assertEqual(len(results), 2)",
            "        for i in xrange(2):",
            "            self.assertIsInstance(results[i], FakeProxy)",
            "            self.assertEqual(results[i].base, self.fake_repo.result[i])",
            "            self.assertEqual(results[i].args, tuple())",
            "            self.assertEqual(results[i].kwargs, {'a': 1})",
            "",
            "    def _test_method_with_proxied_argument(self, name, result):",
            "        self.fake_repo.result = result",
            "        item = FakeProxy('snoop')",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(item)",
            "",
            "        self.assertEqual(self.fake_repo.args, ('snoop',))",
            "        self.assertEqual(self.fake_repo.kwargs, {})",
            "",
            "        if result is None:",
            "            self.assertTrue(proxy_result is None)",
            "        else:",
            "            self.assertIsInstance(proxy_result, FakeProxy)",
            "            self.assertEqual(proxy_result.base, result)",
            "            self.assertEqual(proxy_result.args, tuple())",
            "            self.assertEqual(proxy_result.kwargs, {'a': 1})",
            "",
            "    def test_add(self):",
            "        self._test_method_with_proxied_argument('add', 'dog')",
            "",
            "    def test_add_with_no_result(self):",
            "        self._test_method_with_proxied_argument('add', None)",
            "",
            "    def test_save(self):",
            "        self._test_method_with_proxied_argument('save', 'dog')",
            "",
            "    def test_save_with_no_result(self):",
            "        self._test_method_with_proxied_argument('save', None)",
            "",
            "    def test_remove(self):",
            "        self._test_method_with_proxied_argument('remove', 'dog')",
            "",
            "    def test_remove_with_no_result(self):",
            "        self._test_method_with_proxied_argument('remove', None)",
            "",
            "",
            "class FakeImageFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.kwargs = None",
            "",
            "    def new_image(self, **kwargs):",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "",
            "class TestImageFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.factory = FakeImageFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory)",
            "        self.factory.result = 'eddard'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertEqual(image, 'eddard')",
            "        self.assertEqual(self.factory.kwargs, {'a': 1, 'b': 'two'})",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory,",
            "                                           proxy_class=FakeProxy,",
            "                                           proxy_kwargs={'dog': 'bark'})",
            "        self.factory.result = 'stark'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertIsInstance(image, FakeProxy)",
            "        self.assertEqual(image.base, 'stark')",
            "        self.assertEqual(self.factory.kwargs, {'a': 1, 'b': 'two'})",
            "",
            "",
            "class FakeImageMembershipFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.image = None",
            "        self.member_id = None",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self.image = image",
            "        self.member_id = member_id",
            "        return self.result",
            "",
            "",
            "class TestImageMembershipFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMembershipFactory, self).setUp()",
            "        self.factory = FakeImageMembershipFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(self.factory)",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertEqual(membership, 'tyrion')",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_wrapped_membership(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'a': 1})",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual(membership.base, 'tyrion')",
            "        self.assertEqual(membership.kwargs, {'a': 1})",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_wrapped_image(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, image_proxy_class=FakeProxy)",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertEqual(membership, 'tyrion')",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_both_wrapped(self):",
            "        class FakeProxy2(FakeProxy):",
            "            pass",
            "",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory,",
            "            member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'b': 2},",
            "            image_proxy_class=FakeProxy2)",
            "",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy2('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual(membership.base, 'tyrion')",
            "        self.assertEqual(membership.kwargs, {'b': 2})",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get_member_repo(self):",
            "        return self.result",
            "",
            "",
            "class TestImage(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImage, self).setUp()",
            "        self.image = FakeImage()",
            "",
            "    def test_normal_member_repo(self):",
            "        proxy_image = proxy.Image(self.image)",
            "        self.image.result = 'mormont'",
            "        self.assertEqual(proxy_image.get_member_repo(), 'mormont')",
            "",
            "    def test_proxied_member_repo(self):",
            "        proxy_image = proxy.Image(self.image,",
            "                                  member_repo_proxy_class=FakeProxy,",
            "                                  member_repo_proxy_kwargs={'a': 10})",
            "        self.image.result = 'corn'",
            "        member_repo = proxy_image.get_member_repo()",
            "        self.assertIsInstance(member_repo, FakeProxy)",
            "        self.assertEqual(member_repo.base, 'corn')",
            "",
            "",
            "class TestTaskFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestTaskFactory, self).setUp()",
            "        self.factory = mock.Mock()",
            "        self.fake_type = 'import'",
            "        self.fake_owner = \"owner\"",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.TaskFactory(self.factory)",
            "",
            "        proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        proxy_factory.new_task_details(\"task_01\", \"input\")",
            "",
            "        self.factory.new_task_details.assert_called_once_with(",
            "            \"task_01\",",
            "            \"input\",",
            "            None, None",
            "        )",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.TaskFactory(",
            "            self.factory,",
            "            task_proxy_class=FakeProxy,",
            "            task_proxy_kwargs={'dog': 'bark'},",
            "            task_details_proxy_class=FakeProxy,",
            "            task_details_proxy_kwargs={'dog': 'bark'})",
            "",
            "        self.factory.new_task.return_value = 'fake_task'",
            "        self.factory.new_task_details.return_value = 'fake_task_detail'",
            "",
            "        task = proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "        self.assertIsInstance(task, FakeProxy)",
            "        self.assertEqual(task.base, 'fake_task')",
            "",
            "        task_details = proxy_factory.new_task_details('task_01', \"input\")",
            "",
            "        self.factory.new_task_details.assert_called_once_with(",
            "            'task_01',",
            "            \"input\",",
            "            None, None",
            "        )",
            "",
            "        self.assertIsInstance(task_details, FakeProxy)",
            "        self.assertEqual(task_details.base, 'fake_task_detail')"
        ],
        "afterPatchFile": [
            "# Copyright 2013 OpenStack Foundation.",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from six.moves import xrange",
            "",
            "from glance.domain import proxy",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "",
            "",
            "class FakeProxy(object):",
            "    def __init__(self, base, *args, **kwargs):",
            "        self.base = base",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "",
            "class FakeRepo(object):",
            "    def __init__(self, result=None):",
            "        self.args = None",
            "        self.kwargs = None",
            "        self.result = result",
            "",
            "    def fake_method(self, *args, **kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "    get = fake_method",
            "    list = fake_method",
            "    add = fake_method",
            "    save = fake_method",
            "    remove = fake_method",
            "",
            "",
            "class TestProxyRepoPlain(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoPlain, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo)",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertEqual(proxy_result, base_result)",
            "        self.assertEqual(self.fake_repo.args, args)",
            "        self.assertEqual(self.fake_repo.kwargs, kwargs)",
            "",
            "    def test_get(self):",
            "        self._test_method('get', 'snarf', 'abcd')",
            "",
            "    def test_list(self):",
            "        self._test_method('list', ['sniff', 'snarf'], 2, filter='^sn')",
            "",
            "    def test_add(self):",
            "        self._test_method('add', 'snuff', 'enough')",
            "",
            "    def test_save(self):",
            "        self._test_method('save', 'snuff', 'enough', from_state=None)",
            "",
            "    def test_remove(self):",
            "        self._test_method('add', None, 'flying')",
            "",
            "",
            "class TestProxyRepoWrapping(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestProxyRepoWrapping, self).setUp()",
            "        self.fake_repo = FakeRepo()",
            "        self.proxy_repo = proxy.Repo(self.fake_repo,",
            "                                     item_proxy_class=FakeProxy,",
            "                                     item_proxy_kwargs={'a': 1})",
            "",
            "    def _test_method(self, name, base_result, *args, **kwargs):",
            "        self.fake_repo.result = base_result",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(*args, **kwargs)",
            "        self.assertIsInstance(proxy_result, FakeProxy)",
            "        self.assertEqual(proxy_result.base, base_result)",
            "        self.assertEqual(len(proxy_result.args), 0)",
            "        self.assertEqual(proxy_result.kwargs, {'a': 1})",
            "        self.assertEqual(self.fake_repo.args, args)",
            "        self.assertEqual(self.fake_repo.kwargs, kwargs)",
            "",
            "    def test_get(self):",
            "        self.fake_repo.result = 'snarf'",
            "        result = self.proxy_repo.get('some-id')",
            "        self.assertIsInstance(result, FakeProxy)",
            "        self.assertEqual(self.fake_repo.args, ('some-id',))",
            "        self.assertEqual(self.fake_repo.kwargs, {})",
            "        self.assertEqual(result.base, 'snarf')",
            "        self.assertEqual(result.args, tuple())",
            "        self.assertEqual(result.kwargs, {'a': 1})",
            "",
            "    def test_list(self):",
            "        self.fake_repo.result = ['scratch', 'sniff']",
            "        results = self.proxy_repo.list(2, prefix='s')",
            "        self.assertEqual(self.fake_repo.args, (2,))",
            "        self.assertEqual(self.fake_repo.kwargs, {'prefix': 's'})",
            "        self.assertEqual(len(results), 2)",
            "        for i in xrange(2):",
            "            self.assertIsInstance(results[i], FakeProxy)",
            "            self.assertEqual(results[i].base, self.fake_repo.result[i])",
            "            self.assertEqual(results[i].args, tuple())",
            "            self.assertEqual(results[i].kwargs, {'a': 1})",
            "",
            "    def _test_method_with_proxied_argument(self, name, result, **kwargs):",
            "        self.fake_repo.result = result",
            "        item = FakeProxy('snoop')",
            "        method = getattr(self.proxy_repo, name)",
            "        proxy_result = method(item)",
            "",
            "        self.assertEqual(('snoop',), self.fake_repo.args)",
            "        self.assertEqual(kwargs, self.fake_repo.kwargs)",
            "",
            "        if result is None:",
            "            self.assertTrue(proxy_result is None)",
            "        else:",
            "            self.assertIsInstance(proxy_result, FakeProxy)",
            "            self.assertEqual(proxy_result.base, result)",
            "            self.assertEqual(proxy_result.args, tuple())",
            "            self.assertEqual(proxy_result.kwargs, {'a': 1})",
            "",
            "    def test_add(self):",
            "        self._test_method_with_proxied_argument('add', 'dog')",
            "",
            "    def test_add_with_no_result(self):",
            "        self._test_method_with_proxied_argument('add', None)",
            "",
            "    def test_save(self):",
            "        self._test_method_with_proxied_argument('save', 'dog',",
            "                                                from_state=None)",
            "",
            "    def test_save_with_no_result(self):",
            "        self._test_method_with_proxied_argument('save', None,",
            "                                                from_state=None)",
            "",
            "    def test_remove(self):",
            "        self._test_method_with_proxied_argument('remove', 'dog')",
            "",
            "    def test_remove_with_no_result(self):",
            "        self._test_method_with_proxied_argument('remove', None)",
            "",
            "",
            "class FakeImageFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.kwargs = None",
            "",
            "    def new_image(self, **kwargs):",
            "        self.kwargs = kwargs",
            "        return self.result",
            "",
            "",
            "class TestImageFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.factory = FakeImageFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory)",
            "        self.factory.result = 'eddard'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertEqual(image, 'eddard')",
            "        self.assertEqual(self.factory.kwargs, {'a': 1, 'b': 'two'})",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.ImageFactory(self.factory,",
            "                                           proxy_class=FakeProxy,",
            "                                           proxy_kwargs={'dog': 'bark'})",
            "        self.factory.result = 'stark'",
            "        image = proxy_factory.new_image(a=1, b='two')",
            "        self.assertIsInstance(image, FakeProxy)",
            "        self.assertEqual(image.base, 'stark')",
            "        self.assertEqual(self.factory.kwargs, {'a': 1, 'b': 'two'})",
            "",
            "",
            "class FakeImageMembershipFactory(object):",
            "    def __init__(self, result=None):",
            "        self.result = None",
            "        self.image = None",
            "        self.member_id = None",
            "",
            "    def new_image_member(self, image, member_id):",
            "        self.image = image",
            "        self.member_id = member_id",
            "        return self.result",
            "",
            "",
            "class TestImageMembershipFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMembershipFactory, self).setUp()",
            "        self.factory = FakeImageMembershipFactory()",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(self.factory)",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertEqual(membership, 'tyrion')",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_wrapped_membership(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'a': 1})",
            "        self.factory.result = 'tyrion'",
            "        membership = proxy_factory.new_image_member('jaime', 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual(membership.base, 'tyrion')",
            "        self.assertEqual(membership.kwargs, {'a': 1})",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_wrapped_image(self):",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory, image_proxy_class=FakeProxy)",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertEqual(membership, 'tyrion')",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "    def test_proxy_both_wrapped(self):",
            "        class FakeProxy2(FakeProxy):",
            "            pass",
            "",
            "        proxy_factory = proxy.ImageMembershipFactory(",
            "            self.factory,",
            "            member_proxy_class=FakeProxy,",
            "            member_proxy_kwargs={'b': 2},",
            "            image_proxy_class=FakeProxy2)",
            "",
            "        self.factory.result = 'tyrion'",
            "        image = FakeProxy2('jaime')",
            "        membership = proxy_factory.new_image_member(image, 'cersei')",
            "        self.assertIsInstance(membership, FakeProxy)",
            "        self.assertEqual(membership.base, 'tyrion')",
            "        self.assertEqual(membership.kwargs, {'b': 2})",
            "        self.assertEqual(self.factory.image, 'jaime')",
            "        self.assertEqual(self.factory.member_id, 'cersei')",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get_member_repo(self):",
            "        return self.result",
            "",
            "",
            "class TestImage(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImage, self).setUp()",
            "        self.image = FakeImage()",
            "",
            "    def test_normal_member_repo(self):",
            "        proxy_image = proxy.Image(self.image)",
            "        self.image.result = 'mormont'",
            "        self.assertEqual(proxy_image.get_member_repo(), 'mormont')",
            "",
            "    def test_proxied_member_repo(self):",
            "        proxy_image = proxy.Image(self.image,",
            "                                  member_repo_proxy_class=FakeProxy,",
            "                                  member_repo_proxy_kwargs={'a': 10})",
            "        self.image.result = 'corn'",
            "        member_repo = proxy_image.get_member_repo()",
            "        self.assertIsInstance(member_repo, FakeProxy)",
            "        self.assertEqual(member_repo.base, 'corn')",
            "",
            "",
            "class TestTaskFactory(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestTaskFactory, self).setUp()",
            "        self.factory = mock.Mock()",
            "        self.fake_type = 'import'",
            "        self.fake_owner = \"owner\"",
            "",
            "    def test_proxy_plain(self):",
            "        proxy_factory = proxy.TaskFactory(self.factory)",
            "",
            "        proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        proxy_factory.new_task_details(\"task_01\", \"input\")",
            "",
            "        self.factory.new_task_details.assert_called_once_with(",
            "            \"task_01\",",
            "            \"input\",",
            "            None, None",
            "        )",
            "",
            "    def test_proxy_wrapping(self):",
            "        proxy_factory = proxy.TaskFactory(",
            "            self.factory,",
            "            task_proxy_class=FakeProxy,",
            "            task_proxy_kwargs={'dog': 'bark'},",
            "            task_details_proxy_class=FakeProxy,",
            "            task_details_proxy_kwargs={'dog': 'bark'})",
            "",
            "        self.factory.new_task.return_value = 'fake_task'",
            "        self.factory.new_task_details.return_value = 'fake_task_detail'",
            "",
            "        task = proxy_factory.new_task(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "",
            "        self.factory.new_task.assert_called_once_with(",
            "            type=self.fake_type,",
            "            owner=self.fake_owner",
            "        )",
            "        self.assertIsInstance(task, FakeProxy)",
            "        self.assertEqual(task.base, 'fake_task')",
            "",
            "        task_details = proxy_factory.new_task_details('task_01', \"input\")",
            "",
            "        self.factory.new_task_details.assert_called_once_with(",
            "            'task_01',",
            "            \"input\",",
            "            None, None",
            "        )",
            "",
            "        self.assertIsInstance(task_details, FakeProxy)",
            "        self.assertEqual(task_details.base, 'fake_task_detail')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "77": [
                "TestProxyRepoPlain",
                "test_save"
            ],
            "124": [
                "TestProxyRepoWrapping",
                "_test_method_with_proxied_argument"
            ],
            "130": [
                "TestProxyRepoWrapping",
                "_test_method_with_proxied_argument"
            ],
            "131": [
                "TestProxyRepoWrapping",
                "_test_method_with_proxied_argument"
            ],
            "148": [
                "TestProxyRepoWrapping",
                "test_save"
            ],
            "151": [
                "TestProxyRepoWrapping",
                "test_save_with_no_result"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_policy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def get(self, *args, **kwargs):"
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         return 'member_repo_get'"
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image_member):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    def save(self, image_member, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         image_member.output = 'member_repo_save'"
            },
            "6": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     def list(self, *args, **kwargs):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os.path",
            "",
            "import mock",
            "import oslo.config.cfg",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "import glance.context",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'image_from_get'",
            "",
            "    def save(self, *args, **kwargs):",
            "        return 'image_from_save'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'image_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['image_from_list_0', 'image_from_list_1']",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, visibility='private'):",
            "        self.image_id = image_id",
            "        self.visibility = visibility",
            "        self.status = 'active'",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        self.visibility = visibility",
            "        return 'new_image'",
            "",
            "",
            "class MemberRepoStub(object):",
            "    def add(self, image_member):",
            "        image_member.output = 'member_repo_add'",
            "",
            "    def get(self, *args, **kwargs):",
            "        return 'member_repo_get'",
            "",
            "    def save(self, image_member):",
            "        image_member.output = 'member_repo_save'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return 'member_repo_list'",
            "",
            "    def remove(self, image_member):",
            "        image_member.output = 'member_repo_remove'",
            "",
            "",
            "class ImageMembershipStub(object):",
            "    def __init__(self, output=None):",
            "        self.output = output",
            "",
            "",
            "class TaskRepoStub(object):",
            "    def get_task_and_details(self, *args, **kwargs):",
            "        return 'task_from_get', 'task_details_from_get'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'task_from_add'",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        return ['task_from_list_0', 'task_from_list_1']",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, task_id):",
            "        self.task_id = task_id",
            "        self.status = 'pending'",
            "",
            "    def run(self, executor):",
            "        self.status = 'processing'",
            "",
            "",
            "class TaskFactoryStub(object):",
            "    def new_task(self, *args):",
            "        return 'new_task'",
            "",
            "",
            "class TestPolicyEnforcer(base.IsolatedUnitTest):",
            "    def test_policy_file_default_rules_default_location(self):",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_rules_default_location(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_location(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_check(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertEqual(enforcer.check(context, 'get_image', {}), False)",
            "",
            "",
            "class TestPolicyEnforcerNoFile(base.IsolatedUnitTest):",
            "    def test_policy_file_specified_but_not_found(self):",
            "        \"\"\"Missing defined policy file should result in a default ruleset\"\"\"",
            "        self.config(policy_file='gobble.gobble')",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "    def test_policy_file_default_not_found(self):",
            "        \"\"\"Missing default policy file should result in a default ruleset\"\"\"",
            "        def fake_find_file(self, name):",
            "            return None",
            "",
            "        self.stubs.Set(oslo.config.cfg.ConfigOpts, 'find_file',",
            "                       fake_find_file)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "",
            "class TestImagePolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_factory_stub = ImageFactoryStub()",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        super(TestImagePolicy, self).setUp()",
            "",
            "    def test_publicize_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden,",
            "                          setattr, image, 'visibility', 'public')",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_publicize_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.visibility = 'public'",
            "        self.assertEqual(image.visibility, 'public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_delete_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.delete)",
            "        self.assertEqual(image.status, 'active')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_delete_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_get_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.get, UUID1)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        output = image_repo.get(UUID1)",
            "        self.assertIsInstance(output, glance.api.policy.ImageProxy)",
            "        self.assertEqual(output.image, 'image_from_get')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_images_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.list)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_get_images_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        images = image_repo.list()",
            "        for i, image in enumerate(images):",
            "            self.assertIsInstance(image, glance.api.policy.ImageProxy)",
            "            self.assertEqual(image.image, 'image_from_list_%d' % i)",
            "            self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_modify_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.save, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_modify_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.save(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_add_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.add, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_add_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.add(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_new_image_visibility(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_factory.new_image,",
            "                          visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_new_image_visibility_public_allowed(self):",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        image_factory.new_image(visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_image_get_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.get_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"download_image\", {})",
            "",
            "    def test_image_set_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.set_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"upload_image\", {})",
            "",
            "",
            "class TestMemberPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        self.member_repo = glance.api.policy.ImageMemberRepoProxy(",
            "            MemberRepoStub(), {}, self.policy)",
            "        super(TestMemberPolicy, self).setUp()",
            "",
            "    def test_add_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.add, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_add_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.add(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_add')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_get_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.get, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_get_member_allowed(self):",
            "        output = self.member_repo.get('')",
            "        self.assertEqual(output, 'member_repo_get')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_modify_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.save, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_modify_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.save(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_save')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_get_members_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.list, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_get_members_allowed(self):",
            "        output = self.member_repo.list('')",
            "        self.assertEqual(output, 'member_repo_list')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_delete_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.remove, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "    def test_delete_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.remove(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_remove')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "",
            "class TestTaskPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.task_stub = TaskStub(UUID1)",
            "        self.task_repo_stub = TaskRepoStub()",
            "        self.task_factory_stub = TaskFactoryStub()",
            "        self.policy = unit_test_utils.FakePolicyEnforcer()",
            "        super(TestTaskPolicy, self).setUp()",
            "",
            "    def test_get_task_not_allowed(self):",
            "        rules = {\"get_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden,",
            "                          task_repo.get_task_and_details,",
            "                          UUID1)",
            "",
            "    def test_get_task_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task, task_details = task_repo.get_task_and_details(UUID1)",
            "        self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "        self.assertEqual(task.task, 'task_from_get')",
            "",
            "    def test_get_tasks_not_allowed(self):",
            "        rules = {\"get_tasks\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden, task_repo.list_tasks)",
            "",
            "    def test_get_tasks_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        tasks = task_repo.list_tasks()",
            "        for i, task in enumerate(tasks):",
            "            self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "            self.assertEqual(task.task, 'task_from_list_%d' % i)",
            "",
            "    def test_add_task_not_allowed(self):",
            "        rules = {\"add_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, task_repo.add, task)",
            "",
            "    def test_add_task_allowed(self):",
            "        rules = {\"add_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        task_repo.add(task)",
            "",
            "",
            "class TestContextPolicyEnforcer(base.IsolatedUnitTest):",
            "    def _do_test_policy_influence_context_admin(self,",
            "                                                policy_admin_role,",
            "                                                context_role,",
            "                                                context_is_admin,",
            "                                                admin_expected):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {'context_is_admin': 'role:%s' % policy_admin_role}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[context_role],",
            "                                                is_admin=context_is_admin,",
            "                                                policy_enforcer=enforcer)",
            "        self.assertEqual(context.is_admin, admin_expected)",
            "",
            "    def test_context_admin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     False,",
            "                                                     True)",
            "",
            "    def test_context_admin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     False,",
            "                                                     False)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os.path",
            "",
            "import mock",
            "import oslo.config.cfg",
            "",
            "import glance.api.policy",
            "from glance.common import exception",
            "import glance.context",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def get(self, *args, **kwargs):",
            "        return 'image_from_get'",
            "",
            "    def save(self, *args, **kwargs):",
            "        return 'image_from_save'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'image_from_add'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return ['image_from_list_0', 'image_from_list_1']",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, visibility='private'):",
            "        self.image_id = image_id",
            "        self.visibility = visibility",
            "        self.status = 'active'",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        self.visibility = visibility",
            "        return 'new_image'",
            "",
            "",
            "class MemberRepoStub(object):",
            "    def add(self, image_member):",
            "        image_member.output = 'member_repo_add'",
            "",
            "    def get(self, *args, **kwargs):",
            "        return 'member_repo_get'",
            "",
            "    def save(self, image_member, from_state=None):",
            "        image_member.output = 'member_repo_save'",
            "",
            "    def list(self, *args, **kwargs):",
            "        return 'member_repo_list'",
            "",
            "    def remove(self, image_member):",
            "        image_member.output = 'member_repo_remove'",
            "",
            "",
            "class ImageMembershipStub(object):",
            "    def __init__(self, output=None):",
            "        self.output = output",
            "",
            "",
            "class TaskRepoStub(object):",
            "    def get_task_and_details(self, *args, **kwargs):",
            "        return 'task_from_get', 'task_details_from_get'",
            "",
            "    def add(self, *args, **kwargs):",
            "        return 'task_from_add'",
            "",
            "    def list_tasks(self, *args, **kwargs):",
            "        return ['task_from_list_0', 'task_from_list_1']",
            "",
            "",
            "class TaskStub(object):",
            "    def __init__(self, task_id):",
            "        self.task_id = task_id",
            "        self.status = 'pending'",
            "",
            "    def run(self, executor):",
            "        self.status = 'processing'",
            "",
            "",
            "class TaskFactoryStub(object):",
            "    def new_task(self, *args):",
            "        return 'new_task'",
            "",
            "",
            "class TestPolicyEnforcer(base.IsolatedUnitTest):",
            "    def test_policy_file_default_rules_default_location(self):",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_rules_default_location(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_custom_location(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'get_image', {})",
            "",
            "    def test_policy_file_check(self):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        self.assertEqual(enforcer.check(context, 'get_image', {}), False)",
            "",
            "",
            "class TestPolicyEnforcerNoFile(base.IsolatedUnitTest):",
            "    def test_policy_file_specified_but_not_found(self):",
            "        \"\"\"Missing defined policy file should result in a default ruleset\"\"\"",
            "        self.config(policy_file='gobble.gobble')",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "    def test_policy_file_default_not_found(self):",
            "        \"\"\"Missing default policy file should result in a default ruleset\"\"\"",
            "        def fake_find_file(self, name):",
            "            return None",
            "",
            "        self.stubs.Set(oslo.config.cfg.ConfigOpts, 'find_file',",
            "                       fake_find_file)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[])",
            "        enforcer.enforce(context, 'get_image', {})",
            "        self.assertRaises(exception.Forbidden,",
            "                          enforcer.enforce, context, 'manage_image_cache', {})",
            "",
            "        admin_context = glance.context.RequestContext(roles=['admin'])",
            "        enforcer.enforce(admin_context, 'manage_image_cache', {})",
            "",
            "",
            "class TestImagePolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_factory_stub = ImageFactoryStub()",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        super(TestImagePolicy, self).setUp()",
            "",
            "    def test_publicize_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden,",
            "                          setattr, image, 'visibility', 'public')",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_publicize_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.visibility = 'public'",
            "        self.assertEqual(image.visibility, 'public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_delete_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.delete)",
            "        self.assertEqual(image.status, 'active')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_delete_image_allowed(self):",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_image\", {})",
            "",
            "    def test_get_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.get, UUID1)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        output = image_repo.get(UUID1)",
            "        self.assertIsInstance(output, glance.api.policy.ImageProxy)",
            "        self.assertEqual(output.image, 'image_from_get')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_image\", {})",
            "",
            "    def test_get_images_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.list)",
            "        self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_get_images_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        images = image_repo.list()",
            "        for i, image in enumerate(images):",
            "            self.assertIsInstance(image, glance.api.policy.ImageProxy)",
            "            self.assertEqual(image.image, 'image_from_list_%d' % i)",
            "            self.policy.enforce.assert_called_once_with({}, \"get_images\", {})",
            "",
            "    def test_modify_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.save, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_modify_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.save(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_image\", {})",
            "",
            "    def test_add_image_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_repo.add, image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_add_image_allowed(self):",
            "        image_repo = glance.api.policy.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.policy)",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        image_repo.add(image)",
            "        self.policy.enforce.assert_called_once_with({}, \"add_image\", {})",
            "",
            "    def test_new_image_visibility(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image_factory.new_image,",
            "                          visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_new_image_visibility_public_allowed(self):",
            "        image_factory = glance.api.policy.ImageFactoryProxy(",
            "            self.image_factory_stub, {}, self.policy)",
            "        image_factory.new_image(visibility='public')",
            "        self.policy.enforce.assert_called_once_with({}, \"publicize_image\", {})",
            "",
            "    def test_image_get_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.get_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"download_image\", {})",
            "",
            "    def test_image_set_data(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        image = glance.api.policy.ImageProxy(self.image_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, image.set_data)",
            "        self.policy.enforce.assert_called_once_with({}, \"upload_image\", {})",
            "",
            "",
            "class TestMemberPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.policy = mock.Mock()",
            "        self.policy.enforce = mock.Mock()",
            "        self.member_repo = glance.api.policy.ImageMemberRepoProxy(",
            "            MemberRepoStub(), {}, self.policy)",
            "        super(TestMemberPolicy, self).setUp()",
            "",
            "    def test_add_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.add, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_add_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.add(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_add')",
            "        self.policy.enforce.assert_called_once_with({}, \"add_member\", {})",
            "",
            "    def test_get_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.get, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_get_member_allowed(self):",
            "        output = self.member_repo.get('')",
            "        self.assertEqual(output, 'member_repo_get')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_member\", {})",
            "",
            "    def test_modify_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.save, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_modify_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.save(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_save')",
            "        self.policy.enforce.assert_called_once_with({}, \"modify_member\", {})",
            "",
            "    def test_get_members_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.list, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_get_members_allowed(self):",
            "        output = self.member_repo.list('')",
            "        self.assertEqual(output, 'member_repo_list')",
            "        self.policy.enforce.assert_called_once_with({}, \"get_members\", {})",
            "",
            "    def test_delete_member_not_allowed(self):",
            "        self.policy.enforce.side_effect = exception.Forbidden",
            "        self.assertRaises(exception.Forbidden, self.member_repo.remove, '')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "    def test_delete_member_allowed(self):",
            "        image_member = ImageMembershipStub()",
            "        self.member_repo.remove(image_member)",
            "        self.assertEqual(image_member.output, 'member_repo_remove')",
            "        self.policy.enforce.assert_called_once_with({}, \"delete_member\", {})",
            "",
            "",
            "class TestTaskPolicy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        self.task_stub = TaskStub(UUID1)",
            "        self.task_repo_stub = TaskRepoStub()",
            "        self.task_factory_stub = TaskFactoryStub()",
            "        self.policy = unit_test_utils.FakePolicyEnforcer()",
            "        super(TestTaskPolicy, self).setUp()",
            "",
            "    def test_get_task_not_allowed(self):",
            "        rules = {\"get_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden,",
            "                          task_repo.get_task_and_details,",
            "                          UUID1)",
            "",
            "    def test_get_task_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task, task_details = task_repo.get_task_and_details(UUID1)",
            "        self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "        self.assertEqual(task.task, 'task_from_get')",
            "",
            "    def test_get_tasks_not_allowed(self):",
            "        rules = {\"get_tasks\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        self.assertRaises(exception.Forbidden, task_repo.list_tasks)",
            "",
            "    def test_get_tasks_allowed(self):",
            "        rules = {\"get_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        tasks = task_repo.list_tasks()",
            "        for i, task in enumerate(tasks):",
            "            self.assertIsInstance(task, glance.api.policy.TaskProxy)",
            "            self.assertEqual(task.task, 'task_from_list_%d' % i)",
            "",
            "    def test_add_task_not_allowed(self):",
            "        rules = {\"add_task\": False}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        self.assertRaises(exception.Forbidden, task_repo.add, task)",
            "",
            "    def test_add_task_allowed(self):",
            "        rules = {\"add_task\": True}",
            "        self.policy.set_rules(rules)",
            "        task_repo = glance.api.policy.TaskRepoProxy(",
            "            self.task_repo_stub,",
            "            {},",
            "            self.policy",
            "        )",
            "        task = glance.api.policy.TaskProxy(self.task_stub, {}, self.policy)",
            "        task_repo.add(task)",
            "",
            "",
            "class TestContextPolicyEnforcer(base.IsolatedUnitTest):",
            "    def _do_test_policy_influence_context_admin(self,",
            "                                                policy_admin_role,",
            "                                                context_role,",
            "                                                context_is_admin,",
            "                                                admin_expected):",
            "        self.config(policy_file=os.path.join(self.test_dir, 'gobble.gobble'))",
            "",
            "        rules = {'context_is_admin': 'role:%s' % policy_admin_role}",
            "        self.set_policy_rules(rules)",
            "",
            "        enforcer = glance.api.policy.Enforcer()",
            "",
            "        context = glance.context.RequestContext(roles=[context_role],",
            "                                                is_admin=context_is_admin,",
            "                                                policy_enforcer=enforcer)",
            "        self.assertEqual(context.is_admin, admin_expected)",
            "",
            "    def test_context_admin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_admin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'test_admin',",
            "                                                     False,",
            "                                                     True)",
            "",
            "    def test_context_admin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     True,",
            "                                                     True)",
            "",
            "    def test_context_nonadmin_policy_nonadmin(self):",
            "        self._do_test_policy_influence_context_admin('test_admin',",
            "                                                     'demo',",
            "                                                     False,",
            "                                                     False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [
                "MemberRepoStub",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_quota.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "         self.image.extra_properties = {'foo': 'bar'}"
            },
            "1": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "2": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 292,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "6": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 295,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "     def test_save_image_too_many_image_properties(self):"
            },
            "8": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            },
            "9": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "         self.image.extra_properties = {'foo': 'bar'}"
            },
            "10": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         self.image_repo_proxy.save(self.image)"
            },
            "11": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo_mock.save.assert_called_once_with(self.base_image)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+        self.image_repo_mock.save.assert_called_once_with(self.base_image,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+                                                          from_state=None)"
            },
            "15": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "     def test_add_image_with_image_property(self):"
            },
            "17": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "         self.config(image_property_quota=1)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from mock import patch",
            "import uuid",
            "",
            "import six",
            "",
            "from glance.common import exception",
            "import glance.quota",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class FakeContext(object):",
            "    owner = 'someone'",
            "    is_admin = False",
            "",
            "",
            "class FakeImage(object):",
            "    size = None",
            "    image_id = 'someid'",
            "    locations = [{'url': 'file:///not/a/path', 'metadata': {}}]",
            "    tags = set([])",
            "",
            "    def set_data(self, data, size=None):",
            "        self.size = 0",
            "        for d in data:",
            "            self.size += len(d)",
            "",
            "",
            "class TestImageQuota(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageQuota, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestImageQuota, self).tearDown()",
            "",
            "    def _get_image(self, location_count=1, image_size=10):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'xyz'",
            "        base_image.size = image_size",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        locations = []",
            "        for i in range(location_count):",
            "            locations.append({'url': 'file:///g/there/it/is%d' % i,",
            "                              'metadata': {}})",
            "        image_values = {'id': 'xyz', 'owner': context.owner,",
            "                        'status': 'active', 'size': image_size,",
            "                        'locations': locations}",
            "        db_api.image_create(context, image_values)",
            "        return image",
            "",
            "    def test_quota_allowed(self):",
            "        quota = 10",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        data = '*' * quota",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(quota, base_image.size)",
            "",
            "    def _quota_exceeded_size(self, quota, data,",
            "                             deleted=True, size=None):",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "",
            "        if deleted:",
            "            with patch.object(glance.store, 'safe_delete_from_backend'):",
            "                glance.store.safe_delete_from_backend(",
            "                    context,",
            "                    base_image.locations[0]['url'],",
            "                    image.image_id)",
            "",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.set_data,",
            "                          data,",
            "                          size=size)",
            "",
            "    def test_quota_exceeded_no_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        #NOTE(jbresnah) When the image size is None it means that it is",
            "        # not known.  In this case the only time we will raise an",
            "        # exception is when there is no room left at all, thus we know",
            "        # it will not fit.",
            "        # That's why 'get_remaining_quota' is mocked with return_value = 0.",
            "        with patch.object(glance.api.common, 'get_remaining_quota',",
            "                          return_value=0):",
            "            self._quota_exceeded_size(quota, data)",
            "",
            "    def test_quota_exceeded_with_right_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(quota, data, size=len(data), deleted=False)",
            "",
            "    def test_quota_exceeded_with_lie_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(quota, data, deleted=False, size=quota - 1)",
            "",
            "    def test_append_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.append(new_location)",
            "        pre_add_locations.append(new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_insert_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.insert(0, new_location)",
            "        pre_add_locations.insert(0, new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_extend_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.extend([new_location])",
            "        pre_add_locations.extend([new_location])",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_iadd_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations += [new_location]",
            "        pre_add_locations += [new_location]",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_set_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        image.locations = [new_location]",
            "        self.assertEqual(image.locations, [new_location])",
            "",
            "    def _make_image_with_quota(self, image_size=10, location_count=2):",
            "        quota = image_size * location_count",
            "        self.config(user_storage_quota=quota)",
            "        return self._get_image(image_size=image_size,",
            "                               location_count=location_count)",
            "",
            "    def test_exceed_append_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.append,",
            "                          {'url': 'file:///a/path', 'metadata': {}})",
            "",
            "    def test_exceed_insert_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.insert,",
            "                          0,",
            "                          {'url': 'file:///a/path', 'metadata': {}})",
            "",
            "    def test_exceed_extend_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.extend,",
            "                          [{'url': 'file:///a/path', 'metadata': {}}])",
            "",
            "    def test_set_location_under(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        image.locations = [{'url': 'file:///a/path', 'metadata': {}}]",
            "",
            "    def test_set_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations = [{'url': 'file:///a/path', 'metadata': {}},",
            "                               {'url': 'file:///a/path2', 'metadata': {}}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_iadd_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations += [{'url': 'file:///a/path', 'metadata': {}}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_append_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.append({'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_insert_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.insert(0,",
            "                               {'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_set_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations = [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertEqual([{'url': 'file:///fake.img.tar.gz', 'metadata': {}}],",
            "                         image.locations)",
            "",
            "    def test_iadd_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations += [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "",
            "class TestImagePropertyQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImagePropertyQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_save_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "",
            "    def test_save_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.save, self.image)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in six.text_type(exc))",
            "",
            "    def test_save_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.add, self.image)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in six.text_type(exc))",
            "",
            "    def test_add_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "",
            "class TestImageTagQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageTagQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.tags = set([])",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_replace_too_many_image_tags(self):",
            "        self.config(image_tag_quota=0)",
            "",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                setattr, self.image, 'tags', ['foo', 'bar'])",
            "        self.assertTrue('Attempted: 2, Maximum: 0' in six.text_type(exc))",
            "        self.assertEqual(len(self.image.tags), 0)",
            "",
            "    def test_replace_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_add_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_add_too_many_image_tags(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                self.image.tags.add, 'bar')",
            "        self.assertTrue('Attempted: 2, Maximum: 1' in six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_remove_image_tag_while_over_quota(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "        self.config(image_tag_quota=0)",
            "        self.image.tags.remove('foo')",
            "        self.assertEqual(len(self.image.tags), 0)",
            "",
            "",
            "class TestQuotaImageTagsProxy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestQuotaImageTagsProxy, self).setUp()",
            "",
            "    def test_add(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        proxy.add('foo')",
            "        self.assertTrue('foo' in proxy)",
            "",
            "    def test_add_too_many_tags(self):",
            "        self.config(image_tag_quota=0)",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                proxy.add, 'bar')",
            "        self.assertTrue('Attempted: 1, Maximum: 0' in six.text_type(exc))",
            "",
            "    def test_equals(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        self.assertEqual(set([]), proxy)",
            "",
            "    def test_contains(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo']))",
            "        self.assertTrue('foo' in proxy)",
            "",
            "    def test_len(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo',",
            "                                                      'bar',",
            "                                                      'baz',",
            "                                                      'niz']))",
            "        self.assertEqual(len(proxy), 4)",
            "",
            "    def test_iter(self):",
            "        items = set(['foo', 'bar', 'baz', 'niz'])",
            "        proxy = glance.quota.QuotaImageTagsProxy(items.copy())",
            "        self.assertEqual(len(items), 4)",
            "        for item in proxy:",
            "            items.remove(item)",
            "        self.assertEqual(len(items), 0)",
            "",
            "",
            "class TestImageMemberQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMemberQuotas, self).setUp()",
            "        db_api = unit_test_utils.FakeDB()",
            "        context = FakeContext()",
            "        self.image = mock.Mock()",
            "        self.base_image_member_factory = mock.Mock()",
            "        self.image_member_factory = glance.quota.ImageMemberFactoryProxy(",
            "            self.base_image_member_factory, context,",
            "            db_api)",
            "",
            "    def test_new_image_member(self):",
            "        self.config(image_member_quota=1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        self.base_image_member_factory.new_image_member\\",
            "            .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_unlimited_members(self):",
            "        self.config(image_member_quota=-1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        self.base_image_member_factory.new_image_member\\",
            "            .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_too_many_members(self):",
            "        self.config(image_member_quota=0)",
            "",
            "        self.assertRaises(exception.ImageMemberLimitExceeded,",
            "                          self.image_member_factory.new_image_member,",
            "                          self.image, 'fake_id')",
            "",
            "",
            "class TestImageLocationQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageLocationQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.locations = []",
            "        self.base_image.size = 1",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}",
            "                                 }]",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_replace_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        locations = [",
            "            {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake3.img.tar.gz\", \"metadata\": {}}",
            "        ]",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                setattr, self.image, 'locations', locations)",
            "        self.assertTrue('Attempted: 3, Maximum: 1' in six.text_type(exc))",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_replace_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_add_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_add_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        location2 = {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}}",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                self.image.locations.append, location2)",
            "        self.assertTrue('Attempted: 2, Maximum: 1' in six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_remove_image_location_while_over_quota(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "        self.config(image_location_quota=0)",
            "        self.image.locations.remove(location1)",
            "        self.assertEqual(len(self.image.locations), 0)"
        ],
        "afterPatchFile": [
            "# Copyright 2013, Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from mock import patch",
            "import uuid",
            "",
            "import six",
            "",
            "from glance.common import exception",
            "import glance.quota",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "",
            "",
            "class FakeContext(object):",
            "    owner = 'someone'",
            "    is_admin = False",
            "",
            "",
            "class FakeImage(object):",
            "    size = None",
            "    image_id = 'someid'",
            "    locations = [{'url': 'file:///not/a/path', 'metadata': {}}]",
            "    tags = set([])",
            "",
            "    def set_data(self, data, size=None):",
            "        self.size = 0",
            "        for d in data:",
            "            self.size += len(d)",
            "",
            "",
            "class TestImageQuota(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageQuota, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestImageQuota, self).tearDown()",
            "",
            "    def _get_image(self, location_count=1, image_size=10):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'xyz'",
            "        base_image.size = image_size",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        locations = []",
            "        for i in range(location_count):",
            "            locations.append({'url': 'file:///g/there/it/is%d' % i,",
            "                              'metadata': {}})",
            "        image_values = {'id': 'xyz', 'owner': context.owner,",
            "                        'status': 'active', 'size': image_size,",
            "                        'locations': locations}",
            "        db_api.image_create(context, image_values)",
            "        return image",
            "",
            "    def test_quota_allowed(self):",
            "        quota = 10",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        data = '*' * quota",
            "        base_image.set_data(data, size=None)",
            "        image.set_data(data)",
            "        self.assertEqual(quota, base_image.size)",
            "",
            "    def _quota_exceeded_size(self, quota, data,",
            "                             deleted=True, size=None):",
            "        self.config(user_storage_quota=quota)",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = 'id'",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "",
            "        if deleted:",
            "            with patch.object(glance.store, 'safe_delete_from_backend'):",
            "                glance.store.safe_delete_from_backend(",
            "                    context,",
            "                    base_image.locations[0]['url'],",
            "                    image.image_id)",
            "",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.set_data,",
            "                          data,",
            "                          size=size)",
            "",
            "    def test_quota_exceeded_no_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        #NOTE(jbresnah) When the image size is None it means that it is",
            "        # not known.  In this case the only time we will raise an",
            "        # exception is when there is no room left at all, thus we know",
            "        # it will not fit.",
            "        # That's why 'get_remaining_quota' is mocked with return_value = 0.",
            "        with patch.object(glance.api.common, 'get_remaining_quota',",
            "                          return_value=0):",
            "            self._quota_exceeded_size(quota, data)",
            "",
            "    def test_quota_exceeded_with_right_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(quota, data, size=len(data), deleted=False)",
            "",
            "    def test_quota_exceeded_with_lie_size(self):",
            "        quota = 10",
            "        data = '*' * (quota + 1)",
            "        self._quota_exceeded_size(quota, data, deleted=False, size=quota - 1)",
            "",
            "    def test_append_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.append(new_location)",
            "        pre_add_locations.append(new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_insert_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.insert(0, new_location)",
            "        pre_add_locations.insert(0, new_location)",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_extend_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations.extend([new_location])",
            "        pre_add_locations.extend([new_location])",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_iadd_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        pre_add_locations = image.locations[:]",
            "        image.locations += [new_location]",
            "        pre_add_locations += [new_location]",
            "        self.assertEqual(image.locations, pre_add_locations)",
            "",
            "    def test_set_location(self):",
            "        new_location = {'url': 'file:///a/path', 'metadata': {}}",
            "        image = self._get_image()",
            "        image.locations = [new_location]",
            "        self.assertEqual(image.locations, [new_location])",
            "",
            "    def _make_image_with_quota(self, image_size=10, location_count=2):",
            "        quota = image_size * location_count",
            "        self.config(user_storage_quota=quota)",
            "        return self._get_image(image_size=image_size,",
            "                               location_count=location_count)",
            "",
            "    def test_exceed_append_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.append,",
            "                          {'url': 'file:///a/path', 'metadata': {}})",
            "",
            "    def test_exceed_insert_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.insert,",
            "                          0,",
            "                          {'url': 'file:///a/path', 'metadata': {}})",
            "",
            "    def test_exceed_extend_location(self):",
            "        image = self._make_image_with_quota()",
            "        self.assertRaises(exception.StorageQuotaFull,",
            "                          image.locations.extend,",
            "                          [{'url': 'file:///a/path', 'metadata': {}}])",
            "",
            "    def test_set_location_under(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        image.locations = [{'url': 'file:///a/path', 'metadata': {}}]",
            "",
            "    def test_set_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations = [{'url': 'file:///a/path', 'metadata': {}},",
            "                               {'url': 'file:///a/path2', 'metadata': {}}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_iadd_location_exceed(self):",
            "        image = self._make_image_with_quota(location_count=1)",
            "        try:",
            "            image.locations += [{'url': 'file:///a/path', 'metadata': {}}]",
            "            self.fail('Should have raised the quota exception')",
            "        except exception.StorageQuotaFull:",
            "            pass",
            "",
            "    def test_append_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.append({'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_insert_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations.insert(0,",
            "                               {'url': 'file:///fake.img.tar.gz',",
            "                                'metadata': {}})",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "    def test_set_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations = [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertEqual([{'url': 'file:///fake.img.tar.gz', 'metadata': {}}],",
            "                         image.locations)",
            "",
            "    def test_iadd_location_for_queued_image(self):",
            "        context = FakeContext()",
            "        db_api = unit_test_utils.FakeDB()",
            "        base_image = FakeImage()",
            "        base_image.image_id = str(uuid.uuid4())",
            "        image = glance.quota.ImageProxy(base_image, context, db_api)",
            "        self.assertIsNone(image.size)",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       unit_test_utils.fake_get_size_from_backend)",
            "        image.locations += [{'url': 'file:///fake.img.tar.gz', 'metadata': {}}]",
            "        self.assertIn({'url': 'file:///fake.img.tar.gz', 'metadata': {}},",
            "                      image.locations)",
            "",
            "",
            "class TestImagePropertyQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImagePropertyQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_save_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "",
            "    def test_save_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.save, self.image)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in six.text_type(exc))",
            "",
            "    def test_save_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.save(self.image)",
            "",
            "        self.image_repo_mock.save.assert_called_once_with(self.base_image,",
            "                                                          from_state=None)",
            "",
            "    def test_add_image_with_image_property(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "    def test_add_image_too_many_image_properties(self):",
            "        self.config(image_property_quota=1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar', 'foo2': 'bar2'}",
            "        exc = self.assertRaises(exception.ImagePropertyLimitExceeded,",
            "                                self.image_repo_proxy.add, self.image)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in six.text_type(exc))",
            "",
            "    def test_add_image_unlimited_image_properties(self):",
            "        self.config(image_property_quota=-1)",
            "",
            "        self.image.extra_properties = {'foo': 'bar'}",
            "        self.image_repo_proxy.add(self.image)",
            "",
            "        self.image_repo_mock.add.assert_called_once_with(self.base_image)",
            "",
            "",
            "class TestImageTagQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageTagQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.tags = set([])",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_replace_too_many_image_tags(self):",
            "        self.config(image_tag_quota=0)",
            "",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                setattr, self.image, 'tags', ['foo', 'bar'])",
            "        self.assertTrue('Attempted: 2, Maximum: 0' in six.text_type(exc))",
            "        self.assertEqual(len(self.image.tags), 0)",
            "",
            "    def test_replace_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags = ['foo']",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_add_image_tag(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_add_too_many_image_tags(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                self.image.tags.add, 'bar')",
            "        self.assertTrue('Attempted: 2, Maximum: 1' in six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_tags(self):",
            "        self.config(image_tag_quota=-1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "",
            "    def test_remove_image_tag_while_over_quota(self):",
            "        self.config(image_tag_quota=1)",
            "        self.image.tags.add('foo')",
            "        self.assertEqual(len(self.image.tags), 1)",
            "        self.config(image_tag_quota=0)",
            "        self.image.tags.remove('foo')",
            "        self.assertEqual(len(self.image.tags), 0)",
            "",
            "",
            "class TestQuotaImageTagsProxy(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestQuotaImageTagsProxy, self).setUp()",
            "",
            "    def test_add(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        proxy.add('foo')",
            "        self.assertTrue('foo' in proxy)",
            "",
            "    def test_add_too_many_tags(self):",
            "        self.config(image_tag_quota=0)",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        exc = self.assertRaises(exception.ImageTagLimitExceeded,",
            "                                proxy.add, 'bar')",
            "        self.assertTrue('Attempted: 1, Maximum: 0' in six.text_type(exc))",
            "",
            "    def test_equals(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set([]))",
            "        self.assertEqual(set([]), proxy)",
            "",
            "    def test_contains(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo']))",
            "        self.assertTrue('foo' in proxy)",
            "",
            "    def test_len(self):",
            "        proxy = glance.quota.QuotaImageTagsProxy(set(['foo',",
            "                                                      'bar',",
            "                                                      'baz',",
            "                                                      'niz']))",
            "        self.assertEqual(len(proxy), 4)",
            "",
            "    def test_iter(self):",
            "        items = set(['foo', 'bar', 'baz', 'niz'])",
            "        proxy = glance.quota.QuotaImageTagsProxy(items.copy())",
            "        self.assertEqual(len(items), 4)",
            "        for item in proxy:",
            "            items.remove(item)",
            "        self.assertEqual(len(items), 0)",
            "",
            "",
            "class TestImageMemberQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageMemberQuotas, self).setUp()",
            "        db_api = unit_test_utils.FakeDB()",
            "        context = FakeContext()",
            "        self.image = mock.Mock()",
            "        self.base_image_member_factory = mock.Mock()",
            "        self.image_member_factory = glance.quota.ImageMemberFactoryProxy(",
            "            self.base_image_member_factory, context,",
            "            db_api)",
            "",
            "    def test_new_image_member(self):",
            "        self.config(image_member_quota=1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        self.base_image_member_factory.new_image_member\\",
            "            .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_unlimited_members(self):",
            "        self.config(image_member_quota=-1)",
            "",
            "        self.image_member_factory.new_image_member(self.image,",
            "                                                   'fake_id')",
            "        self.base_image_member_factory.new_image_member\\",
            "            .assert_called_once_with(self.image.base, 'fake_id')",
            "",
            "    def test_new_image_member_too_many_members(self):",
            "        self.config(image_member_quota=0)",
            "",
            "        self.assertRaises(exception.ImageMemberLimitExceeded,",
            "                          self.image_member_factory.new_image_member,",
            "                          self.image, 'fake_id')",
            "",
            "",
            "class TestImageLocationQuotas(test_utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestImageLocationQuotas, self).setUp()",
            "        self.base_image = mock.Mock()",
            "        self.base_image.locations = []",
            "        self.base_image.size = 1",
            "        self.image = glance.quota.ImageProxy(self.base_image,",
            "                                             mock.Mock(),",
            "                                             mock.Mock())",
            "",
            "        self.image_repo_mock = mock.Mock()",
            "        self.image_repo_proxy = glance.quota.ImageRepoProxy(",
            "            self.image_repo_mock,",
            "            mock.Mock(),",
            "            mock.Mock())",
            "",
            "    def test_replace_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}",
            "                                 }]",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_replace_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        locations = [",
            "            {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}},",
            "            {\"url\": \"file:///fake3.img.tar.gz\", \"metadata\": {}}",
            "        ]",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                setattr, self.image, 'locations', locations)",
            "        self.assertTrue('Attempted: 3, Maximum: 1' in six.text_type(exc))",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_replace_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        self.image.locations = [{\"url\": \"file:///fake.img.tar.gz\",",
            "                                 \"metadata\": {}}",
            "                                ]",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_add_image_location(self):",
            "        self.config(image_location_quota=1)",
            "        location = {\"url\": \"file:///fake.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_add_too_many_image_locations(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        location2 = {\"url\": \"file:///fake2.img.tar.gz\", \"metadata\": {}}",
            "        exc = self.assertRaises(exception.ImageLocationLimitExceeded,",
            "                                self.image.locations.append, location2)",
            "        self.assertTrue('Attempted: 2, Maximum: 1' in six.text_type(exc))",
            "",
            "    def test_add_unlimited_image_locations(self):",
            "        self.config(image_location_quota=-1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "",
            "    def test_remove_image_location_while_over_quota(self):",
            "        self.config(image_location_quota=1)",
            "        location1 = {\"url\": \"file:///fake1.img.tar.gz\", \"metadata\": {}}",
            "        self.image.locations.append(location1)",
            "        self.assertEqual(len(self.image.locations), 1)",
            "        self.config(image_location_quota=0)",
            "        self.image.locations.remove(location1)",
            "        self.assertEqual(len(self.image.locations), 0)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "293": [
                "TestImagePropertyQuotas",
                "test_save_image_with_image_property"
            ],
            "309": [
                "TestImagePropertyQuotas",
                "test_save_image_unlimited_image_properties"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_store_image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     def add(self, image):"
            },
            "1": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         return image"
            },
            "2": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         return image"
            },
            "6": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        location = image.locations[0]",
            "        self.assertEqual(image.status, 'active')",
            "        self.store_api.get_from_backend({}, location['url'])",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {}, location['url'])",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image.get_data(), 'XXX')",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, context, location):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image1.get_data(), 'XXX')",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(len(image1.locations), 2)",
            "        self.assertEqual(location_data['url'], UUID2)",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "        # This time, image1.get_data() returns the data wrapped in a",
            "        # LimitingReader|CooperativeReader pipeline, so peeking under",
            "        # the hood of those objects to get at the underlying string.",
            "        self.assertEqual(image1.get_data().data.fd, 'ZZZ')",
            "        image1.locations.pop(0)",
            "        self.assertEqual(len(image1.locations), 1)",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        image = glance.store.ImageProxy(image_stub, context, store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(location_data['url'], UUID2)",
            "        self.assertEqual(location_data['metadata'], loc_meta)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub,",
            "                                        context, self.store_api)",
            "        image.set_data(data, len)",
            "        self.assertEqual(image.size, len)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}}",
            "        self.assertEqual(image.locations, [location])",
            "        self.assertEqual(image_stub.locations, [location])",
            "        self.assertEqual(image.status, 'active')",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual(image_stub1.locations, [location2])",
            "        self.assertEqual(image1.locations, [location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3])",
            "        self.assertEqual(image1.locations, [location3])",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3, location2])",
            "        self.assertEqual(image1.locations, [location3, location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.store.ImageProxy(image_stub1, context, self.store_api)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(image1.locations, [])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.store.ImageProxy(image_stub2, context, self.store_api)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub2.locations, [])",
            "        self.assertEqual(image2.locations, [])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations, [location2, location3])",
            "        self.assertEqual(image3.locations, [location2, location3])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "        self.assertEqual(image_stub3.locations[0], location2)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertTrue(location3 in image_stub3.locations)",
            "        self.assertFalse(location_bad in image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual(image_stub3.locations, [location3, location2])",
            "        self.assertEqual(image3.locations, [location3, location2])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.store.ImageProxy(self.image_stub,",
            "                                             {}, self.store_api)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.store.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.store_api)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}},",
            "                                     {'url': 'bar', 'metadata': {}}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual(self.store_api.acls['foo']['read'], [])",
            "        self.assertEqual(self.store_api.acls['foo']['write'], [])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual(self.store_api.acls['bar']['read'], [])",
            "        self.assertEqual(self.store_api.acls['bar']['write'], [])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(len(self.store_api.acls), 0)",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2, TENANT3])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT2])",
            "",
            "",
            "class TestImageFactory(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.image_factory = glance.store.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            unit_test_utils.FakeStoreAPI())",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertTrue(image.image_id is None)",
            "        self.assertTrue(image.status is None)",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.assertEqual(image.locations, [])",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(image.locations, locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance.store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance.store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       store)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mox",
            "",
            "from glance.common import exception",
            "import glance.store",
            "from glance.tests.unit import utils as unit_test_utils",
            "from glance.tests import utils",
            "",
            "",
            "BASE_URI = 'http://storeurl.com/container'",
            "UUID1 = 'c80a1a6c-bd1f-41c5-90ee-81afedb1d58d'",
            "UUID2 = '971ec09a-8067-4bc8-a91f-ae3557f1c4c7'",
            "USER1 = '54492ba0-f4df-4e4e-be62-27f4d76b29cf'",
            "TENANT1 = '6838eb7b-6ded-434a-882c-b344c77fe8df'",
            "TENANT2 = '2c014f32-55eb-467d-8fcb-4bd706012f81'",
            "TENANT3 = '228c6da5-29cd-4d67-9457-ed632e083fc0'",
            "",
            "",
            "class ImageRepoStub(object):",
            "    def add(self, image):",
            "        return image",
            "",
            "    def save(self, image, from_state=None):",
            "        return image",
            "",
            "",
            "class ImageStub(object):",
            "    def __init__(self, image_id, status=None, locations=None,",
            "                 visibility=None):",
            "        self.image_id = image_id",
            "        self.status = status",
            "        self.locations = locations or []",
            "        self.visibility = visibility",
            "        self.size = 1",
            "",
            "    def delete(self):",
            "        self.status = 'deleted'",
            "",
            "    def get_member_repo(self):",
            "        return FakeMemberRepo(self, [TENANT1, TENANT2])",
            "",
            "",
            "class ImageFactoryStub(object):",
            "    def new_image(self, image_id=None, name=None, visibility='private',",
            "                  min_disk=0, min_ram=0, protected=False, owner=None,",
            "                  disk_format=None, container_format=None,",
            "                  extra_properties=None, tags=None, **other_args):",
            "        return ImageStub(image_id, visibility=visibility, **other_args)",
            "",
            "",
            "class FakeMemberRepo(object):",
            "    def __init__(self, image, tenants=None):",
            "        self.image = image",
            "        self.factory = glance.domain.ImageMemberFactory()",
            "        self.tenants = tenants or []",
            "",
            "    def list(self, *args, **kwargs):",
            "        return [self.factory.new_image_member(self.image, tenant)",
            "                for tenant in self.tenants]",
            "",
            "    def add(self, member):",
            "        self.tenants.append(member.member_id)",
            "",
            "    def remove(self, member):",
            "        self.tenants.remove(member.member_id)",
            "",
            "",
            "class TestStoreImage(utils.BaseTestCase):",
            "    def setUp(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        self.image_stub = ImageStub(UUID1, 'active', locations)",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        super(TestStoreImage, self).setUp()",
            "",
            "    def test_image_delete(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        location = image.locations[0]",
            "        self.assertEqual(image.status, 'active')",
            "        self.store_api.get_from_backend({}, location['url'])",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {}, location['url'])",
            "",
            "    def test_image_get_data(self):",
            "        image = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image.get_data(), 'XXX')",
            "",
            "    def test_image_get_data_from_second_location(self):",
            "        def fake_get_from_backend(self, context, location):",
            "            if UUID1 in location:",
            "                raise Exception('not allow download from %s' % location)",
            "            else:",
            "                return self.data[location]",
            "",
            "        image1 = glance.store.ImageProxy(self.image_stub, {}, self.store_api)",
            "        self.assertEqual(image1.get_data(), 'XXX')",
            "        # Multiple location support",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image2, image_stub2) = self._add_image(context, UUID2, 'ZZZ', 3)",
            "        location_data = image2.locations[0]",
            "        image1.locations.append(location_data)",
            "        self.assertEqual(len(image1.locations), 2)",
            "        self.assertEqual(location_data['url'], UUID2)",
            "",
            "        self.stubs.Set(unit_test_utils.FakeStoreAPI, 'get_from_backend',",
            "                       fake_get_from_backend)",
            "        # This time, image1.get_data() returns the data wrapped in a",
            "        # LimitingReader|CooperativeReader pipeline, so peeking under",
            "        # the hood of those objects to get at the underlying string.",
            "        self.assertEqual(image1.get_data().data.fd, 'ZZZ')",
            "        image1.locations.pop(0)",
            "        self.assertEqual(len(image1.locations), 1)",
            "        image2.delete()",
            "",
            "    def test_image_set_data(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "",
            "    def test_image_set_data_location_metadata(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        loc_meta = {'key': 'value5032'}",
            "        store_api = unit_test_utils.FakeStoreAPI(store_metadata=loc_meta)",
            "        image = glance.store.ImageProxy(image_stub, context, store_api)",
            "        image.set_data('YYYY', 4)",
            "        self.assertEqual(image.size, 4)",
            "        location_data = image.locations[0]",
            "        self.assertEqual(location_data['url'], UUID2)",
            "        self.assertEqual(location_data['metadata'], loc_meta)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def test_image_set_data_unknown_size(self):",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub = ImageStub(UUID2, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub, context, self.store_api)",
            "        image.set_data('YYYY', None)",
            "        self.assertEqual(image.size, 4)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        self.assertEqual(image.locations[0]['url'], UUID2)",
            "        self.assertEqual(image.checksum, 'Z')",
            "        self.assertEqual(image.status, 'active')",
            "        image.delete()",
            "        self.assertEqual(image.status, 'deleted')",
            "        self.assertRaises(exception.NotFound,",
            "                          self.store_api.get_from_backend, {},",
            "                          image.locations[0]['url'])",
            "",
            "    def _add_image(self, context, image_id, data, len):",
            "        image_stub = ImageStub(image_id, status='queued', locations=[])",
            "        image = glance.store.ImageProxy(image_stub,",
            "                                        context, self.store_api)",
            "        image.set_data(data, len)",
            "        self.assertEqual(image.size, len)",
            "        #NOTE(markwash): FakeStore returns image_id for location",
            "        location = {'url': image_id, 'metadata': {}}",
            "        self.assertEqual(image.locations, [location])",
            "        self.assertEqual(image_stub.locations, [location])",
            "        self.assertEqual(image.status, 'active')",
            "        return (image, image_stub)",
            "",
            "    def test_image_change_append_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_invalid_location_metatdata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        # Using only one test rule here is enough to make sure",
            "        # 'store.check_location_metadata()' can be triggered",
            "        # in Location proxy layer. Complete test rule for",
            "        # 'store.check_location_metadata()' testing please",
            "        # check below cases within 'TestStoreMetaDataChecker'.",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.append, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_append_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_pop_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.append(location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.locations.pop()",
            "",
            "        self.assertEqual(image_stub1.locations, [location2])",
            "        self.assertEqual(image1.locations, [location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_extend_invalid_locations_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_invalid_locations_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.extend, [location_bad])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_extend_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "",
            "        self.assertEqual(image_stub1.locations, [location2, location3])",
            "        self.assertEqual(image1.locations, [location2, location3])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_remove_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image1.locations.extend([location3])",
            "        image1.locations.remove(location2)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3])",
            "        self.assertEqual(image1.locations, [location3])",
            "        self.assertRaises(ValueError,",
            "                          image1.locations.remove, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_delete_location(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        del image1.locations[0]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "",
            "    def test_image_change_insert_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_invalid_location_metadata(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location_bad = {'url': UUID3, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image1.locations.insert, 0, location_bad)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_insert_location(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "",
            "        self.assertEqual(image_stub1.locations, [location3, location2])",
            "        self.assertEqual(image1.locations, [location3, location2])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image2.delete()",
            "",
            "    def test_image_change_delete_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image1.locations.insert(0, location3)",
            "        del image1.locations[0:100]",
            "",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(len(image1.locations), 0)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.insert, 0, location2)",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image2.locations.insert, 0, location3)",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_uri(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        image_stub1 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image1 = glance.store.ImageProxy(image_stub1, context, self.store_api)",
            "",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          image1.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub1.locations, [])",
            "        self.assertEqual(image1.locations, [])",
            "",
            "        image1.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_invalid_location_metadata(self):",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "",
            "        image_stub2 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image2 = glance.store.ImageProxy(image_stub2, context, self.store_api)",
            "",
            "        location_bad = {'url': UUID2, 'metadata': \"a invalid metadata\"}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          image2.locations.__iadd__, [location_bad])",
            "        self.assertEqual(image_stub2.locations, [])",
            "        self.assertEqual(image2.locations, [])",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "",
            "    def test_image_change_adding_locations(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations, [location2, location3])",
            "        self.assertEqual(image3.locations, [location2, location3])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_get_location_by_index(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertEqual(image_stub3.locations.index(location3), 1)",
            "        self.assertEqual(image_stub3.locations[0], location2)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_checking_location_exists(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "",
            "        image3.locations += [location2, location3]",
            "",
            "        self.assertTrue(location3 in image_stub3.locations)",
            "        self.assertFalse(location_bad in image_stub3.locations)",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "    def test_image_reverse_locations_order(self):",
            "        UUID3 = 'a8a61ec4-d7a3-11e2-8c28-000c29c27581'",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "",
            "        context = glance.context.RequestContext(user=USER1)",
            "        (image1, image_stub1) = self._add_image(context, UUID2, 'XXXX', 4)",
            "        (image2, image_stub2) = self._add_image(context, UUID3, 'YYYY', 4)",
            "",
            "        location2 = {'url': UUID2, 'metadata': {}}",
            "        location3 = {'url': UUID3, 'metadata': {}}",
            "",
            "        image_stub3 = ImageStub('fake_image_id', status='queued', locations=[])",
            "        image3 = glance.store.ImageProxy(image_stub3, context, self.store_api)",
            "        image3.locations += [location2, location3]",
            "",
            "        image_stub3.locations.reverse()",
            "",
            "        self.assertEqual(image_stub3.locations, [location3, location2])",
            "        self.assertEqual(image3.locations, [location3, location2])",
            "",
            "        image3.delete()",
            "",
            "        self.assertEqual(len(self.store_api.data.keys()), 2)",
            "        self.assertFalse(UUID2 in self.store_api.data.keys())",
            "        self.assertFalse(UUID3 in self.store_api.data.keys())",
            "",
            "        image1.delete()",
            "        image2.delete()",
            "",
            "",
            "class TestStoreImageRepo(utils.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestStoreImageRepo, self).setUp()",
            "        self.store_api = unit_test_utils.FakeStoreAPI()",
            "        self.image_stub = ImageStub(UUID1)",
            "        self.image = glance.store.ImageProxy(self.image_stub,",
            "                                             {}, self.store_api)",
            "        self.image_repo_stub = ImageRepoStub()",
            "        self.image_repo = glance.store.ImageRepoProxy(self.image_repo_stub,",
            "                                                      {}, self.store_api)",
            "",
            "    def test_add_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}},",
            "                                     {'url': 'bar', 'metadata': {}}]",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertTrue(self.store_api.acls['foo']['public'])",
            "        self.assertEqual(self.store_api.acls['foo']['read'], [])",
            "        self.assertEqual(self.store_api.acls['foo']['write'], [])",
            "        self.assertTrue(self.store_api.acls['bar']['public'])",
            "        self.assertEqual(self.store_api.acls['bar']['read'], [])",
            "        self.assertEqual(self.store_api.acls['bar']['write'], [])",
            "",
            "    def test_add_ignores_acls_if_no_locations(self):",
            "        self.image_stub.locations = []",
            "        self.image_stub.visibility = 'public'",
            "        self.image_repo.add(self.image)",
            "        self.assertEqual(len(self.store_api.acls), 0)",
            "",
            "    def test_save_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'foo', 'metadata': {}}]",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('foo', self.store_api.acls)",
            "",
            "    def test_add_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.add(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_save_fetches_members_if_private(self):",
            "        self.image_stub.locations = [{'url': 'glue', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        self.image_repo.save(self.image)",
            "        self.assertIn('glue', self.store_api.acls)",
            "        acls = self.store_api.acls['glue']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2])",
            "",
            "    def test_member_addition_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT3, None, None, status='accepted')",
            "        member_repo.add(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT1, TENANT2, TENANT3])",
            "",
            "    def test_member_removal_updates_acls(self):",
            "        self.image_stub.locations = [{'url': 'glug', 'metadata': {}}]",
            "        self.image_stub.visibility = 'private'",
            "        member_repo = self.image.get_member_repo()",
            "        membership = glance.domain.ImageMembership(",
            "            UUID1, TENANT1, None, None, status='accepted')",
            "        member_repo.remove(membership)",
            "        self.assertIn('glug', self.store_api.acls)",
            "        acls = self.store_api.acls['glug']",
            "        self.assertFalse(acls['public'])",
            "        self.assertEqual(acls['write'], [])",
            "        self.assertEqual(acls['read'], [TENANT2])",
            "",
            "",
            "class TestImageFactory(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageFactory, self).setUp()",
            "        self.image_factory = glance.store.ImageFactoryProxy(",
            "            ImageFactoryStub(),",
            "            glance.context.RequestContext(user=USER1),",
            "            unit_test_utils.FakeStoreAPI())",
            "",
            "    def test_new_image(self):",
            "        image = self.image_factory.new_image()",
            "        self.assertTrue(image.image_id is None)",
            "        self.assertTrue(image.status is None)",
            "        self.assertEqual(image.visibility, 'private')",
            "        self.assertEqual(image.locations, [])",
            "",
            "    def test_new_image_with_location(self):",
            "        locations = [{'url': '%s/%s' % (BASE_URI, UUID1),",
            "                      'metadata': {}}]",
            "        image = self.image_factory.new_image(locations=locations)",
            "        self.assertEqual(image.locations, locations)",
            "        location_bad = {'url': 'unknown://location', 'metadata': {}}",
            "        self.assertRaises(exception.BadStoreUri,",
            "                          self.image_factory.new_image,",
            "                          locations=[location_bad])",
            "",
            "",
            "class TestStoreMetaDataChecker(utils.BaseTestCase):",
            "",
            "    def test_empty(self):",
            "        glance.store.check_location_metadata({})",
            "",
            "    def test_unicode(self):",
            "        m = {'key': u'somevalue'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        glance.store.check_location_metadata(m)",
            "",
            "    def test_simple_bad(self):",
            "        m = {'key1': object()}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_list_bad(self):",
            "        m = {'key1': [u'somevalue', object()]}",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "    def test_nested_dict_bad(self):",
            "        inner = {'key1': u'somevalue', 'key2': object()}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.check_location_metadata,",
            "                          m)",
            "",
            "",
            "class TestStoreAddToBackend(utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestStoreAddToBackend, self).setUp()",
            "        self.image_id = \"animage\"",
            "        self.data = \"dataandstuff\"",
            "        self.size = len(self.data)",
            "        self.location = \"file:///ab/cde/fgh\"",
            "        self.checksum = \"md5\"",
            "        self.mox = mox.Mox()",
            "",
            "    def tearDown(self):",
            "        super(TestStoreAddToBackend, self).tearDown()",
            "        self.mox.UnsetStubs()",
            "",
            "    def _bad_metadata(self, in_metadata):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()",
            "",
            "    def _good_metadata(self, in_metadata):",
            "",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, in_metadata))",
            "",
            "        self.mox.ReplayAll()",
            "        (location,",
            "         size,",
            "         checksum,",
            "         metadata) = glance.store.store_add_to_backend(self.image_id,",
            "                                                       self.data,",
            "                                                       self.size,",
            "                                                       store)",
            "        self.mox.VerifyAll()",
            "        self.assertEqual(self.location, location)",
            "        self.assertEqual(self.size, size)",
            "        self.assertEqual(self.checksum, checksum)",
            "        self.assertEqual(in_metadata, metadata)",
            "",
            "    def test_empty(self):",
            "        metadata = {}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_string(self):",
            "        metadata = {'key': u'somevalue'}",
            "        self._good_metadata(metadata)",
            "",
            "    def test_list(self):",
            "        m = {'key': [u'somevalue', u'2']}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_unicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._good_metadata(m)",
            "",
            "    def test_nested_dict(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue'}",
            "        inner = {'newkey': inner}",
            "        inner = {'anotherkey': inner}",
            "        m = {'topkey': inner}",
            "        self._good_metadata(m)",
            "",
            "    def test_bad_top_level_nonunicode(self):",
            "        metadata = {'key': 'a string'}",
            "        self._bad_metadata(metadata)",
            "",
            "    def test_bad_nonunicode_dict_list(self):",
            "        inner = {'key1': u'somevalue', 'key2': u'somevalue',",
            "                 'k3': [1, object()]}",
            "        m = {'topkey': inner, 'list': [u'somevalue', u'2'], 'u': u'2'}",
            "        self._bad_metadata(m)",
            "",
            "    def test_bad_metadata_not_dict(self):",
            "        store = self.mox.CreateMockAnything()",
            "        store.add(self.image_id, mox.IgnoreArg(), self.size).AndReturn(",
            "            (self.location, self.size, self.checksum, []))",
            "        store.__str__ = lambda: \"hello\"",
            "        store.__unicode__ = lambda: \"hello\"",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(glance.store.BackendException,",
            "                          glance.store.store_add_to_backend,",
            "                          self.image_id,",
            "                          self.data,",
            "                          self.size,",
            "                          store)",
            "        self.mox.VerifyAll()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "36": [
                "ImageRepoStub",
                "save"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/v1/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1583,
                "afterPatchRowNumber": 1583,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1584,
                "afterPatchRowNumber": 1584,
                "PatchRowcode": "         self.assertEqual(1, mock_store_add_to_backend.call_count)"
            },
            "2": {
                "beforePatchRowNumber": 1585,
                "afterPatchRowNumber": 1585,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1586,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_delete_during_image_upload(self):"
            },
            "4": {
                "beforePatchRowNumber": 1587,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = unit_test_utils.get_fake_request()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1586,
                "PatchRowcode": "+    def _check_delete_during_image_upload(self, is_admin=False):"
            },
            "6": {
                "beforePatchRowNumber": 1588,
                "afterPatchRowNumber": 1587,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 1589,
                "afterPatchRowNumber": 1588,
                "PatchRowcode": "         fixture_headers = {'x-image-meta-store': 'file',"
            },
            "8": {
                "beforePatchRowNumber": 1590,
                "afterPatchRowNumber": 1589,
                "PatchRowcode": "                            'x-image-meta-disk-format': 'vhd',"
            },
            "9": {
                "beforePatchRowNumber": 1618,
                "afterPatchRowNumber": 1617,
                "PatchRowcode": "                        mock_initiate_deletion)"
            },
            "10": {
                "beforePatchRowNumber": 1619,
                "afterPatchRowNumber": 1618,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 1620,
                "afterPatchRowNumber": 1619,
                "PatchRowcode": "         orig_update_image_metadata = registry.update_image_metadata"
            },
            "12": {
                "beforePatchRowNumber": 1621,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ctlr = glance.api.v1.controller.BaseController"
            },
            "13": {
                "beforePatchRowNumber": 1622,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404"
            },
            "14": {
                "beforePatchRowNumber": 1623,
                "afterPatchRowNumber": 1620,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 1624,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        def mock_update_image_metadata(*args, **kwargs):"
            },
            "16": {
                "beforePatchRowNumber": 1625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 1626,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if args[2].get('status', None) == 'deleted':"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1621,
                "PatchRowcode": "+        data = \"somedata\""
            },
            "19": {
                "beforePatchRowNumber": 1627,
                "afterPatchRowNumber": 1622,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 1628,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # One shot."
            },
            "21": {
                "beforePatchRowNumber": 1629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                def mock_get_image_meta_or_404(*args, **kwargs):"
            },
            "22": {
                "beforePatchRowNumber": 1630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ret = orig_get_image_meta_or_404(*args, **kwargs)"
            },
            "23": {
                "beforePatchRowNumber": 1631,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ret['status'] = 'queued'"
            },
            "24": {
                "beforePatchRowNumber": 1632,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self.stubs.Set(ctlr, 'get_image_meta_or_404',"
            },
            "25": {
                "beforePatchRowNumber": 1633,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   orig_get_image_meta_or_404)"
            },
            "26": {
                "beforePatchRowNumber": 1634,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return ret"
            },
            "27": {
                "beforePatchRowNumber": 1635,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "28": {
                "beforePatchRowNumber": 1636,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.stubs.Set(ctlr, 'get_image_meta_or_404',"
            },
            "29": {
                "beforePatchRowNumber": 1637,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                               mock_get_image_meta_or_404)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1623,
                "PatchRowcode": "+        def mock_update_image_metadata(*args, **kwargs):"
            },
            "31": {
                "beforePatchRowNumber": 1638,
                "afterPatchRowNumber": 1624,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 1639,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "33": {
                "beforePatchRowNumber": 1640,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.method = 'PUT'"
            },
            "34": {
                "beforePatchRowNumber": 1641,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.headers['Content-Type'] = 'application/octet-stream'"
            },
            "35": {
                "beforePatchRowNumber": 1642,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req.body = \"somedata\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1625,
                "PatchRowcode": "+            if args[2].get('size', None) == len(data):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1626,
                "PatchRowcode": "+                path = \"/images/%s\" % image_id"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1627,
                "PatchRowcode": "+                req = unit_test_utils.get_fake_request(path=path,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1628,
                "PatchRowcode": "+                                                       method='DELETE',"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1629,
                "PatchRowcode": "+                                                       is_admin=is_admin)"
            },
            "41": {
                "beforePatchRowNumber": 1643,
                "afterPatchRowNumber": 1630,
                "PatchRowcode": "                 res = req.get_response(self.api)"
            },
            "42": {
                "beforePatchRowNumber": 1644,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertEqual(res.status_int, 200)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1631,
                "PatchRowcode": "+                self.assertEqual(200, res.status_int)"
            },
            "44": {
                "beforePatchRowNumber": 1645,
                "afterPatchRowNumber": 1632,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 1646,
                "afterPatchRowNumber": 1633,
                "PatchRowcode": "                 self.stubs.Set(registry, 'update_image_metadata',"
            },
            "46": {
                "beforePatchRowNumber": 1647,
                "afterPatchRowNumber": 1634,
                "PatchRowcode": "                                orig_update_image_metadata)"
            },
            "47": {
                "beforePatchRowNumber": 1651,
                "afterPatchRowNumber": 1638,
                "PatchRowcode": "         self.stubs.Set(registry, 'update_image_metadata',"
            },
            "48": {
                "beforePatchRowNumber": 1652,
                "afterPatchRowNumber": 1639,
                "PatchRowcode": "                        mock_update_image_metadata)"
            },
            "49": {
                "beforePatchRowNumber": 1653,
                "afterPatchRowNumber": 1640,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 1654,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "51": {
                "beforePatchRowNumber": 1655,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'DELETE'"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1641,
                "PatchRowcode": "+        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1642,
                "PatchRowcode": "+                                               method='PUT')"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1643,
                "PatchRowcode": "+        req.headers['Content-Type'] = 'application/octet-stream'"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1644,
                "PatchRowcode": "+        req.body = data"
            },
            "56": {
                "beforePatchRowNumber": 1656,
                "afterPatchRowNumber": 1645,
                "PatchRowcode": "         res = req.get_response(self.api)"
            },
            "57": {
                "beforePatchRowNumber": 1657,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(res.status_int, 200)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1646,
                "PatchRowcode": "+        self.assertEqual(412, res.status_int)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1647,
                "PatchRowcode": "+        self.assertFalse(res.location)"
            },
            "60": {
                "beforePatchRowNumber": 1658,
                "afterPatchRowNumber": 1648,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 1659,
                "afterPatchRowNumber": 1649,
                "PatchRowcode": "         self.assertTrue(called['initiate_deletion'])"
            },
            "62": {
                "beforePatchRowNumber": 1660,
                "afterPatchRowNumber": 1650,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 1661,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images/%s\" % image_id)"
            },
            "64": {
                "beforePatchRowNumber": 1662,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'HEAD'"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1651,
                "PatchRowcode": "+        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1652,
                "PatchRowcode": "+                                               method='HEAD',"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1653,
                "PatchRowcode": "+                                               is_admin=True)"
            },
            "68": {
                "beforePatchRowNumber": 1663,
                "afterPatchRowNumber": 1654,
                "PatchRowcode": "         res = req.get_response(self.api)"
            },
            "69": {
                "beforePatchRowNumber": 1664,
                "afterPatchRowNumber": 1655,
                "PatchRowcode": "         self.assertEqual(res.status_int, 200)"
            },
            "70": {
                "beforePatchRowNumber": 1665,
                "afterPatchRowNumber": 1656,
                "PatchRowcode": "         self.assertEqual(res.headers['x-image-meta-deleted'], 'True')"
            },
            "71": {
                "beforePatchRowNumber": 1666,
                "afterPatchRowNumber": 1657,
                "PatchRowcode": "         self.assertEqual(res.headers['x-image-meta-status'], 'deleted')"
            },
            "72": {
                "beforePatchRowNumber": 1667,
                "afterPatchRowNumber": 1658,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1659,
                "PatchRowcode": "+    def test_delete_during_image_upload_by_normal_user(self):"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1660,
                "PatchRowcode": "+        self._check_delete_during_image_upload(is_admin=False)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1661,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1662,
                "PatchRowcode": "+    def test_delete_during_image_upload_by_admin(self):"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1663,
                "PatchRowcode": "+        self._check_delete_during_image_upload(is_admin=True)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1664,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": 1668,
                "afterPatchRowNumber": 1665,
                "PatchRowcode": "     def test_disable_purge_props(self):"
            },
            "80": {
                "beforePatchRowNumber": 1669,
                "afterPatchRowNumber": 1666,
                "PatchRowcode": "         \"\"\""
            },
            "81": {
                "beforePatchRowNumber": 1670,
                "afterPatchRowNumber": 1667,
                "PatchRowcode": "         Test the special x-glance-registry-purge-props header controls"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import mock",
            "from oslo.config import cfg",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import timeutils",
            "",
            "import glance.registry.client.v1.api as registry",
            "import glance.store.filesystem",
            "from glance.store import http",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body, res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue(expected in res.body, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Required store bad is invalid' in res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('External sourcing not supported' in res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'swift',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 413)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertTrue(expected_substr in res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertFalse('location' in res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertFalse('locations' in res_body)",
            "        self.assertFalse('direct_url' in res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('x-image-meta-locations' in res.headers)",
            "        self.assertFalse('x-image-meta-direct_url' in res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 0)",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertTrue('/images/%s' % res_body['id']",
            "                        in res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in fixture_headers.iteritems():",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to update deleted image' in res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertTrue(msg in res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    @mock.patch.object(glance.store.filesystem.Store, 'delete')",
            "    def test_image_status_when_delete_fails(self, mock_fsstore_delete):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "        mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "        # trigger the v1 delete api",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "        # check image metadata is still there with active state",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete a pending_delete image'",
            "                        in res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = \\",
            "            'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(upload_utils, 'initiate_deletion') as \\",
            "                mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(registry, 'get_image_metadata') as \\",
            "                    mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(db_api, '_image_update') as \\",
            "                            mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(res.status_int, 409)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(res.headers['x-image-meta-status'], status)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'],",
            "                         str(check_deleted))",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def test_delete_during_image_upload(self):",
            "        req = unit_test_utils.get_fake_request()",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "        ctlr = glance.api.v1.controller.BaseController",
            "        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('status', None) == 'deleted':",
            "",
            "                # One shot.",
            "                def mock_get_image_meta_or_404(*args, **kwargs):",
            "                    ret = orig_get_image_meta_or_404(*args, **kwargs)",
            "                    ret['status'] = 'queued'",
            "                    self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                                   orig_get_image_meta_or_404)",
            "                    return ret",
            "",
            "                self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                               mock_get_image_meta_or_404)",
            "",
            "                req = webob.Request.blank(\"/images/%s\" % image_id)",
            "                req.method = 'PUT'",
            "                req.headers['Content-Type'] = 'application/octet-stream'",
            "                req.body = \"somedata\"",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID3)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "        self.assertEqual(images[2]['id'], UUID4)",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "        self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(len(images), 3)",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertFalse('location' in res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in headers.iteritems():",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.content_type, 'application/octet-stream')",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.body, '')",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 403)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(len(memb_list), 1)",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(len(original_members), 1)",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, original_members)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, fixture)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        self.assertTrue('Forbidden' in res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': unicode(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': unicode(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(response.headers['x-image-meta-name'].decode('utf-8'),",
            "                         FIXTURE['image_meta']['name'])",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual(response.body, 'chunk67891123456789')",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        #just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        #expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "        self.assertEqual(image_meta, redacted_image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_create_prop_policy'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_default_policy'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_read_prop'], 'foo')",
            "        self.assertEqual(output.status_int, 200)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(output.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-spl_update_prop'], 'foo')",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual(res_body['properties']['spl_read_only_prop'], '1')",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-x_all_permitted'], '1')",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '2')",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "        self.assertEqual(res_body['properties']['x_all_permitted_create'], '3')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import mock",
            "from oslo.config import cfg",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import timeutils",
            "",
            "import glance.registry.client.v1.api as registry",
            "import glance.store.filesystem",
            "from glance.store import http",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body, res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue(expected in res.body, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Required store bad is invalid' in res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('External sourcing not supported' in res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'swift',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 413)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertTrue(expected_substr in res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertFalse('location' in res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertFalse('locations' in res_body)",
            "        self.assertFalse('direct_url' in res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('x-image-meta-locations' in res.headers)",
            "        self.assertFalse('x-image-meta-direct_url' in res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 0)",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertTrue('/images/%s' % res_body['id']",
            "                        in res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in fixture_headers.iteritems():",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to update deleted image' in res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertTrue(msg in res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    @mock.patch.object(glance.store.filesystem.Store, 'delete')",
            "    def test_image_status_when_delete_fails(self, mock_fsstore_delete):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "        mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "        # trigger the v1 delete api",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "        # check image metadata is still there with active state",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete a pending_delete image'",
            "                        in res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = \\",
            "            'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(upload_utils, 'initiate_deletion') as \\",
            "                mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(registry, 'get_image_metadata') as \\",
            "                    mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(db_api, '_image_update') as \\",
            "                            mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(res.status_int, 409)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(res.headers['x-image-meta-status'], status)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'],",
            "                         str(check_deleted))",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def _check_delete_during_image_upload(self, is_admin=False):",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "",
            "        data = \"somedata\"",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('size', None) == len(data):",
            "                path = \"/images/%s\" % image_id",
            "                req = unit_test_utils.get_fake_request(path=path,",
            "                                                       method='DELETE',",
            "                                                       is_admin=is_admin)",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(200, res.status_int)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,",
            "                                               method='PUT')",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = data",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(412, res.status_int)",
            "        self.assertFalse(res.location)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = unit_test_utils.get_fake_request(path=\"/images/%s\" % image_id,",
            "                                               method='HEAD',",
            "                                               is_admin=True)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_during_image_upload_by_normal_user(self):",
            "        self._check_delete_during_image_upload(is_admin=False)",
            "",
            "    def test_delete_during_image_upload_by_admin(self):",
            "        self._check_delete_during_image_upload(is_admin=True)",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID3)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "        self.assertEqual(images[2]['id'], UUID4)",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "        self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(len(images), 3)",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertFalse('location' in res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in headers.iteritems():",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.content_type, 'application/octet-stream')",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.body, '')",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 403)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(len(memb_list), 1)",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(len(original_members), 1)",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, original_members)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, fixture)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        self.assertTrue('Forbidden' in res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': unicode(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': unicode(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(response.headers['x-image-meta-name'].decode('utf-8'),",
            "                         FIXTURE['image_meta']['name'])",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual(response.body, 'chunk67891123456789')",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        #just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        #expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "        self.assertEqual(image_meta, redacted_image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_create_prop_policy'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_default_policy'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_read_prop'], 'foo')",
            "        self.assertEqual(output.status_int, 200)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(output.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-spl_update_prop'], 'foo')",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual(res_body['properties']['spl_read_only_prop'], '1')",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-x_all_permitted'], '1')",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '2')",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "        self.assertEqual(res_body['properties']['x_all_permitted_create'], '3')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1586": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1587": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1621": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1622": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1624": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1625": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1626": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1628": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1629": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1630": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1631": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1632": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1633": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1634": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata",
                "mock_get_image_meta_or_404"
            ],
            "1635": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1636": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1637": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1639": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1640": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1641": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1642": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1644": [
                "TestGlanceAPI",
                "test_delete_during_image_upload",
                "mock_update_image_metadata"
            ],
            "1654": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1655": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1657": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1661": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ],
            "1662": [
                "TestGlanceAPI",
                "test_delete_during_image_upload"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/v2/test_image_data_resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         else:"
            },
            "1": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "             return self.result"
            },
            "2": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def save(self, image):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    def save(self, image, from_state=None):"
            },
            "5": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.saved_image = image"
            },
            "6": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "                           request, unit_test_utils.UUID1, 'YYYY', 4)"
            },
            "9": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     def test_upload_non_existent_image_during_save_initiates_deletion(self):"
            },
            "11": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        def fake_save(self):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        def fake_save_not_found(self):"
            },
            "13": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             raise exception.NotFound()"
            },
            "14": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        request = unit_test_utils.get_fake_request()"
            },
            "16": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        image = FakeImage('abcd', locations=['http://example.com/image'])"
            },
            "17": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo.result = image"
            },
            "18": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.image_repo.save = fake_save"
            },
            "19": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        image.delete = mock.Mock()"
            },
            "20": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertRaises(webob.exc.HTTPGone, self.controller.upload,"
            },
            "21": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          request, str(uuid.uuid4()), 'ABC', 3)"
            },
            "22": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertTrue(image.delete.called)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        def fake_save_conflict(self):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            raise exception.Conflict()"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        for fun in [fake_save_not_found, fake_save_conflict]:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            request = unit_test_utils.get_fake_request()"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+            image = FakeImage('abcd', locations=['http://example.com/image'])"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            self.image_repo.result = image"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            self.image_repo.save = fun"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            image.delete = mock.Mock()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            self.assertRaises(webob.exc.HTTPGone, self.controller.upload,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                              request, str(uuid.uuid4()), 'ABC', 3)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            self.assertTrue(image.delete.called)"
            },
            "35": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     def test_upload_non_existent_image_before_save(self):"
            },
            "37": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         request = unit_test_utils.get_fake_request()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "import uuid",
            "",
            "import six",
            "import webob",
            "",
            "import glance.api.v2.image_data",
            "from glance.common import exception",
            "",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "class Raise(object):",
            "    def __init__(self, exc):",
            "        self.exc = exc",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        raise self.exc",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, image_id=None, data=None, checksum=None, size=0,",
            "                 virtual_size=0, locations=None, container_format='bear',",
            "                 disk_format='rawr', status=None):",
            "        self.image_id = image_id",
            "        self.data = data",
            "        self.checksum = checksum",
            "        self.size = size",
            "        self.virtual_size = virtual_size",
            "        self.locations = locations",
            "        self.container_format = container_format",
            "        self.disk_format = disk_format",
            "        self._status = status",
            "",
            "    @property",
            "    def status(self):",
            "        return self._status",
            "",
            "    @status.setter",
            "    def status(self, value):",
            "        if isinstance(self._status, BaseException):",
            "            raise self._status",
            "        else:",
            "            self._status = value",
            "",
            "    def get_data(self):",
            "        return self.data",
            "",
            "    def set_data(self, data, size=None):",
            "        self.data = ''.join(data)",
            "        self.size = size",
            "        self.status = 'modified-by-fake'",
            "",
            "",
            "class FakeImageRepo(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get(self, image_id):",
            "        if isinstance(self.result, BaseException):",
            "            raise self.result",
            "        else:",
            "            return self.result",
            "",
            "    def save(self, image):",
            "        self.saved_image = image",
            "",
            "",
            "class FakeGateway(object):",
            "    def __init__(self, repo):",
            "        self.repo = repo",
            "",
            "    def get_repo(self, context):",
            "        return self.repo",
            "",
            "",
            "class TestImagesController(base.StoreClearingUnitTest):",
            "    def setUp(self):",
            "        super(TestImagesController, self).setUp()",
            "",
            "        self.config(verbose=True, debug=True)",
            "        self.image_repo = FakeImageRepo()",
            "        self.gateway = FakeGateway(self.image_repo)",
            "        self.controller = glance.api.v2.image_data.ImageDataController(",
            "            gateway=self.gateway)",
            "",
            "    def test_download(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd', locations=['http://example.com/image'])",
            "        self.image_repo.result = image",
            "        image = self.controller.download(request, unit_test_utils.UUID1)",
            "        self.assertEqual(image.image_id, 'abcd')",
            "",
            "    def test_download_no_location(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = FakeImage('abcd')",
            "        self.assertRaises(webob.exc.HTTPNoContent, self.controller.download,",
            "                          request, unit_test_utils.UUID2)",
            "",
            "    def test_download_non_existent_image(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.NotFound()",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_download_forbidden(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.Forbidden()",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_download_get_image_location_forbidden(self):",
            "        class ImageLocations(object):",
            "            def __len__(self):",
            "                raise exception.Forbidden()",
            "",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        image.locations = ImageLocations()",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_upload(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        self.assertEqual(image.data, 'YYYY')",
            "        self.assertEqual(image.size, 4)",
            "",
            "    def test_upload_status(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        insurance = {'called': False}",
            "",
            "        def read_data():",
            "            insurance['called'] = True",
            "            self.assertEqual(self.image_repo.saved_image.status, 'saving')",
            "            yield 'YYYY'",
            "",
            "        self.controller.upload(request, unit_test_utils.UUID2,",
            "                               read_data(), None)",
            "        self.assertTrue(insurance['called'])",
            "        self.assertEqual(self.image_repo.saved_image.status,",
            "                         'modified-by-fake')",
            "",
            "    def test_upload_no_size(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', None)",
            "        self.assertEqual(image.data, 'YYYY')",
            "        self.assertIsNone(image.size)",
            "",
            "    def test_upload_invalid(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        image.status = ValueError()",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYY', 4)",
            "",
            "    def test_upload_non_existent_image_during_save_initiates_deletion(self):",
            "        def fake_save(self):",
            "            raise exception.NotFound()",
            "",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd', locations=['http://example.com/image'])",
            "        self.image_repo.result = image",
            "        self.image_repo.save = fake_save",
            "        image.delete = mock.Mock()",
            "        self.assertRaises(webob.exc.HTTPGone, self.controller.upload,",
            "                          request, str(uuid.uuid4()), 'ABC', 3)",
            "        self.assertTrue(image.delete.called)",
            "",
            "    def test_upload_non_existent_image_before_save(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.NotFound()",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.upload,",
            "                          request, str(uuid.uuid4()), 'ABC', 3)",
            "",
            "    def test_upload_data_exists(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        exc = exception.InvalidImageStatusTransition(cur_status='active',",
            "                                                     new_status='queued')",
            "        image.set_data = Raise(exc)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPConflict, self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYY', 4)",
            "",
            "    def test_upload_storage_full(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.StorageFull)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YYYYYYY', 7)",
            "",
            "    def test_image_size_limit_exceeded(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.ImageSizeLimitExceeded)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYYYYY', 7)",
            "",
            "    def test_upload_storage_forbidden(self):",
            "        request = unit_test_utils.get_fake_request(user=unit_test_utils.USER2)",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.Forbidden)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YY', 2)",
            "",
            "    def test_upload_storage_write_denied(self):",
            "        request = unit_test_utils.get_fake_request(user=unit_test_utils.USER3)",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.StorageWriteDenied)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPServiceUnavailable,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YY', 2)",
            "",
            "    def _test_upload_download_prepare_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        prepare_payload = output['meta'].copy()",
            "        prepare_payload['checksum'] = None",
            "        prepare_payload['size'] = None",
            "        prepare_payload['virtual_size'] = None",
            "        prepare_payload['location'] = None",
            "        prepare_payload['status'] = 'queued'",
            "        del prepare_payload['updated_at']",
            "        prepare_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.prepare\",",
            "            'payload': prepare_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        prepare_updated_at = output_log[0]['payload']['updated_at']",
            "        del output_log[0]['payload']['updated_at']",
            "        self.assertTrue(prepare_updated_at <= output['meta']['updated_at'])",
            "        self.assertEqual(output_log[0], prepare_log)",
            "",
            "    def _test_upload_download_upload_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        upload_payload = output['meta'].copy()",
            "        upload_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.upload\",",
            "            'payload': upload_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        self.assertEqual(output_log[1], upload_log)",
            "",
            "    def _test_upload_download_activate_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        activate_payload = output['meta'].copy()",
            "        activate_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.activate\",",
            "            'payload': activate_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        self.assertEqual(output_log[2], activate_log)",
            "",
            "    def test_restore_image_when_upload_failed(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('fake')",
            "        image.set_data = Raise(exception.StorageWriteDenied)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPServiceUnavailable,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'ZZZ', 3)",
            "        self.assertEqual(self.image_repo.saved_image.status, 'queued')",
            "",
            "",
            "class TestImageDataDeserializer(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageDataDeserializer, self).setUp()",
            "        self.deserializer = glance.api.v2.image_data.RequestDeserializer()",
            "",
            "    def test_upload(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        request.body = 'YYY'",
            "        request.headers['Content-Length'] = 3",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 3}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_chunked(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        # If we use body_file, webob assumes we want to do a chunked upload,",
            "        # ignoring the Content-Length header",
            "        request.body_file = six.StringIO('YYY')",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': None}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_chunked_with_content_length(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        request.body_file = six.StringIO('YYY')",
            "        # The deserializer shouldn't care if the Content-Length is",
            "        # set when the user is attempting to send chunked data.",
            "        request.headers['Content-Length'] = 3",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 3}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_with_incorrect_content_length(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        # The deserializer shouldn't care if the Content-Length and",
            "        # actual request body length differ. That job is left up",
            "        # to the controller",
            "        request.body = 'YYY'",
            "        request.headers['Content-Length'] = 4",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 4}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_wrong_content_type(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/json'",
            "        request.body = 'YYYYY'",
            "        self.assertRaises(webob.exc.HTTPUnsupportedMediaType,",
            "                          self.deserializer.upload, request)",
            "",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-st'",
            "        request.body = 'YYYYY'",
            "        self.assertRaises(webob.exc.HTTPUnsupportedMediaType,",
            "                          self.deserializer.upload, request)",
            "",
            "",
            "class TestImageDataSerializer(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageDataSerializer, self).setUp()",
            "        self.serializer = glance.api.v2.image_data.ResponseSerializer()",
            "",
            "    def test_download(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        image = FakeImage(size=3, data=iter('ZZZ'))",
            "        self.serializer.download(response, image)",
            "        self.assertEqual('ZZZ', response.body)",
            "        self.assertEqual('3', response.headers['Content-Length'])",
            "        self.assertFalse('Content-MD5' in response.headers)",
            "        self.assertEqual('application/octet-stream',",
            "                         response.headers['Content-Type'])",
            "",
            "    def test_download_with_checksum(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        checksum = '0745064918b49693cca64d6b6a13d28a'",
            "        image = FakeImage(size=3, checksum=checksum, data=iter('ZZZ'))",
            "        self.serializer.download(response, image)",
            "        self.assertEqual('ZZZ', response.body)",
            "        self.assertEqual('3', response.headers['Content-Length'])",
            "        self.assertEqual(checksum, response.headers['Content-MD5'])",
            "        self.assertEqual('application/octet-stream',",
            "                         response.headers['Content-Type'])",
            "",
            "    def test_download_forbidden(self):",
            "        \"\"\"Make sure the serializer can return 403 forbidden error instead of",
            "        500 internal server error.",
            "        \"\"\"",
            "        def get_data():",
            "            raise exception.Forbidden()",
            "",
            "        self.stubs.Set(glance.api.policy.ImageProxy,",
            "                       'get_data',",
            "                       get_data)",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        image = FakeImage(size=3, data=iter('ZZZ'))",
            "        image.get_data = get_data",
            "        self.assertRaises(webob.exc.HTTPForbidden,",
            "                          self.serializer.download,",
            "                          response, image)",
            "",
            "    def test_upload(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        self.serializer.upload(response, {})",
            "        self.assertEqual(204, response.status_int)",
            "        self.assertEqual('0', response.headers['Content-Length'])"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "import uuid",
            "",
            "import six",
            "import webob",
            "",
            "import glance.api.v2.image_data",
            "from glance.common import exception",
            "",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "class Raise(object):",
            "    def __init__(self, exc):",
            "        self.exc = exc",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        raise self.exc",
            "",
            "",
            "class FakeImage(object):",
            "    def __init__(self, image_id=None, data=None, checksum=None, size=0,",
            "                 virtual_size=0, locations=None, container_format='bear',",
            "                 disk_format='rawr', status=None):",
            "        self.image_id = image_id",
            "        self.data = data",
            "        self.checksum = checksum",
            "        self.size = size",
            "        self.virtual_size = virtual_size",
            "        self.locations = locations",
            "        self.container_format = container_format",
            "        self.disk_format = disk_format",
            "        self._status = status",
            "",
            "    @property",
            "    def status(self):",
            "        return self._status",
            "",
            "    @status.setter",
            "    def status(self, value):",
            "        if isinstance(self._status, BaseException):",
            "            raise self._status",
            "        else:",
            "            self._status = value",
            "",
            "    def get_data(self):",
            "        return self.data",
            "",
            "    def set_data(self, data, size=None):",
            "        self.data = ''.join(data)",
            "        self.size = size",
            "        self.status = 'modified-by-fake'",
            "",
            "",
            "class FakeImageRepo(object):",
            "    def __init__(self, result=None):",
            "        self.result = result",
            "",
            "    def get(self, image_id):",
            "        if isinstance(self.result, BaseException):",
            "            raise self.result",
            "        else:",
            "            return self.result",
            "",
            "    def save(self, image, from_state=None):",
            "        self.saved_image = image",
            "",
            "",
            "class FakeGateway(object):",
            "    def __init__(self, repo):",
            "        self.repo = repo",
            "",
            "    def get_repo(self, context):",
            "        return self.repo",
            "",
            "",
            "class TestImagesController(base.StoreClearingUnitTest):",
            "    def setUp(self):",
            "        super(TestImagesController, self).setUp()",
            "",
            "        self.config(verbose=True, debug=True)",
            "        self.image_repo = FakeImageRepo()",
            "        self.gateway = FakeGateway(self.image_repo)",
            "        self.controller = glance.api.v2.image_data.ImageDataController(",
            "            gateway=self.gateway)",
            "",
            "    def test_download(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd', locations=['http://example.com/image'])",
            "        self.image_repo.result = image",
            "        image = self.controller.download(request, unit_test_utils.UUID1)",
            "        self.assertEqual(image.image_id, 'abcd')",
            "",
            "    def test_download_no_location(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = FakeImage('abcd')",
            "        self.assertRaises(webob.exc.HTTPNoContent, self.controller.download,",
            "                          request, unit_test_utils.UUID2)",
            "",
            "    def test_download_non_existent_image(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.NotFound()",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_download_forbidden(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.Forbidden()",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_download_get_image_location_forbidden(self):",
            "        class ImageLocations(object):",
            "            def __len__(self):",
            "                raise exception.Forbidden()",
            "",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        image.locations = ImageLocations()",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.download,",
            "                          request, str(uuid.uuid4()))",
            "",
            "    def test_upload(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        self.assertEqual(image.data, 'YYYY')",
            "        self.assertEqual(image.size, 4)",
            "",
            "    def test_upload_status(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        insurance = {'called': False}",
            "",
            "        def read_data():",
            "            insurance['called'] = True",
            "            self.assertEqual(self.image_repo.saved_image.status, 'saving')",
            "            yield 'YYYY'",
            "",
            "        self.controller.upload(request, unit_test_utils.UUID2,",
            "                               read_data(), None)",
            "        self.assertTrue(insurance['called'])",
            "        self.assertEqual(self.image_repo.saved_image.status,",
            "                         'modified-by-fake')",
            "",
            "    def test_upload_no_size(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        self.image_repo.result = image",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', None)",
            "        self.assertEqual(image.data, 'YYYY')",
            "        self.assertIsNone(image.size)",
            "",
            "    def test_upload_invalid(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('abcd')",
            "        image.status = ValueError()",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYY', 4)",
            "",
            "    def test_upload_non_existent_image_during_save_initiates_deletion(self):",
            "        def fake_save_not_found(self):",
            "            raise exception.NotFound()",
            "",
            "        def fake_save_conflict(self):",
            "            raise exception.Conflict()",
            "",
            "        for fun in [fake_save_not_found, fake_save_conflict]:",
            "            request = unit_test_utils.get_fake_request()",
            "            image = FakeImage('abcd', locations=['http://example.com/image'])",
            "            self.image_repo.result = image",
            "            self.image_repo.save = fun",
            "            image.delete = mock.Mock()",
            "            self.assertRaises(webob.exc.HTTPGone, self.controller.upload,",
            "                              request, str(uuid.uuid4()), 'ABC', 3)",
            "            self.assertTrue(image.delete.called)",
            "",
            "    def test_upload_non_existent_image_before_save(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.image_repo.result = exception.NotFound()",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.upload,",
            "                          request, str(uuid.uuid4()), 'ABC', 3)",
            "",
            "    def test_upload_data_exists(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        exc = exception.InvalidImageStatusTransition(cur_status='active',",
            "                                                     new_status='queued')",
            "        image.set_data = Raise(exc)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPConflict, self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYY', 4)",
            "",
            "    def test_upload_storage_full(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.StorageFull)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YYYYYYY', 7)",
            "",
            "    def test_image_size_limit_exceeded(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.ImageSizeLimitExceeded)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID1, 'YYYYYYY', 7)",
            "",
            "    def test_upload_storage_forbidden(self):",
            "        request = unit_test_utils.get_fake_request(user=unit_test_utils.USER2)",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.Forbidden)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPForbidden, self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YY', 2)",
            "",
            "    def test_upload_storage_write_denied(self):",
            "        request = unit_test_utils.get_fake_request(user=unit_test_utils.USER3)",
            "        image = FakeImage()",
            "        image.set_data = Raise(exception.StorageWriteDenied)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPServiceUnavailable,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'YY', 2)",
            "",
            "    def _test_upload_download_prepare_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        prepare_payload = output['meta'].copy()",
            "        prepare_payload['checksum'] = None",
            "        prepare_payload['size'] = None",
            "        prepare_payload['virtual_size'] = None",
            "        prepare_payload['location'] = None",
            "        prepare_payload['status'] = 'queued'",
            "        del prepare_payload['updated_at']",
            "        prepare_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.prepare\",",
            "            'payload': prepare_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        prepare_updated_at = output_log[0]['payload']['updated_at']",
            "        del output_log[0]['payload']['updated_at']",
            "        self.assertTrue(prepare_updated_at <= output['meta']['updated_at'])",
            "        self.assertEqual(output_log[0], prepare_log)",
            "",
            "    def _test_upload_download_upload_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        upload_payload = output['meta'].copy()",
            "        upload_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.upload\",",
            "            'payload': upload_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        self.assertEqual(output_log[1], upload_log)",
            "",
            "    def _test_upload_download_activate_notification(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        self.controller.upload(request, unit_test_utils.UUID2, 'YYYY', 4)",
            "        output = self.controller.download(request, unit_test_utils.UUID2)",
            "        output_log = self.notifier.get_logs()",
            "        activate_payload = output['meta'].copy()",
            "        activate_log = {",
            "            'notification_type': \"INFO\",",
            "            'event_type': \"image.activate\",",
            "            'payload': activate_payload,",
            "        }",
            "        self.assertEqual(len(output_log), 3)",
            "        self.assertEqual(output_log[2], activate_log)",
            "",
            "    def test_restore_image_when_upload_failed(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        image = FakeImage('fake')",
            "        image.set_data = Raise(exception.StorageWriteDenied)",
            "        self.image_repo.result = image",
            "        self.assertRaises(webob.exc.HTTPServiceUnavailable,",
            "                          self.controller.upload,",
            "                          request, unit_test_utils.UUID2, 'ZZZ', 3)",
            "        self.assertEqual(self.image_repo.saved_image.status, 'queued')",
            "",
            "",
            "class TestImageDataDeserializer(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageDataDeserializer, self).setUp()",
            "        self.deserializer = glance.api.v2.image_data.RequestDeserializer()",
            "",
            "    def test_upload(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        request.body = 'YYY'",
            "        request.headers['Content-Length'] = 3",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 3}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_chunked(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        # If we use body_file, webob assumes we want to do a chunked upload,",
            "        # ignoring the Content-Length header",
            "        request.body_file = six.StringIO('YYY')",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': None}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_chunked_with_content_length(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        request.body_file = six.StringIO('YYY')",
            "        # The deserializer shouldn't care if the Content-Length is",
            "        # set when the user is attempting to send chunked data.",
            "        request.headers['Content-Length'] = 3",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 3}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_with_incorrect_content_length(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-stream'",
            "        # The deserializer shouldn't care if the Content-Length and",
            "        # actual request body length differ. That job is left up",
            "        # to the controller",
            "        request.body = 'YYY'",
            "        request.headers['Content-Length'] = 4",
            "        output = self.deserializer.upload(request)",
            "        data = output.pop('data')",
            "        self.assertEqual(data.read(), 'YYY')",
            "        expected = {'size': 4}",
            "        self.assertEqual(expected, output)",
            "",
            "    def test_upload_wrong_content_type(self):",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/json'",
            "        request.body = 'YYYYY'",
            "        self.assertRaises(webob.exc.HTTPUnsupportedMediaType,",
            "                          self.deserializer.upload, request)",
            "",
            "        request = unit_test_utils.get_fake_request()",
            "        request.headers['Content-Type'] = 'application/octet-st'",
            "        request.body = 'YYYYY'",
            "        self.assertRaises(webob.exc.HTTPUnsupportedMediaType,",
            "                          self.deserializer.upload, request)",
            "",
            "",
            "class TestImageDataSerializer(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageDataSerializer, self).setUp()",
            "        self.serializer = glance.api.v2.image_data.ResponseSerializer()",
            "",
            "    def test_download(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        image = FakeImage(size=3, data=iter('ZZZ'))",
            "        self.serializer.download(response, image)",
            "        self.assertEqual('ZZZ', response.body)",
            "        self.assertEqual('3', response.headers['Content-Length'])",
            "        self.assertFalse('Content-MD5' in response.headers)",
            "        self.assertEqual('application/octet-stream',",
            "                         response.headers['Content-Type'])",
            "",
            "    def test_download_with_checksum(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        checksum = '0745064918b49693cca64d6b6a13d28a'",
            "        image = FakeImage(size=3, checksum=checksum, data=iter('ZZZ'))",
            "        self.serializer.download(response, image)",
            "        self.assertEqual('ZZZ', response.body)",
            "        self.assertEqual('3', response.headers['Content-Length'])",
            "        self.assertEqual(checksum, response.headers['Content-MD5'])",
            "        self.assertEqual('application/octet-stream',",
            "                         response.headers['Content-Type'])",
            "",
            "    def test_download_forbidden(self):",
            "        \"\"\"Make sure the serializer can return 403 forbidden error instead of",
            "        500 internal server error.",
            "        \"\"\"",
            "        def get_data():",
            "            raise exception.Forbidden()",
            "",
            "        self.stubs.Set(glance.api.policy.ImageProxy,",
            "                       'get_data',",
            "                       get_data)",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        image = FakeImage(size=3, data=iter('ZZZ'))",
            "        image.get_data = get_data",
            "        self.assertRaises(webob.exc.HTTPForbidden,",
            "                          self.serializer.download,",
            "                          response, image)",
            "",
            "    def test_upload(self):",
            "        request = webob.Request.blank('/')",
            "        request.environ = {}",
            "        response = webob.Response()",
            "        response.request = request",
            "        self.serializer.upload(response, {})",
            "        self.assertEqual(204, response.status_int)",
            "        self.assertEqual('0', response.headers['Content-Length'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "82": [
                "FakeImageRepo",
                "save"
            ],
            "183": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion",
                "fake_save"
            ],
            "186": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "187": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "188": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "189": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "190": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "191": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "192": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ],
            "193": [
                "TestImagesController",
                "test_upload_non_existent_image_during_save_initiates_deletion"
            ]
        },
        "addLocation": []
    }
}