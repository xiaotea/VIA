{
    "mlflow/data/http_dataset_source.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from mlflow.utils.rest_utils import augmented_raise_for_status, cloud_storage_http_request"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+def _is_path(filename: str) -> bool:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    Return True if `filename` is a path, False otherwise. For example,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    \"foo/bar\" is a path, but \"bar\" is not."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    return os.path.basename(filename) != filename"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " class HTTPDatasetSource(DatasetSource):"
            },
            "12": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     Represents the source of a dataset stored at a web location and referred to"
            },
            "14": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         ):"
            },
            "15": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             # NB: If the filename is quoted, unquote it"
            },
            "16": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             basename = file_name[1].strip(\"'\\\"\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            if _is_path(basename):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                raise MlflowException.invalid_parameter_value("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                    f\"Invalid filename in Content-Disposition header: {basename}. \""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                    \"It must be a file name, not a path.\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                )"
            },
            "22": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         elif path is not None and len(posixpath.basename(path)) > 0:"
            },
            "23": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             basename = posixpath.basename(path)"
            },
            "24": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         else:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import posixpath",
            "import re",
            "from typing import Any, Dict",
            "from urllib.parse import urlparse",
            "",
            "from mlflow.data.dataset_source import DatasetSource",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.utils.file_utils import create_tmp_dir",
            "from mlflow.utils.rest_utils import augmented_raise_for_status, cloud_storage_http_request",
            "",
            "",
            "class HTTPDatasetSource(DatasetSource):",
            "    \"\"\"",
            "    Represents the source of a dataset stored at a web location and referred to",
            "    by an HTTP or HTTPS URL.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        self._url = url",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        The HTTP/S URL referring to the dataset source location.",
            "",
            "        :return: The HTTP/S URL referring to the dataset source location.",
            "        \"\"\"",
            "        return self._url",
            "",
            "    @staticmethod",
            "    def _get_source_type() -> str:",
            "        return \"http\"",
            "",
            "    def load(self, dst_path=None) -> str:",
            "        \"\"\"",
            "        Downloads the dataset source to the local filesystem.",
            "",
            "        :param dst_path: Path of the local filesystem destination directory to which to download the",
            "                         dataset source. If the directory does not exist, it is created. If",
            "                         unspecified, the dataset source is downloaded to a new uniquely-named",
            "                         directory on the local filesystem.",
            "        :return: The path to the downloaded dataset source on the local filesystem.",
            "        \"\"\"",
            "        resp = cloud_storage_http_request(",
            "            method=\"GET\",",
            "            url=self.url,",
            "            stream=True,",
            "        )",
            "        augmented_raise_for_status(resp)",
            "",
            "        path = urlparse(self.url).path",
            "        content_disposition = resp.headers.get(\"Content-Disposition\")",
            "        if content_disposition is not None and (",
            "            file_name := next(re.finditer(r\"filename=(.+)\", content_disposition), None)",
            "        ):",
            "            # NB: If the filename is quoted, unquote it",
            "            basename = file_name[1].strip(\"'\\\"\")",
            "        elif path is not None and len(posixpath.basename(path)) > 0:",
            "            basename = posixpath.basename(path)",
            "        else:",
            "            basename = \"dataset_source\"",
            "",
            "        if dst_path is None:",
            "            dst_path = create_tmp_dir()",
            "",
            "        dst_path = os.path.join(dst_path, basename)",
            "        with open(dst_path, \"wb\") as f:",
            "            chunk_size = 1024 * 1024  # 1 MB",
            "            for chunk in resp.iter_content(chunk_size=chunk_size):",
            "                f.write(chunk)",
            "",
            "        return dst_path",
            "",
            "    @staticmethod",
            "    def _can_resolve(raw_source: Any) -> bool:",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        :return: True if this DatsetSource can resolve the raw source, False otherwise.",
            "        \"\"\"",
            "        if not isinstance(raw_source, str):",
            "            return False",
            "",
            "        try:",
            "            parsed_source = urlparse(str(raw_source))",
            "            return parsed_source.scheme in [\"http\", \"https\"]",
            "        except Exception:",
            "            return False",
            "",
            "    @classmethod",
            "    def _resolve(cls, raw_source: Any) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        \"\"\"",
            "        return HTTPDatasetSource(raw_source)",
            "",
            "    def _to_dict(self) -> Dict[Any, Any]:",
            "        \"\"\"",
            "        :return: A JSON-compatible dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        return {",
            "            \"url\": self.url,",
            "        }",
            "",
            "    @classmethod",
            "    def _from_dict(cls, source_dict: Dict[Any, Any]) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param source_dict: A dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        url = source_dict.get(\"url\")",
            "        if url is None:",
            "            raise MlflowException(",
            "                'Failed to parse HTTPDatasetSource. Missing expected key: \"url\"',",
            "                INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        return cls(url=url)"
        ],
        "afterPatchFile": [
            "import os",
            "import posixpath",
            "import re",
            "from typing import Any, Dict",
            "from urllib.parse import urlparse",
            "",
            "from mlflow.data.dataset_source import DatasetSource",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.utils.file_utils import create_tmp_dir",
            "from mlflow.utils.rest_utils import augmented_raise_for_status, cloud_storage_http_request",
            "",
            "",
            "def _is_path(filename: str) -> bool:",
            "    \"\"\"",
            "    Return True if `filename` is a path, False otherwise. For example,",
            "    \"foo/bar\" is a path, but \"bar\" is not.",
            "    \"\"\"",
            "    return os.path.basename(filename) != filename",
            "",
            "",
            "class HTTPDatasetSource(DatasetSource):",
            "    \"\"\"",
            "    Represents the source of a dataset stored at a web location and referred to",
            "    by an HTTP or HTTPS URL.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        self._url = url",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        The HTTP/S URL referring to the dataset source location.",
            "",
            "        :return: The HTTP/S URL referring to the dataset source location.",
            "        \"\"\"",
            "        return self._url",
            "",
            "    @staticmethod",
            "    def _get_source_type() -> str:",
            "        return \"http\"",
            "",
            "    def load(self, dst_path=None) -> str:",
            "        \"\"\"",
            "        Downloads the dataset source to the local filesystem.",
            "",
            "        :param dst_path: Path of the local filesystem destination directory to which to download the",
            "                         dataset source. If the directory does not exist, it is created. If",
            "                         unspecified, the dataset source is downloaded to a new uniquely-named",
            "                         directory on the local filesystem.",
            "        :return: The path to the downloaded dataset source on the local filesystem.",
            "        \"\"\"",
            "        resp = cloud_storage_http_request(",
            "            method=\"GET\",",
            "            url=self.url,",
            "            stream=True,",
            "        )",
            "        augmented_raise_for_status(resp)",
            "",
            "        path = urlparse(self.url).path",
            "        content_disposition = resp.headers.get(\"Content-Disposition\")",
            "        if content_disposition is not None and (",
            "            file_name := next(re.finditer(r\"filename=(.+)\", content_disposition), None)",
            "        ):",
            "            # NB: If the filename is quoted, unquote it",
            "            basename = file_name[1].strip(\"'\\\"\")",
            "            if _is_path(basename):",
            "                raise MlflowException.invalid_parameter_value(",
            "                    f\"Invalid filename in Content-Disposition header: {basename}. \"",
            "                    \"It must be a file name, not a path.\"",
            "                )",
            "        elif path is not None and len(posixpath.basename(path)) > 0:",
            "            basename = posixpath.basename(path)",
            "        else:",
            "            basename = \"dataset_source\"",
            "",
            "        if dst_path is None:",
            "            dst_path = create_tmp_dir()",
            "",
            "        dst_path = os.path.join(dst_path, basename)",
            "        with open(dst_path, \"wb\") as f:",
            "            chunk_size = 1024 * 1024  # 1 MB",
            "            for chunk in resp.iter_content(chunk_size=chunk_size):",
            "                f.write(chunk)",
            "",
            "        return dst_path",
            "",
            "    @staticmethod",
            "    def _can_resolve(raw_source: Any) -> bool:",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        :return: True if this DatsetSource can resolve the raw source, False otherwise.",
            "        \"\"\"",
            "        if not isinstance(raw_source, str):",
            "            return False",
            "",
            "        try:",
            "            parsed_source = urlparse(str(raw_source))",
            "            return parsed_source.scheme in [\"http\", \"https\"]",
            "        except Exception:",
            "            return False",
            "",
            "    @classmethod",
            "    def _resolve(cls, raw_source: Any) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        \"\"\"",
            "        return HTTPDatasetSource(raw_source)",
            "",
            "    def _to_dict(self) -> Dict[Any, Any]:",
            "        \"\"\"",
            "        :return: A JSON-compatible dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        return {",
            "            \"url\": self.url,",
            "        }",
            "",
            "    @classmethod",
            "    def _from_dict(cls, source_dict: Dict[Any, Any]) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param source_dict: A dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        url = source_dict.get(\"url\")",
            "        if url is None:",
            "            raise MlflowException(",
            "                'Failed to parse HTTPDatasetSource. Missing expected key: \"url\"',",
            "                INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        return cls(url=url)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.urllib3.connection",
            "mlflow.data.http_dataset_source.HTTPDatasetSource.load"
        ]
    }
}