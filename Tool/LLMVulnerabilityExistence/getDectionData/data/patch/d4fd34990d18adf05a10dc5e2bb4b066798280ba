{
    "Products/isurlinportal/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         # and redirecting to 'mailto:' or 'ftp:' is silly."
            },
            "1": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         return False"
            },
            "2": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    if schema and not u_host:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        # Example: https:example.org"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        # When we redirect to this, some browsers fail, others happily go to example.org."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        # In any case, this is not in the portal."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        return False"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     # Someone may be doing tricks with escaped html code."
            },
            "10": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     unescaped_url = unescape(url)"
            },
            "11": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     if unescaped_url != url:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from ._compat import get_external_sites",
            "from ._compat import unescape",
            "from ._compat import urljoin",
            "from ._compat import urlparse",
            "from posixpath import normpath",
            "",
            "# This is the class we will patch:",
            "from Products.CMFPlone.URLTool import URLTool",
            "",
            "import re",
            "import string",
            "import unicodedata",
            "",
            "",
            "# These schemas are allowed in full urls to consider them in the portal:",
            "# A mailto schema is an obvious sign of a url that is not in the portal.",
            "# This is a whitelist.",
            "ALLOWED_SCHEMAS = [",
            "    \"https\",",
            "    \"http\",",
            "]",
            "# These bad parts are not allowed in urls that are in the portal:",
            "# This is a blacklist.",
            "BAD_URL_PARTS = [",
            "    \"\\\\\\\\\",",
            "    \"<script\",",
            "    \"%3cscript\",",
            "    \"javascript:\",",
            "    \"javascript%3a\",",
            "]",
            "",
            "# Determine allowed ascii characters.",
            "# We want to allow most printable characters,",
            "# but no whitespace, and no punctuation, except for a few exceptions.",
            "# This boils down to ascii letters plus digits plus exceptions.",
            "# Exceptions:",
            "# - dot and slash for relative or absolute paths.",
            "# - @ because we have views starting with @@",
            "# - + because we have ++resource++ urls",
            "allowed_ascii = string.ascii_letters + string.digits + \"./@+\"",
            "",
            "",
            "def safe_url_first_char(url):",
            "    # For character code points higher than 127, the bytes representation of a character",
            "    # is longer than the unicode representation, so url[0] may give different results",
            "    # for bytes and unicode.  On Python 2:",
            "    # >>> unichr(128)",
            "    # u'\\x80'",
            "    # >>> len(unichr(128))",
            "    # 1",
            "    # >>> unichr(128).encode(\"latin-1\")",
            "    # '\\x80'",
            "    # >>> len(unichr(128).encode(\"latin-1\"))",
            "    # 1",
            "    # >>> unichr(128).encode(\"utf-8\")",
            "    # '\\xc2\\x80'",
            "    # >>> len(unichr(128).encode(\"utf-8\"))",
            "    # 2",
            "    # >>> unichr(128).encode(\"utf-8\")[0]",
            "    # '\\xc2'",
            "    # So make sure we have unicode here for comparing the first character.",
            "    if isinstance(url, bytes):",
            "        # Remember, on Python 2, bytes == str.",
            "        try:",
            "            first = url.decode(\"utf-8\")[0]",
            "        except UnicodeDecodeError:",
            "            # We don't trust this",
            "            return False",
            "    else:",
            "        first = url[0]",
            "    if ord(first) < 128:",
            "        if first not in allowed_ascii:",
            "            # The first character of the url is ascii but not in the allowed range.",
            "            return False",
            "    else:",
            "        # This is non-ascii, which has lots of control characters, which may be dangerous.",
            "        # Check taken from django.utils.http._is_safe_url.  See",
            "        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382",
            "        # Forbid URLs that start with control characters. Some browsers (like",
            "        # Chrome) ignore quite a few control characters at the start of a",
            "        # URL and might consider the URL as scheme relative.",
            "        # For categories, see 5.7.1 General Category Values here:",
            "        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values",
            "        # We look for Control categories here.",
            "        if unicodedata.category(first)[0] == \"C\":",
            "            return False",
            "    return True",
            "",
            "",
            "def isURLInPortal(self, url, context=None):",
            "    # Note: no docstring, because the method is publicly available",
            "    # but does not need to be callable on site-url/portal_url/isURLInPortal.",
            "",
            "    # Check if a given url is on the same host and contains the portal",
            "    # path.  Used to ensure that login forms can determine relevant",
            "    # referrers (i.e. in portal).  Also return true for some relative",
            "    # urls if context is passed in to allow for url parsing. When context",
            "    # is not provided, assume that relative urls are in the portal. It is",
            "    # assumed that http://portal is the same portal as https://portal.",
            "",
            "    # External sites listed in 'allow_external_login_sites' of",
            "    # site_properties are also considered within the portal to allow for",
            "    # single sign on.",
            "",
            "    if len(url.splitlines()) > 1:",
            "        # very fishy",
            "        return False",
            "    if url != url.strip():",
            "        # somewhat fishy",
            "        return False",
            "    if url != \" \".join(url.split()):",
            "        # Some non-normal whitespace is used, like a tab.",
            "        # Could be a ploy to circumvent our checks.  We don't trust this.",
            "        return False",
            "    if url and not safe_url_first_char(url):",
            "        return False",
            "",
            "    # sanitize url",
            "    url = re.sub(\"^[\\x00-\\x20]+\", \"\", url).strip()",
            "    cmp_url = url.lower()",
            "    for bad in BAD_URL_PARTS:",
            "        if bad in cmp_url:",
            "            return False",
            "",
            "    p_url = self()",
            "",
            "    schema, u_host, u_path, _, _, _ = urlparse(url)",
            "    if schema and schema not in ALLOWED_SCHEMAS:",
            "        # Redirecting to 'data:' may be harmful,",
            "        # and redirecting to 'mailto:' or 'ftp:' is silly.",
            "        return False",
            "",
            "    # Someone may be doing tricks with escaped html code.",
            "    unescaped_url = unescape(url)",
            "    if unescaped_url != url:",
            "        if not self.isURLInPortal(unescaped_url):",
            "            return False",
            "",
            "    if not u_host and not u_path.startswith(\"/\"):",
            "        if context is None:",
            "            return True  # old behavior",
            "        if not context.isPrincipiaFolderish:",
            "            useurl = context.aq_parent.absolute_url()",
            "        else:",
            "            useurl = context.absolute_url()",
            "    else:",
            "        useurl = p_url  # when u_path.startswith('/')",
            "    if not useurl.endswith(\"/\"):",
            "        useurl += \"/\"",
            "",
            "    # urljoin to current url to get an absolute path",
            "    _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))",
            "",
            "    # normalise to end with a '/' so /foobar is not considered within /foo",
            "    if not u_path:",
            "        u_path = \"/\"",
            "    else:",
            "        u_path = normpath(u_path)",
            "        if not u_path.endswith(\"/\"):",
            "            u_path += \"/\"",
            "    _, host, path, _, _, _ = urlparse(p_url)",
            "    if not path.endswith(\"/\"):",
            "        path += \"/\"",
            "    if host == u_host and u_path.startswith(path):",
            "        return True",
            "",
            "    for external_site in get_external_sites(self):",
            "        _, host, path, _, _, _ = urlparse(external_site)",
            "        if not path.endswith(\"/\"):",
            "            path += \"/\"",
            "        if host == u_host and u_path.startswith(path):",
            "            return True",
            "    return False",
            "",
            "",
            "# Add our method to the URLTool.",
            "URLTool.isURLInPortal = isURLInPortal"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from ._compat import get_external_sites",
            "from ._compat import unescape",
            "from ._compat import urljoin",
            "from ._compat import urlparse",
            "from posixpath import normpath",
            "",
            "# This is the class we will patch:",
            "from Products.CMFPlone.URLTool import URLTool",
            "",
            "import re",
            "import string",
            "import unicodedata",
            "",
            "",
            "# These schemas are allowed in full urls to consider them in the portal:",
            "# A mailto schema is an obvious sign of a url that is not in the portal.",
            "# This is a whitelist.",
            "ALLOWED_SCHEMAS = [",
            "    \"https\",",
            "    \"http\",",
            "]",
            "# These bad parts are not allowed in urls that are in the portal:",
            "# This is a blacklist.",
            "BAD_URL_PARTS = [",
            "    \"\\\\\\\\\",",
            "    \"<script\",",
            "    \"%3cscript\",",
            "    \"javascript:\",",
            "    \"javascript%3a\",",
            "]",
            "",
            "# Determine allowed ascii characters.",
            "# We want to allow most printable characters,",
            "# but no whitespace, and no punctuation, except for a few exceptions.",
            "# This boils down to ascii letters plus digits plus exceptions.",
            "# Exceptions:",
            "# - dot and slash for relative or absolute paths.",
            "# - @ because we have views starting with @@",
            "# - + because we have ++resource++ urls",
            "allowed_ascii = string.ascii_letters + string.digits + \"./@+\"",
            "",
            "",
            "def safe_url_first_char(url):",
            "    # For character code points higher than 127, the bytes representation of a character",
            "    # is longer than the unicode representation, so url[0] may give different results",
            "    # for bytes and unicode.  On Python 2:",
            "    # >>> unichr(128)",
            "    # u'\\x80'",
            "    # >>> len(unichr(128))",
            "    # 1",
            "    # >>> unichr(128).encode(\"latin-1\")",
            "    # '\\x80'",
            "    # >>> len(unichr(128).encode(\"latin-1\"))",
            "    # 1",
            "    # >>> unichr(128).encode(\"utf-8\")",
            "    # '\\xc2\\x80'",
            "    # >>> len(unichr(128).encode(\"utf-8\"))",
            "    # 2",
            "    # >>> unichr(128).encode(\"utf-8\")[0]",
            "    # '\\xc2'",
            "    # So make sure we have unicode here for comparing the first character.",
            "    if isinstance(url, bytes):",
            "        # Remember, on Python 2, bytes == str.",
            "        try:",
            "            first = url.decode(\"utf-8\")[0]",
            "        except UnicodeDecodeError:",
            "            # We don't trust this",
            "            return False",
            "    else:",
            "        first = url[0]",
            "    if ord(first) < 128:",
            "        if first not in allowed_ascii:",
            "            # The first character of the url is ascii but not in the allowed range.",
            "            return False",
            "    else:",
            "        # This is non-ascii, which has lots of control characters, which may be dangerous.",
            "        # Check taken from django.utils.http._is_safe_url.  See",
            "        # https://github.com/django/django/blob/2.1.5/django/utils/http.py#L356-L382",
            "        # Forbid URLs that start with control characters. Some browsers (like",
            "        # Chrome) ignore quite a few control characters at the start of a",
            "        # URL and might consider the URL as scheme relative.",
            "        # For categories, see 5.7.1 General Category Values here:",
            "        # http://www.unicode.org/reports/tr44/tr44-6.html#Property_Values",
            "        # We look for Control categories here.",
            "        if unicodedata.category(first)[0] == \"C\":",
            "            return False",
            "    return True",
            "",
            "",
            "def isURLInPortal(self, url, context=None):",
            "    # Note: no docstring, because the method is publicly available",
            "    # but does not need to be callable on site-url/portal_url/isURLInPortal.",
            "",
            "    # Check if a given url is on the same host and contains the portal",
            "    # path.  Used to ensure that login forms can determine relevant",
            "    # referrers (i.e. in portal).  Also return true for some relative",
            "    # urls if context is passed in to allow for url parsing. When context",
            "    # is not provided, assume that relative urls are in the portal. It is",
            "    # assumed that http://portal is the same portal as https://portal.",
            "",
            "    # External sites listed in 'allow_external_login_sites' of",
            "    # site_properties are also considered within the portal to allow for",
            "    # single sign on.",
            "",
            "    if len(url.splitlines()) > 1:",
            "        # very fishy",
            "        return False",
            "    if url != url.strip():",
            "        # somewhat fishy",
            "        return False",
            "    if url != \" \".join(url.split()):",
            "        # Some non-normal whitespace is used, like a tab.",
            "        # Could be a ploy to circumvent our checks.  We don't trust this.",
            "        return False",
            "    if url and not safe_url_first_char(url):",
            "        return False",
            "",
            "    # sanitize url",
            "    url = re.sub(\"^[\\x00-\\x20]+\", \"\", url).strip()",
            "    cmp_url = url.lower()",
            "    for bad in BAD_URL_PARTS:",
            "        if bad in cmp_url:",
            "            return False",
            "",
            "    p_url = self()",
            "",
            "    schema, u_host, u_path, _, _, _ = urlparse(url)",
            "    if schema and schema not in ALLOWED_SCHEMAS:",
            "        # Redirecting to 'data:' may be harmful,",
            "        # and redirecting to 'mailto:' or 'ftp:' is silly.",
            "        return False",
            "",
            "    if schema and not u_host:",
            "        # Example: https:example.org",
            "        # When we redirect to this, some browsers fail, others happily go to example.org.",
            "        # In any case, this is not in the portal.",
            "        return False",
            "",
            "    # Someone may be doing tricks with escaped html code.",
            "    unescaped_url = unescape(url)",
            "    if unescaped_url != url:",
            "        if not self.isURLInPortal(unescaped_url):",
            "            return False",
            "",
            "    if not u_host and not u_path.startswith(\"/\"):",
            "        if context is None:",
            "            return True  # old behavior",
            "        if not context.isPrincipiaFolderish:",
            "            useurl = context.aq_parent.absolute_url()",
            "        else:",
            "            useurl = context.absolute_url()",
            "    else:",
            "        useurl = p_url  # when u_path.startswith('/')",
            "    if not useurl.endswith(\"/\"):",
            "        useurl += \"/\"",
            "",
            "    # urljoin to current url to get an absolute path",
            "    _, u_host, u_path, _, _, _ = urlparse(urljoin(useurl, url))",
            "",
            "    # normalise to end with a '/' so /foobar is not considered within /foo",
            "    if not u_path:",
            "        u_path = \"/\"",
            "    else:",
            "        u_path = normpath(u_path)",
            "        if not u_path.endswith(\"/\"):",
            "            u_path += \"/\"",
            "    _, host, path, _, _, _ = urlparse(p_url)",
            "    if not path.endswith(\"/\"):",
            "        path += \"/\"",
            "    if host == u_host and u_path.startswith(path):",
            "        return True",
            "",
            "    for external_site in get_external_sites(self):",
            "        _, host, path, _, _, _ = urlparse(external_site)",
            "        if not path.endswith(\"/\"):",
            "            path += \"/\"",
            "        if host == u_host and u_path.startswith(path):",
            "            return True",
            "    return False",
            "",
            "",
            "# Add our method to the URLTool.",
            "URLTool.isURLInPortal = isURLInPortal"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "Products/isurlinportal/tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")"
            },
            "1": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         )"
            },
            "2": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    def test_ftp_not_in_portal(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        url_tool = self._makeOne()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        iURLiP = url_tool.isURLInPortal"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     def test_double_slash(self):"
            },
            "9": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         # I wondered if this might be a problem after reading"
            },
            "10": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         # https://bugs.python.org/issue23505"
            },
            "11": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         self.assertFalse(iURLiP(\"foo\\t\"))"
            },
            "12": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "         self.assertFalse(iURLiP(\" foo\"))"
            },
            "13": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         self.assertFalse(iURLiP(\"foo \"))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+    def test_without_slashes(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        # This does not work in all browsers."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        url_tool = self._makeOne()"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        iURLiP = url_tool.isURLInPortal"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        self.assertFalse(iURLiP(\"http:example.org\"))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        self.assertFalse(iURLiP(\"https:example.org\"))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from Acquisition import aq_parent",
            "from Products.CMFCore.tests.base.dummy import DummyContent",
            "from Products.CMFCore.tests.base.dummy import DummyFolder",
            "from Products.CMFCore.tests.base.dummy import DummySite",
            "from zope.component import getSiteManager",
            "",
            "import unittest",
            "",
            "",
            "class DummyFolder(DummyFolder):",
            "    def absolute_url(self):",
            "        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])",
            "",
            "",
            "def dummy_get_external_sites(context=None):",
            "    return [",
            "        \"http://external1\",",
            "        \"http://external2/\",",
            "        \"http://external3/site\",",
            "        \"http://external4/site/\",",
            "    ]",
            "",
            "",
            "class TestURLTool(unittest.TestCase):",
            "    def setUp(self):",
            "        import Products.isurlinportal",
            "",
            "        # Patch get_external_sites to return a fixed list of sites.",
            "        self._original_get_external_sites = Products.isurlinportal.get_external_sites",
            "        Products.isurlinportal.get_external_sites = dummy_get_external_sites",
            "",
            "        # Create dummy site and content.",
            "        self.site = DummySite(id=\"foo\")",
            "        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))",
            "        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))",
            "",
            "    def tearDown(self):",
            "        import Products.isurlinportal",
            "",
            "        # Restore original get_external_sites.",
            "        Products.isurlinportal.get_external_sites = self._original_get_external_sites",
            "",
            "    def _makeOne(self, *args, **kw):",
            "        from Products.CMFPlone.URLTool import URLTool",
            "",
            "        url_tool = URLTool(*args, **kw)",
            "        return url_tool.__of__(self.site)",
            "",
            "    def test_isURLInPortal(self):",
            "        # First test what the absolute url of the site is, otherwise these",
            "        # tests look really weird.  Apparently our domain is www.foobar.com.",
            "        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")",
            "",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))",
            "        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))",
            "        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))",
            "        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))",
            "        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))",
            "        self.assertFalse(iURLiP(\"/images\"))",
            "        self.assertTrue(iURLiP(\"/bar/foo/foo\"))",
            "",
            "    def test_isURLInPortalRelative(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "",
            "        # non-root relative urls will need a current context to be passed in",
            "        self.assertTrue(iURLiP(\"images/img1.jpg\"))",
            "        self.assertTrue(iURLiP(\"./images/img1.jpg\"))",
            "",
            "        # /bar/foo/something",
            "        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))",
            "        # /bar/afolder",
            "        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))",
            "        # /afolder",
            "        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))",
            "",
            "        # /../afolder? How do we have more ../'s than there are parts in",
            "        # the URL?",
            "        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))",
            "",
            "        # /bar/foo/afolder",
            "        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))",
            "",
            "    def test_isURLInPortalExternal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"http://external1\"))",
            "        self.assertTrue(iURLiP(\"http://external1/\"))",
            "        self.assertTrue(iURLiP(\"http://external1/something\"))",
            "        self.assertTrue(iURLiP(\"http://external2\"))",
            "        self.assertTrue(iURLiP(\"http://external2/\"))",
            "        self.assertTrue(iURLiP(\"http://external2/something\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site/\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site/something\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site/\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site/something\"))",
            "",
            "        self.assertFalse(iURLiP(\"http://external3/other\"))",
            "        self.assertFalse(iURLiP(\"http://external4/other\"))",
            "        self.assertFalse(iURLiP(\"http://external5\"))",
            "        self.assertFalse(iURLiP(\"http://external11\"))",
            "",
            "    def test_script_tag_url_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))",
            "        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))",
            "        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))",
            "        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))",
            "",
            "    def test_inline_url_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))",
            "        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))",
            "        self.assertFalse(iURLiP(\"javascript:alert(3)\"))",
            "        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))",
            "",
            "    def test_double_back_slash(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))",
            "",
            "    def test_escape(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))",
            "        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))",
            "        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))",
            "        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))",
            "        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))",
            "",
            "    def test_regression_absolute_url_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(url_tool()))",
            "        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))",
            "",
            "    def test_mailto_simple_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))",
            "",
            "    def test_mailto_complex_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(",
            "            iURLiP(",
            "                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"",
            "                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"",
            "                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"",
            "            )",
            "        )",
            "",
            "    def test_data_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(",
            "            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")",
            "        )",
            "",
            "    def test_double_slash(self):",
            "        # I wondered if this might be a problem after reading",
            "        # https://bugs.python.org/issue23505",
            "        # Apparently not, but let's test it.",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"//www.google.com\"))",
            "        self.assertFalse(iURLiP(\"////www.google.com\"))",
            "",
            "    def test_empty(self):",
            "        # Redirecting to nothing would probably mean we end up on the same page.",
            "        # So an empty url should be fine.",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"\"))",
            "",
            "    def test_newlines(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"foo\"))",
            "        self.assertFalse(iURLiP(\"f\\noo\"))",
            "        self.assertFalse(iURLiP(\"f\\roo\"))",
            "        self.assertFalse(iURLiP(\"\\nfoo\"))",
            "        self.assertFalse(iURLiP(\"\\rfoo\"))",
            "",
            "    def test_whitespace(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"foo\"))",
            "        self.assertTrue(iURLiP(\"f oo\"))",
            "        # '\\x20' == ' '",
            "        self.assertTrue(iURLiP(\"f\\x20oo\"))",
            "        self.assertFalse(iURLiP(\"f\\too\"))",
            "        self.assertFalse(iURLiP(\"\\tfoo\"))",
            "        self.assertFalse(iURLiP(\"foo\\t\"))",
            "        self.assertFalse(iURLiP(\" foo\"))",
            "        self.assertFalse(iURLiP(\"foo \"))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from Acquisition import aq_parent",
            "from Products.CMFCore.tests.base.dummy import DummyContent",
            "from Products.CMFCore.tests.base.dummy import DummyFolder",
            "from Products.CMFCore.tests.base.dummy import DummySite",
            "from zope.component import getSiteManager",
            "",
            "import unittest",
            "",
            "",
            "class DummyFolder(DummyFolder):",
            "    def absolute_url(self):",
            "        return \"/\".join([aq_parent(self).absolute_url(), self.getId()])",
            "",
            "",
            "def dummy_get_external_sites(context=None):",
            "    return [",
            "        \"http://external1\",",
            "        \"http://external2/\",",
            "        \"http://external3/site\",",
            "        \"http://external4/site/\",",
            "    ]",
            "",
            "",
            "class TestURLTool(unittest.TestCase):",
            "    def setUp(self):",
            "        import Products.isurlinportal",
            "",
            "        # Patch get_external_sites to return a fixed list of sites.",
            "        self._original_get_external_sites = Products.isurlinportal.get_external_sites",
            "        Products.isurlinportal.get_external_sites = dummy_get_external_sites",
            "",
            "        # Create dummy site and content.",
            "        self.site = DummySite(id=\"foo\")",
            "        self.site._setObject(\"foo\", DummyFolder(id=\"foo\"))",
            "        self.site.foo._setObject(\"doc1\", DummyContent(id=\"doc1\"))",
            "",
            "    def tearDown(self):",
            "        import Products.isurlinportal",
            "",
            "        # Restore original get_external_sites.",
            "        Products.isurlinportal.get_external_sites = self._original_get_external_sites",
            "",
            "    def _makeOne(self, *args, **kw):",
            "        from Products.CMFPlone.URLTool import URLTool",
            "",
            "        url_tool = URLTool(*args, **kw)",
            "        return url_tool.__of__(self.site)",
            "",
            "    def test_isURLInPortal(self):",
            "        # First test what the absolute url of the site is, otherwise these",
            "        # tests look really weird.  Apparently our domain is www.foobar.com.",
            "        self.assertEqual(self.site.absolute_url(), \"http://www.foobar.com/bar/foo\")",
            "",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo/folder\"))",
            "        self.assertTrue(iURLiP(\"http://www.foobar.com/bar/foo\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com/bar2/foo\"))",
            "        self.assertTrue(iURLiP(\"https://www.foobar.com/bar/foo/folder\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com:8080/bar/foo/folder\"))",
            "        self.assertFalse(iURLiP(\"http://www.foobar.com/bar\"))",
            "        self.assertFalse(iURLiP(\"http://other.foobar.com/bar/foo\"))",
            "        self.assertTrue(iURLiP(\"//www.foobar.com/bar/foo\"))",
            "        self.assertFalse(iURLiP(\"/images\"))",
            "        self.assertTrue(iURLiP(\"/bar/foo/foo\"))",
            "",
            "    def test_isURLInPortalRelative(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "",
            "        # non-root relative urls will need a current context to be passed in",
            "        self.assertTrue(iURLiP(\"images/img1.jpg\"))",
            "        self.assertTrue(iURLiP(\"./images/img1.jpg\"))",
            "",
            "        # /bar/foo/something",
            "        self.assertTrue(iURLiP(\"../something\", self.site.foo.doc1))",
            "        # /bar/afolder",
            "        self.assertFalse(iURLiP(\"../../afolder\", self.site.foo.doc1))",
            "        # /afolder",
            "        self.assertFalse(iURLiP(\"../../../afolder\", self.site.foo.doc1))",
            "",
            "        # /../afolder? How do we have more ../'s than there are parts in",
            "        # the URL?",
            "        self.assertFalse(iURLiP(\"../../../../afolder\", self.site.foo.doc1))",
            "",
            "        # /bar/foo/afolder",
            "        self.assertTrue(iURLiP(\"../../foo/afolder\", self.site.foo.doc1))",
            "",
            "    def test_isURLInPortalExternal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"http://external1\"))",
            "        self.assertTrue(iURLiP(\"http://external1/\"))",
            "        self.assertTrue(iURLiP(\"http://external1/something\"))",
            "        self.assertTrue(iURLiP(\"http://external2\"))",
            "        self.assertTrue(iURLiP(\"http://external2/\"))",
            "        self.assertTrue(iURLiP(\"http://external2/something\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site/\"))",
            "        self.assertTrue(iURLiP(\"http://external3/site/something\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site/\"))",
            "        self.assertTrue(iURLiP(\"http://external4/site/something\"))",
            "",
            "        self.assertFalse(iURLiP(\"http://external3/other\"))",
            "        self.assertFalse(iURLiP(\"http://external4/other\"))",
            "        self.assertFalse(iURLiP(\"http://external5\"))",
            "        self.assertFalse(iURLiP(\"http://external11\"))",
            "",
            "    def test_script_tag_url_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP('<script>alert(\"hi\");</script>'))",
            "        self.assertFalse(iURLiP('<sCript>alert(\"hi\");</script>'))",
            "        self.assertFalse(iURLiP(\"%3Cscript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))",
            "        self.assertFalse(iURLiP(\"%3CsCript%3Ealert(%22hi%22)%3B%3C%2Fscript%3E\"))",
            "",
            "    def test_inline_url_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"javascript%3Aalert(3)\"))",
            "        self.assertFalse(iURLiP(\"jaVascript%3Aalert(3)\"))",
            "        self.assertFalse(iURLiP(\"javascript:alert(3)\"))",
            "        self.assertFalse(iURLiP(\"jaVascript:alert(3)\"))",
            "",
            "    def test_double_back_slash(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"\\\\\\\\www.example.com\"))",
            "",
            "    def test_escape(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(r\"\\/\\/www.example.com\"))",
            "        self.assertFalse(iURLiP(r\"\\%2F\\%2Fwww.example.com\"))",
            "        self.assertFalse(iURLiP(r\"\\%2f\\%2fwww.example.com\"))",
            "        self.assertFalse(iURLiP(\"%2F%2Fwww.example.com\"))",
            "        self.assertFalse(iURLiP(\"%2f%2fwww.example.com\"))",
            "",
            "    def test_regression_absolute_url_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(url_tool()))",
            "        self.assertTrue(iURLiP(url_tool() + \"/shrubbery?knights=ni#ekki-ekki\"))",
            "",
            "    def test_mailto_simple_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"mailto:someone@example.org\"))",
            "",
            "    def test_mailto_complex_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(",
            "            iURLiP(",
            "                \"mailto&#58;192&#46;168&#46;163&#46;154&#58;8080&#47;Plone&apos;\"",
            "                \"&quot;&gt;&lt;html&gt;&lt;svg&#32;onload&#61;alert&#40;document\"",
            "                \"&#46;domain&#41;&gt;&lt;&#47;html&gt;\"",
            "            )",
            "        )",
            "",
            "    def test_data_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(",
            "            iURLiP(\"data:text/html%3bbase64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K\")",
            "        )",
            "",
            "    def test_ftp_not_in_portal(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"ftp://ftp.example.org\"))",
            "",
            "    def test_double_slash(self):",
            "        # I wondered if this might be a problem after reading",
            "        # https://bugs.python.org/issue23505",
            "        # Apparently not, but let's test it.",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"//www.google.com\"))",
            "        self.assertFalse(iURLiP(\"////www.google.com\"))",
            "",
            "    def test_empty(self):",
            "        # Redirecting to nothing would probably mean we end up on the same page.",
            "        # So an empty url should be fine.",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"\"))",
            "",
            "    def test_newlines(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"foo\"))",
            "        self.assertFalse(iURLiP(\"f\\noo\"))",
            "        self.assertFalse(iURLiP(\"f\\roo\"))",
            "        self.assertFalse(iURLiP(\"\\nfoo\"))",
            "        self.assertFalse(iURLiP(\"\\rfoo\"))",
            "",
            "    def test_whitespace(self):",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertTrue(iURLiP(\"foo\"))",
            "        self.assertTrue(iURLiP(\"f oo\"))",
            "        # '\\x20' == ' '",
            "        self.assertTrue(iURLiP(\"f\\x20oo\"))",
            "        self.assertFalse(iURLiP(\"f\\too\"))",
            "        self.assertFalse(iURLiP(\"\\tfoo\"))",
            "        self.assertFalse(iURLiP(\"foo\\t\"))",
            "        self.assertFalse(iURLiP(\" foo\"))",
            "        self.assertFalse(iURLiP(\"foo \"))",
            "",
            "    def test_without_slashes(self):",
            "        # This does not work in all browsers.",
            "        url_tool = self._makeOne()",
            "        iURLiP = url_tool.isURLInPortal",
            "        self.assertFalse(iURLiP(\"http:example.org\"))",
            "        self.assertFalse(iURLiP(\"https:example.org\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "Products.isurlinportal.tests.TestURLTool.self",
            "aiohttp.client_reqrep"
        ]
    }
}