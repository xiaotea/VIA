{
    "murano/engine/yaql_yaml_loader.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "                 node.end_mark.line + 1,"
            },
            "1": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "                 node.end_mark.column + 1)"
            },
            "2": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        class MuranoPlYamlConstructor(yaml.constructor.Constructor):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        class MuranoPlYamlConstructor(yaml.constructor.SafeConstructor):"
            },
            "5": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             def construct_yaml_map(self, node):"
            },
            "6": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "                 data = MuranoPlDict()"
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "                 data.source_file_position = build_position(node)"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "                 yield data"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                 value = self.construct_mapping(node)"
            },
            "10": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 data.update(value)"
            },
            "11": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        class YaqlYamlLoader(yaml.Loader, MuranoPlYamlConstructor):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        class YaqlYamlLoader(yaml.SafeLoader, MuranoPlYamlConstructor):"
            },
            "14": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             pass"
            },
            "15": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         YaqlYamlLoader.add_constructor("
            },
            "17": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         # workaround for PyYAML bug: http://pyyaml.org/ticket/221"
            },
            "19": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         resolvers = {}"
            },
            "20": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for k, v in yaml.Loader.yaml_implicit_resolvers.items():"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        for k, v in yaml.SafeLoader.yaml_implicit_resolvers.items():"
            },
            "22": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "             resolvers[k] = v[:]"
            },
            "23": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         YaqlYamlLoader.yaml_implicit_resolvers = resolvers"
            },
            "24": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2014 Mirantis Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
            "# implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import yaml",
            "import yaml.composer",
            "import yaml.constructor",
            "",
            "from murano.dsl import dsl_types",
            "from murano.dsl import helpers",
            "from murano.dsl import yaql_expression",
            "",
            "",
            "@helpers.memoize",
            "def get_loader(version):",
            "    version = helpers.parse_version(version)",
            "",
            "    class MuranoPlDict(dict):",
            "        pass",
            "",
            "    class YaqlExpression(yaql_expression.YaqlExpression):",
            "        @staticmethod",
            "        def match(expr):",
            "            return yaql_expression.YaqlExpression.is_expression(expr, version)",
            "",
            "    def load(contents, file_id):",
            "        def build_position(node):",
            "            return dsl_types.ExpressionFilePosition(",
            "                file_id,",
            "                node.start_mark.line + 1,",
            "                node.start_mark.column + 1,",
            "                node.end_mark.line + 1,",
            "                node.end_mark.column + 1)",
            "",
            "        class MuranoPlYamlConstructor(yaml.constructor.Constructor):",
            "            def construct_yaml_map(self, node):",
            "                data = MuranoPlDict()",
            "                data.source_file_position = build_position(node)",
            "                yield data",
            "                value = self.construct_mapping(node)",
            "                data.update(value)",
            "",
            "        class YaqlYamlLoader(yaml.Loader, MuranoPlYamlConstructor):",
            "            pass",
            "",
            "        YaqlYamlLoader.add_constructor(",
            "            u'tag:yaml.org,2002:map',",
            "            MuranoPlYamlConstructor.construct_yaml_map)",
            "",
            "        # workaround for PyYAML bug: http://pyyaml.org/ticket/221",
            "        resolvers = {}",
            "        for k, v in yaml.Loader.yaml_implicit_resolvers.items():",
            "            resolvers[k] = v[:]",
            "        YaqlYamlLoader.yaml_implicit_resolvers = resolvers",
            "",
            "        def yaql_constructor(loader, node):",
            "            value = loader.construct_scalar(node)",
            "            result = yaql_expression.YaqlExpression(value, version)",
            "            result.source_file_position = build_position(node)",
            "            return result",
            "",
            "        YaqlYamlLoader.add_constructor(u'!yaql', yaql_constructor)",
            "        YaqlYamlLoader.add_implicit_resolver(u'!yaql', YaqlExpression, None)",
            "        return list(filter(",
            "            lambda t: t,",
            "            yaml.load_all(contents, Loader=YaqlYamlLoader))",
            "        )",
            "",
            "    return load"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2014 Mirantis Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
            "# implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import yaml",
            "import yaml.composer",
            "import yaml.constructor",
            "",
            "from murano.dsl import dsl_types",
            "from murano.dsl import helpers",
            "from murano.dsl import yaql_expression",
            "",
            "",
            "@helpers.memoize",
            "def get_loader(version):",
            "    version = helpers.parse_version(version)",
            "",
            "    class MuranoPlDict(dict):",
            "        pass",
            "",
            "    class YaqlExpression(yaql_expression.YaqlExpression):",
            "        @staticmethod",
            "        def match(expr):",
            "            return yaql_expression.YaqlExpression.is_expression(expr, version)",
            "",
            "    def load(contents, file_id):",
            "        def build_position(node):",
            "            return dsl_types.ExpressionFilePosition(",
            "                file_id,",
            "                node.start_mark.line + 1,",
            "                node.start_mark.column + 1,",
            "                node.end_mark.line + 1,",
            "                node.end_mark.column + 1)",
            "",
            "        class MuranoPlYamlConstructor(yaml.constructor.SafeConstructor):",
            "            def construct_yaml_map(self, node):",
            "                data = MuranoPlDict()",
            "                data.source_file_position = build_position(node)",
            "                yield data",
            "                value = self.construct_mapping(node)",
            "                data.update(value)",
            "",
            "        class YaqlYamlLoader(yaml.SafeLoader, MuranoPlYamlConstructor):",
            "            pass",
            "",
            "        YaqlYamlLoader.add_constructor(",
            "            u'tag:yaml.org,2002:map',",
            "            MuranoPlYamlConstructor.construct_yaml_map)",
            "",
            "        # workaround for PyYAML bug: http://pyyaml.org/ticket/221",
            "        resolvers = {}",
            "        for k, v in yaml.SafeLoader.yaml_implicit_resolvers.items():",
            "            resolvers[k] = v[:]",
            "        YaqlYamlLoader.yaml_implicit_resolvers = resolvers",
            "",
            "        def yaql_constructor(loader, node):",
            "            value = loader.construct_scalar(node)",
            "            result = yaql_expression.YaqlExpression(value, version)",
            "            result.source_file_position = build_position(node)",
            "            return result",
            "",
            "        YaqlYamlLoader.add_constructor(u'!yaql', yaql_constructor)",
            "        YaqlYamlLoader.add_implicit_resolver(u'!yaql', YaqlExpression, None)",
            "        return list(filter(",
            "            lambda t: t,",
            "            yaml.load_all(contents, Loader=YaqlYamlLoader))",
            "        )",
            "",
            "    return load"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "46": [
                "get_loader",
                "load",
                "MuranoPlYamlConstructor"
            ],
            "54": [
                "get_loader",
                "load",
                "YaqlYamlLoader"
            ],
            "63": [
                "get_loader",
                "load"
            ]
        },
        "addLocation": []
    },
    "murano/tests/functional/common/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         component = service.to_dict()"
            },
            "2": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         component = json.dumps(component)"
            },
            "3": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return yaml.load(component)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        return yaml.safe_load(component)"
            },
            "5": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     @classmethod"
            },
            "7": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     def get_service_id(cls, service):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2015 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import contextlib",
            "import json",
            "import os",
            "import random",
            "import re",
            "import socket",
            "import telnetlib",
            "import time",
            "",
            "from heatclient import client as heatclient",
            "from keystoneclient import exceptions as ks_exceptions",
            "import keystoneclient.v2_0 as keystoneclientv2",
            "import keystoneclient.v3 as keystoneclientv3",
            "from muranoclient import client as mclient",
            "import muranoclient.common.exceptions as exceptions",
            "from oslo_log import log as logging",
            "import yaml",
            "",
            "from murano.services import states",
            "import murano.tests.functional.common.zip_utils_mixin as zip_utils",
            "import murano.tests.functional.engine.config as cfg",
            "",
            "CONF = cfg.cfg.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "@contextlib.contextmanager",
            "def ignored(*exceptions):",
            "    try:",
            "        yield",
            "    except exceptions:",
            "        pass",
            "",
            "",
            "def memoize(f):",
            "    \"\"\"Saves result of decorated function to cache",
            "",
            "    Decorator, which saves result of a decorated function",
            "    to cache.",
            "    TTL for cache is 1800 sec",
            "",
            "    :param f: decorated function",
            "    :return: saved result of a decorated function",
            "    \"\"\"",
            "    cache = {}",
            "",
            "    def decorated_function(*args):",
            "        if args in cache:",
            "            if time.time() - cache[args][1] < 1800:",
            "                return cache[args][0]",
            "            else:",
            "                cache[args] = (f(*args), time.time())",
            "                return cache[args][0]",
            "        else:",
            "            cache[args] = (f(*args), time.time())",
            "            return cache[args][0]",
            "",
            "    return decorated_function",
            "",
            "",
            "class DeployTestMixin(zip_utils.ZipUtilsMixin):",
            "    cfg.load_config()",
            "",
            "# -----------------------------Clients methods---------------------------------",
            "    @staticmethod",
            "    @memoize",
            "    def keystone_client():",
            "        region = CONF.murano.region_name",
            "        if re.match(\".*/v3/?$\", CONF.murano.auth_url):",
            "            ksclient = keystoneclientv3",
            "        else:",
            "            ksclient = keystoneclientv2",
            "        return ksclient.Client(username=CONF.murano.user,",
            "                               password=CONF.murano.password,",
            "                               tenant_name=CONF.murano.tenant,",
            "                               auth_url=CONF.murano.auth_url,",
            "                               region_name=region)",
            "",
            "    @classmethod",
            "    @memoize",
            "    def heat_client(cls):",
            "        heat_url = cls.keystone_client().service_catalog.url_for(",
            "            service_type='orchestration', endpoint_type='publicURL')",
            "        return heatclient.Client('1',",
            "                                 endpoint=heat_url,",
            "                                 token=cls.keystone_client().auth_token)",
            "",
            "    @classmethod",
            "    @memoize",
            "    def murano_client(cls):",
            "        murano_url = cls.get_murano_url()",
            "        return mclient.Client('1',",
            "                              endpoint=murano_url,",
            "                              token=cls.keystone_client().auth_token)",
            "",
            "# --------------------------Specific test methods------------------------------",
            "",
            "    @classmethod",
            "    def deploy_apps(cls, name, *apps):",
            "        \"\"\"Create and deploy environment.",
            "",
            "        :param name: Murano environment name",
            "        :param apps: App(s), described in JSON format",
            "        :return: Murano environment",
            "        \"\"\"",
            "        environment = cls.murano_client().environments.create({'name': name})",
            "        cls.init_list(\"_environments\")",
            "        cls._environments.append(environment)",
            "        session = cls.murano_client().sessions.configure(environment.id)",
            "        for app in apps:",
            "            cls.murano_client().services.post(",
            "                environment.id,",
            "                path='/',",
            "                data=app,",
            "                session_id=session.id)",
            "        cls.murano_client().sessions.deploy(environment.id, session.id)",
            "        return environment",
            "",
            "    @classmethod",
            "    def wait_for_final_status(cls, environment, timeout=300):",
            "        \"\"\"Function for wait final status of environment.",
            "",
            "        :param environment: Murano environment.",
            "        :param timeout: Timeout for waiting environment to get any status",
            "               excluding DEPLOYING state",
            "        \"\"\"",
            "        start_time = time.time()",
            "        status = environment.manager.get(environment.id).status",
            "        while states.SessionState.DEPLOYING == status:",
            "            if time.time() - start_time > timeout:",
            "                err_msg = ('Deployment not finished in {amount} seconds'",
            "                           .format(amount=timeout))",
            "                LOG.error(err_msg)",
            "                raise RuntimeError(err_msg)",
            "            time.sleep(5)",
            "            status = environment.manager.get(environment.id).status",
            "        dep = cls.murano_client().deployments.list(environment.id)",
            "        reports = cls.murano_client().deployments.reports(environment.id,",
            "                                                          dep[0].id)",
            "        return status, \", \".join([r.text for r in reports])",
            "",
            "# -----------------------------Reports methods---------------------------------",
            "",
            "    @classmethod",
            "    def get_last_deployment(cls, environment):",
            "        \"\"\"Gets last deployment of Murano environment.",
            "",
            "        :param environment: Murano environment",
            "        :return:",
            "        \"\"\"",
            "        deployments = cls.murano_client().deployments.list(environment.id)",
            "        return deployments[0]",
            "",
            "    @classmethod",
            "    def get_deployment_report(cls, environment, deployment):",
            "        \"\"\"Gets reports for environment with specific deployment.",
            "",
            "        :param environment: Murano environment.",
            "        :param deployment: Murano deployment for certain environment",
            "        :return:",
            "        \"\"\"",
            "        history = ''",
            "        report = cls.murano_client().deployments.reports(",
            "            environment.id, deployment.id)",
            "        for status in report:",
            "            history += '\\t{0} - {1}\\n'.format(status.created, status.text)",
            "        return history",
            "",
            "    @classmethod",
            "    def _log_report(cls, environment):",
            "        \"\"\"Used for logging reports on failures.",
            "",
            "        :param environment: Murano environment.",
            "        \"\"\"",
            "        deployment = cls.get_last_deployment(environment)",
            "        try:",
            "            details = deployment.result['result']['details']",
            "            LOG.warning('Details:\\n {details}'.format(details=details))",
            "        except Exception as e:",
            "            LOG.error(e)",
            "        report = cls.get_deployment_report(environment, deployment)",
            "        LOG.debug('Report:\\n {report}\\n'.format(report=report))",
            "",
            "# -----------------------------Service methods---------------------------------",
            "",
            "    @classmethod",
            "    def add_service(cls, environment, data, session, to_dict=False):",
            "        \"\"\"This function adds a specific service to environment.",
            "",
            "        :param environment: Murano environment",
            "        :param data: JSON with specific servive to add into",
            "        :param session: Session that is open for environment",
            "        :param to_dict: If True - returns a JSON object with service",
            "                        If False - returns a specific class <Service>",
            "        \"\"\"",
            "",
            "        LOG.debug('Added service:\\n {data}'.format(data=data))",
            "        service = cls.murano_client().services.post(environment.id,",
            "                                                    path='/', data=data,",
            "                                                    session_id=session.id)",
            "        if to_dict:",
            "            return cls._convert_service(service)",
            "        else:",
            "            return service",
            "",
            "    @classmethod",
            "    def services_list(cls, environment):",
            "        \"\"\"Get a list of environment services.",
            "",
            "        :param environment: Murano environment",
            "        :return: List of <Service> objects",
            "        \"\"\"",
            "        return cls.murano_client().services.list(environment.id)",
            "",
            "    @classmethod",
            "    def get_service(cls, environment, service_name, to_dict=True):",
            "        \"\"\"Get a service with specific name from environment.",
            "",
            "        :param to_dict: Convert service to JSON or not to convert",
            "        :param environment: Murano environment",
            "        :param service_name: Service name",
            "        :return: JSON or <Service> object",
            "        \"\"\"",
            "        for service in cls.services_list(environment):",
            "            if service.name == service_name:",
            "                return cls._convert_service(service) if to_dict else service",
            "",
            "    @classmethod",
            "    def _convert_service(cls, service):",
            "        \"\"\"Converts a <Service> to JSON object.",
            "",
            "        :param service: <Service> object",
            "        :return: JSON object",
            "        \"\"\"",
            "        component = service.to_dict()",
            "        component = json.dumps(component)",
            "        return yaml.load(component)",
            "",
            "    @classmethod",
            "    def get_service_id(cls, service):",
            "        \"\"\"Gets id on <Service> object.",
            "",
            "        :param service: <Service> object",
            "        :return: ID of the Service",
            "        \"\"\"",
            "        serv = cls._convert_service(service)",
            "        serv_id = serv['?']['id']",
            "        return serv_id",
            "",
            "    @classmethod",
            "    def delete_service(cls, environment, session, service):",
            "        \"\"\"This function removes a specific service from environment.",
            "",
            "        :param environment: Murano environment",
            "        :param session: Session fir urano environment",
            "        :param service: <Service> object",
            "        :return: Updated murano environment",
            "        \"\"\"",
            "        cls.murano_client().services.delete(",
            "            environment.id, path='/{0}'.format(cls.get_service_id(service)),",
            "            session_id=session.id)",
            "        LOG.debug('Service with name {0} from environment {1} successfully '",
            "                  'removed'.format(environment.name, service.name))",
            "        updated_env = cls.get_environment(environment)",
            "        return updated_env",
            "",
            "",
            "# -----------------------------Packages methods--------------------------------",
            "",
            "    @classmethod",
            "    def upload_package(cls, package_name, body, app):",
            "        \"\"\"Uploads a .zip package with parameters to Murano.",
            "",
            "        :param package_name: Package name in Murano repository",
            "        :param body: Categories, tags, etc.",
            "                     e.g. {",
            "                           \"categories\": [\"Application Servers\"],",
            "                           \"tags\": [\"tag\"]",
            "                           }",
            "        :param app: Correct .zip archive with the application",
            "        :return: Package",
            "        \"\"\"",
            "        files = {'{0}'.format(package_name): open(app, 'rb')}",
            "        package = cls.murano_client().packages.create(body, files)",
            "        cls.init_list(\"_packages\")",
            "        cls._packages.append(package)",
            "        return package",
            "",
            "# ------------------------------Common methods---------------------------------",
            "",
            "    @classmethod",
            "    def rand_name(cls, name='murano'):",
            "        \"\"\"Generates random string.",
            "",
            "        :param name: Basic name",
            "        :return:",
            "        \"\"\"",
            "        return name + str(random.randint(1, 0x7fffffff))",
            "",
            "    @classmethod",
            "    def init_list(cls, list_name):",
            "        if not hasattr(cls, list_name):",
            "            setattr(cls, list_name, [])",
            "",
            "    @classmethod",
            "    def get_murano_url(cls):",
            "        try:",
            "            url = cls.keystone_client().service_catalog.url_for(",
            "                service_type='application-catalog', endpoint_type='publicURL')",
            "        except ks_exceptions.EndpointNotFound:",
            "            url = CONF.murano.murano_url",
            "            LOG.warning(\"Murano endpoint not found in Keystone. Using CONF.\")",
            "        return url if 'v1' not in url else \"/\".join(",
            "            url.split('/')[:url.split('/').index('v1')])",
            "",
            "    @classmethod",
            "    def verify_connection(cls, ip, port):",
            "        \"\"\"Try to connect to specific ip:port with telnet.",
            "",
            "        :param ip: Ip that you want to check",
            "        :param port: Port that you want to check",
            "        :return: :raise RuntimeError:",
            "        \"\"\"",
            "        tn = telnetlib.Telnet(ip, port)",
            "        tn.write('GET / HTTP/1.0\\n\\n')",
            "        try:",
            "            buf = tn.read_all()",
            "            LOG.debug('Data:\\n {data}'.format(data=buf))",
            "            if len(buf) != 0:",
            "                tn.sock.sendall(telnetlib.IAC + telnetlib.NOP)",
            "                return",
            "            else:",
            "                raise RuntimeError('Resource at {0}:{1} not exist'.",
            "                                   format(ip, port))",
            "        except socket.error as e:",
            "            LOG.error('Socket Error: {error}'.format(error=e))",
            "",
            "    @classmethod",
            "    def get_ip_by_appname(cls, environment, appname):",
            "        \"\"\"Returns ip of instance with a deployed application using app name.",
            "",
            "        :param environment: Murano environment",
            "        :param appname: Application name or substring of application name",
            "        :return:",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if appname in service['name']:",
            "                return service['instance']['floatingIpAddress']",
            "",
            "    @classmethod",
            "    def get_ip_by_instance_name(cls, environment, inst_name):",
            "        \"\"\"Returns ip of instance using instance name.",
            "",
            "        :param environment: Murano environment",
            "        :param name: String, which is substring of name of instance or name of",
            "        instance",
            "        :return:",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if inst_name in service['instance']['name']:",
            "                return service['instance']['floatingIpAddress']",
            "",
            "    @classmethod",
            "    def get_k8s_ip_by_instance_name(cls, environment, inst_name, service_name):",
            "        \"\"\"Returns ip of specific kubernetes node (gateway, master, minion).",
            "",
            "        Search depends on service name of kubernetes and names of spawned",
            "        instances",
            "        :param environment: Murano environment",
            "        :param inst_name: Name of instance or substring of instance name",
            "        :param service_name: Name of Kube Cluster application in Murano",
            "        environment",
            "        :return: Ip of Kubernetes instances",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if service_name in service['name']:",
            "                if \"gateway\" in inst_name:",
            "                    for gateway in service['gatewayNodes']:",
            "                        if inst_name in gateway['instance']['name']:",
            "                            LOG.debug(gateway['instance']['floatingIpAddress'])",
            "                            return gateway['instance']['floatingIpAddress']",
            "                elif \"master\" in inst_name:",
            "                    LOG.debug(service['masterNode']['instance'][",
            "                        'floatingIpAddress'])",
            "                    return service['masterNode']['instance'][",
            "                        'floatingIpAddress']",
            "                elif \"minion\" in inst_name:",
            "                    for minion in service['minionNodes']:",
            "                        if inst_name in minion['instance']['name']:",
            "                            LOG.debug(minion['instance']['floatingIpAddress'])",
            "                            return minion['instance']['floatingIpAddress']",
            "",
            "# -----------------------------Cleanup methods---------------------------------",
            "",
            "    @classmethod",
            "    def purge_uploaded_packages(cls):",
            "        \"\"\"Cleanup for uploaded packages.\"\"\"",
            "        cls.init_list(\"_packages\")",
            "        try:",
            "            for pkg in cls._packages:",
            "                with ignored(Exception):",
            "                    cls.murano_client().packages.delete(pkg.id)",
            "        finally:",
            "            cls._packages = []",
            "        cls.init_list(\"_package_files\")",
            "        try:",
            "            for pkg_file in cls._package_files:",
            "                os.remove(pkg_file)",
            "        finally:",
            "            cls._package_files = []",
            "",
            "    @classmethod",
            "    def purge_environments(cls):",
            "        \"\"\"Cleanup for created environments.\"\"\"",
            "        cls.init_list(\"_environments\")",
            "        try:",
            "            for env in cls._environments:",
            "                with ignored(Exception):",
            "                    LOG.debug('Processing cleanup for environment {0} ({1})'.",
            "                              format(env.name, env.id))",
            "                    cls.environment_delete(env.id)",
            "                    cls.purge_stacks(env.id)",
            "                    time.sleep(5)",
            "        finally:",
            "            cls._environments = []",
            "",
            "    @classmethod",
            "    def purge_stacks(cls, environment_id):",
            "        stack = cls._get_stack(environment_id)",
            "        if not stack:",
            "            return",
            "        else:",
            "            cls.heat_client().stacks.delete(stack.id)",
            "",
            "# -----------------------Methods for environment CRUD--------------------------",
            "",
            "    @classmethod",
            "    def create_environment(cls, name=None):",
            "        \"\"\"Creates Murano environment with random name.",
            "",
            "",
            "        :param name: Environment name",
            "        :return: Murano environment",
            "        \"\"\"",
            "        if not name:",
            "            name = cls.rand_name('MuranoTe')",
            "        environment = cls.murano_client().environments.create({'name': name})",
            "        cls._environments.append(environment)",
            "        return environment",
            "",
            "    @classmethod",
            "    def get_environment(cls, environment):",
            "        \"\"\"Refresh <Environment> variable.",
            "",
            "        :param environment: Murano environment.",
            "        :return: Murano environment.",
            "        \"\"\"",
            "        return cls.murano_client().environments.get(environment.id)",
            "",
            "    @classmethod",
            "    def environment_delete(cls, environment_id, timeout=180):",
            "        \"\"\"Remove Murano environment.",
            "",
            "        :param environment_id: ID of Murano environment",
            "        :param timeout: Timeout to environment get deleted",
            "        :return: :raise RuntimeError:",
            "        \"\"\"",
            "        try:",
            "            cls.murano_client().environments.delete(environment_id)",
            "",
            "            start_time = time.time()",
            "            while time.time() - start_time < timeout:",
            "                try:",
            "                    cls.murano_client().environments.get(environment_id)",
            "                except exceptions.HTTPNotFound:",
            "                    LOG.debug('Environment with id {0} successfully deleted.'.",
            "                              format(environment_id))",
            "                    return",
            "            err_msg = ('Environment {0} was not deleted in {1} seconds'.",
            "                       format(environment_id, timeout))",
            "            LOG.error(err_msg)",
            "            raise RuntimeError(err_msg)",
            "        except Exception as exc:",
            "            LOG.debug('Environment with id {0} going to be abandoned.'.",
            "                      format(environment_id))",
            "            LOG.exception(exc)",
            "            cls.murano_client().environments.delete(environment_id,",
            "                                                    abandon=True)",
            "",
            "# -----------------------Methods for session actions---------------------------",
            "",
            "    @classmethod",
            "    def create_session(cls, environment):",
            "        return cls.murano_client().sessions.configure(environment.id)",
            "",
            "    @classmethod",
            "    def delete_session(cls, environment, session):",
            "        return cls.murano_client().sessions.delete(environment.id, session.id)",
            "",
            "",
            "# -------------------------------Heat methods----------------------------------",
            "",
            "    @classmethod",
            "    def _get_stack(cls, environment_id):",
            "",
            "        for stack in cls.heat_client().stacks.list():",
            "            stack_description = (",
            "                cls.heat_client().stacks.get(stack.id).description)",
            "            if not stack_description:",
            "                err_msg = (\"Stack {0} description is empty\".format(stack.id))",
            "                LOG.error(err_msg)",
            "                raise RuntimeError(err_msg)",
            "            if environment_id in stack_description:",
            "                return stack",
            "",
            "    @classmethod",
            "    def get_stack_template(cls, stack):",
            "        return cls.heat_client().stacks.template(stack.stack_name)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2015 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import contextlib",
            "import json",
            "import os",
            "import random",
            "import re",
            "import socket",
            "import telnetlib",
            "import time",
            "",
            "from heatclient import client as heatclient",
            "from keystoneclient import exceptions as ks_exceptions",
            "import keystoneclient.v2_0 as keystoneclientv2",
            "import keystoneclient.v3 as keystoneclientv3",
            "from muranoclient import client as mclient",
            "import muranoclient.common.exceptions as exceptions",
            "from oslo_log import log as logging",
            "import yaml",
            "",
            "from murano.services import states",
            "import murano.tests.functional.common.zip_utils_mixin as zip_utils",
            "import murano.tests.functional.engine.config as cfg",
            "",
            "CONF = cfg.cfg.CONF",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "@contextlib.contextmanager",
            "def ignored(*exceptions):",
            "    try:",
            "        yield",
            "    except exceptions:",
            "        pass",
            "",
            "",
            "def memoize(f):",
            "    \"\"\"Saves result of decorated function to cache",
            "",
            "    Decorator, which saves result of a decorated function",
            "    to cache.",
            "    TTL for cache is 1800 sec",
            "",
            "    :param f: decorated function",
            "    :return: saved result of a decorated function",
            "    \"\"\"",
            "    cache = {}",
            "",
            "    def decorated_function(*args):",
            "        if args in cache:",
            "            if time.time() - cache[args][1] < 1800:",
            "                return cache[args][0]",
            "            else:",
            "                cache[args] = (f(*args), time.time())",
            "                return cache[args][0]",
            "        else:",
            "            cache[args] = (f(*args), time.time())",
            "            return cache[args][0]",
            "",
            "    return decorated_function",
            "",
            "",
            "class DeployTestMixin(zip_utils.ZipUtilsMixin):",
            "    cfg.load_config()",
            "",
            "# -----------------------------Clients methods---------------------------------",
            "    @staticmethod",
            "    @memoize",
            "    def keystone_client():",
            "        region = CONF.murano.region_name",
            "        if re.match(\".*/v3/?$\", CONF.murano.auth_url):",
            "            ksclient = keystoneclientv3",
            "        else:",
            "            ksclient = keystoneclientv2",
            "        return ksclient.Client(username=CONF.murano.user,",
            "                               password=CONF.murano.password,",
            "                               tenant_name=CONF.murano.tenant,",
            "                               auth_url=CONF.murano.auth_url,",
            "                               region_name=region)",
            "",
            "    @classmethod",
            "    @memoize",
            "    def heat_client(cls):",
            "        heat_url = cls.keystone_client().service_catalog.url_for(",
            "            service_type='orchestration', endpoint_type='publicURL')",
            "        return heatclient.Client('1',",
            "                                 endpoint=heat_url,",
            "                                 token=cls.keystone_client().auth_token)",
            "",
            "    @classmethod",
            "    @memoize",
            "    def murano_client(cls):",
            "        murano_url = cls.get_murano_url()",
            "        return mclient.Client('1',",
            "                              endpoint=murano_url,",
            "                              token=cls.keystone_client().auth_token)",
            "",
            "# --------------------------Specific test methods------------------------------",
            "",
            "    @classmethod",
            "    def deploy_apps(cls, name, *apps):",
            "        \"\"\"Create and deploy environment.",
            "",
            "        :param name: Murano environment name",
            "        :param apps: App(s), described in JSON format",
            "        :return: Murano environment",
            "        \"\"\"",
            "        environment = cls.murano_client().environments.create({'name': name})",
            "        cls.init_list(\"_environments\")",
            "        cls._environments.append(environment)",
            "        session = cls.murano_client().sessions.configure(environment.id)",
            "        for app in apps:",
            "            cls.murano_client().services.post(",
            "                environment.id,",
            "                path='/',",
            "                data=app,",
            "                session_id=session.id)",
            "        cls.murano_client().sessions.deploy(environment.id, session.id)",
            "        return environment",
            "",
            "    @classmethod",
            "    def wait_for_final_status(cls, environment, timeout=300):",
            "        \"\"\"Function for wait final status of environment.",
            "",
            "        :param environment: Murano environment.",
            "        :param timeout: Timeout for waiting environment to get any status",
            "               excluding DEPLOYING state",
            "        \"\"\"",
            "        start_time = time.time()",
            "        status = environment.manager.get(environment.id).status",
            "        while states.SessionState.DEPLOYING == status:",
            "            if time.time() - start_time > timeout:",
            "                err_msg = ('Deployment not finished in {amount} seconds'",
            "                           .format(amount=timeout))",
            "                LOG.error(err_msg)",
            "                raise RuntimeError(err_msg)",
            "            time.sleep(5)",
            "            status = environment.manager.get(environment.id).status",
            "        dep = cls.murano_client().deployments.list(environment.id)",
            "        reports = cls.murano_client().deployments.reports(environment.id,",
            "                                                          dep[0].id)",
            "        return status, \", \".join([r.text for r in reports])",
            "",
            "# -----------------------------Reports methods---------------------------------",
            "",
            "    @classmethod",
            "    def get_last_deployment(cls, environment):",
            "        \"\"\"Gets last deployment of Murano environment.",
            "",
            "        :param environment: Murano environment",
            "        :return:",
            "        \"\"\"",
            "        deployments = cls.murano_client().deployments.list(environment.id)",
            "        return deployments[0]",
            "",
            "    @classmethod",
            "    def get_deployment_report(cls, environment, deployment):",
            "        \"\"\"Gets reports for environment with specific deployment.",
            "",
            "        :param environment: Murano environment.",
            "        :param deployment: Murano deployment for certain environment",
            "        :return:",
            "        \"\"\"",
            "        history = ''",
            "        report = cls.murano_client().deployments.reports(",
            "            environment.id, deployment.id)",
            "        for status in report:",
            "            history += '\\t{0} - {1}\\n'.format(status.created, status.text)",
            "        return history",
            "",
            "    @classmethod",
            "    def _log_report(cls, environment):",
            "        \"\"\"Used for logging reports on failures.",
            "",
            "        :param environment: Murano environment.",
            "        \"\"\"",
            "        deployment = cls.get_last_deployment(environment)",
            "        try:",
            "            details = deployment.result['result']['details']",
            "            LOG.warning('Details:\\n {details}'.format(details=details))",
            "        except Exception as e:",
            "            LOG.error(e)",
            "        report = cls.get_deployment_report(environment, deployment)",
            "        LOG.debug('Report:\\n {report}\\n'.format(report=report))",
            "",
            "# -----------------------------Service methods---------------------------------",
            "",
            "    @classmethod",
            "    def add_service(cls, environment, data, session, to_dict=False):",
            "        \"\"\"This function adds a specific service to environment.",
            "",
            "        :param environment: Murano environment",
            "        :param data: JSON with specific servive to add into",
            "        :param session: Session that is open for environment",
            "        :param to_dict: If True - returns a JSON object with service",
            "                        If False - returns a specific class <Service>",
            "        \"\"\"",
            "",
            "        LOG.debug('Added service:\\n {data}'.format(data=data))",
            "        service = cls.murano_client().services.post(environment.id,",
            "                                                    path='/', data=data,",
            "                                                    session_id=session.id)",
            "        if to_dict:",
            "            return cls._convert_service(service)",
            "        else:",
            "            return service",
            "",
            "    @classmethod",
            "    def services_list(cls, environment):",
            "        \"\"\"Get a list of environment services.",
            "",
            "        :param environment: Murano environment",
            "        :return: List of <Service> objects",
            "        \"\"\"",
            "        return cls.murano_client().services.list(environment.id)",
            "",
            "    @classmethod",
            "    def get_service(cls, environment, service_name, to_dict=True):",
            "        \"\"\"Get a service with specific name from environment.",
            "",
            "        :param to_dict: Convert service to JSON or not to convert",
            "        :param environment: Murano environment",
            "        :param service_name: Service name",
            "        :return: JSON or <Service> object",
            "        \"\"\"",
            "        for service in cls.services_list(environment):",
            "            if service.name == service_name:",
            "                return cls._convert_service(service) if to_dict else service",
            "",
            "    @classmethod",
            "    def _convert_service(cls, service):",
            "        \"\"\"Converts a <Service> to JSON object.",
            "",
            "        :param service: <Service> object",
            "        :return: JSON object",
            "        \"\"\"",
            "        component = service.to_dict()",
            "        component = json.dumps(component)",
            "        return yaml.safe_load(component)",
            "",
            "    @classmethod",
            "    def get_service_id(cls, service):",
            "        \"\"\"Gets id on <Service> object.",
            "",
            "        :param service: <Service> object",
            "        :return: ID of the Service",
            "        \"\"\"",
            "        serv = cls._convert_service(service)",
            "        serv_id = serv['?']['id']",
            "        return serv_id",
            "",
            "    @classmethod",
            "    def delete_service(cls, environment, session, service):",
            "        \"\"\"This function removes a specific service from environment.",
            "",
            "        :param environment: Murano environment",
            "        :param session: Session fir urano environment",
            "        :param service: <Service> object",
            "        :return: Updated murano environment",
            "        \"\"\"",
            "        cls.murano_client().services.delete(",
            "            environment.id, path='/{0}'.format(cls.get_service_id(service)),",
            "            session_id=session.id)",
            "        LOG.debug('Service with name {0} from environment {1} successfully '",
            "                  'removed'.format(environment.name, service.name))",
            "        updated_env = cls.get_environment(environment)",
            "        return updated_env",
            "",
            "",
            "# -----------------------------Packages methods--------------------------------",
            "",
            "    @classmethod",
            "    def upload_package(cls, package_name, body, app):",
            "        \"\"\"Uploads a .zip package with parameters to Murano.",
            "",
            "        :param package_name: Package name in Murano repository",
            "        :param body: Categories, tags, etc.",
            "                     e.g. {",
            "                           \"categories\": [\"Application Servers\"],",
            "                           \"tags\": [\"tag\"]",
            "                           }",
            "        :param app: Correct .zip archive with the application",
            "        :return: Package",
            "        \"\"\"",
            "        files = {'{0}'.format(package_name): open(app, 'rb')}",
            "        package = cls.murano_client().packages.create(body, files)",
            "        cls.init_list(\"_packages\")",
            "        cls._packages.append(package)",
            "        return package",
            "",
            "# ------------------------------Common methods---------------------------------",
            "",
            "    @classmethod",
            "    def rand_name(cls, name='murano'):",
            "        \"\"\"Generates random string.",
            "",
            "        :param name: Basic name",
            "        :return:",
            "        \"\"\"",
            "        return name + str(random.randint(1, 0x7fffffff))",
            "",
            "    @classmethod",
            "    def init_list(cls, list_name):",
            "        if not hasattr(cls, list_name):",
            "            setattr(cls, list_name, [])",
            "",
            "    @classmethod",
            "    def get_murano_url(cls):",
            "        try:",
            "            url = cls.keystone_client().service_catalog.url_for(",
            "                service_type='application-catalog', endpoint_type='publicURL')",
            "        except ks_exceptions.EndpointNotFound:",
            "            url = CONF.murano.murano_url",
            "            LOG.warning(\"Murano endpoint not found in Keystone. Using CONF.\")",
            "        return url if 'v1' not in url else \"/\".join(",
            "            url.split('/')[:url.split('/').index('v1')])",
            "",
            "    @classmethod",
            "    def verify_connection(cls, ip, port):",
            "        \"\"\"Try to connect to specific ip:port with telnet.",
            "",
            "        :param ip: Ip that you want to check",
            "        :param port: Port that you want to check",
            "        :return: :raise RuntimeError:",
            "        \"\"\"",
            "        tn = telnetlib.Telnet(ip, port)",
            "        tn.write('GET / HTTP/1.0\\n\\n')",
            "        try:",
            "            buf = tn.read_all()",
            "            LOG.debug('Data:\\n {data}'.format(data=buf))",
            "            if len(buf) != 0:",
            "                tn.sock.sendall(telnetlib.IAC + telnetlib.NOP)",
            "                return",
            "            else:",
            "                raise RuntimeError('Resource at {0}:{1} not exist'.",
            "                                   format(ip, port))",
            "        except socket.error as e:",
            "            LOG.error('Socket Error: {error}'.format(error=e))",
            "",
            "    @classmethod",
            "    def get_ip_by_appname(cls, environment, appname):",
            "        \"\"\"Returns ip of instance with a deployed application using app name.",
            "",
            "        :param environment: Murano environment",
            "        :param appname: Application name or substring of application name",
            "        :return:",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if appname in service['name']:",
            "                return service['instance']['floatingIpAddress']",
            "",
            "    @classmethod",
            "    def get_ip_by_instance_name(cls, environment, inst_name):",
            "        \"\"\"Returns ip of instance using instance name.",
            "",
            "        :param environment: Murano environment",
            "        :param name: String, which is substring of name of instance or name of",
            "        instance",
            "        :return:",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if inst_name in service['instance']['name']:",
            "                return service['instance']['floatingIpAddress']",
            "",
            "    @classmethod",
            "    def get_k8s_ip_by_instance_name(cls, environment, inst_name, service_name):",
            "        \"\"\"Returns ip of specific kubernetes node (gateway, master, minion).",
            "",
            "        Search depends on service name of kubernetes and names of spawned",
            "        instances",
            "        :param environment: Murano environment",
            "        :param inst_name: Name of instance or substring of instance name",
            "        :param service_name: Name of Kube Cluster application in Murano",
            "        environment",
            "        :return: Ip of Kubernetes instances",
            "        \"\"\"",
            "        for service in environment.services:",
            "            if service_name in service['name']:",
            "                if \"gateway\" in inst_name:",
            "                    for gateway in service['gatewayNodes']:",
            "                        if inst_name in gateway['instance']['name']:",
            "                            LOG.debug(gateway['instance']['floatingIpAddress'])",
            "                            return gateway['instance']['floatingIpAddress']",
            "                elif \"master\" in inst_name:",
            "                    LOG.debug(service['masterNode']['instance'][",
            "                        'floatingIpAddress'])",
            "                    return service['masterNode']['instance'][",
            "                        'floatingIpAddress']",
            "                elif \"minion\" in inst_name:",
            "                    for minion in service['minionNodes']:",
            "                        if inst_name in minion['instance']['name']:",
            "                            LOG.debug(minion['instance']['floatingIpAddress'])",
            "                            return minion['instance']['floatingIpAddress']",
            "",
            "# -----------------------------Cleanup methods---------------------------------",
            "",
            "    @classmethod",
            "    def purge_uploaded_packages(cls):",
            "        \"\"\"Cleanup for uploaded packages.\"\"\"",
            "        cls.init_list(\"_packages\")",
            "        try:",
            "            for pkg in cls._packages:",
            "                with ignored(Exception):",
            "                    cls.murano_client().packages.delete(pkg.id)",
            "        finally:",
            "            cls._packages = []",
            "        cls.init_list(\"_package_files\")",
            "        try:",
            "            for pkg_file in cls._package_files:",
            "                os.remove(pkg_file)",
            "        finally:",
            "            cls._package_files = []",
            "",
            "    @classmethod",
            "    def purge_environments(cls):",
            "        \"\"\"Cleanup for created environments.\"\"\"",
            "        cls.init_list(\"_environments\")",
            "        try:",
            "            for env in cls._environments:",
            "                with ignored(Exception):",
            "                    LOG.debug('Processing cleanup for environment {0} ({1})'.",
            "                              format(env.name, env.id))",
            "                    cls.environment_delete(env.id)",
            "                    cls.purge_stacks(env.id)",
            "                    time.sleep(5)",
            "        finally:",
            "            cls._environments = []",
            "",
            "    @classmethod",
            "    def purge_stacks(cls, environment_id):",
            "        stack = cls._get_stack(environment_id)",
            "        if not stack:",
            "            return",
            "        else:",
            "            cls.heat_client().stacks.delete(stack.id)",
            "",
            "# -----------------------Methods for environment CRUD--------------------------",
            "",
            "    @classmethod",
            "    def create_environment(cls, name=None):",
            "        \"\"\"Creates Murano environment with random name.",
            "",
            "",
            "        :param name: Environment name",
            "        :return: Murano environment",
            "        \"\"\"",
            "        if not name:",
            "            name = cls.rand_name('MuranoTe')",
            "        environment = cls.murano_client().environments.create({'name': name})",
            "        cls._environments.append(environment)",
            "        return environment",
            "",
            "    @classmethod",
            "    def get_environment(cls, environment):",
            "        \"\"\"Refresh <Environment> variable.",
            "",
            "        :param environment: Murano environment.",
            "        :return: Murano environment.",
            "        \"\"\"",
            "        return cls.murano_client().environments.get(environment.id)",
            "",
            "    @classmethod",
            "    def environment_delete(cls, environment_id, timeout=180):",
            "        \"\"\"Remove Murano environment.",
            "",
            "        :param environment_id: ID of Murano environment",
            "        :param timeout: Timeout to environment get deleted",
            "        :return: :raise RuntimeError:",
            "        \"\"\"",
            "        try:",
            "            cls.murano_client().environments.delete(environment_id)",
            "",
            "            start_time = time.time()",
            "            while time.time() - start_time < timeout:",
            "                try:",
            "                    cls.murano_client().environments.get(environment_id)",
            "                except exceptions.HTTPNotFound:",
            "                    LOG.debug('Environment with id {0} successfully deleted.'.",
            "                              format(environment_id))",
            "                    return",
            "            err_msg = ('Environment {0} was not deleted in {1} seconds'.",
            "                       format(environment_id, timeout))",
            "            LOG.error(err_msg)",
            "            raise RuntimeError(err_msg)",
            "        except Exception as exc:",
            "            LOG.debug('Environment with id {0} going to be abandoned.'.",
            "                      format(environment_id))",
            "            LOG.exception(exc)",
            "            cls.murano_client().environments.delete(environment_id,",
            "                                                    abandon=True)",
            "",
            "# -----------------------Methods for session actions---------------------------",
            "",
            "    @classmethod",
            "    def create_session(cls, environment):",
            "        return cls.murano_client().sessions.configure(environment.id)",
            "",
            "    @classmethod",
            "    def delete_session(cls, environment, session):",
            "        return cls.murano_client().sessions.delete(environment.id, session.id)",
            "",
            "",
            "# -------------------------------Heat methods----------------------------------",
            "",
            "    @classmethod",
            "    def _get_stack(cls, environment_id):",
            "",
            "        for stack in cls.heat_client().stacks.list():",
            "            stack_description = (",
            "                cls.heat_client().stacks.get(stack.id).description)",
            "            if not stack_description:",
            "                err_msg = (\"Stack {0} description is empty\".format(stack.id))",
            "                LOG.error(err_msg)",
            "                raise RuntimeError(err_msg)",
            "            if environment_id in stack_description:",
            "                return stack",
            "",
            "    @classmethod",
            "    def get_stack_template(cls, stack):",
            "        return cls.heat_client().stacks.template(stack.stack_name)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "252": [
                "DeployTestMixin",
                "_convert_service"
            ]
        },
        "addLocation": []
    },
    "murano/tests/unit/policy/test_congress_rules.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             os.path.dirname(inspect.getfile(self.__class__)), file_name)"
            },
            "1": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         with open(model_file) as stream:"
            },
            "3": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return yaml.load(stream)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            return yaml.safe_load(stream)"
            },
            "5": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     def _create_rules_str(self, model_file, package_loader=None):"
            },
            "7": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         model = self._load_file(model_file)"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2014 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import inspect",
            "import os.path",
            "",
            "import unittest2 as unittest",
            "import yaml",
            "",
            "from murano.common import uuidutils",
            "from murano.dsl import helpers",
            "from murano.dsl import package_loader",
            "import murano.policy.congress_rules as congress",
            "",
            "TENANT_ID = 'de305d5475b4431badb2eb6b9e546013'",
            "",
            "",
            "class MockPackageLoader(package_loader.MuranoPackageLoader):",
            "    def __init__(self, rules):",
            "        \"\"\"Create rules like this: ['child->parent', 'child->parent2'].\"\"\"",
            "",
            "        self._classes = {}",
            "        rules_dict = {}",
            "        for rule in rules:",
            "            split = rule.split('->')",
            "            rules_dict.setdefault(split[0], []).append(split[1])",
            "        classes = (self.get_class(cls, rules_dict) for cls in rules_dict)",
            "        self._package = MockPackage(classes)",
            "",
            "    def get_class(self, name, rules_dict):",
            "        if name in self._classes:",
            "            return self._classes[name]",
            "        parents = [self.get_class(parent, rules_dict)",
            "                   for parent in rules_dict.get(name, [])]",
            "        result = MockClass({'name': name, 'declared_parents': parents})",
            "        self._classes[name] = result",
            "        return result",
            "",
            "    def register_package(self, package):",
            "        pass",
            "",
            "    def load_class_package(self, class_name, version_spec):",
            "        return self._package",
            "",
            "    def load_package(self, package_name, version_spec):",
            "        return self._package",
            "",
            "",
            "class MockPackage(object):",
            "    def __init__(self, classes):",
            "        self._classes = {}",
            "        for cls in classes:",
            "            self._classes[cls.name] = cls",
            "",
            "    @property",
            "    def classes(self):",
            "        return self._classes.keys()",
            "",
            "    def find_class(self, name, *args, **kwargs):",
            "        return self._classes.get(name)",
            "",
            "",
            "class MockClass(object):",
            "    def __init__(self, entries):",
            "        self.__dict__.update(entries)",
            "",
            "    def ancestors(self):",
            "        return helpers.traverse(self, lambda t: t.declared_parents)",
            "",
            "",
            "class TestCongressRules(unittest.TestCase):",
            "",
            "    def _load_file(self, file_name):",
            "        model_file = os.path.join(",
            "            os.path.dirname(inspect.getfile(self.__class__)), file_name)",
            "",
            "        with open(model_file) as stream:",
            "            return yaml.load(stream)",
            "",
            "    def _create_rules_str(self, model_file, package_loader=None):",
            "        model = self._load_file(model_file)",
            "",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(model, package_loader,",
            "                                       tenant_id=TENANT_ID)",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "",
            "        return rules_str",
            "",
            "    def test_transitive_closure(self):",
            "        closure = congress.CongressRulesManager.transitive_closure(",
            "            [(1, 2), (2, 3), (3, 4)])",
            "        self.assertTrue((1, 4) in closure)",
            "        self.assertTrue((2, 4) in closure)",
            "",
            "    def test_empty_model(self):",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(None)",
            "        self.assertEqual(0, len(rules))",
            "",
            "    def test_convert_simple_app(self):",
            "        rules_str = self._create_and_check_rules_str('model')",
            "",
            "        self.assertFalse(\"instance.\" in rules_str)",
            "",
            "    def test_convert_model_two_instances(self):",
            "        rules_str = self._create_and_check_rules_str('model_two_instances')",
            "",
            "        self.assertFalse(\"\\\"instances\\\"\" in rules_str)",
            "",
            "    def test_convert_model_with_relations(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertFalse(",
            "            'murano:properties+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"server\", \"8ce94f23-f16a-40a1-9d9d-a877266c315d\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", \"server\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"0aafd67e-72e9-4ae0-bb62-fe724f77df2a\", '",
            "            '\"ed8df2b0-ddd2-4009-b3c9-2e7a368f3cb8\", \"instance\")' in rules_str)",
            "",
            "    def test_convert_model_transitive_relationships(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:connected+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:connected+(\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", '",
            "            '\"fc6b8c41-166f-4fc9-a640-d82009e0a03d\")' in rules_str)",
            "",
            "    def test_convert_model_services_relationship(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"3409bdd0590e4c60b70fda5e6777ff96\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", \"services\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"3409bdd0590e4c60b70fda5e6777ff96\", '",
            "            '\"50fa68ff-cd9a-4845-b573-2c80879d158d\", \"services\")' in rules_str)",
            "",
            "    def test_convert_model_complex(self):",
            "        self._create_and_check_rules_str('model_complex')",
            "",
            "    def test_convert_renamed_app(self):",
            "        self._create_and_check_rules_str('model_renamed')",
            "",
            "    def test_parent_types(self):",
            "",
            "        #     grand-parent",
            "        #       /     \\",
            "        #  parent1   parent2",
            "        #       \\     /",
            "        # io.murano.apps.linux.Git",
            "",
            "        package_loader = MockPackageLoader([",
            "            'io.murano.apps.linux.Git->parent1',",
            "            'io.murano.apps.linux.Git->parent2',",
            "            'parent1->grand-parent',",
            "            'parent2->grand-parent'",
            "        ])",
            "",
            "        rules_str = self._create_rules_str('model.yaml', package_loader)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"parent1\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"parent2\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"grand-parent\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"io.murano.apps.linux.Git\")' in rules_str)",
            "",
            "    def test_to_dictionary(self):",
            "        \"\"\"test to_dictionary",
            "",
            "        If model contains object entry (not dict)",
            "        we try to convert to dict using 'to_dictionary' method.",
            "        \"\"\"",
            "",
            "        class Struct(object):",
            "            def __init__(self, d):",
            "                self.__dict__ = d",
            "",
            "            def to_dictionary(self):",
            "                return self.__dict__",
            "",
            "            def __getitem__(self, item):",
            "                return self.__dict__[item]",
            "",
            "        d = {'?': {'id': '1', 'type': 't1'},",
            "             'apps': [Struct({'?': {'id': '2', 'type': 't2'},",
            "                              'instances': [Struct(",
            "                                  {'?': {'id': '3', 'type': 't3'}})]})]",
            "             }",
            "",
            "        model = Struct(d)",
            "",
            "        congress_rules = congress.CongressRulesManager()",
            "        tenant_id = uuidutils.generate_uuid()",
            "        rules = congress_rules.convert(model, tenant_id=tenant_id)",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "",
            "        self.assertTrue('murano:objects+(\"1\", \"{0}\", \"t1\")'.format(tenant_id)",
            "                        in rules_str)",
            "        self.assertTrue('murano:objects+(\"2\", \"1\", \"t2\")' in rules_str)",
            "        self.assertTrue('murano:objects+(\"3\", \"2\", \"t3\")' in rules_str)",
            "",
            "    def test_environment_owner(self):",
            "        model = self._load_file(\"model.yaml\")",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(model, tenant_id='tenant1')",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "        self.assertTrue('murano:objects+(\"c86104748a0c4907b4c5981e6d3bce9f\", '",
            "                        '\"tenant1\", \"io.murano.Environment\")' in rules_str)",
            "",
            "    def test_wordpress(self):",
            "        package_loader = MockPackageLoader([",
            "            'io.murano.Environment->io.murano.Object',",
            "            'io.murano.resources.NeutronNetwork->io.murano.resources.Network',",
            "            'io.murano.resources.Network->io.murano.Object',",
            "            'io.murano.databases.MySql->io.murano.databases.SqlDatabase',",
            "            'io.murano.databases.MySql->io.murano.Application',",
            "            'io.murano.databases.SqlDatabase->io.murano.Object',",
            "            'io.murano.resources.LinuxInstance->io.murano.resources.Instance',",
            "            'io.murano.resources.Instance->io.murano.Object',",
            "            'io.murano.Application->io.murano.Object',",
            "            'io.murano.apps.apache.ApacheHttpServer->io.murano.Application',",
            "            'io.murano.apps.ZabbixServer->io.murano.Application',",
            "            'io.murano.apps.ZabbixAgent->io.murano.Application',",
            "            'io.murano.apps.WordPress->io.murano.Application',",
            "",
            "            'io.murano.resources.LinuxMuranoInstance->'",
            "            'io.murano.resources.LinuxInstance'",
            "        ])",
            "",
            "        self._create_and_check_rules_str('wordpress', package_loader)",
            "",
            "    def _create_and_check_rules_str(self, model_name, package_loader=None):",
            "        rules_str = self._create_rules_str(",
            "            '{0}.yaml'.format(model_name), package_loader)",
            "        self._check_expected_rules(rules_str,",
            "                                   'expected_rules_{0}.txt'.format(model_name))",
            "        return rules_str",
            "",
            "    def _check_expected_rules(self, rules_str, expected_rules_file_name):",
            "        expected_rules_file = os.path.join(",
            "            os.path.dirname(inspect.getfile(self.__class__)),",
            "            expected_rules_file_name)",
            "",
            "        s = ''",
            "        with open(expected_rules_file) as f:",
            "            for line in f:",
            "                line = line.rstrip('\\n')",
            "                if line not in rules_str:",
            "                    s += 'Expected rule not found:\\n\\t' + line + '\\n'",
            "",
            "        if len(s) > 0:",
            "            self.fail(s)",
            "",
            "    def test_state_rule(self):",
            "        rules_str = self._create_rules_str('model.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:states+(\"c86104748a0c4907b4c5981e6d3bce9f\", \"pending\")'",
            "            in rules_str)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2014 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import inspect",
            "import os.path",
            "",
            "import unittest2 as unittest",
            "import yaml",
            "",
            "from murano.common import uuidutils",
            "from murano.dsl import helpers",
            "from murano.dsl import package_loader",
            "import murano.policy.congress_rules as congress",
            "",
            "TENANT_ID = 'de305d5475b4431badb2eb6b9e546013'",
            "",
            "",
            "class MockPackageLoader(package_loader.MuranoPackageLoader):",
            "    def __init__(self, rules):",
            "        \"\"\"Create rules like this: ['child->parent', 'child->parent2'].\"\"\"",
            "",
            "        self._classes = {}",
            "        rules_dict = {}",
            "        for rule in rules:",
            "            split = rule.split('->')",
            "            rules_dict.setdefault(split[0], []).append(split[1])",
            "        classes = (self.get_class(cls, rules_dict) for cls in rules_dict)",
            "        self._package = MockPackage(classes)",
            "",
            "    def get_class(self, name, rules_dict):",
            "        if name in self._classes:",
            "            return self._classes[name]",
            "        parents = [self.get_class(parent, rules_dict)",
            "                   for parent in rules_dict.get(name, [])]",
            "        result = MockClass({'name': name, 'declared_parents': parents})",
            "        self._classes[name] = result",
            "        return result",
            "",
            "    def register_package(self, package):",
            "        pass",
            "",
            "    def load_class_package(self, class_name, version_spec):",
            "        return self._package",
            "",
            "    def load_package(self, package_name, version_spec):",
            "        return self._package",
            "",
            "",
            "class MockPackage(object):",
            "    def __init__(self, classes):",
            "        self._classes = {}",
            "        for cls in classes:",
            "            self._classes[cls.name] = cls",
            "",
            "    @property",
            "    def classes(self):",
            "        return self._classes.keys()",
            "",
            "    def find_class(self, name, *args, **kwargs):",
            "        return self._classes.get(name)",
            "",
            "",
            "class MockClass(object):",
            "    def __init__(self, entries):",
            "        self.__dict__.update(entries)",
            "",
            "    def ancestors(self):",
            "        return helpers.traverse(self, lambda t: t.declared_parents)",
            "",
            "",
            "class TestCongressRules(unittest.TestCase):",
            "",
            "    def _load_file(self, file_name):",
            "        model_file = os.path.join(",
            "            os.path.dirname(inspect.getfile(self.__class__)), file_name)",
            "",
            "        with open(model_file) as stream:",
            "            return yaml.safe_load(stream)",
            "",
            "    def _create_rules_str(self, model_file, package_loader=None):",
            "        model = self._load_file(model_file)",
            "",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(model, package_loader,",
            "                                       tenant_id=TENANT_ID)",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "",
            "        return rules_str",
            "",
            "    def test_transitive_closure(self):",
            "        closure = congress.CongressRulesManager.transitive_closure(",
            "            [(1, 2), (2, 3), (3, 4)])",
            "        self.assertTrue((1, 4) in closure)",
            "        self.assertTrue((2, 4) in closure)",
            "",
            "    def test_empty_model(self):",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(None)",
            "        self.assertEqual(0, len(rules))",
            "",
            "    def test_convert_simple_app(self):",
            "        rules_str = self._create_and_check_rules_str('model')",
            "",
            "        self.assertFalse(\"instance.\" in rules_str)",
            "",
            "    def test_convert_model_two_instances(self):",
            "        rules_str = self._create_and_check_rules_str('model_two_instances')",
            "",
            "        self.assertFalse(\"\\\"instances\\\"\" in rules_str)",
            "",
            "    def test_convert_model_with_relations(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertFalse(",
            "            'murano:properties+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"server\", \"8ce94f23-f16a-40a1-9d9d-a877266c315d\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", \"server\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"0aafd67e-72e9-4ae0-bb62-fe724f77df2a\", '",
            "            '\"ed8df2b0-ddd2-4009-b3c9-2e7a368f3cb8\", \"instance\")' in rules_str)",
            "",
            "    def test_convert_model_transitive_relationships(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:connected+(\"50fa68ff-cd9a-4845-b573-2c80879d158d\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:connected+(\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", '",
            "            '\"fc6b8c41-166f-4fc9-a640-d82009e0a03d\")' in rules_str)",
            "",
            "    def test_convert_model_services_relationship(self):",
            "        rules_str = self._create_rules_str('model_with_relations.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"3409bdd0590e4c60b70fda5e6777ff96\", '",
            "            '\"8ce94f23-f16a-40a1-9d9d-a877266c315d\", \"services\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:relationships+(\"3409bdd0590e4c60b70fda5e6777ff96\", '",
            "            '\"50fa68ff-cd9a-4845-b573-2c80879d158d\", \"services\")' in rules_str)",
            "",
            "    def test_convert_model_complex(self):",
            "        self._create_and_check_rules_str('model_complex')",
            "",
            "    def test_convert_renamed_app(self):",
            "        self._create_and_check_rules_str('model_renamed')",
            "",
            "    def test_parent_types(self):",
            "",
            "        #     grand-parent",
            "        #       /     \\",
            "        #  parent1   parent2",
            "        #       \\     /",
            "        # io.murano.apps.linux.Git",
            "",
            "        package_loader = MockPackageLoader([",
            "            'io.murano.apps.linux.Git->parent1',",
            "            'io.murano.apps.linux.Git->parent2',",
            "            'parent1->grand-parent',",
            "            'parent2->grand-parent'",
            "        ])",
            "",
            "        rules_str = self._create_rules_str('model.yaml', package_loader)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"parent1\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"parent2\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"grand-parent\")' in rules_str)",
            "",
            "        self.assertTrue(",
            "            'murano:parent_types+(\"0c810278-7282-4e4a-9d69-7b4c36b6ce6f\",'",
            "            ' \"io.murano.apps.linux.Git\")' in rules_str)",
            "",
            "    def test_to_dictionary(self):",
            "        \"\"\"test to_dictionary",
            "",
            "        If model contains object entry (not dict)",
            "        we try to convert to dict using 'to_dictionary' method.",
            "        \"\"\"",
            "",
            "        class Struct(object):",
            "            def __init__(self, d):",
            "                self.__dict__ = d",
            "",
            "            def to_dictionary(self):",
            "                return self.__dict__",
            "",
            "            def __getitem__(self, item):",
            "                return self.__dict__[item]",
            "",
            "        d = {'?': {'id': '1', 'type': 't1'},",
            "             'apps': [Struct({'?': {'id': '2', 'type': 't2'},",
            "                              'instances': [Struct(",
            "                                  {'?': {'id': '3', 'type': 't3'}})]})]",
            "             }",
            "",
            "        model = Struct(d)",
            "",
            "        congress_rules = congress.CongressRulesManager()",
            "        tenant_id = uuidutils.generate_uuid()",
            "        rules = congress_rules.convert(model, tenant_id=tenant_id)",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "",
            "        self.assertTrue('murano:objects+(\"1\", \"{0}\", \"t1\")'.format(tenant_id)",
            "                        in rules_str)",
            "        self.assertTrue('murano:objects+(\"2\", \"1\", \"t2\")' in rules_str)",
            "        self.assertTrue('murano:objects+(\"3\", \"2\", \"t3\")' in rules_str)",
            "",
            "    def test_environment_owner(self):",
            "        model = self._load_file(\"model.yaml\")",
            "        congress_rules = congress.CongressRulesManager()",
            "        rules = congress_rules.convert(model, tenant_id='tenant1')",
            "        rules_str = \", \\n\".join(map(str, rules))",
            "        self.assertTrue('murano:objects+(\"c86104748a0c4907b4c5981e6d3bce9f\", '",
            "                        '\"tenant1\", \"io.murano.Environment\")' in rules_str)",
            "",
            "    def test_wordpress(self):",
            "        package_loader = MockPackageLoader([",
            "            'io.murano.Environment->io.murano.Object',",
            "            'io.murano.resources.NeutronNetwork->io.murano.resources.Network',",
            "            'io.murano.resources.Network->io.murano.Object',",
            "            'io.murano.databases.MySql->io.murano.databases.SqlDatabase',",
            "            'io.murano.databases.MySql->io.murano.Application',",
            "            'io.murano.databases.SqlDatabase->io.murano.Object',",
            "            'io.murano.resources.LinuxInstance->io.murano.resources.Instance',",
            "            'io.murano.resources.Instance->io.murano.Object',",
            "            'io.murano.Application->io.murano.Object',",
            "            'io.murano.apps.apache.ApacheHttpServer->io.murano.Application',",
            "            'io.murano.apps.ZabbixServer->io.murano.Application',",
            "            'io.murano.apps.ZabbixAgent->io.murano.Application',",
            "            'io.murano.apps.WordPress->io.murano.Application',",
            "",
            "            'io.murano.resources.LinuxMuranoInstance->'",
            "            'io.murano.resources.LinuxInstance'",
            "        ])",
            "",
            "        self._create_and_check_rules_str('wordpress', package_loader)",
            "",
            "    def _create_and_check_rules_str(self, model_name, package_loader=None):",
            "        rules_str = self._create_rules_str(",
            "            '{0}.yaml'.format(model_name), package_loader)",
            "        self._check_expected_rules(rules_str,",
            "                                   'expected_rules_{0}.txt'.format(model_name))",
            "        return rules_str",
            "",
            "    def _check_expected_rules(self, rules_str, expected_rules_file_name):",
            "        expected_rules_file = os.path.join(",
            "            os.path.dirname(inspect.getfile(self.__class__)),",
            "            expected_rules_file_name)",
            "",
            "        s = ''",
            "        with open(expected_rules_file) as f:",
            "            for line in f:",
            "                line = line.rstrip('\\n')",
            "                if line not in rules_str:",
            "                    s += 'Expected rule not found:\\n\\t' + line + '\\n'",
            "",
            "        if len(s) > 0:",
            "            self.fail(s)",
            "",
            "    def test_state_rule(self):",
            "        rules_str = self._create_rules_str('model.yaml')",
            "",
            "        self.assertTrue(",
            "            'murano:states+(\"c86104748a0c4907b4c5981e6d3bce9f\", \"pending\")'",
            "            in rules_str)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "90": [
                "TestCongressRules",
                "_load_file"
            ]
        },
        "addLocation": []
    }
}