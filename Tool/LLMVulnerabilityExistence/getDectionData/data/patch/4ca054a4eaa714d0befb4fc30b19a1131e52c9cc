{
    "synapse/config/repository.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from collections import namedtuple"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from typing import Dict, List"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from netaddr import IPSet"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from synapse.config.server import DEFAULT_IP_RANGE_BLACKLIST"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from synapse.config.server import DEFAULT_IP_RANGE_BLACKLIST, generate_ip_set"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from synapse.python_dependencies import DependencyException, check_requirements"
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from synapse.util.module_loader import load_module"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "                     \"to work\""
            },
            "11": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "                 )"
            },
            "12": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.url_preview_ip_range_blacklist = IPSet("
            },
            "14": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                config[\"url_preview_ip_range_blacklist\"]"
            },
            "15": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "16": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "             # we always blacklist '0.0.0.0' and '::', which are supposed to be"
            },
            "18": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             # unroutable addresses."
            },
            "19": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.url_preview_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            self.url_preview_ip_range_blacklist = generate_ip_set("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                config[\"url_preview_ip_range_blacklist\"],"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                [\"0.0.0.0\", \"::\"],"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                config_path=(\"url_preview_ip_range_blacklist\",),"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            )"
            },
            "25": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.url_preview_ip_range_whitelist = IPSet("
            },
            "27": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                config.get(\"url_preview_ip_range_whitelist\", ())"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            self.url_preview_ip_range_whitelist = generate_ip_set("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                config.get(\"url_preview_ip_range_whitelist\", ()),"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                config_path=(\"url_preview_ip_range_whitelist\",),"
            },
            "31": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "             )"
            },
            "32": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "             self.url_preview_url_blacklist = config.get(\"url_preview_url_blacklist\", ())"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014, 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "from collections import namedtuple",
            "from typing import Dict, List",
            "",
            "from netaddr import IPSet",
            "",
            "from synapse.config.server import DEFAULT_IP_RANGE_BLACKLIST",
            "from synapse.python_dependencies import DependencyException, check_requirements",
            "from synapse.util.module_loader import load_module",
            "",
            "from ._base import Config, ConfigError",
            "",
            "DEFAULT_THUMBNAIL_SIZES = [",
            "    {\"width\": 32, \"height\": 32, \"method\": \"crop\"},",
            "    {\"width\": 96, \"height\": 96, \"method\": \"crop\"},",
            "    {\"width\": 320, \"height\": 240, \"method\": \"scale\"},",
            "    {\"width\": 640, \"height\": 480, \"method\": \"scale\"},",
            "    {\"width\": 800, \"height\": 600, \"method\": \"scale\"},",
            "]",
            "",
            "THUMBNAIL_SIZE_YAML = \"\"\"\\",
            "        #  - width: %(width)i",
            "        #    height: %(height)i",
            "        #    method: %(method)s",
            "\"\"\"",
            "",
            "ThumbnailRequirement = namedtuple(",
            "    \"ThumbnailRequirement\", [\"width\", \"height\", \"method\", \"media_type\"]",
            ")",
            "",
            "MediaStorageProviderConfig = namedtuple(",
            "    \"MediaStorageProviderConfig\",",
            "    (",
            "        \"store_local\",  # Whether to store newly uploaded local files",
            "        \"store_remote\",  # Whether to store newly downloaded remote files",
            "        \"store_synchronous\",  # Whether to wait for successful storage for local uploads",
            "    ),",
            ")",
            "",
            "",
            "def parse_thumbnail_requirements(thumbnail_sizes):",
            "    \"\"\" Takes a list of dictionaries with \"width\", \"height\", and \"method\" keys",
            "    and creates a map from image media types to the thumbnail size, thumbnailing",
            "    method, and thumbnail media type to precalculate",
            "",
            "    Args:",
            "        thumbnail_sizes(list): List of dicts with \"width\", \"height\", and",
            "            \"method\" keys",
            "    Returns:",
            "        Dictionary mapping from media type string to list of",
            "        ThumbnailRequirement tuples.",
            "    \"\"\"",
            "    requirements = {}  # type: Dict[str, List]",
            "    for size in thumbnail_sizes:",
            "        width = size[\"width\"]",
            "        height = size[\"height\"]",
            "        method = size[\"method\"]",
            "        jpeg_thumbnail = ThumbnailRequirement(width, height, method, \"image/jpeg\")",
            "        png_thumbnail = ThumbnailRequirement(width, height, method, \"image/png\")",
            "        requirements.setdefault(\"image/jpeg\", []).append(jpeg_thumbnail)",
            "        requirements.setdefault(\"image/webp\", []).append(jpeg_thumbnail)",
            "        requirements.setdefault(\"image/gif\", []).append(png_thumbnail)",
            "        requirements.setdefault(\"image/png\", []).append(png_thumbnail)",
            "    return {",
            "        media_type: tuple(thumbnails) for media_type, thumbnails in requirements.items()",
            "    }",
            "",
            "",
            "class ContentRepositoryConfig(Config):",
            "    section = \"media\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "",
            "        # Only enable the media repo if either the media repo is enabled or the",
            "        # current worker app is the media repo.",
            "        if (",
            "            self.enable_media_repo is False",
            "            and config.get(\"worker_app\") != \"synapse.app.media_repository\"",
            "        ):",
            "            self.can_load_media_repo = False",
            "            return",
            "        else:",
            "            self.can_load_media_repo = True",
            "",
            "        # Whether this instance should be the one to run the background jobs to",
            "        # e.g clean up old URL previews.",
            "        self.media_instance_running_background_jobs = config.get(",
            "            \"media_instance_running_background_jobs\",",
            "        )",
            "",
            "        self.max_upload_size = self.parse_size(config.get(\"max_upload_size\", \"50M\"))",
            "        self.max_image_pixels = self.parse_size(config.get(\"max_image_pixels\", \"32M\"))",
            "        self.max_spider_size = self.parse_size(config.get(\"max_spider_size\", \"10M\"))",
            "",
            "        self.media_store_path = self.ensure_directory(",
            "            config.get(\"media_store_path\", \"media_store\")",
            "        )",
            "",
            "        backup_media_store_path = config.get(\"backup_media_store_path\")",
            "",
            "        synchronous_backup_media_store = config.get(",
            "            \"synchronous_backup_media_store\", False",
            "        )",
            "",
            "        storage_providers = config.get(\"media_storage_providers\", [])",
            "",
            "        if backup_media_store_path:",
            "            if storage_providers:",
            "                raise ConfigError(",
            "                    \"Cannot use both 'backup_media_store_path' and 'storage_providers'\"",
            "                )",
            "",
            "            storage_providers = [",
            "                {",
            "                    \"module\": \"file_system\",",
            "                    \"store_local\": True,",
            "                    \"store_synchronous\": synchronous_backup_media_store,",
            "                    \"store_remote\": True,",
            "                    \"config\": {\"directory\": backup_media_store_path},",
            "                }",
            "            ]",
            "",
            "        # This is a list of config that can be used to create the storage",
            "        # providers. The entries are tuples of (Class, class_config,",
            "        # MediaStorageProviderConfig), where Class is the class of the provider,",
            "        # the class_config the config to pass to it, and",
            "        # MediaStorageProviderConfig are options for StorageProviderWrapper.",
            "        #",
            "        # We don't create the storage providers here as not all workers need",
            "        # them to be started.",
            "        self.media_storage_providers = []  # type: List[tuple]",
            "",
            "        for i, provider_config in enumerate(storage_providers):",
            "            # We special case the module \"file_system\" so as not to need to",
            "            # expose FileStorageProviderBackend",
            "            if provider_config[\"module\"] == \"file_system\":",
            "                provider_config[\"module\"] = (",
            "                    \"synapse.rest.media.v1.storage_provider\"",
            "                    \".FileStorageProviderBackend\"",
            "                )",
            "",
            "            provider_class, parsed_config = load_module(",
            "                provider_config, (\"media_storage_providers\", \"<item %i>\" % i)",
            "            )",
            "",
            "            wrapper_config = MediaStorageProviderConfig(",
            "                provider_config.get(\"store_local\", False),",
            "                provider_config.get(\"store_remote\", False),",
            "                provider_config.get(\"store_synchronous\", False),",
            "            )",
            "",
            "            self.media_storage_providers.append(",
            "                (provider_class, parsed_config, wrapper_config)",
            "            )",
            "",
            "        self.dynamic_thumbnails = config.get(\"dynamic_thumbnails\", False)",
            "        self.thumbnail_requirements = parse_thumbnail_requirements(",
            "            config.get(\"thumbnail_sizes\", DEFAULT_THUMBNAIL_SIZES)",
            "        )",
            "        self.url_preview_enabled = config.get(\"url_preview_enabled\", False)",
            "        if self.url_preview_enabled:",
            "            try:",
            "                check_requirements(\"url_preview\")",
            "",
            "            except DependencyException as e:",
            "                raise ConfigError(e.message)",
            "",
            "            if \"url_preview_ip_range_blacklist\" not in config:",
            "                raise ConfigError(",
            "                    \"For security, you must specify an explicit target IP address \"",
            "                    \"blacklist in url_preview_ip_range_blacklist for url previewing \"",
            "                    \"to work\"",
            "                )",
            "",
            "            self.url_preview_ip_range_blacklist = IPSet(",
            "                config[\"url_preview_ip_range_blacklist\"]",
            "            )",
            "",
            "            # we always blacklist '0.0.0.0' and '::', which are supposed to be",
            "            # unroutable addresses.",
            "            self.url_preview_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])",
            "",
            "            self.url_preview_ip_range_whitelist = IPSet(",
            "                config.get(\"url_preview_ip_range_whitelist\", ())",
            "            )",
            "",
            "            self.url_preview_url_blacklist = config.get(\"url_preview_url_blacklist\", ())",
            "",
            "            self.url_preview_accept_language = config.get(",
            "                \"url_preview_accept_language\"",
            "            ) or [\"en\"]",
            "",
            "    def generate_config_section(self, data_dir_path, **kwargs):",
            "        media_store = os.path.join(data_dir_path, \"media_store\")",
            "        uploads_path = os.path.join(data_dir_path, \"uploads\")",
            "",
            "        formatted_thumbnail_sizes = \"\".join(",
            "            THUMBNAIL_SIZE_YAML % s for s in DEFAULT_THUMBNAIL_SIZES",
            "        )",
            "        # strip final NL",
            "        formatted_thumbnail_sizes = formatted_thumbnail_sizes[:-1]",
            "",
            "        ip_range_blacklist = \"\\n\".join(",
            "            \"        #  - '%s'\" % ip for ip in DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        return (",
            "            r\"\"\"",
            "        ## Media Store ##",
            "",
            "        # Enable the media store service in the Synapse master. Uncomment the",
            "        # following if you are using a separate media store worker.",
            "        #",
            "        #enable_media_repo: false",
            "",
            "        # Directory where uploaded images and attachments are stored.",
            "        #",
            "        media_store_path: \"%(media_store)s\"",
            "",
            "        # Media storage providers allow media to be stored in different",
            "        # locations.",
            "        #",
            "        #media_storage_providers:",
            "        #  - module: file_system",
            "        #    # Whether to store newly uploaded local files",
            "        #    store_local: false",
            "        #    # Whether to store newly downloaded remote files",
            "        #    store_remote: false",
            "        #    # Whether to wait for successful storage for local uploads",
            "        #    store_synchronous: false",
            "        #    config:",
            "        #       directory: /mnt/some/other/directory",
            "",
            "        # The largest allowed upload size in bytes",
            "        #",
            "        #max_upload_size: 50M",
            "",
            "        # Maximum number of pixels that will be thumbnailed",
            "        #",
            "        #max_image_pixels: 32M",
            "",
            "        # Whether to generate new thumbnails on the fly to precisely match",
            "        # the resolution requested by the client. If true then whenever",
            "        # a new resolution is requested by the client the server will",
            "        # generate a new thumbnail. If false the server will pick a thumbnail",
            "        # from a precalculated list.",
            "        #",
            "        #dynamic_thumbnails: false",
            "",
            "        # List of thumbnails to precalculate when an image is uploaded.",
            "        #",
            "        #thumbnail_sizes:",
            "%(formatted_thumbnail_sizes)s",
            "",
            "        # Is the preview URL API enabled?",
            "        #",
            "        # 'false' by default: uncomment the following to enable it (and specify a",
            "        # url_preview_ip_range_blacklist blacklist).",
            "        #",
            "        #url_preview_enabled: true",
            "",
            "        # List of IP address CIDR ranges that the URL preview spider is denied",
            "        # from accessing.  There are no defaults: you must explicitly",
            "        # specify a list for URL previewing to work.  You should specify any",
            "        # internal services in your network that you do not want synapse to try",
            "        # to connect to, otherwise anyone in any Matrix room could cause your",
            "        # synapse to issue arbitrary GET requests to your internal services,",
            "        # causing serious security issues.",
            "        #",
            "        # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly",
            "        # listed here, since they correspond to unroutable addresses.)",
            "        #",
            "        # This must be specified if url_preview_enabled is set. It is recommended that",
            "        # you uncomment the following list as a starting point.",
            "        #",
            "        #url_preview_ip_range_blacklist:",
            "%(ip_range_blacklist)s",
            "",
            "        # List of IP address CIDR ranges that the URL preview spider is allowed",
            "        # to access even if they are specified in url_preview_ip_range_blacklist.",
            "        # This is useful for specifying exceptions to wide-ranging blacklisted",
            "        # target IP ranges - e.g. for enabling URL previews for a specific private",
            "        # website only visible in your network.",
            "        #",
            "        #url_preview_ip_range_whitelist:",
            "        #   - '192.168.1.1'",
            "",
            "        # Optional list of URL matches that the URL preview spider is",
            "        # denied from accessing.  You should use url_preview_ip_range_blacklist",
            "        # in preference to this, otherwise someone could define a public DNS",
            "        # entry that points to a private IP address and circumvent the blacklist.",
            "        # This is more useful if you know there is an entire shape of URL that",
            "        # you know that will never want synapse to try to spider.",
            "        #",
            "        # Each list entry is a dictionary of url component attributes as returned",
            "        # by urlparse.urlsplit as applied to the absolute form of the URL.  See",
            "        # https://docs.python.org/2/library/urlparse.html#urlparse.urlsplit",
            "        # The values of the dictionary are treated as an filename match pattern",
            "        # applied to that component of URLs, unless they start with a ^ in which",
            "        # case they are treated as a regular expression match.  If all the",
            "        # specified component matches for a given list item succeed, the URL is",
            "        # blacklisted.",
            "        #",
            "        #url_preview_url_blacklist:",
            "        #  # blacklist any URL with a username in its URI",
            "        #  - username: '*'",
            "        #",
            "        #  # blacklist all *.google.com URLs",
            "        #  - netloc: 'google.com'",
            "        #  - netloc: '*.google.com'",
            "        #",
            "        #  # blacklist all plain HTTP URLs",
            "        #  - scheme: 'http'",
            "        #",
            "        #  # blacklist http(s)://www.acme.com/foo",
            "        #  - netloc: 'www.acme.com'",
            "        #    path: '/foo'",
            "        #",
            "        #  # blacklist any URL with a literal IPv4 address",
            "        #  - netloc: '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$'",
            "",
            "        # The largest allowed URL preview spidering size in bytes",
            "        #",
            "        #max_spider_size: 10M",
            "",
            "        # A list of values for the Accept-Language HTTP header used when",
            "        # downloading webpages during URL preview generation. This allows",
            "        # Synapse to specify the preferred languages that URL previews should",
            "        # be in when communicating with remote servers.",
            "        #",
            "        # Each value is a IETF language tag; a 2-3 letter identifier for a",
            "        # language, optionally followed by subtags separated by '-', specifying",
            "        # a country or region variant.",
            "        #",
            "        # Multiple values can be provided, and a weight can be added to each by",
            "        # using quality value syntax (;q=). '*' translates to any language.",
            "        #",
            "        # Defaults to \"en\".",
            "        #",
            "        # Example:",
            "        #",
            "        # url_preview_accept_language:",
            "        #   - en-UK",
            "        #   - en-US;q=0.9",
            "        #   - fr;q=0.8",
            "        #   - *;q=0.7",
            "        #",
            "        url_preview_accept_language:",
            "        #   - en",
            "        \"\"\"",
            "            % locals()",
            "        )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014, 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "from collections import namedtuple",
            "from typing import Dict, List",
            "",
            "from synapse.config.server import DEFAULT_IP_RANGE_BLACKLIST, generate_ip_set",
            "from synapse.python_dependencies import DependencyException, check_requirements",
            "from synapse.util.module_loader import load_module",
            "",
            "from ._base import Config, ConfigError",
            "",
            "DEFAULT_THUMBNAIL_SIZES = [",
            "    {\"width\": 32, \"height\": 32, \"method\": \"crop\"},",
            "    {\"width\": 96, \"height\": 96, \"method\": \"crop\"},",
            "    {\"width\": 320, \"height\": 240, \"method\": \"scale\"},",
            "    {\"width\": 640, \"height\": 480, \"method\": \"scale\"},",
            "    {\"width\": 800, \"height\": 600, \"method\": \"scale\"},",
            "]",
            "",
            "THUMBNAIL_SIZE_YAML = \"\"\"\\",
            "        #  - width: %(width)i",
            "        #    height: %(height)i",
            "        #    method: %(method)s",
            "\"\"\"",
            "",
            "ThumbnailRequirement = namedtuple(",
            "    \"ThumbnailRequirement\", [\"width\", \"height\", \"method\", \"media_type\"]",
            ")",
            "",
            "MediaStorageProviderConfig = namedtuple(",
            "    \"MediaStorageProviderConfig\",",
            "    (",
            "        \"store_local\",  # Whether to store newly uploaded local files",
            "        \"store_remote\",  # Whether to store newly downloaded remote files",
            "        \"store_synchronous\",  # Whether to wait for successful storage for local uploads",
            "    ),",
            ")",
            "",
            "",
            "def parse_thumbnail_requirements(thumbnail_sizes):",
            "    \"\"\" Takes a list of dictionaries with \"width\", \"height\", and \"method\" keys",
            "    and creates a map from image media types to the thumbnail size, thumbnailing",
            "    method, and thumbnail media type to precalculate",
            "",
            "    Args:",
            "        thumbnail_sizes(list): List of dicts with \"width\", \"height\", and",
            "            \"method\" keys",
            "    Returns:",
            "        Dictionary mapping from media type string to list of",
            "        ThumbnailRequirement tuples.",
            "    \"\"\"",
            "    requirements = {}  # type: Dict[str, List]",
            "    for size in thumbnail_sizes:",
            "        width = size[\"width\"]",
            "        height = size[\"height\"]",
            "        method = size[\"method\"]",
            "        jpeg_thumbnail = ThumbnailRequirement(width, height, method, \"image/jpeg\")",
            "        png_thumbnail = ThumbnailRequirement(width, height, method, \"image/png\")",
            "        requirements.setdefault(\"image/jpeg\", []).append(jpeg_thumbnail)",
            "        requirements.setdefault(\"image/webp\", []).append(jpeg_thumbnail)",
            "        requirements.setdefault(\"image/gif\", []).append(png_thumbnail)",
            "        requirements.setdefault(\"image/png\", []).append(png_thumbnail)",
            "    return {",
            "        media_type: tuple(thumbnails) for media_type, thumbnails in requirements.items()",
            "    }",
            "",
            "",
            "class ContentRepositoryConfig(Config):",
            "    section = \"media\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "",
            "        # Only enable the media repo if either the media repo is enabled or the",
            "        # current worker app is the media repo.",
            "        if (",
            "            self.enable_media_repo is False",
            "            and config.get(\"worker_app\") != \"synapse.app.media_repository\"",
            "        ):",
            "            self.can_load_media_repo = False",
            "            return",
            "        else:",
            "            self.can_load_media_repo = True",
            "",
            "        # Whether this instance should be the one to run the background jobs to",
            "        # e.g clean up old URL previews.",
            "        self.media_instance_running_background_jobs = config.get(",
            "            \"media_instance_running_background_jobs\",",
            "        )",
            "",
            "        self.max_upload_size = self.parse_size(config.get(\"max_upload_size\", \"50M\"))",
            "        self.max_image_pixels = self.parse_size(config.get(\"max_image_pixels\", \"32M\"))",
            "        self.max_spider_size = self.parse_size(config.get(\"max_spider_size\", \"10M\"))",
            "",
            "        self.media_store_path = self.ensure_directory(",
            "            config.get(\"media_store_path\", \"media_store\")",
            "        )",
            "",
            "        backup_media_store_path = config.get(\"backup_media_store_path\")",
            "",
            "        synchronous_backup_media_store = config.get(",
            "            \"synchronous_backup_media_store\", False",
            "        )",
            "",
            "        storage_providers = config.get(\"media_storage_providers\", [])",
            "",
            "        if backup_media_store_path:",
            "            if storage_providers:",
            "                raise ConfigError(",
            "                    \"Cannot use both 'backup_media_store_path' and 'storage_providers'\"",
            "                )",
            "",
            "            storage_providers = [",
            "                {",
            "                    \"module\": \"file_system\",",
            "                    \"store_local\": True,",
            "                    \"store_synchronous\": synchronous_backup_media_store,",
            "                    \"store_remote\": True,",
            "                    \"config\": {\"directory\": backup_media_store_path},",
            "                }",
            "            ]",
            "",
            "        # This is a list of config that can be used to create the storage",
            "        # providers. The entries are tuples of (Class, class_config,",
            "        # MediaStorageProviderConfig), where Class is the class of the provider,",
            "        # the class_config the config to pass to it, and",
            "        # MediaStorageProviderConfig are options for StorageProviderWrapper.",
            "        #",
            "        # We don't create the storage providers here as not all workers need",
            "        # them to be started.",
            "        self.media_storage_providers = []  # type: List[tuple]",
            "",
            "        for i, provider_config in enumerate(storage_providers):",
            "            # We special case the module \"file_system\" so as not to need to",
            "            # expose FileStorageProviderBackend",
            "            if provider_config[\"module\"] == \"file_system\":",
            "                provider_config[\"module\"] = (",
            "                    \"synapse.rest.media.v1.storage_provider\"",
            "                    \".FileStorageProviderBackend\"",
            "                )",
            "",
            "            provider_class, parsed_config = load_module(",
            "                provider_config, (\"media_storage_providers\", \"<item %i>\" % i)",
            "            )",
            "",
            "            wrapper_config = MediaStorageProviderConfig(",
            "                provider_config.get(\"store_local\", False),",
            "                provider_config.get(\"store_remote\", False),",
            "                provider_config.get(\"store_synchronous\", False),",
            "            )",
            "",
            "            self.media_storage_providers.append(",
            "                (provider_class, parsed_config, wrapper_config)",
            "            )",
            "",
            "        self.dynamic_thumbnails = config.get(\"dynamic_thumbnails\", False)",
            "        self.thumbnail_requirements = parse_thumbnail_requirements(",
            "            config.get(\"thumbnail_sizes\", DEFAULT_THUMBNAIL_SIZES)",
            "        )",
            "        self.url_preview_enabled = config.get(\"url_preview_enabled\", False)",
            "        if self.url_preview_enabled:",
            "            try:",
            "                check_requirements(\"url_preview\")",
            "",
            "            except DependencyException as e:",
            "                raise ConfigError(e.message)",
            "",
            "            if \"url_preview_ip_range_blacklist\" not in config:",
            "                raise ConfigError(",
            "                    \"For security, you must specify an explicit target IP address \"",
            "                    \"blacklist in url_preview_ip_range_blacklist for url previewing \"",
            "                    \"to work\"",
            "                )",
            "",
            "            # we always blacklist '0.0.0.0' and '::', which are supposed to be",
            "            # unroutable addresses.",
            "            self.url_preview_ip_range_blacklist = generate_ip_set(",
            "                config[\"url_preview_ip_range_blacklist\"],",
            "                [\"0.0.0.0\", \"::\"],",
            "                config_path=(\"url_preview_ip_range_blacklist\",),",
            "            )",
            "",
            "            self.url_preview_ip_range_whitelist = generate_ip_set(",
            "                config.get(\"url_preview_ip_range_whitelist\", ()),",
            "                config_path=(\"url_preview_ip_range_whitelist\",),",
            "            )",
            "",
            "            self.url_preview_url_blacklist = config.get(\"url_preview_url_blacklist\", ())",
            "",
            "            self.url_preview_accept_language = config.get(",
            "                \"url_preview_accept_language\"",
            "            ) or [\"en\"]",
            "",
            "    def generate_config_section(self, data_dir_path, **kwargs):",
            "        media_store = os.path.join(data_dir_path, \"media_store\")",
            "        uploads_path = os.path.join(data_dir_path, \"uploads\")",
            "",
            "        formatted_thumbnail_sizes = \"\".join(",
            "            THUMBNAIL_SIZE_YAML % s for s in DEFAULT_THUMBNAIL_SIZES",
            "        )",
            "        # strip final NL",
            "        formatted_thumbnail_sizes = formatted_thumbnail_sizes[:-1]",
            "",
            "        ip_range_blacklist = \"\\n\".join(",
            "            \"        #  - '%s'\" % ip for ip in DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        return (",
            "            r\"\"\"",
            "        ## Media Store ##",
            "",
            "        # Enable the media store service in the Synapse master. Uncomment the",
            "        # following if you are using a separate media store worker.",
            "        #",
            "        #enable_media_repo: false",
            "",
            "        # Directory where uploaded images and attachments are stored.",
            "        #",
            "        media_store_path: \"%(media_store)s\"",
            "",
            "        # Media storage providers allow media to be stored in different",
            "        # locations.",
            "        #",
            "        #media_storage_providers:",
            "        #  - module: file_system",
            "        #    # Whether to store newly uploaded local files",
            "        #    store_local: false",
            "        #    # Whether to store newly downloaded remote files",
            "        #    store_remote: false",
            "        #    # Whether to wait for successful storage for local uploads",
            "        #    store_synchronous: false",
            "        #    config:",
            "        #       directory: /mnt/some/other/directory",
            "",
            "        # The largest allowed upload size in bytes",
            "        #",
            "        #max_upload_size: 50M",
            "",
            "        # Maximum number of pixels that will be thumbnailed",
            "        #",
            "        #max_image_pixels: 32M",
            "",
            "        # Whether to generate new thumbnails on the fly to precisely match",
            "        # the resolution requested by the client. If true then whenever",
            "        # a new resolution is requested by the client the server will",
            "        # generate a new thumbnail. If false the server will pick a thumbnail",
            "        # from a precalculated list.",
            "        #",
            "        #dynamic_thumbnails: false",
            "",
            "        # List of thumbnails to precalculate when an image is uploaded.",
            "        #",
            "        #thumbnail_sizes:",
            "%(formatted_thumbnail_sizes)s",
            "",
            "        # Is the preview URL API enabled?",
            "        #",
            "        # 'false' by default: uncomment the following to enable it (and specify a",
            "        # url_preview_ip_range_blacklist blacklist).",
            "        #",
            "        #url_preview_enabled: true",
            "",
            "        # List of IP address CIDR ranges that the URL preview spider is denied",
            "        # from accessing.  There are no defaults: you must explicitly",
            "        # specify a list for URL previewing to work.  You should specify any",
            "        # internal services in your network that you do not want synapse to try",
            "        # to connect to, otherwise anyone in any Matrix room could cause your",
            "        # synapse to issue arbitrary GET requests to your internal services,",
            "        # causing serious security issues.",
            "        #",
            "        # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly",
            "        # listed here, since they correspond to unroutable addresses.)",
            "        #",
            "        # This must be specified if url_preview_enabled is set. It is recommended that",
            "        # you uncomment the following list as a starting point.",
            "        #",
            "        #url_preview_ip_range_blacklist:",
            "%(ip_range_blacklist)s",
            "",
            "        # List of IP address CIDR ranges that the URL preview spider is allowed",
            "        # to access even if they are specified in url_preview_ip_range_blacklist.",
            "        # This is useful for specifying exceptions to wide-ranging blacklisted",
            "        # target IP ranges - e.g. for enabling URL previews for a specific private",
            "        # website only visible in your network.",
            "        #",
            "        #url_preview_ip_range_whitelist:",
            "        #   - '192.168.1.1'",
            "",
            "        # Optional list of URL matches that the URL preview spider is",
            "        # denied from accessing.  You should use url_preview_ip_range_blacklist",
            "        # in preference to this, otherwise someone could define a public DNS",
            "        # entry that points to a private IP address and circumvent the blacklist.",
            "        # This is more useful if you know there is an entire shape of URL that",
            "        # you know that will never want synapse to try to spider.",
            "        #",
            "        # Each list entry is a dictionary of url component attributes as returned",
            "        # by urlparse.urlsplit as applied to the absolute form of the URL.  See",
            "        # https://docs.python.org/2/library/urlparse.html#urlparse.urlsplit",
            "        # The values of the dictionary are treated as an filename match pattern",
            "        # applied to that component of URLs, unless they start with a ^ in which",
            "        # case they are treated as a regular expression match.  If all the",
            "        # specified component matches for a given list item succeed, the URL is",
            "        # blacklisted.",
            "        #",
            "        #url_preview_url_blacklist:",
            "        #  # blacklist any URL with a username in its URI",
            "        #  - username: '*'",
            "        #",
            "        #  # blacklist all *.google.com URLs",
            "        #  - netloc: 'google.com'",
            "        #  - netloc: '*.google.com'",
            "        #",
            "        #  # blacklist all plain HTTP URLs",
            "        #  - scheme: 'http'",
            "        #",
            "        #  # blacklist http(s)://www.acme.com/foo",
            "        #  - netloc: 'www.acme.com'",
            "        #    path: '/foo'",
            "        #",
            "        #  # blacklist any URL with a literal IPv4 address",
            "        #  - netloc: '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$'",
            "",
            "        # The largest allowed URL preview spidering size in bytes",
            "        #",
            "        #max_spider_size: 10M",
            "",
            "        # A list of values for the Accept-Language HTTP header used when",
            "        # downloading webpages during URL preview generation. This allows",
            "        # Synapse to specify the preferred languages that URL previews should",
            "        # be in when communicating with remote servers.",
            "        #",
            "        # Each value is a IETF language tag; a 2-3 letter identifier for a",
            "        # language, optionally followed by subtags separated by '-', specifying",
            "        # a country or region variant.",
            "        #",
            "        # Multiple values can be provided, and a weight can be added to each by",
            "        # using quality value syntax (;q=). '*' translates to any language.",
            "        #",
            "        # Defaults to \"en\".",
            "        #",
            "        # Example:",
            "        #",
            "        # url_preview_accept_language:",
            "        #   - en-UK",
            "        #   - en-US;q=0.9",
            "        #   - fr;q=0.8",
            "        #   - *;q=0.7",
            "        #",
            "        url_preview_accept_language:",
            "        #   - en",
            "        \"\"\"",
            "            % locals()",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [],
            "21": [],
            "22": [],
            "190": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "191": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "192": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "193": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "196": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "198": [
                "ContentRepositoryConfig",
                "read_config"
            ],
            "199": [
                "ContentRepositoryConfig",
                "read_config"
            ]
        },
        "addLocation": []
    },
    "synapse/config/server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " # See the License for the specific language governing permissions and"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " # limitations under the License."
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+import itertools"
            },
            "4": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import logging"
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import os.path"
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import re"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import attr"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import yaml"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from netaddr import IPSet"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from netaddr import AddrFormatError, IPNetwork, IPSet"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from synapse.api.room_versions import KNOWN_ROOM_VERSIONS"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from synapse.util.stringutils import parse_and_validate_server_name"
            },
            "15": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " # in the list."
            },
            "16": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " DEFAULT_BIND_ADDRESSES = [\"::\", \"0.0.0.0\"]"
            },
            "17": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+def _6to4(network: IPNetwork) -> IPNetwork:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    \"\"\"Convert an IPv4 network into a 6to4 IPv6 network per RFC 3056.\"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    # 6to4 networks consist of:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    # * 2002 as the first 16 bits"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    # * The first IPv4 address in the network hex-encoded as the next 32 bits"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    # * The new prefix length needs to include the bits from the 2002 prefix."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    hex_network = hex(network.first)[2:]"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    hex_network = (\"0\" * (8 - len(hex_network))) + hex_network"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    return IPNetwork("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        \"2002:%s:%s::/%d\" % (hex_network[:4], hex_network[4:], 16 + network.prefixlen,)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    )"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+def generate_ip_set("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    ip_addresses: Optional[Iterable[str]],"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    extra_addresses: Optional[Iterable[str]] = None,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    config_path: Optional[Iterable[str]] = None,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+) -> IPSet:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    \"\"\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    Generate an IPSet from a list of IP addresses or CIDRs."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    Additionally, for each IPv4 network in the list of IP addresses, also"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    includes the corresponding IPv6 networks."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    This includes:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    * IPv4-Compatible IPv6 Address (see RFC 4291, section 2.5.5.1)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    * IPv4-Mapped IPv6 Address (see RFC 4291, section 2.5.5.2)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    * 6to4 Address (see RFC 3056, section 2)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    Args:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        ip_addresses: An iterable of IP addresses or CIDRs."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        extra_addresses: An iterable of IP addresses or CIDRs."
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        config_path: The path in the configuration for error messages."
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    Returns:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        A new IP set."
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    \"\"\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    result = IPSet()"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+    for ip in itertools.chain(ip_addresses or (), extra_addresses or ()):"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        try:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            network = IPNetwork(ip)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        except AddrFormatError as e:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            raise ConfigError("
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                \"Invalid IP range provided: %s.\" % (ip,), config_path"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            ) from e"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        result.add(network)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        # It is possible that these already exist in the set, but that's OK."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        if \":\" not in str(network):"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            result.add(IPNetwork(network).ipv6(ipv4_compatible=True))"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            result.add(IPNetwork(network).ipv6(ipv4_compatible=False))"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            result.add(_6to4(network))"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    return result"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+# IP ranges that are considered private / unroutable / don't make sense."
            },
            "78": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " DEFAULT_IP_RANGE_BLACKLIST = ["
            },
            "79": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     # Localhost"
            },
            "80": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     \"127.0.0.0/8\","
            },
            "81": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     \"192.0.0.0/24\","
            },
            "82": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     # Link-local networks."
            },
            "83": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     \"169.254.0.0/16\","
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    # Formerly used for 6to4 relay."
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    \"192.88.99.0/24\","
            },
            "86": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     # Testing networks."
            },
            "87": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     \"198.18.0.0/15\","
            },
            "88": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     \"192.0.2.0/24\","
            },
            "89": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     \"fe80::/10\","
            },
            "90": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     # Unique local addresses."
            },
            "91": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     \"fc00::/7\","
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+    # Testing networks."
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    \"2001:db8::/32\","
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    # Multicast."
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    \"ff00::/8\","
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    # Site-local addresses"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    \"fec0::/10\","
            },
            "98": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " ]"
            },
            "99": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            },
            "100": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " DEFAULT_ROOM_VERSION = \"6\""
            },
            "101": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         )"
            },
            "102": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 364,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         # Attempt to create an IPSet from the given ranges"
            },
            "104": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "105": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.ip_range_blacklist = IPSet(ip_range_blacklist)"
            },
            "106": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except Exception as e:"
            },
            "107": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ConfigError(\"Invalid range(s) provided in ip_range_blacklist.\") from e"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "         # Always blacklist 0.0.0.0, ::"
            },
            "110": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.ip_range_blacklist.update([\"0.0.0.0\", \"::\"])"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+        self.ip_range_blacklist = generate_ip_set("
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+            ip_range_blacklist, [\"0.0.0.0\", \"::\"], config_path=(\"ip_range_blacklist\",)"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+        )"
            },
            "114": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 371,
                "PatchRowcode": " "
            },
            "115": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "116": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.ip_range_whitelist = IPSet(config.get(\"ip_range_whitelist\", ()))"
            },
            "117": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except Exception as e:"
            },
            "118": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ConfigError(\"Invalid range(s) provided in ip_range_whitelist.\") from e"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        self.ip_range_whitelist = generate_ip_set("
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+            config.get(\"ip_range_whitelist\", ()), config_path=(\"ip_range_whitelist\",)"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+        )"
            },
            "122": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 375,
                "PatchRowcode": " "
            },
            "123": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "         # The federation_ip_range_blacklist is used for backwards-compatibility"
            },
            "124": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "         # and only applies to federation and identity servers. If it is not given,"
            },
            "125": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "         # default to ip_range_blacklist."
            },
            "126": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "         federation_ip_range_blacklist = config.get("
            },
            "127": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "             \"federation_ip_range_blacklist\", ip_range_blacklist"
            },
            "128": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         )"
            },
            "129": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "130": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.federation_ip_range_blacklist = IPSet(federation_ip_range_blacklist)"
            },
            "131": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except Exception as e:"
            },
            "132": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ConfigError("
            },
            "133": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Invalid range(s) provided in federation_ip_range_blacklist.\""
            },
            "134": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ) from e"
            },
            "135": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         # Always blacklist 0.0.0.0, ::"
            },
            "136": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.federation_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        self.federation_ip_range_blacklist = generate_ip_set("
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+            federation_ip_range_blacklist,"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+            [\"0.0.0.0\", \"::\"],"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+            config_path=(\"federation_ip_range_blacklist\",),"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+        )"
            },
            "142": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 388,
                "PatchRowcode": " "
            },
            "143": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         self.start_pushers = config.get(\"start_pushers\", True)"
            },
            "144": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 390,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017-2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "import os.path",
            "import re",
            "from textwrap import indent",
            "from typing import Any, Dict, Iterable, List, Optional, Set",
            "",
            "import attr",
            "import yaml",
            "from netaddr import IPSet",
            "",
            "from synapse.api.room_versions import KNOWN_ROOM_VERSIONS",
            "from synapse.util.stringutils import parse_and_validate_server_name",
            "",
            "from ._base import Config, ConfigError",
            "",
            "logger = logging.Logger(__name__)",
            "",
            "# by default, we attempt to listen on both '::' *and* '0.0.0.0' because some OSes",
            "# (Windows, macOS, other BSD/Linux where net.ipv6.bindv6only is set) will only listen",
            "# on IPv6 when '::' is set.",
            "#",
            "# We later check for errors when binding to 0.0.0.0 and ignore them if :: is also in",
            "# in the list.",
            "DEFAULT_BIND_ADDRESSES = [\"::\", \"0.0.0.0\"]",
            "",
            "DEFAULT_IP_RANGE_BLACKLIST = [",
            "    # Localhost",
            "    \"127.0.0.0/8\",",
            "    # Private networks.",
            "    \"10.0.0.0/8\",",
            "    \"172.16.0.0/12\",",
            "    \"192.168.0.0/16\",",
            "    # Carrier grade NAT.",
            "    \"100.64.0.0/10\",",
            "    # Address registry.",
            "    \"192.0.0.0/24\",",
            "    # Link-local networks.",
            "    \"169.254.0.0/16\",",
            "    # Testing networks.",
            "    \"198.18.0.0/15\",",
            "    \"192.0.2.0/24\",",
            "    \"198.51.100.0/24\",",
            "    \"203.0.113.0/24\",",
            "    # Multicast.",
            "    \"224.0.0.0/4\",",
            "    # Localhost",
            "    \"::1/128\",",
            "    # Link-local addresses.",
            "    \"fe80::/10\",",
            "    # Unique local addresses.",
            "    \"fc00::/7\",",
            "]",
            "",
            "DEFAULT_ROOM_VERSION = \"6\"",
            "",
            "ROOM_COMPLEXITY_TOO_GREAT = (",
            "    \"Your homeserver is unable to join rooms this large or complex. \"",
            "    \"Please speak to your server administrator, or upgrade your instance \"",
            "    \"to join this room.\"",
            ")",
            "",
            "METRICS_PORT_WARNING = \"\"\"\\",
            "The metrics_port configuration option is deprecated in Synapse 0.31 in favour of",
            "a listener. Please see",
            "https://github.com/matrix-org/synapse/blob/master/docs/metrics-howto.md",
            "on how to configure the new listener.",
            "--------------------------------------------------------------------------------\"\"\"",
            "",
            "",
            "KNOWN_LISTENER_TYPES = {",
            "    \"http\",",
            "    \"metrics\",",
            "    \"manhole\",",
            "    \"replication\",",
            "}",
            "",
            "KNOWN_RESOURCES = {",
            "    \"client\",",
            "    \"consent\",",
            "    \"federation\",",
            "    \"keys\",",
            "    \"media\",",
            "    \"metrics\",",
            "    \"openid\",",
            "    \"replication\",",
            "    \"static\",",
            "    \"webclient\",",
            "}",
            "",
            "",
            "@attr.s(frozen=True)",
            "class HttpResourceConfig:",
            "    names = attr.ib(",
            "        type=List[str],",
            "        factory=list,",
            "        validator=attr.validators.deep_iterable(attr.validators.in_(KNOWN_RESOURCES)),  # type: ignore",
            "    )",
            "    compress = attr.ib(",
            "        type=bool,",
            "        default=False,",
            "        validator=attr.validators.optional(attr.validators.instance_of(bool)),  # type: ignore[arg-type]",
            "    )",
            "",
            "",
            "@attr.s(frozen=True)",
            "class HttpListenerConfig:",
            "    \"\"\"Object describing the http-specific parts of the config of a listener\"\"\"",
            "",
            "    x_forwarded = attr.ib(type=bool, default=False)",
            "    resources = attr.ib(type=List[HttpResourceConfig], factory=list)",
            "    additional_resources = attr.ib(type=Dict[str, dict], factory=dict)",
            "    tag = attr.ib(type=str, default=None)",
            "",
            "",
            "@attr.s(frozen=True)",
            "class ListenerConfig:",
            "    \"\"\"Object describing the configuration of a single listener.\"\"\"",
            "",
            "    port = attr.ib(type=int, validator=attr.validators.instance_of(int))",
            "    bind_addresses = attr.ib(type=List[str])",
            "    type = attr.ib(type=str, validator=attr.validators.in_(KNOWN_LISTENER_TYPES))",
            "    tls = attr.ib(type=bool, default=False)",
            "",
            "    # http_options is only populated if type=http",
            "    http_options = attr.ib(type=Optional[HttpListenerConfig], default=None)",
            "",
            "",
            "class ServerConfig(Config):",
            "    section = \"server\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.server_name = config[\"server_name\"]",
            "        self.server_context = config.get(\"server_context\", None)",
            "",
            "        try:",
            "            parse_and_validate_server_name(self.server_name)",
            "        except ValueError as e:",
            "            raise ConfigError(str(e))",
            "",
            "        self.pid_file = self.abspath(config.get(\"pid_file\"))",
            "        self.web_client_location = config.get(\"web_client_location\", None)",
            "        self.soft_file_limit = config.get(\"soft_file_limit\", 0)",
            "        self.daemonize = config.get(\"daemonize\")",
            "        self.print_pidfile = config.get(\"print_pidfile\")",
            "        self.user_agent_suffix = config.get(\"user_agent_suffix\")",
            "        self.use_frozen_dicts = config.get(\"use_frozen_dicts\", False)",
            "        self.public_baseurl = config.get(\"public_baseurl\") or \"https://%s/\" % (",
            "            self.server_name,",
            "        )",
            "        if self.public_baseurl[-1] != \"/\":",
            "            self.public_baseurl += \"/\"",
            "",
            "        # Whether to enable user presence.",
            "        self.use_presence = config.get(\"use_presence\", True)",
            "",
            "        # Whether to update the user directory or not. This should be set to",
            "        # false only if we are updating the user directory in a worker",
            "        self.update_user_directory = config.get(\"update_user_directory\", True)",
            "",
            "        # whether to enable the media repository endpoints. This should be set",
            "        # to false if the media repository is running as a separate endpoint;",
            "        # doing so ensures that we will not run cache cleanup jobs on the",
            "        # master, potentially causing inconsistency.",
            "        self.enable_media_repo = config.get(\"enable_media_repo\", True)",
            "",
            "        # Whether to require authentication to retrieve profile data (avatars,",
            "        # display names) of other users through the client API.",
            "        self.require_auth_for_profile_requests = config.get(",
            "            \"require_auth_for_profile_requests\", False",
            "        )",
            "",
            "        # Whether to require sharing a room with a user to retrieve their",
            "        # profile data",
            "        self.limit_profile_requests_to_users_who_share_rooms = config.get(",
            "            \"limit_profile_requests_to_users_who_share_rooms\", False,",
            "        )",
            "",
            "        if \"restrict_public_rooms_to_local_users\" in config and (",
            "            \"allow_public_rooms_without_auth\" in config",
            "            or \"allow_public_rooms_over_federation\" in config",
            "        ):",
            "            raise ConfigError(",
            "                \"Can't use 'restrict_public_rooms_to_local_users' if\"",
            "                \" 'allow_public_rooms_without_auth' and/or\"",
            "                \" 'allow_public_rooms_over_federation' is set.\"",
            "            )",
            "",
            "        # Check if the legacy \"restrict_public_rooms_to_local_users\" flag is set. This",
            "        # flag is now obsolete but we need to check it for backward-compatibility.",
            "        if config.get(\"restrict_public_rooms_to_local_users\", False):",
            "            self.allow_public_rooms_without_auth = False",
            "            self.allow_public_rooms_over_federation = False",
            "        else:",
            "            # If set to 'true', removes the need for authentication to access the server's",
            "            # public rooms directory through the client API, meaning that anyone can",
            "            # query the room directory. Defaults to 'false'.",
            "            self.allow_public_rooms_without_auth = config.get(",
            "                \"allow_public_rooms_without_auth\", False",
            "            )",
            "            # If set to 'true', allows any other homeserver to fetch the server's public",
            "            # rooms directory via federation. Defaults to 'false'.",
            "            self.allow_public_rooms_over_federation = config.get(",
            "                \"allow_public_rooms_over_federation\", False",
            "            )",
            "",
            "        default_room_version = config.get(\"default_room_version\", DEFAULT_ROOM_VERSION)",
            "",
            "        # Ensure room version is a str",
            "        default_room_version = str(default_room_version)",
            "",
            "        if default_room_version not in KNOWN_ROOM_VERSIONS:",
            "            raise ConfigError(",
            "                \"Unknown default_room_version: %s, known room versions: %s\"",
            "                % (default_room_version, list(KNOWN_ROOM_VERSIONS.keys()))",
            "            )",
            "",
            "        # Get the actual room version object rather than just the identifier",
            "        self.default_room_version = KNOWN_ROOM_VERSIONS[default_room_version]",
            "",
            "        # whether to enable search. If disabled, new entries will not be inserted",
            "        # into the search tables and they will not be indexed. Users will receive",
            "        # errors when attempting to search for messages.",
            "        self.enable_search = config.get(\"enable_search\", True)",
            "",
            "        self.filter_timeline_limit = config.get(\"filter_timeline_limit\", 100)",
            "",
            "        # Whether we should block invites sent to users on this server",
            "        # (other than those sent by local server admins)",
            "        self.block_non_admin_invites = config.get(\"block_non_admin_invites\", False)",
            "",
            "        # Whether to enable experimental MSC1849 (aka relations) support",
            "        self.experimental_msc1849_support_enabled = config.get(",
            "            \"experimental_msc1849_support_enabled\", True",
            "        )",
            "",
            "        # Options to control access by tracking MAU",
            "        self.limit_usage_by_mau = config.get(\"limit_usage_by_mau\", False)",
            "        self.max_mau_value = 0",
            "        if self.limit_usage_by_mau:",
            "            self.max_mau_value = config.get(\"max_mau_value\", 0)",
            "        self.mau_stats_only = config.get(\"mau_stats_only\", False)",
            "",
            "        self.mau_limits_reserved_threepids = config.get(",
            "            \"mau_limit_reserved_threepids\", []",
            "        )",
            "",
            "        self.mau_trial_days = config.get(\"mau_trial_days\", 0)",
            "        self.mau_limit_alerting = config.get(\"mau_limit_alerting\", True)",
            "",
            "        # How long to keep redacted events in the database in unredacted form",
            "        # before redacting them.",
            "        redaction_retention_period = config.get(\"redaction_retention_period\", \"7d\")",
            "        if redaction_retention_period is not None:",
            "            self.redaction_retention_period = self.parse_duration(",
            "                redaction_retention_period",
            "            )",
            "        else:",
            "            self.redaction_retention_period = None",
            "",
            "        # How long to keep entries in the `users_ips` table.",
            "        user_ips_max_age = config.get(\"user_ips_max_age\", \"28d\")",
            "        if user_ips_max_age is not None:",
            "            self.user_ips_max_age = self.parse_duration(user_ips_max_age)",
            "        else:",
            "            self.user_ips_max_age = None",
            "",
            "        # Options to disable HS",
            "        self.hs_disabled = config.get(\"hs_disabled\", False)",
            "        self.hs_disabled_message = config.get(\"hs_disabled_message\", \"\")",
            "",
            "        # Admin uri to direct users at should their instance become blocked",
            "        # due to resource constraints",
            "        self.admin_contact = config.get(\"admin_contact\", None)",
            "",
            "        ip_range_blacklist = config.get(",
            "            \"ip_range_blacklist\", DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        # Attempt to create an IPSet from the given ranges",
            "        try:",
            "            self.ip_range_blacklist = IPSet(ip_range_blacklist)",
            "        except Exception as e:",
            "            raise ConfigError(\"Invalid range(s) provided in ip_range_blacklist.\") from e",
            "        # Always blacklist 0.0.0.0, ::",
            "        self.ip_range_blacklist.update([\"0.0.0.0\", \"::\"])",
            "",
            "        try:",
            "            self.ip_range_whitelist = IPSet(config.get(\"ip_range_whitelist\", ()))",
            "        except Exception as e:",
            "            raise ConfigError(\"Invalid range(s) provided in ip_range_whitelist.\") from e",
            "",
            "        # The federation_ip_range_blacklist is used for backwards-compatibility",
            "        # and only applies to federation and identity servers. If it is not given,",
            "        # default to ip_range_blacklist.",
            "        federation_ip_range_blacklist = config.get(",
            "            \"federation_ip_range_blacklist\", ip_range_blacklist",
            "        )",
            "        try:",
            "            self.federation_ip_range_blacklist = IPSet(federation_ip_range_blacklist)",
            "        except Exception as e:",
            "            raise ConfigError(",
            "                \"Invalid range(s) provided in federation_ip_range_blacklist.\"",
            "            ) from e",
            "        # Always blacklist 0.0.0.0, ::",
            "        self.federation_ip_range_blacklist.update([\"0.0.0.0\", \"::\"])",
            "",
            "        self.start_pushers = config.get(\"start_pushers\", True)",
            "",
            "        # (undocumented) option for torturing the worker-mode replication a bit,",
            "        # for testing. The value defines the number of milliseconds to pause before",
            "        # sending out any replication updates.",
            "        self.replication_torture_level = config.get(\"replication_torture_level\")",
            "",
            "        # Whether to require a user to be in the room to add an alias to it.",
            "        # Defaults to True.",
            "        self.require_membership_for_aliases = config.get(",
            "            \"require_membership_for_aliases\", True",
            "        )",
            "",
            "        # Whether to allow per-room membership profiles through the send of membership",
            "        # events with profile information that differ from the target's global profile.",
            "        self.allow_per_room_profiles = config.get(\"allow_per_room_profiles\", True)",
            "",
            "        retention_config = config.get(\"retention\")",
            "        if retention_config is None:",
            "            retention_config = {}",
            "",
            "        self.retention_enabled = retention_config.get(\"enabled\", False)",
            "",
            "        retention_default_policy = retention_config.get(\"default_policy\")",
            "",
            "        if retention_default_policy is not None:",
            "            self.retention_default_min_lifetime = retention_default_policy.get(",
            "                \"min_lifetime\"",
            "            )",
            "            if self.retention_default_min_lifetime is not None:",
            "                self.retention_default_min_lifetime = self.parse_duration(",
            "                    self.retention_default_min_lifetime",
            "                )",
            "",
            "            self.retention_default_max_lifetime = retention_default_policy.get(",
            "                \"max_lifetime\"",
            "            )",
            "            if self.retention_default_max_lifetime is not None:",
            "                self.retention_default_max_lifetime = self.parse_duration(",
            "                    self.retention_default_max_lifetime",
            "                )",
            "",
            "            if (",
            "                self.retention_default_min_lifetime is not None",
            "                and self.retention_default_max_lifetime is not None",
            "                and (",
            "                    self.retention_default_min_lifetime",
            "                    > self.retention_default_max_lifetime",
            "                )",
            "            ):",
            "                raise ConfigError(",
            "                    \"The default retention policy's 'min_lifetime' can not be greater\"",
            "                    \" than its 'max_lifetime'\"",
            "                )",
            "        else:",
            "            self.retention_default_min_lifetime = None",
            "            self.retention_default_max_lifetime = None",
            "",
            "        if self.retention_enabled:",
            "            logger.info(",
            "                \"Message retention policies support enabled with the following default\"",
            "                \" policy: min_lifetime = %s ; max_lifetime = %s\",",
            "                self.retention_default_min_lifetime,",
            "                self.retention_default_max_lifetime,",
            "            )",
            "",
            "        self.retention_allowed_lifetime_min = retention_config.get(",
            "            \"allowed_lifetime_min\"",
            "        )",
            "        if self.retention_allowed_lifetime_min is not None:",
            "            self.retention_allowed_lifetime_min = self.parse_duration(",
            "                self.retention_allowed_lifetime_min",
            "            )",
            "",
            "        self.retention_allowed_lifetime_max = retention_config.get(",
            "            \"allowed_lifetime_max\"",
            "        )",
            "        if self.retention_allowed_lifetime_max is not None:",
            "            self.retention_allowed_lifetime_max = self.parse_duration(",
            "                self.retention_allowed_lifetime_max",
            "            )",
            "",
            "        if (",
            "            self.retention_allowed_lifetime_min is not None",
            "            and self.retention_allowed_lifetime_max is not None",
            "            and self.retention_allowed_lifetime_min",
            "            > self.retention_allowed_lifetime_max",
            "        ):",
            "            raise ConfigError(",
            "                \"Invalid retention policy limits: 'allowed_lifetime_min' can not be\"",
            "                \" greater than 'allowed_lifetime_max'\"",
            "            )",
            "",
            "        self.retention_purge_jobs = []  # type: List[Dict[str, Optional[int]]]",
            "        for purge_job_config in retention_config.get(\"purge_jobs\", []):",
            "            interval_config = purge_job_config.get(\"interval\")",
            "",
            "            if interval_config is None:",
            "                raise ConfigError(",
            "                    \"A retention policy's purge jobs configuration must have the\"",
            "                    \" 'interval' key set.\"",
            "                )",
            "",
            "            interval = self.parse_duration(interval_config)",
            "",
            "            shortest_max_lifetime = purge_job_config.get(\"shortest_max_lifetime\")",
            "",
            "            if shortest_max_lifetime is not None:",
            "                shortest_max_lifetime = self.parse_duration(shortest_max_lifetime)",
            "",
            "            longest_max_lifetime = purge_job_config.get(\"longest_max_lifetime\")",
            "",
            "            if longest_max_lifetime is not None:",
            "                longest_max_lifetime = self.parse_duration(longest_max_lifetime)",
            "",
            "            if (",
            "                shortest_max_lifetime is not None",
            "                and longest_max_lifetime is not None",
            "                and shortest_max_lifetime > longest_max_lifetime",
            "            ):",
            "                raise ConfigError(",
            "                    \"A retention policy's purge jobs configuration's\"",
            "                    \" 'shortest_max_lifetime' value can not be greater than its\"",
            "                    \" 'longest_max_lifetime' value.\"",
            "                )",
            "",
            "            self.retention_purge_jobs.append(",
            "                {",
            "                    \"interval\": interval,",
            "                    \"shortest_max_lifetime\": shortest_max_lifetime,",
            "                    \"longest_max_lifetime\": longest_max_lifetime,",
            "                }",
            "            )",
            "",
            "        if not self.retention_purge_jobs:",
            "            self.retention_purge_jobs = [",
            "                {",
            "                    \"interval\": self.parse_duration(\"1d\"),",
            "                    \"shortest_max_lifetime\": None,",
            "                    \"longest_max_lifetime\": None,",
            "                }",
            "            ]",
            "",
            "        self.listeners = [parse_listener_def(x) for x in config.get(\"listeners\", [])]",
            "",
            "        # no_tls is not really supported any more, but let's grandfather it in",
            "        # here.",
            "        if config.get(\"no_tls\", False):",
            "            l2 = []",
            "            for listener in self.listeners:",
            "                if listener.tls:",
            "                    logger.info(",
            "                        \"Ignoring TLS-enabled listener on port %i due to no_tls\",",
            "                        listener.port,",
            "                    )",
            "                else:",
            "                    l2.append(listener)",
            "            self.listeners = l2",
            "",
            "        if not self.web_client_location:",
            "            _warn_if_webclient_configured(self.listeners)",
            "",
            "        self.gc_thresholds = read_gc_thresholds(config.get(\"gc_thresholds\", None))",
            "",
            "        @attr.s",
            "        class LimitRemoteRoomsConfig:",
            "            enabled = attr.ib(",
            "                validator=attr.validators.instance_of(bool), default=False",
            "            )",
            "            complexity = attr.ib(",
            "                validator=attr.validators.instance_of(",
            "                    (float, int)  # type: ignore[arg-type] # noqa",
            "                ),",
            "                default=1.0,",
            "            )",
            "            complexity_error = attr.ib(",
            "                validator=attr.validators.instance_of(str),",
            "                default=ROOM_COMPLEXITY_TOO_GREAT,",
            "            )",
            "            admins_can_join = attr.ib(",
            "                validator=attr.validators.instance_of(bool), default=False",
            "            )",
            "",
            "        self.limit_remote_rooms = LimitRemoteRoomsConfig(",
            "            **(config.get(\"limit_remote_rooms\") or {})",
            "        )",
            "",
            "        bind_port = config.get(\"bind_port\")",
            "        if bind_port:",
            "            if config.get(\"no_tls\", False):",
            "                raise ConfigError(\"no_tls is incompatible with bind_port\")",
            "",
            "            self.listeners = []",
            "            bind_host = config.get(\"bind_host\", \"\")",
            "            gzip_responses = config.get(\"gzip_responses\", True)",
            "",
            "            http_options = HttpListenerConfig(",
            "                resources=[",
            "                    HttpResourceConfig(names=[\"client\"], compress=gzip_responses),",
            "                    HttpResourceConfig(names=[\"federation\"]),",
            "                ],",
            "            )",
            "",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=bind_port,",
            "                    bind_addresses=[bind_host],",
            "                    tls=True,",
            "                    type=\"http\",",
            "                    http_options=http_options,",
            "                )",
            "            )",
            "",
            "            unsecure_port = config.get(\"unsecure_port\", bind_port - 400)",
            "            if unsecure_port:",
            "                self.listeners.append(",
            "                    ListenerConfig(",
            "                        port=unsecure_port,",
            "                        bind_addresses=[bind_host],",
            "                        tls=False,",
            "                        type=\"http\",",
            "                        http_options=http_options,",
            "                    )",
            "                )",
            "",
            "        manhole = config.get(\"manhole\")",
            "        if manhole:",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=manhole, bind_addresses=[\"127.0.0.1\"], type=\"manhole\",",
            "                )",
            "            )",
            "",
            "        metrics_port = config.get(\"metrics_port\")",
            "        if metrics_port:",
            "            logger.warning(METRICS_PORT_WARNING)",
            "",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=metrics_port,",
            "                    bind_addresses=[config.get(\"metrics_bind_host\", \"127.0.0.1\")],",
            "                    type=\"http\",",
            "                    http_options=HttpListenerConfig(",
            "                        resources=[HttpResourceConfig(names=[\"metrics\"])]",
            "                    ),",
            "                )",
            "            )",
            "",
            "        self.cleanup_extremities_with_dummy_events = config.get(",
            "            \"cleanup_extremities_with_dummy_events\", True",
            "        )",
            "",
            "        # The number of forward extremities in a room needed to send a dummy event.",
            "        self.dummy_events_threshold = config.get(\"dummy_events_threshold\", 10)",
            "",
            "        self.enable_ephemeral_messages = config.get(\"enable_ephemeral_messages\", False)",
            "",
            "        # Inhibits the /requestToken endpoints from returning an error that might leak",
            "        # information about whether an e-mail address is in use or not on this",
            "        # homeserver, and instead return a 200 with a fake sid if this kind of error is",
            "        # met, without sending anything.",
            "        # This is a compromise between sending an email, which could be a spam vector,",
            "        # and letting the client know which email address is bound to an account and",
            "        # which one isn't.",
            "        self.request_token_inhibit_3pid_errors = config.get(",
            "            \"request_token_inhibit_3pid_errors\", False,",
            "        )",
            "",
            "        # List of users trialing the new experimental default push rules. This setting is",
            "        # not included in the sample configuration file on purpose as it's a temporary",
            "        # hack, so that some users can trial the new defaults without impacting every",
            "        # user on the homeserver.",
            "        users_new_default_push_rules = (",
            "            config.get(\"users_new_default_push_rules\") or []",
            "        )  # type: list",
            "        if not isinstance(users_new_default_push_rules, list):",
            "            raise ConfigError(\"'users_new_default_push_rules' must be a list\")",
            "",
            "        # Turn the list into a set to improve lookup speed.",
            "        self.users_new_default_push_rules = set(",
            "            users_new_default_push_rules",
            "        )  # type: set",
            "",
            "        # Whitelist of domain names that given next_link parameters must have",
            "        next_link_domain_whitelist = config.get(",
            "            \"next_link_domain_whitelist\"",
            "        )  # type: Optional[List[str]]",
            "",
            "        self.next_link_domain_whitelist = None  # type: Optional[Set[str]]",
            "        if next_link_domain_whitelist is not None:",
            "            if not isinstance(next_link_domain_whitelist, list):",
            "                raise ConfigError(\"'next_link_domain_whitelist' must be a list\")",
            "",
            "            # Turn the list into a set to improve lookup speed.",
            "            self.next_link_domain_whitelist = set(next_link_domain_whitelist)",
            "",
            "    def has_tls_listener(self) -> bool:",
            "        return any(listener.tls for listener in self.listeners)",
            "",
            "    def generate_config_section(",
            "        self, server_name, data_dir_path, open_private_ports, listeners, **kwargs",
            "    ):",
            "        ip_range_blacklist = \"\\n\".join(",
            "            \"        #  - '%s'\" % ip for ip in DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        _, bind_port = parse_and_validate_server_name(server_name)",
            "        if bind_port is not None:",
            "            unsecure_port = bind_port - 400",
            "        else:",
            "            bind_port = 8448",
            "            unsecure_port = 8008",
            "",
            "        pid_file = os.path.join(data_dir_path, \"homeserver.pid\")",
            "",
            "        # Bring DEFAULT_ROOM_VERSION into the local-scope for use in the",
            "        # default config string",
            "        default_room_version = DEFAULT_ROOM_VERSION",
            "        secure_listeners = []",
            "        unsecure_listeners = []",
            "        private_addresses = [\"::1\", \"127.0.0.1\"]",
            "        if listeners:",
            "            for listener in listeners:",
            "                if listener[\"tls\"]:",
            "                    secure_listeners.append(listener)",
            "                else:",
            "                    # If we don't want open ports we need to bind the listeners",
            "                    # to some address other than 0.0.0.0. Here we chose to use",
            "                    # localhost.",
            "                    # If the addresses are already bound we won't overwrite them",
            "                    # however.",
            "                    if not open_private_ports:",
            "                        listener.setdefault(\"bind_addresses\", private_addresses)",
            "",
            "                    unsecure_listeners.append(listener)",
            "",
            "            secure_http_bindings = indent(",
            "                yaml.dump(secure_listeners), \" \" * 10",
            "            ).lstrip()",
            "",
            "            unsecure_http_bindings = indent(",
            "                yaml.dump(unsecure_listeners), \" \" * 10",
            "            ).lstrip()",
            "",
            "        if not unsecure_listeners:",
            "            unsecure_http_bindings = (",
            "                \"\"\"- port: %(unsecure_port)s",
            "            tls: false",
            "            type: http",
            "            x_forwarded: true\"\"\"",
            "                % locals()",
            "            )",
            "",
            "            if not open_private_ports:",
            "                unsecure_http_bindings += (",
            "                    \"\\n            bind_addresses: ['::1', '127.0.0.1']\"",
            "                )",
            "",
            "            unsecure_http_bindings += \"\"\"",
            "",
            "            resources:",
            "              - names: [client, federation]",
            "                compress: false\"\"\"",
            "",
            "            if listeners:",
            "                # comment out this block",
            "                unsecure_http_bindings = \"#\" + re.sub(",
            "                    \"\\n {10}\",",
            "                    lambda match: match.group(0) + \"#\",",
            "                    unsecure_http_bindings,",
            "                )",
            "",
            "        if not secure_listeners:",
            "            secure_http_bindings = (",
            "                \"\"\"#- port: %(bind_port)s",
            "          #  type: http",
            "          #  tls: true",
            "          #  resources:",
            "          #    - names: [client, federation]\"\"\"",
            "                % locals()",
            "            )",
            "",
            "        return (",
            "            \"\"\"\\",
            "        ## Server ##",
            "",
            "        # The public-facing domain of the server",
            "        #",
            "        # The server_name name will appear at the end of usernames and room addresses",
            "        # created on this server. For example if the server_name was example.com,",
            "        # usernames on this server would be in the format @user:example.com",
            "        #",
            "        # In most cases you should avoid using a matrix specific subdomain such as",
            "        # matrix.example.com or synapse.example.com as the server_name for the same",
            "        # reasons you wouldn't use user@email.example.com as your email address.",
            "        # See https://github.com/matrix-org/synapse/blob/master/docs/delegate.md",
            "        # for information on how to host Synapse on a subdomain while preserving",
            "        # a clean server_name.",
            "        #",
            "        # The server_name cannot be changed later so it is important to",
            "        # configure this correctly before you start Synapse. It should be all",
            "        # lowercase and may contain an explicit port.",
            "        # Examples: matrix.org, localhost:8080",
            "        #",
            "        server_name: \"%(server_name)s\"",
            "",
            "        # When running as a daemon, the file to store the pid in",
            "        #",
            "        pid_file: %(pid_file)s",
            "",
            "        # The absolute URL to the web client which /_matrix/client will redirect",
            "        # to if 'webclient' is configured under the 'listeners' configuration.",
            "        #",
            "        # This option can be also set to the filesystem path to the web client",
            "        # which will be served at /_matrix/client/ if 'webclient' is configured",
            "        # under the 'listeners' configuration, however this is a security risk:",
            "        # https://github.com/matrix-org/synapse#security-note",
            "        #",
            "        #web_client_location: https://riot.example.com/",
            "",
            "        # The public-facing base URL that clients use to access this Homeserver (not",
            "        # including _matrix/...). This is the same URL a user might enter into the",
            "        # 'Custom Homeserver URL' field on their client. If you use Synapse with a",
            "        # reverse proxy, this should be the URL to reach Synapse via the proxy.",
            "        # Otherwise, it should be the URL to reach Synapse's client HTTP listener (see",
            "        # 'listeners' below).",
            "        #",
            "        # If this is left unset, it defaults to 'https://<server_name>/'. (Note that",
            "        # that will not work unless you configure Synapse or a reverse-proxy to listen",
            "        # on port 443.)",
            "        #",
            "        #public_baseurl: https://example.com/",
            "",
            "        # Set the soft limit on the number of file descriptors synapse can use",
            "        # Zero is used to indicate synapse should set the soft limit to the",
            "        # hard limit.",
            "        #",
            "        #soft_file_limit: 0",
            "",
            "        # Set to false to disable presence tracking on this homeserver.",
            "        #",
            "        #use_presence: false",
            "",
            "        # Whether to require authentication to retrieve profile data (avatars,",
            "        # display names) of other users through the client API. Defaults to",
            "        # 'false'. Note that profile data is also available via the federation",
            "        # API, so this setting is of limited value if federation is enabled on",
            "        # the server.",
            "        #",
            "        #require_auth_for_profile_requests: true",
            "",
            "        # Uncomment to require a user to share a room with another user in order",
            "        # to retrieve their profile information. Only checked on Client-Server",
            "        # requests. Profile requests from other servers should be checked by the",
            "        # requesting server. Defaults to 'false'.",
            "        #",
            "        #limit_profile_requests_to_users_who_share_rooms: true",
            "",
            "        # If set to 'true', removes the need for authentication to access the server's",
            "        # public rooms directory through the client API, meaning that anyone can",
            "        # query the room directory. Defaults to 'false'.",
            "        #",
            "        #allow_public_rooms_without_auth: true",
            "",
            "        # If set to 'true', allows any other homeserver to fetch the server's public",
            "        # rooms directory via federation. Defaults to 'false'.",
            "        #",
            "        #allow_public_rooms_over_federation: true",
            "",
            "        # The default room version for newly created rooms.",
            "        #",
            "        # Known room versions are listed here:",
            "        # https://matrix.org/docs/spec/#complete-list-of-room-versions",
            "        #",
            "        # For example, for room version 1, default_room_version should be set",
            "        # to \"1\".",
            "        #",
            "        #default_room_version: \"%(default_room_version)s\"",
            "",
            "        # The GC threshold parameters to pass to `gc.set_threshold`, if defined",
            "        #",
            "        #gc_thresholds: [700, 10, 10]",
            "",
            "        # Set the limit on the returned events in the timeline in the get",
            "        # and sync operations. The default value is 100. -1 means no upper limit.",
            "        #",
            "        # Uncomment the following to increase the limit to 5000.",
            "        #",
            "        #filter_timeline_limit: 5000",
            "",
            "        # Whether room invites to users on this server should be blocked",
            "        # (except those sent by local server admins). The default is False.",
            "        #",
            "        #block_non_admin_invites: true",
            "",
            "        # Room searching",
            "        #",
            "        # If disabled, new messages will not be indexed for searching and users",
            "        # will receive errors when searching for messages. Defaults to enabled.",
            "        #",
            "        #enable_search: false",
            "",
            "        # Prevent outgoing requests from being sent to the following blacklisted IP address",
            "        # CIDR ranges. If this option is not specified then it defaults to private IP",
            "        # address ranges (see the example below).",
            "        #",
            "        # The blacklist applies to the outbound requests for federation, identity servers,",
            "        # push servers, and for checking key validity for third-party invite events.",
            "        #",
            "        # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly",
            "        # listed here, since they correspond to unroutable addresses.)",
            "        #",
            "        # This option replaces federation_ip_range_blacklist in Synapse v1.25.0.",
            "        #",
            "        #ip_range_blacklist:",
            "%(ip_range_blacklist)s",
            "",
            "        # List of IP address CIDR ranges that should be allowed for federation,",
            "        # identity servers, push servers, and for checking key validity for",
            "        # third-party invite events. This is useful for specifying exceptions to",
            "        # wide-ranging blacklisted target IP ranges - e.g. for communication with",
            "        # a push server only visible in your network.",
            "        #",
            "        # This whitelist overrides ip_range_blacklist and defaults to an empty",
            "        # list.",
            "        #",
            "        #ip_range_whitelist:",
            "        #   - '192.168.1.1'",
            "",
            "        # List of ports that Synapse should listen on, their purpose and their",
            "        # configuration.",
            "        #",
            "        # Options for each listener include:",
            "        #",
            "        #   port: the TCP port to bind to",
            "        #",
            "        #   bind_addresses: a list of local addresses to listen on. The default is",
            "        #       'all local interfaces'.",
            "        #",
            "        #   type: the type of listener. Normally 'http', but other valid options are:",
            "        #       'manhole' (see docs/manhole.md),",
            "        #       'metrics' (see docs/metrics-howto.md),",
            "        #       'replication' (see docs/workers.md).",
            "        #",
            "        #   tls: set to true to enable TLS for this listener. Will use the TLS",
            "        #       key/cert specified in tls_private_key_path / tls_certificate_path.",
            "        #",
            "        #   x_forwarded: Only valid for an 'http' listener. Set to true to use the",
            "        #       X-Forwarded-For header as the client IP. Useful when Synapse is",
            "        #       behind a reverse-proxy.",
            "        #",
            "        #   resources: Only valid for an 'http' listener. A list of resources to host",
            "        #       on this port. Options for each resource are:",
            "        #",
            "        #       names: a list of names of HTTP resources. See below for a list of",
            "        #           valid resource names.",
            "        #",
            "        #       compress: set to true to enable HTTP compression for this resource.",
            "        #",
            "        #   additional_resources: Only valid for an 'http' listener. A map of",
            "        #        additional endpoints which should be loaded via dynamic modules.",
            "        #",
            "        # Valid resource names are:",
            "        #",
            "        #   client: the client-server API (/_matrix/client), and the synapse admin",
            "        #       API (/_synapse/admin). Also implies 'media' and 'static'.",
            "        #",
            "        #   consent: user consent forms (/_matrix/consent). See",
            "        #       docs/consent_tracking.md.",
            "        #",
            "        #   federation: the server-server API (/_matrix/federation). Also implies",
            "        #       'media', 'keys', 'openid'",
            "        #",
            "        #   keys: the key discovery API (/_matrix/keys).",
            "        #",
            "        #   media: the media API (/_matrix/media).",
            "        #",
            "        #   metrics: the metrics interface. See docs/metrics-howto.md.",
            "        #",
            "        #   openid: OpenID authentication.",
            "        #",
            "        #   replication: the HTTP replication API (/_synapse/replication). See",
            "        #       docs/workers.md.",
            "        #",
            "        #   static: static resources under synapse/static (/_matrix/static). (Mostly",
            "        #       useful for 'fallback authentication'.)",
            "        #",
            "        #   webclient: A web client. Requires web_client_location to be set.",
            "        #",
            "        listeners:",
            "          # TLS-enabled listener: for when matrix traffic is sent directly to synapse.",
            "          #",
            "          # Disabled by default. To enable it, uncomment the following. (Note that you",
            "          # will also need to give Synapse a TLS key and certificate: see the TLS section",
            "          # below.)",
            "          #",
            "          %(secure_http_bindings)s",
            "",
            "          # Unsecure HTTP listener: for when matrix traffic passes through a reverse proxy",
            "          # that unwraps TLS.",
            "          #",
            "          # If you plan to use a reverse proxy, please see",
            "          # https://github.com/matrix-org/synapse/blob/master/docs/reverse_proxy.md.",
            "          #",
            "          %(unsecure_http_bindings)s",
            "",
            "            # example additional_resources:",
            "            #",
            "            #additional_resources:",
            "            #  \"/_matrix/my/custom/endpoint\":",
            "            #    module: my_module.CustomRequestHandler",
            "            #    config: {}",
            "",
            "          # Turn on the twisted ssh manhole service on localhost on the given",
            "          # port.",
            "          #",
            "          #- port: 9000",
            "          #  bind_addresses: ['::1', '127.0.0.1']",
            "          #  type: manhole",
            "",
            "        # Forward extremities can build up in a room due to networking delays between",
            "        # homeservers. Once this happens in a large room, calculation of the state of",
            "        # that room can become quite expensive. To mitigate this, once the number of",
            "        # forward extremities reaches a given threshold, Synapse will send an",
            "        # org.matrix.dummy_event event, which will reduce the forward extremities",
            "        # in the room.",
            "        #",
            "        # This setting defines the threshold (i.e. number of forward extremities in the",
            "        # room) at which dummy events are sent. The default value is 10.",
            "        #",
            "        #dummy_events_threshold: 5",
            "",
            "",
            "        ## Homeserver blocking ##",
            "",
            "        # How to reach the server admin, used in ResourceLimitError",
            "        #",
            "        #admin_contact: 'mailto:admin@server.com'",
            "",
            "        # Global blocking",
            "        #",
            "        #hs_disabled: false",
            "        #hs_disabled_message: 'Human readable reason for why the HS is blocked'",
            "",
            "        # Monthly Active User Blocking",
            "        #",
            "        # Used in cases where the admin or server owner wants to limit to the",
            "        # number of monthly active users.",
            "        #",
            "        # 'limit_usage_by_mau' disables/enables monthly active user blocking. When",
            "        # enabled and a limit is reached the server returns a 'ResourceLimitError'",
            "        # with error type Codes.RESOURCE_LIMIT_EXCEEDED",
            "        #",
            "        # 'max_mau_value' is the hard limit of monthly active users above which",
            "        # the server will start blocking user actions.",
            "        #",
            "        # 'mau_trial_days' is a means to add a grace period for active users. It",
            "        # means that users must be active for this number of days before they",
            "        # can be considered active and guards against the case where lots of users",
            "        # sign up in a short space of time never to return after their initial",
            "        # session.",
            "        #",
            "        # 'mau_limit_alerting' is a means of limiting client side alerting",
            "        # should the mau limit be reached. This is useful for small instances",
            "        # where the admin has 5 mau seats (say) for 5 specific people and no",
            "        # interest increasing the mau limit further. Defaults to True, which",
            "        # means that alerting is enabled",
            "        #",
            "        #limit_usage_by_mau: false",
            "        #max_mau_value: 50",
            "        #mau_trial_days: 2",
            "        #mau_limit_alerting: false",
            "",
            "        # If enabled, the metrics for the number of monthly active users will",
            "        # be populated, however no one will be limited. If limit_usage_by_mau",
            "        # is true, this is implied to be true.",
            "        #",
            "        #mau_stats_only: false",
            "",
            "        # Sometimes the server admin will want to ensure certain accounts are",
            "        # never blocked by mau checking. These accounts are specified here.",
            "        #",
            "        #mau_limit_reserved_threepids:",
            "        #  - medium: 'email'",
            "        #    address: 'reserved_user@example.com'",
            "",
            "        # Used by phonehome stats to group together related servers.",
            "        #server_context: context",
            "",
            "        # Resource-constrained homeserver settings",
            "        #",
            "        # When this is enabled, the room \"complexity\" will be checked before a user",
            "        # joins a new remote room. If it is above the complexity limit, the server will",
            "        # disallow joining, or will instantly leave.",
            "        #",
            "        # Room complexity is an arbitrary measure based on factors such as the number of",
            "        # users in the room.",
            "        #",
            "        limit_remote_rooms:",
            "          # Uncomment to enable room complexity checking.",
            "          #",
            "          #enabled: true",
            "",
            "          # the limit above which rooms cannot be joined. The default is 1.0.",
            "          #",
            "          #complexity: 0.5",
            "",
            "          # override the error which is returned when the room is too complex.",
            "          #",
            "          #complexity_error: \"This room is too complex.\"",
            "",
            "          # allow server admins to join complex rooms. Default is false.",
            "          #",
            "          #admins_can_join: true",
            "",
            "        # Whether to require a user to be in the room to add an alias to it.",
            "        # Defaults to 'true'.",
            "        #",
            "        #require_membership_for_aliases: false",
            "",
            "        # Whether to allow per-room membership profiles through the send of membership",
            "        # events with profile information that differ from the target's global profile.",
            "        # Defaults to 'true'.",
            "        #",
            "        #allow_per_room_profiles: false",
            "",
            "        # How long to keep redacted events in unredacted form in the database. After",
            "        # this period redacted events get replaced with their redacted form in the DB.",
            "        #",
            "        # Defaults to `7d`. Set to `null` to disable.",
            "        #",
            "        #redaction_retention_period: 28d",
            "",
            "        # How long to track users' last seen time and IPs in the database.",
            "        #",
            "        # Defaults to `28d`. Set to `null` to disable clearing out of old rows.",
            "        #",
            "        #user_ips_max_age: 14d",
            "",
            "        # Message retention policy at the server level.",
            "        #",
            "        # Room admins and mods can define a retention period for their rooms using the",
            "        # 'm.room.retention' state event, and server admins can cap this period by setting",
            "        # the 'allowed_lifetime_min' and 'allowed_lifetime_max' config options.",
            "        #",
            "        # If this feature is enabled, Synapse will regularly look for and purge events",
            "        # which are older than the room's maximum retention period. Synapse will also",
            "        # filter events received over federation so that events that should have been",
            "        # purged are ignored and not stored again.",
            "        #",
            "        retention:",
            "          # The message retention policies feature is disabled by default. Uncomment the",
            "          # following line to enable it.",
            "          #",
            "          #enabled: true",
            "",
            "          # Default retention policy. If set, Synapse will apply it to rooms that lack the",
            "          # 'm.room.retention' state event. Currently, the value of 'min_lifetime' doesn't",
            "          # matter much because Synapse doesn't take it into account yet.",
            "          #",
            "          #default_policy:",
            "          #  min_lifetime: 1d",
            "          #  max_lifetime: 1y",
            "",
            "          # Retention policy limits. If set, and the state of a room contains a",
            "          # 'm.room.retention' event in its state which contains a 'min_lifetime' or a",
            "          # 'max_lifetime' that's out of these bounds, Synapse will cap the room's policy",
            "          # to these limits when running purge jobs.",
            "          #",
            "          #allowed_lifetime_min: 1d",
            "          #allowed_lifetime_max: 1y",
            "",
            "          # Server admins can define the settings of the background jobs purging the",
            "          # events which lifetime has expired under the 'purge_jobs' section.",
            "          #",
            "          # If no configuration is provided, a single job will be set up to delete expired",
            "          # events in every room daily.",
            "          #",
            "          # Each job's configuration defines which range of message lifetimes the job",
            "          # takes care of. For example, if 'shortest_max_lifetime' is '2d' and",
            "          # 'longest_max_lifetime' is '3d', the job will handle purging expired events in",
            "          # rooms whose state defines a 'max_lifetime' that's both higher than 2 days, and",
            "          # lower than or equal to 3 days. Both the minimum and the maximum value of a",
            "          # range are optional, e.g. a job with no 'shortest_max_lifetime' and a",
            "          # 'longest_max_lifetime' of '3d' will handle every room with a retention policy",
            "          # which 'max_lifetime' is lower than or equal to three days.",
            "          #",
            "          # The rationale for this per-job configuration is that some rooms might have a",
            "          # retention policy with a low 'max_lifetime', where history needs to be purged",
            "          # of outdated messages on a more frequent basis than for the rest of the rooms",
            "          # (e.g. every 12h), but not want that purge to be performed by a job that's",
            "          # iterating over every room it knows, which could be heavy on the server.",
            "          #",
            "          # If any purge job is configured, it is strongly recommended to have at least",
            "          # a single job with neither 'shortest_max_lifetime' nor 'longest_max_lifetime'",
            "          # set, or one job without 'shortest_max_lifetime' and one job without",
            "          # 'longest_max_lifetime' set. Otherwise some rooms might be ignored, even if",
            "          # 'allowed_lifetime_min' and 'allowed_lifetime_max' are set, because capping a",
            "          # room's policy to these values is done after the policies are retrieved from",
            "          # Synapse's database (which is done using the range specified in a purge job's",
            "          # configuration).",
            "          #",
            "          #purge_jobs:",
            "          #  - longest_max_lifetime: 3d",
            "          #    interval: 12h",
            "          #  - shortest_max_lifetime: 3d",
            "          #    interval: 1d",
            "",
            "        # Inhibits the /requestToken endpoints from returning an error that might leak",
            "        # information about whether an e-mail address is in use or not on this",
            "        # homeserver.",
            "        # Note that for some endpoints the error situation is the e-mail already being",
            "        # used, and for others the error is entering the e-mail being unused.",
            "        # If this option is enabled, instead of returning an error, these endpoints will",
            "        # act as if no error happened and return a fake session ID ('sid') to clients.",
            "        #",
            "        #request_token_inhibit_3pid_errors: true",
            "",
            "        # A list of domains that the domain portion of 'next_link' parameters",
            "        # must match.",
            "        #",
            "        # This parameter is optionally provided by clients while requesting",
            "        # validation of an email or phone number, and maps to a link that",
            "        # users will be automatically redirected to after validation",
            "        # succeeds. Clients can make use this parameter to aid the validation",
            "        # process.",
            "        #",
            "        # The whitelist is applied whether the homeserver or an",
            "        # identity server is handling validation.",
            "        #",
            "        # The default value is no whitelist functionality; all domains are",
            "        # allowed. Setting this value to an empty list will instead disallow",
            "        # all domains.",
            "        #",
            "        #next_link_domain_whitelist: [\"matrix.org\"]",
            "        \"\"\"",
            "            % locals()",
            "        )",
            "",
            "    def read_arguments(self, args):",
            "        if args.manhole is not None:",
            "            self.manhole = args.manhole",
            "        if args.daemonize is not None:",
            "            self.daemonize = args.daemonize",
            "        if args.print_pidfile is not None:",
            "            self.print_pidfile = args.print_pidfile",
            "",
            "    @staticmethod",
            "    def add_arguments(parser):",
            "        server_group = parser.add_argument_group(\"server\")",
            "        server_group.add_argument(",
            "            \"-D\",",
            "            \"--daemonize\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Daemonize the homeserver\",",
            "        )",
            "        server_group.add_argument(",
            "            \"--print-pidfile\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Print the path to the pidfile just before daemonizing\",",
            "        )",
            "        server_group.add_argument(",
            "            \"--manhole\",",
            "            metavar=\"PORT\",",
            "            dest=\"manhole\",",
            "            type=int,",
            "            help=\"Turn on the twisted telnet manhole service on the given port.\",",
            "        )",
            "",
            "",
            "def is_threepid_reserved(reserved_threepids, threepid):",
            "    \"\"\"Check the threepid against the reserved threepid config",
            "    Args:",
            "        reserved_threepids([dict]) - list of reserved threepids",
            "        threepid(dict) - The threepid to test for",
            "",
            "    Returns:",
            "        boolean Is the threepid undertest reserved_user",
            "    \"\"\"",
            "",
            "    for tp in reserved_threepids:",
            "        if threepid[\"medium\"] == tp[\"medium\"] and threepid[\"address\"] == tp[\"address\"]:",
            "            return True",
            "    return False",
            "",
            "",
            "def read_gc_thresholds(thresholds):",
            "    \"\"\"Reads the three integer thresholds for garbage collection. Ensures that",
            "    the thresholds are integers if thresholds are supplied.",
            "    \"\"\"",
            "    if thresholds is None:",
            "        return None",
            "    try:",
            "        assert len(thresholds) == 3",
            "        return (int(thresholds[0]), int(thresholds[1]), int(thresholds[2]))",
            "    except Exception:",
            "        raise ConfigError(",
            "            \"Value of `gc_threshold` must be a list of three integers if set\"",
            "        )",
            "",
            "",
            "def parse_listener_def(listener: Any) -> ListenerConfig:",
            "    \"\"\"parse a listener config from the config file\"\"\"",
            "    listener_type = listener[\"type\"]",
            "",
            "    port = listener.get(\"port\")",
            "    if not isinstance(port, int):",
            "        raise ConfigError(\"Listener configuration is lacking a valid 'port' option\")",
            "",
            "    tls = listener.get(\"tls\", False)",
            "",
            "    bind_addresses = listener.get(\"bind_addresses\", [])",
            "    bind_address = listener.get(\"bind_address\")",
            "    # if bind_address was specified, add it to the list of addresses",
            "    if bind_address:",
            "        bind_addresses.append(bind_address)",
            "",
            "    # if we still have an empty list of addresses, use the default list",
            "    if not bind_addresses:",
            "        if listener_type == \"metrics\":",
            "            # the metrics listener doesn't support IPv6",
            "            bind_addresses.append(\"0.0.0.0\")",
            "        else:",
            "            bind_addresses.extend(DEFAULT_BIND_ADDRESSES)",
            "",
            "    http_config = None",
            "    if listener_type == \"http\":",
            "        http_config = HttpListenerConfig(",
            "            x_forwarded=listener.get(\"x_forwarded\", False),",
            "            resources=[",
            "                HttpResourceConfig(**res) for res in listener.get(\"resources\", [])",
            "            ],",
            "            additional_resources=listener.get(\"additional_resources\", {}),",
            "            tag=listener.get(\"tag\"),",
            "        )",
            "",
            "    return ListenerConfig(port, bind_addresses, listener_type, tls, http_config)",
            "",
            "",
            "NO_MORE_WEB_CLIENT_WARNING = \"\"\"",
            "Synapse no longer includes a web client. To enable a web client, configure",
            "web_client_location. To remove this warning, remove 'webclient' from the 'listeners'",
            "configuration.",
            "\"\"\"",
            "",
            "",
            "def _warn_if_webclient_configured(listeners: Iterable[ListenerConfig]) -> None:",
            "    for listener in listeners:",
            "        if not listener.http_options:",
            "            continue",
            "        for res in listener.http_options.resources:",
            "            for name in res.names:",
            "                if name == \"webclient\":",
            "                    logger.warning(NO_MORE_WEB_CLIENT_WARNING)",
            "                    return"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017-2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import itertools",
            "import logging",
            "import os.path",
            "import re",
            "from textwrap import indent",
            "from typing import Any, Dict, Iterable, List, Optional, Set",
            "",
            "import attr",
            "import yaml",
            "from netaddr import AddrFormatError, IPNetwork, IPSet",
            "",
            "from synapse.api.room_versions import KNOWN_ROOM_VERSIONS",
            "from synapse.util.stringutils import parse_and_validate_server_name",
            "",
            "from ._base import Config, ConfigError",
            "",
            "logger = logging.Logger(__name__)",
            "",
            "# by default, we attempt to listen on both '::' *and* '0.0.0.0' because some OSes",
            "# (Windows, macOS, other BSD/Linux where net.ipv6.bindv6only is set) will only listen",
            "# on IPv6 when '::' is set.",
            "#",
            "# We later check for errors when binding to 0.0.0.0 and ignore them if :: is also in",
            "# in the list.",
            "DEFAULT_BIND_ADDRESSES = [\"::\", \"0.0.0.0\"]",
            "",
            "",
            "def _6to4(network: IPNetwork) -> IPNetwork:",
            "    \"\"\"Convert an IPv4 network into a 6to4 IPv6 network per RFC 3056.\"\"\"",
            "",
            "    # 6to4 networks consist of:",
            "    # * 2002 as the first 16 bits",
            "    # * The first IPv4 address in the network hex-encoded as the next 32 bits",
            "    # * The new prefix length needs to include the bits from the 2002 prefix.",
            "    hex_network = hex(network.first)[2:]",
            "    hex_network = (\"0\" * (8 - len(hex_network))) + hex_network",
            "    return IPNetwork(",
            "        \"2002:%s:%s::/%d\" % (hex_network[:4], hex_network[4:], 16 + network.prefixlen,)",
            "    )",
            "",
            "",
            "def generate_ip_set(",
            "    ip_addresses: Optional[Iterable[str]],",
            "    extra_addresses: Optional[Iterable[str]] = None,",
            "    config_path: Optional[Iterable[str]] = None,",
            ") -> IPSet:",
            "    \"\"\"",
            "    Generate an IPSet from a list of IP addresses or CIDRs.",
            "",
            "    Additionally, for each IPv4 network in the list of IP addresses, also",
            "    includes the corresponding IPv6 networks.",
            "",
            "    This includes:",
            "",
            "    * IPv4-Compatible IPv6 Address (see RFC 4291, section 2.5.5.1)",
            "    * IPv4-Mapped IPv6 Address (see RFC 4291, section 2.5.5.2)",
            "    * 6to4 Address (see RFC 3056, section 2)",
            "",
            "    Args:",
            "        ip_addresses: An iterable of IP addresses or CIDRs.",
            "        extra_addresses: An iterable of IP addresses or CIDRs.",
            "        config_path: The path in the configuration for error messages.",
            "",
            "    Returns:",
            "        A new IP set.",
            "    \"\"\"",
            "    result = IPSet()",
            "    for ip in itertools.chain(ip_addresses or (), extra_addresses or ()):",
            "        try:",
            "            network = IPNetwork(ip)",
            "        except AddrFormatError as e:",
            "            raise ConfigError(",
            "                \"Invalid IP range provided: %s.\" % (ip,), config_path",
            "            ) from e",
            "        result.add(network)",
            "",
            "        # It is possible that these already exist in the set, but that's OK.",
            "        if \":\" not in str(network):",
            "            result.add(IPNetwork(network).ipv6(ipv4_compatible=True))",
            "            result.add(IPNetwork(network).ipv6(ipv4_compatible=False))",
            "            result.add(_6to4(network))",
            "",
            "    return result",
            "",
            "",
            "# IP ranges that are considered private / unroutable / don't make sense.",
            "DEFAULT_IP_RANGE_BLACKLIST = [",
            "    # Localhost",
            "    \"127.0.0.0/8\",",
            "    # Private networks.",
            "    \"10.0.0.0/8\",",
            "    \"172.16.0.0/12\",",
            "    \"192.168.0.0/16\",",
            "    # Carrier grade NAT.",
            "    \"100.64.0.0/10\",",
            "    # Address registry.",
            "    \"192.0.0.0/24\",",
            "    # Link-local networks.",
            "    \"169.254.0.0/16\",",
            "    # Formerly used for 6to4 relay.",
            "    \"192.88.99.0/24\",",
            "    # Testing networks.",
            "    \"198.18.0.0/15\",",
            "    \"192.0.2.0/24\",",
            "    \"198.51.100.0/24\",",
            "    \"203.0.113.0/24\",",
            "    # Multicast.",
            "    \"224.0.0.0/4\",",
            "    # Localhost",
            "    \"::1/128\",",
            "    # Link-local addresses.",
            "    \"fe80::/10\",",
            "    # Unique local addresses.",
            "    \"fc00::/7\",",
            "    # Testing networks.",
            "    \"2001:db8::/32\",",
            "    # Multicast.",
            "    \"ff00::/8\",",
            "    # Site-local addresses",
            "    \"fec0::/10\",",
            "]",
            "",
            "DEFAULT_ROOM_VERSION = \"6\"",
            "",
            "ROOM_COMPLEXITY_TOO_GREAT = (",
            "    \"Your homeserver is unable to join rooms this large or complex. \"",
            "    \"Please speak to your server administrator, or upgrade your instance \"",
            "    \"to join this room.\"",
            ")",
            "",
            "METRICS_PORT_WARNING = \"\"\"\\",
            "The metrics_port configuration option is deprecated in Synapse 0.31 in favour of",
            "a listener. Please see",
            "https://github.com/matrix-org/synapse/blob/master/docs/metrics-howto.md",
            "on how to configure the new listener.",
            "--------------------------------------------------------------------------------\"\"\"",
            "",
            "",
            "KNOWN_LISTENER_TYPES = {",
            "    \"http\",",
            "    \"metrics\",",
            "    \"manhole\",",
            "    \"replication\",",
            "}",
            "",
            "KNOWN_RESOURCES = {",
            "    \"client\",",
            "    \"consent\",",
            "    \"federation\",",
            "    \"keys\",",
            "    \"media\",",
            "    \"metrics\",",
            "    \"openid\",",
            "    \"replication\",",
            "    \"static\",",
            "    \"webclient\",",
            "}",
            "",
            "",
            "@attr.s(frozen=True)",
            "class HttpResourceConfig:",
            "    names = attr.ib(",
            "        type=List[str],",
            "        factory=list,",
            "        validator=attr.validators.deep_iterable(attr.validators.in_(KNOWN_RESOURCES)),  # type: ignore",
            "    )",
            "    compress = attr.ib(",
            "        type=bool,",
            "        default=False,",
            "        validator=attr.validators.optional(attr.validators.instance_of(bool)),  # type: ignore[arg-type]",
            "    )",
            "",
            "",
            "@attr.s(frozen=True)",
            "class HttpListenerConfig:",
            "    \"\"\"Object describing the http-specific parts of the config of a listener\"\"\"",
            "",
            "    x_forwarded = attr.ib(type=bool, default=False)",
            "    resources = attr.ib(type=List[HttpResourceConfig], factory=list)",
            "    additional_resources = attr.ib(type=Dict[str, dict], factory=dict)",
            "    tag = attr.ib(type=str, default=None)",
            "",
            "",
            "@attr.s(frozen=True)",
            "class ListenerConfig:",
            "    \"\"\"Object describing the configuration of a single listener.\"\"\"",
            "",
            "    port = attr.ib(type=int, validator=attr.validators.instance_of(int))",
            "    bind_addresses = attr.ib(type=List[str])",
            "    type = attr.ib(type=str, validator=attr.validators.in_(KNOWN_LISTENER_TYPES))",
            "    tls = attr.ib(type=bool, default=False)",
            "",
            "    # http_options is only populated if type=http",
            "    http_options = attr.ib(type=Optional[HttpListenerConfig], default=None)",
            "",
            "",
            "class ServerConfig(Config):",
            "    section = \"server\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.server_name = config[\"server_name\"]",
            "        self.server_context = config.get(\"server_context\", None)",
            "",
            "        try:",
            "            parse_and_validate_server_name(self.server_name)",
            "        except ValueError as e:",
            "            raise ConfigError(str(e))",
            "",
            "        self.pid_file = self.abspath(config.get(\"pid_file\"))",
            "        self.web_client_location = config.get(\"web_client_location\", None)",
            "        self.soft_file_limit = config.get(\"soft_file_limit\", 0)",
            "        self.daemonize = config.get(\"daemonize\")",
            "        self.print_pidfile = config.get(\"print_pidfile\")",
            "        self.user_agent_suffix = config.get(\"user_agent_suffix\")",
            "        self.use_frozen_dicts = config.get(\"use_frozen_dicts\", False)",
            "        self.public_baseurl = config.get(\"public_baseurl\") or \"https://%s/\" % (",
            "            self.server_name,",
            "        )",
            "        if self.public_baseurl[-1] != \"/\":",
            "            self.public_baseurl += \"/\"",
            "",
            "        # Whether to enable user presence.",
            "        self.use_presence = config.get(\"use_presence\", True)",
            "",
            "        # Whether to update the user directory or not. This should be set to",
            "        # false only if we are updating the user directory in a worker",
            "        self.update_user_directory = config.get(\"update_user_directory\", True)",
            "",
            "        # whether to enable the media repository endpoints. This should be set",
            "        # to false if the media repository is running as a separate endpoint;",
            "        # doing so ensures that we will not run cache cleanup jobs on the",
            "        # master, potentially causing inconsistency.",
            "        self.enable_media_repo = config.get(\"enable_media_repo\", True)",
            "",
            "        # Whether to require authentication to retrieve profile data (avatars,",
            "        # display names) of other users through the client API.",
            "        self.require_auth_for_profile_requests = config.get(",
            "            \"require_auth_for_profile_requests\", False",
            "        )",
            "",
            "        # Whether to require sharing a room with a user to retrieve their",
            "        # profile data",
            "        self.limit_profile_requests_to_users_who_share_rooms = config.get(",
            "            \"limit_profile_requests_to_users_who_share_rooms\", False,",
            "        )",
            "",
            "        if \"restrict_public_rooms_to_local_users\" in config and (",
            "            \"allow_public_rooms_without_auth\" in config",
            "            or \"allow_public_rooms_over_federation\" in config",
            "        ):",
            "            raise ConfigError(",
            "                \"Can't use 'restrict_public_rooms_to_local_users' if\"",
            "                \" 'allow_public_rooms_without_auth' and/or\"",
            "                \" 'allow_public_rooms_over_federation' is set.\"",
            "            )",
            "",
            "        # Check if the legacy \"restrict_public_rooms_to_local_users\" flag is set. This",
            "        # flag is now obsolete but we need to check it for backward-compatibility.",
            "        if config.get(\"restrict_public_rooms_to_local_users\", False):",
            "            self.allow_public_rooms_without_auth = False",
            "            self.allow_public_rooms_over_federation = False",
            "        else:",
            "            # If set to 'true', removes the need for authentication to access the server's",
            "            # public rooms directory through the client API, meaning that anyone can",
            "            # query the room directory. Defaults to 'false'.",
            "            self.allow_public_rooms_without_auth = config.get(",
            "                \"allow_public_rooms_without_auth\", False",
            "            )",
            "            # If set to 'true', allows any other homeserver to fetch the server's public",
            "            # rooms directory via federation. Defaults to 'false'.",
            "            self.allow_public_rooms_over_federation = config.get(",
            "                \"allow_public_rooms_over_federation\", False",
            "            )",
            "",
            "        default_room_version = config.get(\"default_room_version\", DEFAULT_ROOM_VERSION)",
            "",
            "        # Ensure room version is a str",
            "        default_room_version = str(default_room_version)",
            "",
            "        if default_room_version not in KNOWN_ROOM_VERSIONS:",
            "            raise ConfigError(",
            "                \"Unknown default_room_version: %s, known room versions: %s\"",
            "                % (default_room_version, list(KNOWN_ROOM_VERSIONS.keys()))",
            "            )",
            "",
            "        # Get the actual room version object rather than just the identifier",
            "        self.default_room_version = KNOWN_ROOM_VERSIONS[default_room_version]",
            "",
            "        # whether to enable search. If disabled, new entries will not be inserted",
            "        # into the search tables and they will not be indexed. Users will receive",
            "        # errors when attempting to search for messages.",
            "        self.enable_search = config.get(\"enable_search\", True)",
            "",
            "        self.filter_timeline_limit = config.get(\"filter_timeline_limit\", 100)",
            "",
            "        # Whether we should block invites sent to users on this server",
            "        # (other than those sent by local server admins)",
            "        self.block_non_admin_invites = config.get(\"block_non_admin_invites\", False)",
            "",
            "        # Whether to enable experimental MSC1849 (aka relations) support",
            "        self.experimental_msc1849_support_enabled = config.get(",
            "            \"experimental_msc1849_support_enabled\", True",
            "        )",
            "",
            "        # Options to control access by tracking MAU",
            "        self.limit_usage_by_mau = config.get(\"limit_usage_by_mau\", False)",
            "        self.max_mau_value = 0",
            "        if self.limit_usage_by_mau:",
            "            self.max_mau_value = config.get(\"max_mau_value\", 0)",
            "        self.mau_stats_only = config.get(\"mau_stats_only\", False)",
            "",
            "        self.mau_limits_reserved_threepids = config.get(",
            "            \"mau_limit_reserved_threepids\", []",
            "        )",
            "",
            "        self.mau_trial_days = config.get(\"mau_trial_days\", 0)",
            "        self.mau_limit_alerting = config.get(\"mau_limit_alerting\", True)",
            "",
            "        # How long to keep redacted events in the database in unredacted form",
            "        # before redacting them.",
            "        redaction_retention_period = config.get(\"redaction_retention_period\", \"7d\")",
            "        if redaction_retention_period is not None:",
            "            self.redaction_retention_period = self.parse_duration(",
            "                redaction_retention_period",
            "            )",
            "        else:",
            "            self.redaction_retention_period = None",
            "",
            "        # How long to keep entries in the `users_ips` table.",
            "        user_ips_max_age = config.get(\"user_ips_max_age\", \"28d\")",
            "        if user_ips_max_age is not None:",
            "            self.user_ips_max_age = self.parse_duration(user_ips_max_age)",
            "        else:",
            "            self.user_ips_max_age = None",
            "",
            "        # Options to disable HS",
            "        self.hs_disabled = config.get(\"hs_disabled\", False)",
            "        self.hs_disabled_message = config.get(\"hs_disabled_message\", \"\")",
            "",
            "        # Admin uri to direct users at should their instance become blocked",
            "        # due to resource constraints",
            "        self.admin_contact = config.get(\"admin_contact\", None)",
            "",
            "        ip_range_blacklist = config.get(",
            "            \"ip_range_blacklist\", DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        # Attempt to create an IPSet from the given ranges",
            "",
            "        # Always blacklist 0.0.0.0, ::",
            "        self.ip_range_blacklist = generate_ip_set(",
            "            ip_range_blacklist, [\"0.0.0.0\", \"::\"], config_path=(\"ip_range_blacklist\",)",
            "        )",
            "",
            "        self.ip_range_whitelist = generate_ip_set(",
            "            config.get(\"ip_range_whitelist\", ()), config_path=(\"ip_range_whitelist\",)",
            "        )",
            "",
            "        # The federation_ip_range_blacklist is used for backwards-compatibility",
            "        # and only applies to federation and identity servers. If it is not given,",
            "        # default to ip_range_blacklist.",
            "        federation_ip_range_blacklist = config.get(",
            "            \"federation_ip_range_blacklist\", ip_range_blacklist",
            "        )",
            "        # Always blacklist 0.0.0.0, ::",
            "        self.federation_ip_range_blacklist = generate_ip_set(",
            "            federation_ip_range_blacklist,",
            "            [\"0.0.0.0\", \"::\"],",
            "            config_path=(\"federation_ip_range_blacklist\",),",
            "        )",
            "",
            "        self.start_pushers = config.get(\"start_pushers\", True)",
            "",
            "        # (undocumented) option for torturing the worker-mode replication a bit,",
            "        # for testing. The value defines the number of milliseconds to pause before",
            "        # sending out any replication updates.",
            "        self.replication_torture_level = config.get(\"replication_torture_level\")",
            "",
            "        # Whether to require a user to be in the room to add an alias to it.",
            "        # Defaults to True.",
            "        self.require_membership_for_aliases = config.get(",
            "            \"require_membership_for_aliases\", True",
            "        )",
            "",
            "        # Whether to allow per-room membership profiles through the send of membership",
            "        # events with profile information that differ from the target's global profile.",
            "        self.allow_per_room_profiles = config.get(\"allow_per_room_profiles\", True)",
            "",
            "        retention_config = config.get(\"retention\")",
            "        if retention_config is None:",
            "            retention_config = {}",
            "",
            "        self.retention_enabled = retention_config.get(\"enabled\", False)",
            "",
            "        retention_default_policy = retention_config.get(\"default_policy\")",
            "",
            "        if retention_default_policy is not None:",
            "            self.retention_default_min_lifetime = retention_default_policy.get(",
            "                \"min_lifetime\"",
            "            )",
            "            if self.retention_default_min_lifetime is not None:",
            "                self.retention_default_min_lifetime = self.parse_duration(",
            "                    self.retention_default_min_lifetime",
            "                )",
            "",
            "            self.retention_default_max_lifetime = retention_default_policy.get(",
            "                \"max_lifetime\"",
            "            )",
            "            if self.retention_default_max_lifetime is not None:",
            "                self.retention_default_max_lifetime = self.parse_duration(",
            "                    self.retention_default_max_lifetime",
            "                )",
            "",
            "            if (",
            "                self.retention_default_min_lifetime is not None",
            "                and self.retention_default_max_lifetime is not None",
            "                and (",
            "                    self.retention_default_min_lifetime",
            "                    > self.retention_default_max_lifetime",
            "                )",
            "            ):",
            "                raise ConfigError(",
            "                    \"The default retention policy's 'min_lifetime' can not be greater\"",
            "                    \" than its 'max_lifetime'\"",
            "                )",
            "        else:",
            "            self.retention_default_min_lifetime = None",
            "            self.retention_default_max_lifetime = None",
            "",
            "        if self.retention_enabled:",
            "            logger.info(",
            "                \"Message retention policies support enabled with the following default\"",
            "                \" policy: min_lifetime = %s ; max_lifetime = %s\",",
            "                self.retention_default_min_lifetime,",
            "                self.retention_default_max_lifetime,",
            "            )",
            "",
            "        self.retention_allowed_lifetime_min = retention_config.get(",
            "            \"allowed_lifetime_min\"",
            "        )",
            "        if self.retention_allowed_lifetime_min is not None:",
            "            self.retention_allowed_lifetime_min = self.parse_duration(",
            "                self.retention_allowed_lifetime_min",
            "            )",
            "",
            "        self.retention_allowed_lifetime_max = retention_config.get(",
            "            \"allowed_lifetime_max\"",
            "        )",
            "        if self.retention_allowed_lifetime_max is not None:",
            "            self.retention_allowed_lifetime_max = self.parse_duration(",
            "                self.retention_allowed_lifetime_max",
            "            )",
            "",
            "        if (",
            "            self.retention_allowed_lifetime_min is not None",
            "            and self.retention_allowed_lifetime_max is not None",
            "            and self.retention_allowed_lifetime_min",
            "            > self.retention_allowed_lifetime_max",
            "        ):",
            "            raise ConfigError(",
            "                \"Invalid retention policy limits: 'allowed_lifetime_min' can not be\"",
            "                \" greater than 'allowed_lifetime_max'\"",
            "            )",
            "",
            "        self.retention_purge_jobs = []  # type: List[Dict[str, Optional[int]]]",
            "        for purge_job_config in retention_config.get(\"purge_jobs\", []):",
            "            interval_config = purge_job_config.get(\"interval\")",
            "",
            "            if interval_config is None:",
            "                raise ConfigError(",
            "                    \"A retention policy's purge jobs configuration must have the\"",
            "                    \" 'interval' key set.\"",
            "                )",
            "",
            "            interval = self.parse_duration(interval_config)",
            "",
            "            shortest_max_lifetime = purge_job_config.get(\"shortest_max_lifetime\")",
            "",
            "            if shortest_max_lifetime is not None:",
            "                shortest_max_lifetime = self.parse_duration(shortest_max_lifetime)",
            "",
            "            longest_max_lifetime = purge_job_config.get(\"longest_max_lifetime\")",
            "",
            "            if longest_max_lifetime is not None:",
            "                longest_max_lifetime = self.parse_duration(longest_max_lifetime)",
            "",
            "            if (",
            "                shortest_max_lifetime is not None",
            "                and longest_max_lifetime is not None",
            "                and shortest_max_lifetime > longest_max_lifetime",
            "            ):",
            "                raise ConfigError(",
            "                    \"A retention policy's purge jobs configuration's\"",
            "                    \" 'shortest_max_lifetime' value can not be greater than its\"",
            "                    \" 'longest_max_lifetime' value.\"",
            "                )",
            "",
            "            self.retention_purge_jobs.append(",
            "                {",
            "                    \"interval\": interval,",
            "                    \"shortest_max_lifetime\": shortest_max_lifetime,",
            "                    \"longest_max_lifetime\": longest_max_lifetime,",
            "                }",
            "            )",
            "",
            "        if not self.retention_purge_jobs:",
            "            self.retention_purge_jobs = [",
            "                {",
            "                    \"interval\": self.parse_duration(\"1d\"),",
            "                    \"shortest_max_lifetime\": None,",
            "                    \"longest_max_lifetime\": None,",
            "                }",
            "            ]",
            "",
            "        self.listeners = [parse_listener_def(x) for x in config.get(\"listeners\", [])]",
            "",
            "        # no_tls is not really supported any more, but let's grandfather it in",
            "        # here.",
            "        if config.get(\"no_tls\", False):",
            "            l2 = []",
            "            for listener in self.listeners:",
            "                if listener.tls:",
            "                    logger.info(",
            "                        \"Ignoring TLS-enabled listener on port %i due to no_tls\",",
            "                        listener.port,",
            "                    )",
            "                else:",
            "                    l2.append(listener)",
            "            self.listeners = l2",
            "",
            "        if not self.web_client_location:",
            "            _warn_if_webclient_configured(self.listeners)",
            "",
            "        self.gc_thresholds = read_gc_thresholds(config.get(\"gc_thresholds\", None))",
            "",
            "        @attr.s",
            "        class LimitRemoteRoomsConfig:",
            "            enabled = attr.ib(",
            "                validator=attr.validators.instance_of(bool), default=False",
            "            )",
            "            complexity = attr.ib(",
            "                validator=attr.validators.instance_of(",
            "                    (float, int)  # type: ignore[arg-type] # noqa",
            "                ),",
            "                default=1.0,",
            "            )",
            "            complexity_error = attr.ib(",
            "                validator=attr.validators.instance_of(str),",
            "                default=ROOM_COMPLEXITY_TOO_GREAT,",
            "            )",
            "            admins_can_join = attr.ib(",
            "                validator=attr.validators.instance_of(bool), default=False",
            "            )",
            "",
            "        self.limit_remote_rooms = LimitRemoteRoomsConfig(",
            "            **(config.get(\"limit_remote_rooms\") or {})",
            "        )",
            "",
            "        bind_port = config.get(\"bind_port\")",
            "        if bind_port:",
            "            if config.get(\"no_tls\", False):",
            "                raise ConfigError(\"no_tls is incompatible with bind_port\")",
            "",
            "            self.listeners = []",
            "            bind_host = config.get(\"bind_host\", \"\")",
            "            gzip_responses = config.get(\"gzip_responses\", True)",
            "",
            "            http_options = HttpListenerConfig(",
            "                resources=[",
            "                    HttpResourceConfig(names=[\"client\"], compress=gzip_responses),",
            "                    HttpResourceConfig(names=[\"federation\"]),",
            "                ],",
            "            )",
            "",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=bind_port,",
            "                    bind_addresses=[bind_host],",
            "                    tls=True,",
            "                    type=\"http\",",
            "                    http_options=http_options,",
            "                )",
            "            )",
            "",
            "            unsecure_port = config.get(\"unsecure_port\", bind_port - 400)",
            "            if unsecure_port:",
            "                self.listeners.append(",
            "                    ListenerConfig(",
            "                        port=unsecure_port,",
            "                        bind_addresses=[bind_host],",
            "                        tls=False,",
            "                        type=\"http\",",
            "                        http_options=http_options,",
            "                    )",
            "                )",
            "",
            "        manhole = config.get(\"manhole\")",
            "        if manhole:",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=manhole, bind_addresses=[\"127.0.0.1\"], type=\"manhole\",",
            "                )",
            "            )",
            "",
            "        metrics_port = config.get(\"metrics_port\")",
            "        if metrics_port:",
            "            logger.warning(METRICS_PORT_WARNING)",
            "",
            "            self.listeners.append(",
            "                ListenerConfig(",
            "                    port=metrics_port,",
            "                    bind_addresses=[config.get(\"metrics_bind_host\", \"127.0.0.1\")],",
            "                    type=\"http\",",
            "                    http_options=HttpListenerConfig(",
            "                        resources=[HttpResourceConfig(names=[\"metrics\"])]",
            "                    ),",
            "                )",
            "            )",
            "",
            "        self.cleanup_extremities_with_dummy_events = config.get(",
            "            \"cleanup_extremities_with_dummy_events\", True",
            "        )",
            "",
            "        # The number of forward extremities in a room needed to send a dummy event.",
            "        self.dummy_events_threshold = config.get(\"dummy_events_threshold\", 10)",
            "",
            "        self.enable_ephemeral_messages = config.get(\"enable_ephemeral_messages\", False)",
            "",
            "        # Inhibits the /requestToken endpoints from returning an error that might leak",
            "        # information about whether an e-mail address is in use or not on this",
            "        # homeserver, and instead return a 200 with a fake sid if this kind of error is",
            "        # met, without sending anything.",
            "        # This is a compromise between sending an email, which could be a spam vector,",
            "        # and letting the client know which email address is bound to an account and",
            "        # which one isn't.",
            "        self.request_token_inhibit_3pid_errors = config.get(",
            "            \"request_token_inhibit_3pid_errors\", False,",
            "        )",
            "",
            "        # List of users trialing the new experimental default push rules. This setting is",
            "        # not included in the sample configuration file on purpose as it's a temporary",
            "        # hack, so that some users can trial the new defaults without impacting every",
            "        # user on the homeserver.",
            "        users_new_default_push_rules = (",
            "            config.get(\"users_new_default_push_rules\") or []",
            "        )  # type: list",
            "        if not isinstance(users_new_default_push_rules, list):",
            "            raise ConfigError(\"'users_new_default_push_rules' must be a list\")",
            "",
            "        # Turn the list into a set to improve lookup speed.",
            "        self.users_new_default_push_rules = set(",
            "            users_new_default_push_rules",
            "        )  # type: set",
            "",
            "        # Whitelist of domain names that given next_link parameters must have",
            "        next_link_domain_whitelist = config.get(",
            "            \"next_link_domain_whitelist\"",
            "        )  # type: Optional[List[str]]",
            "",
            "        self.next_link_domain_whitelist = None  # type: Optional[Set[str]]",
            "        if next_link_domain_whitelist is not None:",
            "            if not isinstance(next_link_domain_whitelist, list):",
            "                raise ConfigError(\"'next_link_domain_whitelist' must be a list\")",
            "",
            "            # Turn the list into a set to improve lookup speed.",
            "            self.next_link_domain_whitelist = set(next_link_domain_whitelist)",
            "",
            "    def has_tls_listener(self) -> bool:",
            "        return any(listener.tls for listener in self.listeners)",
            "",
            "    def generate_config_section(",
            "        self, server_name, data_dir_path, open_private_ports, listeners, **kwargs",
            "    ):",
            "        ip_range_blacklist = \"\\n\".join(",
            "            \"        #  - '%s'\" % ip for ip in DEFAULT_IP_RANGE_BLACKLIST",
            "        )",
            "",
            "        _, bind_port = parse_and_validate_server_name(server_name)",
            "        if bind_port is not None:",
            "            unsecure_port = bind_port - 400",
            "        else:",
            "            bind_port = 8448",
            "            unsecure_port = 8008",
            "",
            "        pid_file = os.path.join(data_dir_path, \"homeserver.pid\")",
            "",
            "        # Bring DEFAULT_ROOM_VERSION into the local-scope for use in the",
            "        # default config string",
            "        default_room_version = DEFAULT_ROOM_VERSION",
            "        secure_listeners = []",
            "        unsecure_listeners = []",
            "        private_addresses = [\"::1\", \"127.0.0.1\"]",
            "        if listeners:",
            "            for listener in listeners:",
            "                if listener[\"tls\"]:",
            "                    secure_listeners.append(listener)",
            "                else:",
            "                    # If we don't want open ports we need to bind the listeners",
            "                    # to some address other than 0.0.0.0. Here we chose to use",
            "                    # localhost.",
            "                    # If the addresses are already bound we won't overwrite them",
            "                    # however.",
            "                    if not open_private_ports:",
            "                        listener.setdefault(\"bind_addresses\", private_addresses)",
            "",
            "                    unsecure_listeners.append(listener)",
            "",
            "            secure_http_bindings = indent(",
            "                yaml.dump(secure_listeners), \" \" * 10",
            "            ).lstrip()",
            "",
            "            unsecure_http_bindings = indent(",
            "                yaml.dump(unsecure_listeners), \" \" * 10",
            "            ).lstrip()",
            "",
            "        if not unsecure_listeners:",
            "            unsecure_http_bindings = (",
            "                \"\"\"- port: %(unsecure_port)s",
            "            tls: false",
            "            type: http",
            "            x_forwarded: true\"\"\"",
            "                % locals()",
            "            )",
            "",
            "            if not open_private_ports:",
            "                unsecure_http_bindings += (",
            "                    \"\\n            bind_addresses: ['::1', '127.0.0.1']\"",
            "                )",
            "",
            "            unsecure_http_bindings += \"\"\"",
            "",
            "            resources:",
            "              - names: [client, federation]",
            "                compress: false\"\"\"",
            "",
            "            if listeners:",
            "                # comment out this block",
            "                unsecure_http_bindings = \"#\" + re.sub(",
            "                    \"\\n {10}\",",
            "                    lambda match: match.group(0) + \"#\",",
            "                    unsecure_http_bindings,",
            "                )",
            "",
            "        if not secure_listeners:",
            "            secure_http_bindings = (",
            "                \"\"\"#- port: %(bind_port)s",
            "          #  type: http",
            "          #  tls: true",
            "          #  resources:",
            "          #    - names: [client, federation]\"\"\"",
            "                % locals()",
            "            )",
            "",
            "        return (",
            "            \"\"\"\\",
            "        ## Server ##",
            "",
            "        # The public-facing domain of the server",
            "        #",
            "        # The server_name name will appear at the end of usernames and room addresses",
            "        # created on this server. For example if the server_name was example.com,",
            "        # usernames on this server would be in the format @user:example.com",
            "        #",
            "        # In most cases you should avoid using a matrix specific subdomain such as",
            "        # matrix.example.com or synapse.example.com as the server_name for the same",
            "        # reasons you wouldn't use user@email.example.com as your email address.",
            "        # See https://github.com/matrix-org/synapse/blob/master/docs/delegate.md",
            "        # for information on how to host Synapse on a subdomain while preserving",
            "        # a clean server_name.",
            "        #",
            "        # The server_name cannot be changed later so it is important to",
            "        # configure this correctly before you start Synapse. It should be all",
            "        # lowercase and may contain an explicit port.",
            "        # Examples: matrix.org, localhost:8080",
            "        #",
            "        server_name: \"%(server_name)s\"",
            "",
            "        # When running as a daemon, the file to store the pid in",
            "        #",
            "        pid_file: %(pid_file)s",
            "",
            "        # The absolute URL to the web client which /_matrix/client will redirect",
            "        # to if 'webclient' is configured under the 'listeners' configuration.",
            "        #",
            "        # This option can be also set to the filesystem path to the web client",
            "        # which will be served at /_matrix/client/ if 'webclient' is configured",
            "        # under the 'listeners' configuration, however this is a security risk:",
            "        # https://github.com/matrix-org/synapse#security-note",
            "        #",
            "        #web_client_location: https://riot.example.com/",
            "",
            "        # The public-facing base URL that clients use to access this Homeserver (not",
            "        # including _matrix/...). This is the same URL a user might enter into the",
            "        # 'Custom Homeserver URL' field on their client. If you use Synapse with a",
            "        # reverse proxy, this should be the URL to reach Synapse via the proxy.",
            "        # Otherwise, it should be the URL to reach Synapse's client HTTP listener (see",
            "        # 'listeners' below).",
            "        #",
            "        # If this is left unset, it defaults to 'https://<server_name>/'. (Note that",
            "        # that will not work unless you configure Synapse or a reverse-proxy to listen",
            "        # on port 443.)",
            "        #",
            "        #public_baseurl: https://example.com/",
            "",
            "        # Set the soft limit on the number of file descriptors synapse can use",
            "        # Zero is used to indicate synapse should set the soft limit to the",
            "        # hard limit.",
            "        #",
            "        #soft_file_limit: 0",
            "",
            "        # Set to false to disable presence tracking on this homeserver.",
            "        #",
            "        #use_presence: false",
            "",
            "        # Whether to require authentication to retrieve profile data (avatars,",
            "        # display names) of other users through the client API. Defaults to",
            "        # 'false'. Note that profile data is also available via the federation",
            "        # API, so this setting is of limited value if federation is enabled on",
            "        # the server.",
            "        #",
            "        #require_auth_for_profile_requests: true",
            "",
            "        # Uncomment to require a user to share a room with another user in order",
            "        # to retrieve their profile information. Only checked on Client-Server",
            "        # requests. Profile requests from other servers should be checked by the",
            "        # requesting server. Defaults to 'false'.",
            "        #",
            "        #limit_profile_requests_to_users_who_share_rooms: true",
            "",
            "        # If set to 'true', removes the need for authentication to access the server's",
            "        # public rooms directory through the client API, meaning that anyone can",
            "        # query the room directory. Defaults to 'false'.",
            "        #",
            "        #allow_public_rooms_without_auth: true",
            "",
            "        # If set to 'true', allows any other homeserver to fetch the server's public",
            "        # rooms directory via federation. Defaults to 'false'.",
            "        #",
            "        #allow_public_rooms_over_federation: true",
            "",
            "        # The default room version for newly created rooms.",
            "        #",
            "        # Known room versions are listed here:",
            "        # https://matrix.org/docs/spec/#complete-list-of-room-versions",
            "        #",
            "        # For example, for room version 1, default_room_version should be set",
            "        # to \"1\".",
            "        #",
            "        #default_room_version: \"%(default_room_version)s\"",
            "",
            "        # The GC threshold parameters to pass to `gc.set_threshold`, if defined",
            "        #",
            "        #gc_thresholds: [700, 10, 10]",
            "",
            "        # Set the limit on the returned events in the timeline in the get",
            "        # and sync operations. The default value is 100. -1 means no upper limit.",
            "        #",
            "        # Uncomment the following to increase the limit to 5000.",
            "        #",
            "        #filter_timeline_limit: 5000",
            "",
            "        # Whether room invites to users on this server should be blocked",
            "        # (except those sent by local server admins). The default is False.",
            "        #",
            "        #block_non_admin_invites: true",
            "",
            "        # Room searching",
            "        #",
            "        # If disabled, new messages will not be indexed for searching and users",
            "        # will receive errors when searching for messages. Defaults to enabled.",
            "        #",
            "        #enable_search: false",
            "",
            "        # Prevent outgoing requests from being sent to the following blacklisted IP address",
            "        # CIDR ranges. If this option is not specified then it defaults to private IP",
            "        # address ranges (see the example below).",
            "        #",
            "        # The blacklist applies to the outbound requests for federation, identity servers,",
            "        # push servers, and for checking key validity for third-party invite events.",
            "        #",
            "        # (0.0.0.0 and :: are always blacklisted, whether or not they are explicitly",
            "        # listed here, since they correspond to unroutable addresses.)",
            "        #",
            "        # This option replaces federation_ip_range_blacklist in Synapse v1.25.0.",
            "        #",
            "        #ip_range_blacklist:",
            "%(ip_range_blacklist)s",
            "",
            "        # List of IP address CIDR ranges that should be allowed for federation,",
            "        # identity servers, push servers, and for checking key validity for",
            "        # third-party invite events. This is useful for specifying exceptions to",
            "        # wide-ranging blacklisted target IP ranges - e.g. for communication with",
            "        # a push server only visible in your network.",
            "        #",
            "        # This whitelist overrides ip_range_blacklist and defaults to an empty",
            "        # list.",
            "        #",
            "        #ip_range_whitelist:",
            "        #   - '192.168.1.1'",
            "",
            "        # List of ports that Synapse should listen on, their purpose and their",
            "        # configuration.",
            "        #",
            "        # Options for each listener include:",
            "        #",
            "        #   port: the TCP port to bind to",
            "        #",
            "        #   bind_addresses: a list of local addresses to listen on. The default is",
            "        #       'all local interfaces'.",
            "        #",
            "        #   type: the type of listener. Normally 'http', but other valid options are:",
            "        #       'manhole' (see docs/manhole.md),",
            "        #       'metrics' (see docs/metrics-howto.md),",
            "        #       'replication' (see docs/workers.md).",
            "        #",
            "        #   tls: set to true to enable TLS for this listener. Will use the TLS",
            "        #       key/cert specified in tls_private_key_path / tls_certificate_path.",
            "        #",
            "        #   x_forwarded: Only valid for an 'http' listener. Set to true to use the",
            "        #       X-Forwarded-For header as the client IP. Useful when Synapse is",
            "        #       behind a reverse-proxy.",
            "        #",
            "        #   resources: Only valid for an 'http' listener. A list of resources to host",
            "        #       on this port. Options for each resource are:",
            "        #",
            "        #       names: a list of names of HTTP resources. See below for a list of",
            "        #           valid resource names.",
            "        #",
            "        #       compress: set to true to enable HTTP compression for this resource.",
            "        #",
            "        #   additional_resources: Only valid for an 'http' listener. A map of",
            "        #        additional endpoints which should be loaded via dynamic modules.",
            "        #",
            "        # Valid resource names are:",
            "        #",
            "        #   client: the client-server API (/_matrix/client), and the synapse admin",
            "        #       API (/_synapse/admin). Also implies 'media' and 'static'.",
            "        #",
            "        #   consent: user consent forms (/_matrix/consent). See",
            "        #       docs/consent_tracking.md.",
            "        #",
            "        #   federation: the server-server API (/_matrix/federation). Also implies",
            "        #       'media', 'keys', 'openid'",
            "        #",
            "        #   keys: the key discovery API (/_matrix/keys).",
            "        #",
            "        #   media: the media API (/_matrix/media).",
            "        #",
            "        #   metrics: the metrics interface. See docs/metrics-howto.md.",
            "        #",
            "        #   openid: OpenID authentication.",
            "        #",
            "        #   replication: the HTTP replication API (/_synapse/replication). See",
            "        #       docs/workers.md.",
            "        #",
            "        #   static: static resources under synapse/static (/_matrix/static). (Mostly",
            "        #       useful for 'fallback authentication'.)",
            "        #",
            "        #   webclient: A web client. Requires web_client_location to be set.",
            "        #",
            "        listeners:",
            "          # TLS-enabled listener: for when matrix traffic is sent directly to synapse.",
            "          #",
            "          # Disabled by default. To enable it, uncomment the following. (Note that you",
            "          # will also need to give Synapse a TLS key and certificate: see the TLS section",
            "          # below.)",
            "          #",
            "          %(secure_http_bindings)s",
            "",
            "          # Unsecure HTTP listener: for when matrix traffic passes through a reverse proxy",
            "          # that unwraps TLS.",
            "          #",
            "          # If you plan to use a reverse proxy, please see",
            "          # https://github.com/matrix-org/synapse/blob/master/docs/reverse_proxy.md.",
            "          #",
            "          %(unsecure_http_bindings)s",
            "",
            "            # example additional_resources:",
            "            #",
            "            #additional_resources:",
            "            #  \"/_matrix/my/custom/endpoint\":",
            "            #    module: my_module.CustomRequestHandler",
            "            #    config: {}",
            "",
            "          # Turn on the twisted ssh manhole service on localhost on the given",
            "          # port.",
            "          #",
            "          #- port: 9000",
            "          #  bind_addresses: ['::1', '127.0.0.1']",
            "          #  type: manhole",
            "",
            "        # Forward extremities can build up in a room due to networking delays between",
            "        # homeservers. Once this happens in a large room, calculation of the state of",
            "        # that room can become quite expensive. To mitigate this, once the number of",
            "        # forward extremities reaches a given threshold, Synapse will send an",
            "        # org.matrix.dummy_event event, which will reduce the forward extremities",
            "        # in the room.",
            "        #",
            "        # This setting defines the threshold (i.e. number of forward extremities in the",
            "        # room) at which dummy events are sent. The default value is 10.",
            "        #",
            "        #dummy_events_threshold: 5",
            "",
            "",
            "        ## Homeserver blocking ##",
            "",
            "        # How to reach the server admin, used in ResourceLimitError",
            "        #",
            "        #admin_contact: 'mailto:admin@server.com'",
            "",
            "        # Global blocking",
            "        #",
            "        #hs_disabled: false",
            "        #hs_disabled_message: 'Human readable reason for why the HS is blocked'",
            "",
            "        # Monthly Active User Blocking",
            "        #",
            "        # Used in cases where the admin or server owner wants to limit to the",
            "        # number of monthly active users.",
            "        #",
            "        # 'limit_usage_by_mau' disables/enables monthly active user blocking. When",
            "        # enabled and a limit is reached the server returns a 'ResourceLimitError'",
            "        # with error type Codes.RESOURCE_LIMIT_EXCEEDED",
            "        #",
            "        # 'max_mau_value' is the hard limit of monthly active users above which",
            "        # the server will start blocking user actions.",
            "        #",
            "        # 'mau_trial_days' is a means to add a grace period for active users. It",
            "        # means that users must be active for this number of days before they",
            "        # can be considered active and guards against the case where lots of users",
            "        # sign up in a short space of time never to return after their initial",
            "        # session.",
            "        #",
            "        # 'mau_limit_alerting' is a means of limiting client side alerting",
            "        # should the mau limit be reached. This is useful for small instances",
            "        # where the admin has 5 mau seats (say) for 5 specific people and no",
            "        # interest increasing the mau limit further. Defaults to True, which",
            "        # means that alerting is enabled",
            "        #",
            "        #limit_usage_by_mau: false",
            "        #max_mau_value: 50",
            "        #mau_trial_days: 2",
            "        #mau_limit_alerting: false",
            "",
            "        # If enabled, the metrics for the number of monthly active users will",
            "        # be populated, however no one will be limited. If limit_usage_by_mau",
            "        # is true, this is implied to be true.",
            "        #",
            "        #mau_stats_only: false",
            "",
            "        # Sometimes the server admin will want to ensure certain accounts are",
            "        # never blocked by mau checking. These accounts are specified here.",
            "        #",
            "        #mau_limit_reserved_threepids:",
            "        #  - medium: 'email'",
            "        #    address: 'reserved_user@example.com'",
            "",
            "        # Used by phonehome stats to group together related servers.",
            "        #server_context: context",
            "",
            "        # Resource-constrained homeserver settings",
            "        #",
            "        # When this is enabled, the room \"complexity\" will be checked before a user",
            "        # joins a new remote room. If it is above the complexity limit, the server will",
            "        # disallow joining, or will instantly leave.",
            "        #",
            "        # Room complexity is an arbitrary measure based on factors such as the number of",
            "        # users in the room.",
            "        #",
            "        limit_remote_rooms:",
            "          # Uncomment to enable room complexity checking.",
            "          #",
            "          #enabled: true",
            "",
            "          # the limit above which rooms cannot be joined. The default is 1.0.",
            "          #",
            "          #complexity: 0.5",
            "",
            "          # override the error which is returned when the room is too complex.",
            "          #",
            "          #complexity_error: \"This room is too complex.\"",
            "",
            "          # allow server admins to join complex rooms. Default is false.",
            "          #",
            "          #admins_can_join: true",
            "",
            "        # Whether to require a user to be in the room to add an alias to it.",
            "        # Defaults to 'true'.",
            "        #",
            "        #require_membership_for_aliases: false",
            "",
            "        # Whether to allow per-room membership profiles through the send of membership",
            "        # events with profile information that differ from the target's global profile.",
            "        # Defaults to 'true'.",
            "        #",
            "        #allow_per_room_profiles: false",
            "",
            "        # How long to keep redacted events in unredacted form in the database. After",
            "        # this period redacted events get replaced with their redacted form in the DB.",
            "        #",
            "        # Defaults to `7d`. Set to `null` to disable.",
            "        #",
            "        #redaction_retention_period: 28d",
            "",
            "        # How long to track users' last seen time and IPs in the database.",
            "        #",
            "        # Defaults to `28d`. Set to `null` to disable clearing out of old rows.",
            "        #",
            "        #user_ips_max_age: 14d",
            "",
            "        # Message retention policy at the server level.",
            "        #",
            "        # Room admins and mods can define a retention period for their rooms using the",
            "        # 'm.room.retention' state event, and server admins can cap this period by setting",
            "        # the 'allowed_lifetime_min' and 'allowed_lifetime_max' config options.",
            "        #",
            "        # If this feature is enabled, Synapse will regularly look for and purge events",
            "        # which are older than the room's maximum retention period. Synapse will also",
            "        # filter events received over federation so that events that should have been",
            "        # purged are ignored and not stored again.",
            "        #",
            "        retention:",
            "          # The message retention policies feature is disabled by default. Uncomment the",
            "          # following line to enable it.",
            "          #",
            "          #enabled: true",
            "",
            "          # Default retention policy. If set, Synapse will apply it to rooms that lack the",
            "          # 'm.room.retention' state event. Currently, the value of 'min_lifetime' doesn't",
            "          # matter much because Synapse doesn't take it into account yet.",
            "          #",
            "          #default_policy:",
            "          #  min_lifetime: 1d",
            "          #  max_lifetime: 1y",
            "",
            "          # Retention policy limits. If set, and the state of a room contains a",
            "          # 'm.room.retention' event in its state which contains a 'min_lifetime' or a",
            "          # 'max_lifetime' that's out of these bounds, Synapse will cap the room's policy",
            "          # to these limits when running purge jobs.",
            "          #",
            "          #allowed_lifetime_min: 1d",
            "          #allowed_lifetime_max: 1y",
            "",
            "          # Server admins can define the settings of the background jobs purging the",
            "          # events which lifetime has expired under the 'purge_jobs' section.",
            "          #",
            "          # If no configuration is provided, a single job will be set up to delete expired",
            "          # events in every room daily.",
            "          #",
            "          # Each job's configuration defines which range of message lifetimes the job",
            "          # takes care of. For example, if 'shortest_max_lifetime' is '2d' and",
            "          # 'longest_max_lifetime' is '3d', the job will handle purging expired events in",
            "          # rooms whose state defines a 'max_lifetime' that's both higher than 2 days, and",
            "          # lower than or equal to 3 days. Both the minimum and the maximum value of a",
            "          # range are optional, e.g. a job with no 'shortest_max_lifetime' and a",
            "          # 'longest_max_lifetime' of '3d' will handle every room with a retention policy",
            "          # which 'max_lifetime' is lower than or equal to three days.",
            "          #",
            "          # The rationale for this per-job configuration is that some rooms might have a",
            "          # retention policy with a low 'max_lifetime', where history needs to be purged",
            "          # of outdated messages on a more frequent basis than for the rest of the rooms",
            "          # (e.g. every 12h), but not want that purge to be performed by a job that's",
            "          # iterating over every room it knows, which could be heavy on the server.",
            "          #",
            "          # If any purge job is configured, it is strongly recommended to have at least",
            "          # a single job with neither 'shortest_max_lifetime' nor 'longest_max_lifetime'",
            "          # set, or one job without 'shortest_max_lifetime' and one job without",
            "          # 'longest_max_lifetime' set. Otherwise some rooms might be ignored, even if",
            "          # 'allowed_lifetime_min' and 'allowed_lifetime_max' are set, because capping a",
            "          # room's policy to these values is done after the policies are retrieved from",
            "          # Synapse's database (which is done using the range specified in a purge job's",
            "          # configuration).",
            "          #",
            "          #purge_jobs:",
            "          #  - longest_max_lifetime: 3d",
            "          #    interval: 12h",
            "          #  - shortest_max_lifetime: 3d",
            "          #    interval: 1d",
            "",
            "        # Inhibits the /requestToken endpoints from returning an error that might leak",
            "        # information about whether an e-mail address is in use or not on this",
            "        # homeserver.",
            "        # Note that for some endpoints the error situation is the e-mail already being",
            "        # used, and for others the error is entering the e-mail being unused.",
            "        # If this option is enabled, instead of returning an error, these endpoints will",
            "        # act as if no error happened and return a fake session ID ('sid') to clients.",
            "        #",
            "        #request_token_inhibit_3pid_errors: true",
            "",
            "        # A list of domains that the domain portion of 'next_link' parameters",
            "        # must match.",
            "        #",
            "        # This parameter is optionally provided by clients while requesting",
            "        # validation of an email or phone number, and maps to a link that",
            "        # users will be automatically redirected to after validation",
            "        # succeeds. Clients can make use this parameter to aid the validation",
            "        # process.",
            "        #",
            "        # The whitelist is applied whether the homeserver or an",
            "        # identity server is handling validation.",
            "        #",
            "        # The default value is no whitelist functionality; all domains are",
            "        # allowed. Setting this value to an empty list will instead disallow",
            "        # all domains.",
            "        #",
            "        #next_link_domain_whitelist: [\"matrix.org\"]",
            "        \"\"\"",
            "            % locals()",
            "        )",
            "",
            "    def read_arguments(self, args):",
            "        if args.manhole is not None:",
            "            self.manhole = args.manhole",
            "        if args.daemonize is not None:",
            "            self.daemonize = args.daemonize",
            "        if args.print_pidfile is not None:",
            "            self.print_pidfile = args.print_pidfile",
            "",
            "    @staticmethod",
            "    def add_arguments(parser):",
            "        server_group = parser.add_argument_group(\"server\")",
            "        server_group.add_argument(",
            "            \"-D\",",
            "            \"--daemonize\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Daemonize the homeserver\",",
            "        )",
            "        server_group.add_argument(",
            "            \"--print-pidfile\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Print the path to the pidfile just before daemonizing\",",
            "        )",
            "        server_group.add_argument(",
            "            \"--manhole\",",
            "            metavar=\"PORT\",",
            "            dest=\"manhole\",",
            "            type=int,",
            "            help=\"Turn on the twisted telnet manhole service on the given port.\",",
            "        )",
            "",
            "",
            "def is_threepid_reserved(reserved_threepids, threepid):",
            "    \"\"\"Check the threepid against the reserved threepid config",
            "    Args:",
            "        reserved_threepids([dict]) - list of reserved threepids",
            "        threepid(dict) - The threepid to test for",
            "",
            "    Returns:",
            "        boolean Is the threepid undertest reserved_user",
            "    \"\"\"",
            "",
            "    for tp in reserved_threepids:",
            "        if threepid[\"medium\"] == tp[\"medium\"] and threepid[\"address\"] == tp[\"address\"]:",
            "            return True",
            "    return False",
            "",
            "",
            "def read_gc_thresholds(thresholds):",
            "    \"\"\"Reads the three integer thresholds for garbage collection. Ensures that",
            "    the thresholds are integers if thresholds are supplied.",
            "    \"\"\"",
            "    if thresholds is None:",
            "        return None",
            "    try:",
            "        assert len(thresholds) == 3",
            "        return (int(thresholds[0]), int(thresholds[1]), int(thresholds[2]))",
            "    except Exception:",
            "        raise ConfigError(",
            "            \"Value of `gc_threshold` must be a list of three integers if set\"",
            "        )",
            "",
            "",
            "def parse_listener_def(listener: Any) -> ListenerConfig:",
            "    \"\"\"parse a listener config from the config file\"\"\"",
            "    listener_type = listener[\"type\"]",
            "",
            "    port = listener.get(\"port\")",
            "    if not isinstance(port, int):",
            "        raise ConfigError(\"Listener configuration is lacking a valid 'port' option\")",
            "",
            "    tls = listener.get(\"tls\", False)",
            "",
            "    bind_addresses = listener.get(\"bind_addresses\", [])",
            "    bind_address = listener.get(\"bind_address\")",
            "    # if bind_address was specified, add it to the list of addresses",
            "    if bind_address:",
            "        bind_addresses.append(bind_address)",
            "",
            "    # if we still have an empty list of addresses, use the default list",
            "    if not bind_addresses:",
            "        if listener_type == \"metrics\":",
            "            # the metrics listener doesn't support IPv6",
            "            bind_addresses.append(\"0.0.0.0\")",
            "        else:",
            "            bind_addresses.extend(DEFAULT_BIND_ADDRESSES)",
            "",
            "    http_config = None",
            "    if listener_type == \"http\":",
            "        http_config = HttpListenerConfig(",
            "            x_forwarded=listener.get(\"x_forwarded\", False),",
            "            resources=[",
            "                HttpResourceConfig(**res) for res in listener.get(\"resources\", [])",
            "            ],",
            "            additional_resources=listener.get(\"additional_resources\", {}),",
            "            tag=listener.get(\"tag\"),",
            "        )",
            "",
            "    return ListenerConfig(port, bind_addresses, listener_type, tls, http_config)",
            "",
            "",
            "NO_MORE_WEB_CLIENT_WARNING = \"\"\"",
            "Synapse no longer includes a web client. To enable a web client, configure",
            "web_client_location. To remove this warning, remove 'webclient' from the 'listeners'",
            "configuration.",
            "\"\"\"",
            "",
            "",
            "def _warn_if_webclient_configured(listeners: Iterable[ListenerConfig]) -> None:",
            "    for listener in listeners:",
            "        if not listener.http_options:",
            "            continue",
            "        for res in listener.http_options.resources:",
            "            for name in res.names:",
            "                if name == \"webclient\":",
            "                    logger.warning(NO_MORE_WEB_CLIENT_WARNING)",
            "                    return"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "297": [
                "ServerConfig",
                "read_config"
            ],
            "298": [
                "ServerConfig",
                "read_config"
            ],
            "299": [
                "ServerConfig",
                "read_config"
            ],
            "300": [
                "ServerConfig",
                "read_config"
            ],
            "302": [
                "ServerConfig",
                "read_config"
            ],
            "304": [
                "ServerConfig",
                "read_config"
            ],
            "305": [
                "ServerConfig",
                "read_config"
            ],
            "306": [
                "ServerConfig",
                "read_config"
            ],
            "307": [
                "ServerConfig",
                "read_config"
            ],
            "315": [
                "ServerConfig",
                "read_config"
            ],
            "316": [
                "ServerConfig",
                "read_config"
            ],
            "317": [
                "ServerConfig",
                "read_config"
            ],
            "318": [
                "ServerConfig",
                "read_config"
            ],
            "319": [
                "ServerConfig",
                "read_config"
            ],
            "320": [
                "ServerConfig",
                "read_config"
            ],
            "322": [
                "ServerConfig",
                "read_config"
            ]
        },
        "addLocation": []
    }
}