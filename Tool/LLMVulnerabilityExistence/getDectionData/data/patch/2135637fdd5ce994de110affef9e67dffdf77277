{
    "django/contrib/auth/password_validation.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         ) % {'min_length': self.min_length}"
            },
            "1": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+def exceeds_maximum_length_ratio(password, max_similarity, value):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    Test that value is within a reasonable range of password."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    The following ratio calculations are based on testing SequenceMatcher like"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    this:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    for i in range(0,6):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+      print(10**i, SequenceMatcher(a='A', b='A'*(10**i)).quick_ratio())"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    which yields:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    1 1.0"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    10 0.18181818181818182"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+    100 0.019801980198019802"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    1000 0.001998001998001998"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    10000 0.00019998000199980003"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    100000 1.999980000199998e-05"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    This means a length_ratio of 10 should never yield a similarity higher than"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    0.2, for 100 this is down to 0.02 and for 1000 it is 0.002. This can be"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    calculated via 2 / length_ratio. As a result we avoid the potentially"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    expensive sequence matching."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    pwd_len = len(password)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    length_bound_similarity = max_similarity / 2 * pwd_len"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    value_len = len(value)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    return pwd_len >= 10 * value_len and value_len < length_bound_similarity"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " class UserAttributeSimilarityValidator:"
            },
            "34": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     \"\"\""
            },
            "35": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     Validate whether the password is sufficiently different from the user's"
            },
            "36": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     def __init__(self, user_attributes=DEFAULT_USER_ATTRIBUTES, max_similarity=0.7):"
            },
            "38": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         self.user_attributes = user_attributes"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        if max_similarity < 0.1:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            raise ValueError('max_similarity must be at least 0.1')"
            },
            "41": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         self.max_similarity = max_similarity"
            },
            "42": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     def validate(self, password, user=None):"
            },
            "44": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         if not user:"
            },
            "45": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             return"
            },
            "46": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        password = password.lower()"
            },
            "48": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         for attribute_name in self.user_attributes:"
            },
            "49": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             value = getattr(user, attribute_name, None)"
            },
            "50": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             if not value or not isinstance(value, str):"
            },
            "51": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "                 continue"
            },
            "52": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value_parts = re.split(r'\\W+', value) + [value]"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            value_lower = value.lower()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            value_parts = re.split(r'\\W+', value_lower) + [value_lower]"
            },
            "55": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "             for value_part in value_parts:"
            },
            "56": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if SequenceMatcher(a=password.lower(), b=value_part.lower()).quick_ratio() >= self.max_similarity:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+                if exceeds_maximum_length_ratio(password, self.max_similarity, value_part):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+                    continue"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                if SequenceMatcher(a=password, b=value_part).quick_ratio() >= self.max_similarity:"
            },
            "60": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                     try:"
            },
            "61": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                         verbose_name = str(user._meta.get_field(attribute_name).verbose_name)"
            },
            "62": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                     except FieldDoesNotExist:"
            }
        },
        "frontPatchFile": [
            "import functools",
            "import gzip",
            "import re",
            "from difflib import SequenceMatcher",
            "from pathlib import Path",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist, ImproperlyConfigured, ValidationError,",
            ")",
            "from django.utils.functional import lazy",
            "from django.utils.html import format_html, format_html_join",
            "from django.utils.module_loading import import_string",
            "from django.utils.translation import gettext as _, ngettext",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_default_password_validators():",
            "    return get_password_validators(settings.AUTH_PASSWORD_VALIDATORS)",
            "",
            "",
            "def get_password_validators(validator_config):",
            "    validators = []",
            "    for validator in validator_config:",
            "        try:",
            "            klass = import_string(validator['NAME'])",
            "        except ImportError:",
            "            msg = \"The module in NAME could not be imported: %s. Check your AUTH_PASSWORD_VALIDATORS setting.\"",
            "            raise ImproperlyConfigured(msg % validator['NAME'])",
            "        validators.append(klass(**validator.get('OPTIONS', {})))",
            "",
            "    return validators",
            "",
            "",
            "def validate_password(password, user=None, password_validators=None):",
            "    \"\"\"",
            "    Validate whether the password meets all validator requirements.",
            "",
            "    If the password is valid, return ``None``.",
            "    If the password is invalid, raise ValidationError with all error messages.",
            "    \"\"\"",
            "    errors = []",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        try:",
            "            validator.validate(password, user)",
            "        except ValidationError as error:",
            "            errors.append(error)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "",
            "def password_changed(password, user=None, password_validators=None):",
            "    \"\"\"",
            "    Inform all validators that have implemented a password_changed() method",
            "    that the password has been changed.",
            "    \"\"\"",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        password_changed = getattr(validator, 'password_changed', lambda *a: None)",
            "        password_changed(password, user)",
            "",
            "",
            "def password_validators_help_texts(password_validators=None):",
            "    \"\"\"",
            "    Return a list of all help texts of all configured validators.",
            "    \"\"\"",
            "    help_texts = []",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        help_texts.append(validator.get_help_text())",
            "    return help_texts",
            "",
            "",
            "def _password_validators_help_text_html(password_validators=None):",
            "    \"\"\"",
            "    Return an HTML string with all help texts of all configured validators",
            "    in an <ul>.",
            "    \"\"\"",
            "    help_texts = password_validators_help_texts(password_validators)",
            "    help_items = format_html_join('', '<li>{}</li>', ((help_text,) for help_text in help_texts))",
            "    return format_html('<ul>{}</ul>', help_items) if help_items else ''",
            "",
            "",
            "password_validators_help_text_html = lazy(_password_validators_help_text_html, str)",
            "",
            "",
            "class MinimumLengthValidator:",
            "    \"\"\"",
            "    Validate whether the password is of a minimum length.",
            "    \"\"\"",
            "    def __init__(self, min_length=8):",
            "        self.min_length = min_length",
            "",
            "    def validate(self, password, user=None):",
            "        if len(password) < self.min_length:",
            "            raise ValidationError(",
            "                ngettext(",
            "                    \"This password is too short. It must contain at least %(min_length)d character.\",",
            "                    \"This password is too short. It must contain at least %(min_length)d characters.\",",
            "                    self.min_length",
            "                ),",
            "                code='password_too_short',",
            "                params={'min_length': self.min_length},",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return ngettext(",
            "            \"Your password must contain at least %(min_length)d character.\",",
            "            \"Your password must contain at least %(min_length)d characters.\",",
            "            self.min_length",
            "        ) % {'min_length': self.min_length}",
            "",
            "",
            "class UserAttributeSimilarityValidator:",
            "    \"\"\"",
            "    Validate whether the password is sufficiently different from the user's",
            "    attributes.",
            "",
            "    If no specific attributes are provided, look at a sensible list of",
            "    defaults. Attributes that don't exist are ignored. Comparison is made to",
            "    not only the full attribute value, but also its components, so that, for",
            "    example, a password is validated against either part of an email address,",
            "    as well as the full address.",
            "    \"\"\"",
            "    DEFAULT_USER_ATTRIBUTES = ('username', 'first_name', 'last_name', 'email')",
            "",
            "    def __init__(self, user_attributes=DEFAULT_USER_ATTRIBUTES, max_similarity=0.7):",
            "        self.user_attributes = user_attributes",
            "        self.max_similarity = max_similarity",
            "",
            "    def validate(self, password, user=None):",
            "        if not user:",
            "            return",
            "",
            "        for attribute_name in self.user_attributes:",
            "            value = getattr(user, attribute_name, None)",
            "            if not value or not isinstance(value, str):",
            "                continue",
            "            value_parts = re.split(r'\\W+', value) + [value]",
            "            for value_part in value_parts:",
            "                if SequenceMatcher(a=password.lower(), b=value_part.lower()).quick_ratio() >= self.max_similarity:",
            "                    try:",
            "                        verbose_name = str(user._meta.get_field(attribute_name).verbose_name)",
            "                    except FieldDoesNotExist:",
            "                        verbose_name = attribute_name",
            "                    raise ValidationError(",
            "                        _(\"The password is too similar to the %(verbose_name)s.\"),",
            "                        code='password_too_similar',",
            "                        params={'verbose_name': verbose_name},",
            "                    )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be too similar to your other personal information.\")",
            "",
            "",
            "class CommonPasswordValidator:",
            "    \"\"\"",
            "    Validate whether the password is a common password.",
            "",
            "    The password is rejected if it occurs in a provided list of passwords,",
            "    which may be gzipped. The list Django ships with contains 20000 common",
            "    passwords (lowercased and deduplicated), created by Royce Williams:",
            "    https://gist.github.com/roycewilliams/281ce539915a947a23db17137d91aeb7",
            "    The password list must be lowercased to match the comparison in validate().",
            "    \"\"\"",
            "    DEFAULT_PASSWORD_LIST_PATH = Path(__file__).resolve().parent / 'common-passwords.txt.gz'",
            "",
            "    def __init__(self, password_list_path=DEFAULT_PASSWORD_LIST_PATH):",
            "        try:",
            "            with gzip.open(str(password_list_path)) as f:",
            "                common_passwords_lines = f.read().decode().splitlines()",
            "        except IOError:",
            "            with open(str(password_list_path)) as f:",
            "                common_passwords_lines = f.readlines()",
            "",
            "        self.passwords = {p.strip() for p in common_passwords_lines}",
            "",
            "    def validate(self, password, user=None):",
            "        if password.lower().strip() in self.passwords:",
            "            raise ValidationError(",
            "                _(\"This password is too common.\"),",
            "                code='password_too_common',",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be a commonly used password.\")",
            "",
            "",
            "class NumericPasswordValidator:",
            "    \"\"\"",
            "    Validate whether the password is alphanumeric.",
            "    \"\"\"",
            "    def validate(self, password, user=None):",
            "        if password.isdigit():",
            "            raise ValidationError(",
            "                _(\"This password is entirely numeric.\"),",
            "                code='password_entirely_numeric',",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be entirely numeric.\")"
        ],
        "afterPatchFile": [
            "import functools",
            "import gzip",
            "import re",
            "from difflib import SequenceMatcher",
            "from pathlib import Path",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist, ImproperlyConfigured, ValidationError,",
            ")",
            "from django.utils.functional import lazy",
            "from django.utils.html import format_html, format_html_join",
            "from django.utils.module_loading import import_string",
            "from django.utils.translation import gettext as _, ngettext",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def get_default_password_validators():",
            "    return get_password_validators(settings.AUTH_PASSWORD_VALIDATORS)",
            "",
            "",
            "def get_password_validators(validator_config):",
            "    validators = []",
            "    for validator in validator_config:",
            "        try:",
            "            klass = import_string(validator['NAME'])",
            "        except ImportError:",
            "            msg = \"The module in NAME could not be imported: %s. Check your AUTH_PASSWORD_VALIDATORS setting.\"",
            "            raise ImproperlyConfigured(msg % validator['NAME'])",
            "        validators.append(klass(**validator.get('OPTIONS', {})))",
            "",
            "    return validators",
            "",
            "",
            "def validate_password(password, user=None, password_validators=None):",
            "    \"\"\"",
            "    Validate whether the password meets all validator requirements.",
            "",
            "    If the password is valid, return ``None``.",
            "    If the password is invalid, raise ValidationError with all error messages.",
            "    \"\"\"",
            "    errors = []",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        try:",
            "            validator.validate(password, user)",
            "        except ValidationError as error:",
            "            errors.append(error)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "",
            "def password_changed(password, user=None, password_validators=None):",
            "    \"\"\"",
            "    Inform all validators that have implemented a password_changed() method",
            "    that the password has been changed.",
            "    \"\"\"",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        password_changed = getattr(validator, 'password_changed', lambda *a: None)",
            "        password_changed(password, user)",
            "",
            "",
            "def password_validators_help_texts(password_validators=None):",
            "    \"\"\"",
            "    Return a list of all help texts of all configured validators.",
            "    \"\"\"",
            "    help_texts = []",
            "    if password_validators is None:",
            "        password_validators = get_default_password_validators()",
            "    for validator in password_validators:",
            "        help_texts.append(validator.get_help_text())",
            "    return help_texts",
            "",
            "",
            "def _password_validators_help_text_html(password_validators=None):",
            "    \"\"\"",
            "    Return an HTML string with all help texts of all configured validators",
            "    in an <ul>.",
            "    \"\"\"",
            "    help_texts = password_validators_help_texts(password_validators)",
            "    help_items = format_html_join('', '<li>{}</li>', ((help_text,) for help_text in help_texts))",
            "    return format_html('<ul>{}</ul>', help_items) if help_items else ''",
            "",
            "",
            "password_validators_help_text_html = lazy(_password_validators_help_text_html, str)",
            "",
            "",
            "class MinimumLengthValidator:",
            "    \"\"\"",
            "    Validate whether the password is of a minimum length.",
            "    \"\"\"",
            "    def __init__(self, min_length=8):",
            "        self.min_length = min_length",
            "",
            "    def validate(self, password, user=None):",
            "        if len(password) < self.min_length:",
            "            raise ValidationError(",
            "                ngettext(",
            "                    \"This password is too short. It must contain at least %(min_length)d character.\",",
            "                    \"This password is too short. It must contain at least %(min_length)d characters.\",",
            "                    self.min_length",
            "                ),",
            "                code='password_too_short',",
            "                params={'min_length': self.min_length},",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return ngettext(",
            "            \"Your password must contain at least %(min_length)d character.\",",
            "            \"Your password must contain at least %(min_length)d characters.\",",
            "            self.min_length",
            "        ) % {'min_length': self.min_length}",
            "",
            "",
            "def exceeds_maximum_length_ratio(password, max_similarity, value):",
            "    \"\"\"",
            "    Test that value is within a reasonable range of password.",
            "",
            "    The following ratio calculations are based on testing SequenceMatcher like",
            "    this:",
            "",
            "    for i in range(0,6):",
            "      print(10**i, SequenceMatcher(a='A', b='A'*(10**i)).quick_ratio())",
            "",
            "    which yields:",
            "",
            "    1 1.0",
            "    10 0.18181818181818182",
            "    100 0.019801980198019802",
            "    1000 0.001998001998001998",
            "    10000 0.00019998000199980003",
            "    100000 1.999980000199998e-05",
            "",
            "    This means a length_ratio of 10 should never yield a similarity higher than",
            "    0.2, for 100 this is down to 0.02 and for 1000 it is 0.002. This can be",
            "    calculated via 2 / length_ratio. As a result we avoid the potentially",
            "    expensive sequence matching.",
            "    \"\"\"",
            "    pwd_len = len(password)",
            "    length_bound_similarity = max_similarity / 2 * pwd_len",
            "    value_len = len(value)",
            "    return pwd_len >= 10 * value_len and value_len < length_bound_similarity",
            "",
            "",
            "class UserAttributeSimilarityValidator:",
            "    \"\"\"",
            "    Validate whether the password is sufficiently different from the user's",
            "    attributes.",
            "",
            "    If no specific attributes are provided, look at a sensible list of",
            "    defaults. Attributes that don't exist are ignored. Comparison is made to",
            "    not only the full attribute value, but also its components, so that, for",
            "    example, a password is validated against either part of an email address,",
            "    as well as the full address.",
            "    \"\"\"",
            "    DEFAULT_USER_ATTRIBUTES = ('username', 'first_name', 'last_name', 'email')",
            "",
            "    def __init__(self, user_attributes=DEFAULT_USER_ATTRIBUTES, max_similarity=0.7):",
            "        self.user_attributes = user_attributes",
            "        if max_similarity < 0.1:",
            "            raise ValueError('max_similarity must be at least 0.1')",
            "        self.max_similarity = max_similarity",
            "",
            "    def validate(self, password, user=None):",
            "        if not user:",
            "            return",
            "",
            "        password = password.lower()",
            "        for attribute_name in self.user_attributes:",
            "            value = getattr(user, attribute_name, None)",
            "            if not value or not isinstance(value, str):",
            "                continue",
            "            value_lower = value.lower()",
            "            value_parts = re.split(r'\\W+', value_lower) + [value_lower]",
            "            for value_part in value_parts:",
            "                if exceeds_maximum_length_ratio(password, self.max_similarity, value_part):",
            "                    continue",
            "                if SequenceMatcher(a=password, b=value_part).quick_ratio() >= self.max_similarity:",
            "                    try:",
            "                        verbose_name = str(user._meta.get_field(attribute_name).verbose_name)",
            "                    except FieldDoesNotExist:",
            "                        verbose_name = attribute_name",
            "                    raise ValidationError(",
            "                        _(\"The password is too similar to the %(verbose_name)s.\"),",
            "                        code='password_too_similar',",
            "                        params={'verbose_name': verbose_name},",
            "                    )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be too similar to your other personal information.\")",
            "",
            "",
            "class CommonPasswordValidator:",
            "    \"\"\"",
            "    Validate whether the password is a common password.",
            "",
            "    The password is rejected if it occurs in a provided list of passwords,",
            "    which may be gzipped. The list Django ships with contains 20000 common",
            "    passwords (lowercased and deduplicated), created by Royce Williams:",
            "    https://gist.github.com/roycewilliams/281ce539915a947a23db17137d91aeb7",
            "    The password list must be lowercased to match the comparison in validate().",
            "    \"\"\"",
            "    DEFAULT_PASSWORD_LIST_PATH = Path(__file__).resolve().parent / 'common-passwords.txt.gz'",
            "",
            "    def __init__(self, password_list_path=DEFAULT_PASSWORD_LIST_PATH):",
            "        try:",
            "            with gzip.open(str(password_list_path)) as f:",
            "                common_passwords_lines = f.read().decode().splitlines()",
            "        except IOError:",
            "            with open(str(password_list_path)) as f:",
            "                common_passwords_lines = f.readlines()",
            "",
            "        self.passwords = {p.strip() for p in common_passwords_lines}",
            "",
            "    def validate(self, password, user=None):",
            "        if password.lower().strip() in self.passwords:",
            "            raise ValidationError(",
            "                _(\"This password is too common.\"),",
            "                code='password_too_common',",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be a commonly used password.\")",
            "",
            "",
            "class NumericPasswordValidator:",
            "    \"\"\"",
            "    Validate whether the password is alphanumeric.",
            "    \"\"\"",
            "    def validate(self, password, user=None):",
            "        if password.isdigit():",
            "            raise ValidationError(",
            "                _(\"This password is entirely numeric.\"),",
            "                code='password_entirely_numeric',",
            "            )",
            "",
            "    def get_help_text(self):",
            "        return _(\"Your password can't be entirely numeric.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "143": [
                "UserAttributeSimilarityValidator",
                "validate"
            ],
            "145": [
                "UserAttributeSimilarityValidator",
                "validate"
            ]
        },
        "addLocation": [
            "django.contrib.auth.password_validation.UserAttributeSimilarityValidator.validate",
            "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
        ]
    }
}