{
    "neutron/agent/linux/dhcp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1322,
                "afterPatchRowNumber": 1322,
                "PatchRowcode": "         elif not option.isdigit():"
            },
            "1": {
                "beforePatchRowNumber": 1323,
                "afterPatchRowNumber": 1323,
                "PatchRowcode": "             option = 'option:%s' % option"
            },
            "2": {
                "beforePatchRowNumber": 1324,
                "afterPatchRowNumber": 1324,
                "PatchRowcode": "         if extra_tag:"
            },
            "3": {
                "beforePatchRowNumber": 1325,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tags = ('tag:' + tag, extra_tag[:-1], '%s' % option)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1325,
                "PatchRowcode": "+            tags = ['tag:' + tag, extra_tag[:-1], '%s' % option]"
            },
            "5": {
                "beforePatchRowNumber": 1326,
                "afterPatchRowNumber": 1326,
                "PatchRowcode": "         else:"
            },
            "6": {
                "beforePatchRowNumber": 1327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            tags = ('tag:' + tag, '%s' % option)"
            },
            "7": {
                "beforePatchRowNumber": 1328,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return ','.join(tags + args)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1327,
                "PatchRowcode": "+            tags = ['tag:' + tag, '%s' % option]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1328,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1329,
                "PatchRowcode": "+        return ','.join(tags + [v.split(\"\\n\", 1)[0] for v in args])"
            },
            "11": {
                "beforePatchRowNumber": 1329,
                "afterPatchRowNumber": 1330,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 1330,
                "afterPatchRowNumber": 1331,
                "PatchRowcode": "     @staticmethod"
            },
            "13": {
                "beforePatchRowNumber": 1331,
                "afterPatchRowNumber": 1332,
                "PatchRowcode": "     def _convert_to_literal_addrs(ip_version, ips):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "import collections",
            "import copy",
            "import io",
            "import itertools",
            "import os",
            "import re",
            "import shutil",
            "import time",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import extra_dhcp_opt as edo_ext",
            "from neutron_lib import constants",
            "from neutron_lib import exceptions",
            "from neutron_lib.utils import file as file_utils",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import netutils",
            "from oslo_utils import uuidutils",
            "",
            "from neutron.agent.common import utils as agent_common_utils",
            "from neutron.agent.linux import external_process",
            "from neutron.agent.linux import ip_lib",
            "from neutron.agent.linux import iptables_manager",
            "from neutron.cmd import runtime_checks as checks",
            "from neutron.common import utils as common_utils",
            "from neutron.ipam import utils as ipam_utils",
            "from neutron.privileged.agent.linux import dhcp as priv_dhcp",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "DNS_PORT = 53",
            "WIN2k3_STATIC_DNS = 249",
            "NS_PREFIX = 'qdhcp-'",
            "DNSMASQ_SERVICE_NAME = 'dnsmasq'",
            "DHCP_RELEASE_TRIES = 3",
            "DHCP_RELEASE_TRIES_SLEEP = 0.3",
            "HOST_DHCPV6_TAG = 'tag:dhcpv6,'",
            "",
            "# this variable will be removed when neutron-lib is updated with this value",
            "DHCP_OPT_CLIENT_ID_NUM = 61",
            "",
            "",
            "def port_requires_dhcp_configuration(port):",
            "    if not getattr(port, 'device_owner', None):",
            "        # We can't check if port needs dhcp entry, so it will be better",
            "        # to create one",
            "        return True",
            "    # TODO(slaweq): define this list as a constant in neutron_lib.constants",
            "    # NOTE(slaweq): Not all port types which belongs e.g. to the routers can be",
            "    # excluded from that list. For some of them, like router interfaces used to",
            "    # plug subnet to the router should be configured in dnsmasq to provide DNS",
            "    # naming resolution. Otherwise it may slowdown e.g. traceroutes from the VM",
            "    return port.device_owner not in [",
            "        constants.DEVICE_OWNER_ROUTER_HA_INTF,",
            "        constants.DEVICE_OWNER_FLOATINGIP,",
            "        constants.DEVICE_OWNER_DHCP,",
            "        constants.DEVICE_OWNER_DISTRIBUTED]",
            "",
            "",
            "class DictModel(collections.abc.MutableMapping):",
            "    \"\"\"Convert dict into an object that provides attribute access to values.\"\"\"",
            "",
            "    __slots__ = ['_dictmodel_internal_storage']",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Convert dict values to DictModel values.\"\"\"",
            "        temp_dict = dict(*args)",
            "        self._dictmodel_internal_storage = {}",
            "",
            "        def needs_upgrade(item):",
            "            \"\"\"Check if `item` is a dict and needs to be changed to DictModel.",
            "            \"\"\"",
            "            return isinstance(item, dict) and not isinstance(item, DictModel)",
            "",
            "        def upgrade(item):",
            "            \"\"\"Upgrade item if it needs to be upgraded.\"\"\"",
            "            if needs_upgrade(item):",
            "                return DictModel(item)",
            "            else:",
            "                return item",
            "",
            "        for key, value in itertools.chain(temp_dict.items(), kwargs.items()):",
            "            if isinstance(value, (list, tuple)):",
            "                # Keep the same type but convert dicts to DictModels",
            "                self._dictmodel_internal_storage[key] = type(value)(",
            "                    (upgrade(item) for item in value)",
            "                )",
            "            elif needs_upgrade(value):",
            "                # Change dict instance values to DictModel instance values",
            "                self._dictmodel_internal_storage[key] = DictModel(value)",
            "            else:",
            "                self._dictmodel_internal_storage[key] = value",
            "",
            "    def __getattr__(self, name):",
            "        try:",
            "            if name == '_dictmodel_internal_storage':",
            "                return super(DictModel, self).__getattr__(name)",
            "            return self.__getitem__(name)",
            "        except KeyError as e:",
            "            raise AttributeError(e)",
            "",
            "    def __setattr__(self, name, value):",
            "        if name == '_dictmodel_internal_storage':",
            "            super(DictModel, self).__setattr__(name, value)",
            "        else:",
            "            self._dictmodel_internal_storage[name] = value",
            "",
            "    def __delattr__(self, name):",
            "        del self._dictmodel_internal_storage[name]",
            "",
            "    def __str__(self):",
            "        pairs = ['%s=%s' % (k, v) for k, v in",
            "                 self._dictmodel_internal_storage.items()]",
            "        return ', '.join(sorted(pairs))",
            "",
            "    def __getitem__(self, name):",
            "        return self._dictmodel_internal_storage[name]",
            "",
            "    def __setitem__(self, name, value):",
            "        self._dictmodel_internal_storage[name] = value",
            "",
            "    def __delitem__(self, name):",
            "        del self._dictmodel_internal_storage[name]",
            "",
            "    def __iter__(self):",
            "        return iter(self._dictmodel_internal_storage)",
            "",
            "    def __len__(self):",
            "        return len(self._dictmodel_internal_storage)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # pylint: disable=no-value-for-parameter",
            "        cls = self.__class__",
            "        result = cls.__new__(cls)",
            "        memo[id(self)] = result",
            "        result._dictmodel_internal_storage = copy.deepcopy(",
            "            self._dictmodel_internal_storage)",
            "        return result",
            "",
            "",
            "class NetModel(DictModel):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(NetModel, self).__init__(*args, **kwargs)",
            "",
            "        self._ns_name = \"%s%s\" % (NS_PREFIX, self.id)",
            "",
            "    @property",
            "    def namespace(self):",
            "        return self._ns_name",
            "",
            "",
            "class DhcpBase(object, metaclass=abc.ABCMeta):",
            "",
            "    def __init__(self, conf, network, process_monitor,",
            "                 version=None, plugin=None):",
            "        self.conf = conf",
            "        self.network = network",
            "        self.process_monitor = process_monitor",
            "        self.device_manager = DeviceManager(self.conf, plugin)",
            "        self.version = version",
            "",
            "    @abc.abstractmethod",
            "    def enable(self):",
            "        \"\"\"Enables DHCP for this network.\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def disable(self, retain_port=False, block=False):",
            "        \"\"\"Disable dhcp for this network.\"\"\"",
            "",
            "    def restart(self):",
            "        \"\"\"Restart the dhcp service for the network.\"\"\"",
            "        self.disable(retain_port=True, block=True)",
            "        self.enable()",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def active(self):",
            "        \"\"\"Boolean representing the running state of the DHCP server.\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def reload_allocations(self):",
            "        \"\"\"Force the DHCP server to reload the assignment database.\"\"\"",
            "",
            "    @classmethod",
            "    def existing_dhcp_networks(cls, conf):",
            "        \"\"\"Return a list of existing networks ids that we have configs for.\"\"\"",
            "",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def check_version(cls):",
            "        \"\"\"Execute version checks on DHCP server.\"\"\"",
            "",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def get_isolated_subnets(cls, network):",
            "        \"\"\"Returns a dict indicating whether or not a subnet is isolated\"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def should_enable_metadata(cls, conf, network):",
            "        \"\"\"True if the metadata-proxy should be enabled for the network.\"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class DhcpLocalProcess(DhcpBase, metaclass=abc.ABCMeta):",
            "    PORTS = []",
            "",
            "    def __init__(self, conf, network, process_monitor, version=None,",
            "                 plugin=None):",
            "        super(DhcpLocalProcess, self).__init__(conf, network, process_monitor,",
            "                                               version, plugin)",
            "        self.confs_dir = self.get_confs_dir(conf)",
            "        self.network_conf_dir = os.path.join(self.confs_dir, network.id)",
            "        fileutils.ensure_tree(self.network_conf_dir, mode=0o755)",
            "",
            "    @staticmethod",
            "    def get_confs_dir(conf):",
            "        return os.path.abspath(os.path.normpath(conf.dhcp_confs))",
            "",
            "    def get_conf_file_name(self, kind):",
            "        \"\"\"Returns the file name for a given kind of config file.\"\"\"",
            "        return os.path.join(self.network_conf_dir, kind)",
            "",
            "    def _remove_config_files(self):",
            "        shutil.rmtree(self.network_conf_dir, ignore_errors=True)",
            "",
            "    @staticmethod",
            "    def _get_all_subnets(network):",
            "        non_local_subnets = getattr(network, 'non_local_subnets', [])",
            "        return network.subnets + non_local_subnets",
            "",
            "    def _enable_dhcp(self):",
            "        \"\"\"check if there is a subnet within the network with dhcp enabled.\"\"\"",
            "        for subnet in self.network.subnets:",
            "            if subnet.enable_dhcp:",
            "                return True",
            "        return False",
            "",
            "    def enable(self):",
            "        \"\"\"Enables DHCP for this network by spawning a local process.\"\"\"",
            "        try:",
            "            common_utils.wait_until_true(self._enable, timeout=300)",
            "        except common_utils.WaitTimeout:",
            "            LOG.error(\"Failed to start DHCP process for network %s\",",
            "                      self.network.id)",
            "",
            "    def _enable(self):",
            "        try:",
            "            if self.active:",
            "                self.disable(retain_port=True, block=True)",
            "",
            "            if self._enable_dhcp():",
            "                fileutils.ensure_tree(self.network_conf_dir, mode=0o755)",
            "                interface_name = self.device_manager.setup(self.network)",
            "                self.interface_name = interface_name",
            "                self.spawn_process()",
            "            return True",
            "        except exceptions.ProcessExecutionError as error:",
            "            LOG.debug(\"Spawning DHCP process for network %s failed; \"",
            "                      \"Error: %s\", self.network.id, error)",
            "            return False",
            "",
            "    def _get_process_manager(self, cmd_callback=None):",
            "        return external_process.ProcessManager(",
            "            conf=self.conf,",
            "            uuid=self.network.id,",
            "            namespace=self.network.namespace,",
            "            service=DNSMASQ_SERVICE_NAME,",
            "            default_cmd_callback=cmd_callback,",
            "            pid_file=self.get_conf_file_name('pid'),",
            "            run_as_root=True)",
            "",
            "    def disable(self, retain_port=False, block=False):",
            "        \"\"\"Disable DHCP for this network by killing the local process.\"\"\"",
            "        self.process_monitor.unregister(self.network.id, DNSMASQ_SERVICE_NAME)",
            "        self._get_process_manager().disable()",
            "        if block:",
            "            common_utils.wait_until_true(lambda: not self.active)",
            "        if not retain_port:",
            "            self._destroy_namespace_and_port()",
            "            self._remove_config_files()",
            "",
            "    def _destroy_namespace_and_port(self):",
            "        try:",
            "            self.device_manager.destroy(self.network, self.interface_name)",
            "        except RuntimeError:",
            "            LOG.warning('Failed trying to delete interface: %s',",
            "                        self.interface_name)",
            "",
            "        try:",
            "            ip_lib.delete_network_namespace(self.network.namespace)",
            "        except RuntimeError:",
            "            LOG.warning('Failed trying to delete namespace: %s',",
            "                        self.network.namespace)",
            "",
            "    def _get_value_from_conf_file(self, kind, converter=None):",
            "        \"\"\"A helper function to read a value from one of the state files.\"\"\"",
            "        file_name = self.get_conf_file_name(kind)",
            "        try:",
            "            with open(file_name, 'r') as f:",
            "                return converter(f.read()) if converter else f.read()",
            "        except ValueError:",
            "            msg = \"Unable to convert value in %s\"",
            "        except IOError:",
            "            msg = \"Unable to access %s\"",
            "        LOG.debug(msg, file_name)",
            "        return None",
            "",
            "    @property",
            "    def interface_name(self):",
            "        return self._get_value_from_conf_file('interface')",
            "",
            "    @interface_name.setter",
            "    def interface_name(self, value):",
            "        interface_file_path = self.get_conf_file_name('interface')",
            "        file_utils.replace_file(interface_file_path, value)",
            "",
            "    def get_metadata_bind_interface(self, port):",
            "        return self.device_manager.get_interface_name(self.network, port)",
            "",
            "    @property",
            "    def active(self):",
            "        return self._get_process_manager().active",
            "",
            "    @abc.abstractmethod",
            "    def spawn_process(self):",
            "        pass",
            "",
            "",
            "class Dnsmasq(DhcpLocalProcess):",
            "    # The ports that need to be opened when security policies are active",
            "    # on the Neutron port used for DHCP.  These are provided as a convenience",
            "    # for users of this class.",
            "    PORTS = {constants.IP_VERSION_4:",
            "             [(constants.PROTO_NAME_UDP, DNS_PORT),",
            "              (constants.PROTO_NAME_TCP, DNS_PORT),",
            "              (constants.PROTO_NAME_UDP, constants.DHCP_RESPONSE_PORT)],",
            "             constants.IP_VERSION_6:",
            "             [(constants.PROTO_NAME_UDP, DNS_PORT),",
            "              (constants.PROTO_NAME_TCP, DNS_PORT),",
            "              (constants.PROTO_NAME_UDP, constants.DHCPV6_RESPONSE_PORT)],",
            "             }",
            "",
            "    _SUBNET_TAG_PREFIX = 'subnet-%s'",
            "    _PORT_TAG_PREFIX = 'port-%s'",
            "",
            "    _ID = 'id:'",
            "",
            "    _IS_DHCP_RELEASE6_SUPPORTED = None",
            "    _IS_HOST_TAG_SUPPORTED = None",
            "",
            "    @classmethod",
            "    def check_version(cls):",
            "        pass",
            "",
            "    @classmethod",
            "    def existing_dhcp_networks(cls, conf):",
            "        \"\"\"Return a list of existing networks ids that we have configs for.\"\"\"",
            "        confs_dir = cls.get_confs_dir(conf)",
            "        try:",
            "            return [",
            "                c for c in os.listdir(confs_dir)",
            "                if uuidutils.is_uuid_like(c)",
            "            ]",
            "        except OSError:",
            "            return []",
            "",
            "    def _build_cmdline_callback(self, pid_file):",
            "        # We ignore local resolv.conf if dns servers are specified",
            "        # or if local resolution is explicitly disabled.",
            "        _no_resolv = (",
            "            '--no-resolv' if self.conf.dnsmasq_dns_servers or",
            "            not self.conf.dnsmasq_local_resolv else '')",
            "        cmd = [",
            "            'dnsmasq',",
            "            '--no-hosts',",
            "            _no_resolv,",
            "            '--pid-file=%s' % pid_file,",
            "            '--dhcp-hostsfile=%s' % self.get_conf_file_name('host'),",
            "            '--addn-hosts=%s' % self.get_conf_file_name('addn_hosts'),",
            "            '--dhcp-optsfile=%s' % self.get_conf_file_name('opts'),",
            "            '--dhcp-leasefile=%s' % self.get_conf_file_name('leases'),",
            "            '--dhcp-match=set:ipxe,175',",
            "            '--dhcp-userclass=set:ipxe6,iPXE',",
            "            '--local-service',",
            "            '--bind-dynamic',",
            "        ]",
            "        if not self.device_manager.driver.bridged:",
            "            cmd += [",
            "                '--bridge-interface=%s,tap*' % self.interface_name,",
            "            ]",
            "",
            "        possible_leases = 0",
            "        for subnet in self._get_all_subnets(self.network):",
            "            mode = None",
            "            # if a subnet is specified to have dhcp disabled",
            "            if not subnet.enable_dhcp:",
            "                continue",
            "            if subnet.ip_version == 4:",
            "                mode = 'static'",
            "            else:",
            "                # Note(scollins) If the IPv6 attributes are not set, set it as",
            "                # static to preserve previous behavior",
            "                addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "                ra_mode = getattr(subnet, 'ipv6_ra_mode', None)",
            "                if (addr_mode in [constants.DHCPV6_STATEFUL,",
            "                                  constants.DHCPV6_STATELESS] or",
            "                        not addr_mode and not ra_mode):",
            "                    mode = 'static'",
            "",
            "            cidr = netaddr.IPNetwork(subnet.cidr)",
            "",
            "            if self.conf.dhcp_lease_duration == -1:",
            "                lease = 'infinite'",
            "            else:",
            "                lease = '%ss' % self.conf.dhcp_lease_duration",
            "",
            "            # mode is optional and is not set - skip it",
            "            if mode:",
            "                if subnet.ip_version == 4:",
            "                    cmd.append('--dhcp-range=%s%s,%s,%s,%s,%s' %",
            "                               ('set:', self._SUBNET_TAG_PREFIX % subnet.id,",
            "                                cidr.network, mode, cidr.netmask, lease))",
            "                else:",
            "                    if cidr.prefixlen < 64:",
            "                        LOG.debug('Ignoring subnet %(subnet)s, CIDR has '",
            "                                  'prefix length < 64: %(cidr)s',",
            "                                  {'subnet': subnet.id, 'cidr': cidr})",
            "                        continue",
            "                    cmd.append('--dhcp-range=%s%s,%s,%s,%d,%s' %",
            "                               ('set:', self._SUBNET_TAG_PREFIX % subnet.id,",
            "                                cidr.network, mode,",
            "                                cidr.prefixlen, lease))",
            "                possible_leases += cidr.size",
            "",
            "        mtu = getattr(self.network, 'mtu', 0)",
            "        # Do not advertise unknown mtu",
            "        if mtu > 0:",
            "            cmd.append('--dhcp-option-force=option:mtu,%d' % mtu)",
            "",
            "        # Cap the limit because creating lots of subnets can inflate",
            "        # this possible lease cap.",
            "        cmd.append('--dhcp-lease-max=%d' %",
            "                   min(possible_leases, self.conf.dnsmasq_lease_max))",
            "",
            "        if self.conf.dhcp_renewal_time > 0:",
            "            cmd.append('--dhcp-option-force=option:T1,%ds' %",
            "                       self.conf.dhcp_renewal_time)",
            "",
            "        if self.conf.dhcp_rebinding_time > 0:",
            "            cmd.append('--dhcp-option-force=option:T2,%ds' %",
            "                       self.conf.dhcp_rebinding_time)",
            "",
            "        cmd.append('--conf-file=%s' %",
            "                   (self.conf.dnsmasq_config_file.strip() or '/dev/null'))",
            "        for server in self.conf.dnsmasq_dns_servers:",
            "            cmd.append('--server=%s' % server)",
            "",
            "        if self.conf.dns_domain:",
            "            cmd.append('--domain=%s' % self.conf.dns_domain)",
            "",
            "        if self.conf.dhcp_broadcast_reply:",
            "            cmd.append('--dhcp-broadcast')",
            "",
            "        if self.conf.dnsmasq_base_log_dir:",
            "            log_dir = os.path.join(",
            "                self.conf.dnsmasq_base_log_dir,",
            "                self.network.id)",
            "            try:",
            "                if not os.path.exists(log_dir):",
            "                    os.makedirs(log_dir)",
            "            except OSError:",
            "                LOG.error('Error while create dnsmasq log dir: %s', log_dir)",
            "            else:",
            "                log_filename = os.path.join(log_dir, 'dhcp_dns_log')",
            "                cmd.append('--log-queries')",
            "                cmd.append('--log-dhcp')",
            "                cmd.append('--log-facility=%s' % log_filename)",
            "",
            "        return cmd",
            "",
            "    def spawn_process(self):",
            "        \"\"\"Spawn the process, if it's not spawned already.\"\"\"",
            "        # we only need to generate the lease file the first time dnsmasq starts",
            "        # rather than on every reload since dnsmasq will keep the file current",
            "        self._output_init_lease_file()",
            "        self._spawn_or_reload_process(reload_with_HUP=False)",
            "",
            "    def _spawn_or_reload_process(self, reload_with_HUP):",
            "        \"\"\"Spawns or reloads a Dnsmasq process for the network.",
            "",
            "        When reload_with_HUP is True, dnsmasq receives a HUP signal,",
            "        or it's reloaded if the process is not running.",
            "        \"\"\"",
            "",
            "        self._output_config_files()",
            "",
            "        pm = self._get_process_manager(",
            "            cmd_callback=self._build_cmdline_callback)",
            "",
            "        pm.enable(reload_cfg=reload_with_HUP, ensure_active=True)",
            "",
            "        self.process_monitor.register(uuid=self.network.id,",
            "                                      service_name=DNSMASQ_SERVICE_NAME,",
            "                                      monitored_process=pm)",
            "",
            "    def _is_dhcp_release6_supported(self):",
            "        if self._IS_DHCP_RELEASE6_SUPPORTED is None:",
            "            self._IS_DHCP_RELEASE6_SUPPORTED = (",
            "                priv_dhcp.dhcp_release6_supported())",
            "            if not self._IS_DHCP_RELEASE6_SUPPORTED:",
            "                LOG.warning(\"dhcp_release6 is not present on this system, \"",
            "                            \"will not call it again.\")",
            "        return self._IS_DHCP_RELEASE6_SUPPORTED",
            "",
            "    def _is_dnsmasq_host_tag_supported(self):",
            "        if self._IS_HOST_TAG_SUPPORTED is None:",
            "            self._IS_HOST_TAG_SUPPORTED = checks.dnsmasq_host_tag_support()",
            "",
            "        return self._IS_HOST_TAG_SUPPORTED",
            "",
            "    def _release_lease(self, mac_address, ip, ip_version, client_id=None,",
            "                       server_id=None, iaid=None):",
            "        \"\"\"Release a DHCP lease.\"\"\"",
            "        try:",
            "            if ip_version == constants.IP_VERSION_6:",
            "                if not self._is_dhcp_release6_supported():",
            "                    return",
            "",
            "                params = {'interface_name': self.interface_name,",
            "                          'ip_address': ip, 'client_id': client_id,",
            "                          'server_id': server_id, 'iaid': iaid,",
            "                          'namespace': self.network.namespace}",
            "                priv_dhcp.dhcp_release6(**params)",
            "            else:",
            "                params = {'interface_name': self.interface_name,",
            "                          'ip_address': ip, 'mac_address': mac_address,",
            "                          'client_id': client_id,",
            "                          'namespace': self.network.namespace}",
            "                priv_dhcp.dhcp_release(**params)",
            "        except (processutils.ProcessExecutionError, OSError) as e:",
            "            # when failed to release single lease there's",
            "            # no need to propagate error further",
            "            LOG.warning('DHCP release failed for params %(params)s. '",
            "                        'Reason: %(e)s', {'params': params, 'e': e})",
            "",
            "    def _output_config_files(self):",
            "        self._output_hosts_file()",
            "        self._output_addn_hosts_file()",
            "        self._output_opts_file()",
            "",
            "    def reload_allocations(self):",
            "        \"\"\"Rebuild the dnsmasq config and signal the dnsmasq to reload.\"\"\"",
            "",
            "        # If all subnets turn off dhcp, kill the process.",
            "        if not self._enable_dhcp():",
            "            self.disable()",
            "            LOG.debug('Killing dnsmasq for network since all subnets have '",
            "                      'turned off DHCP: %s', self.network.id)",
            "            return",
            "        if not self.interface_name:",
            "            # we land here if above has been called and we receive port",
            "            # delete notifications for the network",
            "            LOG.debug('Agent does not have an interface on this network '",
            "                      'anymore, skipping reload: %s', self.network.id)",
            "            return",
            "",
            "        self._release_unused_leases()",
            "        self._spawn_or_reload_process(reload_with_HUP=True)",
            "        LOG.debug('Reloading allocations for network: %s', self.network.id)",
            "        self.device_manager.update(self.network, self.interface_name)",
            "",
            "    def _sort_fixed_ips_for_dnsmasq(self, fixed_ips, v6_nets):",
            "        \"\"\"Sort fixed_ips so that stateless IPv6 subnets appear first.",
            "",
            "        For example, If a port with v6 extra_dhcp_opts is on a network with",
            "        IPv4 and IPv6 stateless subnets. Then dhcp host file will have",
            "        below 2 entries for same MAC,",
            "",
            "        fa:16:3e:8f:9d:65,30.0.0.5,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        (entry for IPv4 dhcp)",
            "        fa:16:3e:8f:9d:65,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        (entry for stateless IPv6 for v6 options)",
            "",
            "        dnsmasq internal details for processing host file entries",
            "        1) dnsmasq reads the host file from EOF.",
            "        2) So it first picks up stateless IPv6 entry,",
            "           fa:16:3e:8f:9d:65,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        3) But dnsmasq doesn't have sufficient checks to skip this entry and",
            "           pick next entry, to process dhcp IPv4 request.",
            "        4) So dnsmasq uses this entry to process dhcp IPv4 request.",
            "        5) As there is no ip in this entry, dnsmasq logs \"no address available\"",
            "           and fails to send DHCPOFFER message.",
            "",
            "        As we rely on internal details of dnsmasq to understand and fix the",
            "        issue, Ihar sent a mail to dnsmasq-discuss mailing list",
            "        http://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2015q2/",
            "        009650.html",
            "",
            "        So if we reverse the order of writing entries in host file,",
            "        so that entry for stateless IPv6 comes first,",
            "        then dnsmasq can correctly fetch the IPv4 address.",
            "        \"\"\"",
            "        return sorted(",
            "            fixed_ips,",
            "            key=lambda fip: ((fip.subnet_id in v6_nets) and (",
            "                v6_nets[fip.subnet_id].ipv6_address_mode == (",
            "                    constants.DHCPV6_STATELESS))),",
            "            reverse=True)",
            "",
            "    def _merge_alloc_addr6_list(self, fixed_ips, v6_nets):",
            "        \"\"\"Merge fixed_ips to ipv6 addr lists",
            "",
            "        If a port have multiple IPv6 addresses in the same subnet, merge the",
            "        into one entry listing all the addresess, creating a single dhcp-host",
            "        entry with the list of addresses defined allow dnsmasq to make all",
            "        addresses available as requests for leases arrive.",
            "",
            "        See dnsmasq-discuss mailing list: http://lists.thekelleys.org.uk/",
            "        pipermail/dnsmasq-discuss/2020q1/013743.html",
            "",
            "        \"\"\"",
            "        by_subnet = {}",
            "        NewFip = collections.namedtuple('NewFip', 'subnet_id ip_address')",
            "        merged = []",
            "",
            "        for fip in fixed_ips:",
            "            if (fip.subnet_id in v6_nets and",
            "                    v6_nets[fip.subnet_id].ipv6_address_mode == (",
            "                            constants.DHCPV6_STATEFUL)):",
            "                if fip.subnet_id not in by_subnet:",
            "                    by_subnet.update({fip.subnet_id: []})",
            "                by_subnet[fip.subnet_id].append(fip.ip_address)",
            "            else:",
            "                merged.append(fip)",
            "",
            "        for subnet_id in by_subnet:",
            "            addr6_list = ','.join([self._format_address_for_dnsmasq(ip)",
            "                                   for ip in by_subnet[subnet_id]])",
            "            merged.append(NewFip(subnet_id=subnet_id,",
            "                                 ip_address=addr6_list))",
            "",
            "        return merged",
            "",
            "    def _get_dns_assignment(self, ip_address, dns_assignment):",
            "        \"\"\"Get DNS assignment hostname and fqdn",
            "",
            "        In dnsmasq it is not possible to configure two dhcp-host",
            "        entries mapped to a single client mac address with IP",
            "        addresses in the same subnet. When recieving a requst",
            "        dnsmasq will match on the first entry in it's config,",
            "        and lease that address. The second entry will never be",
            "        used.",
            "",
            "        For IPv6 it is possible to add multiple IPv6 addresses",
            "        to a single dhcp-host entry by placing a list of addresses",
            "        in brackets, i.e [addr1][addr2][...]. See dnsmasq mailing",
            "        list: http://lists.thekelleys.org.uk/pipermail/",
            "        dnsmasq-discuss/2020q1/013671.html. Since we cannot have",
            "        two hostnames in the dhcp-host entry this method picks the",
            "        first hostname and fqdn it find's matching one of the IP's",
            "        in the fixed-ips in dns_assignment or the hostname is",
            "        generated based on the first fixed-ip.",
            "",
            "        :param ip_address: IP address or a list of IPv6 addresses",
            "        :param dns_ip_map: DNS IP Mapping",
            "        :param dns_assignment: DNS assignments",
            "        :return: hostname, fqdn",
            "        \"\"\"",
            "        hostname, fqdn = None, None",
            "        ip_addresses = ip_address.replace('[', '').split(']')",
            "",
            "        if dns_assignment:",
            "            dns_ip_map = {d.ip_address: d for d in dns_assignment}",
            "            for addr in ip_addresses:",
            "                # If dns_name attribute is supported by ports API, return the",
            "                # dns_assignment generated by the Neutron server. Otherwise,",
            "                # generate hostname and fqdn locally (previous behaviour)",
            "                if addr in dns_ip_map:",
            "                    hostname = dns_ip_map[addr].hostname",
            "                    fqdn = dns_ip_map[addr].fqdn",
            "                    break",
            "",
            "        if hostname is None:",
            "            hostname = ('host-%s' %",
            "                        ip_addresses[0].replace('.', '-').replace(':', '-'))",
            "            fqdn = hostname",
            "            if self.conf.dns_domain:",
            "                fqdn = '%s.%s' % (fqdn, self.conf.dns_domain)",
            "",
            "        return hostname, fqdn",
            "",
            "    def _iter_hosts(self, merge_addr6_list=False):",
            "        \"\"\"Iterate over hosts.",
            "",
            "        For each host on the network we yield a tuple containing:",
            "        (",
            "            port,  # a DictModel instance representing the port.",
            "            alloc,  # a DictModel instance of the allocated ip and subnet.",
            "                    # if alloc is None, it means there is no need to allocate",
            "                    # an IPv6 address because of stateless DHCPv6 network.",
            "            host_name,  # Host name.",
            "            name,  # Canonical hostname in the format 'hostname[.domain]'.",
            "            no_dhcp,  # A flag indicating that the address doesn't need a DHCP",
            "                      # IP address.",
            "            no_opts,  # A flag indication that options shouldn't be written",
            "            tag,    # A dhcp-host tag to add to the configuration if supported",
            "        )",
            "        \"\"\"",
            "        v6_nets = dict((subnet.id, subnet) for subnet in",
            "                       self._get_all_subnets(self.network)",
            "                       if subnet.ip_version == 6)",
            "",
            "        for port in self.network.ports:",
            "            if not port_requires_dhcp_configuration(port):",
            "                continue",
            "",
            "            fixed_ips = self._sort_fixed_ips_for_dnsmasq(port.fixed_ips,",
            "                                                         v6_nets)",
            "            # TODO(hjensas): Drop this conditional and option once distros",
            "            #  generally have dnsmasq supporting addr6 list and range.",
            "            if self.conf.dnsmasq_enable_addr6_list and merge_addr6_list:",
            "                fixed_ips = self._merge_alloc_addr6_list(fixed_ips, v6_nets)",
            "            # Confirm whether Neutron server supports dns_name attribute in the",
            "            # ports API",
            "            dns_assignment = getattr(port, 'dns_assignment', None)",
            "            for alloc in fixed_ips:",
            "                no_dhcp = False",
            "                no_opts = False",
            "                tag = ''",
            "                if alloc.subnet_id in v6_nets:",
            "                    addr_mode = v6_nets[alloc.subnet_id].ipv6_address_mode",
            "                    no_dhcp = addr_mode in (constants.IPV6_SLAAC,",
            "                                            constants.DHCPV6_STATELESS)",
            "                    if self._is_dnsmasq_host_tag_supported():",
            "                        tag = HOST_DHCPV6_TAG",
            "                    # we don't setup anything for SLAAC. It doesn't make sense",
            "                    # to provide options for a client that won't use DHCP",
            "                    no_opts = addr_mode == constants.IPV6_SLAAC",
            "",
            "                hostname, fqdn = self._get_dns_assignment(alloc.ip_address,",
            "                                                          dns_assignment)",
            "",
            "                yield (port, alloc, hostname, fqdn, no_dhcp, no_opts, tag)",
            "",
            "    def _get_port_extra_dhcp_opts(self, port):",
            "        return getattr(port, edo_ext.EXTRADHCPOPTS, False)",
            "",
            "    def _output_init_lease_file(self):",
            "        \"\"\"Write a fake lease file to bootstrap dnsmasq.",
            "",
            "        The generated file is passed to the --dhcp-leasefile option of dnsmasq.",
            "        This is used as a bootstrapping mechanism to avoid NAKing active leases",
            "        when a dhcp server is scheduled to another agent. Using a leasefile",
            "        will also prevent dnsmasq from NAKing or ignoring renewals after a",
            "        restart.",
            "",
            "        Format is as follows:",
            "        epoch-timestamp mac_addr ip_addr hostname client-ID",
            "        \"\"\"",
            "        filename = self.get_conf_file_name('leases')",
            "        buf = io.StringIO()",
            "",
            "        LOG.debug('Building initial lease file: %s', filename)",
            "        # we make up a lease time for the database entry",
            "        if self.conf.dhcp_lease_duration == -1:",
            "            # Even with an infinite lease, a client may choose to renew a",
            "            # previous lease on reboot or interface bounce so we should have",
            "            # an entry for it.",
            "            # Dnsmasq timestamp format for an infinite lease is 0.",
            "            timestamp = 0",
            "        else:",
            "            timestamp = int(time.time()) + self.conf.dhcp_lease_duration",
            "        dhcpv4_enabled_subnet_ids = [",
            "            s.id for s in self._get_all_subnets(self.network)",
            "            if s.enable_dhcp and s.ip_version == constants.IP_VERSION_4]",
            "        dhcpv6_enabled_subnet_ids = [",
            "            s.id for s in self._get_all_subnets(self.network)",
            "            if s.enable_dhcp and s.ip_version == constants.IP_VERSION_6]",
            "",
            "        existing_ipv6_leases = {}",
            "        if os.path.isfile(filename):",
            "            # The IPv6 leases can't be generated as their IAID is unknown. To",
            "            # not loose active leases, read the existing leases and add them to",
            "            # the generated file.",
            "            LOG.debug('Reading IPv6 leases from existing lease file.')",
            "            with open(filename) as leasefile:",
            "                for line in leasefile:",
            "                    if line.startswith('duid '):",
            "                        # Keep the DUID",
            "                        buf.write(line)",
            "                        continue",
            "                    try:",
            "                        ts, mac, ip, host, iaid = line.split(' ')",
            "                    except ValueError:",
            "                        # not the correct format for a lease, skip this line",
            "                        continue",
            "",
            "                    if netaddr.valid_ipv6(ip):",
            "                        existing_ipv6_leases[netaddr.IPAddress(ip)] = line",
            "",
            "        for host_tuple in self._iter_hosts():",
            "            port, alloc, hostname, name, no_dhcp, no_opts, tag = host_tuple",
            "",
            "            if no_dhcp:",
            "                continue",
            "",
            "            if alloc.subnet_id in dhcpv4_enabled_subnet_ids:",
            "                # all that matters is the mac address and IP. the hostname and",
            "                # client ID will be overwritten on the next renewal.",
            "                buf.write('%s %s %s * *\\n' %",
            "                          (timestamp, port.mac_address, alloc.ip_address))",
            "            elif (alloc.subnet_id in dhcpv6_enabled_subnet_ids and",
            "                  netaddr.IPAddress(alloc.ip_address) in existing_ipv6_leases):",
            "                # Keep the existing IPv6 lease if the port still exists and is",
            "                # still configured for DHCPv6",
            "                buf.write(",
            "                    existing_ipv6_leases[netaddr.IPAddress(alloc.ip_address)]",
            "                )",
            "",
            "        contents = buf.getvalue()",
            "        file_utils.replace_file(filename, contents)",
            "        LOG.debug('Done building initial lease file %s with contents:\\n%s',",
            "                  filename, contents)",
            "        return filename",
            "",
            "    @staticmethod",
            "    def _format_address_for_dnsmasq(address):",
            "        # (dzyu) Check if it is legal ipv6 address, if so, need wrap",
            "        # it with '[]' to let dnsmasq to distinguish MAC address from",
            "        # IPv6 address.",
            "        if netaddr.valid_ipv6(address):",
            "            return '[%s]' % address",
            "        return address",
            "",
            "    def _output_hosts_file(self):",
            "        \"\"\"Writes a dnsmasq compatible dhcp hosts file.",
            "",
            "        The generated file is sent to the --dhcp-hostsfile option of dnsmasq,",
            "        and lists the hosts on the network which should receive a dhcp lease.",
            "        Each line in this file is in the form::",
            "",
            "            'mac_address,FQDN,ip_address'",
            "",
            "        IMPORTANT NOTE: a dnsmasq instance does not resolve hosts defined in",
            "        this file if it did not give a lease to a host listed in it (e.g.:",
            "        multiple dnsmasq instances on the same network if this network is on",
            "        multiple network nodes). This file is only defining hosts which",
            "        should receive a dhcp lease, the hosts resolution in itself is",
            "        defined by the `_output_addn_hosts_file` method.",
            "        \"\"\"",
            "        buf = io.StringIO()",
            "        filename = self.get_conf_file_name('host')",
            "",
            "        LOG.debug('Building host file: %s', filename)",
            "        dhcp_enabled_subnet_ids = [s.id for s in",
            "                                   self._get_all_subnets(self.network)",
            "                                   if s.enable_dhcp]",
            "        # NOTE(ihrachyshka): the loop should not log anything inside it, to",
            "        # avoid potential performance drop when lots of hosts are dumped",
            "        for host_tuple in self._iter_hosts(merge_addr6_list=True):",
            "            port, alloc, hostname, name, no_dhcp, no_opts, tag = host_tuple",
            "            if no_dhcp:",
            "                if not no_opts and self._get_port_extra_dhcp_opts(port):",
            "                    buf.write('%s,%s%s%s\\n' % (",
            "                        port.mac_address, tag,",
            "                        'set:', self._PORT_TAG_PREFIX % port.id))",
            "                continue",
            "",
            "            # don't write ip address which belongs to a dhcp disabled subnet.",
            "            if alloc.subnet_id not in dhcp_enabled_subnet_ids:",
            "                continue",
            "",
            "            ip_address = self._format_address_for_dnsmasq(alloc.ip_address)",
            "",
            "            if self._get_port_extra_dhcp_opts(port):",
            "                client_id = self._get_client_id(port)",
            "                if client_id and len(port.extra_dhcp_opts) > 1:",
            "                    buf.write('%s,%s%s%s,%s,%s,%s%s\\n' %",
            "                              (port.mac_address, tag, self._ID, client_id,",
            "                               name, ip_address, 'set:',",
            "                               self._PORT_TAG_PREFIX % port.id))",
            "                elif client_id and len(port.extra_dhcp_opts) == 1:",
            "                    buf.write('%s,%s%s%s,%s,%s\\n' %",
            "                              (port.mac_address, tag, self._ID, client_id,",
            "                               name, ip_address))",
            "                else:",
            "                    buf.write('%s,%s%s,%s,%s%s\\n' %",
            "                              (port.mac_address, tag, name, ip_address,",
            "                               'set:', self._PORT_TAG_PREFIX % port.id))",
            "            else:",
            "                buf.write('%s,%s%s,%s\\n' %",
            "                          (port.mac_address, tag, name, ip_address))",
            "",
            "        file_utils.replace_file(filename, buf.getvalue())",
            "        LOG.debug('Done building host file %s', filename)",
            "        return filename",
            "",
            "    def _get_client_id(self, port):",
            "        if self._get_port_extra_dhcp_opts(port):",
            "            for opt in port.extra_dhcp_opts:",
            "                if opt.opt_name in (edo_ext.DHCP_OPT_CLIENT_ID,",
            "                                    DHCP_OPT_CLIENT_ID_NUM,",
            "                                    str(DHCP_OPT_CLIENT_ID_NUM)):",
            "                    return opt.opt_value",
            "",
            "    @staticmethod",
            "    def _parse_ip_addresses(ip_list):",
            "        ip_list = [ip.strip('[]') for ip in ip_list]",
            "        return [ip for ip in ip_list if netutils.is_valid_ip(ip)]",
            "",
            "    def _read_hosts_file_leases(self, filename):",
            "        leases = set()",
            "        try:",
            "            with open(filename) as f:",
            "                for line in f.readlines():",
            "                    host = line.strip().split(',')",
            "                    mac = host[0]",
            "                    client_id = None",
            "                    if host[1].startswith('set:'):",
            "                        continue",
            "                    if host[1].startswith(self._ID):",
            "                        ips = self._parse_ip_addresses(host[3:])",
            "                        client_id = host[1][len(self._ID):]",
            "                    elif host[1].startswith('tag:'):",
            "                        ips = self._parse_ip_addresses(host[3:])",
            "                    else:",
            "                        ips = self._parse_ip_addresses(host[2:])",
            "                    for ip in ips:",
            "                        leases.add((ip, mac, client_id))",
            "        except (OSError, IOError):",
            "            LOG.debug('Error while reading hosts file %s', filename)",
            "        return leases",
            "",
            "    def _read_leases_file_leases(self, filename):",
            "        \"\"\"Read dnsmasq dhcp leases file",
            "",
            "        Read information from leases file, which is needed to pass to",
            "        dhcp_release6 command line utility if some of these leases are not",
            "        needed anymore",
            "",
            "        each line in dnsmasq leases file is one of the following",
            "          * duid entry: duid server_duid",
            "          There MUST be single duid entry per file",
            "          * ipv4 entry: space separated list",
            "            - The expiration time (seconds since unix epoch) or duration",
            "              (if dnsmasq is compiled with HAVE_BROKEN_RTC) of the lease.",
            "              0 means infinite.",
            "            - The link address, in format XX-YY:YY:YY[...], where XX is the ARP",
            "              hardware type.  \"XX-\" may be omitted for Ethernet.",
            "            - The IPv4 address",
            "            - The hostname (sent by the client or assigned by dnsmasq)",
            "              or '*' for none.",
            "            - The client identifier (colon-separated hex bytes)",
            "              or '*' for none.",
            "",
            "          *  ipv6 entry: space separated list",
            "            - The expiration time or duration",
            "            - The IAID as a Big Endian decimal number, prefixed by T for",
            "              IA_TAs (temporary addresses).",
            "            - The IPv6 address",
            "            - The hostname or '*'",
            "            - The client DUID (colon-separated hex bytes) or '*' if unknown",
            "",
            "        original discussion is in dnsmasq mailing list",
            "        http://lists.thekelleys.org.uk/pipermail/\\",
            "        dnsmasq-discuss/2016q2/010595.html",
            "",
            "        :param filename: leases file",
            "        :return: dict, keys are IP(v6) addresses, values are dicts containing",
            "                iaid, client_id and server_id",
            "        \"\"\"",
            "        leases = {}",
            "        server_id = None",
            "        if os.path.exists(filename):",
            "            with open(filename) as f:",
            "                for line in f.readlines():",
            "                    if line.startswith('duid'):",
            "                        if not server_id:",
            "                            server_id = line.strip().split()[1]",
            "                        else:",
            "                            LOG.warning('Multiple DUID entries in %s '",
            "                                        'lease file, dnsmasq is possibly '",
            "                                        'not functioning properly',",
            "                                        filename)",
            "                        continue",
            "                    parts = line.strip().split()",
            "                    if len(parts) != 5:",
            "                        LOG.warning('Invalid lease entry %s found in %s '",
            "                                    'lease file, ignoring', parts, filename)",
            "                        continue",
            "                    (iaid, ip, client_id) = parts[1], parts[2], parts[4]",
            "                    ip = ip.strip('[]')",
            "                    leases[ip] = {'iaid': iaid,",
            "                                  'client_id': client_id,",
            "                                  'server_id': server_id",
            "                                  }",
            "        return leases",
            "",
            "    def _release_unused_leases(self):",
            "        filename = self.get_conf_file_name('host')",
            "        old_leases = self._read_hosts_file_leases(filename)",
            "        leases_filename = self.get_conf_file_name('leases')",
            "        cur_leases = self._read_leases_file_leases(leases_filename)",
            "        if not cur_leases:",
            "            return",
            "",
            "        v4_leases = set()",
            "        for (k, v) in cur_leases.items():",
            "            # IPv4 leases have a MAC, IPv6 ones do not, so we must ignore",
            "            if netaddr.IPAddress(k).version == constants.IP_VERSION_4:",
            "                # treat '*' as None, see note in _read_leases_file_leases()",
            "                client_id = v['client_id']",
            "                if client_id == '*':",
            "                    client_id = None",
            "                v4_leases.add((k, v['iaid'], client_id))",
            "",
            "        new_leases = set()",
            "        for port in self.network.ports:",
            "            client_id = self._get_client_id(port)",
            "            for alloc in port.fixed_ips:",
            "                new_leases.add((alloc.ip_address, port.mac_address, client_id))",
            "",
            "        # If an entry is in the leases or host file(s), but doesn't have",
            "        # a fixed IP on a corresponding neutron port, consider it stale.",
            "        entries_to_release = (v4_leases | old_leases) - new_leases",
            "        if not entries_to_release:",
            "            return",
            "",
            "        # If the VM advertises a client ID in its lease, but its not set in",
            "        # the port's Extra DHCP Opts, the lease will not be filtered above.",
            "        # Release the lease only if client ID is set in port DB and a mismatch",
            "        # Otherwise the lease is released when other ports are deleted/updated",
            "        entries_with_no_client_id = set()",
            "        for ip, mac, client_id in entries_to_release:",
            "            if client_id:",
            "                entry_no_client_id = (ip, mac, None)",
            "                if (entry_no_client_id in old_leases and",
            "                        entry_no_client_id in new_leases):",
            "                    entries_with_no_client_id.add((ip, mac, client_id))",
            "        entries_to_release -= entries_with_no_client_id",
            "",
            "        # Try DHCP_RELEASE_TRIES times to release a lease, re-reading the",
            "        # file each time to see if it's still there.  We loop +1 times to",
            "        # check the lease file one last time before logging any remaining",
            "        # entries.",
            "        for i in range(DHCP_RELEASE_TRIES + 1):",
            "            entries_not_present = set()",
            "            for ip, mac, client_id in entries_to_release:",
            "                try:",
            "                    entry = cur_leases[ip]",
            "                except KeyError:",
            "                    entries_not_present.add((ip, mac, client_id))",
            "                    continue",
            "                # if not the final loop, try and release",
            "                if i < DHCP_RELEASE_TRIES:",
            "                    ip_version = netaddr.IPAddress(ip).version",
            "                    if ip_version == constants.IP_VERSION_6:",
            "                        client_id = entry['client_id']",
            "                    self._release_lease(mac, ip, ip_version, client_id,",
            "                                        entry['server_id'], entry['iaid'])",
            "",
            "            # Remove elements that were not in the current leases file,",
            "            # no need to look for them again, and see if we're done.",
            "            entries_to_release -= entries_not_present",
            "            if not entries_to_release:",
            "                break",
            "",
            "            if i < DHCP_RELEASE_TRIES:",
            "                time.sleep(DHCP_RELEASE_TRIES_SLEEP)",
            "                cur_leases = self._read_leases_file_leases(leases_filename)",
            "                if not cur_leases:",
            "                    break",
            "        else:",
            "            LOG.warning(\"Could not release DHCP leases for these IP \"",
            "                        \"addresses after %d tries: %s\",",
            "                        DHCP_RELEASE_TRIES,",
            "                        ', '.join(ip for ip, m, c in entries_to_release))",
            "",
            "    def _output_addn_hosts_file(self):",
            "        \"\"\"Writes a dnsmasq compatible additional hosts file.",
            "",
            "        The generated file is sent to the --addn-hosts option of dnsmasq,",
            "        and lists the hosts on the network which should be resolved even if",
            "        the dnsmasq instance did not give a lease to the host (see the",
            "        `_output_hosts_file` method).",
            "        Each line in this file is in the same form as a standard /etc/hosts",
            "        file.",
            "        \"\"\"",
            "        buf = io.StringIO()",
            "        for host_tuple in self._iter_hosts():",
            "            port, alloc, hostname, fqdn, no_dhcp, no_opts, tag = host_tuple",
            "            # It is compulsory to write the `fqdn` before the `hostname` in",
            "            # order to obtain it in PTR responses.",
            "            if alloc:",
            "                buf.write('%s\\t%s %s\\n' % (alloc.ip_address, fqdn, hostname))",
            "        addn_hosts = self.get_conf_file_name('addn_hosts')",
            "        file_utils.replace_file(addn_hosts, buf.getvalue())",
            "        return addn_hosts",
            "",
            "    def _output_opts_file(self):",
            "        \"\"\"Write a dnsmasq compatible options file.\"\"\"",
            "        options, subnet_index_map = self._generate_opts_per_subnet()",
            "        options += self._generate_opts_per_port(subnet_index_map)",
            "",
            "        name = self.get_conf_file_name('opts')",
            "        file_utils.replace_file(name, '\\n'.join(options))",
            "        return name",
            "",
            "    def _generate_opts_per_subnet(self):",
            "        options = []",
            "        subnets_without_nameservers = set()",
            "        if self.conf.enable_isolated_metadata or self.conf.force_metadata:",
            "            subnet_to_interface_ip = self._make_subnet_interface_ip_map()",
            "        isolated_subnets = self.get_isolated_subnets(self.network)",
            "        for subnet in self._get_all_subnets(self.network):",
            "            addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "            segment_id = getattr(subnet, 'segment_id', None)",
            "            if (not subnet.enable_dhcp or",
            "                (subnet.ip_version == 6 and",
            "                 addr_mode == constants.IPV6_SLAAC)):",
            "                continue",
            "            if subnet.dns_nameservers:",
            "                if ((subnet.ip_version == 4 and",
            "                     subnet.dns_nameservers == ['0.0.0.0']) or",
            "                    (subnet.ip_version == 6 and",
            "                     subnet.dns_nameservers == ['::'])):",
            "                    # Special case: Do not announce DNS servers",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'dns-server'))",
            "                else:",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'dns-server', ','.join(",
            "                                Dnsmasq._convert_to_literal_addrs(",
            "                                    subnet.ip_version,",
            "                                    subnet.dns_nameservers))))",
            "            else:",
            "                # use the dnsmasq ip as nameservers only if there is no",
            "                # dns-server submitted by the server",
            "                # Here is something to check still",
            "                subnets_without_nameservers.add(subnet.id)",
            "",
            "            if self.conf.dns_domain and subnet.ip_version == 6:",
            "                # This should be change also",
            "                options.append(",
            "                    self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        \"domain-search\", ''.join(self.conf.dns_domain)))",
            "",
            "            gateway = subnet.gateway_ip",
            "            host_routes = []",
            "            for hr in subnet.host_routes:",
            "                if hr.destination == constants.IPv4_ANY:",
            "                    if not gateway:",
            "                        gateway = hr.nexthop",
            "                else:",
            "                    host_routes.append(\"%s,%s\" % (hr.destination, hr.nexthop))",
            "",
            "            # Add host routes for isolated network segments",
            "",
            "            if ((self.conf.force_metadata or",
            "                 (isolated_subnets[subnet.id] and",
            "                     self.conf.enable_isolated_metadata)) and",
            "                    subnet.ip_version == 4):",
            "                subnet_dhcp_ip = subnet_to_interface_ip.get(subnet.id)",
            "                if subnet_dhcp_ip:",
            "                    host_routes.append(",
            "                        '%s,%s' % (constants.METADATA_CIDR, subnet_dhcp_ip)",
            "                    )",
            "            elif not isolated_subnets[subnet.id] and gateway:",
            "                host_routes.append(",
            "                    '%s,%s' % (constants.METADATA_CIDR, gateway)",
            "                )",
            "",
            "            if subnet.ip_version == 4:",
            "                for s in self._get_all_subnets(self.network):",
            "                    sub_segment_id = getattr(s, 'segment_id', None)",
            "                    if (s.ip_version == 4 and",
            "                            s.cidr != subnet.cidr and",
            "                            sub_segment_id == segment_id):",
            "                        host_routes.insert(0, \"%s,0.0.0.0\" % s.cidr)",
            "",
            "                if host_routes:",
            "                    if gateway:",
            "                        host_routes.append(\"%s,%s\" % (constants.IPv4_ANY,",
            "                                                      gateway))",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'classless-static-route',",
            "                            ','.join(host_routes)))",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            WIN2k3_STATIC_DNS,",
            "                            ','.join(host_routes)))",
            "",
            "                if gateway:",
            "                    options.append(self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        'router', gateway))",
            "                else:",
            "                    options.append(self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        'router'))",
            "        return options, subnets_without_nameservers",
            "",
            "    def _generate_opts_per_port(self, subnets_without_nameservers):",
            "        options = []",
            "        dhcp_ips = collections.defaultdict(list)",
            "        for port in self.network.ports:",
            "            if self._get_port_extra_dhcp_opts(port):",
            "                port_ip_versions = set(",
            "                    [netaddr.IPAddress(ip.ip_address).version",
            "                     for ip in port.fixed_ips])",
            "                for opt in port.extra_dhcp_opts:",
            "                    if opt.opt_name in (edo_ext.DHCP_OPT_CLIENT_ID,",
            "                                        DHCP_OPT_CLIENT_ID_NUM,",
            "                                        str(DHCP_OPT_CLIENT_ID_NUM)):",
            "                        continue",
            "                    opt_ip_version = opt.ip_version",
            "                    if opt_ip_version in port_ip_versions:",
            "                        options.append(",
            "                            self._format_option(",
            "                                opt_ip_version,",
            "                                self._PORT_TAG_PREFIX % port.id,",
            "                                opt.opt_name, opt.opt_value))",
            "                    else:",
            "                        LOG.info(\"Cannot apply dhcp option %(opt)s \"",
            "                                 \"because it's ip_version %(version)d \"",
            "                                 \"is not in port's address IP versions\",",
            "                                 {'opt': opt.opt_name,",
            "                                  'version': opt_ip_version})",
            "",
            "            # provides all dnsmasq ip as dns-server if there is more than",
            "            # one dnsmasq for a subnet and there is no dns-server submitted",
            "            # by the server",
            "            if port.device_owner == constants.DEVICE_OWNER_DHCP:",
            "                for ip in port.fixed_ips:",
            "                    if ip.subnet_id not in subnets_without_nameservers:",
            "                        continue",
            "                    dhcp_ips[ip.subnet_id].append(ip.ip_address)",
            "",
            "        for subnet_id, ips in dhcp_ips.items():",
            "            for ip_version in (4, 6):",
            "                vx_ips = [ip for ip in ips",
            "                          if netaddr.IPAddress(ip).version == ip_version]",
            "                if len(vx_ips) > 1:",
            "                    options.append(",
            "                        self._format_option(",
            "                            ip_version, self._SUBNET_TAG_PREFIX % subnet_id,",
            "                            'dns-server',",
            "                            ','.join(",
            "                                Dnsmasq._convert_to_literal_addrs(ip_version,",
            "                                                                  vx_ips))))",
            "        return options",
            "",
            "    def _make_subnet_interface_ip_map(self):",
            "        subnet_lookup = dict(",
            "            (netaddr.IPNetwork(subnet.cidr), subnet.id)",
            "            for subnet in self.network.subnets",
            "        )",
            "",
            "        retval = {}",
            "",
            "        for addr in ip_lib.get_devices_with_ip(self.network.namespace,",
            "                                               name=self.interface_name):",
            "            ip_net = netaddr.IPNetwork(addr['cidr'])",
            "",
            "            if ip_net in subnet_lookup:",
            "                retval[subnet_lookup[ip_net]] = addr['cidr'].split('/')[0]",
            "",
            "        return retval",
            "",
            "    def _format_option(self, ip_version, tag, option, *args):",
            "        \"\"\"Format DHCP option by option name or code.\"\"\"",
            "        option = str(option)",
            "        pattern = \"(tag:(.*),)?(.*)$\"",
            "        matches = re.match(pattern, option)",
            "        extra_tag = matches.groups()[0]",
            "        option = matches.groups()[2]",
            "",
            "        # NOTE(TheJulia): prepending option6 to any DHCPv6 option is",
            "        # indicated as required in the dnsmasq man page for version 2.79.",
            "        # Testing reveals that the man page is correct, option is not",
            "        # honored if not in the format \"option6:$NUM\".  For IPv4 we",
            "        # only apply if the option is non-numeric.",
            "        if ip_version == constants.IP_VERSION_6:",
            "            option = 'option6:%s' % option",
            "        elif not option.isdigit():",
            "            option = 'option:%s' % option",
            "        if extra_tag:",
            "            tags = ('tag:' + tag, extra_tag[:-1], '%s' % option)",
            "        else:",
            "            tags = ('tag:' + tag, '%s' % option)",
            "        return ','.join(tags + args)",
            "",
            "    @staticmethod",
            "    def _convert_to_literal_addrs(ip_version, ips):",
            "        if ip_version == 4:",
            "            return ips",
            "        return ['[' + ip + ']' for ip in ips]",
            "",
            "    @classmethod",
            "    def get_isolated_subnets(cls, network):",
            "        \"\"\"Returns a dict indicating whether or not a subnet is isolated",
            "",
            "        A subnet is considered non-isolated if there is a port connected to",
            "        the subnet, and the port's ip address matches that of the subnet's",
            "        gateway. The port must be owned by a neutron router.",
            "        \"\"\"",
            "        isolated_subnets = collections.defaultdict(lambda: True)",
            "        all_subnets = cls._get_all_subnets(network)",
            "        subnets = dict((subnet.id, subnet) for subnet in all_subnets)",
            "",
            "        for port in network.ports:",
            "            if port.device_owner not in constants.ROUTER_INTERFACE_OWNERS:",
            "                continue",
            "            for alloc in port.fixed_ips:",
            "                if (alloc.subnet_id in subnets and",
            "                        subnets[alloc.subnet_id].gateway_ip ==",
            "                        alloc.ip_address):",
            "                    isolated_subnets[alloc.subnet_id] = False",
            "",
            "        return isolated_subnets",
            "",
            "    @staticmethod",
            "    def has_metadata_subnet(subnets):",
            "        \"\"\"Check if the subnets has a metadata subnet.\"\"\"",
            "        meta_cidr = netaddr.IPNetwork(constants.METADATA_V4_SUBNET)",
            "        if any(netaddr.IPNetwork(s.cidr) in meta_cidr",
            "               for s in subnets):",
            "            return True",
            "        return False",
            "",
            "    @classmethod",
            "    def should_enable_metadata(cls, conf, network):",
            "        \"\"\"Determine whether the metadata proxy is needed for a network",
            "",
            "        This method returns True for truly isolated networks (ie: not attached",
            "        to a router) when enable_isolated_metadata is True, or for all the",
            "        networks when the force_metadata flags is True.",
            "",
            "        This method also returns True when enable_metadata_network is True,",
            "        and the network passed as a parameter has a subnet in the link-local",
            "        CIDR, thus characterizing it as a \"metadata\" network. The metadata",
            "        network is used by solutions which do not leverage the l3 agent for",
            "        providing access to the metadata service via logical routers built",
            "        with 3rd party backends.",
            "        \"\"\"",
            "        all_subnets = cls._get_all_subnets(network)",
            "        dhcp_subnets = [s for s in all_subnets if s.enable_dhcp]",
            "        if not dhcp_subnets:",
            "            return False",
            "",
            "        if conf.force_metadata:",
            "            return True",
            "",
            "        if not conf.enable_isolated_metadata:",
            "            return False",
            "",
            "        if (conf.enable_metadata_network and",
            "                cls.has_metadata_subnet(all_subnets)):",
            "            return True",
            "",
            "        isolated_subnets = cls.get_isolated_subnets(network)",
            "        return any(isolated_subnets[s.id] for s in dhcp_subnets)",
            "",
            "",
            "class DeviceManager(object):",
            "",
            "    def __init__(self, conf, plugin):",
            "        self.conf = conf",
            "        self.plugin = plugin",
            "        self.driver = agent_common_utils.load_interface_driver(",
            "            conf,",
            "            get_networks_callback=self.plugin.get_networks)",
            "",
            "    def get_interface_name(self, network, port):",
            "        \"\"\"Return interface(device) name for use by the DHCP process.\"\"\"",
            "        return self.driver.get_device_name(port)",
            "",
            "    def get_device_id(self, network):",
            "        \"\"\"Return a unique DHCP device ID for this host on the network.\"\"\"",
            "        # There could be more than one dhcp server per network, so create",
            "        # a device id that combines host and network ids",
            "        return common_utils.get_dhcp_agent_device_id(network.id,",
            "                                                     self.conf.host)",
            "",
            "    def _set_default_route_ip_version(self, network, device_name, ip_version):",
            "        device = ip_lib.IPDevice(device_name, namespace=network.namespace)",
            "        gateway = device.route.get_gateway(ip_version=ip_version)",
            "        if gateway:",
            "            gateway = gateway.get('gateway')",
            "",
            "        for subnet in network.subnets:",
            "            skip_subnet = (",
            "                subnet.ip_version != ip_version or",
            "                not subnet.enable_dhcp or",
            "                subnet.gateway_ip is None)",
            "",
            "            if skip_subnet:",
            "                continue",
            "",
            "            if subnet.ip_version == constants.IP_VERSION_6:",
            "                # This is duplicating some of the API checks already done,",
            "                # but some of the functional tests call directly",
            "                prefixlen = netaddr.IPNetwork(subnet.cidr).prefixlen",
            "                if prefixlen == 0 or prefixlen > 126:",
            "                    continue",
            "                modes = [constants.IPV6_SLAAC, constants.DHCPV6_STATELESS]",
            "                addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "                ra_mode = getattr(subnet, 'ipv6_ra_mode', None)",
            "                if (prefixlen != 64 and",
            "                        (addr_mode in modes or ra_mode in modes)):",
            "                    continue",
            "",
            "            if gateway != subnet.gateway_ip:",
            "                LOG.debug('Setting IPv%(version)s gateway for dhcp netns '",
            "                          'on net %(n)s to %(ip)s',",
            "                          {'n': network.id, 'ip': subnet.gateway_ip,",
            "                           'version': ip_version})",
            "",
            "                # Check for and remove the on-link route for the old",
            "                # gateway being replaced, if it is outside the subnet",
            "                is_old_gateway_not_in_subnet = (gateway and",
            "                                                not ipam_utils.check_subnet_ip(",
            "                                                        subnet.cidr, gateway))",
            "                if is_old_gateway_not_in_subnet:",
            "                    onlink = device.route.list_onlink_routes(ip_version)",
            "                    existing_onlink_routes = set(r['cidr'] for r in onlink)",
            "                    if gateway in existing_onlink_routes:",
            "                        device.route.delete_route(gateway, scope='link')",
            "",
            "                is_new_gateway_not_in_subnet = (subnet.gateway_ip and",
            "                                                not ipam_utils.check_subnet_ip(",
            "                                                        subnet.cidr,",
            "                                                        subnet.gateway_ip))",
            "                if is_new_gateway_not_in_subnet:",
            "                    device.route.add_route(subnet.gateway_ip, scope='link')",
            "                device.route.add_gateway(subnet.gateway_ip)",
            "",
            "            return",
            "",
            "        # No subnets on the network have a valid gateway.  Clean it up to avoid",
            "        # confusion from seeing an invalid gateway here.",
            "        if gateway is not None:",
            "            LOG.debug('Removing IPv%(version)s gateway for dhcp netns on '",
            "                      'net %(n)s',",
            "                      {'n': network.id, 'version': ip_version})",
            "",
            "            device.route.delete_gateway(gateway)",
            "",
            "    def _set_default_route(self, network, device_name):",
            "        \"\"\"Sets the default gateway for this dhcp namespace.",
            "",
            "        This method is idempotent and will only adjust the route if adjusting",
            "        it would change it from what it already is.  This makes it safe to call",
            "        and avoids unnecessary perturbation of the system.",
            "        \"\"\"",
            "        for ip_version in (constants.IP_VERSION_4, constants.IP_VERSION_6):",
            "            self._set_default_route_ip_version(network, device_name,",
            "                                               ip_version)",
            "",
            "    def _setup_existing_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Set up the existing DHCP port, if there is one.\"\"\"",
            "",
            "        # To avoid pylint thinking that port might be undefined after",
            "        # the following loop...",
            "        port = None",
            "",
            "        # Look for an existing DHCP port for this network.",
            "        for port in network.ports:",
            "            port_device_id = getattr(port, 'device_id', None)",
            "            if port_device_id == device_id:",
            "                # If using gateway IPs on this port, we can skip the",
            "                # following code, whose purpose is just to review and",
            "                # update the Neutron-allocated IP addresses for the",
            "                # port.",
            "                if self.driver.use_gateway_ips:",
            "                    return port",
            "                # Otherwise break out, as we now have the DHCP port",
            "                # whose subnets and addresses we need to review.",
            "                break",
            "        else:",
            "            return None",
            "",
            "        # Compare what the subnets should be against what is already",
            "        # on the port.",
            "        dhcp_enabled_subnet_ids = set(dhcp_subnets)",
            "        port_subnet_ids = set(ip.subnet_id for ip in port.fixed_ips)",
            "",
            "        # If those differ, we need to call update.",
            "        if dhcp_enabled_subnet_ids != port_subnet_ids:",
            "            # Collect the subnets and fixed IPs that the port already",
            "            # has, for subnets that are still in the DHCP-enabled set.",
            "            wanted_fixed_ips = []",
            "            for fixed_ip in port.fixed_ips:",
            "                if fixed_ip.subnet_id in dhcp_enabled_subnet_ids:",
            "                    wanted_fixed_ips.append(",
            "                        {'subnet_id': fixed_ip.subnet_id,",
            "                         'ip_address': fixed_ip.ip_address})",
            "",
            "            # Add subnet IDs for new DHCP-enabled subnets.",
            "            wanted_fixed_ips.extend(",
            "                dict(subnet_id=s)",
            "                for s in dhcp_enabled_subnet_ids - port_subnet_ids)",
            "",
            "            # Update the port to have the calculated subnets and fixed",
            "            # IPs.  The Neutron server will allocate a fresh IP for",
            "            # each subnet that doesn't already have one.",
            "            port = self.plugin.update_dhcp_port(",
            "                port.id,",
            "                {'port': {'network_id': network.id,",
            "                          'fixed_ips': wanted_fixed_ips}})",
            "            if not port:",
            "                raise exceptions.Conflict()",
            "",
            "        return port",
            "",
            "    def _setup_reserved_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Setup the reserved DHCP port, if there is one.\"\"\"",
            "        LOG.debug('DHCP port %(device_id)s on network %(network_id)s'",
            "                  ' does not yet exist. Checking for a reserved port.',",
            "                  {'device_id': device_id, 'network_id': network.id})",
            "        for port in network.ports:",
            "            port_device_id = getattr(port, 'device_id', None)",
            "            if port_device_id == constants.DEVICE_ID_RESERVED_DHCP_PORT:",
            "                port = self.plugin.update_dhcp_port(",
            "                    port.id, {'port': {'network_id': network.id,",
            "                                       'device_id': device_id}})",
            "                if port:",
            "                    return port",
            "",
            "    def _setup_new_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Create and set up new DHCP port for the specified network.\"\"\"",
            "        LOG.debug('DHCP port %(device_id)s on network %(network_id)s'",
            "                  ' does not yet exist. Creating new one.',",
            "                  {'device_id': device_id, 'network_id': network.id})",
            "",
            "        # Make a list of the subnets that need a unique IP address for",
            "        # this DHCP port.",
            "        if self.driver.use_gateway_ips:",
            "            unique_ip_subnets = []",
            "        else:",
            "            unique_ip_subnets = [dict(subnet_id=s) for s in dhcp_subnets]",
            "",
            "        port_dict = dict(",
            "            name='',",
            "            admin_state_up=True,",
            "            device_id=device_id,",
            "            network_id=network.id,",
            "            tenant_id=network.tenant_id,",
            "            fixed_ips=unique_ip_subnets)",
            "        return self.plugin.create_dhcp_port({'port': port_dict})",
            "",
            "    def _check_dhcp_port_subnet(self, dhcp_port, dhcp_subnets, network):",
            "        \"\"\"Check if DHCP port IPs are in the range of the DHCP subnets",
            "",
            "        FIXME(kevinbenton): ensure we have the IPs we actually need.",
            "        can be removed once bug/1627480 is fixed",
            "        \"\"\"",
            "        if self.driver.use_gateway_ips:",
            "            return",
            "",
            "        expected = set(dhcp_subnets)",
            "        actual = {fip.subnet_id for fip in dhcp_port.fixed_ips}",
            "        missing = expected - actual",
            "        if not missing:",
            "            return",
            "",
            "        LOG.debug('Requested DHCP port with IPs on subnets %(expected)s '",
            "                  'but only got IPs on subnets %(actual)s.',",
            "                  {'expected': expected, 'actual': actual})",
            "        updated_dhcp_port = self.plugin.get_dhcp_port(dhcp_port.id)",
            "        actual = {fip.subnet_id for fip in updated_dhcp_port.fixed_ips}",
            "        missing = expected - actual",
            "        if missing:",
            "            raise exceptions.SubnetMismatchForPort(",
            "                port_id=updated_dhcp_port.id, subnet_id=list(missing)[0])",
            "",
            "        self._update_dhcp_port(network, updated_dhcp_port)",
            "        LOG.debug('Previous DHCP port information: %(dhcp_port)s. Updated '",
            "                  'DHCP port information: %(updated_dhcp_port)s.',",
            "                  {'dhcp_port': dhcp_port,",
            "                   'updated_dhcp_port': updated_dhcp_port})",
            "",
            "    def setup_dhcp_port(self, network):",
            "        \"\"\"Create/update DHCP port for the host if needed and return port.\"\"\"",
            "",
            "        # The ID that the DHCP port will have (or already has).",
            "        device_id = self.get_device_id(network)",
            "",
            "        # Get the set of DHCP-enabled local subnets on this network.",
            "        dhcp_subnets = {subnet.id: subnet for subnet in network.subnets",
            "                        if subnet.enable_dhcp}",
            "",
            "        # There are 3 cases: either the DHCP port already exists (but",
            "        # might need to be updated for a changed set of subnets); or",
            "        # some other code has already prepared a 'reserved' DHCP port,",
            "        # and we just need to adopt that; or we need to create a new",
            "        # DHCP port.  Try each of those in turn until we have a DHCP",
            "        # port.",
            "        for setup_method in (self._setup_existing_dhcp_port,",
            "                             self._setup_reserved_dhcp_port,",
            "                             self._setup_new_dhcp_port):",
            "            dhcp_port = setup_method(network, device_id, dhcp_subnets)",
            "            if dhcp_port:",
            "                break",
            "        else:",
            "            raise exceptions.Conflict()",
            "",
            "        self._check_dhcp_port_subnet(dhcp_port, dhcp_subnets, network)",
            "",
            "        # Convert subnet_id to subnet dict",
            "        fixed_ips = [dict(subnet_id=fixed_ip.subnet_id,",
            "                          ip_address=fixed_ip.ip_address,",
            "                          subnet=dhcp_subnets[fixed_ip.subnet_id])",
            "                     for fixed_ip in dhcp_port.fixed_ips",
            "                     # we don't care about any ips on subnets irrelevant",
            "                     # to us (e.g. auto ipv6 addresses)",
            "                     if fixed_ip.subnet_id in dhcp_subnets]",
            "",
            "        ips = [DictModel(item) if isinstance(item, dict) else item",
            "               for item in fixed_ips]",
            "        dhcp_port.fixed_ips = ips",
            "",
            "        return dhcp_port",
            "",
            "    def _update_dhcp_port(self, network, port):",
            "        for index in range(len(network.ports)):",
            "            if network.ports[index].id == port.id:",
            "                network.ports[index] = port",
            "                break",
            "        else:",
            "            network.ports.append(port)",
            "",
            "    def _cleanup_stale_devices(self, network, dhcp_port):",
            "        \"\"\"Unplug any devices found in the namespace except for dhcp_port.\"\"\"",
            "        LOG.debug(\"Cleaning stale devices for network %s\", network.id)",
            "        skip_dev_name = (self.driver.get_device_name(dhcp_port)",
            "                         if dhcp_port else None)",
            "        ns_ip = ip_lib.IPWrapper(namespace=network.namespace)",
            "        if not ns_ip.netns.exists(network.namespace):",
            "            return",
            "        for d in ns_ip.get_devices():",
            "            # delete all devices except current active DHCP port device",
            "            if d.name != skip_dev_name:",
            "                LOG.debug(\"Found stale device %s, deleting\", d.name)",
            "                try:",
            "                    self.unplug(d.name, network)",
            "                except Exception:",
            "                    LOG.exception(\"Exception during stale \"",
            "                                  \"dhcp device cleanup\")",
            "",
            "    def plug(self, network, port, interface_name):",
            "        \"\"\"Plug device settings for the network's DHCP on this host.\"\"\"",
            "        self.driver.plug(network.id,",
            "                         port.id,",
            "                         interface_name,",
            "                         port.mac_address,",
            "                         namespace=network.namespace,",
            "                         mtu=network.get('mtu'))",
            "",
            "    def setup(self, network):",
            "        \"\"\"Create and initialize a device for network's DHCP on this host.\"\"\"",
            "        try:",
            "            port = self.setup_dhcp_port(network)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                # clear everything out so we don't leave dangling interfaces",
            "                # if setup never succeeds in the future.",
            "                self._cleanup_stale_devices(network, dhcp_port=None)",
            "        self._update_dhcp_port(network, port)",
            "        interface_name = self.get_interface_name(network, port)",
            "",
            "        # Disable acceptance of RAs in the namespace so we don't",
            "        # auto-configure an IPv6 address since we explicitly configure",
            "        # them on the device.  This must be done before any interfaces",
            "        # are plugged since it could receive an RA by the time",
            "        # plug() returns, so we have to create the namespace first.",
            "        # It must also be done in the case there is an existing IPv6",
            "        # address here created via SLAAC, since it will be deleted",
            "        # and added back statically in the call to init_l3() below.",
            "        if network.namespace:",
            "            ip_lib.IPWrapper().ensure_namespace(network.namespace)",
            "            ip_lib.set_ip_nonlocal_bind_for_namespace(network.namespace, 1,",
            "                                                      root_namespace=True)",
            "        if netutils.is_ipv6_enabled():",
            "            self.driver.configure_ipv6_ra(network.namespace, 'default',",
            "                                          constants.ACCEPT_RA_DISABLED)",
            "",
            "        if ip_lib.ensure_device_is_ready(interface_name,",
            "                                         namespace=network.namespace):",
            "            LOG.debug('Reusing existing device: %s.', interface_name)",
            "            # force mtu on the port for in case it was changed for the network",
            "            mtu = getattr(network, 'mtu', 0)",
            "            if mtu:",
            "                self.driver.set_mtu(interface_name, mtu,",
            "                                    namespace=network.namespace)",
            "        else:",
            "            try:",
            "                self.plug(network, port, interface_name)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception('Unable to plug DHCP port for '",
            "                                  'network %s. Releasing port.',",
            "                                  network.id)",
            "                    # We should unplug the interface in bridge side.",
            "                    self.unplug(interface_name, network)",
            "                    self.plugin.release_dhcp_port(network.id, port.device_id)",
            "",
            "            self.fill_dhcp_udp_checksums(namespace=network.namespace)",
            "        ip_cidrs = []",
            "        for fixed_ip in port.fixed_ips:",
            "            subnet = fixed_ip.subnet",
            "            net = netaddr.IPNetwork(subnet.cidr)",
            "            ip_cidr = '%s/%s' % (fixed_ip.ip_address, net.prefixlen)",
            "            ip_cidrs.append(ip_cidr)",
            "",
            "        if self.driver.use_gateway_ips:",
            "            # For each DHCP-enabled subnet, add that subnet's gateway",
            "            # IP address to the Linux device for the DHCP port.",
            "            for subnet in network.subnets:",
            "                if not subnet.enable_dhcp:",
            "                    continue",
            "                gateway = subnet.gateway_ip",
            "                if gateway:",
            "                    net = netaddr.IPNetwork(subnet.cidr)",
            "                    ip_cidrs.append('%s/%s' % (gateway, net.prefixlen))",
            "",
            "        if self.conf.force_metadata or self.conf.enable_isolated_metadata:",
            "            ip_cidrs.append(constants.METADATA_CIDR)",
            "            if netutils.is_ipv6_enabled():",
            "                ip_cidrs.append(constants.METADATA_V6_CIDR)",
            "",
            "        self.driver.init_l3(interface_name, ip_cidrs,",
            "                            namespace=network.namespace)",
            "",
            "        self._set_default_route(network, interface_name)",
            "        self._cleanup_stale_devices(network, port)",
            "",
            "        return interface_name",
            "",
            "    def update(self, network, device_name):",
            "        \"\"\"Update device settings for the network's DHCP on this host.\"\"\"",
            "        self._set_default_route(network, device_name)",
            "",
            "    def unplug(self, device_name, network):",
            "        \"\"\"Unplug device settings for the network's DHCP on this host.\"\"\"",
            "        self.driver.unplug(device_name, namespace=network.namespace)",
            "",
            "    def destroy(self, network, device_name):",
            "        \"\"\"Destroy the device used for the network's DHCP on this host.\"\"\"",
            "        if device_name:",
            "            self.unplug(device_name, network)",
            "        else:",
            "            LOG.debug('No interface exists for network %s', network.id)",
            "",
            "        self.plugin.release_dhcp_port(network.id,",
            "                                      self.get_device_id(network))",
            "",
            "    def fill_dhcp_udp_checksums(self, namespace):",
            "        \"\"\"Ensure DHCP reply packets always have correct UDP checksums.\"\"\"",
            "        iptables_mgr = iptables_manager.IptablesManager(",
            "            use_ipv6=netutils.is_ipv6_enabled(), nat=False,",
            "            namespace=namespace)",
            "        ipv4_rule = ('-p udp -m udp --dport %d -j CHECKSUM --checksum-fill'",
            "                     % constants.DHCP_CLIENT_PORT)",
            "        ipv6_rule = ('-p udp -m udp --dport %d -j CHECKSUM --checksum-fill'",
            "                     % constants.DHCPV6_CLIENT_PORT)",
            "        iptables_mgr.ipv4['mangle'].add_rule('POSTROUTING', ipv4_rule)",
            "        iptables_mgr.ipv6['mangle'].add_rule('POSTROUTING', ipv6_rule)",
            "        iptables_mgr.apply()"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "import collections",
            "import copy",
            "import io",
            "import itertools",
            "import os",
            "import re",
            "import shutil",
            "import time",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import extra_dhcp_opt as edo_ext",
            "from neutron_lib import constants",
            "from neutron_lib import exceptions",
            "from neutron_lib.utils import file as file_utils",
            "from oslo_concurrency import processutils",
            "from oslo_log import log as logging",
            "from oslo_utils import excutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import netutils",
            "from oslo_utils import uuidutils",
            "",
            "from neutron.agent.common import utils as agent_common_utils",
            "from neutron.agent.linux import external_process",
            "from neutron.agent.linux import ip_lib",
            "from neutron.agent.linux import iptables_manager",
            "from neutron.cmd import runtime_checks as checks",
            "from neutron.common import utils as common_utils",
            "from neutron.ipam import utils as ipam_utils",
            "from neutron.privileged.agent.linux import dhcp as priv_dhcp",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "DNS_PORT = 53",
            "WIN2k3_STATIC_DNS = 249",
            "NS_PREFIX = 'qdhcp-'",
            "DNSMASQ_SERVICE_NAME = 'dnsmasq'",
            "DHCP_RELEASE_TRIES = 3",
            "DHCP_RELEASE_TRIES_SLEEP = 0.3",
            "HOST_DHCPV6_TAG = 'tag:dhcpv6,'",
            "",
            "# this variable will be removed when neutron-lib is updated with this value",
            "DHCP_OPT_CLIENT_ID_NUM = 61",
            "",
            "",
            "def port_requires_dhcp_configuration(port):",
            "    if not getattr(port, 'device_owner', None):",
            "        # We can't check if port needs dhcp entry, so it will be better",
            "        # to create one",
            "        return True",
            "    # TODO(slaweq): define this list as a constant in neutron_lib.constants",
            "    # NOTE(slaweq): Not all port types which belongs e.g. to the routers can be",
            "    # excluded from that list. For some of them, like router interfaces used to",
            "    # plug subnet to the router should be configured in dnsmasq to provide DNS",
            "    # naming resolution. Otherwise it may slowdown e.g. traceroutes from the VM",
            "    return port.device_owner not in [",
            "        constants.DEVICE_OWNER_ROUTER_HA_INTF,",
            "        constants.DEVICE_OWNER_FLOATINGIP,",
            "        constants.DEVICE_OWNER_DHCP,",
            "        constants.DEVICE_OWNER_DISTRIBUTED]",
            "",
            "",
            "class DictModel(collections.abc.MutableMapping):",
            "    \"\"\"Convert dict into an object that provides attribute access to values.\"\"\"",
            "",
            "    __slots__ = ['_dictmodel_internal_storage']",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Convert dict values to DictModel values.\"\"\"",
            "        temp_dict = dict(*args)",
            "        self._dictmodel_internal_storage = {}",
            "",
            "        def needs_upgrade(item):",
            "            \"\"\"Check if `item` is a dict and needs to be changed to DictModel.",
            "            \"\"\"",
            "            return isinstance(item, dict) and not isinstance(item, DictModel)",
            "",
            "        def upgrade(item):",
            "            \"\"\"Upgrade item if it needs to be upgraded.\"\"\"",
            "            if needs_upgrade(item):",
            "                return DictModel(item)",
            "            else:",
            "                return item",
            "",
            "        for key, value in itertools.chain(temp_dict.items(), kwargs.items()):",
            "            if isinstance(value, (list, tuple)):",
            "                # Keep the same type but convert dicts to DictModels",
            "                self._dictmodel_internal_storage[key] = type(value)(",
            "                    (upgrade(item) for item in value)",
            "                )",
            "            elif needs_upgrade(value):",
            "                # Change dict instance values to DictModel instance values",
            "                self._dictmodel_internal_storage[key] = DictModel(value)",
            "            else:",
            "                self._dictmodel_internal_storage[key] = value",
            "",
            "    def __getattr__(self, name):",
            "        try:",
            "            if name == '_dictmodel_internal_storage':",
            "                return super(DictModel, self).__getattr__(name)",
            "            return self.__getitem__(name)",
            "        except KeyError as e:",
            "            raise AttributeError(e)",
            "",
            "    def __setattr__(self, name, value):",
            "        if name == '_dictmodel_internal_storage':",
            "            super(DictModel, self).__setattr__(name, value)",
            "        else:",
            "            self._dictmodel_internal_storage[name] = value",
            "",
            "    def __delattr__(self, name):",
            "        del self._dictmodel_internal_storage[name]",
            "",
            "    def __str__(self):",
            "        pairs = ['%s=%s' % (k, v) for k, v in",
            "                 self._dictmodel_internal_storage.items()]",
            "        return ', '.join(sorted(pairs))",
            "",
            "    def __getitem__(self, name):",
            "        return self._dictmodel_internal_storage[name]",
            "",
            "    def __setitem__(self, name, value):",
            "        self._dictmodel_internal_storage[name] = value",
            "",
            "    def __delitem__(self, name):",
            "        del self._dictmodel_internal_storage[name]",
            "",
            "    def __iter__(self):",
            "        return iter(self._dictmodel_internal_storage)",
            "",
            "    def __len__(self):",
            "        return len(self._dictmodel_internal_storage)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # pylint: disable=no-value-for-parameter",
            "        cls = self.__class__",
            "        result = cls.__new__(cls)",
            "        memo[id(self)] = result",
            "        result._dictmodel_internal_storage = copy.deepcopy(",
            "            self._dictmodel_internal_storage)",
            "        return result",
            "",
            "",
            "class NetModel(DictModel):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(NetModel, self).__init__(*args, **kwargs)",
            "",
            "        self._ns_name = \"%s%s\" % (NS_PREFIX, self.id)",
            "",
            "    @property",
            "    def namespace(self):",
            "        return self._ns_name",
            "",
            "",
            "class DhcpBase(object, metaclass=abc.ABCMeta):",
            "",
            "    def __init__(self, conf, network, process_monitor,",
            "                 version=None, plugin=None):",
            "        self.conf = conf",
            "        self.network = network",
            "        self.process_monitor = process_monitor",
            "        self.device_manager = DeviceManager(self.conf, plugin)",
            "        self.version = version",
            "",
            "    @abc.abstractmethod",
            "    def enable(self):",
            "        \"\"\"Enables DHCP for this network.\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def disable(self, retain_port=False, block=False):",
            "        \"\"\"Disable dhcp for this network.\"\"\"",
            "",
            "    def restart(self):",
            "        \"\"\"Restart the dhcp service for the network.\"\"\"",
            "        self.disable(retain_port=True, block=True)",
            "        self.enable()",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def active(self):",
            "        \"\"\"Boolean representing the running state of the DHCP server.\"\"\"",
            "",
            "    @abc.abstractmethod",
            "    def reload_allocations(self):",
            "        \"\"\"Force the DHCP server to reload the assignment database.\"\"\"",
            "",
            "    @classmethod",
            "    def existing_dhcp_networks(cls, conf):",
            "        \"\"\"Return a list of existing networks ids that we have configs for.\"\"\"",
            "",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def check_version(cls):",
            "        \"\"\"Execute version checks on DHCP server.\"\"\"",
            "",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def get_isolated_subnets(cls, network):",
            "        \"\"\"Returns a dict indicating whether or not a subnet is isolated\"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def should_enable_metadata(cls, conf, network):",
            "        \"\"\"True if the metadata-proxy should be enabled for the network.\"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class DhcpLocalProcess(DhcpBase, metaclass=abc.ABCMeta):",
            "    PORTS = []",
            "",
            "    def __init__(self, conf, network, process_monitor, version=None,",
            "                 plugin=None):",
            "        super(DhcpLocalProcess, self).__init__(conf, network, process_monitor,",
            "                                               version, plugin)",
            "        self.confs_dir = self.get_confs_dir(conf)",
            "        self.network_conf_dir = os.path.join(self.confs_dir, network.id)",
            "        fileutils.ensure_tree(self.network_conf_dir, mode=0o755)",
            "",
            "    @staticmethod",
            "    def get_confs_dir(conf):",
            "        return os.path.abspath(os.path.normpath(conf.dhcp_confs))",
            "",
            "    def get_conf_file_name(self, kind):",
            "        \"\"\"Returns the file name for a given kind of config file.\"\"\"",
            "        return os.path.join(self.network_conf_dir, kind)",
            "",
            "    def _remove_config_files(self):",
            "        shutil.rmtree(self.network_conf_dir, ignore_errors=True)",
            "",
            "    @staticmethod",
            "    def _get_all_subnets(network):",
            "        non_local_subnets = getattr(network, 'non_local_subnets', [])",
            "        return network.subnets + non_local_subnets",
            "",
            "    def _enable_dhcp(self):",
            "        \"\"\"check if there is a subnet within the network with dhcp enabled.\"\"\"",
            "        for subnet in self.network.subnets:",
            "            if subnet.enable_dhcp:",
            "                return True",
            "        return False",
            "",
            "    def enable(self):",
            "        \"\"\"Enables DHCP for this network by spawning a local process.\"\"\"",
            "        try:",
            "            common_utils.wait_until_true(self._enable, timeout=300)",
            "        except common_utils.WaitTimeout:",
            "            LOG.error(\"Failed to start DHCP process for network %s\",",
            "                      self.network.id)",
            "",
            "    def _enable(self):",
            "        try:",
            "            if self.active:",
            "                self.disable(retain_port=True, block=True)",
            "",
            "            if self._enable_dhcp():",
            "                fileutils.ensure_tree(self.network_conf_dir, mode=0o755)",
            "                interface_name = self.device_manager.setup(self.network)",
            "                self.interface_name = interface_name",
            "                self.spawn_process()",
            "            return True",
            "        except exceptions.ProcessExecutionError as error:",
            "            LOG.debug(\"Spawning DHCP process for network %s failed; \"",
            "                      \"Error: %s\", self.network.id, error)",
            "            return False",
            "",
            "    def _get_process_manager(self, cmd_callback=None):",
            "        return external_process.ProcessManager(",
            "            conf=self.conf,",
            "            uuid=self.network.id,",
            "            namespace=self.network.namespace,",
            "            service=DNSMASQ_SERVICE_NAME,",
            "            default_cmd_callback=cmd_callback,",
            "            pid_file=self.get_conf_file_name('pid'),",
            "            run_as_root=True)",
            "",
            "    def disable(self, retain_port=False, block=False):",
            "        \"\"\"Disable DHCP for this network by killing the local process.\"\"\"",
            "        self.process_monitor.unregister(self.network.id, DNSMASQ_SERVICE_NAME)",
            "        self._get_process_manager().disable()",
            "        if block:",
            "            common_utils.wait_until_true(lambda: not self.active)",
            "        if not retain_port:",
            "            self._destroy_namespace_and_port()",
            "            self._remove_config_files()",
            "",
            "    def _destroy_namespace_and_port(self):",
            "        try:",
            "            self.device_manager.destroy(self.network, self.interface_name)",
            "        except RuntimeError:",
            "            LOG.warning('Failed trying to delete interface: %s',",
            "                        self.interface_name)",
            "",
            "        try:",
            "            ip_lib.delete_network_namespace(self.network.namespace)",
            "        except RuntimeError:",
            "            LOG.warning('Failed trying to delete namespace: %s',",
            "                        self.network.namespace)",
            "",
            "    def _get_value_from_conf_file(self, kind, converter=None):",
            "        \"\"\"A helper function to read a value from one of the state files.\"\"\"",
            "        file_name = self.get_conf_file_name(kind)",
            "        try:",
            "            with open(file_name, 'r') as f:",
            "                return converter(f.read()) if converter else f.read()",
            "        except ValueError:",
            "            msg = \"Unable to convert value in %s\"",
            "        except IOError:",
            "            msg = \"Unable to access %s\"",
            "        LOG.debug(msg, file_name)",
            "        return None",
            "",
            "    @property",
            "    def interface_name(self):",
            "        return self._get_value_from_conf_file('interface')",
            "",
            "    @interface_name.setter",
            "    def interface_name(self, value):",
            "        interface_file_path = self.get_conf_file_name('interface')",
            "        file_utils.replace_file(interface_file_path, value)",
            "",
            "    def get_metadata_bind_interface(self, port):",
            "        return self.device_manager.get_interface_name(self.network, port)",
            "",
            "    @property",
            "    def active(self):",
            "        return self._get_process_manager().active",
            "",
            "    @abc.abstractmethod",
            "    def spawn_process(self):",
            "        pass",
            "",
            "",
            "class Dnsmasq(DhcpLocalProcess):",
            "    # The ports that need to be opened when security policies are active",
            "    # on the Neutron port used for DHCP.  These are provided as a convenience",
            "    # for users of this class.",
            "    PORTS = {constants.IP_VERSION_4:",
            "             [(constants.PROTO_NAME_UDP, DNS_PORT),",
            "              (constants.PROTO_NAME_TCP, DNS_PORT),",
            "              (constants.PROTO_NAME_UDP, constants.DHCP_RESPONSE_PORT)],",
            "             constants.IP_VERSION_6:",
            "             [(constants.PROTO_NAME_UDP, DNS_PORT),",
            "              (constants.PROTO_NAME_TCP, DNS_PORT),",
            "              (constants.PROTO_NAME_UDP, constants.DHCPV6_RESPONSE_PORT)],",
            "             }",
            "",
            "    _SUBNET_TAG_PREFIX = 'subnet-%s'",
            "    _PORT_TAG_PREFIX = 'port-%s'",
            "",
            "    _ID = 'id:'",
            "",
            "    _IS_DHCP_RELEASE6_SUPPORTED = None",
            "    _IS_HOST_TAG_SUPPORTED = None",
            "",
            "    @classmethod",
            "    def check_version(cls):",
            "        pass",
            "",
            "    @classmethod",
            "    def existing_dhcp_networks(cls, conf):",
            "        \"\"\"Return a list of existing networks ids that we have configs for.\"\"\"",
            "        confs_dir = cls.get_confs_dir(conf)",
            "        try:",
            "            return [",
            "                c for c in os.listdir(confs_dir)",
            "                if uuidutils.is_uuid_like(c)",
            "            ]",
            "        except OSError:",
            "            return []",
            "",
            "    def _build_cmdline_callback(self, pid_file):",
            "        # We ignore local resolv.conf if dns servers are specified",
            "        # or if local resolution is explicitly disabled.",
            "        _no_resolv = (",
            "            '--no-resolv' if self.conf.dnsmasq_dns_servers or",
            "            not self.conf.dnsmasq_local_resolv else '')",
            "        cmd = [",
            "            'dnsmasq',",
            "            '--no-hosts',",
            "            _no_resolv,",
            "            '--pid-file=%s' % pid_file,",
            "            '--dhcp-hostsfile=%s' % self.get_conf_file_name('host'),",
            "            '--addn-hosts=%s' % self.get_conf_file_name('addn_hosts'),",
            "            '--dhcp-optsfile=%s' % self.get_conf_file_name('opts'),",
            "            '--dhcp-leasefile=%s' % self.get_conf_file_name('leases'),",
            "            '--dhcp-match=set:ipxe,175',",
            "            '--dhcp-userclass=set:ipxe6,iPXE',",
            "            '--local-service',",
            "            '--bind-dynamic',",
            "        ]",
            "        if not self.device_manager.driver.bridged:",
            "            cmd += [",
            "                '--bridge-interface=%s,tap*' % self.interface_name,",
            "            ]",
            "",
            "        possible_leases = 0",
            "        for subnet in self._get_all_subnets(self.network):",
            "            mode = None",
            "            # if a subnet is specified to have dhcp disabled",
            "            if not subnet.enable_dhcp:",
            "                continue",
            "            if subnet.ip_version == 4:",
            "                mode = 'static'",
            "            else:",
            "                # Note(scollins) If the IPv6 attributes are not set, set it as",
            "                # static to preserve previous behavior",
            "                addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "                ra_mode = getattr(subnet, 'ipv6_ra_mode', None)",
            "                if (addr_mode in [constants.DHCPV6_STATEFUL,",
            "                                  constants.DHCPV6_STATELESS] or",
            "                        not addr_mode and not ra_mode):",
            "                    mode = 'static'",
            "",
            "            cidr = netaddr.IPNetwork(subnet.cidr)",
            "",
            "            if self.conf.dhcp_lease_duration == -1:",
            "                lease = 'infinite'",
            "            else:",
            "                lease = '%ss' % self.conf.dhcp_lease_duration",
            "",
            "            # mode is optional and is not set - skip it",
            "            if mode:",
            "                if subnet.ip_version == 4:",
            "                    cmd.append('--dhcp-range=%s%s,%s,%s,%s,%s' %",
            "                               ('set:', self._SUBNET_TAG_PREFIX % subnet.id,",
            "                                cidr.network, mode, cidr.netmask, lease))",
            "                else:",
            "                    if cidr.prefixlen < 64:",
            "                        LOG.debug('Ignoring subnet %(subnet)s, CIDR has '",
            "                                  'prefix length < 64: %(cidr)s',",
            "                                  {'subnet': subnet.id, 'cidr': cidr})",
            "                        continue",
            "                    cmd.append('--dhcp-range=%s%s,%s,%s,%d,%s' %",
            "                               ('set:', self._SUBNET_TAG_PREFIX % subnet.id,",
            "                                cidr.network, mode,",
            "                                cidr.prefixlen, lease))",
            "                possible_leases += cidr.size",
            "",
            "        mtu = getattr(self.network, 'mtu', 0)",
            "        # Do not advertise unknown mtu",
            "        if mtu > 0:",
            "            cmd.append('--dhcp-option-force=option:mtu,%d' % mtu)",
            "",
            "        # Cap the limit because creating lots of subnets can inflate",
            "        # this possible lease cap.",
            "        cmd.append('--dhcp-lease-max=%d' %",
            "                   min(possible_leases, self.conf.dnsmasq_lease_max))",
            "",
            "        if self.conf.dhcp_renewal_time > 0:",
            "            cmd.append('--dhcp-option-force=option:T1,%ds' %",
            "                       self.conf.dhcp_renewal_time)",
            "",
            "        if self.conf.dhcp_rebinding_time > 0:",
            "            cmd.append('--dhcp-option-force=option:T2,%ds' %",
            "                       self.conf.dhcp_rebinding_time)",
            "",
            "        cmd.append('--conf-file=%s' %",
            "                   (self.conf.dnsmasq_config_file.strip() or '/dev/null'))",
            "        for server in self.conf.dnsmasq_dns_servers:",
            "            cmd.append('--server=%s' % server)",
            "",
            "        if self.conf.dns_domain:",
            "            cmd.append('--domain=%s' % self.conf.dns_domain)",
            "",
            "        if self.conf.dhcp_broadcast_reply:",
            "            cmd.append('--dhcp-broadcast')",
            "",
            "        if self.conf.dnsmasq_base_log_dir:",
            "            log_dir = os.path.join(",
            "                self.conf.dnsmasq_base_log_dir,",
            "                self.network.id)",
            "            try:",
            "                if not os.path.exists(log_dir):",
            "                    os.makedirs(log_dir)",
            "            except OSError:",
            "                LOG.error('Error while create dnsmasq log dir: %s', log_dir)",
            "            else:",
            "                log_filename = os.path.join(log_dir, 'dhcp_dns_log')",
            "                cmd.append('--log-queries')",
            "                cmd.append('--log-dhcp')",
            "                cmd.append('--log-facility=%s' % log_filename)",
            "",
            "        return cmd",
            "",
            "    def spawn_process(self):",
            "        \"\"\"Spawn the process, if it's not spawned already.\"\"\"",
            "        # we only need to generate the lease file the first time dnsmasq starts",
            "        # rather than on every reload since dnsmasq will keep the file current",
            "        self._output_init_lease_file()",
            "        self._spawn_or_reload_process(reload_with_HUP=False)",
            "",
            "    def _spawn_or_reload_process(self, reload_with_HUP):",
            "        \"\"\"Spawns or reloads a Dnsmasq process for the network.",
            "",
            "        When reload_with_HUP is True, dnsmasq receives a HUP signal,",
            "        or it's reloaded if the process is not running.",
            "        \"\"\"",
            "",
            "        self._output_config_files()",
            "",
            "        pm = self._get_process_manager(",
            "            cmd_callback=self._build_cmdline_callback)",
            "",
            "        pm.enable(reload_cfg=reload_with_HUP, ensure_active=True)",
            "",
            "        self.process_monitor.register(uuid=self.network.id,",
            "                                      service_name=DNSMASQ_SERVICE_NAME,",
            "                                      monitored_process=pm)",
            "",
            "    def _is_dhcp_release6_supported(self):",
            "        if self._IS_DHCP_RELEASE6_SUPPORTED is None:",
            "            self._IS_DHCP_RELEASE6_SUPPORTED = (",
            "                priv_dhcp.dhcp_release6_supported())",
            "            if not self._IS_DHCP_RELEASE6_SUPPORTED:",
            "                LOG.warning(\"dhcp_release6 is not present on this system, \"",
            "                            \"will not call it again.\")",
            "        return self._IS_DHCP_RELEASE6_SUPPORTED",
            "",
            "    def _is_dnsmasq_host_tag_supported(self):",
            "        if self._IS_HOST_TAG_SUPPORTED is None:",
            "            self._IS_HOST_TAG_SUPPORTED = checks.dnsmasq_host_tag_support()",
            "",
            "        return self._IS_HOST_TAG_SUPPORTED",
            "",
            "    def _release_lease(self, mac_address, ip, ip_version, client_id=None,",
            "                       server_id=None, iaid=None):",
            "        \"\"\"Release a DHCP lease.\"\"\"",
            "        try:",
            "            if ip_version == constants.IP_VERSION_6:",
            "                if not self._is_dhcp_release6_supported():",
            "                    return",
            "",
            "                params = {'interface_name': self.interface_name,",
            "                          'ip_address': ip, 'client_id': client_id,",
            "                          'server_id': server_id, 'iaid': iaid,",
            "                          'namespace': self.network.namespace}",
            "                priv_dhcp.dhcp_release6(**params)",
            "            else:",
            "                params = {'interface_name': self.interface_name,",
            "                          'ip_address': ip, 'mac_address': mac_address,",
            "                          'client_id': client_id,",
            "                          'namespace': self.network.namespace}",
            "                priv_dhcp.dhcp_release(**params)",
            "        except (processutils.ProcessExecutionError, OSError) as e:",
            "            # when failed to release single lease there's",
            "            # no need to propagate error further",
            "            LOG.warning('DHCP release failed for params %(params)s. '",
            "                        'Reason: %(e)s', {'params': params, 'e': e})",
            "",
            "    def _output_config_files(self):",
            "        self._output_hosts_file()",
            "        self._output_addn_hosts_file()",
            "        self._output_opts_file()",
            "",
            "    def reload_allocations(self):",
            "        \"\"\"Rebuild the dnsmasq config and signal the dnsmasq to reload.\"\"\"",
            "",
            "        # If all subnets turn off dhcp, kill the process.",
            "        if not self._enable_dhcp():",
            "            self.disable()",
            "            LOG.debug('Killing dnsmasq for network since all subnets have '",
            "                      'turned off DHCP: %s', self.network.id)",
            "            return",
            "        if not self.interface_name:",
            "            # we land here if above has been called and we receive port",
            "            # delete notifications for the network",
            "            LOG.debug('Agent does not have an interface on this network '",
            "                      'anymore, skipping reload: %s', self.network.id)",
            "            return",
            "",
            "        self._release_unused_leases()",
            "        self._spawn_or_reload_process(reload_with_HUP=True)",
            "        LOG.debug('Reloading allocations for network: %s', self.network.id)",
            "        self.device_manager.update(self.network, self.interface_name)",
            "",
            "    def _sort_fixed_ips_for_dnsmasq(self, fixed_ips, v6_nets):",
            "        \"\"\"Sort fixed_ips so that stateless IPv6 subnets appear first.",
            "",
            "        For example, If a port with v6 extra_dhcp_opts is on a network with",
            "        IPv4 and IPv6 stateless subnets. Then dhcp host file will have",
            "        below 2 entries for same MAC,",
            "",
            "        fa:16:3e:8f:9d:65,30.0.0.5,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        (entry for IPv4 dhcp)",
            "        fa:16:3e:8f:9d:65,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        (entry for stateless IPv6 for v6 options)",
            "",
            "        dnsmasq internal details for processing host file entries",
            "        1) dnsmasq reads the host file from EOF.",
            "        2) So it first picks up stateless IPv6 entry,",
            "           fa:16:3e:8f:9d:65,set:aabc7d33-4874-429e-9637-436e4232d2cd",
            "        3) But dnsmasq doesn't have sufficient checks to skip this entry and",
            "           pick next entry, to process dhcp IPv4 request.",
            "        4) So dnsmasq uses this entry to process dhcp IPv4 request.",
            "        5) As there is no ip in this entry, dnsmasq logs \"no address available\"",
            "           and fails to send DHCPOFFER message.",
            "",
            "        As we rely on internal details of dnsmasq to understand and fix the",
            "        issue, Ihar sent a mail to dnsmasq-discuss mailing list",
            "        http://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2015q2/",
            "        009650.html",
            "",
            "        So if we reverse the order of writing entries in host file,",
            "        so that entry for stateless IPv6 comes first,",
            "        then dnsmasq can correctly fetch the IPv4 address.",
            "        \"\"\"",
            "        return sorted(",
            "            fixed_ips,",
            "            key=lambda fip: ((fip.subnet_id in v6_nets) and (",
            "                v6_nets[fip.subnet_id].ipv6_address_mode == (",
            "                    constants.DHCPV6_STATELESS))),",
            "            reverse=True)",
            "",
            "    def _merge_alloc_addr6_list(self, fixed_ips, v6_nets):",
            "        \"\"\"Merge fixed_ips to ipv6 addr lists",
            "",
            "        If a port have multiple IPv6 addresses in the same subnet, merge the",
            "        into one entry listing all the addresess, creating a single dhcp-host",
            "        entry with the list of addresses defined allow dnsmasq to make all",
            "        addresses available as requests for leases arrive.",
            "",
            "        See dnsmasq-discuss mailing list: http://lists.thekelleys.org.uk/",
            "        pipermail/dnsmasq-discuss/2020q1/013743.html",
            "",
            "        \"\"\"",
            "        by_subnet = {}",
            "        NewFip = collections.namedtuple('NewFip', 'subnet_id ip_address')",
            "        merged = []",
            "",
            "        for fip in fixed_ips:",
            "            if (fip.subnet_id in v6_nets and",
            "                    v6_nets[fip.subnet_id].ipv6_address_mode == (",
            "                            constants.DHCPV6_STATEFUL)):",
            "                if fip.subnet_id not in by_subnet:",
            "                    by_subnet.update({fip.subnet_id: []})",
            "                by_subnet[fip.subnet_id].append(fip.ip_address)",
            "            else:",
            "                merged.append(fip)",
            "",
            "        for subnet_id in by_subnet:",
            "            addr6_list = ','.join([self._format_address_for_dnsmasq(ip)",
            "                                   for ip in by_subnet[subnet_id]])",
            "            merged.append(NewFip(subnet_id=subnet_id,",
            "                                 ip_address=addr6_list))",
            "",
            "        return merged",
            "",
            "    def _get_dns_assignment(self, ip_address, dns_assignment):",
            "        \"\"\"Get DNS assignment hostname and fqdn",
            "",
            "        In dnsmasq it is not possible to configure two dhcp-host",
            "        entries mapped to a single client mac address with IP",
            "        addresses in the same subnet. When recieving a requst",
            "        dnsmasq will match on the first entry in it's config,",
            "        and lease that address. The second entry will never be",
            "        used.",
            "",
            "        For IPv6 it is possible to add multiple IPv6 addresses",
            "        to a single dhcp-host entry by placing a list of addresses",
            "        in brackets, i.e [addr1][addr2][...]. See dnsmasq mailing",
            "        list: http://lists.thekelleys.org.uk/pipermail/",
            "        dnsmasq-discuss/2020q1/013671.html. Since we cannot have",
            "        two hostnames in the dhcp-host entry this method picks the",
            "        first hostname and fqdn it find's matching one of the IP's",
            "        in the fixed-ips in dns_assignment or the hostname is",
            "        generated based on the first fixed-ip.",
            "",
            "        :param ip_address: IP address or a list of IPv6 addresses",
            "        :param dns_ip_map: DNS IP Mapping",
            "        :param dns_assignment: DNS assignments",
            "        :return: hostname, fqdn",
            "        \"\"\"",
            "        hostname, fqdn = None, None",
            "        ip_addresses = ip_address.replace('[', '').split(']')",
            "",
            "        if dns_assignment:",
            "            dns_ip_map = {d.ip_address: d for d in dns_assignment}",
            "            for addr in ip_addresses:",
            "                # If dns_name attribute is supported by ports API, return the",
            "                # dns_assignment generated by the Neutron server. Otherwise,",
            "                # generate hostname and fqdn locally (previous behaviour)",
            "                if addr in dns_ip_map:",
            "                    hostname = dns_ip_map[addr].hostname",
            "                    fqdn = dns_ip_map[addr].fqdn",
            "                    break",
            "",
            "        if hostname is None:",
            "            hostname = ('host-%s' %",
            "                        ip_addresses[0].replace('.', '-').replace(':', '-'))",
            "            fqdn = hostname",
            "            if self.conf.dns_domain:",
            "                fqdn = '%s.%s' % (fqdn, self.conf.dns_domain)",
            "",
            "        return hostname, fqdn",
            "",
            "    def _iter_hosts(self, merge_addr6_list=False):",
            "        \"\"\"Iterate over hosts.",
            "",
            "        For each host on the network we yield a tuple containing:",
            "        (",
            "            port,  # a DictModel instance representing the port.",
            "            alloc,  # a DictModel instance of the allocated ip and subnet.",
            "                    # if alloc is None, it means there is no need to allocate",
            "                    # an IPv6 address because of stateless DHCPv6 network.",
            "            host_name,  # Host name.",
            "            name,  # Canonical hostname in the format 'hostname[.domain]'.",
            "            no_dhcp,  # A flag indicating that the address doesn't need a DHCP",
            "                      # IP address.",
            "            no_opts,  # A flag indication that options shouldn't be written",
            "            tag,    # A dhcp-host tag to add to the configuration if supported",
            "        )",
            "        \"\"\"",
            "        v6_nets = dict((subnet.id, subnet) for subnet in",
            "                       self._get_all_subnets(self.network)",
            "                       if subnet.ip_version == 6)",
            "",
            "        for port in self.network.ports:",
            "            if not port_requires_dhcp_configuration(port):",
            "                continue",
            "",
            "            fixed_ips = self._sort_fixed_ips_for_dnsmasq(port.fixed_ips,",
            "                                                         v6_nets)",
            "            # TODO(hjensas): Drop this conditional and option once distros",
            "            #  generally have dnsmasq supporting addr6 list and range.",
            "            if self.conf.dnsmasq_enable_addr6_list and merge_addr6_list:",
            "                fixed_ips = self._merge_alloc_addr6_list(fixed_ips, v6_nets)",
            "            # Confirm whether Neutron server supports dns_name attribute in the",
            "            # ports API",
            "            dns_assignment = getattr(port, 'dns_assignment', None)",
            "            for alloc in fixed_ips:",
            "                no_dhcp = False",
            "                no_opts = False",
            "                tag = ''",
            "                if alloc.subnet_id in v6_nets:",
            "                    addr_mode = v6_nets[alloc.subnet_id].ipv6_address_mode",
            "                    no_dhcp = addr_mode in (constants.IPV6_SLAAC,",
            "                                            constants.DHCPV6_STATELESS)",
            "                    if self._is_dnsmasq_host_tag_supported():",
            "                        tag = HOST_DHCPV6_TAG",
            "                    # we don't setup anything for SLAAC. It doesn't make sense",
            "                    # to provide options for a client that won't use DHCP",
            "                    no_opts = addr_mode == constants.IPV6_SLAAC",
            "",
            "                hostname, fqdn = self._get_dns_assignment(alloc.ip_address,",
            "                                                          dns_assignment)",
            "",
            "                yield (port, alloc, hostname, fqdn, no_dhcp, no_opts, tag)",
            "",
            "    def _get_port_extra_dhcp_opts(self, port):",
            "        return getattr(port, edo_ext.EXTRADHCPOPTS, False)",
            "",
            "    def _output_init_lease_file(self):",
            "        \"\"\"Write a fake lease file to bootstrap dnsmasq.",
            "",
            "        The generated file is passed to the --dhcp-leasefile option of dnsmasq.",
            "        This is used as a bootstrapping mechanism to avoid NAKing active leases",
            "        when a dhcp server is scheduled to another agent. Using a leasefile",
            "        will also prevent dnsmasq from NAKing or ignoring renewals after a",
            "        restart.",
            "",
            "        Format is as follows:",
            "        epoch-timestamp mac_addr ip_addr hostname client-ID",
            "        \"\"\"",
            "        filename = self.get_conf_file_name('leases')",
            "        buf = io.StringIO()",
            "",
            "        LOG.debug('Building initial lease file: %s', filename)",
            "        # we make up a lease time for the database entry",
            "        if self.conf.dhcp_lease_duration == -1:",
            "            # Even with an infinite lease, a client may choose to renew a",
            "            # previous lease on reboot or interface bounce so we should have",
            "            # an entry for it.",
            "            # Dnsmasq timestamp format for an infinite lease is 0.",
            "            timestamp = 0",
            "        else:",
            "            timestamp = int(time.time()) + self.conf.dhcp_lease_duration",
            "        dhcpv4_enabled_subnet_ids = [",
            "            s.id for s in self._get_all_subnets(self.network)",
            "            if s.enable_dhcp and s.ip_version == constants.IP_VERSION_4]",
            "        dhcpv6_enabled_subnet_ids = [",
            "            s.id for s in self._get_all_subnets(self.network)",
            "            if s.enable_dhcp and s.ip_version == constants.IP_VERSION_6]",
            "",
            "        existing_ipv6_leases = {}",
            "        if os.path.isfile(filename):",
            "            # The IPv6 leases can't be generated as their IAID is unknown. To",
            "            # not loose active leases, read the existing leases and add them to",
            "            # the generated file.",
            "            LOG.debug('Reading IPv6 leases from existing lease file.')",
            "            with open(filename) as leasefile:",
            "                for line in leasefile:",
            "                    if line.startswith('duid '):",
            "                        # Keep the DUID",
            "                        buf.write(line)",
            "                        continue",
            "                    try:",
            "                        ts, mac, ip, host, iaid = line.split(' ')",
            "                    except ValueError:",
            "                        # not the correct format for a lease, skip this line",
            "                        continue",
            "",
            "                    if netaddr.valid_ipv6(ip):",
            "                        existing_ipv6_leases[netaddr.IPAddress(ip)] = line",
            "",
            "        for host_tuple in self._iter_hosts():",
            "            port, alloc, hostname, name, no_dhcp, no_opts, tag = host_tuple",
            "",
            "            if no_dhcp:",
            "                continue",
            "",
            "            if alloc.subnet_id in dhcpv4_enabled_subnet_ids:",
            "                # all that matters is the mac address and IP. the hostname and",
            "                # client ID will be overwritten on the next renewal.",
            "                buf.write('%s %s %s * *\\n' %",
            "                          (timestamp, port.mac_address, alloc.ip_address))",
            "            elif (alloc.subnet_id in dhcpv6_enabled_subnet_ids and",
            "                  netaddr.IPAddress(alloc.ip_address) in existing_ipv6_leases):",
            "                # Keep the existing IPv6 lease if the port still exists and is",
            "                # still configured for DHCPv6",
            "                buf.write(",
            "                    existing_ipv6_leases[netaddr.IPAddress(alloc.ip_address)]",
            "                )",
            "",
            "        contents = buf.getvalue()",
            "        file_utils.replace_file(filename, contents)",
            "        LOG.debug('Done building initial lease file %s with contents:\\n%s',",
            "                  filename, contents)",
            "        return filename",
            "",
            "    @staticmethod",
            "    def _format_address_for_dnsmasq(address):",
            "        # (dzyu) Check if it is legal ipv6 address, if so, need wrap",
            "        # it with '[]' to let dnsmasq to distinguish MAC address from",
            "        # IPv6 address.",
            "        if netaddr.valid_ipv6(address):",
            "            return '[%s]' % address",
            "        return address",
            "",
            "    def _output_hosts_file(self):",
            "        \"\"\"Writes a dnsmasq compatible dhcp hosts file.",
            "",
            "        The generated file is sent to the --dhcp-hostsfile option of dnsmasq,",
            "        and lists the hosts on the network which should receive a dhcp lease.",
            "        Each line in this file is in the form::",
            "",
            "            'mac_address,FQDN,ip_address'",
            "",
            "        IMPORTANT NOTE: a dnsmasq instance does not resolve hosts defined in",
            "        this file if it did not give a lease to a host listed in it (e.g.:",
            "        multiple dnsmasq instances on the same network if this network is on",
            "        multiple network nodes). This file is only defining hosts which",
            "        should receive a dhcp lease, the hosts resolution in itself is",
            "        defined by the `_output_addn_hosts_file` method.",
            "        \"\"\"",
            "        buf = io.StringIO()",
            "        filename = self.get_conf_file_name('host')",
            "",
            "        LOG.debug('Building host file: %s', filename)",
            "        dhcp_enabled_subnet_ids = [s.id for s in",
            "                                   self._get_all_subnets(self.network)",
            "                                   if s.enable_dhcp]",
            "        # NOTE(ihrachyshka): the loop should not log anything inside it, to",
            "        # avoid potential performance drop when lots of hosts are dumped",
            "        for host_tuple in self._iter_hosts(merge_addr6_list=True):",
            "            port, alloc, hostname, name, no_dhcp, no_opts, tag = host_tuple",
            "            if no_dhcp:",
            "                if not no_opts and self._get_port_extra_dhcp_opts(port):",
            "                    buf.write('%s,%s%s%s\\n' % (",
            "                        port.mac_address, tag,",
            "                        'set:', self._PORT_TAG_PREFIX % port.id))",
            "                continue",
            "",
            "            # don't write ip address which belongs to a dhcp disabled subnet.",
            "            if alloc.subnet_id not in dhcp_enabled_subnet_ids:",
            "                continue",
            "",
            "            ip_address = self._format_address_for_dnsmasq(alloc.ip_address)",
            "",
            "            if self._get_port_extra_dhcp_opts(port):",
            "                client_id = self._get_client_id(port)",
            "                if client_id and len(port.extra_dhcp_opts) > 1:",
            "                    buf.write('%s,%s%s%s,%s,%s,%s%s\\n' %",
            "                              (port.mac_address, tag, self._ID, client_id,",
            "                               name, ip_address, 'set:',",
            "                               self._PORT_TAG_PREFIX % port.id))",
            "                elif client_id and len(port.extra_dhcp_opts) == 1:",
            "                    buf.write('%s,%s%s%s,%s,%s\\n' %",
            "                              (port.mac_address, tag, self._ID, client_id,",
            "                               name, ip_address))",
            "                else:",
            "                    buf.write('%s,%s%s,%s,%s%s\\n' %",
            "                              (port.mac_address, tag, name, ip_address,",
            "                               'set:', self._PORT_TAG_PREFIX % port.id))",
            "            else:",
            "                buf.write('%s,%s%s,%s\\n' %",
            "                          (port.mac_address, tag, name, ip_address))",
            "",
            "        file_utils.replace_file(filename, buf.getvalue())",
            "        LOG.debug('Done building host file %s', filename)",
            "        return filename",
            "",
            "    def _get_client_id(self, port):",
            "        if self._get_port_extra_dhcp_opts(port):",
            "            for opt in port.extra_dhcp_opts:",
            "                if opt.opt_name in (edo_ext.DHCP_OPT_CLIENT_ID,",
            "                                    DHCP_OPT_CLIENT_ID_NUM,",
            "                                    str(DHCP_OPT_CLIENT_ID_NUM)):",
            "                    return opt.opt_value",
            "",
            "    @staticmethod",
            "    def _parse_ip_addresses(ip_list):",
            "        ip_list = [ip.strip('[]') for ip in ip_list]",
            "        return [ip for ip in ip_list if netutils.is_valid_ip(ip)]",
            "",
            "    def _read_hosts_file_leases(self, filename):",
            "        leases = set()",
            "        try:",
            "            with open(filename) as f:",
            "                for line in f.readlines():",
            "                    host = line.strip().split(',')",
            "                    mac = host[0]",
            "                    client_id = None",
            "                    if host[1].startswith('set:'):",
            "                        continue",
            "                    if host[1].startswith(self._ID):",
            "                        ips = self._parse_ip_addresses(host[3:])",
            "                        client_id = host[1][len(self._ID):]",
            "                    elif host[1].startswith('tag:'):",
            "                        ips = self._parse_ip_addresses(host[3:])",
            "                    else:",
            "                        ips = self._parse_ip_addresses(host[2:])",
            "                    for ip in ips:",
            "                        leases.add((ip, mac, client_id))",
            "        except (OSError, IOError):",
            "            LOG.debug('Error while reading hosts file %s', filename)",
            "        return leases",
            "",
            "    def _read_leases_file_leases(self, filename):",
            "        \"\"\"Read dnsmasq dhcp leases file",
            "",
            "        Read information from leases file, which is needed to pass to",
            "        dhcp_release6 command line utility if some of these leases are not",
            "        needed anymore",
            "",
            "        each line in dnsmasq leases file is one of the following",
            "          * duid entry: duid server_duid",
            "          There MUST be single duid entry per file",
            "          * ipv4 entry: space separated list",
            "            - The expiration time (seconds since unix epoch) or duration",
            "              (if dnsmasq is compiled with HAVE_BROKEN_RTC) of the lease.",
            "              0 means infinite.",
            "            - The link address, in format XX-YY:YY:YY[...], where XX is the ARP",
            "              hardware type.  \"XX-\" may be omitted for Ethernet.",
            "            - The IPv4 address",
            "            - The hostname (sent by the client or assigned by dnsmasq)",
            "              or '*' for none.",
            "            - The client identifier (colon-separated hex bytes)",
            "              or '*' for none.",
            "",
            "          *  ipv6 entry: space separated list",
            "            - The expiration time or duration",
            "            - The IAID as a Big Endian decimal number, prefixed by T for",
            "              IA_TAs (temporary addresses).",
            "            - The IPv6 address",
            "            - The hostname or '*'",
            "            - The client DUID (colon-separated hex bytes) or '*' if unknown",
            "",
            "        original discussion is in dnsmasq mailing list",
            "        http://lists.thekelleys.org.uk/pipermail/\\",
            "        dnsmasq-discuss/2016q2/010595.html",
            "",
            "        :param filename: leases file",
            "        :return: dict, keys are IP(v6) addresses, values are dicts containing",
            "                iaid, client_id and server_id",
            "        \"\"\"",
            "        leases = {}",
            "        server_id = None",
            "        if os.path.exists(filename):",
            "            with open(filename) as f:",
            "                for line in f.readlines():",
            "                    if line.startswith('duid'):",
            "                        if not server_id:",
            "                            server_id = line.strip().split()[1]",
            "                        else:",
            "                            LOG.warning('Multiple DUID entries in %s '",
            "                                        'lease file, dnsmasq is possibly '",
            "                                        'not functioning properly',",
            "                                        filename)",
            "                        continue",
            "                    parts = line.strip().split()",
            "                    if len(parts) != 5:",
            "                        LOG.warning('Invalid lease entry %s found in %s '",
            "                                    'lease file, ignoring', parts, filename)",
            "                        continue",
            "                    (iaid, ip, client_id) = parts[1], parts[2], parts[4]",
            "                    ip = ip.strip('[]')",
            "                    leases[ip] = {'iaid': iaid,",
            "                                  'client_id': client_id,",
            "                                  'server_id': server_id",
            "                                  }",
            "        return leases",
            "",
            "    def _release_unused_leases(self):",
            "        filename = self.get_conf_file_name('host')",
            "        old_leases = self._read_hosts_file_leases(filename)",
            "        leases_filename = self.get_conf_file_name('leases')",
            "        cur_leases = self._read_leases_file_leases(leases_filename)",
            "        if not cur_leases:",
            "            return",
            "",
            "        v4_leases = set()",
            "        for (k, v) in cur_leases.items():",
            "            # IPv4 leases have a MAC, IPv6 ones do not, so we must ignore",
            "            if netaddr.IPAddress(k).version == constants.IP_VERSION_4:",
            "                # treat '*' as None, see note in _read_leases_file_leases()",
            "                client_id = v['client_id']",
            "                if client_id == '*':",
            "                    client_id = None",
            "                v4_leases.add((k, v['iaid'], client_id))",
            "",
            "        new_leases = set()",
            "        for port in self.network.ports:",
            "            client_id = self._get_client_id(port)",
            "            for alloc in port.fixed_ips:",
            "                new_leases.add((alloc.ip_address, port.mac_address, client_id))",
            "",
            "        # If an entry is in the leases or host file(s), but doesn't have",
            "        # a fixed IP on a corresponding neutron port, consider it stale.",
            "        entries_to_release = (v4_leases | old_leases) - new_leases",
            "        if not entries_to_release:",
            "            return",
            "",
            "        # If the VM advertises a client ID in its lease, but its not set in",
            "        # the port's Extra DHCP Opts, the lease will not be filtered above.",
            "        # Release the lease only if client ID is set in port DB and a mismatch",
            "        # Otherwise the lease is released when other ports are deleted/updated",
            "        entries_with_no_client_id = set()",
            "        for ip, mac, client_id in entries_to_release:",
            "            if client_id:",
            "                entry_no_client_id = (ip, mac, None)",
            "                if (entry_no_client_id in old_leases and",
            "                        entry_no_client_id in new_leases):",
            "                    entries_with_no_client_id.add((ip, mac, client_id))",
            "        entries_to_release -= entries_with_no_client_id",
            "",
            "        # Try DHCP_RELEASE_TRIES times to release a lease, re-reading the",
            "        # file each time to see if it's still there.  We loop +1 times to",
            "        # check the lease file one last time before logging any remaining",
            "        # entries.",
            "        for i in range(DHCP_RELEASE_TRIES + 1):",
            "            entries_not_present = set()",
            "            for ip, mac, client_id in entries_to_release:",
            "                try:",
            "                    entry = cur_leases[ip]",
            "                except KeyError:",
            "                    entries_not_present.add((ip, mac, client_id))",
            "                    continue",
            "                # if not the final loop, try and release",
            "                if i < DHCP_RELEASE_TRIES:",
            "                    ip_version = netaddr.IPAddress(ip).version",
            "                    if ip_version == constants.IP_VERSION_6:",
            "                        client_id = entry['client_id']",
            "                    self._release_lease(mac, ip, ip_version, client_id,",
            "                                        entry['server_id'], entry['iaid'])",
            "",
            "            # Remove elements that were not in the current leases file,",
            "            # no need to look for them again, and see if we're done.",
            "            entries_to_release -= entries_not_present",
            "            if not entries_to_release:",
            "                break",
            "",
            "            if i < DHCP_RELEASE_TRIES:",
            "                time.sleep(DHCP_RELEASE_TRIES_SLEEP)",
            "                cur_leases = self._read_leases_file_leases(leases_filename)",
            "                if not cur_leases:",
            "                    break",
            "        else:",
            "            LOG.warning(\"Could not release DHCP leases for these IP \"",
            "                        \"addresses after %d tries: %s\",",
            "                        DHCP_RELEASE_TRIES,",
            "                        ', '.join(ip for ip, m, c in entries_to_release))",
            "",
            "    def _output_addn_hosts_file(self):",
            "        \"\"\"Writes a dnsmasq compatible additional hosts file.",
            "",
            "        The generated file is sent to the --addn-hosts option of dnsmasq,",
            "        and lists the hosts on the network which should be resolved even if",
            "        the dnsmasq instance did not give a lease to the host (see the",
            "        `_output_hosts_file` method).",
            "        Each line in this file is in the same form as a standard /etc/hosts",
            "        file.",
            "        \"\"\"",
            "        buf = io.StringIO()",
            "        for host_tuple in self._iter_hosts():",
            "            port, alloc, hostname, fqdn, no_dhcp, no_opts, tag = host_tuple",
            "            # It is compulsory to write the `fqdn` before the `hostname` in",
            "            # order to obtain it in PTR responses.",
            "            if alloc:",
            "                buf.write('%s\\t%s %s\\n' % (alloc.ip_address, fqdn, hostname))",
            "        addn_hosts = self.get_conf_file_name('addn_hosts')",
            "        file_utils.replace_file(addn_hosts, buf.getvalue())",
            "        return addn_hosts",
            "",
            "    def _output_opts_file(self):",
            "        \"\"\"Write a dnsmasq compatible options file.\"\"\"",
            "        options, subnet_index_map = self._generate_opts_per_subnet()",
            "        options += self._generate_opts_per_port(subnet_index_map)",
            "",
            "        name = self.get_conf_file_name('opts')",
            "        file_utils.replace_file(name, '\\n'.join(options))",
            "        return name",
            "",
            "    def _generate_opts_per_subnet(self):",
            "        options = []",
            "        subnets_without_nameservers = set()",
            "        if self.conf.enable_isolated_metadata or self.conf.force_metadata:",
            "            subnet_to_interface_ip = self._make_subnet_interface_ip_map()",
            "        isolated_subnets = self.get_isolated_subnets(self.network)",
            "        for subnet in self._get_all_subnets(self.network):",
            "            addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "            segment_id = getattr(subnet, 'segment_id', None)",
            "            if (not subnet.enable_dhcp or",
            "                (subnet.ip_version == 6 and",
            "                 addr_mode == constants.IPV6_SLAAC)):",
            "                continue",
            "            if subnet.dns_nameservers:",
            "                if ((subnet.ip_version == 4 and",
            "                     subnet.dns_nameservers == ['0.0.0.0']) or",
            "                    (subnet.ip_version == 6 and",
            "                     subnet.dns_nameservers == ['::'])):",
            "                    # Special case: Do not announce DNS servers",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'dns-server'))",
            "                else:",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'dns-server', ','.join(",
            "                                Dnsmasq._convert_to_literal_addrs(",
            "                                    subnet.ip_version,",
            "                                    subnet.dns_nameservers))))",
            "            else:",
            "                # use the dnsmasq ip as nameservers only if there is no",
            "                # dns-server submitted by the server",
            "                # Here is something to check still",
            "                subnets_without_nameservers.add(subnet.id)",
            "",
            "            if self.conf.dns_domain and subnet.ip_version == 6:",
            "                # This should be change also",
            "                options.append(",
            "                    self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        \"domain-search\", ''.join(self.conf.dns_domain)))",
            "",
            "            gateway = subnet.gateway_ip",
            "            host_routes = []",
            "            for hr in subnet.host_routes:",
            "                if hr.destination == constants.IPv4_ANY:",
            "                    if not gateway:",
            "                        gateway = hr.nexthop",
            "                else:",
            "                    host_routes.append(\"%s,%s\" % (hr.destination, hr.nexthop))",
            "",
            "            # Add host routes for isolated network segments",
            "",
            "            if ((self.conf.force_metadata or",
            "                 (isolated_subnets[subnet.id] and",
            "                     self.conf.enable_isolated_metadata)) and",
            "                    subnet.ip_version == 4):",
            "                subnet_dhcp_ip = subnet_to_interface_ip.get(subnet.id)",
            "                if subnet_dhcp_ip:",
            "                    host_routes.append(",
            "                        '%s,%s' % (constants.METADATA_CIDR, subnet_dhcp_ip)",
            "                    )",
            "            elif not isolated_subnets[subnet.id] and gateway:",
            "                host_routes.append(",
            "                    '%s,%s' % (constants.METADATA_CIDR, gateway)",
            "                )",
            "",
            "            if subnet.ip_version == 4:",
            "                for s in self._get_all_subnets(self.network):",
            "                    sub_segment_id = getattr(s, 'segment_id', None)",
            "                    if (s.ip_version == 4 and",
            "                            s.cidr != subnet.cidr and",
            "                            sub_segment_id == segment_id):",
            "                        host_routes.insert(0, \"%s,0.0.0.0\" % s.cidr)",
            "",
            "                if host_routes:",
            "                    if gateway:",
            "                        host_routes.append(\"%s,%s\" % (constants.IPv4_ANY,",
            "                                                      gateway))",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            'classless-static-route',",
            "                            ','.join(host_routes)))",
            "                    options.append(",
            "                        self._format_option(",
            "                            subnet.ip_version,",
            "                            self._SUBNET_TAG_PREFIX % subnet.id,",
            "                            WIN2k3_STATIC_DNS,",
            "                            ','.join(host_routes)))",
            "",
            "                if gateway:",
            "                    options.append(self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        'router', gateway))",
            "                else:",
            "                    options.append(self._format_option(",
            "                        subnet.ip_version, self._SUBNET_TAG_PREFIX % subnet.id,",
            "                        'router'))",
            "        return options, subnets_without_nameservers",
            "",
            "    def _generate_opts_per_port(self, subnets_without_nameservers):",
            "        options = []",
            "        dhcp_ips = collections.defaultdict(list)",
            "        for port in self.network.ports:",
            "            if self._get_port_extra_dhcp_opts(port):",
            "                port_ip_versions = set(",
            "                    [netaddr.IPAddress(ip.ip_address).version",
            "                     for ip in port.fixed_ips])",
            "                for opt in port.extra_dhcp_opts:",
            "                    if opt.opt_name in (edo_ext.DHCP_OPT_CLIENT_ID,",
            "                                        DHCP_OPT_CLIENT_ID_NUM,",
            "                                        str(DHCP_OPT_CLIENT_ID_NUM)):",
            "                        continue",
            "                    opt_ip_version = opt.ip_version",
            "                    if opt_ip_version in port_ip_versions:",
            "                        options.append(",
            "                            self._format_option(",
            "                                opt_ip_version,",
            "                                self._PORT_TAG_PREFIX % port.id,",
            "                                opt.opt_name, opt.opt_value))",
            "                    else:",
            "                        LOG.info(\"Cannot apply dhcp option %(opt)s \"",
            "                                 \"because it's ip_version %(version)d \"",
            "                                 \"is not in port's address IP versions\",",
            "                                 {'opt': opt.opt_name,",
            "                                  'version': opt_ip_version})",
            "",
            "            # provides all dnsmasq ip as dns-server if there is more than",
            "            # one dnsmasq for a subnet and there is no dns-server submitted",
            "            # by the server",
            "            if port.device_owner == constants.DEVICE_OWNER_DHCP:",
            "                for ip in port.fixed_ips:",
            "                    if ip.subnet_id not in subnets_without_nameservers:",
            "                        continue",
            "                    dhcp_ips[ip.subnet_id].append(ip.ip_address)",
            "",
            "        for subnet_id, ips in dhcp_ips.items():",
            "            for ip_version in (4, 6):",
            "                vx_ips = [ip for ip in ips",
            "                          if netaddr.IPAddress(ip).version == ip_version]",
            "                if len(vx_ips) > 1:",
            "                    options.append(",
            "                        self._format_option(",
            "                            ip_version, self._SUBNET_TAG_PREFIX % subnet_id,",
            "                            'dns-server',",
            "                            ','.join(",
            "                                Dnsmasq._convert_to_literal_addrs(ip_version,",
            "                                                                  vx_ips))))",
            "        return options",
            "",
            "    def _make_subnet_interface_ip_map(self):",
            "        subnet_lookup = dict(",
            "            (netaddr.IPNetwork(subnet.cidr), subnet.id)",
            "            for subnet in self.network.subnets",
            "        )",
            "",
            "        retval = {}",
            "",
            "        for addr in ip_lib.get_devices_with_ip(self.network.namespace,",
            "                                               name=self.interface_name):",
            "            ip_net = netaddr.IPNetwork(addr['cidr'])",
            "",
            "            if ip_net in subnet_lookup:",
            "                retval[subnet_lookup[ip_net]] = addr['cidr'].split('/')[0]",
            "",
            "        return retval",
            "",
            "    def _format_option(self, ip_version, tag, option, *args):",
            "        \"\"\"Format DHCP option by option name or code.\"\"\"",
            "        option = str(option)",
            "        pattern = \"(tag:(.*),)?(.*)$\"",
            "        matches = re.match(pattern, option)",
            "        extra_tag = matches.groups()[0]",
            "        option = matches.groups()[2]",
            "",
            "        # NOTE(TheJulia): prepending option6 to any DHCPv6 option is",
            "        # indicated as required in the dnsmasq man page for version 2.79.",
            "        # Testing reveals that the man page is correct, option is not",
            "        # honored if not in the format \"option6:$NUM\".  For IPv4 we",
            "        # only apply if the option is non-numeric.",
            "        if ip_version == constants.IP_VERSION_6:",
            "            option = 'option6:%s' % option",
            "        elif not option.isdigit():",
            "            option = 'option:%s' % option",
            "        if extra_tag:",
            "            tags = ['tag:' + tag, extra_tag[:-1], '%s' % option]",
            "        else:",
            "            tags = ['tag:' + tag, '%s' % option]",
            "",
            "        return ','.join(tags + [v.split(\"\\n\", 1)[0] for v in args])",
            "",
            "    @staticmethod",
            "    def _convert_to_literal_addrs(ip_version, ips):",
            "        if ip_version == 4:",
            "            return ips",
            "        return ['[' + ip + ']' for ip in ips]",
            "",
            "    @classmethod",
            "    def get_isolated_subnets(cls, network):",
            "        \"\"\"Returns a dict indicating whether or not a subnet is isolated",
            "",
            "        A subnet is considered non-isolated if there is a port connected to",
            "        the subnet, and the port's ip address matches that of the subnet's",
            "        gateway. The port must be owned by a neutron router.",
            "        \"\"\"",
            "        isolated_subnets = collections.defaultdict(lambda: True)",
            "        all_subnets = cls._get_all_subnets(network)",
            "        subnets = dict((subnet.id, subnet) for subnet in all_subnets)",
            "",
            "        for port in network.ports:",
            "            if port.device_owner not in constants.ROUTER_INTERFACE_OWNERS:",
            "                continue",
            "            for alloc in port.fixed_ips:",
            "                if (alloc.subnet_id in subnets and",
            "                        subnets[alloc.subnet_id].gateway_ip ==",
            "                        alloc.ip_address):",
            "                    isolated_subnets[alloc.subnet_id] = False",
            "",
            "        return isolated_subnets",
            "",
            "    @staticmethod",
            "    def has_metadata_subnet(subnets):",
            "        \"\"\"Check if the subnets has a metadata subnet.\"\"\"",
            "        meta_cidr = netaddr.IPNetwork(constants.METADATA_V4_SUBNET)",
            "        if any(netaddr.IPNetwork(s.cidr) in meta_cidr",
            "               for s in subnets):",
            "            return True",
            "        return False",
            "",
            "    @classmethod",
            "    def should_enable_metadata(cls, conf, network):",
            "        \"\"\"Determine whether the metadata proxy is needed for a network",
            "",
            "        This method returns True for truly isolated networks (ie: not attached",
            "        to a router) when enable_isolated_metadata is True, or for all the",
            "        networks when the force_metadata flags is True.",
            "",
            "        This method also returns True when enable_metadata_network is True,",
            "        and the network passed as a parameter has a subnet in the link-local",
            "        CIDR, thus characterizing it as a \"metadata\" network. The metadata",
            "        network is used by solutions which do not leverage the l3 agent for",
            "        providing access to the metadata service via logical routers built",
            "        with 3rd party backends.",
            "        \"\"\"",
            "        all_subnets = cls._get_all_subnets(network)",
            "        dhcp_subnets = [s for s in all_subnets if s.enable_dhcp]",
            "        if not dhcp_subnets:",
            "            return False",
            "",
            "        if conf.force_metadata:",
            "            return True",
            "",
            "        if not conf.enable_isolated_metadata:",
            "            return False",
            "",
            "        if (conf.enable_metadata_network and",
            "                cls.has_metadata_subnet(all_subnets)):",
            "            return True",
            "",
            "        isolated_subnets = cls.get_isolated_subnets(network)",
            "        return any(isolated_subnets[s.id] for s in dhcp_subnets)",
            "",
            "",
            "class DeviceManager(object):",
            "",
            "    def __init__(self, conf, plugin):",
            "        self.conf = conf",
            "        self.plugin = plugin",
            "        self.driver = agent_common_utils.load_interface_driver(",
            "            conf,",
            "            get_networks_callback=self.plugin.get_networks)",
            "",
            "    def get_interface_name(self, network, port):",
            "        \"\"\"Return interface(device) name for use by the DHCP process.\"\"\"",
            "        return self.driver.get_device_name(port)",
            "",
            "    def get_device_id(self, network):",
            "        \"\"\"Return a unique DHCP device ID for this host on the network.\"\"\"",
            "        # There could be more than one dhcp server per network, so create",
            "        # a device id that combines host and network ids",
            "        return common_utils.get_dhcp_agent_device_id(network.id,",
            "                                                     self.conf.host)",
            "",
            "    def _set_default_route_ip_version(self, network, device_name, ip_version):",
            "        device = ip_lib.IPDevice(device_name, namespace=network.namespace)",
            "        gateway = device.route.get_gateway(ip_version=ip_version)",
            "        if gateway:",
            "            gateway = gateway.get('gateway')",
            "",
            "        for subnet in network.subnets:",
            "            skip_subnet = (",
            "                subnet.ip_version != ip_version or",
            "                not subnet.enable_dhcp or",
            "                subnet.gateway_ip is None)",
            "",
            "            if skip_subnet:",
            "                continue",
            "",
            "            if subnet.ip_version == constants.IP_VERSION_6:",
            "                # This is duplicating some of the API checks already done,",
            "                # but some of the functional tests call directly",
            "                prefixlen = netaddr.IPNetwork(subnet.cidr).prefixlen",
            "                if prefixlen == 0 or prefixlen > 126:",
            "                    continue",
            "                modes = [constants.IPV6_SLAAC, constants.DHCPV6_STATELESS]",
            "                addr_mode = getattr(subnet, 'ipv6_address_mode', None)",
            "                ra_mode = getattr(subnet, 'ipv6_ra_mode', None)",
            "                if (prefixlen != 64 and",
            "                        (addr_mode in modes or ra_mode in modes)):",
            "                    continue",
            "",
            "            if gateway != subnet.gateway_ip:",
            "                LOG.debug('Setting IPv%(version)s gateway for dhcp netns '",
            "                          'on net %(n)s to %(ip)s',",
            "                          {'n': network.id, 'ip': subnet.gateway_ip,",
            "                           'version': ip_version})",
            "",
            "                # Check for and remove the on-link route for the old",
            "                # gateway being replaced, if it is outside the subnet",
            "                is_old_gateway_not_in_subnet = (gateway and",
            "                                                not ipam_utils.check_subnet_ip(",
            "                                                        subnet.cidr, gateway))",
            "                if is_old_gateway_not_in_subnet:",
            "                    onlink = device.route.list_onlink_routes(ip_version)",
            "                    existing_onlink_routes = set(r['cidr'] for r in onlink)",
            "                    if gateway in existing_onlink_routes:",
            "                        device.route.delete_route(gateway, scope='link')",
            "",
            "                is_new_gateway_not_in_subnet = (subnet.gateway_ip and",
            "                                                not ipam_utils.check_subnet_ip(",
            "                                                        subnet.cidr,",
            "                                                        subnet.gateway_ip))",
            "                if is_new_gateway_not_in_subnet:",
            "                    device.route.add_route(subnet.gateway_ip, scope='link')",
            "                device.route.add_gateway(subnet.gateway_ip)",
            "",
            "            return",
            "",
            "        # No subnets on the network have a valid gateway.  Clean it up to avoid",
            "        # confusion from seeing an invalid gateway here.",
            "        if gateway is not None:",
            "            LOG.debug('Removing IPv%(version)s gateway for dhcp netns on '",
            "                      'net %(n)s',",
            "                      {'n': network.id, 'version': ip_version})",
            "",
            "            device.route.delete_gateway(gateway)",
            "",
            "    def _set_default_route(self, network, device_name):",
            "        \"\"\"Sets the default gateway for this dhcp namespace.",
            "",
            "        This method is idempotent and will only adjust the route if adjusting",
            "        it would change it from what it already is.  This makes it safe to call",
            "        and avoids unnecessary perturbation of the system.",
            "        \"\"\"",
            "        for ip_version in (constants.IP_VERSION_4, constants.IP_VERSION_6):",
            "            self._set_default_route_ip_version(network, device_name,",
            "                                               ip_version)",
            "",
            "    def _setup_existing_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Set up the existing DHCP port, if there is one.\"\"\"",
            "",
            "        # To avoid pylint thinking that port might be undefined after",
            "        # the following loop...",
            "        port = None",
            "",
            "        # Look for an existing DHCP port for this network.",
            "        for port in network.ports:",
            "            port_device_id = getattr(port, 'device_id', None)",
            "            if port_device_id == device_id:",
            "                # If using gateway IPs on this port, we can skip the",
            "                # following code, whose purpose is just to review and",
            "                # update the Neutron-allocated IP addresses for the",
            "                # port.",
            "                if self.driver.use_gateway_ips:",
            "                    return port",
            "                # Otherwise break out, as we now have the DHCP port",
            "                # whose subnets and addresses we need to review.",
            "                break",
            "        else:",
            "            return None",
            "",
            "        # Compare what the subnets should be against what is already",
            "        # on the port.",
            "        dhcp_enabled_subnet_ids = set(dhcp_subnets)",
            "        port_subnet_ids = set(ip.subnet_id for ip in port.fixed_ips)",
            "",
            "        # If those differ, we need to call update.",
            "        if dhcp_enabled_subnet_ids != port_subnet_ids:",
            "            # Collect the subnets and fixed IPs that the port already",
            "            # has, for subnets that are still in the DHCP-enabled set.",
            "            wanted_fixed_ips = []",
            "            for fixed_ip in port.fixed_ips:",
            "                if fixed_ip.subnet_id in dhcp_enabled_subnet_ids:",
            "                    wanted_fixed_ips.append(",
            "                        {'subnet_id': fixed_ip.subnet_id,",
            "                         'ip_address': fixed_ip.ip_address})",
            "",
            "            # Add subnet IDs for new DHCP-enabled subnets.",
            "            wanted_fixed_ips.extend(",
            "                dict(subnet_id=s)",
            "                for s in dhcp_enabled_subnet_ids - port_subnet_ids)",
            "",
            "            # Update the port to have the calculated subnets and fixed",
            "            # IPs.  The Neutron server will allocate a fresh IP for",
            "            # each subnet that doesn't already have one.",
            "            port = self.plugin.update_dhcp_port(",
            "                port.id,",
            "                {'port': {'network_id': network.id,",
            "                          'fixed_ips': wanted_fixed_ips}})",
            "            if not port:",
            "                raise exceptions.Conflict()",
            "",
            "        return port",
            "",
            "    def _setup_reserved_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Setup the reserved DHCP port, if there is one.\"\"\"",
            "        LOG.debug('DHCP port %(device_id)s on network %(network_id)s'",
            "                  ' does not yet exist. Checking for a reserved port.',",
            "                  {'device_id': device_id, 'network_id': network.id})",
            "        for port in network.ports:",
            "            port_device_id = getattr(port, 'device_id', None)",
            "            if port_device_id == constants.DEVICE_ID_RESERVED_DHCP_PORT:",
            "                port = self.plugin.update_dhcp_port(",
            "                    port.id, {'port': {'network_id': network.id,",
            "                                       'device_id': device_id}})",
            "                if port:",
            "                    return port",
            "",
            "    def _setup_new_dhcp_port(self, network, device_id, dhcp_subnets):",
            "        \"\"\"Create and set up new DHCP port for the specified network.\"\"\"",
            "        LOG.debug('DHCP port %(device_id)s on network %(network_id)s'",
            "                  ' does not yet exist. Creating new one.',",
            "                  {'device_id': device_id, 'network_id': network.id})",
            "",
            "        # Make a list of the subnets that need a unique IP address for",
            "        # this DHCP port.",
            "        if self.driver.use_gateway_ips:",
            "            unique_ip_subnets = []",
            "        else:",
            "            unique_ip_subnets = [dict(subnet_id=s) for s in dhcp_subnets]",
            "",
            "        port_dict = dict(",
            "            name='',",
            "            admin_state_up=True,",
            "            device_id=device_id,",
            "            network_id=network.id,",
            "            tenant_id=network.tenant_id,",
            "            fixed_ips=unique_ip_subnets)",
            "        return self.plugin.create_dhcp_port({'port': port_dict})",
            "",
            "    def _check_dhcp_port_subnet(self, dhcp_port, dhcp_subnets, network):",
            "        \"\"\"Check if DHCP port IPs are in the range of the DHCP subnets",
            "",
            "        FIXME(kevinbenton): ensure we have the IPs we actually need.",
            "        can be removed once bug/1627480 is fixed",
            "        \"\"\"",
            "        if self.driver.use_gateway_ips:",
            "            return",
            "",
            "        expected = set(dhcp_subnets)",
            "        actual = {fip.subnet_id for fip in dhcp_port.fixed_ips}",
            "        missing = expected - actual",
            "        if not missing:",
            "            return",
            "",
            "        LOG.debug('Requested DHCP port with IPs on subnets %(expected)s '",
            "                  'but only got IPs on subnets %(actual)s.',",
            "                  {'expected': expected, 'actual': actual})",
            "        updated_dhcp_port = self.plugin.get_dhcp_port(dhcp_port.id)",
            "        actual = {fip.subnet_id for fip in updated_dhcp_port.fixed_ips}",
            "        missing = expected - actual",
            "        if missing:",
            "            raise exceptions.SubnetMismatchForPort(",
            "                port_id=updated_dhcp_port.id, subnet_id=list(missing)[0])",
            "",
            "        self._update_dhcp_port(network, updated_dhcp_port)",
            "        LOG.debug('Previous DHCP port information: %(dhcp_port)s. Updated '",
            "                  'DHCP port information: %(updated_dhcp_port)s.',",
            "                  {'dhcp_port': dhcp_port,",
            "                   'updated_dhcp_port': updated_dhcp_port})",
            "",
            "    def setup_dhcp_port(self, network):",
            "        \"\"\"Create/update DHCP port for the host if needed and return port.\"\"\"",
            "",
            "        # The ID that the DHCP port will have (or already has).",
            "        device_id = self.get_device_id(network)",
            "",
            "        # Get the set of DHCP-enabled local subnets on this network.",
            "        dhcp_subnets = {subnet.id: subnet for subnet in network.subnets",
            "                        if subnet.enable_dhcp}",
            "",
            "        # There are 3 cases: either the DHCP port already exists (but",
            "        # might need to be updated for a changed set of subnets); or",
            "        # some other code has already prepared a 'reserved' DHCP port,",
            "        # and we just need to adopt that; or we need to create a new",
            "        # DHCP port.  Try each of those in turn until we have a DHCP",
            "        # port.",
            "        for setup_method in (self._setup_existing_dhcp_port,",
            "                             self._setup_reserved_dhcp_port,",
            "                             self._setup_new_dhcp_port):",
            "            dhcp_port = setup_method(network, device_id, dhcp_subnets)",
            "            if dhcp_port:",
            "                break",
            "        else:",
            "            raise exceptions.Conflict()",
            "",
            "        self._check_dhcp_port_subnet(dhcp_port, dhcp_subnets, network)",
            "",
            "        # Convert subnet_id to subnet dict",
            "        fixed_ips = [dict(subnet_id=fixed_ip.subnet_id,",
            "                          ip_address=fixed_ip.ip_address,",
            "                          subnet=dhcp_subnets[fixed_ip.subnet_id])",
            "                     for fixed_ip in dhcp_port.fixed_ips",
            "                     # we don't care about any ips on subnets irrelevant",
            "                     # to us (e.g. auto ipv6 addresses)",
            "                     if fixed_ip.subnet_id in dhcp_subnets]",
            "",
            "        ips = [DictModel(item) if isinstance(item, dict) else item",
            "               for item in fixed_ips]",
            "        dhcp_port.fixed_ips = ips",
            "",
            "        return dhcp_port",
            "",
            "    def _update_dhcp_port(self, network, port):",
            "        for index in range(len(network.ports)):",
            "            if network.ports[index].id == port.id:",
            "                network.ports[index] = port",
            "                break",
            "        else:",
            "            network.ports.append(port)",
            "",
            "    def _cleanup_stale_devices(self, network, dhcp_port):",
            "        \"\"\"Unplug any devices found in the namespace except for dhcp_port.\"\"\"",
            "        LOG.debug(\"Cleaning stale devices for network %s\", network.id)",
            "        skip_dev_name = (self.driver.get_device_name(dhcp_port)",
            "                         if dhcp_port else None)",
            "        ns_ip = ip_lib.IPWrapper(namespace=network.namespace)",
            "        if not ns_ip.netns.exists(network.namespace):",
            "            return",
            "        for d in ns_ip.get_devices():",
            "            # delete all devices except current active DHCP port device",
            "            if d.name != skip_dev_name:",
            "                LOG.debug(\"Found stale device %s, deleting\", d.name)",
            "                try:",
            "                    self.unplug(d.name, network)",
            "                except Exception:",
            "                    LOG.exception(\"Exception during stale \"",
            "                                  \"dhcp device cleanup\")",
            "",
            "    def plug(self, network, port, interface_name):",
            "        \"\"\"Plug device settings for the network's DHCP on this host.\"\"\"",
            "        self.driver.plug(network.id,",
            "                         port.id,",
            "                         interface_name,",
            "                         port.mac_address,",
            "                         namespace=network.namespace,",
            "                         mtu=network.get('mtu'))",
            "",
            "    def setup(self, network):",
            "        \"\"\"Create and initialize a device for network's DHCP on this host.\"\"\"",
            "        try:",
            "            port = self.setup_dhcp_port(network)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                # clear everything out so we don't leave dangling interfaces",
            "                # if setup never succeeds in the future.",
            "                self._cleanup_stale_devices(network, dhcp_port=None)",
            "        self._update_dhcp_port(network, port)",
            "        interface_name = self.get_interface_name(network, port)",
            "",
            "        # Disable acceptance of RAs in the namespace so we don't",
            "        # auto-configure an IPv6 address since we explicitly configure",
            "        # them on the device.  This must be done before any interfaces",
            "        # are plugged since it could receive an RA by the time",
            "        # plug() returns, so we have to create the namespace first.",
            "        # It must also be done in the case there is an existing IPv6",
            "        # address here created via SLAAC, since it will be deleted",
            "        # and added back statically in the call to init_l3() below.",
            "        if network.namespace:",
            "            ip_lib.IPWrapper().ensure_namespace(network.namespace)",
            "            ip_lib.set_ip_nonlocal_bind_for_namespace(network.namespace, 1,",
            "                                                      root_namespace=True)",
            "        if netutils.is_ipv6_enabled():",
            "            self.driver.configure_ipv6_ra(network.namespace, 'default',",
            "                                          constants.ACCEPT_RA_DISABLED)",
            "",
            "        if ip_lib.ensure_device_is_ready(interface_name,",
            "                                         namespace=network.namespace):",
            "            LOG.debug('Reusing existing device: %s.', interface_name)",
            "            # force mtu on the port for in case it was changed for the network",
            "            mtu = getattr(network, 'mtu', 0)",
            "            if mtu:",
            "                self.driver.set_mtu(interface_name, mtu,",
            "                                    namespace=network.namespace)",
            "        else:",
            "            try:",
            "                self.plug(network, port, interface_name)",
            "            except Exception:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.exception('Unable to plug DHCP port for '",
            "                                  'network %s. Releasing port.',",
            "                                  network.id)",
            "                    # We should unplug the interface in bridge side.",
            "                    self.unplug(interface_name, network)",
            "                    self.plugin.release_dhcp_port(network.id, port.device_id)",
            "",
            "            self.fill_dhcp_udp_checksums(namespace=network.namespace)",
            "        ip_cidrs = []",
            "        for fixed_ip in port.fixed_ips:",
            "            subnet = fixed_ip.subnet",
            "            net = netaddr.IPNetwork(subnet.cidr)",
            "            ip_cidr = '%s/%s' % (fixed_ip.ip_address, net.prefixlen)",
            "            ip_cidrs.append(ip_cidr)",
            "",
            "        if self.driver.use_gateway_ips:",
            "            # For each DHCP-enabled subnet, add that subnet's gateway",
            "            # IP address to the Linux device for the DHCP port.",
            "            for subnet in network.subnets:",
            "                if not subnet.enable_dhcp:",
            "                    continue",
            "                gateway = subnet.gateway_ip",
            "                if gateway:",
            "                    net = netaddr.IPNetwork(subnet.cidr)",
            "                    ip_cidrs.append('%s/%s' % (gateway, net.prefixlen))",
            "",
            "        if self.conf.force_metadata or self.conf.enable_isolated_metadata:",
            "            ip_cidrs.append(constants.METADATA_CIDR)",
            "            if netutils.is_ipv6_enabled():",
            "                ip_cidrs.append(constants.METADATA_V6_CIDR)",
            "",
            "        self.driver.init_l3(interface_name, ip_cidrs,",
            "                            namespace=network.namespace)",
            "",
            "        self._set_default_route(network, interface_name)",
            "        self._cleanup_stale_devices(network, port)",
            "",
            "        return interface_name",
            "",
            "    def update(self, network, device_name):",
            "        \"\"\"Update device settings for the network's DHCP on this host.\"\"\"",
            "        self._set_default_route(network, device_name)",
            "",
            "    def unplug(self, device_name, network):",
            "        \"\"\"Unplug device settings for the network's DHCP on this host.\"\"\"",
            "        self.driver.unplug(device_name, namespace=network.namespace)",
            "",
            "    def destroy(self, network, device_name):",
            "        \"\"\"Destroy the device used for the network's DHCP on this host.\"\"\"",
            "        if device_name:",
            "            self.unplug(device_name, network)",
            "        else:",
            "            LOG.debug('No interface exists for network %s', network.id)",
            "",
            "        self.plugin.release_dhcp_port(network.id,",
            "                                      self.get_device_id(network))",
            "",
            "    def fill_dhcp_udp_checksums(self, namespace):",
            "        \"\"\"Ensure DHCP reply packets always have correct UDP checksums.\"\"\"",
            "        iptables_mgr = iptables_manager.IptablesManager(",
            "            use_ipv6=netutils.is_ipv6_enabled(), nat=False,",
            "            namespace=namespace)",
            "        ipv4_rule = ('-p udp -m udp --dport %d -j CHECKSUM --checksum-fill'",
            "                     % constants.DHCP_CLIENT_PORT)",
            "        ipv6_rule = ('-p udp -m udp --dport %d -j CHECKSUM --checksum-fill'",
            "                     % constants.DHCPV6_CLIENT_PORT)",
            "        iptables_mgr.ipv4['mangle'].add_rule('POSTROUTING', ipv4_rule)",
            "        iptables_mgr.ipv6['mangle'].add_rule('POSTROUTING', ipv6_rule)",
            "        iptables_mgr.apply()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1325": [
                "Dnsmasq",
                "_format_option"
            ],
            "1327": [
                "Dnsmasq",
                "_format_option"
            ],
            "1328": [
                "Dnsmasq",
                "_format_option"
            ]
        },
        "addLocation": []
    },
    "neutron/tests/unit/agent/linux/test_dhcp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         self.extra_dhcp_opts = ["
            },
            "1": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "             DhcpOpt(opt_name='dns-server',"
            },
            "2": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "                     opt_value='ffea:3ba5:a17a:4ba3::100',"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                    ip_version=constants.IP_VERSION_6),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+            DhcpOpt(opt_name='malicious-option',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                    opt_value='aaa\\nbbb.ccc\\n',"
            },
            "6": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "                     ip_version=constants.IP_VERSION_6)]"
            },
            "7": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 2910,
                "afterPatchRowNumber": 2913,
                "PatchRowcode": "         exp_opt_data = ('tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'"
            },
            "10": {
                "beforePatchRowNumber": 2911,
                "afterPatchRowNumber": 2914,
                "PatchRowcode": "                         'option6:domain-search,openstacklocal\\n'"
            },
            "11": {
                "beforePatchRowNumber": 2912,
                "afterPatchRowNumber": 2915,
                "PatchRowcode": "                         'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'"
            },
            "12": {
                "beforePatchRowNumber": 2913,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'option6:dns-server,ffea:3ba5:a17a:4ba3::100').lstrip()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2916,
                "PatchRowcode": "+                        'option6:dns-server,ffea:3ba5:a17a:4ba3::100\\n'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2917,
                "PatchRowcode": "+                        'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2918,
                "PatchRowcode": "+                        'option6:malicious-option,aaa').lstrip()"
            },
            "16": {
                "beforePatchRowNumber": 2914,
                "afterPatchRowNumber": 2919,
                "PatchRowcode": "         dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCP())"
            },
            "17": {
                "beforePatchRowNumber": 2915,
                "afterPatchRowNumber": 2920,
                "PatchRowcode": "         dm._output_hosts_file()"
            },
            "18": {
                "beforePatchRowNumber": 2916,
                "afterPatchRowNumber": 2921,
                "PatchRowcode": "         dm._output_opts_file()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import os",
            "from unittest import mock",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import extra_dhcp_opt as edo_ext",
            "from neutron_lib import constants",
            "from neutron_lib import exceptions",
            "from neutron_lib import fixture as lib_fixtures",
            "from oslo_config import cfg",
            "import oslo_messaging",
            "from oslo_utils import fileutils",
            "from oslo_utils import uuidutils",
            "import testtools",
            "",
            "from neutron.agent.linux import dhcp",
            "from neutron.agent.linux import ip_lib",
            "from neutron.cmd import runtime_checks as checks",
            "from neutron.conf.agent import common as config",
            "from neutron.conf.agent import dhcp as dhcp_config",
            "from neutron.conf import common as base_config",
            "from neutron.privileged.agent.linux import dhcp as priv_dhcp",
            "from neutron.tests import base",
            "",
            "",
            "class FakeIPAllocation(object):",
            "    def __init__(self, address, subnet_id=None):",
            "        self.ip_address = address",
            "        self.subnet_id = subnet_id",
            "",
            "",
            "class FakeDNSAssignment(object):",
            "    def __init__(self, ip_address, dns_name='', domain='openstacklocal'):",
            "        if dns_name:",
            "            self.hostname = dns_name",
            "        else:",
            "            self.hostname = 'host-%s' % ip_address.replace(",
            "                '.', '-').replace(':', '-')",
            "        self.ip_address = ip_address",
            "        self.fqdn = self.hostname",
            "        if domain:",
            "            self.fqdn = '%s.%s.' % (self.hostname, domain)",
            "",
            "",
            "class DhcpOpt(object):",
            "    def __init__(self, **kwargs):",
            "        self.__dict__.update(ip_version=constants.IP_VERSION_4)",
            "        self.__dict__.update(kwargs)",
            "",
            "    def __str__(self):",
            "        return str(self.__dict__)",
            "",
            "",
            "# A base class where class attributes can also be accessed by treating",
            "# an instance as a dict.",
            "class Dictable(object):",
            "    def __getitem__(self, k):",
            "        return self.__class__.__dict__.get(k)",
            "",
            "",
            "class FakeDhcpPort(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.1',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:80:aa:bb:ee'",
            "        self.device_id = 'fake_dhcp_port'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakeReservedPort(object):",
            "    def __init__(self, id='reserved-aaaa-aaaa-aaaa-aaaaaaaaaaa'):",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:80:aa:bb:ee'",
            "        self.device_id = constants.DEVICE_ID_RESERVED_DHCP_PORT",
            "        self.extra_dhcp_opts = []",
            "        self.id = id",
            "",
            "",
            "class FakePort1(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo1'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.2',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:80:aa:bb:cc'",
            "        self.device_id = 'fake_port1'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.2', domain=domain)]",
            "",
            "",
            "class FakePort2(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.admin_state_up = False",
            "        self.device_owner = 'foo2'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port2'",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.3')]",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort3(object):",
            "    def __init__(self):",
            "        self.id = '44444444-4444-4444-4444-444444444444'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.4',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('192.168.1.2',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.4'),",
            "                               FakeDNSAssignment('192.168.1.2')]",
            "        self.mac_address = '00:00:0f:aa:bb:cc'",
            "        self.device_id = 'fake_port3'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort4(object):",
            "    def __init__(self):",
            "        self.id = 'gggggggg-gggg-gggg-gggg-gggggggggggg'",
            "        self.admin_state_up = False",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.4',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('ffda:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('192.168.0.4'),",
            "            FakeDNSAssignment('ffda:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3E:C2:77:1D'",
            "        self.device_id = 'fake_port4'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort5(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeee'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo5'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.5',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.5')]",
            "        self.mac_address = '00:00:0f:aa:bb:55'",
            "        self.device_id = 'fake_port5'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=edo_ext.DHCP_OPT_CLIENT_ID,",
            "                    opt_value='test5')]",
            "",
            "",
            "class FakePort6(object):",
            "    def __init__(self):",
            "        self.id = 'ccccccccc-cccc-cccc-cccc-ccccccccc'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo6'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.6')]",
            "        self.mac_address = '00:00:0f:aa:bb:66'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=edo_ext.DHCP_OPT_CLIENT_ID,",
            "                    opt_value='test6',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='123.123.123.45',",
            "                    ip_version=constants.IP_VERSION_4)]",
            "",
            "",
            "class FakeV6Port(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('fdca:3ba5:a17a:4ba3::2',",
            "                               domain=domain)]",
            "",
            "",
            "class FakeV6PortExtraOpt(object):",
            "    def __init__(self):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3e:c2:77:1d'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='ffea:3ba5:a17a:4ba3::100',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeV6PortMultipleFixedIpsSameSubnet(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::4',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('fdca:3ba5:a17a:4ba3::2',",
            "                                                 domain=domain),",
            "                               FakeDNSAssignment('fdca:3ba5:a17a:4ba3::4',",
            "                                                 domain=domain)]",
            "",
            "",
            "class FakeDualPortWithV6ExtraOpt(object):",
            "    def __init__(self):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('192.168.0.3'),",
            "            FakeDNSAssignment('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3e:c2:77:1d'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='ffea:3ba5:a17a:4ba3::100',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeDualPort(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::3',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:0f:aa:bb:cc'",
            "        self.device_id = 'fake_dual_port'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.3', domain=domain),",
            "                               FakeDNSAssignment('fdca:3ba5:a17a:4ba3::3',",
            "                                                 domain=domain)]",
            "",
            "",
            "class FakeRouterPort(object):",
            "    def __init__(self, dev_owner=constants.DEVICE_OWNER_ROUTER_INTF,",
            "                 ip_address='192.168.0.1', domain='openstacklocal'):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.mac_address = '00:00:0f:rr:rr:rr'",
            "        self.device_id = 'fake_router_port'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.device_owner = dev_owner",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            ip_address, 'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment(ip.ip_address, domain=domain)",
            "                               for ip in self.fixed_ips]",
            "",
            "",
            "class FakeRouterHAPort(object):",
            "    def __init__(self):",
            "        self.id = 'hahahaha-haha-haha-haha-hahahahahaha'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_HA_INTF",
            "        self.mac_address = '00:00:0f:aa:aa:aa'",
            "        self.device_id = 'fake_router_ha_port'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            '169.254.169.20', 'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "",
            "",
            "class FakeRouterPortNoDHCP(object):",
            "    def __init__(self, dev_owner=constants.DEVICE_OWNER_ROUTER_INTF,",
            "                 ip_address='192.168.0.1', domain='openstacklocal'):",
            "        self.id = 'ssssssss-ssss-ssss-ssss-ssssssssssss'",
            "        self.admin_state_up = True",
            "        self.mac_address = '00:00:0f:rr:rr:rr'",
            "        self.device_id = 'fake_router_port_no_dhcp'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.device_owner = dev_owner",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            ip_address, 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [FakeDNSAssignment(ip.ip_address, domain=domain)",
            "                               for ip in self.fixed_ips]",
            "",
            "",
            "class FakeRouterPort2(object):",
            "    def __init__(self):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_INTF",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.1.1',",
            "                             'cccccccc-cccc-cccc-cccc-cccccccccccc')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.1.1')]",
            "        self.mac_address = '00:00:0f:rr:rr:r2'",
            "        self.device_id = 'fake_router_port2'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakeRouterPortSegmentID(object):",
            "    def __init__(self):",
            "        self.id = 'qqqqqqqq-qqqq-qqqq-qqqq-qqqqqqqqqqqq'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_INTF",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.2.1',",
            "                             'iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.2.1')]",
            "        self.mac_address = '00:00:0f:rr:rr:r3'",
            "        self.device_id = 'fake_router_port3'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortMultipleAgents1(object):",
            "    def __init__(self):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.5',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.5')]",
            "        self.mac_address = '00:00:0f:dd:dd:dd'",
            "        self.device_id = 'fake_multiple_agents_port'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortMultipleAgents2(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.6')]",
            "        self.mac_address = '00:00:0f:ee:ee:ee'",
            "        self.device_id = 'fake_multiple_agents_port2'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortWithClientIdNum(object):",
            "    def __init__(self):",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=dhcp.DHCP_OPT_CLIENT_ID_NUM,",
            "                    opt_value='test_client_id_num')]",
            "",
            "",
            "class FakePortWithClientIdNumStr(object):",
            "    def __init__(self):",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=str(dhcp.DHCP_OPT_CLIENT_ID_NUM),",
            "                    opt_value='test_client_id_num')]",
            "",
            "",
            "class FakeV4HostRoute(object):",
            "    def __init__(self):",
            "        self.destination = '20.0.0.1/24'",
            "        self.nexthop = '20.0.0.1'",
            "",
            "",
            "class FakeV4HostRouteGateway(object):",
            "    def __init__(self):",
            "        self.destination = constants.IPv4_ANY",
            "        self.nexthop = '10.0.0.1'",
            "",
            "",
            "class FakeV6HostRoute(object):",
            "    def __init__(self):",
            "        self.destination = '2001:0200:feed:7ac0::/64'",
            "        self.nexthop = '2001:0200:feed:7ac0::1'",
            "",
            "",
            "class FakeV4Subnet(Dictable):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.ip_version = constants.IP_VERSION_4",
            "        self.cidr = '192.168.0.0/24'",
            "        self.gateway_ip = '192.168.0.1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV4HostRoute()]",
            "        self.dns_nameservers = ['8.8.8.8']",
            "",
            "",
            "class FakeV4Subnet2(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4Subnet2, self).__init__()",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetSegmentID(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetSegmentID, self).__init__()",
            "        self.id = 'iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii'",
            "        self.cidr = '192.168.2.0/24'",
            "        self.gateway_ip = '192.168.2.1'",
            "        self.host_routes = []",
            "        self.segment_id = 1",
            "",
            "",
            "class FakeV4SubnetSegmentID2(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetSegmentID2, self).__init__()",
            "        self.id = 'jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj'",
            "        self.host_routes = []",
            "        self.segment_id = 2",
            "",
            "",
            "class FakeV4MetadataSubnet(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4MetadataSubnet, self).__init__()",
            "        self.cidr = '169.254.169.254/30'",
            "        self.gateway_ip = '169.254.169.253'",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4SubnetGatewayRoute(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetGatewayRoute, self).__init__()",
            "        self.host_routes = [FakeV4HostRouteGateway()]",
            "",
            "",
            "class FakeV4SubnetMultipleAgentsWithoutDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetMultipleAgentsWithoutDnsProvided, self).__init__()",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetAgentWithManyDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetAgentWithManyDnsProvided, self).__init__()",
            "        self.dns_nameservers = ['2.2.2.2', '9.9.9.9', '1.1.1.1', '3.3.3.3']",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetAgentWithNoDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetAgentWithNoDnsProvided, self).__init__()",
            "        self.dns_nameservers = ['0.0.0.0']",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4MultipleAgentsWithoutDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithoutDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1(), FakePortMultipleAgents2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithoutDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithoutDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithManyDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetAgentWithManyDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetAgentWithNoDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4SubnetMultipleAgentsWithDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetMultipleAgentsWithDnsProvided, self).__init__()",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4MultipleAgentsWithDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1(), FakePortMultipleAgents2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6Subnet(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'fdca:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'fdca:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.dns_nameservers = ['2001:0200:feed:7ac0::1']",
            "        self.ipv6_ra_mode = None",
            "        self.ipv6_address_mode = None",
            "",
            "",
            "class FakeV4SubnetNoDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_4",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.enable_dhcp = False",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV6SubnetDHCPStateful(Dictable):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'fdca:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'fdca:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.dns_nameservers = ['2001:0200:feed:7ac0::1']",
            "        self.ipv6_ra_mode = None",
            "        self.ipv6_address_mode = constants.DHCPV6_STATEFUL",
            "",
            "",
            "class FakeV6SubnetSlaac(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffda:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffda:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.ipv6_address_mode = constants.IPV6_SLAAC",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStateless(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffea:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffea:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStatelessNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffea:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffea:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = ['::']",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStatelessBadPrefixLength(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffeb:3ba5:a17a:4ba3::/56'",
            "        self.gateway_ip = 'ffeb:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV4SubnetNoGateway(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetNoGateway, self).__init__()",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = None",
            "        self.enable_dhcp = True",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4SubnetNoRouter(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetNoRouter, self).__init__()",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4Network(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientId(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort5(), FakePort6()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientIdNum(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePortWithClientIdNum()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientIdNumStr(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePortWithClientIdNumStr()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6Network(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6Subnet()]",
            "        self.ports = [FakePort2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetwork(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports = [FakePort1(domain=domain), FakeV6Port(domain=domain),",
            "                      FakeDualPort(domain=domain),",
            "                      FakeRouterHAPort(),",
            "                      FakeRouterPort(domain=domain)]",
            "",
            "",
            "class FakeDeviceManagerNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(),",
            "                      FakeV6Port(),",
            "                      FakeDualPort(),",
            "                      FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkReserved(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakeV6Port(), FakeDualPort(),",
            "                      FakeRouterPort(), FakeReservedPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkReserved2(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakeV6Port(), FakeDualPort(),",
            "                      FakeRouterPort(), FakeReservedPort(),",
            "                      FakeReservedPort(id='reserved-2')]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNetworkDhcpPort(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeDhcpPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkGatewayRoute(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetGatewayRoute(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkSingleDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetNoDHCP()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkSingleDHCPBothAttaced(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        # dhcp-agent actually can't get the subnet with dhcp disabled",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeRouterPortNoDHCP(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkDualDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4Subnet2()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPort2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkDualDHCPOnLinkSubnetRoutesDisabled(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNonLocalSubnets(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetSegmentID2()]",
            "        self.non_local_subnets = [FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkTriDHCPOneOnLinkSubnetRoute(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4Subnet2(),",
            "                        FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPort2(),",
            "                      FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NoGatewayNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetNoGateway()]",
            "        self.ports = [FakePort1()]",
            "",
            "",
            "class FakeV4NetworkNoRouter(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetNoRouter()]",
            "        self.ports = [FakePort1()]",
            "",
            "",
            "class FakeV4MetadataNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4MetadataSubnet()]",
            "        self.ports = [FakeRouterPort(ip_address='169.254.169.253')]",
            "",
            "",
            "class FakeV4NetworkDistRouter(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(),",
            "                      FakeRouterPort(",
            "                          dev_owner=constants.DEVICE_OWNER_DVR_INTERFACE)]",
            "",
            "",
            "class FakeDualV4Pxe3Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetNoDHCP()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "",
            "",
            "class FakeV4NetworkPxe2Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort2(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV4NetworkPxe3Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "",
            "",
            "class FakeV4NetworkPxePort(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='nd98', opt_value='option-nondigit-98',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='99', opt_value='option-99',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_4)]",
            "",
            "",
            "class FakeV6NetworkPxePort(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='2001:192:168::1',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='nd98', opt_value='option-nondigit-98',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='99', opt_value='option-99',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeV6NetworkPxePortWrongOptVersion(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeDualStackNetworkSingleDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetSlaac()]",
            "        self.ports = [FakePort1(), FakePort4(), FakeRouterPort()]",
            "",
            "",
            "class FakeDualStackNetworkingSingleDHCPTags(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetSlaac()]",
            "        self.ports = [FakePort1(), FakePort4(), FakeRouterPort()]",
            "        for port in self.ports:",
            "            port.extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tag:ipxe,bootfile-name',",
            "                        opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV4NetworkMultipleTags(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tag:ipxe,bootfile-name', opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV6NetworkStatelessDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStateless()]",
            "        self.ports = [FakeV6PortExtraOpt()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatelessDHCPNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStatelessNoDnsProvided()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatelessDHCPBadPrefixLength(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStatelessBadPrefixLength()]",
            "        self.ports = [FakeV6PortExtraOpt()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNetworkWithV6SatelessAndV4DHCPSubnets(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStateless(), FakeV4Subnet()]",
            "        self.ports = [FakeDualPortWithV6ExtraOpt(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatefulDHCPSameSubnetFixedIps(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6PortMultipleFixedIpsSameSubnet()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class LocalChild(dhcp.DhcpLocalProcess):",
            "    PORTS = {4: [4], 6: [6]}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.process_monitor = mock.Mock()",
            "        kwargs['process_monitor'] = self.process_monitor",
            "        super(LocalChild, self).__init__(*args, **kwargs)",
            "        self.called = []",
            "",
            "    def reload_allocations(self):",
            "        self.called.append('reload')",
            "",
            "    def spawn_process(self):",
            "        self.called.append('spawn')",
            "",
            "",
            "class TestConfBase(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestConfBase, self).setUp()",
            "        self.conf = config.setup_conf()",
            "        self.conf.register_opts(base_config.core_opts)",
            "        self.conf.register_opts(dhcp_config.DHCP_OPTS)",
            "        self.conf.register_opts(dhcp_config.DNSMASQ_OPTS)",
            "        self.conf.register_opts(config.DHCP_PROTOCOL_OPTS)",
            "        config.register_external_process_opts(self.conf)",
            "        config.register_interface_driver_opts_helper(self.conf)",
            "",
            "",
            "class TestBase(TestConfBase):",
            "    def setUp(self):",
            "        super(TestBase, self).setUp()",
            "        instance = mock.patch(\"neutron.agent.linux.dhcp.DeviceManager\")",
            "        self.mock_mgr = instance.start()",
            "        self.conf.register_opt(cfg.BoolOpt('enable_isolated_metadata',",
            "                                           default=True))",
            "        self.conf.register_opt(cfg.BoolOpt(\"force_metadata\",",
            "                                           default=False))",
            "        self.conf.register_opt(cfg.BoolOpt('enable_metadata_network',",
            "                                           default=False))",
            "        self.config_parse(self.conf)",
            "        self.conf.set_override('state_path', '')",
            "",
            "        self.replace_p = mock.patch('neutron_lib.utils.file.replace_file')",
            "        self.execute_p = mock.patch('neutron.agent.common.utils.execute')",
            "        mock.patch('neutron.agent.linux.utils.execute').start()",
            "        self.safe = self.replace_p.start()",
            "        self.execute = self.execute_p.start()",
            "",
            "        self.makedirs = mock.patch('os.makedirs').start()",
            "        self.rmtree = mock.patch('shutil.rmtree').start()",
            "",
            "        self.external_process = mock.patch(",
            "            'neutron.agent.linux.external_process.ProcessManager').start()",
            "",
            "        self.mock_mgr.return_value.driver.bridged = True",
            "",
            "",
            "class TestDhcpBase(TestBase):",
            "",
            "    def test_existing_dhcp_networks_abstract_error(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          dhcp.DhcpBase.existing_dhcp_networks,",
            "                          None)",
            "",
            "    def test_check_version_abstract_error(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          dhcp.DhcpBase.check_version)",
            "",
            "    def test_base_abc_error(self):",
            "        self.assertRaises(TypeError, dhcp.DhcpBase, None)",
            "",
            "    def test_restart(self):",
            "        class SubClass(dhcp.DhcpBase):",
            "            def __init__(self):",
            "                dhcp.DhcpBase.__init__(self, cfg.CONF, FakeV4Network(),",
            "                                       mock.Mock(), None)",
            "                self.called = []",
            "",
            "            def enable(self):",
            "                self.called.append('enable')",
            "",
            "            def disable(self, retain_port=False, block=False):",
            "                self.called.append('disable %s %s' % (retain_port, block))",
            "",
            "            def reload_allocations(self):",
            "                pass",
            "",
            "            @property",
            "            def active(self):",
            "                return True",
            "",
            "        c = SubClass()",
            "        c.restart()",
            "        self.assertEqual(c.called, ['disable True True', 'enable'])",
            "",
            "",
            "class TestDhcpLocalProcess(TestBase):",
            "",
            "    def test_get_conf_file_name(self):",
            "        tpl = '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/dev'",
            "        lp = LocalChild(self.conf, FakeV4Network())",
            "        self.assertEqual(lp.get_conf_file_name('dev'), tpl)",
            "",
            "    @mock.patch.object(fileutils, 'ensure_tree')",
            "    def test_ensure_dir_called(self, ensure_dir):",
            "        LocalChild(self.conf, FakeV4Network())",
            "        ensure_dir.assert_called_once_with(",
            "            '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', mode=0o755)",
            "",
            "    def test_enable_already_active(self):",
            "        with mock.patch.object(LocalChild, 'active') as patched:",
            "            patched.__get__ = mock.Mock(side_effect=[True, False])",
            "            lp = LocalChild(self.conf, FakeV4Network())",
            "            with mock.patch.object(ip_lib, 'delete_network_namespace'):",
            "                lp.enable()",
            "",
            "            self.assertEqual(lp.called, ['spawn'])",
            "            self.assertTrue(self.mock_mgr.return_value.setup.called)",
            "",
            "    @mock.patch.object(fileutils, 'ensure_tree')",
            "    def test_enable(self, ensure_dir):",
            "        attrs_to_mock = dict(",
            "            (a, mock.DEFAULT) for a in",
            "            ['active', 'interface_name', 'spawn_process']",
            "        )",
            "",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            mocks['interface_name'].__set__ = mock.Mock()",
            "            mocks['spawn_process'].side_effect = [",
            "                exceptions.ProcessExecutionError(",
            "                    returncode=2, message=\"Test dnsmasq start failed\"),",
            "                None]",
            "            lp = LocalChild(self.conf,",
            "                            FakeDualNetwork())",
            "",
            "            lp.enable()",
            "",
            "            self.mock_mgr.assert_has_calls(",
            "                [mock.call(self.conf, None),",
            "                 mock.call().setup(mock.ANY)])",
            "            self.assertEqual(2, mocks['interface_name'].__set__.call_count)",
            "            ensure_dir.assert_has_calls([",
            "                mock.call(",
            "                    '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc', mode=0o755),",
            "                mock.call(",
            "                    '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc', mode=0o755)])",
            "",
            "    def _assert_disabled(self, lp):",
            "        self.assertTrue(lp.process_monitor.unregister.called)",
            "        self.assertTrue(self.external_process().disable.called)",
            "",
            "    def test_disable_not_active(self):",
            "        attrs_to_mock = dict((a, mock.DEFAULT) for a in",
            "                             ['active', 'interface_name'])",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "            network = FakeDualNetwork()",
            "            lp = LocalChild(self.conf, network)",
            "            lp.device_manager = mock.Mock()",
            "            with mock.patch('neutron.agent.linux.ip_lib.'",
            "                            'delete_network_namespace') as delete_ns:",
            "                lp.disable()",
            "            lp.device_manager.destroy.assert_called_once_with(",
            "                network, 'tap0')",
            "            self._assert_disabled(lp)",
            "",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_disable_retain_port(self):",
            "        attrs_to_mock = dict((a, mock.DEFAULT) for a in",
            "                             ['active', 'interface_name'])",
            "        network = FakeDualNetwork()",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=True)",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "            lp = LocalChild(self.conf, network)",
            "            lp.disable(retain_port=True)",
            "            self.rmtree.assert_not_called()",
            "            self._assert_disabled(lp)",
            "",
            "    def test_disable(self):",
            "        attrs_to_mock = {'active': mock.DEFAULT}",
            "",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            lp = LocalChild(self.conf, FakeDualNetwork())",
            "            with mock.patch('neutron.agent.linux.ip_lib.'",
            "                            'delete_network_namespace') as delete_ns:",
            "                lp.disable()",
            "                self.rmtree.assert_called_once()",
            "",
            "            self._assert_disabled(lp)",
            "",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_disable_config_dir_removed_after_destroy(self):",
            "        parent = mock.MagicMock()",
            "        parent.attach_mock(self.rmtree, 'rmtree')",
            "        parent.attach_mock(self.mock_mgr, 'DeviceManager')",
            "",
            "        lp = LocalChild(self.conf, FakeDualNetwork())",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'delete_network_namespace') as delete_ns:",
            "            lp.disable(retain_port=False)",
            "",
            "        expected = [mock.call.DeviceManager().destroy(mock.ANY, mock.ANY),",
            "                    mock.call.rmtree(mock.ANY, ignore_errors=True)]",
            "        parent.assert_has_calls(expected)",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_get_interface_name(self):",
            "        net = FakeDualNetwork()",
            "        path = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(path, 'tap0'))",
            "        lp = LocalChild(self.conf, net)",
            "        self.assertEqual(lp.interface_name, 'tap0')",
            "",
            "    def test_set_interface_name(self):",
            "        with mock.patch('neutron_lib.utils.file.replace_file') as replace:",
            "            lp = LocalChild(self.conf, FakeDualNetwork())",
            "            with mock.patch.object(lp, 'get_conf_file_name') as conf_file:",
            "                conf_file.return_value = '/interface'",
            "                lp.interface_name = 'tap0'",
            "                conf_file.assert_called_once_with('interface')",
            "                replace.assert_called_once_with(mock.ANY, 'tap0')",
            "",
            "",
            "class TestDnsmasq(TestBase):",
            "",
            "    def setUp(self):",
            "        super(TestDnsmasq, self).setUp()",
            "        self._mock_get_devices_with_ip = mock.patch.object(",
            "            ip_lib, 'get_devices_with_ip')",
            "        self.mock_get_devices_with_ip = self._mock_get_devices_with_ip.start()",
            "        self.addCleanup(self._stop_mocks)",
            "",
            "    def _stop_mocks(self):",
            "        self._mock_get_devices_with_ip.stop()",
            "",
            "    def _get_dnsmasq(self, network, process_monitor=None):",
            "        process_monitor = process_monitor or mock.Mock()",
            "        return dhcp.Dnsmasq(self.conf, network,",
            "                            process_monitor=process_monitor)",
            "",
            "    def _test_spawn(self, extra_options, network=FakeDualNetwork(),",
            "                    max_leases=16777216, lease_duration=86400,",
            "                    has_static=True, no_resolv='--no-resolv',",
            "                    has_stateless=True, dhcp_t1=0, dhcp_t2=0,",
            "                    bridged=True):",
            "        def mock_get_conf_file_name(kind):",
            "            return '/dhcp/%s/%s' % (network.id, kind)",
            "",
            "        # Empty string passed to --conf-file in dnsmasq is invalid",
            "        # we must force '' to '/dev/null' because the dhcp agent",
            "        # does the same. Therefore we allow empty string to",
            "        # be passed to neutron but not to dnsmasq.",
            "        def check_conf_file_empty(cmd_list):",
            "            for i in cmd_list:",
            "                conf_file = ''",
            "                value = ''",
            "                if i.startswith('--conf-file='):",
            "                    conf_file = i",
            "                    value = i[12:].strip()",
            "                    if not value:",
            "                        idx = cmd_list.index(conf_file)",
            "                        cmd_list[idx] = '--conf-file=/dev/null'",
            "",
            "        # if you need to change this path here, think twice,",
            "        # that means pid files will move around, breaking upgrades",
            "        # or backwards-compatibility",
            "        expected_pid_file = '/dhcp/%s/pid' % network.id",
            "",
            "        expected = [",
            "            'dnsmasq',",
            "            '--no-hosts',",
            "            no_resolv,",
            "            '--pid-file=%s' % expected_pid_file,",
            "            '--dhcp-hostsfile=/dhcp/%s/host' % network.id,",
            "            '--addn-hosts=/dhcp/%s/addn_hosts' % network.id,",
            "            '--dhcp-optsfile=/dhcp/%s/opts' % network.id,",
            "            '--dhcp-leasefile=/dhcp/%s/leases' % network.id,",
            "            '--dhcp-match=set:ipxe,175',",
            "            '--dhcp-userclass=set:ipxe6,iPXE',",
            "            '--local-service',",
            "            '--bind-dynamic',",
            "        ]",
            "        if not bridged:",
            "            expected += [",
            "                '--bridge-interface=tap0,tap*'",
            "            ]",
            "",
            "        seconds = ''",
            "        if lease_duration == -1:",
            "            lease_duration = 'infinite'",
            "        else:",
            "            seconds = 's'",
            "        if has_static:",
            "            prefix = '--dhcp-range=set:subnet-%s,%s,static,%s,%s%s'",
            "            prefix6 = '--dhcp-range=set:subnet-%s,%s,static,%s,%s%s'",
            "        elif has_stateless:",
            "            prefix = '--dhcp-range=set:subnet-%s,%s,%s,%s%s'",
            "            prefix6 = '--dhcp-range=set:subnet-%s,%s,%s,%s%s'",
            "        possible_leases = 0",
            "        for s in network.subnets:",
            "            if (s.ip_version != constants.IP_VERSION_6 or",
            "                    s.ipv6_address_mode == constants.DHCPV6_STATEFUL):",
            "                if s.ip_version == constants.IP_VERSION_4:",
            "                    expected.extend([prefix % (",
            "                        s.id, s.cidr.split('/')[0],",
            "                        netaddr.IPNetwork(s.cidr).netmask, lease_duration,",
            "                        seconds)])",
            "                else:",
            "                    expected.extend([prefix6 % (",
            "                        s.id, s.cidr.split('/')[0], s.cidr.split('/')[1],",
            "                        lease_duration, seconds)])",
            "                possible_leases += netaddr.IPNetwork(s.cidr).size",
            "",
            "        if hasattr(network, 'mtu'):",
            "            expected.append(",
            "                '--dhcp-option-force=option:mtu,%s' % network.mtu)",
            "",
            "        expected.append('--dhcp-lease-max=%d' % min(",
            "            possible_leases, max_leases))",
            "",
            "        if dhcp_t1:",
            "            expected.append('--dhcp-option-force=option:T1,%ds' % dhcp_t1)",
            "        if dhcp_t2:",
            "            expected.append('--dhcp-option-force=option:T2,%ds' % dhcp_t2)",
            "",
            "        expected.extend(extra_options)",
            "        check_conf_file_empty(expected)",
            "",
            "        self.execute.return_value = ('', '')",
            "",
            "        attrs_to_mock = dict(",
            "            (a, mock.DEFAULT) for a in",
            "            ['_output_opts_file', 'get_conf_file_name', 'interface_name']",
            "        )",
            "",
            "        test_pm = mock.Mock()",
            "",
            "        with mock.patch.multiple(dhcp.Dnsmasq, **attrs_to_mock) as mocks:",
            "            mocks['get_conf_file_name'].side_effect = mock_get_conf_file_name",
            "            mocks['_output_opts_file'].return_value = (",
            "                '/dhcp/%s/opts' % network.id",
            "            )",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "",
            "            dm = self._get_dnsmasq(network, test_pm)",
            "            dm.spawn_process()",
            "            self.assertTrue(mocks['_output_opts_file'].called)",
            "",
            "            self.assertTrue(test_pm.register.called)",
            "            self.external_process().enable.assert_called_once_with(",
            "                ensure_active=True, reload_cfg=False)",
            "            call_kwargs = self.external_process.mock_calls[0][2]",
            "            cmd_callback = call_kwargs['default_cmd_callback']",
            "",
            "            result_cmd = cmd_callback(expected_pid_file)",
            "",
            "            self.assertEqual(expected, result_cmd)",
            "",
            "    def test_spawn(self):",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'])",
            "",
            "    def test_spawn_not_bridged(self):",
            "        self.mock_mgr.return_value.driver.bridged = False",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         bridged=False)",
            "",
            "    def test_spawn_infinite_lease_duration(self):",
            "        self.conf.set_override('dhcp_lease_duration', -1)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         FakeDualNetwork(), 16777216, -1)",
            "",
            "    def test_spawn_cfg_config_file(self):",
            "        self.conf.set_override('dnsmasq_config_file', '/foo')",
            "        self._test_spawn(['--conf-file=/foo', '--domain=openstacklocal'])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_spawn_no_dns_domain(self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data) = self._test_no_dns_domain_alloc_data()",
            "        self.conf.set_override('dns_domain', '')",
            "        network = FakeDualNetwork(domain=self.conf.dns_domain)",
            "        self._test_spawn(['--conf-file='], network=network)",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_addn_name, exp_addn_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_spawn_no_dns_domain_tag_support(self, mock_tag_support):",
            "        mock_tag_support.return_value = True",
            "        (exp_host_name, exp_host_data, exp_addn_name,",
            "         exp_addn_data) = self._test_no_dns_domain_alloc_data(",
            "            tag=dhcp.HOST_DHCPV6_TAG)",
            "        self.conf.set_override('dns_domain', '')",
            "        network = FakeDualNetwork(domain=self.conf.dns_domain)",
            "        self._test_spawn(['--conf-file='], network=network)",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_addn_name, exp_addn_data)])",
            "",
            "    def test_spawn_no_dhcp_range(self):",
            "        network = FakeV6Network()",
            "        subnet = FakeV6SubnetSlaac()",
            "        network.subnets = [subnet]",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network, has_static=False)",
            "",
            "    def test_spawn_no_dhcp_range_bad_prefix_length(self):",
            "        network = FakeV6NetworkStatelessDHCPBadPrefixLength()",
            "        subnet = FakeV6SubnetStatelessBadPrefixLength()",
            "        network.subnets = [subnet]",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network, has_static=False, has_stateless=False)",
            "",
            "    def test_spawn_cfg_dns_server(self):",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8'])",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_cfg_multiple_dns_server(self):",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8',",
            "                                                       '9.9.9.9'])",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--server=9.9.9.9',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_cfg_enable_dnsmasq_log(self):",
            "        self.conf.set_override('dnsmasq_base_log_dir', '/tmp')",
            "        network = FakeV4Network()",
            "        dhcp_dns_log = \\",
            "            '/tmp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/dhcp_dns_log'",
            "",
            "        self._test_spawn(['--conf-file=',",
            "                          '--domain=openstacklocal',",
            "                          '--log-queries',",
            "                          '--log-dhcp',",
            "                          ('--log-facility=%s' % dhcp_dns_log)],",
            "                         network)",
            "        self.makedirs.assert_called_with(os.path.join('/tmp', network.id))",
            "",
            "    def test_spawn_cfg_with_local_resolv(self):",
            "        self.conf.set_override('dnsmasq_local_resolv', True)",
            "",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         no_resolv='')",
            "",
            "    def test_spawn_cfg_with_local_resolv_overridden(self):",
            "        self.conf.set_override('dnsmasq_local_resolv', True)",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8'])",
            "",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_max_leases_is_smaller_than_cap(self):",
            "        self._test_spawn(",
            "            ['--conf-file=', '--domain=openstacklocal'],",
            "            network=FakeV4Network(),",
            "            max_leases=256)",
            "",
            "    def test_spawn_cfg_broadcast(self):",
            "        self.conf.set_override('dhcp_broadcast_reply', True)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal',",
            "                          '--dhcp-broadcast'])",
            "",
            "    def test_spawn_cfg_advertise_mtu(self):",
            "        network = FakeV4Network()",
            "        network.mtu = 1500",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network)",
            "",
            "    def test_spawn_cfg_advertise_mtu_plugin_doesnt_pass_mtu_value(self):",
            "        network = FakeV4Network()",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network)",
            "",
            "    def test_spawn_cfg_with_dhcp_timers(self):",
            "        self.conf.set_override('dhcp_renewal_time', 30)",
            "        self.conf.set_override('dhcp_rebinding_time', 100)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         dhcp_t1=30, dhcp_t2=100)",
            "",
            "    def _test_output_init_lease_file(self, timestamp):",
            "        expected = [",
            "            '00:00:80:aa:bb:cc 192.168.0.2 * *',",
            "            '00:00:0f:aa:bb:cc 192.168.0.3 * *',",
            "            '00:00:0f:rr:rr:rr 192.168.0.1 * *\\n']",
            "        expected = \"\\n\".join(['%s %s' % (timestamp, le) for le in expected])",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/leases'",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "            dm._output_init_lease_file()",
            "        self.safe.assert_called_once_with('/foo/leases', expected)",
            "",
            "    @mock.patch('time.time')",
            "    def test_output_init_lease_file(self, tmock):",
            "        self.conf.set_override('dhcp_lease_duration', 500)",
            "        tmock.return_value = 1000000",
            "        # lease duration should be added to current time",
            "        timestamp = 1000000 + 500",
            "        self._test_output_init_lease_file(timestamp)",
            "",
            "    def test_output_init_lease_file_infinite_duration(self):",
            "        self.conf.set_override('dhcp_lease_duration', -1)",
            "        # when duration is infinite, lease db timestamp should be 0",
            "        timestamp = 0",
            "        self._test_output_init_lease_file(timestamp)",
            "",
            "    @mock.patch('time.time')",
            "    @mock.patch('os.path.isfile', return_value=True)",
            "    def test_output_init_lease_file_existing(self, isfile, tmock):",
            "",
            "        duid = 'duid 00:01:00:01:27:da:58:97:fa:16:3e:6c:ad:c1'",
            "        ipv4_leases = (",
            "            '1623162161 00:00:80:aa:bb:cc 192.168.0.2 host-192-168-0-2 *\\n'",
            "            '1623147425 00:00:0f:aa:bb:cc 192.168.0.3 host-192-168-0-3 '",
            "            'ff:b5:5e:67:ff:00:02:00:00:ab:11:43:e5:86:52:f3:d7:2c:97\\n'",
            "            '1623138717 00:00:0f:rr:rr:rr 192.168.0.1 host-192-168-0-1 '",
            "            'ff:b5:5e:67:ff:00:02:00:00:ab:11:f6:f2:aa:cb:94:c1:b4:86'",
            "        )",
            "        ipv6_lease_v6_port = (",
            "            '1623083263 755752236 fdca:3ba5:a17a:4ba3::2 '",
            "            'host-fdca-3ba5-a17a-4ba3--2 '",
            "            '00:01:00:01:28:50:e8:31:5a:42:2d:0b:dd:2c'",
            "        )",
            "        additional_ipv6_leases = (",
            "            '1623143299 3042863103 2001:db8::45 host-2001-db8--45 '",
            "            '00:02:00:00:ab:11:fa:c9:0e:0f:3d:90:73:f0\\n'",
            "            '1623134168 3042863103 2001:db8::12 host-2001-db8--12 '",
            "            '00:02:00:00:ab:11:f6:f2:aa:cb:94:c1:b4:86'",
            "        )",
            "        existing_leases = '\\n'.join((ipv4_leases, duid, ipv6_lease_v6_port,",
            "                                     additional_ipv6_leases))",
            "",
            "        # lease duration should be added to current time",
            "        timestamp = 1000000 + 500",
            "        # The expected lease file contains:",
            "        # * The DHCPv6 servers DUID",
            "        # * A lease for all IPv4 addresses",
            "        # * A lease for the IPv6 addresses present in the existing lease file",
            "        #   (IPv6 of FakeV6Port)",
            "        # * No lease for the IPv6 addresses NOT present in the existing lease",
            "        #   file (IPv6 of FakeDualPort)",
            "        # * No lease for the IPv6 addresses present in the existing lease file",
            "        #   which are no longer assigned to any port",
            "        expected = (",
            "            '%s\\n'",
            "            '%s 00:00:80:aa:bb:cc 192.168.0.2 * *\\n'",
            "            '%s\\n'",
            "            '%s 00:00:0f:aa:bb:cc 192.168.0.3 * *\\n'",
            "            '%s 00:00:0f:rr:rr:rr 192.168.0.1 * *\\n'",
            "        ) % (duid, timestamp, ipv6_lease_v6_port, timestamp, timestamp)",
            "",
            "        self.conf.set_override('dhcp_lease_duration', 500)",
            "        tmock.return_value = 1000000",
            "",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/leases'",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "            # Patch __iter__ into mock for Python < 3.8 compatibility",
            "            open_mock = mock.mock_open(read_data=existing_leases)",
            "            open_mock.return_value.__iter__ = lambda s: iter(s.readline, '')",
            "",
            "            with mock.patch('builtins.open', open_mock):",
            "                dm._output_init_lease_file()",
            "",
            "        # Assert the lease file contains the existing ipv6_leases",
            "        self.safe.assert_called_once_with('/foo/leases', expected)",
            "",
            "    def _test_output_opts_file(self, expected, network, ipm_retval=None):",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/opts'",
            "            dm = self._get_dnsmasq(network)",
            "            if ipm_retval:",
            "                with mock.patch.object(",
            "                        dm, '_make_subnet_interface_ip_map') as ipm:",
            "                    ipm.return_value = ipm_retval",
            "                    dm._output_opts_file()",
            "                    self.assertTrue(ipm.called)",
            "            else:",
            "                dm._output_opts_file()",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    def test_output_opts_file(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal'",
            "        ).lstrip() % ('[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetwork())",
            "",
            "    def test_output_opts_file_gateway_route(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal'",
            "        ).lstrip() % ('[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkGatewayRoute())",
            "",
            "    def test_output_opts_file_multiple_agents_without_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,192.168.0.5,192.168.0.6').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4MultipleAgentsWithoutDnsProvided())",
            "",
            "    def test_output_opts_file_agent_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithoutDnsProvided())",
            "",
            "    def test_output_opts_file_agent_with_many_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,2.2.2.2,9.9.9.9,1.1.1.1,3.3.3.3\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithManyDnsProvided())",
            "",
            "    def test_output_opts_file_agent_with_no_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithNoDnsProvided())",
            "",
            "    def test_output_opts_file_multiple_agents_with_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4MultipleAgentsWithDnsProvided())",
            "",
            "    def test_output_opts_file_single_dhcp(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkSingleDHCP())",
            "",
            "    def test_output_opts_file_single_dhcp_both_not_isolated(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeDualNetworkSingleDHCPBothAttaced())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:classless-static-route,192.168.0.0/24,0.0.0.0,'",
            "            '169.254.169.254/32,192.168.1.1,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            '249,192.168.0.0/24,0.0.0.0,169.254.169.254/32,192.168.1.1,'",
            "            '0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:router,192.168.1.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkDualDHCP())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442_no_on_link_subnet_routes(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "            FakeDualNetworkDualDHCPOnLinkSubnetRoutesDisabled())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442_one_on_link_subnet_route(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:classless-static-route,192.168.0.0/24,0.0.0.0,'",
            "            '169.254.169.254/32,192.168.1.1,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            '249,192.168.0.0/24,0.0.0.0,169.254.169.254/32,192.168.1.1,'",
            "            '0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:router,192.168.1.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "            FakeDualNetworkTriDHCPOneOnLinkSubnetRoute())",
            "",
            "    def test_output_opts_file_no_gateway(self):",
            "        expected = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '249,169.254.169.254/32,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:router').lstrip()",
            "",
            "        ipm_retval = {FakeV4SubnetNoGateway().id: '192.168.1.1'}",
            "        self._test_output_opts_file(expected, FakeV4NoGatewayNetwork(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_non_local_subnets(self):",
            "        expected = (",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "        ipm_retval = {FakeV4SubnetSegmentID2().id: '192.168.0.1'}",
            "        self._test_output_opts_file(expected, FakeNonLocalSubnets(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_no_neutron_router_on_subnet(self):",
            "        expected = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.1.2,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '249,169.254.169.254/32,192.168.1.2,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:router,192.168.1.1').lstrip()",
            "",
            "        ipm_retval = {FakeV4SubnetNoRouter().id: '192.168.1.2'}",
            "        self._test_output_opts_file(expected, FakeV4NetworkNoRouter(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_dist_neutron_router_on_subnet(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        ipm_retval = {FakeV4Subnet().id: '192.168.0.1'}",
            "        self._test_output_opts_file(expected, FakeV4NetworkDistRouter(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_pxe_2port_1net(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeV4NetworkPxe2Ports())",
            "",
            "    def test_output_opts_file_pxe_2port_1net_diff_details(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.0.5\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.0.5\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4NetworkPxe2Ports(\"portsDiff\"))",
            "",
            "    def test_output_opts_file_pxe_3port_2net(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,20.0.0.1/24,'",
            "            '20.0.0.1,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.1.3\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.1.2\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux2.0\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:tftp-server,192.168.1.3\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:server-ip-address,192.168.1.2\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:bootfile-name,pxelinux3.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualV4Pxe3Ports())",
            "",
            "    def test_output_opts_file_pxe_port(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:nd98,option-nondigit-98\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '99,option-99\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeV4NetworkPxePort())",
            "",
            "    def test_output_opts_file_multiple_tags(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'tag:ipxe,option:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/opts'",
            "            dm = self._get_dnsmasq(FakeV4NetworkMultipleTags())",
            "            dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    @mock.patch('neutron.agent.linux.dhcp.Dnsmasq.get_conf_file_name',",
            "                return_value='/foo/opts')",
            "    def test_output_opts_file_pxe_ipv6_port_with_ipv6_opt(self,",
            "                                                          mock_get_conf_fn):",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:tftp-server,2001:192:168::1\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:nd98,option-nondigit-98\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:99,option-99\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV6NetworkPxePort())",
            "        dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    @mock.patch('neutron.agent.linux.dhcp.Dnsmasq.get_conf_file_name',",
            "                return_value='/foo/opts')",
            "    def test_output_opts_file_pxe_ipv6_port_with_ipv4_opt(self,",
            "                                                          mock_get_conf_fn):",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV6NetworkPxePortWrongOptVersion())",
            "        dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    def test_output_opts_file_ipv6_address_mode_unset(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "                '[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeV6Network())",
            "",
            "    def test_output_opts_file_ipv6_address_force_metadata(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "                '[' + fake_v6 + ']')",
            "        self.conf.force_metadata = True",
            "        self._test_output_opts_file(expected, FakeV6Network())",
            "",
            "    def _test_no_dns_domain_alloc_data(self, tag=''):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--2,'",
            "                         '[fdca:3ba5:a17a:4ba3::2]\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-3,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--3,'",
            "                         '[fdca:3ba5:a17a:4ba3::3]\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1,'",
            "                         '192.168.0.1\\n').format(tag=tag).lstrip()",
            "        exp_addn_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/addn_hosts'",
            "        exp_addn_data = (",
            "            '192.168.0.2\\t'",
            "            'host-192-168-0-2 host-192-168-0-2\\n'",
            "            'fdca:3ba5:a17a:4ba3::2\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--2 '",
            "            'host-fdca-3ba5-a17a-4ba3--2\\n'",
            "            '192.168.0.3\\thost-192-168-0-3 '",
            "            'host-192-168-0-3\\n'",
            "            'fdca:3ba5:a17a:4ba3::3\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--3 '",
            "            'host-fdca-3ba5-a17a-4ba3--3\\n'",
            "            '192.168.0.1\\t'",
            "            'host-192-168-0-1 '",
            "            'host-192-168-0-1\\n'",
            "        ).lstrip()",
            "        return (exp_host_name, exp_host_data,",
            "                exp_addn_name, exp_addn_data)",
            "",
            "    def _test_reload_allocation_data(self, tag=''):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--2.'",
            "                         'openstacklocal.,[fdca:3ba5:a17a:4ba3::2]\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-3.openstacklocal.,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--3.'",
            "                         'openstacklocal.,[fdca:3ba5:a17a:4ba3::3]\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').format(tag=tag).lstrip()",
            "        exp_addn_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/addn_hosts'",
            "        exp_addn_data = (",
            "            '192.168.0.2\\t'",
            "            'host-192-168-0-2.openstacklocal. host-192-168-0-2\\n'",
            "            'fdca:3ba5:a17a:4ba3::2\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--2.openstacklocal. '",
            "            'host-fdca-3ba5-a17a-4ba3--2\\n'",
            "            '192.168.0.3\\thost-192-168-0-3.openstacklocal. '",
            "            'host-192-168-0-3\\n'",
            "            'fdca:3ba5:a17a:4ba3::3\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--3.openstacklocal. '",
            "            'host-fdca-3ba5-a17a-4ba3--3\\n'",
            "            '192.168.0.1\\t'",
            "            'host-192-168-0-1.openstacklocal. '",
            "            'host-192-168-0-1\\n'",
            "        ).lstrip()",
            "        exp_opt_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/opts'",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        exp_opt_data = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "            '[' + fake_v6 + ']')",
            "        return (exp_host_name, exp_host_data,",
            "                exp_addn_name, exp_addn_data,",
            "                exp_opt_name, exp_opt_data,)",
            "",
            "    def test_reload_allocations_no_interface(self):",
            "        net = FakeDualNetwork()",
            "        ipath = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(ipath))",
            "        test_pm = mock.Mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertFalse(test_pm.register.called)",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_reload_allocations(self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data,",
            "         exp_opt_name, exp_opt_data,) = self._test_reload_allocation_data()",
            "",
            "        net = FakeDualNetwork()",
            "        hpath = '/dhcp/%s/host' % net.id",
            "        ipath = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(hpath))",
            "        self.useFixture(lib_fixtures.OpenFixture(ipath, 'tapdancingmice'))",
            "        test_pm = mock.Mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertTrue(test_pm.register.called)",
            "        self.external_process().enable.assert_called_once_with(",
            "            ensure_active=True, reload_cfg=True)",
            "",
            "        self.safe.assert_has_calls([",
            "            mock.call(exp_host_name, exp_host_data),",
            "            mock.call(exp_addn_name, exp_addn_data),",
            "            mock.call(exp_opt_name, exp_opt_data),",
            "        ])",
            "",
            "        mock_tag_support.return_value = True",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data,",
            "         exp_opt_name, exp_opt_data,) = self._test_reload_allocation_data(",
            "            tag=dhcp.HOST_DHCPV6_TAG)",
            "        test_pm.reset_mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertTrue(test_pm.register.called)",
            "",
            "        self.safe.assert_has_calls([",
            "            mock.call(exp_host_name, exp_host_data),",
            "            mock.call(exp_addn_name, exp_addn_data),",
            "            mock.call(exp_opt_name, exp_opt_data),",
            "        ])",
            "",
            "    def test_release_unused_leases(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip3 = '0001:0002:0003:0004:0005:0006:0007:0008'",
            "        mac3 = '00:00:80:bb:aa:cc'",
            "",
            "        old_leases = {(ip1, mac1, None), (ip2, mac2, None), (ip3, mac3, None)}",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip1: {'iaid': mac1,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip3: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {}])",
            "",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = []",
            "        dnsmasq.device_manager.unplug = mock.Mock()",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_has_calls([mock.call(mac1, ip1,",
            "                                                     constants.IP_VERSION_4,",
            "                                                     None, 'server_id', mac1),",
            "                                                 mock.call(mac2, ip2,",
            "                                                     constants.IP_VERSION_4,",
            "                                                     None, 'server_id', mac2),",
            "                                                 mock.call(mac3, ip3,",
            "                                                     constants.IP_VERSION_6,",
            "                                                     'client_id', 'server_id',",
            "                                                     0xff),",
            "                                                 ],",
            "                                                any_order=True)",
            "",
            "    def test_release_for_ipv6_lease(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = 'fdca:3ba5:a17a::1'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "",
            "        old_leases = set([(ip1, mac1, 'client_id'), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip1: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {}])",
            "        mock_dhcp_release = mock.patch.object(priv_dhcp,",
            "                                              'dhcp_release').start()",
            "        mock_dhcp_release6 = mock.patch.object(priv_dhcp,",
            "                                               'dhcp_release6').start()",
            "        mock_dhcp_release6_supported = mock.patch.object(",
            "            priv_dhcp, 'dhcp_release6_supported').start()",
            "        dnsmasq._release_unused_leases()",
            "        # Verify that dhcp_release is called both for ipv4 and ipv6 addresses.",
            "        self.assertEqual(1, mock_dhcp_release.call_count)",
            "        self.assertEqual(1, mock_dhcp_release6.call_count)",
            "        mock_dhcp_release.assert_called_once_with(",
            "            interface_name=None, ip_address=ip2, mac_address=mac2,",
            "            client_id=None, namespace=dnsmasq.network.namespace)",
            "        mock_dhcp_release6.assert_called_once_with(",
            "            interface_name=None, ip_address=ip1, client_id='client_id',",
            "            server_id='server_id', iaid=0xff,",
            "            namespace=dnsmasq.network.namespace)",
            "        mock_dhcp_release6_supported.assert_called_once_with()",
            "",
            "    def test_release_for_ipv6_lease_no_dhcp_release6(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = 'fdca:3ba5:a17a::1'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "",
            "        old_leases = set([(ip1, mac1, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            return_value={'fdca:3ba5:a17a::1': {'iaid': 0xff,",
            "                                                'client_id': 'client_id',",
            "                                                'server_id': 'server_id'}",
            "                          })",
            "        ipw = mock.patch(",
            "            'neutron.agent.linux.ip_lib.IpNetnsCommand.execute').start()",
            "        dnsmasq._IS_DHCP_RELEASE6_SUPPORTED = False",
            "        dnsmasq._release_unused_leases()",
            "        # Verify that dhcp_release6 is not called when it is not present",
            "        ipw.assert_not_called()",
            "",
            "    def test_release_unused_leases_with_dhcp_port(self):",
            "        dnsmasq = self._get_dnsmasq(FakeNetworkDhcpPort())",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            return_value={ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          })",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.device_manager.get_device_id = mock.Mock(",
            "            return_value='fake_dhcp_port')",
            "        dnsmasq._release_unused_leases()",
            "        self.assertFalse(",
            "            dnsmasq.device_manager.unplug.called)",
            "        self.assertFalse(",
            "            dnsmasq.device_manager.driver.unplug.called)",
            "",
            "    def test_release_unused_leases_with_client_id(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        client_id2 = 'client2'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, client_id2)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = []",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_has_calls(",
            "            [mock.call(mac1, ip1, constants.IP_VERSION_4, client_id1,",
            "                       'server_id', mac1),",
            "             mock.call(mac2, ip2, constants.IP_VERSION_4, client_id2,",
            "                       'server_id', mac2)],",
            "            any_order=True)",
            "",
            "    def test_release_unused_leases_one_lease(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac2, ip2, constants.IP_VERSION_4, None, 'server_id', mac2)",
            "",
            "    def test_release_unused_leases_one_lease_with_client_id(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.0.5'",
            "        mac2 = '00:00:0f:aa:bb:55'",
            "        client_id2 = 'test5'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, client_id2)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort5()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac1, ip1, constants.IP_VERSION_4, client_id1, 'server_id', mac1)",
            "",
            "    def test_release_unused_leases_one_lease_with_client_id_none(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.0.4'",
            "        mac2 = '00:16:3E:C2:77:1D'",
            "        client_id2 = 'test4'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort4()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac1, ip1, constants.IP_VERSION_4, client_id1, 'server_id', mac1)",
            "",
            "    def test_release_unused_leases_one_lease_from_leases_file(self):",
            "        # leases file has a stale entry that is not in the host file",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac2, ip2, constants.IP_VERSION_4, None, 'server_id', mac2)",
            "",
            "    @mock.patch.object(dhcp.LOG, 'warn')",
            "    def _test_release_unused_leases_one_lease_mult_times(self, mock_log_warn,",
            "                                                         removed):",
            "        # Simulate a dhcp_release failure where the lease remains in the",
            "        # lease file despite multiple dhcp_release calls",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second and subsequent reads of the lease file must have the",
            "        # entries that were not released.",
            "        side_effect = [{ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        },",
            "                       {ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        },",
            "                       {ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        }]",
            "        # entry did/didn't go away after final dhcp_release try",
            "        if not removed:",
            "            side_effect.append(",
            "                     {ip6: {'iaid': 0xff,",
            "                            'client_id': 'client_id',",
            "                            'server_id': 'server_id'},",
            "                      ip2: {'iaid': mac2,",
            "                            'client_id': None,",
            "                            'server_id': 'server_id'}",
            "                      })",
            "        else:",
            "            side_effect.append({})",
            "",
            "        dnsmasq._read_leases_file_leases = mock.Mock(side_effect=side_effect)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        self.assertEqual(dhcp.DHCP_RELEASE_TRIES,",
            "                         dnsmasq._release_lease.call_count)",
            "",
            "        self.assertEqual(dhcp.DHCP_RELEASE_TRIES + 1,",
            "                         dnsmasq._read_leases_file_leases.call_count)",
            "",
            "        if not removed:",
            "            self.assertTrue(mock_log_warn.called)",
            "",
            "    def test_release_unused_leases_one_lease_mult_times_not_removed(self):",
            "        self._test_release_unused_leases_one_lease_mult_times(False)",
            "",
            "    def test_release_unused_leases_one_lease_mult_times_removed(self):",
            "        self._test_release_unused_leases_one_lease_mult_times(True)",
            "",
            "    def test__parse_ip_addresses(self):",
            "        ip_list = ['192.168.0.1', '[fdca:3ba5:a17a::1]', 'no_ip_address']",
            "        self.assertEqual(['192.168.0.1', 'fdca:3ba5:a17a::1'],",
            "                         dhcp.Dnsmasq._parse_ip_addresses(ip_list))",
            "",
            "    def _test_read_hosts_file_leases(self, lines, expected_result):",
            "        filename = '/path/to/file'",
            "        mock_open = self.useFixture(",
            "            lib_fixtures.OpenFixture(filename, '\\n'.join(lines))).mock_open",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "        leases = dnsmasq._read_hosts_file_leases(filename)",
            "        self.assertEqual(expected_result, leases)",
            "        mock_open.assert_called_once_with(filename)",
            "",
            "    def test_read_hosts_file_leases(self):",
            "        lines = [\"00:00:80:aa:bb:cc,inst-name,192.168.0.1\",",
            "                 \"00:00:80:aa:bb:cc,inst-name,[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", None)}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_client_id(self):",
            "        lines = [\"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "                 \"00:00:80:aa:bb:cc,id:client2,inst-name,\"",
            "                 \"[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", 'client2')}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_stateless_IPv6_tag(self):",
            "        lines = [",
            "            \"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "            \"00:00:80:aa:bb:cc,set:ccccccccc-cccc-cccc-cccc-cccccccc\",",
            "            \"00:00:80:aa:bb:cc,id:client2,inst-name,[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", 'client2')}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_IPv6_tag_and_multiple_ips(self):",
            "        lines = [",
            "            \"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "            \"00:00:80:aa:bb:cc,set:ccccccccc-cccc-cccc-cccc-cccccccc\",",
            "            \"00:00:80:aa:bb:cc,tag:dhcpv6,inst-name,[fdca:3ba5:a17a::1],\"",
            "            \"[fdca:3ba5:a17a::2],[fdca:3ba5:a17a::3],[fdca:3ba5:a17a::4],\"",
            "            \"set:port-fe2baee9-aba9-4b67-be03-be4aeee40cca\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::2\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::3\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::4\", \"00:00:80:aa:bb:cc\", None)}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def _test_read_leases_file_leases(self, add_bad_line=False):",
            "        filename = '/path/to/file'",
            "        lines = [",
            "                \"1472673289 aa:bb:cc:00:00:02 192.168.1.2 host-192-168-1-2 *\",",
            "                \"1472673289 aa:bb:cc:00:00:03 192.168.1.3 host-192-168-1-3 *\",",
            "                \"1472673289 aa:bb:cc:00:00:04 192.168.1.4 host-192-168-1-4 *\",",
            "                \"duid 00:01:00:01:02:03:04:05:06:07:08:09:0a:0b\",",
            "                \"1472597740 1044800001 [2001:DB8::a] host-2001-db8--a \"",
            "                \"00:04:4a:d0:d2:34:19:2b:49:08:84:e8:34:bd:0c:dc:b9:3b\",",
            "                \"1472597823 1044800002 [2001:DB8::b] host-2001-db8--b \"",
            "                \"00:04:ce:96:53:3d:f2:c2:4c:4c:81:7d:db:c9:8d:d2:74:22:3b:0a\",",
            "                \"1472599048 1044800003 [2001:DB8::c] host-2001-db8--c \"",
            "                \"00:04:4f:f0:cd:ca:5e:77:41:bc:9d:7f:5c:33:31:37:5d:80:77:b4\"",
            "                 ]",
            "        bad_line = '1472673289 aa:bb:cc:00:00:05 192.168.1.5 host-192.168-1-5'",
            "        if add_bad_line:",
            "            lines.append(bad_line)",
            "",
            "        mock_open = self.useFixture(",
            "            lib_fixtures.OpenFixture(filename, '\\n'.join(lines))).mock_open",
            "",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "        with mock.patch('os.path.exists', return_value=True), \\",
            "                mock.patch.object(dhcp.LOG, 'warning') as mock_log_warn:",
            "            leases = dnsmasq._read_leases_file_leases(filename)",
            "        server_id = '00:01:00:01:02:03:04:05:06:07:08:09:0a:0b'",
            "        entry1 = {'iaid': '1044800001',",
            "                  'client_id': '00:04:4a:d0:d2:34:19:2b:49:08:84:'",
            "                               'e8:34:bd:0c:dc:b9:3b',",
            "                  'server_id': server_id",
            "                  }",
            "        entry2 = {'iaid': '1044800002',",
            "                  'client_id': '00:04:ce:96:53:3d:f2:c2:4c:4c:81:'",
            "                               '7d:db:c9:8d:d2:74:22:3b:0a',",
            "                  'server_id': server_id",
            "                  }",
            "        entry3 = {'iaid': '1044800003',",
            "                  'client_id': '00:04:4f:f0:cd:ca:5e:77:41:bc:9d:'",
            "                               '7f:5c:33:31:37:5d:80:77:b4',",
            "                  'server_id': server_id",
            "                  }",
            "        entry4 = {'iaid': 'aa:bb:cc:00:00:02',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        entry5 = {'iaid': 'aa:bb:cc:00:00:03',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        entry6 = {'iaid': 'aa:bb:cc:00:00:04',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        expected = {'2001:DB8::a': entry1,",
            "                    '2001:DB8::b': entry2,",
            "                    '2001:DB8::c': entry3,",
            "                    '192.168.1.2': entry4,",
            "                    '192.168.1.3': entry5,",
            "                    '192.168.1.4': entry6",
            "                    }",
            "",
            "        mock_open.assert_called_once_with(filename)",
            "        self.assertEqual(expected, leases)",
            "        if add_bad_line:",
            "            self.assertTrue(mock_log_warn.called)",
            "",
            "    def test_read_all_leases_file_leases(self):",
            "        self._test_read_leases_file_leases()",
            "",
            "    def test_read_all_leases_file_leases_with_bad_line(self):",
            "        self._test_read_leases_file_leases(add_bad_line=True)",
            "",
            "    def test_make_subnet_interface_ip_map(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'get_devices_with_ip') as list_mock:",
            "            list_mock.return_value = [{'cidr': '192.168.0.1/24'}]",
            "",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "            self.assertEqual(",
            "                dm._make_subnet_interface_ip_map(),",
            "                {FakeV4Subnet().id: '192.168.0.1'}",
            "            )",
            "",
            "    def test_remove_config_files(self):",
            "        net = FakeV4Network()",
            "        path = '/opt/data/neutron/dhcp'",
            "        self.conf.dhcp_confs = path",
            "        lp = LocalChild(self.conf, net)",
            "        lp._remove_config_files()",
            "        self.rmtree.assert_called_once_with(os.path.join(path, net.id),",
            "                                            ignore_errors=True)",
            "",
            "    def test_existing_dhcp_networks(self):",
            "        path = '/opt/data/neutron/dhcp'",
            "        self.conf.dhcp_confs = path",
            "",
            "        cases = {",
            "            # network_uuid --> is_dhcp_alive?",
            "            'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa': True,",
            "            'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb': False,",
            "            'not_uuid_like_name': True",
            "        }",
            "",
            "        def active_fake(self, instance, cls):",
            "            return cases[instance.network.id]",
            "",
            "        with mock.patch('os.listdir') as mock_listdir:",
            "            with mock.patch.object(dhcp.Dnsmasq, 'active') as mock_active:",
            "                mock_active.__get__ = active_fake",
            "                mock_listdir.return_value = list(cases)",
            "",
            "                result = dhcp.Dnsmasq.existing_dhcp_networks(self.conf)",
            "",
            "                mock_listdir.assert_called_once_with(path)",
            "                self.assertCountEqual(['aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',",
            "                                       'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'],",
            "                                      result)",
            "",
            "    def test__output_hosts_file_log_only_twice(self):",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkSingleDHCP())",
            "        with mock.patch.object(dhcp, 'LOG') as logger:",
            "            logger.process.return_value = ('fake_message', {})",
            "            dm._output_hosts_file()",
            "        # The method logs twice, at the start of and the end. There should be",
            "        # no other logs, no matter how many hosts there are to dump in the",
            "        # file.",
            "        self.assertEqual(2, len(logger.method_calls))",
            "",
            "    def test_only_populates_dhcp_enabled_subnets(self):",
            "        exp_host_name = '/dhcp/eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:16:3E:C2:77:1D,host-192-168-0-4.openstacklocal.,'",
            "                         '192.168.0.4\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkSingleDHCP())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    def test_only_populates_dhcp_client_id(self):",
            "        exp_host_name = '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/host'",
            "        exp_host_data = (",
            "            '00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "            '192.168.0.2\\n'",
            "            '00:00:0f:aa:bb:55,id:test5,'",
            "            'host-192-168-0-5.openstacklocal.,'",
            "            '192.168.0.5\\n'",
            "            '00:00:0f:aa:bb:66,id:test6,'",
            "            'host-192-168-0-6.openstacklocal.,192.168.0.6,'",
            "            'set:port-ccccccccc-cccc-cccc-cccc-ccccccccc\\n').lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientId())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    def test_only_populates_dhcp_enabled_subnet_on_a_network(self):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,host-192-168-0-3.openstacklocal.,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-4.openstacklocal.,'",
            "                         '192.168.0.4\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualNetworkSingleDHCP())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_stateless_dhcpv6_network(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n').lstrip()",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:domain-search,openstacklocal\\n'",
            "                        'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "                        'option6:dns-server,ffea:3ba5:a17a:4ba3::100').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCP())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,tag:dhcpv6,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCP())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_stateful_dhcpv6_same_subnet_fixedips(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        self.conf.set_override('dnsmasq_enable_addr6_list', True)",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:00:f3:aa:bb:cc,host-fdca-3ba5-a17a-4ba3--2.openstacklocal.,'",
            "            '[fdca:3ba5:a17a:4ba3::2],[fdca:3ba5:a17a:4ba3::4]\\n'.lstrip())",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "                        'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "                        'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "                        'option6:domain-search,openstacklocal').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatefulDHCPSameSubnetFixedIps())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:00:f3:aa:bb:cc,tag:dhcpv6,'",
            "            'host-fdca-3ba5-a17a-4ba3--2.openstacklocal.,'",
            "            '[fdca:3ba5:a17a:4ba3::2],[fdca:3ba5:a17a:4ba3::4]\\n'.lstrip())",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatefulDHCPSameSubnetFixedIps())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_host_and_opts_file_on_stateless_dhcpv6_network_no_dns(self):",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:dns-server\\n'",
            "                        'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:domain-search,openstacklocal').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCPNoDnsProvided())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, ''),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_host_file_on_net_with_v6_slaac_and_v4(self):",
            "        exp_host_name = '/dhcp/eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee/host'",
            "        exp_host_data = (",
            "            '00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,192.168.0.2,'",
            "            'set:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee\\n'",
            "            '00:16:3E:C2:77:1D,host-192-168-0-4.openstacklocal.,192.168.0.4,'",
            "            'set:port-gggggggg-gggg-gggg-gggg-gggggggggggg\\n00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1,'",
            "            'set:port-rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkingSingleDHCPTags())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_net_with_V6_stateless_and_V4_subnets(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:16:3e:c2:77:1d,host-192-168-0-3.openstacklocal.,'",
            "            '192.168.0.3,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1\\n').lstrip()",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,'",
            "            '192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:dns-server,ffea:3ba5:a17a:4ba3::100').lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeNetworkWithV6SatelessAndV4DHCPSubnets())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,tag:dhcpv6,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:16:3e:c2:77:1d,host-192-168-0-3.openstacklocal.,'",
            "            '192.168.0.3,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeNetworkWithV6SatelessAndV4DHCPSubnets())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_has_metadata_subnet_returns_true(self):",
            "        self.assertTrue(dhcp.Dnsmasq.has_metadata_subnet(",
            "            [FakeV4MetadataSubnet()]))",
            "",
            "    def test_has_metadata_subnet_returns_false(self):",
            "        self.assertFalse(dhcp.Dnsmasq.has_metadata_subnet(",
            "            [FakeV4Subnet()]))",
            "",
            "    def test_should_enable_metadata_isolated_network_returns_true(self):",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4NetworkNoRouter()))",
            "",
            "    def test_should_enable_metadata_isolated_network_returns_true_ipv6(self):",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV6Network()))",
            "",
            "    def test_should_enable_metadata_non_isolated_network_returns_false(self):",
            "        self.assertFalse(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4NetworkDistRouter()))",
            "",
            "    def test_should_enable_metadata_isolated_meta_disabled_returns_false(self):",
            "        self.conf.set_override('enable_isolated_metadata', False)",
            "        self.assertFalse(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4MetadataNetwork()))",
            "",
            "    def test_should_enable_metadata_with_metadata_network_returns_true(self):",
            "        self.conf.set_override('enable_metadata_network', True)",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4MetadataNetwork()))",
            "",
            "    def test_should_force_metadata_returns_true(self):",
            "        self.conf.set_override(\"force_metadata\", True)",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeDualNetworkDualDHCP()))",
            "",
            "    def _test__generate_opts_per_subnet_helper(",
            "            self, config_opts, expected_mdt_ip,",
            "            network_class=FakeNetworkDhcpPort):",
            "        for key, value in config_opts.items():",
            "            self.conf.set_override(key, value)",
            "        dm = self._get_dnsmasq(network_class())",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'get_devices_with_ip') as list_mock:",
            "            list_mock.return_value = [{'cidr': alloc.ip_address + '/24'}",
            "                                      for alloc in FakeDhcpPort().fixed_ips]",
            "            options, idx_map = dm._generate_opts_per_subnet()",
            "",
            "        contains_metadata_ip = any(['%s' % constants.METADATA_CIDR in line",
            "                                    for line in options])",
            "        self.assertEqual(expected_mdt_ip, contains_metadata_ip)",
            "",
            "    def test__generate_opts_per_subnet_no_metadata(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': False}",
            "        self._test__generate_opts_per_subnet_helper(config, False)",
            "",
            "    def test__generate_opts_per_subnet_isolated_metadata_with_router(self):",
            "        config = {'enable_isolated_metadata': True,",
            "                  'force_metadata': False}",
            "        self._test__generate_opts_per_subnet_helper(config, True)",
            "",
            "    def test__generate_opts_per_subnet_forced_metadata(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': True}",
            "        self._test__generate_opts_per_subnet_helper(config, True)",
            "",
            "    def test__generate_opts_per_subnet_forced_metadata_non_local_subnet(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': True}",
            "        self._test__generate_opts_per_subnet_helper(",
            "            config, True, network_class=FakeNonLocalSubnets)",
            "",
            "    def test_client_id_num(self):",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientIdNum())",
            "        self.assertEqual('test_client_id_num',",
            "                         dm._get_client_id(FakePortWithClientIdNum()))",
            "",
            "    def test_client_id_num_str(self):",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientIdNumStr())",
            "        self.assertEqual('test_client_id_num',",
            "                         dm._get_client_id(FakePortWithClientIdNumStr()))",
            "",
            "",
            "class TestDeviceManager(TestConfBase):",
            "    def setUp(self):",
            "        super(TestDeviceManager, self).setUp()",
            "        ip_lib_patcher = mock.patch('neutron.agent.linux.dhcp.ip_lib')",
            "        load_interface_driver_patcher = mock.patch(",
            "            'neutron.agent.linux.dhcp.agent_common_utils.'",
            "            'load_interface_driver')",
            "        self.mock_ip_lib = ip_lib_patcher.start()",
            "        self.mock_load_interface_driver = load_interface_driver_patcher.start()",
            "",
            "    def _test_setup(self, load_interface_driver, ip_lib, use_gateway_ips):",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(cfg.BoolOpt('enable_isolated_metadata',",
            "                                               default=False))",
            "            self.conf.register_opt(cfg.BoolOpt('force_metadata',",
            "                                               default=False))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with no existing DHCP port - expect a new DHCP port to",
            "            # be created.",
            "            network = FakeDeviceManagerNetwork()",
            "            network.tenant_id = 'Tenant A'",
            "",
            "            def mock_create(dict):",
            "                port = dhcp.DictModel(dict['port'])",
            "                port.id = 'abcd-123456789'",
            "                port.mac_address = '00-12-34-56-78-90'",
            "                port.fixed_ips = [",
            "                    dhcp.DictModel({'subnet_id': ip['subnet_id'],",
            "                                    'ip_address': 'unique-IP-address'})",
            "                    for ip in port.fixed_ips",
            "                ]",
            "                # server rudely gave us an extra address we didn't ask for",
            "                port.fixed_ips.append(dhcp.DictModel(",
            "                    {'subnet_id': 'ffffffff-6666-6666-6666-ffffffffffff',",
            "                     'ip_address': '2003::f816:3eff:fe45:e893'}))",
            "                return port",
            "",
            "            plugin.create_dhcp_port.side_effect = mock_create",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = use_gateway_ips",
            "            ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.create_dhcp_port.assert_called_with(mock.ANY)",
            "",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  mock.ANY,",
            "                                                  namespace='qdhcp-ns')",
            "            cidrs = set(mgr.driver.init_l3.call_args[0][1])",
            "            if use_gateway_ips:",
            "                self.assertEqual(cidrs, set(['%s/%s' % (s.gateway_ip,",
            "                                                        s.cidr.split('/')[1])",
            "                                             for s in network.subnets]))",
            "            else:",
            "                self.assertEqual(cidrs, set(['unique-IP-address/24',",
            "                                         'unique-IP-address/64']))",
            "",
            "            # Now call setup again.  This time we go through the existing",
            "            # port code path, and the driver's init_l3 method is called",
            "            # again.",
            "            plugin.create_dhcp_port.reset_mock()",
            "            mgr.driver.init_l3.reset_mock()",
            "            mgr.setup(network)",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  mock.ANY,",
            "                                                  namespace='qdhcp-ns')",
            "            cidrs = set(mgr.driver.init_l3.call_args[0][1])",
            "            if use_gateway_ips:",
            "                self.assertEqual(cidrs, set(['%s/%s' % (s.gateway_ip,",
            "                                                        s.cidr.split('/')[1])",
            "                                             for s in network.subnets]))",
            "            else:",
            "                self.assertEqual(cidrs, set(['unique-IP-address/24',",
            "                                             'unique-IP-address/64']))",
            "            self.assertFalse(plugin.create_dhcp_port.called)",
            "",
            "    def test_setup_device_manager_dhcp_port_without_gateway_ips(self):",
            "        self._test_setup(self.mock_load_interface_driver,",
            "                         self.mock_ip_lib, use_gateway_ips=False)",
            "",
            "    def test_setup_device_manager_dhcp_port_with_gateway_ips(self):",
            "        self._test_setup(self.mock_load_interface_driver,",
            "                         self.mock_ip_lib, use_gateway_ips=True)",
            "",
            "    def _test_setup_reserved(self, enable_isolated_metadata=False,",
            "                             force_metadata=False):",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('enable_isolated_metadata',",
            "                            default=enable_isolated_metadata))",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('force_metadata',",
            "                            default=force_metadata))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            self.mock_load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with a reserved DHCP port.",
            "            network = FakeDualNetworkReserved()",
            "            network.tenant_id = 'Tenant A'",
            "            reserved_port = network.ports[-1]",
            "",
            "            def mock_update(port_id, dict):",
            "                port = reserved_port",
            "                port.network_id = dict['port']['network_id']",
            "                port.device_id = dict['port']['device_id']",
            "                return port",
            "",
            "            plugin.update_dhcp_port.side_effect = mock_update",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = False",
            "            self.mock_ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.update_dhcp_port.assert_called_with(reserved_port.id,",
            "                                                       mock.ANY)",
            "",
            "            expect_ips = ['192.168.0.6/24', 'fdca:3ba5:a17a:4ba3::2/64']",
            "            if enable_isolated_metadata or force_metadata:",
            "                expect_ips.extend([",
            "                    constants.METADATA_CIDR,",
            "                    constants.METADATA_V6_CIDR])",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  expect_ips,",
            "                                                  namespace='qdhcp-ns')",
            "",
            "    def test_setup_reserved_and_disable_metadata(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which metadata disabled.",
            "        \"\"\"",
            "        self._test_setup_reserved()",
            "",
            "    def test_setup_reserved_with_isolated_metadata_enable(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which isolated_ metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(enable_isolated_metadata=True)",
            "",
            "    def test_setup_reserved_with_force_metadata_enable(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which force_metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(force_metadata=True)",
            "",
            "    def test_setup_reserved_and_enable_metadata(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which both isolated_metadata and force_metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(enable_isolated_metadata=True,",
            "                                  force_metadata=True)",
            "",
            "    def test_setup_reserved_2(self):",
            "        \"\"\"Test scenario where a network has two reserved ports, and",
            "        update_dhcp_port fails for the first of those.",
            "        \"\"\"",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('enable_isolated_metadata', default=False))",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('force_metadata', default=False))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            self.mock_load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with a reserved DHCP port.",
            "            network = FakeDualNetworkReserved2()",
            "            network.tenant_id = 'Tenant A'",
            "            reserved_port_1 = network.ports[-2]",
            "            reserved_port_2 = network.ports[-1]",
            "",
            "            def mock_update(port_id, dict):",
            "                if port_id == reserved_port_1.id:",
            "                    return None",
            "",
            "                port = reserved_port_2",
            "                port.network_id = dict['port']['network_id']",
            "                port.device_id = dict['port']['device_id']",
            "                return port",
            "",
            "            plugin.update_dhcp_port.side_effect = mock_update",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = False",
            "            self.mock_ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.update_dhcp_port.assert_called_with(reserved_port_2.id,",
            "                                                       mock.ANY)",
            "",
            "            mgr.driver.init_l3.assert_called_with(",
            "                'ns-XXX', ['192.168.0.6/24', 'fdca:3ba5:a17a:4ba3::2/64'],",
            "                namespace='qdhcp-ns')",
            "",
            "    def test__setup_reserved_dhcp_port_with_fake_remote_error(self):",
            "        \"\"\"Test scenario where a fake_network has two reserved ports, and",
            "        update_dhcp_port fails for the first of those with a RemoteError.",
            "        \"\"\"",
            "        # Setup with a reserved DHCP port.",
            "        fake_network = FakeDualNetworkReserved2()",
            "        fake_network.tenant_id = 'Tenant A'",
            "        reserved_port_2 = fake_network.ports[-1]",
            "",
            "        mock_plugin = mock.Mock()",
            "        dh = dhcp.DeviceManager(cfg.CONF, mock_plugin)",
            "        messaging_error = oslo_messaging.RemoteError(",
            "            exc_type='FakeRemoteError')",
            "        mock_plugin.update_dhcp_port.side_effect = [messaging_error,",
            "                                                    reserved_port_2]",
            "",
            "        with testtools.ExpectedException(oslo_messaging.RemoteError):",
            "            dh.setup_dhcp_port(fake_network)",
            "",
            "",
            "class TestDictModel(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestDictModel, self).setUp()",
            "        self._a = uuidutils.generate_uuid()",
            "        self._b = uuidutils.generate_uuid()",
            "        self.dm = dhcp.DictModel(a=self._a, b=self._b)",
            "",
            "    def test_basic_dict(self):",
            "        d = dict(a=1, b=2)",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(1, m.a)",
            "        self.assertEqual(2, m.b)",
            "",
            "    def test_dict_has_sub_dict(self):",
            "        d = dict(a=dict(b=2))",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(2, m.a.b)",
            "",
            "    def test_dict_contains_list(self):",
            "        d = dict(a=[1, 2])",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual([1, 2], m.a)",
            "",
            "    def test_dict_contains_list_of_dicts(self):",
            "        d = dict(a=[dict(b=2), dict(c=3)])",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(2, m.a[0].b)",
            "        self.assertEqual(3, m.a[1].c)",
            "",
            "    def test_string_representation_port(self):",
            "        port = dhcp.DictModel({'id': 'id', 'network_id': 'net_id'})",
            "        self.assertEqual('id=id, network_id=net_id', str(port))",
            "",
            "    def test_string_representation_network(self):",
            "        net = dhcp.DictModel({'id': 'id', 'name': 'myname'})",
            "        self.assertEqual('id=id, name=myname', str(net))",
            "",
            "    def test__init_parameters(self):",
            "        self.assertEqual(self._a, self.dm.a)",
            "        self.assertEqual(self._b, self.dm.b)",
            "",
            "    def test__init_dictmodel(self):",
            "        dm2 = dhcp.DictModel(self.dm)",
            "        self.assertEqual(self._a, dm2.a)",
            "        self.assertEqual(self._b, dm2.b)",
            "        dm2.a = 'new_value'",
            "        self.assertEqual('new_value', dm2.a)",
            "        self.assertEqual(self._a, self.dm.a)",
            "",
            "    def test__getattr(self):",
            "        self.assertEqual({'a': self._a, 'b': self._b},",
            "                         self.dm._dictmodel_internal_storage)",
            "        try:",
            "            self.dm.z",
            "        except AttributeError:",
            "            pass",
            "        except Exception:",
            "            self.fail('Getting a non existing attribute from a DictModel '",
            "                      'object should raise AttributeError')",
            "",
            "    def test__setattr(self):",
            "        self.dm.c = 'c_value'",
            "        self.assertEqual('c_value', self.dm.c)",
            "",
            "    def test__delattr(self):",
            "        del self.dm.a",
            "        self.assertIsNone(self.dm.get('a'))",
            "",
            "    def test__str(self):",
            "        reference = 'a=%s, b=%s' % (self._a, self._b)",
            "        self.assertEqual(reference, str(self.dm))",
            "",
            "    def test__getitem(self):",
            "        self.assertEqual(self._a, self.dm['a'])",
            "        self.assertEqual(self._b, self.dm['b'])",
            "",
            "    def test__setitem(self):",
            "        self.dm['a'] = 'a_new_value'",
            "        self.assertEqual('a_new_value', self.dm.a)",
            "        self.assertEqual('a_new_value', self.dm['a'])",
            "        self.assertEqual(self._b, self.dm.b)",
            "",
            "    def test__iter(self):",
            "        list_keys = sorted(list(self.dm))",
            "        self.assertEqual(['a', 'b'], list_keys)",
            "",
            "    def test__len(self):",
            "        self.assertEqual(2, len(self.dm))",
            "",
            "    def test__copy_and_deepcopy(self):",
            "        for method in (copy.copy, copy.deepcopy):",
            "            self.dm._tuple = (10, 11)",
            "            self.dm._list = [20, 21]",
            "            dm2 = method(self.dm)",
            "            dm2._tuple = (30, 31)",
            "            dm2._list[0] = 200",
            "            self.assertEqual((10, 11), self.dm._tuple)",
            "            self.assertEqual([20, 21], self.dm._list)",
            "            self.assertEqual((30, 31), dm2._tuple)",
            "            self.assertEqual([200, 21], dm2._list)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import os",
            "from unittest import mock",
            "",
            "import netaddr",
            "from neutron_lib.api.definitions import extra_dhcp_opt as edo_ext",
            "from neutron_lib import constants",
            "from neutron_lib import exceptions",
            "from neutron_lib import fixture as lib_fixtures",
            "from oslo_config import cfg",
            "import oslo_messaging",
            "from oslo_utils import fileutils",
            "from oslo_utils import uuidutils",
            "import testtools",
            "",
            "from neutron.agent.linux import dhcp",
            "from neutron.agent.linux import ip_lib",
            "from neutron.cmd import runtime_checks as checks",
            "from neutron.conf.agent import common as config",
            "from neutron.conf.agent import dhcp as dhcp_config",
            "from neutron.conf import common as base_config",
            "from neutron.privileged.agent.linux import dhcp as priv_dhcp",
            "from neutron.tests import base",
            "",
            "",
            "class FakeIPAllocation(object):",
            "    def __init__(self, address, subnet_id=None):",
            "        self.ip_address = address",
            "        self.subnet_id = subnet_id",
            "",
            "",
            "class FakeDNSAssignment(object):",
            "    def __init__(self, ip_address, dns_name='', domain='openstacklocal'):",
            "        if dns_name:",
            "            self.hostname = dns_name",
            "        else:",
            "            self.hostname = 'host-%s' % ip_address.replace(",
            "                '.', '-').replace(':', '-')",
            "        self.ip_address = ip_address",
            "        self.fqdn = self.hostname",
            "        if domain:",
            "            self.fqdn = '%s.%s.' % (self.hostname, domain)",
            "",
            "",
            "class DhcpOpt(object):",
            "    def __init__(self, **kwargs):",
            "        self.__dict__.update(ip_version=constants.IP_VERSION_4)",
            "        self.__dict__.update(kwargs)",
            "",
            "    def __str__(self):",
            "        return str(self.__dict__)",
            "",
            "",
            "# A base class where class attributes can also be accessed by treating",
            "# an instance as a dict.",
            "class Dictable(object):",
            "    def __getitem__(self, k):",
            "        return self.__class__.__dict__.get(k)",
            "",
            "",
            "class FakeDhcpPort(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.1',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:80:aa:bb:ee'",
            "        self.device_id = 'fake_dhcp_port'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakeReservedPort(object):",
            "    def __init__(self, id='reserved-aaaa-aaaa-aaaa-aaaaaaaaaaa'):",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:80:aa:bb:ee'",
            "        self.device_id = constants.DEVICE_ID_RESERVED_DHCP_PORT",
            "        self.extra_dhcp_opts = []",
            "        self.id = id",
            "",
            "",
            "class FakePort1(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo1'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.2',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:80:aa:bb:cc'",
            "        self.device_id = 'fake_port1'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.2', domain=domain)]",
            "",
            "",
            "class FakePort2(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.admin_state_up = False",
            "        self.device_owner = 'foo2'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port2'",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.3')]",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort3(object):",
            "    def __init__(self):",
            "        self.id = '44444444-4444-4444-4444-444444444444'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.4',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('192.168.1.2',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.4'),",
            "                               FakeDNSAssignment('192.168.1.2')]",
            "        self.mac_address = '00:00:0f:aa:bb:cc'",
            "        self.device_id = 'fake_port3'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort4(object):",
            "    def __init__(self):",
            "        self.id = 'gggggggg-gggg-gggg-gggg-gggggggggggg'",
            "        self.admin_state_up = False",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.4',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('ffda:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('192.168.0.4'),",
            "            FakeDNSAssignment('ffda:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3E:C2:77:1D'",
            "        self.device_id = 'fake_port4'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePort5(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeee'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo5'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.5',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.5')]",
            "        self.mac_address = '00:00:0f:aa:bb:55'",
            "        self.device_id = 'fake_port5'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=edo_ext.DHCP_OPT_CLIENT_ID,",
            "                    opt_value='test5')]",
            "",
            "",
            "class FakePort6(object):",
            "    def __init__(self):",
            "        self.id = 'ccccccccc-cccc-cccc-cccc-ccccccccc'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo6'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.6')]",
            "        self.mac_address = '00:00:0f:aa:bb:66'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=edo_ext.DHCP_OPT_CLIENT_ID,",
            "                    opt_value='test6',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='123.123.123.45',",
            "                    ip_version=constants.IP_VERSION_4)]",
            "",
            "",
            "class FakeV6Port(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('fdca:3ba5:a17a:4ba3::2',",
            "                               domain=domain)]",
            "",
            "",
            "class FakeV6PortExtraOpt(object):",
            "    def __init__(self):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3e:c2:77:1d'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='ffea:3ba5:a17a:4ba3::100',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='malicious-option',",
            "                    opt_value='aaa\\nbbb.ccc\\n',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeV6PortMultipleFixedIpsSameSubnet(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::2',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::4',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:f3:aa:bb:cc'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('fdca:3ba5:a17a:4ba3::2',",
            "                                                 domain=domain),",
            "                               FakeDNSAssignment('fdca:3ba5:a17a:4ba3::4',",
            "                                                 domain=domain)]",
            "",
            "",
            "class FakeDualPortWithV6ExtraOpt(object):",
            "    def __init__(self):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d',",
            "                             'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [",
            "            FakeDNSAssignment('192.168.0.3'),",
            "            FakeDNSAssignment('ffea:3ba5:a17a:4ba3:0216:3eff:fec2:771d')]",
            "        self.mac_address = '00:16:3e:c2:77:1d'",
            "        self.device_id = 'fake_port6'",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='dns-server',",
            "                    opt_value='ffea:3ba5:a17a:4ba3::100',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeDualPort(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh'",
            "        self.admin_state_up = True",
            "        self.device_owner = 'foo3'",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.3',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd'),",
            "            FakeIPAllocation('fdca:3ba5:a17a:4ba3::3',",
            "                             'ffffffff-ffff-ffff-ffff-ffffffffffff')]",
            "        self.mac_address = '00:00:0f:aa:bb:cc'",
            "        self.device_id = 'fake_dual_port'",
            "        self.extra_dhcp_opts = []",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.3', domain=domain),",
            "                               FakeDNSAssignment('fdca:3ba5:a17a:4ba3::3',",
            "                                                 domain=domain)]",
            "",
            "",
            "class FakeRouterPort(object):",
            "    def __init__(self, dev_owner=constants.DEVICE_OWNER_ROUTER_INTF,",
            "                 ip_address='192.168.0.1', domain='openstacklocal'):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.mac_address = '00:00:0f:rr:rr:rr'",
            "        self.device_id = 'fake_router_port'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.device_owner = dev_owner",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            ip_address, 'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment(ip.ip_address, domain=domain)",
            "                               for ip in self.fixed_ips]",
            "",
            "",
            "class FakeRouterHAPort(object):",
            "    def __init__(self):",
            "        self.id = 'hahahaha-haha-haha-haha-hahahahahaha'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_HA_INTF",
            "        self.mac_address = '00:00:0f:aa:aa:aa'",
            "        self.device_id = 'fake_router_ha_port'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            '169.254.169.20', 'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "",
            "",
            "class FakeRouterPortNoDHCP(object):",
            "    def __init__(self, dev_owner=constants.DEVICE_OWNER_ROUTER_INTF,",
            "                 ip_address='192.168.0.1', domain='openstacklocal'):",
            "        self.id = 'ssssssss-ssss-ssss-ssss-ssssssssssss'",
            "        self.admin_state_up = True",
            "        self.mac_address = '00:00:0f:rr:rr:rr'",
            "        self.device_id = 'fake_router_port_no_dhcp'",
            "        self.dns_assignment = []",
            "        self.extra_dhcp_opts = []",
            "        self.device_owner = dev_owner",
            "        self.fixed_ips = [FakeIPAllocation(",
            "            ip_address, 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee')]",
            "        self.dns_assignment = [FakeDNSAssignment(ip.ip_address, domain=domain)",
            "                               for ip in self.fixed_ips]",
            "",
            "",
            "class FakeRouterPort2(object):",
            "    def __init__(self):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_INTF",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.1.1',",
            "                             'cccccccc-cccc-cccc-cccc-cccccccccccc')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.1.1')]",
            "        self.mac_address = '00:00:0f:rr:rr:r2'",
            "        self.device_id = 'fake_router_port2'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakeRouterPortSegmentID(object):",
            "    def __init__(self):",
            "        self.id = 'qqqqqqqq-qqqq-qqqq-qqqq-qqqqqqqqqqqq'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_ROUTER_INTF",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.2.1',",
            "                             'iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.2.1')]",
            "        self.mac_address = '00:00:0f:rr:rr:r3'",
            "        self.device_id = 'fake_router_port3'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortMultipleAgents1(object):",
            "    def __init__(self):",
            "        self.id = 'rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.5',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.5')]",
            "        self.mac_address = '00:00:0f:dd:dd:dd'",
            "        self.device_id = 'fake_multiple_agents_port'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortMultipleAgents2(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.admin_state_up = True",
            "        self.device_owner = constants.DEVICE_OWNER_DHCP",
            "        self.fixed_ips = [",
            "            FakeIPAllocation('192.168.0.6',",
            "                             'dddddddd-dddd-dddd-dddd-dddddddddddd')]",
            "        self.dns_assignment = [FakeDNSAssignment('192.168.0.6')]",
            "        self.mac_address = '00:00:0f:ee:ee:ee'",
            "        self.device_id = 'fake_multiple_agents_port2'",
            "        self.extra_dhcp_opts = []",
            "",
            "",
            "class FakePortWithClientIdNum(object):",
            "    def __init__(self):",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=dhcp.DHCP_OPT_CLIENT_ID_NUM,",
            "                    opt_value='test_client_id_num')]",
            "",
            "",
            "class FakePortWithClientIdNumStr(object):",
            "    def __init__(self):",
            "        self.extra_dhcp_opts = [",
            "            DhcpOpt(opt_name=str(dhcp.DHCP_OPT_CLIENT_ID_NUM),",
            "                    opt_value='test_client_id_num')]",
            "",
            "",
            "class FakeV4HostRoute(object):",
            "    def __init__(self):",
            "        self.destination = '20.0.0.1/24'",
            "        self.nexthop = '20.0.0.1'",
            "",
            "",
            "class FakeV4HostRouteGateway(object):",
            "    def __init__(self):",
            "        self.destination = constants.IPv4_ANY",
            "        self.nexthop = '10.0.0.1'",
            "",
            "",
            "class FakeV6HostRoute(object):",
            "    def __init__(self):",
            "        self.destination = '2001:0200:feed:7ac0::/64'",
            "        self.nexthop = '2001:0200:feed:7ac0::1'",
            "",
            "",
            "class FakeV4Subnet(Dictable):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.ip_version = constants.IP_VERSION_4",
            "        self.cidr = '192.168.0.0/24'",
            "        self.gateway_ip = '192.168.0.1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV4HostRoute()]",
            "        self.dns_nameservers = ['8.8.8.8']",
            "",
            "",
            "class FakeV4Subnet2(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4Subnet2, self).__init__()",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetSegmentID(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetSegmentID, self).__init__()",
            "        self.id = 'iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii'",
            "        self.cidr = '192.168.2.0/24'",
            "        self.gateway_ip = '192.168.2.1'",
            "        self.host_routes = []",
            "        self.segment_id = 1",
            "",
            "",
            "class FakeV4SubnetSegmentID2(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetSegmentID2, self).__init__()",
            "        self.id = 'jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj'",
            "        self.host_routes = []",
            "        self.segment_id = 2",
            "",
            "",
            "class FakeV4MetadataSubnet(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4MetadataSubnet, self).__init__()",
            "        self.cidr = '169.254.169.254/30'",
            "        self.gateway_ip = '169.254.169.253'",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4SubnetGatewayRoute(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetGatewayRoute, self).__init__()",
            "        self.host_routes = [FakeV4HostRouteGateway()]",
            "",
            "",
            "class FakeV4SubnetMultipleAgentsWithoutDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetMultipleAgentsWithoutDnsProvided, self).__init__()",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetAgentWithManyDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetAgentWithManyDnsProvided, self).__init__()",
            "        self.dns_nameservers = ['2.2.2.2', '9.9.9.9', '1.1.1.1', '3.3.3.3']",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4SubnetAgentWithNoDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetAgentWithNoDnsProvided, self).__init__()",
            "        self.dns_nameservers = ['0.0.0.0']",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4MultipleAgentsWithoutDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithoutDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1(), FakePortMultipleAgents2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithoutDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithoutDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithManyDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetAgentWithManyDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4AgentWithNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetAgentWithNoDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4SubnetMultipleAgentsWithDnsProvided(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetMultipleAgentsWithDnsProvided, self).__init__()",
            "        self.host_routes = []",
            "",
            "",
            "class FakeV4MultipleAgentsWithDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.subnets = [FakeV4SubnetMultipleAgentsWithDnsProvided()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort(),",
            "                      FakePortMultipleAgents1(), FakePortMultipleAgents2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6Subnet(object):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'fdca:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'fdca:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.dns_nameservers = ['2001:0200:feed:7ac0::1']",
            "        self.ipv6_ra_mode = None",
            "        self.ipv6_address_mode = None",
            "",
            "",
            "class FakeV4SubnetNoDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_4",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.enable_dhcp = False",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV6SubnetDHCPStateful(Dictable):",
            "    def __init__(self):",
            "        self.id = 'ffffffff-ffff-ffff-ffff-ffffffffffff'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'fdca:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'fdca:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.dns_nameservers = ['2001:0200:feed:7ac0::1']",
            "        self.ipv6_ra_mode = None",
            "        self.ipv6_address_mode = constants.DHCPV6_STATEFUL",
            "",
            "",
            "class FakeV6SubnetSlaac(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffda:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffda:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.host_routes = [FakeV6HostRoute()]",
            "        self.ipv6_address_mode = constants.IPV6_SLAAC",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStateless(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffea:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffea:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStatelessNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffea:3ba5:a17a:4ba3::/64'",
            "        self.gateway_ip = 'ffea:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = ['::']",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV6SubnetStatelessBadPrefixLength(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.ip_version = constants.IP_VERSION_6",
            "        self.cidr = 'ffeb:3ba5:a17a:4ba3::/56'",
            "        self.gateway_ip = 'ffeb:3ba5:a17a:4ba3::1'",
            "        self.enable_dhcp = True",
            "        self.dns_nameservers = []",
            "        self.host_routes = []",
            "        self.ipv6_address_mode = constants.DHCPV6_STATELESS",
            "        self.ipv6_ra_mode = None",
            "",
            "",
            "class FakeV4SubnetNoGateway(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetNoGateway, self).__init__()",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = None",
            "        self.enable_dhcp = True",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4SubnetNoRouter(FakeV4Subnet):",
            "    def __init__(self):",
            "        super(FakeV4SubnetNoRouter, self).__init__()",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.cidr = '192.168.1.0/24'",
            "        self.gateway_ip = '192.168.1.1'",
            "        self.host_routes = []",
            "        self.dns_nameservers = []",
            "",
            "",
            "class FakeV4Network(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientId(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort5(), FakePort6()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientIdNum(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePortWithClientIdNum()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NetworkClientIdNumStr(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePortWithClientIdNumStr()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6Network(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6Subnet()]",
            "        self.ports = [FakePort2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetwork(object):",
            "    def __init__(self, domain='openstacklocal'):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports = [FakePort1(domain=domain), FakeV6Port(domain=domain),",
            "                      FakeDualPort(domain=domain),",
            "                      FakeRouterHAPort(),",
            "                      FakeRouterPort(domain=domain)]",
            "",
            "",
            "class FakeDeviceManagerNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(),",
            "                      FakeV6Port(),",
            "                      FakeDualPort(),",
            "                      FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkReserved(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakeV6Port(), FakeDualPort(),",
            "                      FakeRouterPort(), FakeReservedPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkReserved2(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakeV6Port(), FakeDualPort(),",
            "                      FakeRouterPort(), FakeReservedPort(),",
            "                      FakeReservedPort(id='reserved-2')]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNetworkDhcpPort(object):",
            "    def __init__(self):",
            "        self.id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeDhcpPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkGatewayRoute(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetGatewayRoute(), FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkSingleDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetNoDHCP()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkSingleDHCPBothAttaced(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        # dhcp-agent actually can't get the subnet with dhcp disabled",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeRouterPortNoDHCP(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkDualDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4Subnet2()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPort2()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkDualDHCPOnLinkSubnetRoutesDisabled(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNonLocalSubnets(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetSegmentID2()]",
            "        self.non_local_subnets = [FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeDualNetworkTriDHCPOneOnLinkSubnetRoute(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4Subnet2(),",
            "                        FakeV4SubnetSegmentID()]",
            "        self.ports = [FakePort1(), FakeRouterPort(), FakeRouterPort2(),",
            "                      FakeRouterPortSegmentID()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV4NoGatewayNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetNoGateway()]",
            "        self.ports = [FakePort1()]",
            "",
            "",
            "class FakeV4NetworkNoRouter(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4SubnetNoRouter()]",
            "        self.ports = [FakePort1()]",
            "",
            "",
            "class FakeV4MetadataNetwork(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4MetadataSubnet()]",
            "        self.ports = [FakeRouterPort(ip_address='169.254.169.253')]",
            "",
            "",
            "class FakeV4NetworkDistRouter(object):",
            "    def __init__(self):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(),",
            "                      FakeRouterPort(",
            "                          dev_owner=constants.DEVICE_OWNER_DVR_INTERFACE)]",
            "",
            "",
            "class FakeDualV4Pxe3Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'cccccccc-cccc-cccc-cccc-cccccccccccc'",
            "        self.subnets = [FakeV4Subnet(), FakeV4SubnetNoDHCP()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "",
            "",
            "class FakeV4NetworkPxe2Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort2(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV4NetworkPxe3Ports(object):",
            "    def __init__(self, port_detail=\"portsSame\"):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakePort2(), FakePort3(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        if port_detail == \"portsSame\":",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.1.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.1.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "        else:",
            "            self.ports[0].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0')]",
            "            self.ports[1].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.5'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux2.0')]",
            "            self.ports[2].extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.7'),",
            "                DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux3.0')]",
            "",
            "",
            "class FakeV4NetworkPxePort(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.3',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='server-ip-address', opt_value='192.168.0.2',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='nd98', opt_value='option-nondigit-98',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='99', opt_value='option-99',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_4)]",
            "",
            "",
            "class FakeV6NetworkPxePort(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='2001:192:168::1',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='nd98', opt_value='option-nondigit-98',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='99', opt_value='option-99',",
            "                    ip_version=constants.IP_VERSION_6),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeV6NetworkPxePortWrongOptVersion(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tftp-server', opt_value='192.168.0.7',",
            "                    ip_version=constants.IP_VERSION_4),",
            "            DhcpOpt(opt_name='bootfile-name', opt_value='pxelinux.0',",
            "                    ip_version=constants.IP_VERSION_6)]",
            "",
            "",
            "class FakeDualStackNetworkSingleDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetSlaac()]",
            "        self.ports = [FakePort1(), FakePort4(), FakeRouterPort()]",
            "",
            "",
            "class FakeDualStackNetworkingSingleDHCPTags(object):",
            "    def __init__(self):",
            "        self.id = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        self.subnets = [FakeV4Subnet(), FakeV6SubnetSlaac()]",
            "        self.ports = [FakePort1(), FakePort4(), FakeRouterPort()]",
            "        for port in self.ports:",
            "            port.extra_dhcp_opts = [",
            "                DhcpOpt(opt_name='tag:ipxe,bootfile-name',",
            "                        opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV4NetworkMultipleTags(object):",
            "    def __init__(self):",
            "        self.id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'",
            "        self.subnets = [FakeV4Subnet()]",
            "        self.ports = [FakePort1(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "        self.ports[0].extra_dhcp_opts = [",
            "            DhcpOpt(opt_name='tag:ipxe,bootfile-name', opt_value='pxelinux.0')]",
            "",
            "",
            "class FakeV6NetworkStatelessDHCP(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStateless()]",
            "        self.ports = [FakeV6PortExtraOpt()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatelessDHCPNoDnsProvided(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStatelessNoDnsProvided()]",
            "        self.ports = [FakeV6Port()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatelessDHCPBadPrefixLength(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStatelessBadPrefixLength()]",
            "        self.ports = [FakeV6PortExtraOpt()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeNetworkWithV6SatelessAndV4DHCPSubnets(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetStateless(), FakeV4Subnet()]",
            "        self.ports = [FakeDualPortWithV6ExtraOpt(), FakeRouterPort()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class FakeV6NetworkStatefulDHCPSameSubnetFixedIps(object):",
            "    def __init__(self):",
            "        self.id = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'",
            "        self.subnets = [FakeV6SubnetDHCPStateful()]",
            "        self.ports = [FakeV6PortMultipleFixedIpsSameSubnet()]",
            "        self.namespace = 'qdhcp-ns'",
            "",
            "",
            "class LocalChild(dhcp.DhcpLocalProcess):",
            "    PORTS = {4: [4], 6: [6]}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.process_monitor = mock.Mock()",
            "        kwargs['process_monitor'] = self.process_monitor",
            "        super(LocalChild, self).__init__(*args, **kwargs)",
            "        self.called = []",
            "",
            "    def reload_allocations(self):",
            "        self.called.append('reload')",
            "",
            "    def spawn_process(self):",
            "        self.called.append('spawn')",
            "",
            "",
            "class TestConfBase(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestConfBase, self).setUp()",
            "        self.conf = config.setup_conf()",
            "        self.conf.register_opts(base_config.core_opts)",
            "        self.conf.register_opts(dhcp_config.DHCP_OPTS)",
            "        self.conf.register_opts(dhcp_config.DNSMASQ_OPTS)",
            "        self.conf.register_opts(config.DHCP_PROTOCOL_OPTS)",
            "        config.register_external_process_opts(self.conf)",
            "        config.register_interface_driver_opts_helper(self.conf)",
            "",
            "",
            "class TestBase(TestConfBase):",
            "    def setUp(self):",
            "        super(TestBase, self).setUp()",
            "        instance = mock.patch(\"neutron.agent.linux.dhcp.DeviceManager\")",
            "        self.mock_mgr = instance.start()",
            "        self.conf.register_opt(cfg.BoolOpt('enable_isolated_metadata',",
            "                                           default=True))",
            "        self.conf.register_opt(cfg.BoolOpt(\"force_metadata\",",
            "                                           default=False))",
            "        self.conf.register_opt(cfg.BoolOpt('enable_metadata_network',",
            "                                           default=False))",
            "        self.config_parse(self.conf)",
            "        self.conf.set_override('state_path', '')",
            "",
            "        self.replace_p = mock.patch('neutron_lib.utils.file.replace_file')",
            "        self.execute_p = mock.patch('neutron.agent.common.utils.execute')",
            "        mock.patch('neutron.agent.linux.utils.execute').start()",
            "        self.safe = self.replace_p.start()",
            "        self.execute = self.execute_p.start()",
            "",
            "        self.makedirs = mock.patch('os.makedirs').start()",
            "        self.rmtree = mock.patch('shutil.rmtree').start()",
            "",
            "        self.external_process = mock.patch(",
            "            'neutron.agent.linux.external_process.ProcessManager').start()",
            "",
            "        self.mock_mgr.return_value.driver.bridged = True",
            "",
            "",
            "class TestDhcpBase(TestBase):",
            "",
            "    def test_existing_dhcp_networks_abstract_error(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          dhcp.DhcpBase.existing_dhcp_networks,",
            "                          None)",
            "",
            "    def test_check_version_abstract_error(self):",
            "        self.assertRaises(NotImplementedError,",
            "                          dhcp.DhcpBase.check_version)",
            "",
            "    def test_base_abc_error(self):",
            "        self.assertRaises(TypeError, dhcp.DhcpBase, None)",
            "",
            "    def test_restart(self):",
            "        class SubClass(dhcp.DhcpBase):",
            "            def __init__(self):",
            "                dhcp.DhcpBase.__init__(self, cfg.CONF, FakeV4Network(),",
            "                                       mock.Mock(), None)",
            "                self.called = []",
            "",
            "            def enable(self):",
            "                self.called.append('enable')",
            "",
            "            def disable(self, retain_port=False, block=False):",
            "                self.called.append('disable %s %s' % (retain_port, block))",
            "",
            "            def reload_allocations(self):",
            "                pass",
            "",
            "            @property",
            "            def active(self):",
            "                return True",
            "",
            "        c = SubClass()",
            "        c.restart()",
            "        self.assertEqual(c.called, ['disable True True', 'enable'])",
            "",
            "",
            "class TestDhcpLocalProcess(TestBase):",
            "",
            "    def test_get_conf_file_name(self):",
            "        tpl = '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/dev'",
            "        lp = LocalChild(self.conf, FakeV4Network())",
            "        self.assertEqual(lp.get_conf_file_name('dev'), tpl)",
            "",
            "    @mock.patch.object(fileutils, 'ensure_tree')",
            "    def test_ensure_dir_called(self, ensure_dir):",
            "        LocalChild(self.conf, FakeV4Network())",
            "        ensure_dir.assert_called_once_with(",
            "            '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', mode=0o755)",
            "",
            "    def test_enable_already_active(self):",
            "        with mock.patch.object(LocalChild, 'active') as patched:",
            "            patched.__get__ = mock.Mock(side_effect=[True, False])",
            "            lp = LocalChild(self.conf, FakeV4Network())",
            "            with mock.patch.object(ip_lib, 'delete_network_namespace'):",
            "                lp.enable()",
            "",
            "            self.assertEqual(lp.called, ['spawn'])",
            "            self.assertTrue(self.mock_mgr.return_value.setup.called)",
            "",
            "    @mock.patch.object(fileutils, 'ensure_tree')",
            "    def test_enable(self, ensure_dir):",
            "        attrs_to_mock = dict(",
            "            (a, mock.DEFAULT) for a in",
            "            ['active', 'interface_name', 'spawn_process']",
            "        )",
            "",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            mocks['interface_name'].__set__ = mock.Mock()",
            "            mocks['spawn_process'].side_effect = [",
            "                exceptions.ProcessExecutionError(",
            "                    returncode=2, message=\"Test dnsmasq start failed\"),",
            "                None]",
            "            lp = LocalChild(self.conf,",
            "                            FakeDualNetwork())",
            "",
            "            lp.enable()",
            "",
            "            self.mock_mgr.assert_has_calls(",
            "                [mock.call(self.conf, None),",
            "                 mock.call().setup(mock.ANY)])",
            "            self.assertEqual(2, mocks['interface_name'].__set__.call_count)",
            "            ensure_dir.assert_has_calls([",
            "                mock.call(",
            "                    '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc', mode=0o755),",
            "                mock.call(",
            "                    '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc', mode=0o755)])",
            "",
            "    def _assert_disabled(self, lp):",
            "        self.assertTrue(lp.process_monitor.unregister.called)",
            "        self.assertTrue(self.external_process().disable.called)",
            "",
            "    def test_disable_not_active(self):",
            "        attrs_to_mock = dict((a, mock.DEFAULT) for a in",
            "                             ['active', 'interface_name'])",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "            network = FakeDualNetwork()",
            "            lp = LocalChild(self.conf, network)",
            "            lp.device_manager = mock.Mock()",
            "            with mock.patch('neutron.agent.linux.ip_lib.'",
            "                            'delete_network_namespace') as delete_ns:",
            "                lp.disable()",
            "            lp.device_manager.destroy.assert_called_once_with(",
            "                network, 'tap0')",
            "            self._assert_disabled(lp)",
            "",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_disable_retain_port(self):",
            "        attrs_to_mock = dict((a, mock.DEFAULT) for a in",
            "                             ['active', 'interface_name'])",
            "        network = FakeDualNetwork()",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=True)",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "            lp = LocalChild(self.conf, network)",
            "            lp.disable(retain_port=True)",
            "            self.rmtree.assert_not_called()",
            "            self._assert_disabled(lp)",
            "",
            "    def test_disable(self):",
            "        attrs_to_mock = {'active': mock.DEFAULT}",
            "",
            "        with mock.patch.multiple(LocalChild, **attrs_to_mock) as mocks:",
            "            mocks['active'].__get__ = mock.Mock(return_value=False)",
            "            lp = LocalChild(self.conf, FakeDualNetwork())",
            "            with mock.patch('neutron.agent.linux.ip_lib.'",
            "                            'delete_network_namespace') as delete_ns:",
            "                lp.disable()",
            "                self.rmtree.assert_called_once()",
            "",
            "            self._assert_disabled(lp)",
            "",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_disable_config_dir_removed_after_destroy(self):",
            "        parent = mock.MagicMock()",
            "        parent.attach_mock(self.rmtree, 'rmtree')",
            "        parent.attach_mock(self.mock_mgr, 'DeviceManager')",
            "",
            "        lp = LocalChild(self.conf, FakeDualNetwork())",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'delete_network_namespace') as delete_ns:",
            "            lp.disable(retain_port=False)",
            "",
            "        expected = [mock.call.DeviceManager().destroy(mock.ANY, mock.ANY),",
            "                    mock.call.rmtree(mock.ANY, ignore_errors=True)]",
            "        parent.assert_has_calls(expected)",
            "        delete_ns.assert_called_with('qdhcp-ns')",
            "",
            "    def test_get_interface_name(self):",
            "        net = FakeDualNetwork()",
            "        path = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(path, 'tap0'))",
            "        lp = LocalChild(self.conf, net)",
            "        self.assertEqual(lp.interface_name, 'tap0')",
            "",
            "    def test_set_interface_name(self):",
            "        with mock.patch('neutron_lib.utils.file.replace_file') as replace:",
            "            lp = LocalChild(self.conf, FakeDualNetwork())",
            "            with mock.patch.object(lp, 'get_conf_file_name') as conf_file:",
            "                conf_file.return_value = '/interface'",
            "                lp.interface_name = 'tap0'",
            "                conf_file.assert_called_once_with('interface')",
            "                replace.assert_called_once_with(mock.ANY, 'tap0')",
            "",
            "",
            "class TestDnsmasq(TestBase):",
            "",
            "    def setUp(self):",
            "        super(TestDnsmasq, self).setUp()",
            "        self._mock_get_devices_with_ip = mock.patch.object(",
            "            ip_lib, 'get_devices_with_ip')",
            "        self.mock_get_devices_with_ip = self._mock_get_devices_with_ip.start()",
            "        self.addCleanup(self._stop_mocks)",
            "",
            "    def _stop_mocks(self):",
            "        self._mock_get_devices_with_ip.stop()",
            "",
            "    def _get_dnsmasq(self, network, process_monitor=None):",
            "        process_monitor = process_monitor or mock.Mock()",
            "        return dhcp.Dnsmasq(self.conf, network,",
            "                            process_monitor=process_monitor)",
            "",
            "    def _test_spawn(self, extra_options, network=FakeDualNetwork(),",
            "                    max_leases=16777216, lease_duration=86400,",
            "                    has_static=True, no_resolv='--no-resolv',",
            "                    has_stateless=True, dhcp_t1=0, dhcp_t2=0,",
            "                    bridged=True):",
            "        def mock_get_conf_file_name(kind):",
            "            return '/dhcp/%s/%s' % (network.id, kind)",
            "",
            "        # Empty string passed to --conf-file in dnsmasq is invalid",
            "        # we must force '' to '/dev/null' because the dhcp agent",
            "        # does the same. Therefore we allow empty string to",
            "        # be passed to neutron but not to dnsmasq.",
            "        def check_conf_file_empty(cmd_list):",
            "            for i in cmd_list:",
            "                conf_file = ''",
            "                value = ''",
            "                if i.startswith('--conf-file='):",
            "                    conf_file = i",
            "                    value = i[12:].strip()",
            "                    if not value:",
            "                        idx = cmd_list.index(conf_file)",
            "                        cmd_list[idx] = '--conf-file=/dev/null'",
            "",
            "        # if you need to change this path here, think twice,",
            "        # that means pid files will move around, breaking upgrades",
            "        # or backwards-compatibility",
            "        expected_pid_file = '/dhcp/%s/pid' % network.id",
            "",
            "        expected = [",
            "            'dnsmasq',",
            "            '--no-hosts',",
            "            no_resolv,",
            "            '--pid-file=%s' % expected_pid_file,",
            "            '--dhcp-hostsfile=/dhcp/%s/host' % network.id,",
            "            '--addn-hosts=/dhcp/%s/addn_hosts' % network.id,",
            "            '--dhcp-optsfile=/dhcp/%s/opts' % network.id,",
            "            '--dhcp-leasefile=/dhcp/%s/leases' % network.id,",
            "            '--dhcp-match=set:ipxe,175',",
            "            '--dhcp-userclass=set:ipxe6,iPXE',",
            "            '--local-service',",
            "            '--bind-dynamic',",
            "        ]",
            "        if not bridged:",
            "            expected += [",
            "                '--bridge-interface=tap0,tap*'",
            "            ]",
            "",
            "        seconds = ''",
            "        if lease_duration == -1:",
            "            lease_duration = 'infinite'",
            "        else:",
            "            seconds = 's'",
            "        if has_static:",
            "            prefix = '--dhcp-range=set:subnet-%s,%s,static,%s,%s%s'",
            "            prefix6 = '--dhcp-range=set:subnet-%s,%s,static,%s,%s%s'",
            "        elif has_stateless:",
            "            prefix = '--dhcp-range=set:subnet-%s,%s,%s,%s%s'",
            "            prefix6 = '--dhcp-range=set:subnet-%s,%s,%s,%s%s'",
            "        possible_leases = 0",
            "        for s in network.subnets:",
            "            if (s.ip_version != constants.IP_VERSION_6 or",
            "                    s.ipv6_address_mode == constants.DHCPV6_STATEFUL):",
            "                if s.ip_version == constants.IP_VERSION_4:",
            "                    expected.extend([prefix % (",
            "                        s.id, s.cidr.split('/')[0],",
            "                        netaddr.IPNetwork(s.cidr).netmask, lease_duration,",
            "                        seconds)])",
            "                else:",
            "                    expected.extend([prefix6 % (",
            "                        s.id, s.cidr.split('/')[0], s.cidr.split('/')[1],",
            "                        lease_duration, seconds)])",
            "                possible_leases += netaddr.IPNetwork(s.cidr).size",
            "",
            "        if hasattr(network, 'mtu'):",
            "            expected.append(",
            "                '--dhcp-option-force=option:mtu,%s' % network.mtu)",
            "",
            "        expected.append('--dhcp-lease-max=%d' % min(",
            "            possible_leases, max_leases))",
            "",
            "        if dhcp_t1:",
            "            expected.append('--dhcp-option-force=option:T1,%ds' % dhcp_t1)",
            "        if dhcp_t2:",
            "            expected.append('--dhcp-option-force=option:T2,%ds' % dhcp_t2)",
            "",
            "        expected.extend(extra_options)",
            "        check_conf_file_empty(expected)",
            "",
            "        self.execute.return_value = ('', '')",
            "",
            "        attrs_to_mock = dict(",
            "            (a, mock.DEFAULT) for a in",
            "            ['_output_opts_file', 'get_conf_file_name', 'interface_name']",
            "        )",
            "",
            "        test_pm = mock.Mock()",
            "",
            "        with mock.patch.multiple(dhcp.Dnsmasq, **attrs_to_mock) as mocks:",
            "            mocks['get_conf_file_name'].side_effect = mock_get_conf_file_name",
            "            mocks['_output_opts_file'].return_value = (",
            "                '/dhcp/%s/opts' % network.id",
            "            )",
            "            mocks['interface_name'].__get__ = mock.Mock(return_value='tap0')",
            "",
            "            dm = self._get_dnsmasq(network, test_pm)",
            "            dm.spawn_process()",
            "            self.assertTrue(mocks['_output_opts_file'].called)",
            "",
            "            self.assertTrue(test_pm.register.called)",
            "            self.external_process().enable.assert_called_once_with(",
            "                ensure_active=True, reload_cfg=False)",
            "            call_kwargs = self.external_process.mock_calls[0][2]",
            "            cmd_callback = call_kwargs['default_cmd_callback']",
            "",
            "            result_cmd = cmd_callback(expected_pid_file)",
            "",
            "            self.assertEqual(expected, result_cmd)",
            "",
            "    def test_spawn(self):",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'])",
            "",
            "    def test_spawn_not_bridged(self):",
            "        self.mock_mgr.return_value.driver.bridged = False",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         bridged=False)",
            "",
            "    def test_spawn_infinite_lease_duration(self):",
            "        self.conf.set_override('dhcp_lease_duration', -1)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         FakeDualNetwork(), 16777216, -1)",
            "",
            "    def test_spawn_cfg_config_file(self):",
            "        self.conf.set_override('dnsmasq_config_file', '/foo')",
            "        self._test_spawn(['--conf-file=/foo', '--domain=openstacklocal'])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_spawn_no_dns_domain(self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data) = self._test_no_dns_domain_alloc_data()",
            "        self.conf.set_override('dns_domain', '')",
            "        network = FakeDualNetwork(domain=self.conf.dns_domain)",
            "        self._test_spawn(['--conf-file='], network=network)",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_addn_name, exp_addn_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_spawn_no_dns_domain_tag_support(self, mock_tag_support):",
            "        mock_tag_support.return_value = True",
            "        (exp_host_name, exp_host_data, exp_addn_name,",
            "         exp_addn_data) = self._test_no_dns_domain_alloc_data(",
            "            tag=dhcp.HOST_DHCPV6_TAG)",
            "        self.conf.set_override('dns_domain', '')",
            "        network = FakeDualNetwork(domain=self.conf.dns_domain)",
            "        self._test_spawn(['--conf-file='], network=network)",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_addn_name, exp_addn_data)])",
            "",
            "    def test_spawn_no_dhcp_range(self):",
            "        network = FakeV6Network()",
            "        subnet = FakeV6SubnetSlaac()",
            "        network.subnets = [subnet]",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network, has_static=False)",
            "",
            "    def test_spawn_no_dhcp_range_bad_prefix_length(self):",
            "        network = FakeV6NetworkStatelessDHCPBadPrefixLength()",
            "        subnet = FakeV6SubnetStatelessBadPrefixLength()",
            "        network.subnets = [subnet]",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network, has_static=False, has_stateless=False)",
            "",
            "    def test_spawn_cfg_dns_server(self):",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8'])",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_cfg_multiple_dns_server(self):",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8',",
            "                                                       '9.9.9.9'])",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--server=9.9.9.9',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_cfg_enable_dnsmasq_log(self):",
            "        self.conf.set_override('dnsmasq_base_log_dir', '/tmp')",
            "        network = FakeV4Network()",
            "        dhcp_dns_log = \\",
            "            '/tmp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/dhcp_dns_log'",
            "",
            "        self._test_spawn(['--conf-file=',",
            "                          '--domain=openstacklocal',",
            "                          '--log-queries',",
            "                          '--log-dhcp',",
            "                          ('--log-facility=%s' % dhcp_dns_log)],",
            "                         network)",
            "        self.makedirs.assert_called_with(os.path.join('/tmp', network.id))",
            "",
            "    def test_spawn_cfg_with_local_resolv(self):",
            "        self.conf.set_override('dnsmasq_local_resolv', True)",
            "",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         no_resolv='')",
            "",
            "    def test_spawn_cfg_with_local_resolv_overridden(self):",
            "        self.conf.set_override('dnsmasq_local_resolv', True)",
            "        self.conf.set_override('dnsmasq_dns_servers', ['8.8.8.8'])",
            "",
            "        self._test_spawn(['--conf-file=',",
            "                          '--server=8.8.8.8',",
            "                          '--domain=openstacklocal'])",
            "",
            "    def test_spawn_max_leases_is_smaller_than_cap(self):",
            "        self._test_spawn(",
            "            ['--conf-file=', '--domain=openstacklocal'],",
            "            network=FakeV4Network(),",
            "            max_leases=256)",
            "",
            "    def test_spawn_cfg_broadcast(self):",
            "        self.conf.set_override('dhcp_broadcast_reply', True)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal',",
            "                          '--dhcp-broadcast'])",
            "",
            "    def test_spawn_cfg_advertise_mtu(self):",
            "        network = FakeV4Network()",
            "        network.mtu = 1500",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network)",
            "",
            "    def test_spawn_cfg_advertise_mtu_plugin_doesnt_pass_mtu_value(self):",
            "        network = FakeV4Network()",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         network)",
            "",
            "    def test_spawn_cfg_with_dhcp_timers(self):",
            "        self.conf.set_override('dhcp_renewal_time', 30)",
            "        self.conf.set_override('dhcp_rebinding_time', 100)",
            "        self._test_spawn(['--conf-file=', '--domain=openstacklocal'],",
            "                         dhcp_t1=30, dhcp_t2=100)",
            "",
            "    def _test_output_init_lease_file(self, timestamp):",
            "        expected = [",
            "            '00:00:80:aa:bb:cc 192.168.0.2 * *',",
            "            '00:00:0f:aa:bb:cc 192.168.0.3 * *',",
            "            '00:00:0f:rr:rr:rr 192.168.0.1 * *\\n']",
            "        expected = \"\\n\".join(['%s %s' % (timestamp, le) for le in expected])",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/leases'",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "            dm._output_init_lease_file()",
            "        self.safe.assert_called_once_with('/foo/leases', expected)",
            "",
            "    @mock.patch('time.time')",
            "    def test_output_init_lease_file(self, tmock):",
            "        self.conf.set_override('dhcp_lease_duration', 500)",
            "        tmock.return_value = 1000000",
            "        # lease duration should be added to current time",
            "        timestamp = 1000000 + 500",
            "        self._test_output_init_lease_file(timestamp)",
            "",
            "    def test_output_init_lease_file_infinite_duration(self):",
            "        self.conf.set_override('dhcp_lease_duration', -1)",
            "        # when duration is infinite, lease db timestamp should be 0",
            "        timestamp = 0",
            "        self._test_output_init_lease_file(timestamp)",
            "",
            "    @mock.patch('time.time')",
            "    @mock.patch('os.path.isfile', return_value=True)",
            "    def test_output_init_lease_file_existing(self, isfile, tmock):",
            "",
            "        duid = 'duid 00:01:00:01:27:da:58:97:fa:16:3e:6c:ad:c1'",
            "        ipv4_leases = (",
            "            '1623162161 00:00:80:aa:bb:cc 192.168.0.2 host-192-168-0-2 *\\n'",
            "            '1623147425 00:00:0f:aa:bb:cc 192.168.0.3 host-192-168-0-3 '",
            "            'ff:b5:5e:67:ff:00:02:00:00:ab:11:43:e5:86:52:f3:d7:2c:97\\n'",
            "            '1623138717 00:00:0f:rr:rr:rr 192.168.0.1 host-192-168-0-1 '",
            "            'ff:b5:5e:67:ff:00:02:00:00:ab:11:f6:f2:aa:cb:94:c1:b4:86'",
            "        )",
            "        ipv6_lease_v6_port = (",
            "            '1623083263 755752236 fdca:3ba5:a17a:4ba3::2 '",
            "            'host-fdca-3ba5-a17a-4ba3--2 '",
            "            '00:01:00:01:28:50:e8:31:5a:42:2d:0b:dd:2c'",
            "        )",
            "        additional_ipv6_leases = (",
            "            '1623143299 3042863103 2001:db8::45 host-2001-db8--45 '",
            "            '00:02:00:00:ab:11:fa:c9:0e:0f:3d:90:73:f0\\n'",
            "            '1623134168 3042863103 2001:db8::12 host-2001-db8--12 '",
            "            '00:02:00:00:ab:11:f6:f2:aa:cb:94:c1:b4:86'",
            "        )",
            "        existing_leases = '\\n'.join((ipv4_leases, duid, ipv6_lease_v6_port,",
            "                                     additional_ipv6_leases))",
            "",
            "        # lease duration should be added to current time",
            "        timestamp = 1000000 + 500",
            "        # The expected lease file contains:",
            "        # * The DHCPv6 servers DUID",
            "        # * A lease for all IPv4 addresses",
            "        # * A lease for the IPv6 addresses present in the existing lease file",
            "        #   (IPv6 of FakeV6Port)",
            "        # * No lease for the IPv6 addresses NOT present in the existing lease",
            "        #   file (IPv6 of FakeDualPort)",
            "        # * No lease for the IPv6 addresses present in the existing lease file",
            "        #   which are no longer assigned to any port",
            "        expected = (",
            "            '%s\\n'",
            "            '%s 00:00:80:aa:bb:cc 192.168.0.2 * *\\n'",
            "            '%s\\n'",
            "            '%s 00:00:0f:aa:bb:cc 192.168.0.3 * *\\n'",
            "            '%s 00:00:0f:rr:rr:rr 192.168.0.1 * *\\n'",
            "        ) % (duid, timestamp, ipv6_lease_v6_port, timestamp, timestamp)",
            "",
            "        self.conf.set_override('dhcp_lease_duration', 500)",
            "        tmock.return_value = 1000000",
            "",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/leases'",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "            # Patch __iter__ into mock for Python < 3.8 compatibility",
            "            open_mock = mock.mock_open(read_data=existing_leases)",
            "            open_mock.return_value.__iter__ = lambda s: iter(s.readline, '')",
            "",
            "            with mock.patch('builtins.open', open_mock):",
            "                dm._output_init_lease_file()",
            "",
            "        # Assert the lease file contains the existing ipv6_leases",
            "        self.safe.assert_called_once_with('/foo/leases', expected)",
            "",
            "    def _test_output_opts_file(self, expected, network, ipm_retval=None):",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/opts'",
            "            dm = self._get_dnsmasq(network)",
            "            if ipm_retval:",
            "                with mock.patch.object(",
            "                        dm, '_make_subnet_interface_ip_map') as ipm:",
            "                    ipm.return_value = ipm_retval",
            "                    dm._output_opts_file()",
            "                    self.assertTrue(ipm.called)",
            "            else:",
            "                dm._output_opts_file()",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    def test_output_opts_file(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal'",
            "        ).lstrip() % ('[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetwork())",
            "",
            "    def test_output_opts_file_gateway_route(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal'",
            "        ).lstrip() % ('[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkGatewayRoute())",
            "",
            "    def test_output_opts_file_multiple_agents_without_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,192.168.0.5,192.168.0.6').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4MultipleAgentsWithoutDnsProvided())",
            "",
            "    def test_output_opts_file_agent_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithoutDnsProvided())",
            "",
            "    def test_output_opts_file_agent_with_many_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,2.2.2.2,9.9.9.9,1.1.1.1,3.3.3.3\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithManyDnsProvided())",
            "",
            "    def test_output_opts_file_agent_with_no_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4AgentWithNoDnsProvided())",
            "",
            "    def test_output_opts_file_multiple_agents_with_dns_provided(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4MultipleAgentsWithDnsProvided())",
            "",
            "    def test_output_opts_file_single_dhcp(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkSingleDHCP())",
            "",
            "    def test_output_opts_file_single_dhcp_both_not_isolated(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeDualNetworkSingleDHCPBothAttaced())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:classless-static-route,192.168.0.0/24,0.0.0.0,'",
            "            '169.254.169.254/32,192.168.1.1,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            '249,192.168.0.0/24,0.0.0.0,169.254.169.254/32,192.168.1.1,'",
            "            '0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:router,192.168.1.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualNetworkDualDHCP())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442_no_on_link_subnet_routes(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "            FakeDualNetworkDualDHCPOnLinkSubnetRoutesDisabled())",
            "",
            "    def test_output_opts_file_dual_dhcp_rfc3442_one_on_link_subnet_route(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,'",
            "            '20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:classless-static-route,192.168.0.0/24,0.0.0.0,'",
            "            '169.254.169.254/32,192.168.1.1,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            '249,192.168.0.0/24,0.0.0.0,169.254.169.254/32,192.168.1.1,'",
            "            '0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-cccccccc-cccc-cccc-cccc-cccccccccccc,'",
            "            'option:router,192.168.1.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "            FakeDualNetworkTriDHCPOneOnLinkSubnetRoute())",
            "",
            "    def test_output_opts_file_no_gateway(self):",
            "        expected = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '249,169.254.169.254/32,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:router').lstrip()",
            "",
            "        ipm_retval = {FakeV4SubnetNoGateway().id: '192.168.1.1'}",
            "        self._test_output_opts_file(expected, FakeV4NoGatewayNetwork(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_non_local_subnets(self):",
            "        expected = (",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            '249,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-jjjjjjjj-jjjj-jjjj-jjjj-jjjjjjjjjjjj,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:classless-static-route,169.254.169.254/32,192.168.2.1,'",
            "            '0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            '249,169.254.169.254/32,192.168.2.1,0.0.0.0/0,192.168.2.1\\n'",
            "            'tag:subnet-iiiiiiii-iiii-iiii-iiii-iiiiiiiiiiii,'",
            "            'option:router,192.168.2.1').lstrip()",
            "        ipm_retval = {FakeV4SubnetSegmentID2().id: '192.168.0.1'}",
            "        self._test_output_opts_file(expected, FakeNonLocalSubnets(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_no_neutron_router_on_subnet(self):",
            "        expected = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:classless-static-route,'",
            "            '169.254.169.254/32,192.168.1.2,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '249,169.254.169.254/32,192.168.1.2,0.0.0.0/0,192.168.1.1\\n'",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:router,192.168.1.1').lstrip()",
            "",
            "        ipm_retval = {FakeV4SubnetNoRouter().id: '192.168.1.2'}",
            "        self._test_output_opts_file(expected, FakeV4NetworkNoRouter(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_dist_neutron_router_on_subnet(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1').lstrip()",
            "",
            "        ipm_retval = {FakeV4Subnet().id: '192.168.0.1'}",
            "        self._test_output_opts_file(expected, FakeV4NetworkDistRouter(),",
            "                                    ipm_retval=ipm_retval)",
            "",
            "    def test_output_opts_file_pxe_2port_1net(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeV4NetworkPxe2Ports())",
            "",
            "    def test_output_opts_file_pxe_2port_1net_diff_details(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,192.168.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.0.5\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.0.5\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected,",
            "                                    FakeV4NetworkPxe2Ports(\"portsDiff\"))",
            "",
            "    def test_output_opts_file_pxe_3port_2net(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,192.168.1.0/24,0.0.0.0,20.0.0.1/24,'",
            "            '20.0.0.1,169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,192.168.1.0/24,0.0.0.0,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:tftp-server,192.168.1.3\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:server-ip-address,192.168.1.2\\n'",
            "            'tag:port-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option:bootfile-name,pxelinux2.0\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:tftp-server,192.168.1.3\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:server-ip-address,192.168.1.2\\n'",
            "            'tag:port-44444444-4444-4444-4444-444444444444,'",
            "            'option:bootfile-name,pxelinux3.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeDualV4Pxe3Ports())",
            "",
            "    def test_output_opts_file_pxe_port(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:tftp-server,192.168.0.3\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:server-ip-address,192.168.0.2\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:nd98,option-nondigit-98\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            '99,option-99\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option:bootfile-name,pxelinux.0').lstrip()",
            "",
            "        self._test_output_opts_file(expected, FakeV4NetworkPxePort())",
            "",
            "    def test_output_opts_file_multiple_tags(self):",
            "        expected = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'tag:ipxe,option:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        with mock.patch.object(dhcp.Dnsmasq, 'get_conf_file_name') as conf_fn:",
            "            conf_fn.return_value = '/foo/opts'",
            "            dm = self._get_dnsmasq(FakeV4NetworkMultipleTags())",
            "            dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    @mock.patch('neutron.agent.linux.dhcp.Dnsmasq.get_conf_file_name',",
            "                return_value='/foo/opts')",
            "    def test_output_opts_file_pxe_ipv6_port_with_ipv6_opt(self,",
            "                                                          mock_get_conf_fn):",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:tftp-server,2001:192:168::1\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:nd98,option-nondigit-98\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:99,option-99\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV6NetworkPxePort())",
            "        dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    @mock.patch('neutron.agent.linux.dhcp.Dnsmasq.get_conf_file_name',",
            "                return_value='/foo/opts')",
            "    def test_output_opts_file_pxe_ipv6_port_with_ipv4_opt(self,",
            "                                                          mock_get_conf_fn):",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:bootfile-name,pxelinux.0')",
            "        expected = expected.lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV6NetworkPxePortWrongOptVersion())",
            "        dm._output_opts_file()",
            "",
            "        self.safe.assert_called_once_with('/foo/opts', expected)",
            "",
            "    def test_output_opts_file_ipv6_address_mode_unset(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "                '[' + fake_v6 + ']')",
            "",
            "        self._test_output_opts_file(expected, FakeV6Network())",
            "",
            "    def test_output_opts_file_ipv6_address_force_metadata(self):",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        expected = (",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "                '[' + fake_v6 + ']')",
            "        self.conf.force_metadata = True",
            "        self._test_output_opts_file(expected, FakeV6Network())",
            "",
            "    def _test_no_dns_domain_alloc_data(self, tag=''):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--2,'",
            "                         '[fdca:3ba5:a17a:4ba3::2]\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-3,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--3,'",
            "                         '[fdca:3ba5:a17a:4ba3::3]\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1,'",
            "                         '192.168.0.1\\n').format(tag=tag).lstrip()",
            "        exp_addn_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/addn_hosts'",
            "        exp_addn_data = (",
            "            '192.168.0.2\\t'",
            "            'host-192-168-0-2 host-192-168-0-2\\n'",
            "            'fdca:3ba5:a17a:4ba3::2\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--2 '",
            "            'host-fdca-3ba5-a17a-4ba3--2\\n'",
            "            '192.168.0.3\\thost-192-168-0-3 '",
            "            'host-192-168-0-3\\n'",
            "            'fdca:3ba5:a17a:4ba3::3\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--3 '",
            "            'host-fdca-3ba5-a17a-4ba3--3\\n'",
            "            '192.168.0.1\\t'",
            "            'host-192-168-0-1 '",
            "            'host-192-168-0-1\\n'",
            "        ).lstrip()",
            "        return (exp_host_name, exp_host_data,",
            "                exp_addn_name, exp_addn_data)",
            "",
            "    def _test_reload_allocation_data(self, tag=''):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--2.'",
            "                         'openstacklocal.,[fdca:3ba5:a17a:4ba3::2]\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-3.openstacklocal.,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,{tag}host-fdca-3ba5-a17a-4ba3--3.'",
            "                         'openstacklocal.,[fdca:3ba5:a17a:4ba3::3]\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').format(tag=tag).lstrip()",
            "        exp_addn_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/addn_hosts'",
            "        exp_addn_data = (",
            "            '192.168.0.2\\t'",
            "            'host-192-168-0-2.openstacklocal. host-192-168-0-2\\n'",
            "            'fdca:3ba5:a17a:4ba3::2\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--2.openstacklocal. '",
            "            'host-fdca-3ba5-a17a-4ba3--2\\n'",
            "            '192.168.0.3\\thost-192-168-0-3.openstacklocal. '",
            "            'host-192-168-0-3\\n'",
            "            'fdca:3ba5:a17a:4ba3::3\\t'",
            "            'host-fdca-3ba5-a17a-4ba3--3.openstacklocal. '",
            "            'host-fdca-3ba5-a17a-4ba3--3\\n'",
            "            '192.168.0.1\\t'",
            "            'host-192-168-0-1.openstacklocal. '",
            "            'host-192-168-0-1\\n'",
            "        ).lstrip()",
            "        exp_opt_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/opts'",
            "        fake_v6 = '2001:0200:feed:7ac0::1'",
            "        exp_opt_data = (",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:dns-server,%s\\n'",
            "            'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "            'option6:domain-search,openstacklocal').lstrip() % (",
            "            '[' + fake_v6 + ']')",
            "        return (exp_host_name, exp_host_data,",
            "                exp_addn_name, exp_addn_data,",
            "                exp_opt_name, exp_opt_data,)",
            "",
            "    def test_reload_allocations_no_interface(self):",
            "        net = FakeDualNetwork()",
            "        ipath = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(ipath))",
            "        test_pm = mock.Mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertFalse(test_pm.register.called)",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_reload_allocations(self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data,",
            "         exp_opt_name, exp_opt_data,) = self._test_reload_allocation_data()",
            "",
            "        net = FakeDualNetwork()",
            "        hpath = '/dhcp/%s/host' % net.id",
            "        ipath = '/dhcp/%s/interface' % net.id",
            "        self.useFixture(lib_fixtures.OpenFixture(hpath))",
            "        self.useFixture(lib_fixtures.OpenFixture(ipath, 'tapdancingmice'))",
            "        test_pm = mock.Mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertTrue(test_pm.register.called)",
            "        self.external_process().enable.assert_called_once_with(",
            "            ensure_active=True, reload_cfg=True)",
            "",
            "        self.safe.assert_has_calls([",
            "            mock.call(exp_host_name, exp_host_data),",
            "            mock.call(exp_addn_name, exp_addn_data),",
            "            mock.call(exp_opt_name, exp_opt_data),",
            "        ])",
            "",
            "        mock_tag_support.return_value = True",
            "        (exp_host_name, exp_host_data,",
            "         exp_addn_name, exp_addn_data,",
            "         exp_opt_name, exp_opt_data,) = self._test_reload_allocation_data(",
            "            tag=dhcp.HOST_DHCPV6_TAG)",
            "        test_pm.reset_mock()",
            "        dm = self._get_dnsmasq(net, test_pm)",
            "        dm.reload_allocations()",
            "        self.assertTrue(test_pm.register.called)",
            "",
            "        self.safe.assert_has_calls([",
            "            mock.call(exp_host_name, exp_host_data),",
            "            mock.call(exp_addn_name, exp_addn_data),",
            "            mock.call(exp_opt_name, exp_opt_data),",
            "        ])",
            "",
            "    def test_release_unused_leases(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip3 = '0001:0002:0003:0004:0005:0006:0007:0008'",
            "        mac3 = '00:00:80:bb:aa:cc'",
            "",
            "        old_leases = {(ip1, mac1, None), (ip2, mac2, None), (ip3, mac3, None)}",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip1: {'iaid': mac1,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip3: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {}])",
            "",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = []",
            "        dnsmasq.device_manager.unplug = mock.Mock()",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_has_calls([mock.call(mac1, ip1,",
            "                                                     constants.IP_VERSION_4,",
            "                                                     None, 'server_id', mac1),",
            "                                                 mock.call(mac2, ip2,",
            "                                                     constants.IP_VERSION_4,",
            "                                                     None, 'server_id', mac2),",
            "                                                 mock.call(mac3, ip3,",
            "                                                     constants.IP_VERSION_6,",
            "                                                     'client_id', 'server_id',",
            "                                                     0xff),",
            "                                                 ],",
            "                                                any_order=True)",
            "",
            "    def test_release_for_ipv6_lease(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = 'fdca:3ba5:a17a::1'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "",
            "        old_leases = set([(ip1, mac1, 'client_id'), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip1: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {}])",
            "        mock_dhcp_release = mock.patch.object(priv_dhcp,",
            "                                              'dhcp_release').start()",
            "        mock_dhcp_release6 = mock.patch.object(priv_dhcp,",
            "                                               'dhcp_release6').start()",
            "        mock_dhcp_release6_supported = mock.patch.object(",
            "            priv_dhcp, 'dhcp_release6_supported').start()",
            "        dnsmasq._release_unused_leases()",
            "        # Verify that dhcp_release is called both for ipv4 and ipv6 addresses.",
            "        self.assertEqual(1, mock_dhcp_release.call_count)",
            "        self.assertEqual(1, mock_dhcp_release6.call_count)",
            "        mock_dhcp_release.assert_called_once_with(",
            "            interface_name=None, ip_address=ip2, mac_address=mac2,",
            "            client_id=None, namespace=dnsmasq.network.namespace)",
            "        mock_dhcp_release6.assert_called_once_with(",
            "            interface_name=None, ip_address=ip1, client_id='client_id',",
            "            server_id='server_id', iaid=0xff,",
            "            namespace=dnsmasq.network.namespace)",
            "        mock_dhcp_release6_supported.assert_called_once_with()",
            "",
            "    def test_release_for_ipv6_lease_no_dhcp_release6(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = 'fdca:3ba5:a17a::1'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "",
            "        old_leases = set([(ip1, mac1, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            return_value={'fdca:3ba5:a17a::1': {'iaid': 0xff,",
            "                                                'client_id': 'client_id',",
            "                                                'server_id': 'server_id'}",
            "                          })",
            "        ipw = mock.patch(",
            "            'neutron.agent.linux.ip_lib.IpNetnsCommand.execute').start()",
            "        dnsmasq._IS_DHCP_RELEASE6_SUPPORTED = False",
            "        dnsmasq._release_unused_leases()",
            "        # Verify that dhcp_release6 is not called when it is not present",
            "        ipw.assert_not_called()",
            "",
            "    def test_release_unused_leases_with_dhcp_port(self):",
            "        dnsmasq = self._get_dnsmasq(FakeNetworkDhcpPort())",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            return_value={ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          })",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.device_manager.get_device_id = mock.Mock(",
            "            return_value='fake_dhcp_port')",
            "        dnsmasq._release_unused_leases()",
            "        self.assertFalse(",
            "            dnsmasq.device_manager.unplug.called)",
            "        self.assertFalse(",
            "            dnsmasq.device_manager.driver.unplug.called)",
            "",
            "    def test_release_unused_leases_with_client_id(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.1.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.1.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        client_id2 = 'client2'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, client_id2)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = []",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_has_calls(",
            "            [mock.call(mac1, ip1, constants.IP_VERSION_4, client_id1,",
            "                       'server_id', mac1),",
            "             mock.call(mac2, ip2, constants.IP_VERSION_4, client_id2,",
            "                       'server_id', mac2)],",
            "            any_order=True)",
            "",
            "    def test_release_unused_leases_one_lease(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac2, ip2, constants.IP_VERSION_4, None, 'server_id', mac2)",
            "",
            "    def test_release_unused_leases_one_lease_with_client_id(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.0.5'",
            "        mac2 = '00:00:0f:aa:bb:55'",
            "        client_id2 = 'test5'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, client_id2)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort5()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac1, ip1, constants.IP_VERSION_4, client_id1, 'server_id', mac1)",
            "",
            "    def test_release_unused_leases_one_lease_with_client_id_none(self):",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        client_id1 = 'client1'",
            "        ip2 = '192.168.0.4'",
            "        mac2 = '00:16:3E:C2:77:1D'",
            "        client_id2 = 'test4'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, client_id1), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip1: {'iaid': mac1,",
            "                                'client_id': client_id1,",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': client_id2,",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort4()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac1, ip1, constants.IP_VERSION_4, client_id1, 'server_id', mac1)",
            "",
            "    def test_release_unused_leases_one_lease_from_leases_file(self):",
            "        # leases file has a stale entry that is not in the host file",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second read of the lease file must not have the entries that",
            "        # would have been released.",
            "        dnsmasq._read_leases_file_leases = mock.Mock(",
            "            side_effect=[{ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'},",
            "                          ip2: {'iaid': mac2,",
            "                                'client_id': None,",
            "                                'server_id': 'server_id'}",
            "                          },",
            "                         {ip6: {'iaid': 0xff,",
            "                                'client_id': 'client_id',",
            "                                'server_id': 'server_id'}",
            "                          }])",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        dnsmasq._release_lease.assert_called_once_with(",
            "            mac2, ip2, constants.IP_VERSION_4, None, 'server_id', mac2)",
            "",
            "    @mock.patch.object(dhcp.LOG, 'warn')",
            "    def _test_release_unused_leases_one_lease_mult_times(self, mock_log_warn,",
            "                                                         removed):",
            "        # Simulate a dhcp_release failure where the lease remains in the",
            "        # lease file despite multiple dhcp_release calls",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "        ip1 = '192.168.0.2'",
            "        mac1 = '00:00:80:aa:bb:cc'",
            "        ip2 = '192.168.0.3'",
            "        mac2 = '00:00:80:cc:bb:aa'",
            "        ip6 = '2001:0db8:11a3:09d7:1f34:8a2e:07a0:765d'",
            "",
            "        old_leases = set([(ip1, mac1, None), (ip2, mac2, None)])",
            "        dnsmasq._read_hosts_file_leases = mock.Mock(return_value=old_leases)",
            "        # Because the lease release code could fire multiple times, the",
            "        # second and subsequent reads of the lease file must have the",
            "        # entries that were not released.",
            "        side_effect = [{ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        },",
            "                       {ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        },",
            "                       {ip6: {'iaid': 0xff,",
            "                              'client_id': 'client_id',",
            "                              'server_id': 'server_id'},",
            "                        ip2: {'iaid': mac2,",
            "                              'client_id': None,",
            "                              'server_id': 'server_id'}",
            "                        }]",
            "        # entry did/didn't go away after final dhcp_release try",
            "        if not removed:",
            "            side_effect.append(",
            "                     {ip6: {'iaid': 0xff,",
            "                            'client_id': 'client_id',",
            "                            'server_id': 'server_id'},",
            "                      ip2: {'iaid': mac2,",
            "                            'client_id': None,",
            "                            'server_id': 'server_id'}",
            "                      })",
            "        else:",
            "            side_effect.append({})",
            "",
            "        dnsmasq._read_leases_file_leases = mock.Mock(side_effect=side_effect)",
            "        dnsmasq._output_hosts_file = mock.Mock()",
            "        dnsmasq._release_lease = mock.Mock()",
            "        dnsmasq.network.ports = [FakePort1()]",
            "",
            "        dnsmasq._release_unused_leases()",
            "",
            "        self.assertEqual(dhcp.DHCP_RELEASE_TRIES,",
            "                         dnsmasq._release_lease.call_count)",
            "",
            "        self.assertEqual(dhcp.DHCP_RELEASE_TRIES + 1,",
            "                         dnsmasq._read_leases_file_leases.call_count)",
            "",
            "        if not removed:",
            "            self.assertTrue(mock_log_warn.called)",
            "",
            "    def test_release_unused_leases_one_lease_mult_times_not_removed(self):",
            "        self._test_release_unused_leases_one_lease_mult_times(False)",
            "",
            "    def test_release_unused_leases_one_lease_mult_times_removed(self):",
            "        self._test_release_unused_leases_one_lease_mult_times(True)",
            "",
            "    def test__parse_ip_addresses(self):",
            "        ip_list = ['192.168.0.1', '[fdca:3ba5:a17a::1]', 'no_ip_address']",
            "        self.assertEqual(['192.168.0.1', 'fdca:3ba5:a17a::1'],",
            "                         dhcp.Dnsmasq._parse_ip_addresses(ip_list))",
            "",
            "    def _test_read_hosts_file_leases(self, lines, expected_result):",
            "        filename = '/path/to/file'",
            "        mock_open = self.useFixture(",
            "            lib_fixtures.OpenFixture(filename, '\\n'.join(lines))).mock_open",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "        leases = dnsmasq._read_hosts_file_leases(filename)",
            "        self.assertEqual(expected_result, leases)",
            "        mock_open.assert_called_once_with(filename)",
            "",
            "    def test_read_hosts_file_leases(self):",
            "        lines = [\"00:00:80:aa:bb:cc,inst-name,192.168.0.1\",",
            "                 \"00:00:80:aa:bb:cc,inst-name,[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", None)}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_client_id(self):",
            "        lines = [\"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "                 \"00:00:80:aa:bb:cc,id:client2,inst-name,\"",
            "                 \"[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", 'client2')}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_stateless_IPv6_tag(self):",
            "        lines = [",
            "            \"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "            \"00:00:80:aa:bb:cc,set:ccccccccc-cccc-cccc-cccc-cccccccc\",",
            "            \"00:00:80:aa:bb:cc,id:client2,inst-name,[fdca:3ba5:a17a::1]\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", 'client2')}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def test_read_hosts_file_leases_with_IPv6_tag_and_multiple_ips(self):",
            "        lines = [",
            "            \"00:00:80:aa:bb:cc,id:client1,inst-name,192.168.0.1\",",
            "            \"00:00:80:aa:bb:cc,set:ccccccccc-cccc-cccc-cccc-cccccccc\",",
            "            \"00:00:80:aa:bb:cc,tag:dhcpv6,inst-name,[fdca:3ba5:a17a::1],\"",
            "            \"[fdca:3ba5:a17a::2],[fdca:3ba5:a17a::3],[fdca:3ba5:a17a::4],\"",
            "            \"set:port-fe2baee9-aba9-4b67-be03-be4aeee40cca\"]",
            "        result = {(\"192.168.0.1\", \"00:00:80:aa:bb:cc\", 'client1'),",
            "                  (\"fdca:3ba5:a17a::1\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::2\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::3\", \"00:00:80:aa:bb:cc\", None),",
            "                  (\"fdca:3ba5:a17a::4\", \"00:00:80:aa:bb:cc\", None)}",
            "        self._test_read_hosts_file_leases(lines, result)",
            "",
            "    def _test_read_leases_file_leases(self, add_bad_line=False):",
            "        filename = '/path/to/file'",
            "        lines = [",
            "                \"1472673289 aa:bb:cc:00:00:02 192.168.1.2 host-192-168-1-2 *\",",
            "                \"1472673289 aa:bb:cc:00:00:03 192.168.1.3 host-192-168-1-3 *\",",
            "                \"1472673289 aa:bb:cc:00:00:04 192.168.1.4 host-192-168-1-4 *\",",
            "                \"duid 00:01:00:01:02:03:04:05:06:07:08:09:0a:0b\",",
            "                \"1472597740 1044800001 [2001:DB8::a] host-2001-db8--a \"",
            "                \"00:04:4a:d0:d2:34:19:2b:49:08:84:e8:34:bd:0c:dc:b9:3b\",",
            "                \"1472597823 1044800002 [2001:DB8::b] host-2001-db8--b \"",
            "                \"00:04:ce:96:53:3d:f2:c2:4c:4c:81:7d:db:c9:8d:d2:74:22:3b:0a\",",
            "                \"1472599048 1044800003 [2001:DB8::c] host-2001-db8--c \"",
            "                \"00:04:4f:f0:cd:ca:5e:77:41:bc:9d:7f:5c:33:31:37:5d:80:77:b4\"",
            "                 ]",
            "        bad_line = '1472673289 aa:bb:cc:00:00:05 192.168.1.5 host-192.168-1-5'",
            "        if add_bad_line:",
            "            lines.append(bad_line)",
            "",
            "        mock_open = self.useFixture(",
            "            lib_fixtures.OpenFixture(filename, '\\n'.join(lines))).mock_open",
            "",
            "        dnsmasq = self._get_dnsmasq(FakeDualNetwork())",
            "        with mock.patch('os.path.exists', return_value=True), \\",
            "                mock.patch.object(dhcp.LOG, 'warning') as mock_log_warn:",
            "            leases = dnsmasq._read_leases_file_leases(filename)",
            "        server_id = '00:01:00:01:02:03:04:05:06:07:08:09:0a:0b'",
            "        entry1 = {'iaid': '1044800001',",
            "                  'client_id': '00:04:4a:d0:d2:34:19:2b:49:08:84:'",
            "                               'e8:34:bd:0c:dc:b9:3b',",
            "                  'server_id': server_id",
            "                  }",
            "        entry2 = {'iaid': '1044800002',",
            "                  'client_id': '00:04:ce:96:53:3d:f2:c2:4c:4c:81:'",
            "                               '7d:db:c9:8d:d2:74:22:3b:0a',",
            "                  'server_id': server_id",
            "                  }",
            "        entry3 = {'iaid': '1044800003',",
            "                  'client_id': '00:04:4f:f0:cd:ca:5e:77:41:bc:9d:'",
            "                               '7f:5c:33:31:37:5d:80:77:b4',",
            "                  'server_id': server_id",
            "                  }",
            "        entry4 = {'iaid': 'aa:bb:cc:00:00:02',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        entry5 = {'iaid': 'aa:bb:cc:00:00:03',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        entry6 = {'iaid': 'aa:bb:cc:00:00:04',",
            "                  'client_id': '*',",
            "                  'server_id': None",
            "                  }",
            "        expected = {'2001:DB8::a': entry1,",
            "                    '2001:DB8::b': entry2,",
            "                    '2001:DB8::c': entry3,",
            "                    '192.168.1.2': entry4,",
            "                    '192.168.1.3': entry5,",
            "                    '192.168.1.4': entry6",
            "                    }",
            "",
            "        mock_open.assert_called_once_with(filename)",
            "        self.assertEqual(expected, leases)",
            "        if add_bad_line:",
            "            self.assertTrue(mock_log_warn.called)",
            "",
            "    def test_read_all_leases_file_leases(self):",
            "        self._test_read_leases_file_leases()",
            "",
            "    def test_read_all_leases_file_leases_with_bad_line(self):",
            "        self._test_read_leases_file_leases(add_bad_line=True)",
            "",
            "    def test_make_subnet_interface_ip_map(self):",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'get_devices_with_ip') as list_mock:",
            "            list_mock.return_value = [{'cidr': '192.168.0.1/24'}]",
            "",
            "            dm = self._get_dnsmasq(FakeDualNetwork())",
            "",
            "            self.assertEqual(",
            "                dm._make_subnet_interface_ip_map(),",
            "                {FakeV4Subnet().id: '192.168.0.1'}",
            "            )",
            "",
            "    def test_remove_config_files(self):",
            "        net = FakeV4Network()",
            "        path = '/opt/data/neutron/dhcp'",
            "        self.conf.dhcp_confs = path",
            "        lp = LocalChild(self.conf, net)",
            "        lp._remove_config_files()",
            "        self.rmtree.assert_called_once_with(os.path.join(path, net.id),",
            "                                            ignore_errors=True)",
            "",
            "    def test_existing_dhcp_networks(self):",
            "        path = '/opt/data/neutron/dhcp'",
            "        self.conf.dhcp_confs = path",
            "",
            "        cases = {",
            "            # network_uuid --> is_dhcp_alive?",
            "            'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa': True,",
            "            'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb': False,",
            "            'not_uuid_like_name': True",
            "        }",
            "",
            "        def active_fake(self, instance, cls):",
            "            return cases[instance.network.id]",
            "",
            "        with mock.patch('os.listdir') as mock_listdir:",
            "            with mock.patch.object(dhcp.Dnsmasq, 'active') as mock_active:",
            "                mock_active.__get__ = active_fake",
            "                mock_listdir.return_value = list(cases)",
            "",
            "                result = dhcp.Dnsmasq.existing_dhcp_networks(self.conf)",
            "",
            "                mock_listdir.assert_called_once_with(path)",
            "                self.assertCountEqual(['aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',",
            "                                       'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'],",
            "                                      result)",
            "",
            "    def test__output_hosts_file_log_only_twice(self):",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkSingleDHCP())",
            "        with mock.patch.object(dhcp, 'LOG') as logger:",
            "            logger.process.return_value = ('fake_message', {})",
            "            dm._output_hosts_file()",
            "        # The method logs twice, at the start of and the end. There should be",
            "        # no other logs, no matter how many hosts there are to dump in the",
            "        # file.",
            "        self.assertEqual(2, len(logger.method_calls))",
            "",
            "    def test_only_populates_dhcp_enabled_subnets(self):",
            "        exp_host_name = '/dhcp/eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:16:3E:C2:77:1D,host-192-168-0-4.openstacklocal.,'",
            "                         '192.168.0.4\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkSingleDHCP())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    def test_only_populates_dhcp_client_id(self):",
            "        exp_host_name = '/dhcp/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa/host'",
            "        exp_host_data = (",
            "            '00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "            '192.168.0.2\\n'",
            "            '00:00:0f:aa:bb:55,id:test5,'",
            "            'host-192-168-0-5.openstacklocal.,'",
            "            '192.168.0.5\\n'",
            "            '00:00:0f:aa:bb:66,id:test6,'",
            "            'host-192-168-0-6.openstacklocal.,192.168.0.6,'",
            "            'set:port-ccccccccc-cccc-cccc-cccc-ccccccccc\\n').lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientId())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    def test_only_populates_dhcp_enabled_subnet_on_a_network(self):",
            "        exp_host_name = '/dhcp/cccccccc-cccc-cccc-cccc-cccccccccccc/host'",
            "        exp_host_data = ('00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,'",
            "                         '192.168.0.2\\n'",
            "                         '00:00:f3:aa:bb:cc,host-192-168-0-3.openstacklocal.,'",
            "                         '192.168.0.3\\n'",
            "                         '00:00:0f:aa:bb:cc,host-192-168-0-4.openstacklocal.,'",
            "                         '192.168.0.4\\n'",
            "                         '00:00:0f:rr:rr:rr,host-192-168-0-1.openstacklocal.,'",
            "                         '192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualNetworkSingleDHCP())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name,",
            "                                              exp_host_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_stateless_dhcpv6_network(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n').lstrip()",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:domain-search,openstacklocal\\n'",
            "                        'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "                        'option6:dns-server,ffea:3ba5:a17a:4ba3::100\\n'",
            "                        'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "                        'option6:malicious-option,aaa').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCP())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,tag:dhcpv6,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCP())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_stateful_dhcpv6_same_subnet_fixedips(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        self.conf.set_override('dnsmasq_enable_addr6_list', True)",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:00:f3:aa:bb:cc,host-fdca-3ba5-a17a-4ba3--2.openstacklocal.,'",
            "            '[fdca:3ba5:a17a:4ba3::2],[fdca:3ba5:a17a:4ba3::4]\\n'.lstrip())",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "                        'option6:dns-server,[2001:0200:feed:7ac0::1]\\n'",
            "                        'tag:subnet-ffffffff-ffff-ffff-ffff-ffffffffffff,'",
            "                        'option6:domain-search,openstacklocal').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatefulDHCPSameSubnetFixedIps())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:00:f3:aa:bb:cc,tag:dhcpv6,'",
            "            'host-fdca-3ba5-a17a-4ba3--2.openstacklocal.,'",
            "            '[fdca:3ba5:a17a:4ba3::2],[fdca:3ba5:a17a:4ba3::4]\\n'.lstrip())",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatefulDHCPSameSubnetFixedIps())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_host_and_opts_file_on_stateless_dhcpv6_network_no_dns(self):",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = ('tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:dns-server\\n'",
            "                        'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "                        'option6:domain-search,openstacklocal').lstrip()",
            "        dm = self._get_dnsmasq(FakeV6NetworkStatelessDHCPNoDnsProvided())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, ''),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_host_file_on_net_with_v6_slaac_and_v4(self):",
            "        exp_host_name = '/dhcp/eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee/host'",
            "        exp_host_data = (",
            "            '00:00:80:aa:bb:cc,host-192-168-0-2.openstacklocal.,192.168.0.2,'",
            "            'set:port-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee\\n'",
            "            '00:16:3E:C2:77:1D,host-192-168-0-4.openstacklocal.,192.168.0.4,'",
            "            'set:port-gggggggg-gggg-gggg-gggg-gggggggggggg\\n00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1,'",
            "            'set:port-rrrrrrrr-rrrr-rrrr-rrrr-rrrrrrrrrrrr\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeDualStackNetworkingSingleDHCPTags())",
            "        dm._output_hosts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data)])",
            "",
            "    @mock.patch.object(checks, 'dnsmasq_host_tag_support', autospec=True)",
            "    def test_host_and_opts_file_on_net_with_V6_stateless_and_V4_subnets(",
            "            self, mock_tag_support):",
            "        mock_tag_support.return_value = False",
            "        exp_host_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/host'",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:16:3e:c2:77:1d,host-192-168-0-3.openstacklocal.,'",
            "            '192.168.0.3,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1\\n').lstrip()",
            "        exp_opt_name = '/dhcp/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb/opts'",
            "        exp_opt_data = (",
            "            'tag:subnet-eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee,'",
            "            'option6:domain-search,openstacklocal\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:dns-server,8.8.8.8\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:classless-static-route,20.0.0.1/24,20.0.0.1,'",
            "            '169.254.169.254/32,192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            '249,20.0.0.1/24,20.0.0.1,169.254.169.254/32,'",
            "            '192.168.0.1,0.0.0.0/0,192.168.0.1\\n'",
            "            'tag:subnet-dddddddd-dddd-dddd-dddd-dddddddddddd,'",
            "            'option:router,192.168.0.1\\n'",
            "            'tag:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh,'",
            "            'option6:dns-server,ffea:3ba5:a17a:4ba3::100').lstrip()",
            "",
            "        dm = self._get_dnsmasq(FakeNetworkWithV6SatelessAndV4DHCPSubnets())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "        mock_tag_support.return_value = True",
            "        exp_host_data = (",
            "            '00:16:3e:c2:77:1d,tag:dhcpv6,'",
            "            'set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:16:3e:c2:77:1d,host-192-168-0-3.openstacklocal.,'",
            "            '192.168.0.3,set:port-hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh\\n'",
            "            '00:00:0f:rr:rr:rr,'",
            "            'host-192-168-0-1.openstacklocal.,192.168.0.1\\n').lstrip()",
            "        dm = self._get_dnsmasq(FakeNetworkWithV6SatelessAndV4DHCPSubnets())",
            "        dm._output_hosts_file()",
            "        dm._output_opts_file()",
            "        self.safe.assert_has_calls([mock.call(exp_host_name, exp_host_data),",
            "                                    mock.call(exp_opt_name, exp_opt_data)])",
            "",
            "    def test_has_metadata_subnet_returns_true(self):",
            "        self.assertTrue(dhcp.Dnsmasq.has_metadata_subnet(",
            "            [FakeV4MetadataSubnet()]))",
            "",
            "    def test_has_metadata_subnet_returns_false(self):",
            "        self.assertFalse(dhcp.Dnsmasq.has_metadata_subnet(",
            "            [FakeV4Subnet()]))",
            "",
            "    def test_should_enable_metadata_isolated_network_returns_true(self):",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4NetworkNoRouter()))",
            "",
            "    def test_should_enable_metadata_isolated_network_returns_true_ipv6(self):",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV6Network()))",
            "",
            "    def test_should_enable_metadata_non_isolated_network_returns_false(self):",
            "        self.assertFalse(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4NetworkDistRouter()))",
            "",
            "    def test_should_enable_metadata_isolated_meta_disabled_returns_false(self):",
            "        self.conf.set_override('enable_isolated_metadata', False)",
            "        self.assertFalse(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4MetadataNetwork()))",
            "",
            "    def test_should_enable_metadata_with_metadata_network_returns_true(self):",
            "        self.conf.set_override('enable_metadata_network', True)",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeV4MetadataNetwork()))",
            "",
            "    def test_should_force_metadata_returns_true(self):",
            "        self.conf.set_override(\"force_metadata\", True)",
            "        self.assertTrue(dhcp.Dnsmasq.should_enable_metadata(",
            "            self.conf, FakeDualNetworkDualDHCP()))",
            "",
            "    def _test__generate_opts_per_subnet_helper(",
            "            self, config_opts, expected_mdt_ip,",
            "            network_class=FakeNetworkDhcpPort):",
            "        for key, value in config_opts.items():",
            "            self.conf.set_override(key, value)",
            "        dm = self._get_dnsmasq(network_class())",
            "        with mock.patch('neutron.agent.linux.ip_lib.'",
            "                        'get_devices_with_ip') as list_mock:",
            "            list_mock.return_value = [{'cidr': alloc.ip_address + '/24'}",
            "                                      for alloc in FakeDhcpPort().fixed_ips]",
            "            options, idx_map = dm._generate_opts_per_subnet()",
            "",
            "        contains_metadata_ip = any(['%s' % constants.METADATA_CIDR in line",
            "                                    for line in options])",
            "        self.assertEqual(expected_mdt_ip, contains_metadata_ip)",
            "",
            "    def test__generate_opts_per_subnet_no_metadata(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': False}",
            "        self._test__generate_opts_per_subnet_helper(config, False)",
            "",
            "    def test__generate_opts_per_subnet_isolated_metadata_with_router(self):",
            "        config = {'enable_isolated_metadata': True,",
            "                  'force_metadata': False}",
            "        self._test__generate_opts_per_subnet_helper(config, True)",
            "",
            "    def test__generate_opts_per_subnet_forced_metadata(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': True}",
            "        self._test__generate_opts_per_subnet_helper(config, True)",
            "",
            "    def test__generate_opts_per_subnet_forced_metadata_non_local_subnet(self):",
            "        config = {'enable_isolated_metadata': False,",
            "                  'force_metadata': True}",
            "        self._test__generate_opts_per_subnet_helper(",
            "            config, True, network_class=FakeNonLocalSubnets)",
            "",
            "    def test_client_id_num(self):",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientIdNum())",
            "        self.assertEqual('test_client_id_num',",
            "                         dm._get_client_id(FakePortWithClientIdNum()))",
            "",
            "    def test_client_id_num_str(self):",
            "        dm = self._get_dnsmasq(FakeV4NetworkClientIdNumStr())",
            "        self.assertEqual('test_client_id_num',",
            "                         dm._get_client_id(FakePortWithClientIdNumStr()))",
            "",
            "",
            "class TestDeviceManager(TestConfBase):",
            "    def setUp(self):",
            "        super(TestDeviceManager, self).setUp()",
            "        ip_lib_patcher = mock.patch('neutron.agent.linux.dhcp.ip_lib')",
            "        load_interface_driver_patcher = mock.patch(",
            "            'neutron.agent.linux.dhcp.agent_common_utils.'",
            "            'load_interface_driver')",
            "        self.mock_ip_lib = ip_lib_patcher.start()",
            "        self.mock_load_interface_driver = load_interface_driver_patcher.start()",
            "",
            "    def _test_setup(self, load_interface_driver, ip_lib, use_gateway_ips):",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(cfg.BoolOpt('enable_isolated_metadata',",
            "                                               default=False))",
            "            self.conf.register_opt(cfg.BoolOpt('force_metadata',",
            "                                               default=False))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with no existing DHCP port - expect a new DHCP port to",
            "            # be created.",
            "            network = FakeDeviceManagerNetwork()",
            "            network.tenant_id = 'Tenant A'",
            "",
            "            def mock_create(dict):",
            "                port = dhcp.DictModel(dict['port'])",
            "                port.id = 'abcd-123456789'",
            "                port.mac_address = '00-12-34-56-78-90'",
            "                port.fixed_ips = [",
            "                    dhcp.DictModel({'subnet_id': ip['subnet_id'],",
            "                                    'ip_address': 'unique-IP-address'})",
            "                    for ip in port.fixed_ips",
            "                ]",
            "                # server rudely gave us an extra address we didn't ask for",
            "                port.fixed_ips.append(dhcp.DictModel(",
            "                    {'subnet_id': 'ffffffff-6666-6666-6666-ffffffffffff',",
            "                     'ip_address': '2003::f816:3eff:fe45:e893'}))",
            "                return port",
            "",
            "            plugin.create_dhcp_port.side_effect = mock_create",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = use_gateway_ips",
            "            ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.create_dhcp_port.assert_called_with(mock.ANY)",
            "",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  mock.ANY,",
            "                                                  namespace='qdhcp-ns')",
            "            cidrs = set(mgr.driver.init_l3.call_args[0][1])",
            "            if use_gateway_ips:",
            "                self.assertEqual(cidrs, set(['%s/%s' % (s.gateway_ip,",
            "                                                        s.cidr.split('/')[1])",
            "                                             for s in network.subnets]))",
            "            else:",
            "                self.assertEqual(cidrs, set(['unique-IP-address/24',",
            "                                         'unique-IP-address/64']))",
            "",
            "            # Now call setup again.  This time we go through the existing",
            "            # port code path, and the driver's init_l3 method is called",
            "            # again.",
            "            plugin.create_dhcp_port.reset_mock()",
            "            mgr.driver.init_l3.reset_mock()",
            "            mgr.setup(network)",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  mock.ANY,",
            "                                                  namespace='qdhcp-ns')",
            "            cidrs = set(mgr.driver.init_l3.call_args[0][1])",
            "            if use_gateway_ips:",
            "                self.assertEqual(cidrs, set(['%s/%s' % (s.gateway_ip,",
            "                                                        s.cidr.split('/')[1])",
            "                                             for s in network.subnets]))",
            "            else:",
            "                self.assertEqual(cidrs, set(['unique-IP-address/24',",
            "                                             'unique-IP-address/64']))",
            "            self.assertFalse(plugin.create_dhcp_port.called)",
            "",
            "    def test_setup_device_manager_dhcp_port_without_gateway_ips(self):",
            "        self._test_setup(self.mock_load_interface_driver,",
            "                         self.mock_ip_lib, use_gateway_ips=False)",
            "",
            "    def test_setup_device_manager_dhcp_port_with_gateway_ips(self):",
            "        self._test_setup(self.mock_load_interface_driver,",
            "                         self.mock_ip_lib, use_gateway_ips=True)",
            "",
            "    def _test_setup_reserved(self, enable_isolated_metadata=False,",
            "                             force_metadata=False):",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('enable_isolated_metadata',",
            "                            default=enable_isolated_metadata))",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('force_metadata',",
            "                            default=force_metadata))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            self.mock_load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with a reserved DHCP port.",
            "            network = FakeDualNetworkReserved()",
            "            network.tenant_id = 'Tenant A'",
            "            reserved_port = network.ports[-1]",
            "",
            "            def mock_update(port_id, dict):",
            "                port = reserved_port",
            "                port.network_id = dict['port']['network_id']",
            "                port.device_id = dict['port']['device_id']",
            "                return port",
            "",
            "            plugin.update_dhcp_port.side_effect = mock_update",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = False",
            "            self.mock_ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.update_dhcp_port.assert_called_with(reserved_port.id,",
            "                                                       mock.ANY)",
            "",
            "            expect_ips = ['192.168.0.6/24', 'fdca:3ba5:a17a:4ba3::2/64']",
            "            if enable_isolated_metadata or force_metadata:",
            "                expect_ips.extend([",
            "                    constants.METADATA_CIDR,",
            "                    constants.METADATA_V6_CIDR])",
            "            mgr.driver.init_l3.assert_called_with('ns-XXX',",
            "                                                  expect_ips,",
            "                                                  namespace='qdhcp-ns')",
            "",
            "    def test_setup_reserved_and_disable_metadata(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which metadata disabled.",
            "        \"\"\"",
            "        self._test_setup_reserved()",
            "",
            "    def test_setup_reserved_with_isolated_metadata_enable(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which isolated_ metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(enable_isolated_metadata=True)",
            "",
            "    def test_setup_reserved_with_force_metadata_enable(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which force_metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(force_metadata=True)",
            "",
            "    def test_setup_reserved_and_enable_metadata(self):",
            "        \"\"\"Test reserved port case of DeviceManager's DHCP port setup",
            "        logic which both isolated_metadata and force_metadata enabled.",
            "        \"\"\"",
            "        self._test_setup_reserved(enable_isolated_metadata=True,",
            "                                  force_metadata=True)",
            "",
            "    def test_setup_reserved_2(self):",
            "        \"\"\"Test scenario where a network has two reserved ports, and",
            "        update_dhcp_port fails for the first of those.",
            "        \"\"\"",
            "        with mock.patch.object(dhcp.ip_lib, 'IPDevice') as mock_IPDevice:",
            "            # Create DeviceManager.",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('enable_isolated_metadata', default=False))",
            "            self.conf.register_opt(",
            "                cfg.BoolOpt('force_metadata', default=False))",
            "            plugin = mock.Mock()",
            "            device = mock.Mock()",
            "            mock_IPDevice.return_value = device",
            "            device.route.get_gateway.return_value = None",
            "            mgr = dhcp.DeviceManager(self.conf, plugin)",
            "            self.mock_load_interface_driver.assert_called_with(",
            "                self.conf, get_networks_callback=plugin.get_networks)",
            "",
            "            # Setup with a reserved DHCP port.",
            "            network = FakeDualNetworkReserved2()",
            "            network.tenant_id = 'Tenant A'",
            "            reserved_port_1 = network.ports[-2]",
            "            reserved_port_2 = network.ports[-1]",
            "",
            "            def mock_update(port_id, dict):",
            "                if port_id == reserved_port_1.id:",
            "                    return None",
            "",
            "                port = reserved_port_2",
            "                port.network_id = dict['port']['network_id']",
            "                port.device_id = dict['port']['device_id']",
            "                return port",
            "",
            "            plugin.update_dhcp_port.side_effect = mock_update",
            "            mgr.driver.get_device_name.return_value = 'ns-XXX'",
            "            mgr.driver.use_gateway_ips = False",
            "            self.mock_ip_lib.ensure_device_is_ready.return_value = True",
            "            mgr.setup(network)",
            "            plugin.update_dhcp_port.assert_called_with(reserved_port_2.id,",
            "                                                       mock.ANY)",
            "",
            "            mgr.driver.init_l3.assert_called_with(",
            "                'ns-XXX', ['192.168.0.6/24', 'fdca:3ba5:a17a:4ba3::2/64'],",
            "                namespace='qdhcp-ns')",
            "",
            "    def test__setup_reserved_dhcp_port_with_fake_remote_error(self):",
            "        \"\"\"Test scenario where a fake_network has two reserved ports, and",
            "        update_dhcp_port fails for the first of those with a RemoteError.",
            "        \"\"\"",
            "        # Setup with a reserved DHCP port.",
            "        fake_network = FakeDualNetworkReserved2()",
            "        fake_network.tenant_id = 'Tenant A'",
            "        reserved_port_2 = fake_network.ports[-1]",
            "",
            "        mock_plugin = mock.Mock()",
            "        dh = dhcp.DeviceManager(cfg.CONF, mock_plugin)",
            "        messaging_error = oslo_messaging.RemoteError(",
            "            exc_type='FakeRemoteError')",
            "        mock_plugin.update_dhcp_port.side_effect = [messaging_error,",
            "                                                    reserved_port_2]",
            "",
            "        with testtools.ExpectedException(oslo_messaging.RemoteError):",
            "            dh.setup_dhcp_port(fake_network)",
            "",
            "",
            "class TestDictModel(base.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestDictModel, self).setUp()",
            "        self._a = uuidutils.generate_uuid()",
            "        self._b = uuidutils.generate_uuid()",
            "        self.dm = dhcp.DictModel(a=self._a, b=self._b)",
            "",
            "    def test_basic_dict(self):",
            "        d = dict(a=1, b=2)",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(1, m.a)",
            "        self.assertEqual(2, m.b)",
            "",
            "    def test_dict_has_sub_dict(self):",
            "        d = dict(a=dict(b=2))",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(2, m.a.b)",
            "",
            "    def test_dict_contains_list(self):",
            "        d = dict(a=[1, 2])",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual([1, 2], m.a)",
            "",
            "    def test_dict_contains_list_of_dicts(self):",
            "        d = dict(a=[dict(b=2), dict(c=3)])",
            "        m = dhcp.DictModel(d)",
            "        self.assertEqual(2, m.a[0].b)",
            "        self.assertEqual(3, m.a[1].c)",
            "",
            "    def test_string_representation_port(self):",
            "        port = dhcp.DictModel({'id': 'id', 'network_id': 'net_id'})",
            "        self.assertEqual('id=id, network_id=net_id', str(port))",
            "",
            "    def test_string_representation_network(self):",
            "        net = dhcp.DictModel({'id': 'id', 'name': 'myname'})",
            "        self.assertEqual('id=id, name=myname', str(net))",
            "",
            "    def test__init_parameters(self):",
            "        self.assertEqual(self._a, self.dm.a)",
            "        self.assertEqual(self._b, self.dm.b)",
            "",
            "    def test__init_dictmodel(self):",
            "        dm2 = dhcp.DictModel(self.dm)",
            "        self.assertEqual(self._a, dm2.a)",
            "        self.assertEqual(self._b, dm2.b)",
            "        dm2.a = 'new_value'",
            "        self.assertEqual('new_value', dm2.a)",
            "        self.assertEqual(self._a, self.dm.a)",
            "",
            "    def test__getattr(self):",
            "        self.assertEqual({'a': self._a, 'b': self._b},",
            "                         self.dm._dictmodel_internal_storage)",
            "        try:",
            "            self.dm.z",
            "        except AttributeError:",
            "            pass",
            "        except Exception:",
            "            self.fail('Getting a non existing attribute from a DictModel '",
            "                      'object should raise AttributeError')",
            "",
            "    def test__setattr(self):",
            "        self.dm.c = 'c_value'",
            "        self.assertEqual('c_value', self.dm.c)",
            "",
            "    def test__delattr(self):",
            "        del self.dm.a",
            "        self.assertIsNone(self.dm.get('a'))",
            "",
            "    def test__str(self):",
            "        reference = 'a=%s, b=%s' % (self._a, self._b)",
            "        self.assertEqual(reference, str(self.dm))",
            "",
            "    def test__getitem(self):",
            "        self.assertEqual(self._a, self.dm['a'])",
            "        self.assertEqual(self._b, self.dm['b'])",
            "",
            "    def test__setitem(self):",
            "        self.dm['a'] = 'a_new_value'",
            "        self.assertEqual('a_new_value', self.dm.a)",
            "        self.assertEqual('a_new_value', self.dm['a'])",
            "        self.assertEqual(self._b, self.dm.b)",
            "",
            "    def test__iter(self):",
            "        list_keys = sorted(list(self.dm))",
            "        self.assertEqual(['a', 'b'], list_keys)",
            "",
            "    def test__len(self):",
            "        self.assertEqual(2, len(self.dm))",
            "",
            "    def test__copy_and_deepcopy(self):",
            "        for method in (copy.copy, copy.deepcopy):",
            "            self.dm._tuple = (10, 11)",
            "            self.dm._list = [20, 21]",
            "            dm2 = method(self.dm)",
            "            dm2._tuple = (30, 31)",
            "            dm2._list[0] = 200",
            "            self.assertEqual((10, 11), self.dm._tuple)",
            "            self.assertEqual([20, 21], self.dm._list)",
            "            self.assertEqual((30, 31), dm2._tuple)",
            "            self.assertEqual([200, 21], dm2._list)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2913": [
                "TestDnsmasq",
                "test_host_and_opts_file_on_stateless_dhcpv6_network"
            ]
        },
        "addLocation": [
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6PortExtraOpt.extra_dhcp_opts",
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6PortExtraOpt.dns_assignment",
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6PortExtraOpt.fixed_ips",
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6NetworkStatelessDHCPBadPrefixLength.__init__",
            "hpack",
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6NetworkStatelessDHCP.__init__",
            "neutron.tests.unit.agent.linux.test_dhcp.FakeV6PortExtraOpt"
        ]
    }
}