{
    "airflow/providers/apache/drill/hooks/drill.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         \"\"\"Establish a connection to Drillbit.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         conn_md = self.get_connection(getattr(self, self.conn_name_attr))"
            },
            "2": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         creds = f\"{conn_md.login}:{conn_md.password}@\" if conn_md.login else \"\""
            },
            "3": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if \"/\" in conn_md.host or \"&\" in conn_md.host:"
            },
            "4": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError(\"Drill host should not contain '/&' characters\")"
            },
            "5": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        engine = create_engine("
            },
            "6": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            f'{conn_md.extra_dejson.get(\"dialect_driver\", \"drill+sadrill\")}://{creds}'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        database_url = ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            f\"{conn_md.extra_dejson.get('dialect_driver', 'drill+sadrill')}://{creds}\""
            },
            "9": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             f\"{conn_md.host}:{conn_md.port}/\""
            },
            "10": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             f'{conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")}'"
            },
            "11": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         )"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        if \"?\" in database_url:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            raise ValueError(\"Drill database_url should not contain a '?'\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        engine = create_engine(database_url)"
            },
            "15": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         self.log.info("
            },
            "17": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             \"Connected to the Drillbit at %s:%s as user %s\", conn_md.host, conn_md.port, conn_md.login"
            },
            "18": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         storage_plugin = conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")"
            },
            "19": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         return f\"{conn_type}://{host}/{storage_plugin}?dialect_driver={dialect_driver}\""
            },
            "20": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def set_autocommit(self, conn: Connection, autocommit: bool) -> NotImplementedError:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    # The superclass DbApiHook's method implementation has a return type `None` and mypy fails saying"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    # return type `NotImplementedError` is incompatible with it. Hence, we ignore the mypy error here."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    def set_autocommit(  # type: ignore[override]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        self, conn: Connection, autocommit: bool"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+    ) -> NotImplementedError:"
            },
            "27": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         raise NotImplementedError(\"There are no transactions in Drill.\")"
            },
            "28": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def insert_rows("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    # The superclass DbApiHook's method implementation has a return type `None` and mypy fails saying"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    # return type `NotImplementedError` is incompatible with it. Hence, we ignore the mypy error here."
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    def insert_rows(  # type: ignore[override]"
            },
            "33": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self,"
            },
            "34": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         table: str,"
            },
            "35": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         rows: Iterable[tuple[str]],"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import Any, Iterable",
            "",
            "from sqlalchemy import create_engine",
            "from sqlalchemy.engine import Connection",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "",
            "",
            "class DrillHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with Apache Drill via sqlalchemy-drill.",
            "",
            "    You can specify the SQLAlchemy dialect and driver that sqlalchemy-drill",
            "    will employ to communicate with Drill in the extras field of your",
            "    connection, e.g. ``{\"dialect_driver\": \"drill+sadrill\"}`` for communication",
            "    over Drill's REST API.  See the sqlalchemy-drill documentation for",
            "    descriptions of the supported dialects and drivers.",
            "",
            "    You can specify the default storage_plugin for the sqlalchemy-drill",
            "    connection using the extras field e.g. ``{\"storage_plugin\": \"dfs\"}``.",
            "    \"\"\"",
            "",
            "    conn_name_attr = \"drill_conn_id\"",
            "    default_conn_name = \"drill_default\"",
            "    conn_type = \"drill\"",
            "    hook_name = \"Drill\"",
            "    supports_autocommit = False",
            "",
            "    def get_conn(self) -> Connection:",
            "        \"\"\"Establish a connection to Drillbit.\"\"\"",
            "        conn_md = self.get_connection(getattr(self, self.conn_name_attr))",
            "        creds = f\"{conn_md.login}:{conn_md.password}@\" if conn_md.login else \"\"",
            "        if \"/\" in conn_md.host or \"&\" in conn_md.host:",
            "            raise ValueError(\"Drill host should not contain '/&' characters\")",
            "        engine = create_engine(",
            "            f'{conn_md.extra_dejson.get(\"dialect_driver\", \"drill+sadrill\")}://{creds}'",
            "            f\"{conn_md.host}:{conn_md.port}/\"",
            "            f'{conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")}'",
            "        )",
            "",
            "        self.log.info(",
            "            \"Connected to the Drillbit at %s:%s as user %s\", conn_md.host, conn_md.port, conn_md.login",
            "        )",
            "        return engine.raw_connection()",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"",
            "        Returns the connection URI.",
            "",
            "        e.g: ``drill://localhost:8047/dfs``",
            "        \"\"\"",
            "        conn_md = self.get_connection(getattr(self, self.conn_name_attr))",
            "        host = conn_md.host",
            "        if conn_md.port is not None:",
            "            host += f\":{conn_md.port}\"",
            "        conn_type = conn_md.conn_type or \"drill\"",
            "        dialect_driver = conn_md.extra_dejson.get(\"dialect_driver\", \"drill+sadrill\")",
            "        storage_plugin = conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")",
            "        return f\"{conn_type}://{host}/{storage_plugin}?dialect_driver={dialect_driver}\"",
            "",
            "    def set_autocommit(self, conn: Connection, autocommit: bool) -> NotImplementedError:",
            "        raise NotImplementedError(\"There are no transactions in Drill.\")",
            "",
            "    def insert_rows(",
            "        self,",
            "        table: str,",
            "        rows: Iterable[tuple[str]],",
            "        target_fields: Iterable[str] | None = None,",
            "        commit_every: int = 1000,",
            "        replace: bool = False,",
            "        **kwargs: Any,",
            "    ) -> NotImplementedError:",
            "        raise NotImplementedError(\"There is no INSERT statement in Drill.\")"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from typing import Any, Iterable",
            "",
            "from sqlalchemy import create_engine",
            "from sqlalchemy.engine import Connection",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "",
            "",
            "class DrillHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with Apache Drill via sqlalchemy-drill.",
            "",
            "    You can specify the SQLAlchemy dialect and driver that sqlalchemy-drill",
            "    will employ to communicate with Drill in the extras field of your",
            "    connection, e.g. ``{\"dialect_driver\": \"drill+sadrill\"}`` for communication",
            "    over Drill's REST API.  See the sqlalchemy-drill documentation for",
            "    descriptions of the supported dialects and drivers.",
            "",
            "    You can specify the default storage_plugin for the sqlalchemy-drill",
            "    connection using the extras field e.g. ``{\"storage_plugin\": \"dfs\"}``.",
            "    \"\"\"",
            "",
            "    conn_name_attr = \"drill_conn_id\"",
            "    default_conn_name = \"drill_default\"",
            "    conn_type = \"drill\"",
            "    hook_name = \"Drill\"",
            "    supports_autocommit = False",
            "",
            "    def get_conn(self) -> Connection:",
            "        \"\"\"Establish a connection to Drillbit.\"\"\"",
            "        conn_md = self.get_connection(getattr(self, self.conn_name_attr))",
            "        creds = f\"{conn_md.login}:{conn_md.password}@\" if conn_md.login else \"\"",
            "        database_url = (",
            "            f\"{conn_md.extra_dejson.get('dialect_driver', 'drill+sadrill')}://{creds}\"",
            "            f\"{conn_md.host}:{conn_md.port}/\"",
            "            f'{conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")}'",
            "        )",
            "        if \"?\" in database_url:",
            "            raise ValueError(\"Drill database_url should not contain a '?'\")",
            "        engine = create_engine(database_url)",
            "",
            "        self.log.info(",
            "            \"Connected to the Drillbit at %s:%s as user %s\", conn_md.host, conn_md.port, conn_md.login",
            "        )",
            "        return engine.raw_connection()",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"",
            "        Returns the connection URI.",
            "",
            "        e.g: ``drill://localhost:8047/dfs``",
            "        \"\"\"",
            "        conn_md = self.get_connection(getattr(self, self.conn_name_attr))",
            "        host = conn_md.host",
            "        if conn_md.port is not None:",
            "            host += f\":{conn_md.port}\"",
            "        conn_type = conn_md.conn_type or \"drill\"",
            "        dialect_driver = conn_md.extra_dejson.get(\"dialect_driver\", \"drill+sadrill\")",
            "        storage_plugin = conn_md.extra_dejson.get(\"storage_plugin\", \"dfs\")",
            "        return f\"{conn_type}://{host}/{storage_plugin}?dialect_driver={dialect_driver}\"",
            "",
            "    # The superclass DbApiHook's method implementation has a return type `None` and mypy fails saying",
            "    # return type `NotImplementedError` is incompatible with it. Hence, we ignore the mypy error here.",
            "    def set_autocommit(  # type: ignore[override]",
            "        self, conn: Connection, autocommit: bool",
            "    ) -> NotImplementedError:",
            "        raise NotImplementedError(\"There are no transactions in Drill.\")",
            "",
            "    # The superclass DbApiHook's method implementation has a return type `None` and mypy fails saying",
            "    # return type `NotImplementedError` is incompatible with it. Hence, we ignore the mypy error here.",
            "    def insert_rows(  # type: ignore[override]",
            "        self,",
            "        table: str,",
            "        rows: Iterable[tuple[str]],",
            "        target_fields: Iterable[str] | None = None,",
            "        commit_every: int = 1000,",
            "        replace: bool = False,",
            "        **kwargs: Any,",
            "    ) -> NotImplementedError:",
            "        raise NotImplementedError(\"There is no INSERT statement in Drill.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "DrillHook",
                "get_conn"
            ],
            "53": [
                "DrillHook",
                "get_conn"
            ],
            "54": [
                "DrillHook",
                "get_conn"
            ],
            "55": [
                "DrillHook",
                "get_conn"
            ],
            "80": [
                "DrillHook",
                "set_autocommit"
            ],
            "83": [
                "DrillHook",
                "insert_rows"
            ]
        },
        "addLocation": []
    }
}