{
    "starlette/formparsers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import typing"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from dataclasses import dataclass, field"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from enum import Enum"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from tempfile import SpooledTemporaryFile"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from urllib.parse import unquote_plus"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     END = 5"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class MultiPartMessage(Enum):"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PART_BEGIN = 1"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PART_DATA = 2"
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PART_END = 3"
            },
            "12": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    HEADER_FIELD = 4"
            },
            "13": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    HEADER_VALUE = 5"
            },
            "14": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    HEADER_END = 6"
            },
            "15": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    HEADERS_FINISHED = 7"
            },
            "16": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    END = 8"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+@dataclass"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+class MultipartPart:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    content_disposition: typing.Optional[bytes] = None"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    field_name: str = \"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    data: bytes = b\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    file: typing.Optional[UploadFile] = None"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    item_headers: typing.List[typing.Tuple[bytes, bytes]] = field(default_factory=list)"
            },
            "24": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " def _user_safe_decode(src: bytes, codec: str) -> str:"
            },
            "27": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     max_file_size = 1024 * 1024"
            },
            "28": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def __init__("
            },
            "30": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        self,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        headers: Headers,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        stream: typing.AsyncGenerator[bytes, None],"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        *,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        max_files: typing.Union[int, float] = 1000,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        max_fields: typing.Union[int, float] = 1000,"
            },
            "37": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     ) -> None:"
            },
            "38": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         assert ("
            },
            "39": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             multipart is not None"
            },
            "40": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         ), \"The `python-multipart` library must be installed to use form parsing.\""
            },
            "41": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         self.headers = headers"
            },
            "42": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         self.stream = stream"
            },
            "43": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages: typing.List[typing.Tuple[MultiPartMessage, bytes]] = []"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        self.max_files = max_files"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        self.max_fields = max_fields"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        self.items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        self._current_files = 0"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        self._current_fields = 0"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        self._current_partial_header_name: bytes = b\"\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        self._current_partial_header_value: bytes = b\"\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        self._current_part = MultipartPart()"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        self._charset = \"\""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        self._file_parts_to_write: typing.List[typing.Tuple[MultipartPart, bytes]] = []"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        self._file_parts_to_finish: typing.List[MultipartPart] = []"
            },
            "55": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     def on_part_begin(self) -> None:"
            },
            "57": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.PART_BEGIN, b\"\")"
            },
            "58": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        self._current_part = MultipartPart()"
            },
            "60": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     def on_part_data(self, data: bytes, start: int, end: int) -> None:"
            },
            "62": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.PART_DATA, data[start:end])"
            },
            "63": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        message_bytes = data[start:end]"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        if self._current_part.file is None:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            self._current_part.data += message_bytes"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        else:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            self._file_parts_to_write.append((self._current_part, message_bytes))"
            },
            "69": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     def on_part_end(self) -> None:"
            },
            "71": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.PART_END, b\"\")"
            },
            "72": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        if self._current_part.file is None:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            self.items.append("
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                ("
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                    self._current_part.field_name,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                    _user_safe_decode(self._current_part.data, self._charset),"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                )"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            )"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        else:"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            self._file_parts_to_finish.append(self._current_part)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            # The file can be added to the items right now even though it's not"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            # finished yet, because it will be finished in the `parse()` method, before"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            # self.items is used in the return value."
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            self.items.append((self._current_part.field_name, self._current_part.file))"
            },
            "86": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     def on_header_field(self, data: bytes, start: int, end: int) -> None:"
            },
            "88": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.HEADER_FIELD, data[start:end])"
            },
            "89": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        self._current_partial_header_name += data[start:end]"
            },
            "91": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     def on_header_value(self, data: bytes, start: int, end: int) -> None:"
            },
            "93": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.HEADER_VALUE, data[start:end])"
            },
            "94": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self._current_partial_header_value += data[start:end]"
            },
            "96": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "     def on_header_end(self) -> None:"
            },
            "98": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.HEADER_END, b\"\")"
            },
            "99": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        field = self._current_partial_header_name.lower()"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        if field == b\"content-disposition\":"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            self._current_part.content_disposition = self._current_partial_header_value"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        self._current_part.item_headers.append("
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            (field, self._current_partial_header_value)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        )"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        self._current_partial_header_name = b\"\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        self._current_partial_header_value = b\"\""
            },
            "108": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "109": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     def on_headers_finished(self) -> None:"
            },
            "110": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.HEADERS_FINISHED, b\"\")"
            },
            "111": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        disposition, options = parse_options_header("
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            self._current_part.content_disposition"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        )"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        try:"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            self._current_part.field_name = _user_safe_decode("
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                options[b\"name\"], self._charset"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            )"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        except KeyError:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            raise MultiPartException("
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                'The Content-Disposition header field \"name\" must be ' \"provided.\""
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            )"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        if b\"filename\" in options:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            self._current_files += 1"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            if self._current_files > self.max_files:"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+                raise MultiPartException("
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                    f\"Too many files. Maximum number of files is {self.max_files}.\""
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                )"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            filename = _user_safe_decode(options[b\"filename\"], self._charset)"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            tempfile = SpooledTemporaryFile(max_size=self.max_file_size)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            self._current_part.file = UploadFile("
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                file=tempfile,  # type: ignore[arg-type]"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                size=0,"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                filename=filename,"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                headers=Headers(raw=self._current_part.item_headers),"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            )"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        else:"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            self._current_fields += 1"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            if self._current_fields > self.max_fields:"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                raise MultiPartException("
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\""
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+                )"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            self._current_part.file = None"
            },
            "144": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "145": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "     def on_end(self) -> None:"
            },
            "146": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        message = (MultiPartMessage.END, b\"\")"
            },
            "147": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.messages.append(message)"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        pass"
            },
            "149": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "150": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "     async def parse(self) -> FormData:"
            },
            "151": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         # Parse the Content-Type header to get the multipart boundary."
            },
            "152": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         _, params = parse_options_header(self.headers[\"Content-Type\"])"
            },
            "153": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "         charset = params.get(b\"charset\", \"utf-8\")"
            },
            "154": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         if type(charset) == bytes:"
            },
            "155": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             charset = charset.decode(\"latin-1\")"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        self._charset = charset"
            },
            "157": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         try:"
            },
            "158": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             boundary = params[b\"boundary\"]"
            },
            "159": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         except KeyError:"
            },
            "160": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            },
            "161": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         # Create the parser."
            },
            "162": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         parser = multipart.MultipartParser(boundary, callbacks)"
            },
            "163": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        header_field = b\"\""
            },
            "164": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        header_value = b\"\""
            },
            "165": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        content_disposition = None"
            },
            "166": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        field_name = \"\""
            },
            "167": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = b\"\""
            },
            "168": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        file: typing.Optional[UploadFile] = None"
            },
            "169": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "170": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []"
            },
            "171": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        item_headers: typing.List[typing.Tuple[bytes, bytes]] = []"
            },
            "172": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "173": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         # Feed the parser with data from the request."
            },
            "174": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         async for chunk in self.stream:"
            },
            "175": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "             parser.write(chunk)"
            },
            "176": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            messages = list(self.messages)"
            },
            "177": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.messages.clear()"
            },
            "178": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for message_type, message_bytes in messages:"
            },
            "179": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if message_type == MultiPartMessage.PART_BEGIN:"
            },
            "180": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    content_disposition = None"
            },
            "181": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    data = b\"\""
            },
            "182": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    item_headers = []"
            },
            "183": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.HEADER_FIELD:"
            },
            "184": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    header_field += message_bytes"
            },
            "185": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.HEADER_VALUE:"
            },
            "186": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    header_value += message_bytes"
            },
            "187": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.HEADER_END:"
            },
            "188": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    field = header_field.lower()"
            },
            "189": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if field == b\"content-disposition\":"
            },
            "190": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        content_disposition = header_value"
            },
            "191": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    item_headers.append((field, header_value))"
            },
            "192": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    header_field = b\"\""
            },
            "193": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    header_value = b\"\""
            },
            "194": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.HEADERS_FINISHED:"
            },
            "195": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    disposition, options = parse_options_header(content_disposition)"
            },
            "196": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    try:"
            },
            "197": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        field_name = _user_safe_decode(options[b\"name\"], charset)"
            },
            "198": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    except KeyError:"
            },
            "199": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        raise MultiPartException("
            },
            "200": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            'The Content-Disposition header field \"name\" must be '"
            },
            "201": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            \"provided.\""
            },
            "202": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        )"
            },
            "203": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if b\"filename\" in options:"
            },
            "204": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        filename = _user_safe_decode(options[b\"filename\"], charset)"
            },
            "205": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        tempfile = SpooledTemporaryFile(max_size=self.max_file_size)"
            },
            "206": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        file = UploadFile("
            },
            "207": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            file=tempfile,  # type: ignore[arg-type]"
            },
            "208": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            size=0,"
            },
            "209": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            filename=filename,"
            },
            "210": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            headers=Headers(raw=item_headers),"
            },
            "211": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        )"
            },
            "212": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "213": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        file = None"
            },
            "214": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.PART_DATA:"
            },
            "215": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if file is None:"
            },
            "216": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        data += message_bytes"
            },
            "217": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "218": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        await file.write(message_bytes)"
            },
            "219": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif message_type == MultiPartMessage.PART_END:"
            },
            "220": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if file is None:"
            },
            "221": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        items.append((field_name, _user_safe_decode(data, charset)))"
            },
            "222": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "223": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        await file.seek(0)"
            },
            "224": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        items.append((field_name, file))"
            },
            "225": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            # Write file data, it needs to use await with the UploadFile methods that"
            },
            "226": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            # call the corresponding file methods *in a threadpool*, otherwise, if"
            },
            "227": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            # they were called directly in the callback methods above (regular,"
            },
            "228": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+            # non-async functions), that would block the event loop in the main thread."
            },
            "229": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+            for part, data in self._file_parts_to_write:"
            },
            "230": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+                assert part.file  # for type checkers"
            },
            "231": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+                await part.file.write(data)"
            },
            "232": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+            for part in self._file_parts_to_finish:"
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+                assert part.file  # for type checkers"
            },
            "234": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+                await part.file.seek(0)"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+            self._file_parts_to_write.clear()"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+            self._file_parts_to_finish.clear()"
            },
            "237": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " "
            },
            "238": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         parser.finalize()"
            },
            "239": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return FormData(items)"
            },
            "240": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        return FormData(self.items)"
            }
        },
        "frontPatchFile": [
            "import typing",
            "from enum import Enum",
            "from tempfile import SpooledTemporaryFile",
            "from urllib.parse import unquote_plus",
            "",
            "from starlette.datastructures import FormData, Headers, UploadFile",
            "",
            "try:",
            "    import multipart",
            "    from multipart.multipart import parse_options_header",
            "except ImportError:  # pragma: nocover",
            "    parse_options_header = None",
            "    multipart = None",
            "",
            "",
            "class FormMessage(Enum):",
            "    FIELD_START = 1",
            "    FIELD_NAME = 2",
            "    FIELD_DATA = 3",
            "    FIELD_END = 4",
            "    END = 5",
            "",
            "",
            "class MultiPartMessage(Enum):",
            "    PART_BEGIN = 1",
            "    PART_DATA = 2",
            "    PART_END = 3",
            "    HEADER_FIELD = 4",
            "    HEADER_VALUE = 5",
            "    HEADER_END = 6",
            "    HEADERS_FINISHED = 7",
            "    END = 8",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class MultiPartException(Exception):",
            "    def __init__(self, message: str) -> None:",
            "        self.message = message",
            "",
            "",
            "class FormParser:",
            "    def __init__(",
            "        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]",
            "    ) -> None:",
            "        assert (",
            "            multipart is not None",
            "        ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.messages: typing.List[typing.Tuple[FormMessage, bytes]] = []",
            "",
            "    def on_field_start(self) -> None:",
            "        message = (FormMessage.FIELD_START, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_field_name(self, data: bytes, start: int, end: int) -> None:",
            "        message = (FormMessage.FIELD_NAME, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_field_data(self, data: bytes, start: int, end: int) -> None:",
            "        message = (FormMessage.FIELD_DATA, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_field_end(self) -> None:",
            "        message = (FormMessage.FIELD_END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_end(self) -> None:",
            "        message = (FormMessage.END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    async def parse(self) -> FormData:",
            "        # Callbacks dictionary.",
            "        callbacks = {",
            "            \"on_field_start\": self.on_field_start,",
            "            \"on_field_name\": self.on_field_name,",
            "            \"on_field_data\": self.on_field_data,",
            "            \"on_field_end\": self.on_field_end,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.QuerystringParser(callbacks)",
            "        field_name = b\"\"",
            "        field_value = b\"\"",
            "",
            "        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []",
            "",
            "        # Feed the parser with data from the request.",
            "        async for chunk in self.stream:",
            "            if chunk:",
            "                parser.write(chunk)",
            "            else:",
            "                parser.finalize()",
            "            messages = list(self.messages)",
            "            self.messages.clear()",
            "            for message_type, message_bytes in messages:",
            "                if message_type == FormMessage.FIELD_START:",
            "                    field_name = b\"\"",
            "                    field_value = b\"\"",
            "                elif message_type == FormMessage.FIELD_NAME:",
            "                    field_name += message_bytes",
            "                elif message_type == FormMessage.FIELD_DATA:",
            "                    field_value += message_bytes",
            "                elif message_type == FormMessage.FIELD_END:",
            "                    name = unquote_plus(field_name.decode(\"latin-1\"))",
            "                    value = unquote_plus(field_value.decode(\"latin-1\"))",
            "                    items.append((name, value))",
            "",
            "        return FormData(items)",
            "",
            "",
            "class MultiPartParser:",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]",
            "    ) -> None:",
            "        assert (",
            "            multipart is not None",
            "        ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.messages: typing.List[typing.Tuple[MultiPartMessage, bytes]] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        message = (MultiPartMessage.PART_BEGIN, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message = (MultiPartMessage.PART_DATA, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_part_end(self) -> None:",
            "        message = (MultiPartMessage.PART_END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        message = (MultiPartMessage.HEADER_FIELD, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        message = (MultiPartMessage.HEADER_VALUE, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_header_end(self) -> None:",
            "        message = (MultiPartMessage.HEADER_END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_headers_finished(self) -> None:",
            "        message = (MultiPartMessage.HEADERS_FINISHED, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_end(self) -> None:",
            "        message = (MultiPartMessage.END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if type(charset) == bytes:",
            "            charset = charset.decode(\"latin-1\")",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError:",
            "            raise MultiPartException(\"Missing boundary in multipart.\")",
            "",
            "        # Callbacks dictionary.",
            "        callbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        header_field = b\"\"",
            "        header_value = b\"\"",
            "        content_disposition = None",
            "        field_name = \"\"",
            "        data = b\"\"",
            "        file: typing.Optional[UploadFile] = None",
            "",
            "        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []",
            "        item_headers: typing.List[typing.Tuple[bytes, bytes]] = []",
            "",
            "        # Feed the parser with data from the request.",
            "        async for chunk in self.stream:",
            "            parser.write(chunk)",
            "            messages = list(self.messages)",
            "            self.messages.clear()",
            "            for message_type, message_bytes in messages:",
            "                if message_type == MultiPartMessage.PART_BEGIN:",
            "                    content_disposition = None",
            "                    data = b\"\"",
            "                    item_headers = []",
            "                elif message_type == MultiPartMessage.HEADER_FIELD:",
            "                    header_field += message_bytes",
            "                elif message_type == MultiPartMessage.HEADER_VALUE:",
            "                    header_value += message_bytes",
            "                elif message_type == MultiPartMessage.HEADER_END:",
            "                    field = header_field.lower()",
            "                    if field == b\"content-disposition\":",
            "                        content_disposition = header_value",
            "                    item_headers.append((field, header_value))",
            "                    header_field = b\"\"",
            "                    header_value = b\"\"",
            "                elif message_type == MultiPartMessage.HEADERS_FINISHED:",
            "                    disposition, options = parse_options_header(content_disposition)",
            "                    try:",
            "                        field_name = _user_safe_decode(options[b\"name\"], charset)",
            "                    except KeyError:",
            "                        raise MultiPartException(",
            "                            'The Content-Disposition header field \"name\" must be '",
            "                            \"provided.\"",
            "                        )",
            "                    if b\"filename\" in options:",
            "                        filename = _user_safe_decode(options[b\"filename\"], charset)",
            "                        tempfile = SpooledTemporaryFile(max_size=self.max_file_size)",
            "                        file = UploadFile(",
            "                            file=tempfile,  # type: ignore[arg-type]",
            "                            size=0,",
            "                            filename=filename,",
            "                            headers=Headers(raw=item_headers),",
            "                        )",
            "                    else:",
            "                        file = None",
            "                elif message_type == MultiPartMessage.PART_DATA:",
            "                    if file is None:",
            "                        data += message_bytes",
            "                    else:",
            "                        await file.write(message_bytes)",
            "                elif message_type == MultiPartMessage.PART_END:",
            "                    if file is None:",
            "                        items.append((field_name, _user_safe_decode(data, charset)))",
            "                    else:",
            "                        await file.seek(0)",
            "                        items.append((field_name, file))",
            "",
            "        parser.finalize()",
            "        return FormData(items)"
        ],
        "afterPatchFile": [
            "import typing",
            "from dataclasses import dataclass, field",
            "from enum import Enum",
            "from tempfile import SpooledTemporaryFile",
            "from urllib.parse import unquote_plus",
            "",
            "from starlette.datastructures import FormData, Headers, UploadFile",
            "",
            "try:",
            "    import multipart",
            "    from multipart.multipart import parse_options_header",
            "except ImportError:  # pragma: nocover",
            "    parse_options_header = None",
            "    multipart = None",
            "",
            "",
            "class FormMessage(Enum):",
            "    FIELD_START = 1",
            "    FIELD_NAME = 2",
            "    FIELD_DATA = 3",
            "    FIELD_END = 4",
            "    END = 5",
            "",
            "",
            "@dataclass",
            "class MultipartPart:",
            "    content_disposition: typing.Optional[bytes] = None",
            "    field_name: str = \"\"",
            "    data: bytes = b\"\"",
            "    file: typing.Optional[UploadFile] = None",
            "    item_headers: typing.List[typing.Tuple[bytes, bytes]] = field(default_factory=list)",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class MultiPartException(Exception):",
            "    def __init__(self, message: str) -> None:",
            "        self.message = message",
            "",
            "",
            "class FormParser:",
            "    def __init__(",
            "        self, headers: Headers, stream: typing.AsyncGenerator[bytes, None]",
            "    ) -> None:",
            "        assert (",
            "            multipart is not None",
            "        ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.messages: typing.List[typing.Tuple[FormMessage, bytes]] = []",
            "",
            "    def on_field_start(self) -> None:",
            "        message = (FormMessage.FIELD_START, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_field_name(self, data: bytes, start: int, end: int) -> None:",
            "        message = (FormMessage.FIELD_NAME, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_field_data(self, data: bytes, start: int, end: int) -> None:",
            "        message = (FormMessage.FIELD_DATA, data[start:end])",
            "        self.messages.append(message)",
            "",
            "    def on_field_end(self) -> None:",
            "        message = (FormMessage.FIELD_END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    def on_end(self) -> None:",
            "        message = (FormMessage.END, b\"\")",
            "        self.messages.append(message)",
            "",
            "    async def parse(self) -> FormData:",
            "        # Callbacks dictionary.",
            "        callbacks = {",
            "            \"on_field_start\": self.on_field_start,",
            "            \"on_field_name\": self.on_field_name,",
            "            \"on_field_data\": self.on_field_data,",
            "            \"on_field_end\": self.on_field_end,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.QuerystringParser(callbacks)",
            "        field_name = b\"\"",
            "        field_value = b\"\"",
            "",
            "        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []",
            "",
            "        # Feed the parser with data from the request.",
            "        async for chunk in self.stream:",
            "            if chunk:",
            "                parser.write(chunk)",
            "            else:",
            "                parser.finalize()",
            "            messages = list(self.messages)",
            "            self.messages.clear()",
            "            for message_type, message_bytes in messages:",
            "                if message_type == FormMessage.FIELD_START:",
            "                    field_name = b\"\"",
            "                    field_value = b\"\"",
            "                elif message_type == FormMessage.FIELD_NAME:",
            "                    field_name += message_bytes",
            "                elif message_type == FormMessage.FIELD_DATA:",
            "                    field_value += message_bytes",
            "                elif message_type == FormMessage.FIELD_END:",
            "                    name = unquote_plus(field_name.decode(\"latin-1\"))",
            "                    value = unquote_plus(field_value.decode(\"latin-1\"))",
            "                    items.append((name, value))",
            "",
            "        return FormData(items)",
            "",
            "",
            "class MultiPartParser:",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: typing.AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: typing.Union[int, float] = 1000,",
            "        max_fields: typing.Union[int, float] = 1000,",
            "    ) -> None:",
            "        assert (",
            "            multipart is not None",
            "        ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: typing.List[typing.Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: typing.List[MultipartPart] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, self._charset),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        disposition, options = parse_options_header(",
            "            self._current_part.content_disposition",
            "        )",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], self._charset",
            "            )",
            "        except KeyError:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            )",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], self._charset)",
            "            tempfile = SpooledTemporaryFile(max_size=self.max_file_size)",
            "            self._current_part.file = UploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if type(charset) == bytes:",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError:",
            "            raise MultiPartException(\"Missing boundary in multipart.\")",
            "",
            "        # Callbacks dictionary.",
            "        callbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        # Feed the parser with data from the request.",
            "        async for chunk in self.stream:",
            "            parser.write(chunk)",
            "            # Write file data, it needs to use await with the UploadFile methods that",
            "            # call the corresponding file methods *in a threadpool*, otherwise, if",
            "            # they were called directly in the callback methods above (regular,",
            "            # non-async functions), that would block the event loop in the main thread.",
            "            for part, data in self._file_parts_to_write:",
            "                assert part.file  # for type checkers",
            "                await part.file.write(data)",
            "            for part in self._file_parts_to_finish:",
            "                assert part.file  # for type checkers",
            "                await part.file.seek(0)",
            "            self._file_parts_to_write.clear()",
            "            self._file_parts_to_finish.clear()",
            "",
            "        parser.finalize()",
            "        return FormData(self.items)"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "24": [
                "MultiPartMessage"
            ],
            "25": [
                "MultiPartMessage"
            ],
            "26": [
                "MultiPartMessage"
            ],
            "27": [
                "MultiPartMessage"
            ],
            "28": [
                "MultiPartMessage"
            ],
            "29": [
                "MultiPartMessage"
            ],
            "30": [
                "MultiPartMessage"
            ],
            "31": [
                "MultiPartMessage"
            ],
            "32": [
                "MultiPartMessage"
            ],
            "123": [
                "MultiPartParser",
                "__init__"
            ],
            "130": [
                "MultiPartParser",
                "__init__"
            ],
            "133": [
                "MultiPartParser",
                "on_part_begin"
            ],
            "134": [
                "MultiPartParser",
                "on_part_begin"
            ],
            "137": [
                "MultiPartParser",
                "on_part_data"
            ],
            "138": [
                "MultiPartParser",
                "on_part_data"
            ],
            "141": [
                "MultiPartParser",
                "on_part_end"
            ],
            "142": [
                "MultiPartParser",
                "on_part_end"
            ],
            "145": [
                "MultiPartParser",
                "on_header_field"
            ],
            "146": [
                "MultiPartParser",
                "on_header_field"
            ],
            "149": [
                "MultiPartParser",
                "on_header_value"
            ],
            "150": [
                "MultiPartParser",
                "on_header_value"
            ],
            "153": [
                "MultiPartParser",
                "on_header_end"
            ],
            "154": [
                "MultiPartParser",
                "on_header_end"
            ],
            "157": [
                "MultiPartParser",
                "on_headers_finished"
            ],
            "158": [
                "MultiPartParser",
                "on_headers_finished"
            ],
            "161": [
                "MultiPartParser",
                "on_end"
            ],
            "162": [
                "MultiPartParser",
                "on_end"
            ],
            "189": [
                "MultiPartParser"
            ],
            "190": [
                "MultiPartParser"
            ],
            "191": [
                "MultiPartParser"
            ],
            "192": [
                "MultiPartParser"
            ],
            "193": [
                "MultiPartParser"
            ],
            "194": [
                "MultiPartParser"
            ],
            "195": [
                "MultiPartParser"
            ],
            "196": [
                "MultiPartParser"
            ],
            "197": [
                "MultiPartParser"
            ],
            "198": [
                "MultiPartParser"
            ],
            "202": [
                "MultiPartParser"
            ],
            "203": [
                "MultiPartParser"
            ],
            "204": [
                "MultiPartParser"
            ],
            "205": [
                "MultiPartParser"
            ],
            "206": [
                "MultiPartParser"
            ],
            "207": [
                "MultiPartParser"
            ],
            "208": [
                "MultiPartParser"
            ],
            "209": [
                "MultiPartParser"
            ],
            "210": [
                "MultiPartParser"
            ],
            "211": [
                "MultiPartParser"
            ],
            "212": [
                "MultiPartParser"
            ],
            "213": [
                "MultiPartParser"
            ],
            "214": [
                "MultiPartParser"
            ],
            "215": [
                "MultiPartParser"
            ],
            "216": [
                "MultiPartParser"
            ],
            "217": [
                "MultiPartParser"
            ],
            "218": [
                "MultiPartParser"
            ],
            "219": [
                "MultiPartParser"
            ],
            "220": [
                "MultiPartParser"
            ],
            "221": [
                "MultiPartParser"
            ],
            "222": [
                "MultiPartParser"
            ],
            "223": [
                "MultiPartParser"
            ],
            "224": [
                "MultiPartParser"
            ],
            "225": [
                "MultiPartParser"
            ],
            "226": [
                "MultiPartParser"
            ],
            "227": [
                "MultiPartParser"
            ],
            "228": [
                "MultiPartParser"
            ],
            "229": [
                "MultiPartParser"
            ],
            "230": [
                "MultiPartParser"
            ],
            "231": [
                "MultiPartParser"
            ],
            "232": [
                "MultiPartParser"
            ],
            "233": [
                "MultiPartParser"
            ],
            "234": [
                "MultiPartParser"
            ],
            "235": [
                "MultiPartParser"
            ],
            "236": [
                "MultiPartParser"
            ],
            "237": [
                "MultiPartParser"
            ],
            "238": [
                "MultiPartParser"
            ],
            "239": [
                "MultiPartParser"
            ],
            "240": [
                "MultiPartParser"
            ],
            "241": [
                "MultiPartParser"
            ],
            "242": [
                "MultiPartParser"
            ],
            "243": [
                "MultiPartParser"
            ],
            "244": [
                "MultiPartParser"
            ],
            "245": [
                "MultiPartParser"
            ],
            "246": [
                "MultiPartParser"
            ],
            "247": [
                "MultiPartParser"
            ],
            "248": [
                "MultiPartParser"
            ],
            "249": [
                "MultiPartParser"
            ],
            "250": [
                "MultiPartParser"
            ],
            "253": [
                "MultiPartParser"
            ]
        },
        "addLocation": []
    },
    "starlette/requests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             self._json = json.loads(body)"
            },
            "1": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         return self._json"
            },
            "2": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    async def _get_form(self) -> FormData:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    async def _get_form("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        self,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        *,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        max_files: typing.Union[int, float] = 1000,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        max_fields: typing.Union[int, float] = 1000,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    ) -> FormData:"
            },
            "10": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         if self._form is None:"
            },
            "11": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             assert ("
            },
            "12": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "                 parse_options_header is not None"
            },
            "13": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "             content_type, _ = parse_options_header(content_type_header)"
            },
            "14": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             if content_type == b\"multipart/form-data\":"
            },
            "15": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "                 try:"
            },
            "16": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    multipart_parser = MultiPartParser(self.headers, self.stream())"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+                    multipart_parser = MultiPartParser("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+                        self.headers,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                        self.stream(),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                        max_files=max_files,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                        max_fields=max_fields,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+                    )"
            },
            "23": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "                     self._form = await multipart_parser.parse()"
            },
            "24": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "                 except MultiPartException as exc:"
            },
            "25": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "                     if \"app\" in self.scope:"
            },
            "26": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "                 self._form = FormData()"
            },
            "27": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         return self._form"
            },
            "28": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def form(self) -> AwaitableOrContextManager[FormData]:"
            },
            "30": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return AwaitableOrContextManagerWrapper(self._get_form())"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+    def form("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+        self,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        *,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+        max_files: typing.Union[int, float] = 1000,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        max_fields: typing.Union[int, float] = 1000,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    ) -> AwaitableOrContextManager[FormData]:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        return AwaitableOrContextManagerWrapper("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            self._get_form(max_files=max_files, max_fields=max_fields)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        )"
            },
            "40": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     async def close(self) -> None:"
            },
            "42": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         if self._form is not None:"
            }
        },
        "frontPatchFile": [
            "import json",
            "import typing",
            "from http import cookies as http_cookies",
            "",
            "import anyio",
            "",
            "from starlette._utils import AwaitableOrContextManager, AwaitableOrContextManagerWrapper",
            "from starlette.datastructures import URL, Address, FormData, Headers, QueryParams, State",
            "from starlette.exceptions import HTTPException",
            "from starlette.formparsers import FormParser, MultiPartException, MultiPartParser",
            "from starlette.types import Message, Receive, Scope, Send",
            "",
            "try:",
            "    from multipart.multipart import parse_options_header",
            "except ImportError:  # pragma: nocover",
            "    parse_options_header = None",
            "",
            "",
            "if typing.TYPE_CHECKING:",
            "    from starlette.routing import Router",
            "",
            "",
            "SERVER_PUSH_HEADERS_TO_COPY = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "def cookie_parser(cookie_string: str) -> typing.Dict[str, str]:",
            "    \"\"\"",
            "    This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.",
            "",
            "    It attempts to mimic browser cookie parsing behavior: browsers and web servers",
            "    frequently disregard the spec (RFC 6265) when setting and reading cookies,",
            "    so we attempt to suit the common scenarios here.",
            "",
            "    This function has been adapted from Django 3.1.0.",
            "    Note: we are explicitly _NOT_ using `SimpleCookie.load` because it is based",
            "    on an outdated spec and will fail on lots of input we want to support",
            "    \"\"\"",
            "    cookie_dict: typing.Dict[str, str] = {}",
            "    for chunk in cookie_string.split(\";\"):",
            "        if \"=\" in chunk:",
            "            key, val = chunk.split(\"=\", 1)",
            "        else:",
            "            # Assume an empty name per",
            "            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091",
            "            key, val = \"\", chunk",
            "        key, val = key.strip(), val.strip()",
            "        if key or val:",
            "            # unquote using Python's algorithm.",
            "            cookie_dict[key] = http_cookies._unquote(val)",
            "    return cookie_dict",
            "",
            "",
            "class ClientDisconnect(Exception):",
            "    pass",
            "",
            "",
            "class HTTPConnection(typing.Mapping[str, typing.Any]):",
            "    \"\"\"",
            "    A base class for incoming HTTP connections, that is used to provide",
            "    any functionality that is common to both `Request` and `WebSocket`.",
            "    \"\"\"",
            "",
            "    def __init__(self, scope: Scope, receive: typing.Optional[Receive] = None) -> None:",
            "        assert scope[\"type\"] in (\"http\", \"websocket\")",
            "        self.scope = scope",
            "",
            "    def __getitem__(self, key: str) -> typing.Any:",
            "        return self.scope[key]",
            "",
            "    def __iter__(self) -> typing.Iterator[str]:",
            "        return iter(self.scope)",
            "",
            "    def __len__(self) -> int:",
            "        return len(self.scope)",
            "",
            "    # Don't use the `abc.Mapping.__eq__` implementation.",
            "    # Connection instances should never be considered equal",
            "    # unless `self is other`.",
            "    __eq__ = object.__eq__",
            "    __hash__ = object.__hash__",
            "",
            "    @property",
            "    def app(self) -> typing.Any:",
            "        return self.scope[\"app\"]",
            "",
            "    @property",
            "    def url(self) -> URL:",
            "        if not hasattr(self, \"_url\"):",
            "            self._url = URL(scope=self.scope)",
            "        return self._url",
            "",
            "    @property",
            "    def base_url(self) -> URL:",
            "        if not hasattr(self, \"_base_url\"):",
            "            base_url_scope = dict(self.scope)",
            "            base_url_scope[\"path\"] = \"/\"",
            "            base_url_scope[\"query_string\"] = b\"\"",
            "            base_url_scope[\"root_path\"] = base_url_scope.get(",
            "                \"app_root_path\", base_url_scope.get(\"root_path\", \"\")",
            "            )",
            "            self._base_url = URL(scope=base_url_scope)",
            "        return self._base_url",
            "",
            "    @property",
            "    def headers(self) -> Headers:",
            "        if not hasattr(self, \"_headers\"):",
            "            self._headers = Headers(scope=self.scope)",
            "        return self._headers",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        if not hasattr(self, \"_query_params\"):",
            "            self._query_params = QueryParams(self.scope[\"query_string\"])",
            "        return self._query_params",
            "",
            "    @property",
            "    def path_params(self) -> typing.Dict[str, typing.Any]:",
            "        return self.scope.get(\"path_params\", {})",
            "",
            "    @property",
            "    def cookies(self) -> typing.Dict[str, str]:",
            "        if not hasattr(self, \"_cookies\"):",
            "            cookies: typing.Dict[str, str] = {}",
            "            cookie_header = self.headers.get(\"cookie\")",
            "",
            "            if cookie_header:",
            "                cookies = cookie_parser(cookie_header)",
            "            self._cookies = cookies",
            "        return self._cookies",
            "",
            "    @property",
            "    def client(self) -> typing.Optional[Address]:",
            "        # client is a 2 item tuple of (host, port), None or missing",
            "        host_port = self.scope.get(\"client\")",
            "        if host_port is not None:",
            "            return Address(*host_port)",
            "        return None",
            "",
            "    @property",
            "    def session(self) -> typing.Dict[str, typing.Any]:",
            "        assert (",
            "            \"session\" in self.scope",
            "        ), \"SessionMiddleware must be installed to access request.session\"",
            "        return self.scope[\"session\"]",
            "",
            "    @property",
            "    def auth(self) -> typing.Any:",
            "        assert (",
            "            \"auth\" in self.scope",
            "        ), \"AuthenticationMiddleware must be installed to access request.auth\"",
            "        return self.scope[\"auth\"]",
            "",
            "    @property",
            "    def user(self) -> typing.Any:",
            "        assert (",
            "            \"user\" in self.scope",
            "        ), \"AuthenticationMiddleware must be installed to access request.user\"",
            "        return self.scope[\"user\"]",
            "",
            "    @property",
            "    def state(self) -> State:",
            "        if not hasattr(self, \"_state\"):",
            "            # Ensure 'state' has an empty dict if it's not already populated.",
            "            self.scope.setdefault(\"state\", {})",
            "            # Create a state instance with a reference to the dict in which it should",
            "            # store info",
            "            self._state = State(self.scope[\"state\"])",
            "        return self._state",
            "",
            "    def url_for(self, name: str, **path_params: typing.Any) -> str:",
            "        router: Router = self.scope[\"router\"]",
            "        url_path = router.url_path_for(name, **path_params)",
            "        return url_path.make_absolute_url(base_url=self.base_url)",
            "",
            "",
            "async def empty_receive() -> typing.NoReturn:",
            "    raise RuntimeError(\"Receive channel has not been made available\")",
            "",
            "",
            "async def empty_send(message: Message) -> typing.NoReturn:",
            "    raise RuntimeError(\"Send channel has not been made available\")",
            "",
            "",
            "class Request(HTTPConnection):",
            "    _form: typing.Optional[FormData]",
            "",
            "    def __init__(",
            "        self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send",
            "    ):",
            "        super().__init__(scope)",
            "        assert scope[\"type\"] == \"http\"",
            "        self._receive = receive",
            "        self._send = send",
            "        self._stream_consumed = False",
            "        self._is_disconnected = False",
            "        self._form = None",
            "",
            "    @property",
            "    def method(self) -> str:",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def receive(self) -> Receive:",
            "        return self._receive",
            "",
            "    async def stream(self) -> typing.AsyncGenerator[bytes, None]:",
            "        if hasattr(self, \"_body\"):",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "        if self._stream_consumed:",
            "            raise RuntimeError(\"Stream consumed\")",
            "        self._stream_consumed = True",
            "        while True:",
            "            message = await self._receive()",
            "            if message[\"type\"] == \"http.request\":",
            "                body = message.get(\"body\", b\"\")",
            "                if body:",
            "                    yield body",
            "                if not message.get(\"more_body\", False):",
            "                    break",
            "            elif message[\"type\"] == \"http.disconnect\":",
            "                self._is_disconnected = True",
            "                raise ClientDisconnect()",
            "        yield b\"\"",
            "",
            "    async def body(self) -> bytes:",
            "        if not hasattr(self, \"_body\"):",
            "            chunks: \"typing.List[bytes]\" = []",
            "            async for chunk in self.stream():",
            "                chunks.append(chunk)",
            "            self._body = b\"\".join(chunks)",
            "        return self._body",
            "",
            "    async def json(self) -> typing.Any:",
            "        if not hasattr(self, \"_json\"):",
            "            body = await self.body()",
            "            self._json = json.loads(body)",
            "        return self._json",
            "",
            "    async def _get_form(self) -> FormData:",
            "        if self._form is None:",
            "            assert (",
            "                parse_options_header is not None",
            "            ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "            content_type_header = self.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header)",
            "            if content_type == b\"multipart/form-data\":",
            "                try:",
            "                    multipart_parser = MultiPartParser(self.headers, self.stream())",
            "                    self._form = await multipart_parser.parse()",
            "                except MultiPartException as exc:",
            "                    if \"app\" in self.scope:",
            "                        raise HTTPException(status_code=400, detail=exc.message)",
            "                    raise exc",
            "            elif content_type == b\"application/x-www-form-urlencoded\":",
            "                form_parser = FormParser(self.headers, self.stream())",
            "                self._form = await form_parser.parse()",
            "            else:",
            "                self._form = FormData()",
            "        return self._form",
            "",
            "    def form(self) -> AwaitableOrContextManager[FormData]:",
            "        return AwaitableOrContextManagerWrapper(self._get_form())",
            "",
            "    async def close(self) -> None:",
            "        if self._form is not None:",
            "            await self._form.close()",
            "",
            "    async def is_disconnected(self) -> bool:",
            "        if not self._is_disconnected:",
            "            message: Message = {}",
            "",
            "            # If message isn't immediately available, move on",
            "            with anyio.CancelScope() as cs:",
            "                cs.cancel()",
            "                message = await self._receive()",
            "",
            "            if message.get(\"type\") == \"http.disconnect\":",
            "                self._is_disconnected = True",
            "",
            "        return self._is_disconnected",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        if \"http.response.push\" in self.scope.get(\"extensions\", {}):",
            "            raw_headers: \"typing.List[typing.Tuple[bytes, bytes]]\" = []",
            "            for name in SERVER_PUSH_HEADERS_TO_COPY:",
            "                for value in self.headers.getlist(name):",
            "                    raw_headers.append(",
            "                        (name.encode(\"latin-1\"), value.encode(\"latin-1\"))",
            "                    )",
            "            await self._send(",
            "                {\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers}",
            "            )"
        ],
        "afterPatchFile": [
            "import json",
            "import typing",
            "from http import cookies as http_cookies",
            "",
            "import anyio",
            "",
            "from starlette._utils import AwaitableOrContextManager, AwaitableOrContextManagerWrapper",
            "from starlette.datastructures import URL, Address, FormData, Headers, QueryParams, State",
            "from starlette.exceptions import HTTPException",
            "from starlette.formparsers import FormParser, MultiPartException, MultiPartParser",
            "from starlette.types import Message, Receive, Scope, Send",
            "",
            "try:",
            "    from multipart.multipart import parse_options_header",
            "except ImportError:  # pragma: nocover",
            "    parse_options_header = None",
            "",
            "",
            "if typing.TYPE_CHECKING:",
            "    from starlette.routing import Router",
            "",
            "",
            "SERVER_PUSH_HEADERS_TO_COPY = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "def cookie_parser(cookie_string: str) -> typing.Dict[str, str]:",
            "    \"\"\"",
            "    This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.",
            "",
            "    It attempts to mimic browser cookie parsing behavior: browsers and web servers",
            "    frequently disregard the spec (RFC 6265) when setting and reading cookies,",
            "    so we attempt to suit the common scenarios here.",
            "",
            "    This function has been adapted from Django 3.1.0.",
            "    Note: we are explicitly _NOT_ using `SimpleCookie.load` because it is based",
            "    on an outdated spec and will fail on lots of input we want to support",
            "    \"\"\"",
            "    cookie_dict: typing.Dict[str, str] = {}",
            "    for chunk in cookie_string.split(\";\"):",
            "        if \"=\" in chunk:",
            "            key, val = chunk.split(\"=\", 1)",
            "        else:",
            "            # Assume an empty name per",
            "            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091",
            "            key, val = \"\", chunk",
            "        key, val = key.strip(), val.strip()",
            "        if key or val:",
            "            # unquote using Python's algorithm.",
            "            cookie_dict[key] = http_cookies._unquote(val)",
            "    return cookie_dict",
            "",
            "",
            "class ClientDisconnect(Exception):",
            "    pass",
            "",
            "",
            "class HTTPConnection(typing.Mapping[str, typing.Any]):",
            "    \"\"\"",
            "    A base class for incoming HTTP connections, that is used to provide",
            "    any functionality that is common to both `Request` and `WebSocket`.",
            "    \"\"\"",
            "",
            "    def __init__(self, scope: Scope, receive: typing.Optional[Receive] = None) -> None:",
            "        assert scope[\"type\"] in (\"http\", \"websocket\")",
            "        self.scope = scope",
            "",
            "    def __getitem__(self, key: str) -> typing.Any:",
            "        return self.scope[key]",
            "",
            "    def __iter__(self) -> typing.Iterator[str]:",
            "        return iter(self.scope)",
            "",
            "    def __len__(self) -> int:",
            "        return len(self.scope)",
            "",
            "    # Don't use the `abc.Mapping.__eq__` implementation.",
            "    # Connection instances should never be considered equal",
            "    # unless `self is other`.",
            "    __eq__ = object.__eq__",
            "    __hash__ = object.__hash__",
            "",
            "    @property",
            "    def app(self) -> typing.Any:",
            "        return self.scope[\"app\"]",
            "",
            "    @property",
            "    def url(self) -> URL:",
            "        if not hasattr(self, \"_url\"):",
            "            self._url = URL(scope=self.scope)",
            "        return self._url",
            "",
            "    @property",
            "    def base_url(self) -> URL:",
            "        if not hasattr(self, \"_base_url\"):",
            "            base_url_scope = dict(self.scope)",
            "            base_url_scope[\"path\"] = \"/\"",
            "            base_url_scope[\"query_string\"] = b\"\"",
            "            base_url_scope[\"root_path\"] = base_url_scope.get(",
            "                \"app_root_path\", base_url_scope.get(\"root_path\", \"\")",
            "            )",
            "            self._base_url = URL(scope=base_url_scope)",
            "        return self._base_url",
            "",
            "    @property",
            "    def headers(self) -> Headers:",
            "        if not hasattr(self, \"_headers\"):",
            "            self._headers = Headers(scope=self.scope)",
            "        return self._headers",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        if not hasattr(self, \"_query_params\"):",
            "            self._query_params = QueryParams(self.scope[\"query_string\"])",
            "        return self._query_params",
            "",
            "    @property",
            "    def path_params(self) -> typing.Dict[str, typing.Any]:",
            "        return self.scope.get(\"path_params\", {})",
            "",
            "    @property",
            "    def cookies(self) -> typing.Dict[str, str]:",
            "        if not hasattr(self, \"_cookies\"):",
            "            cookies: typing.Dict[str, str] = {}",
            "            cookie_header = self.headers.get(\"cookie\")",
            "",
            "            if cookie_header:",
            "                cookies = cookie_parser(cookie_header)",
            "            self._cookies = cookies",
            "        return self._cookies",
            "",
            "    @property",
            "    def client(self) -> typing.Optional[Address]:",
            "        # client is a 2 item tuple of (host, port), None or missing",
            "        host_port = self.scope.get(\"client\")",
            "        if host_port is not None:",
            "            return Address(*host_port)",
            "        return None",
            "",
            "    @property",
            "    def session(self) -> typing.Dict[str, typing.Any]:",
            "        assert (",
            "            \"session\" in self.scope",
            "        ), \"SessionMiddleware must be installed to access request.session\"",
            "        return self.scope[\"session\"]",
            "",
            "    @property",
            "    def auth(self) -> typing.Any:",
            "        assert (",
            "            \"auth\" in self.scope",
            "        ), \"AuthenticationMiddleware must be installed to access request.auth\"",
            "        return self.scope[\"auth\"]",
            "",
            "    @property",
            "    def user(self) -> typing.Any:",
            "        assert (",
            "            \"user\" in self.scope",
            "        ), \"AuthenticationMiddleware must be installed to access request.user\"",
            "        return self.scope[\"user\"]",
            "",
            "    @property",
            "    def state(self) -> State:",
            "        if not hasattr(self, \"_state\"):",
            "            # Ensure 'state' has an empty dict if it's not already populated.",
            "            self.scope.setdefault(\"state\", {})",
            "            # Create a state instance with a reference to the dict in which it should",
            "            # store info",
            "            self._state = State(self.scope[\"state\"])",
            "        return self._state",
            "",
            "    def url_for(self, name: str, **path_params: typing.Any) -> str:",
            "        router: Router = self.scope[\"router\"]",
            "        url_path = router.url_path_for(name, **path_params)",
            "        return url_path.make_absolute_url(base_url=self.base_url)",
            "",
            "",
            "async def empty_receive() -> typing.NoReturn:",
            "    raise RuntimeError(\"Receive channel has not been made available\")",
            "",
            "",
            "async def empty_send(message: Message) -> typing.NoReturn:",
            "    raise RuntimeError(\"Send channel has not been made available\")",
            "",
            "",
            "class Request(HTTPConnection):",
            "    _form: typing.Optional[FormData]",
            "",
            "    def __init__(",
            "        self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send",
            "    ):",
            "        super().__init__(scope)",
            "        assert scope[\"type\"] == \"http\"",
            "        self._receive = receive",
            "        self._send = send",
            "        self._stream_consumed = False",
            "        self._is_disconnected = False",
            "        self._form = None",
            "",
            "    @property",
            "    def method(self) -> str:",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def receive(self) -> Receive:",
            "        return self._receive",
            "",
            "    async def stream(self) -> typing.AsyncGenerator[bytes, None]:",
            "        if hasattr(self, \"_body\"):",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "        if self._stream_consumed:",
            "            raise RuntimeError(\"Stream consumed\")",
            "        self._stream_consumed = True",
            "        while True:",
            "            message = await self._receive()",
            "            if message[\"type\"] == \"http.request\":",
            "                body = message.get(\"body\", b\"\")",
            "                if body:",
            "                    yield body",
            "                if not message.get(\"more_body\", False):",
            "                    break",
            "            elif message[\"type\"] == \"http.disconnect\":",
            "                self._is_disconnected = True",
            "                raise ClientDisconnect()",
            "        yield b\"\"",
            "",
            "    async def body(self) -> bytes:",
            "        if not hasattr(self, \"_body\"):",
            "            chunks: \"typing.List[bytes]\" = []",
            "            async for chunk in self.stream():",
            "                chunks.append(chunk)",
            "            self._body = b\"\".join(chunks)",
            "        return self._body",
            "",
            "    async def json(self) -> typing.Any:",
            "        if not hasattr(self, \"_json\"):",
            "            body = await self.body()",
            "            self._json = json.loads(body)",
            "        return self._json",
            "",
            "    async def _get_form(",
            "        self,",
            "        *,",
            "        max_files: typing.Union[int, float] = 1000,",
            "        max_fields: typing.Union[int, float] = 1000,",
            "    ) -> FormData:",
            "        if self._form is None:",
            "            assert (",
            "                parse_options_header is not None",
            "            ), \"The `python-multipart` library must be installed to use form parsing.\"",
            "            content_type_header = self.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header)",
            "            if content_type == b\"multipart/form-data\":",
            "                try:",
            "                    multipart_parser = MultiPartParser(",
            "                        self.headers,",
            "                        self.stream(),",
            "                        max_files=max_files,",
            "                        max_fields=max_fields,",
            "                    )",
            "                    self._form = await multipart_parser.parse()",
            "                except MultiPartException as exc:",
            "                    if \"app\" in self.scope:",
            "                        raise HTTPException(status_code=400, detail=exc.message)",
            "                    raise exc",
            "            elif content_type == b\"application/x-www-form-urlencoded\":",
            "                form_parser = FormParser(self.headers, self.stream())",
            "                self._form = await form_parser.parse()",
            "            else:",
            "                self._form = FormData()",
            "        return self._form",
            "",
            "    def form(",
            "        self,",
            "        *,",
            "        max_files: typing.Union[int, float] = 1000,",
            "        max_fields: typing.Union[int, float] = 1000,",
            "    ) -> AwaitableOrContextManager[FormData]:",
            "        return AwaitableOrContextManagerWrapper(",
            "            self._get_form(max_files=max_files, max_fields=max_fields)",
            "        )",
            "",
            "    async def close(self) -> None:",
            "        if self._form is not None:",
            "            await self._form.close()",
            "",
            "    async def is_disconnected(self) -> bool:",
            "        if not self._is_disconnected:",
            "            message: Message = {}",
            "",
            "            # If message isn't immediately available, move on",
            "            with anyio.CancelScope() as cs:",
            "                cs.cancel()",
            "                message = await self._receive()",
            "",
            "            if message.get(\"type\") == \"http.disconnect\":",
            "                self._is_disconnected = True",
            "",
            "        return self._is_disconnected",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        if \"http.response.push\" in self.scope.get(\"extensions\", {}):",
            "            raw_headers: \"typing.List[typing.Tuple[bytes, bytes]]\" = []",
            "            for name in SERVER_PUSH_HEADERS_TO_COPY:",
            "                for value in self.headers.getlist(name):",
            "                    raw_headers.append(",
            "                        (name.encode(\"latin-1\"), value.encode(\"latin-1\"))",
            "                    )",
            "            await self._send(",
            "                {\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers}",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "247": [
                "Request"
            ],
            "257": [
                "Request"
            ],
            "270": [
                "Request",
                "form"
            ],
            "271": [
                "Request",
                "form"
            ]
        },
        "addLocation": []
    }
}