{
    "libs/core/langchain_core/output_parsers/xml.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import xml.etree.ElementTree as ET"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from typing import Any, AsyncIterator, Dict, Iterator, List, Optional, Union"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from xml.etree import ElementTree as ET"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from xml.etree.ElementTree import TreeBuilder"
            },
            "5": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from langchain_core.exceptions import OutputParserException"
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from langchain_core.messages import BaseMessage"
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         return XML_FORMAT_INSTRUCTIONS.format(tags=self.tags)"
            },
            "9": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     def parse(self, text: str) -> Dict[str, List[Any]]:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        # Imports are temporarily placed here to avoid issue with caching on CI"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        # likely if you're reading this you can move them to the top of the file"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        from defusedxml import ElementTree as DET  # type: ignore[import]"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         # Try to find XML string within triple backticks"
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         match = re.search(r\"```(xml)?(.*)```\", text, re.DOTALL)"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         if match is not None:"
            },
            "18": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         text = text.strip()"
            },
            "20": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         try:"
            },
            "21": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            root = ET.fromstring(text)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            root = DET.fromstring(text)"
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             return self._root_to_dict(root)"
            },
            "24": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except ET.ParseError as e:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        except (DET.ParseError, DET.EntitiesForbidden) as e:"
            },
            "27": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             msg = f\"Failed to parse XML format from completion {text}. Got: {e}\""
            },
            "28": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             raise OutputParserException(msg, llm_output=text) from e"
            },
            "29": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     def _transform("
            },
            "31": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         self, input: Iterator[Union[str, BaseMessage]]"
            },
            "32": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     ) -> Iterator[AddableDict]:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        # Imports are temporarily placed here to avoid issue with caching on CI"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        # likely if you're reading this you can move them to the top of the file"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        from defusedxml.ElementTree import DefusedXMLParser  # type: ignore[import]"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        parser = ET.XMLPullParser("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            [\"start\", \"end\"], _parser=DefusedXMLParser(target=TreeBuilder())"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        )"
            },
            "40": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         xml_start_re = re.compile(r\"<[a-zA-Z:_]\")"
            },
            "41": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser = ET.XMLPullParser([\"start\", \"end\"])"
            },
            "42": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         xml_started = False"
            },
            "43": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         current_path: List[str] = []"
            },
            "44": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         current_path_has_children = False"
            },
            "45": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "             parser.feed(buffer)"
            },
            "46": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             buffer = \"\""
            },
            "47": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             # yield all events"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             for event, elem in parser.read_events():"
            },
            "50": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "                 if event == \"start\":"
            },
            "51": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "                     # update current path"
            },
            "52": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     async def _atransform("
            },
            "53": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         self, input: AsyncIterator[Union[str, BaseMessage]]"
            },
            "54": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     ) -> AsyncIterator[AddableDict]:"
            },
            "55": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser = ET.XMLPullParser([\"start\", \"end\"])"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        # Imports are temporarily placed here to avoid issue with caching on CI"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        # likely if you're reading this you can move them to the top of the file"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        from defusedxml.ElementTree import DefusedXMLParser  # type: ignore[import]"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        _parser = DefusedXMLParser(target=TreeBuilder())"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        parser = ET.XMLPullParser([\"start\", \"end\"], _parser=_parser)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        xml_start_re = re.compile(r\"<[a-zA-Z:_]\")"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        xml_started = False"
            },
            "64": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         current_path: List[str] = []"
            },
            "65": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         current_path_has_children = False"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        buffer = \"\""
            },
            "67": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         async for chunk in input:"
            },
            "68": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "             if isinstance(chunk, BaseMessage):"
            },
            "69": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                 # extract text"
            },
            "70": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                 chunk_content = chunk.content"
            },
            "71": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                 if not isinstance(chunk_content, str):"
            },
            "72": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                     continue"
            },
            "73": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "                 chunk = chunk_content"
            },
            "74": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # pass chunk to parser"
            },
            "75": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            parser.feed(chunk)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            # add chunk to buffer of unprocessed text"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            buffer += chunk"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            # if xml string hasn't started yet, continue to next chunk"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+            if not xml_started:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+                if match := xml_start_re.search(buffer):"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+                    # if xml string has started, remove all text before it"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                    buffer = buffer[match.start() :]"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                    xml_started = True"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                else:"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                    continue"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            # feed buffer to parser"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            parser.feed(buffer)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            buffer = \"\""
            },
            "89": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             # yield all events"
            },
            "90": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             for event, elem in parser.read_events():"
            },
            "91": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                 if event == \"start\":"
            },
            "92": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                     if not current_path_has_children:"
            },
            "93": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "                         yield nested_element(current_path, elem)"
            },
            "94": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                     # prevent yielding of parent element"
            },
            "95": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    current_path_has_children = True"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+                    if current_path:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                        current_path_has_children = True"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                    else:"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                        xml_started = False"
            },
            "100": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         # close parser"
            },
            "101": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         parser.close()"
            },
            "102": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import re",
            "import xml.etree.ElementTree as ET",
            "from typing import Any, AsyncIterator, Dict, Iterator, List, Optional, Union",
            "",
            "from langchain_core.exceptions import OutputParserException",
            "from langchain_core.messages import BaseMessage",
            "from langchain_core.output_parsers.transform import BaseTransformOutputParser",
            "from langchain_core.runnables.utils import AddableDict",
            "",
            "XML_FORMAT_INSTRUCTIONS = \"\"\"The output should be formatted as a XML file.",
            "1. Output should conform to the tags below. ",
            "2. If tags are not given, make them on your own.",
            "3. Remember to always open and close all the tags.",
            "",
            "As an example, for the tags [\"foo\", \"bar\", \"baz\"]:",
            "1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. ",
            "2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.",
            "3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.",
            "",
            "Here are the output tags:",
            "```",
            "{tags}",
            "```\"\"\"  # noqa: E501",
            "",
            "",
            "class XMLOutputParser(BaseTransformOutputParser):",
            "    \"\"\"Parse an output using xml format.\"\"\"",
            "",
            "    tags: Optional[List[str]] = None",
            "    encoding_matcher: re.Pattern = re.compile(",
            "        r\"<([^>]*encoding[^>]*)>\\n(.*)\", re.MULTILINE | re.DOTALL",
            "    )",
            "",
            "    def get_format_instructions(self) -> str:",
            "        return XML_FORMAT_INSTRUCTIONS.format(tags=self.tags)",
            "",
            "    def parse(self, text: str) -> Dict[str, List[Any]]:",
            "        # Try to find XML string within triple backticks",
            "        match = re.search(r\"```(xml)?(.*)```\", text, re.DOTALL)",
            "        if match is not None:",
            "            # If match found, use the content within the backticks",
            "            text = match.group(2)",
            "        encoding_match = self.encoding_matcher.search(text)",
            "        if encoding_match:",
            "            text = encoding_match.group(2)",
            "",
            "        text = text.strip()",
            "        try:",
            "            root = ET.fromstring(text)",
            "            return self._root_to_dict(root)",
            "",
            "        except ET.ParseError as e:",
            "            msg = f\"Failed to parse XML format from completion {text}. Got: {e}\"",
            "            raise OutputParserException(msg, llm_output=text) from e",
            "",
            "    def _transform(",
            "        self, input: Iterator[Union[str, BaseMessage]]",
            "    ) -> Iterator[AddableDict]:",
            "        xml_start_re = re.compile(r\"<[a-zA-Z:_]\")",
            "        parser = ET.XMLPullParser([\"start\", \"end\"])",
            "        xml_started = False",
            "        current_path: List[str] = []",
            "        current_path_has_children = False",
            "        buffer = \"\"",
            "        for chunk in input:",
            "            if isinstance(chunk, BaseMessage):",
            "                # extract text",
            "                chunk_content = chunk.content",
            "                if not isinstance(chunk_content, str):",
            "                    continue",
            "                chunk = chunk_content",
            "            # add chunk to buffer of unprocessed text",
            "            buffer += chunk",
            "            # if xml string hasn't started yet, continue to next chunk",
            "            if not xml_started:",
            "                if match := xml_start_re.search(buffer):",
            "                    # if xml string has started, remove all text before it",
            "                    buffer = buffer[match.start() :]",
            "                    xml_started = True",
            "                else:",
            "                    continue",
            "            # feed buffer to parser",
            "            parser.feed(buffer)",
            "            buffer = \"\"",
            "            # yield all events",
            "            for event, elem in parser.read_events():",
            "                if event == \"start\":",
            "                    # update current path",
            "                    current_path.append(elem.tag)",
            "                    current_path_has_children = False",
            "                elif event == \"end\":",
            "                    # remove last element from current path",
            "                    current_path.pop()",
            "                    # yield element",
            "                    if not current_path_has_children:",
            "                        yield nested_element(current_path, elem)",
            "                    # prevent yielding of parent element",
            "                    if current_path:",
            "                        current_path_has_children = True",
            "                    else:",
            "                        xml_started = False",
            "        # close parser",
            "        parser.close()",
            "",
            "    async def _atransform(",
            "        self, input: AsyncIterator[Union[str, BaseMessage]]",
            "    ) -> AsyncIterator[AddableDict]:",
            "        parser = ET.XMLPullParser([\"start\", \"end\"])",
            "        current_path: List[str] = []",
            "        current_path_has_children = False",
            "        async for chunk in input:",
            "            if isinstance(chunk, BaseMessage):",
            "                # extract text",
            "                chunk_content = chunk.content",
            "                if not isinstance(chunk_content, str):",
            "                    continue",
            "                chunk = chunk_content",
            "            # pass chunk to parser",
            "            parser.feed(chunk)",
            "            # yield all events",
            "            for event, elem in parser.read_events():",
            "                if event == \"start\":",
            "                    # update current path",
            "                    current_path.append(elem.tag)",
            "                    current_path_has_children = False",
            "                elif event == \"end\":",
            "                    # remove last element from current path",
            "                    current_path.pop()",
            "                    # yield element",
            "                    if not current_path_has_children:",
            "                        yield nested_element(current_path, elem)",
            "                    # prevent yielding of parent element",
            "                    current_path_has_children = True",
            "        # close parser",
            "        parser.close()",
            "",
            "    def _root_to_dict(self, root: ET.Element) -> Dict[str, List[Any]]:",
            "        \"\"\"Converts xml tree to python dictionary.\"\"\"",
            "        result: Dict[str, List[Any]] = {root.tag: []}",
            "        for child in root:",
            "            if len(child) == 0:",
            "                result[root.tag].append({child.tag: child.text})",
            "            else:",
            "                result[root.tag].append(self._root_to_dict(child))",
            "        return result",
            "",
            "    @property",
            "    def _type(self) -> str:",
            "        return \"xml\"",
            "",
            "",
            "def nested_element(path: List[str], elem: ET.Element) -> Any:",
            "    \"\"\"Get nested element from path.\"\"\"",
            "    if len(path) == 0:",
            "        return AddableDict({elem.tag: elem.text})",
            "    else:",
            "        return AddableDict({path[0]: [nested_element(path[1:], elem)]})"
        ],
        "afterPatchFile": [
            "import re",
            "from typing import Any, AsyncIterator, Dict, Iterator, List, Optional, Union",
            "from xml.etree import ElementTree as ET",
            "from xml.etree.ElementTree import TreeBuilder",
            "",
            "from langchain_core.exceptions import OutputParserException",
            "from langchain_core.messages import BaseMessage",
            "from langchain_core.output_parsers.transform import BaseTransformOutputParser",
            "from langchain_core.runnables.utils import AddableDict",
            "",
            "XML_FORMAT_INSTRUCTIONS = \"\"\"The output should be formatted as a XML file.",
            "1. Output should conform to the tags below. ",
            "2. If tags are not given, make them on your own.",
            "3. Remember to always open and close all the tags.",
            "",
            "As an example, for the tags [\"foo\", \"bar\", \"baz\"]:",
            "1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. ",
            "2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.",
            "3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.",
            "",
            "Here are the output tags:",
            "```",
            "{tags}",
            "```\"\"\"  # noqa: E501",
            "",
            "",
            "class XMLOutputParser(BaseTransformOutputParser):",
            "    \"\"\"Parse an output using xml format.\"\"\"",
            "",
            "    tags: Optional[List[str]] = None",
            "    encoding_matcher: re.Pattern = re.compile(",
            "        r\"<([^>]*encoding[^>]*)>\\n(.*)\", re.MULTILINE | re.DOTALL",
            "    )",
            "",
            "    def get_format_instructions(self) -> str:",
            "        return XML_FORMAT_INSTRUCTIONS.format(tags=self.tags)",
            "",
            "    def parse(self, text: str) -> Dict[str, List[Any]]:",
            "        # Imports are temporarily placed here to avoid issue with caching on CI",
            "        # likely if you're reading this you can move them to the top of the file",
            "        from defusedxml import ElementTree as DET  # type: ignore[import]",
            "",
            "        # Try to find XML string within triple backticks",
            "        match = re.search(r\"```(xml)?(.*)```\", text, re.DOTALL)",
            "        if match is not None:",
            "            # If match found, use the content within the backticks",
            "            text = match.group(2)",
            "        encoding_match = self.encoding_matcher.search(text)",
            "        if encoding_match:",
            "            text = encoding_match.group(2)",
            "",
            "        text = text.strip()",
            "        try:",
            "            root = DET.fromstring(text)",
            "            return self._root_to_dict(root)",
            "",
            "        except (DET.ParseError, DET.EntitiesForbidden) as e:",
            "            msg = f\"Failed to parse XML format from completion {text}. Got: {e}\"",
            "            raise OutputParserException(msg, llm_output=text) from e",
            "",
            "    def _transform(",
            "        self, input: Iterator[Union[str, BaseMessage]]",
            "    ) -> Iterator[AddableDict]:",
            "        # Imports are temporarily placed here to avoid issue with caching on CI",
            "        # likely if you're reading this you can move them to the top of the file",
            "        from defusedxml.ElementTree import DefusedXMLParser  # type: ignore[import]",
            "",
            "        parser = ET.XMLPullParser(",
            "            [\"start\", \"end\"], _parser=DefusedXMLParser(target=TreeBuilder())",
            "        )",
            "        xml_start_re = re.compile(r\"<[a-zA-Z:_]\")",
            "        xml_started = False",
            "        current_path: List[str] = []",
            "        current_path_has_children = False",
            "        buffer = \"\"",
            "        for chunk in input:",
            "            if isinstance(chunk, BaseMessage):",
            "                # extract text",
            "                chunk_content = chunk.content",
            "                if not isinstance(chunk_content, str):",
            "                    continue",
            "                chunk = chunk_content",
            "            # add chunk to buffer of unprocessed text",
            "            buffer += chunk",
            "            # if xml string hasn't started yet, continue to next chunk",
            "            if not xml_started:",
            "                if match := xml_start_re.search(buffer):",
            "                    # if xml string has started, remove all text before it",
            "                    buffer = buffer[match.start() :]",
            "                    xml_started = True",
            "                else:",
            "                    continue",
            "            # feed buffer to parser",
            "            parser.feed(buffer)",
            "            buffer = \"\"",
            "            # yield all events",
            "",
            "            for event, elem in parser.read_events():",
            "                if event == \"start\":",
            "                    # update current path",
            "                    current_path.append(elem.tag)",
            "                    current_path_has_children = False",
            "                elif event == \"end\":",
            "                    # remove last element from current path",
            "                    current_path.pop()",
            "                    # yield element",
            "                    if not current_path_has_children:",
            "                        yield nested_element(current_path, elem)",
            "                    # prevent yielding of parent element",
            "                    if current_path:",
            "                        current_path_has_children = True",
            "                    else:",
            "                        xml_started = False",
            "        # close parser",
            "        parser.close()",
            "",
            "    async def _atransform(",
            "        self, input: AsyncIterator[Union[str, BaseMessage]]",
            "    ) -> AsyncIterator[AddableDict]:",
            "        # Imports are temporarily placed here to avoid issue with caching on CI",
            "        # likely if you're reading this you can move them to the top of the file",
            "        from defusedxml.ElementTree import DefusedXMLParser  # type: ignore[import]",
            "",
            "        _parser = DefusedXMLParser(target=TreeBuilder())",
            "        parser = ET.XMLPullParser([\"start\", \"end\"], _parser=_parser)",
            "        xml_start_re = re.compile(r\"<[a-zA-Z:_]\")",
            "        xml_started = False",
            "        current_path: List[str] = []",
            "        current_path_has_children = False",
            "        buffer = \"\"",
            "        async for chunk in input:",
            "            if isinstance(chunk, BaseMessage):",
            "                # extract text",
            "                chunk_content = chunk.content",
            "                if not isinstance(chunk_content, str):",
            "                    continue",
            "                chunk = chunk_content",
            "            # add chunk to buffer of unprocessed text",
            "            buffer += chunk",
            "            # if xml string hasn't started yet, continue to next chunk",
            "            if not xml_started:",
            "                if match := xml_start_re.search(buffer):",
            "                    # if xml string has started, remove all text before it",
            "                    buffer = buffer[match.start() :]",
            "                    xml_started = True",
            "                else:",
            "                    continue",
            "            # feed buffer to parser",
            "            parser.feed(buffer)",
            "            buffer = \"\"",
            "            # yield all events",
            "            for event, elem in parser.read_events():",
            "                if event == \"start\":",
            "                    # update current path",
            "                    current_path.append(elem.tag)",
            "                    current_path_has_children = False",
            "                elif event == \"end\":",
            "                    # remove last element from current path",
            "                    current_path.pop()",
            "                    # yield element",
            "                    if not current_path_has_children:",
            "                        yield nested_element(current_path, elem)",
            "                    # prevent yielding of parent element",
            "                    if current_path:",
            "                        current_path_has_children = True",
            "                    else:",
            "                        xml_started = False",
            "        # close parser",
            "        parser.close()",
            "",
            "    def _root_to_dict(self, root: ET.Element) -> Dict[str, List[Any]]:",
            "        \"\"\"Converts xml tree to python dictionary.\"\"\"",
            "        result: Dict[str, List[Any]] = {root.tag: []}",
            "        for child in root:",
            "            if len(child) == 0:",
            "                result[root.tag].append({child.tag: child.text})",
            "            else:",
            "                result[root.tag].append(self._root_to_dict(child))",
            "        return result",
            "",
            "    @property",
            "    def _type(self) -> str:",
            "        return \"xml\"",
            "",
            "",
            "def nested_element(path: List[str], elem: ET.Element) -> Any:",
            "    \"\"\"Get nested element from path.\"\"\"",
            "    if len(path) == 0:",
            "        return AddableDict({elem.tag: elem.text})",
            "    else:",
            "        return AddableDict({path[0]: [nested_element(path[1:], elem)]})"
        ],
        "action": [
            "0",
            "1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": [],
            "49": [
                "XMLOutputParser",
                "parse"
            ],
            "52": [
                "XMLOutputParser",
                "parse"
            ],
            "60": [
                "XMLOutputParser",
                "_transform"
            ],
            "108": [
                "XMLOutputParser"
            ],
            "118": [
                "XMLOutputParser"
            ],
            "119": [
                "XMLOutputParser"
            ],
            "133": [
                "XMLOutputParser"
            ]
        },
        "addLocation": []
    },
    "libs/core/tests/unit_tests/output_parsers/test_xml_parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " \"\"\"Test XMLOutputParser\"\"\""
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from typing import AsyncIterator"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from xml.etree.ElementTree import ParseError"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import pytest"
            },
            "5": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from langchain_core.exceptions import OutputParserException"
            },
            "7": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " \"\"\","
            },
            "8": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     ],"
            },
            "9": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " )"
            },
            "10": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def test_xml_output_parser(result: str) -> None:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+async def test_xml_output_parser(result: str) -> None:"
            },
            "12": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     \"\"\"Test XMLOutputParser.\"\"\""
            },
            "13": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     xml_parser = XMLOutputParser()"
            },
            "15": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    xml_result = xml_parser.parse(result)"
            },
            "17": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert DEF_RESULT_EXPECTED == xml_result"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    assert DEF_RESULT_EXPECTED == xml_parser.parse(result)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    assert DEF_RESULT_EXPECTED == (await xml_parser.aparse(result))"
            },
            "20": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     assert list(xml_parser.transform(iter(result))) == ["
            },
            "21": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         {\"foo\": [{\"bar\": [{\"baz\": None}]}]},"
            },
            "22": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         {\"foo\": [{\"bar\": [{\"baz\": \"slim.shady\"}]}]},"
            },
            "23": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         {\"foo\": [{\"baz\": \"tag\"}]},"
            },
            "24": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     ]"
            },
            "25": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    async def _as_iter(string: str) -> AsyncIterator[str]:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        for c in string:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            yield c"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    chunks = [chunk async for chunk in xml_parser.atransform(_as_iter(result))]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    assert chunks == ["
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        {\"foo\": [{\"bar\": [{\"baz\": None}]}]},"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        {\"foo\": [{\"bar\": [{\"baz\": \"slim.shady\"}]}]},"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        {\"foo\": [{\"baz\": \"tag\"}]},"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    ]"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " @pytest.mark.parametrize(\"result\", [\"foo></foo>\", \"<foo></foo\", \"foo></foo\", \"foofoo\"])"
            },
            "39": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " def test_xml_output_parser_fail(result: str) -> None:"
            },
            "40": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     with pytest.raises(OutputParserException) as e:"
            },
            "41": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         xml_parser.parse(result)"
            },
            "42": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     assert \"Failed to parse\" in str(e)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+MALICIOUS_XML = \"\"\"<?xml version=\"1.0\"?>"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+<!DOCTYPE lolz [<!ENTITY lol \"lol\"><!ELEMENT lolz (#PCDATA)>"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+ <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+ <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+ <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+ <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\">"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+ <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\">"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+ <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\">"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+ <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\">"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+ <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\">"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+ <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+]>"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+<lolz>&lol9;</lolz>\"\"\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+async def tests_billion_laughs_attack() -> None:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    parser = XMLOutputParser()"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    with pytest.raises(OutputParserException):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        parser.parse(MALICIOUS_XML)"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    with pytest.raises(OutputParserException):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        await parser.aparse(MALICIOUS_XML)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    with pytest.raises(ParseError):"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        # Right now raises undefined entity error"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        assert list(parser.transform(iter(MALICIOUS_XML))) == ["
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            {\"foo\": [{\"bar\": [{\"baz\": None}]}]}"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        ]"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    async def _as_iter(string: str) -> AsyncIterator[str]:"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        for c in string:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            yield c"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+    with pytest.raises(ParseError):"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        chunks = [chunk async for chunk in parser.atransform(_as_iter(MALICIOUS_XML))]"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        assert chunks == [{\"foo\": [{\"bar\": [{\"baz\": None}]}]}]"
            }
        },
        "frontPatchFile": [
            "\"\"\"Test XMLOutputParser\"\"\"",
            "import pytest",
            "",
            "from langchain_core.exceptions import OutputParserException",
            "from langchain_core.output_parsers.xml import XMLOutputParser",
            "",
            "DEF_RESULT_ENCODING = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            " <foo>",
            "    <bar>",
            "        <baz></baz>",
            "        <baz>slim.shady</baz>",
            "    </bar>",
            "    <baz>tag</baz>",
            "</foo>\"\"\"",
            "",
            "DEF_RESULT_EXPECTED = {",
            "    \"foo\": [",
            "        {\"bar\": [{\"baz\": None}, {\"baz\": \"slim.shady\"}]},",
            "        {\"baz\": \"tag\"},",
            "    ],",
            "}",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"result\",",
            "    [",
            "        DEF_RESULT_ENCODING,",
            "        DEF_RESULT_ENCODING[DEF_RESULT_ENCODING.find(\"\\n\") :],",
            "        f\"\"\"",
            "```xml",
            "{DEF_RESULT_ENCODING}",
            "```",
            "\"\"\",",
            "        f\"\"\"",
            "Some random text",
            "```xml",
            "{DEF_RESULT_ENCODING}",
            "```",
            "More random text",
            "\"\"\",",
            "    ],",
            ")",
            "def test_xml_output_parser(result: str) -> None:",
            "    \"\"\"Test XMLOutputParser.\"\"\"",
            "",
            "    xml_parser = XMLOutputParser()",
            "",
            "    xml_result = xml_parser.parse(result)",
            "    assert DEF_RESULT_EXPECTED == xml_result",
            "    assert list(xml_parser.transform(iter(result))) == [",
            "        {\"foo\": [{\"bar\": [{\"baz\": None}]}]},",
            "        {\"foo\": [{\"bar\": [{\"baz\": \"slim.shady\"}]}]},",
            "        {\"foo\": [{\"baz\": \"tag\"}]},",
            "    ]",
            "",
            "",
            "@pytest.mark.parametrize(\"result\", [\"foo></foo>\", \"<foo></foo\", \"foo></foo\", \"foofoo\"])",
            "def test_xml_output_parser_fail(result: str) -> None:",
            "    \"\"\"Test XMLOutputParser where complete output is not in XML format.\"\"\"",
            "",
            "    xml_parser = XMLOutputParser()",
            "",
            "    with pytest.raises(OutputParserException) as e:",
            "        xml_parser.parse(result)",
            "    assert \"Failed to parse\" in str(e)"
        ],
        "afterPatchFile": [
            "\"\"\"Test XMLOutputParser\"\"\"",
            "from typing import AsyncIterator",
            "from xml.etree.ElementTree import ParseError",
            "",
            "import pytest",
            "",
            "from langchain_core.exceptions import OutputParserException",
            "from langchain_core.output_parsers.xml import XMLOutputParser",
            "",
            "DEF_RESULT_ENCODING = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            " <foo>",
            "    <bar>",
            "        <baz></baz>",
            "        <baz>slim.shady</baz>",
            "    </bar>",
            "    <baz>tag</baz>",
            "</foo>\"\"\"",
            "",
            "DEF_RESULT_EXPECTED = {",
            "    \"foo\": [",
            "        {\"bar\": [{\"baz\": None}, {\"baz\": \"slim.shady\"}]},",
            "        {\"baz\": \"tag\"},",
            "    ],",
            "}",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"result\",",
            "    [",
            "        DEF_RESULT_ENCODING,",
            "        DEF_RESULT_ENCODING[DEF_RESULT_ENCODING.find(\"\\n\") :],",
            "        f\"\"\"",
            "```xml",
            "{DEF_RESULT_ENCODING}",
            "```",
            "\"\"\",",
            "        f\"\"\"",
            "Some random text",
            "```xml",
            "{DEF_RESULT_ENCODING}",
            "```",
            "More random text",
            "\"\"\",",
            "    ],",
            ")",
            "async def test_xml_output_parser(result: str) -> None:",
            "    \"\"\"Test XMLOutputParser.\"\"\"",
            "",
            "    xml_parser = XMLOutputParser()",
            "    assert DEF_RESULT_EXPECTED == xml_parser.parse(result)",
            "    assert DEF_RESULT_EXPECTED == (await xml_parser.aparse(result))",
            "    assert list(xml_parser.transform(iter(result))) == [",
            "        {\"foo\": [{\"bar\": [{\"baz\": None}]}]},",
            "        {\"foo\": [{\"bar\": [{\"baz\": \"slim.shady\"}]}]},",
            "        {\"foo\": [{\"baz\": \"tag\"}]},",
            "    ]",
            "",
            "    async def _as_iter(string: str) -> AsyncIterator[str]:",
            "        for c in string:",
            "            yield c",
            "",
            "    chunks = [chunk async for chunk in xml_parser.atransform(_as_iter(result))]",
            "    assert chunks == [",
            "        {\"foo\": [{\"bar\": [{\"baz\": None}]}]},",
            "        {\"foo\": [{\"bar\": [{\"baz\": \"slim.shady\"}]}]},",
            "        {\"foo\": [{\"baz\": \"tag\"}]},",
            "    ]",
            "",
            "",
            "@pytest.mark.parametrize(\"result\", [\"foo></foo>\", \"<foo></foo\", \"foo></foo\", \"foofoo\"])",
            "def test_xml_output_parser_fail(result: str) -> None:",
            "    \"\"\"Test XMLOutputParser where complete output is not in XML format.\"\"\"",
            "",
            "    xml_parser = XMLOutputParser()",
            "",
            "    with pytest.raises(OutputParserException) as e:",
            "        xml_parser.parse(result)",
            "    assert \"Failed to parse\" in str(e)",
            "",
            "",
            "MALICIOUS_XML = \"\"\"<?xml version=\"1.0\"?>",
            "<!DOCTYPE lolz [<!ENTITY lol \"lol\"><!ELEMENT lolz (#PCDATA)>",
            " <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">",
            " <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">",
            " <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">",
            " <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\">",
            " <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\">",
            " <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\">",
            " <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\">",
            " <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\">",
            " <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">",
            "]>",
            "<lolz>&lol9;</lolz>\"\"\"",
            "",
            "",
            "async def tests_billion_laughs_attack() -> None:",
            "    parser = XMLOutputParser()",
            "    with pytest.raises(OutputParserException):",
            "        parser.parse(MALICIOUS_XML)",
            "",
            "    with pytest.raises(OutputParserException):",
            "        await parser.aparse(MALICIOUS_XML)",
            "",
            "    with pytest.raises(ParseError):",
            "        # Right now raises undefined entity error",
            "        assert list(parser.transform(iter(MALICIOUS_XML))) == [",
            "            {\"foo\": [{\"bar\": [{\"baz\": None}]}]}",
            "        ]",
            "",
            "    async def _as_iter(string: str) -> AsyncIterator[str]:",
            "        for c in string:",
            "            yield c",
            "",
            "    with pytest.raises(ParseError):",
            "        chunks = [chunk async for chunk in parser.atransform(_as_iter(MALICIOUS_XML))]",
            "        assert chunks == [{\"foo\": [{\"bar\": [{\"baz\": None}]}]}]"
        ],
        "action": [
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "43": [
                "test_xml_output_parser"
            ],
            "47": [
                "test_xml_output_parser"
            ],
            "48": [
                "test_xml_output_parser"
            ],
            "49": [
                "test_xml_output_parser"
            ]
        },
        "addLocation": []
    }
}