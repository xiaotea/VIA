{
    "homeassistant/components/octoprint/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import homeassistant.helpers.config_validation as cv"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from homeassistant.helpers.typing import ConfigType"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from homeassistant.util import slugify as util_slugify"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from homeassistant.util.ssl import get_default_context, get_default_no_verify_context"
            },
            "4": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from .const import DOMAIN"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from .coordinator import OctoprintDataUpdateCoordinator"
            },
            "7": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     connector = aiohttp.TCPConnector("
            },
            "9": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         force_close=True,"
            },
            "10": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ssl=False if not entry.data[CONF_VERIFY_SSL] else None,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        ssl=get_default_no_verify_context()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        if not entry.data[CONF_VERIFY_SSL]"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        else get_default_context(),"
            },
            "14": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     )"
            },
            "15": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     session = aiohttp.ClientSession(connector=connector)"
            },
            "16": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Support for monitoring OctoPrint 3D printers.\"\"\"",
            "from __future__ import annotations",
            "",
            "import logging",
            "",
            "import aiohttp",
            "from pyoctoprintapi import OctoprintClient",
            "import voluptuous as vol",
            "",
            "from homeassistant.config_entries import SOURCE_IMPORT, ConfigEntry",
            "from homeassistant.const import (",
            "    CONF_API_KEY,",
            "    CONF_BINARY_SENSORS,",
            "    CONF_HOST,",
            "    CONF_MONITORED_CONDITIONS,",
            "    CONF_NAME,",
            "    CONF_PATH,",
            "    CONF_PORT,",
            "    CONF_SENSORS,",
            "    CONF_SSL,",
            "    CONF_VERIFY_SSL,",
            "    EVENT_HOMEASSISTANT_STOP,",
            "    Platform,",
            ")",
            "from homeassistant.core import Event, HomeAssistant, callback",
            "import homeassistant.helpers.config_validation as cv",
            "from homeassistant.helpers.typing import ConfigType",
            "from homeassistant.util import slugify as util_slugify",
            "",
            "from .const import DOMAIN",
            "from .coordinator import OctoprintDataUpdateCoordinator",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "",
            "def has_all_unique_names(value):",
            "    \"\"\"Validate that printers have an unique name.\"\"\"",
            "    names = [util_slugify(printer[\"name\"]) for printer in value]",
            "    vol.Schema(vol.Unique())(names)",
            "    return value",
            "",
            "",
            "def ensure_valid_path(value):",
            "    \"\"\"Validate the path, ensuring it starts and ends with a /.\"\"\"",
            "    vol.Schema(cv.string)(value)",
            "    if value[0] != \"/\":",
            "        value = f\"/{value}\"",
            "    if value[-1] != \"/\":",
            "        value += \"/\"",
            "    return value",
            "",
            "",
            "PLATFORMS = [Platform.BINARY_SENSOR, Platform.BUTTON, Platform.CAMERA, Platform.SENSOR]",
            "DEFAULT_NAME = \"OctoPrint\"",
            "CONF_NUMBER_OF_TOOLS = \"number_of_tools\"",
            "CONF_BED = \"bed\"",
            "",
            "BINARY_SENSOR_TYPES = [",
            "    \"Printing\",",
            "    \"Printing Error\",",
            "]",
            "",
            "BINARY_SENSOR_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(",
            "            CONF_MONITORED_CONDITIONS, default=list(BINARY_SENSOR_TYPES)",
            "        ): vol.All(cv.ensure_list, [vol.In(BINARY_SENSOR_TYPES)]),",
            "        vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "    }",
            ")",
            "",
            "SENSOR_TYPES = [",
            "    \"Temperatures\",",
            "    \"Current State\",",
            "    \"Job Percentage\",",
            "    \"Time Remaining\",",
            "    \"Time Elapsed\",",
            "]",
            "",
            "SENSOR_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(CONF_MONITORED_CONDITIONS, default=list(SENSOR_TYPES)): vol.All(",
            "            cv.ensure_list, [vol.In(SENSOR_TYPES)]",
            "        ),",
            "        vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "    }",
            ")",
            "",
            "CONFIG_SCHEMA = vol.Schema(",
            "    vol.All(",
            "        cv.deprecated(DOMAIN),",
            "        {",
            "            DOMAIN: vol.All(",
            "                cv.ensure_list,",
            "                [",
            "                    vol.Schema(",
            "                        {",
            "                            vol.Required(CONF_API_KEY): cv.string,",
            "                            vol.Required(CONF_HOST): cv.string,",
            "                            vol.Optional(CONF_SSL, default=False): cv.boolean,",
            "                            vol.Optional(CONF_PORT, default=80): cv.port,",
            "                            vol.Optional(CONF_PATH, default=\"/\"): ensure_valid_path,",
            "                            # Following values are not longer used in the configuration",
            "                            # of the integration and are here for historical purposes",
            "                            vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "                            vol.Optional(",
            "                                CONF_NUMBER_OF_TOOLS, default=0",
            "                            ): cv.positive_int,",
            "                            vol.Optional(CONF_BED, default=False): cv.boolean,",
            "                            vol.Optional(CONF_SENSORS, default={}): SENSOR_SCHEMA,",
            "                            vol.Optional(",
            "                                CONF_BINARY_SENSORS, default={}",
            "                            ): BINARY_SENSOR_SCHEMA,",
            "                        }",
            "                    )",
            "                ],",
            "                has_all_unique_names,",
            "            )",
            "        },",
            "    ),",
            "    extra=vol.ALLOW_EXTRA,",
            ")",
            "",
            "",
            "async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:",
            "    \"\"\"Set up the OctoPrint component.\"\"\"",
            "    if DOMAIN not in config:",
            "        return True",
            "",
            "    domain_config = config[DOMAIN]",
            "",
            "    for conf in domain_config:",
            "        hass.async_create_task(",
            "            hass.config_entries.flow.async_init(",
            "                DOMAIN,",
            "                context={\"source\": SOURCE_IMPORT},",
            "                data={",
            "                    CONF_API_KEY: conf[CONF_API_KEY],",
            "                    CONF_HOST: conf[CONF_HOST],",
            "                    CONF_PATH: conf[CONF_PATH],",
            "                    CONF_PORT: conf[CONF_PORT],",
            "                    CONF_SSL: conf[CONF_SSL],",
            "                },",
            "            )",
            "        )",
            "",
            "    return True",
            "",
            "",
            "async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:",
            "    \"\"\"Set up OctoPrint from a config entry.\"\"\"",
            "",
            "    if DOMAIN not in hass.data:",
            "        hass.data[DOMAIN] = {}",
            "",
            "    if CONF_VERIFY_SSL not in entry.data:",
            "        data = {**entry.data, CONF_VERIFY_SSL: True}",
            "        hass.config_entries.async_update_entry(entry, data=data)",
            "",
            "    connector = aiohttp.TCPConnector(",
            "        force_close=True,",
            "        ssl=False if not entry.data[CONF_VERIFY_SSL] else None,",
            "    )",
            "    session = aiohttp.ClientSession(connector=connector)",
            "",
            "    @callback",
            "    def _async_close_websession(event: Event) -> None:",
            "        \"\"\"Close websession.\"\"\"",
            "        session.detach()",
            "",
            "    hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, _async_close_websession)",
            "",
            "    client = OctoprintClient(",
            "        host=entry.data[CONF_HOST],",
            "        session=session,",
            "        port=entry.data[CONF_PORT],",
            "        ssl=entry.data[CONF_SSL],",
            "        path=entry.data[CONF_PATH],",
            "    )",
            "",
            "    client.set_api_key(entry.data[CONF_API_KEY])",
            "",
            "    coordinator = OctoprintDataUpdateCoordinator(hass, client, entry, 30)",
            "",
            "    await coordinator.async_config_entry_first_refresh()",
            "",
            "    hass.data[DOMAIN][entry.entry_id] = {",
            "        \"coordinator\": coordinator,",
            "        \"client\": client,",
            "    }",
            "",
            "    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)",
            "",
            "    return True",
            "",
            "",
            "async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:",
            "    \"\"\"Unload a config entry.\"\"\"",
            "    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)",
            "",
            "    if unload_ok:",
            "        hass.data[DOMAIN].pop(entry.entry_id)",
            "",
            "    return unload_ok"
        ],
        "afterPatchFile": [
            "\"\"\"Support for monitoring OctoPrint 3D printers.\"\"\"",
            "from __future__ import annotations",
            "",
            "import logging",
            "",
            "import aiohttp",
            "from pyoctoprintapi import OctoprintClient",
            "import voluptuous as vol",
            "",
            "from homeassistant.config_entries import SOURCE_IMPORT, ConfigEntry",
            "from homeassistant.const import (",
            "    CONF_API_KEY,",
            "    CONF_BINARY_SENSORS,",
            "    CONF_HOST,",
            "    CONF_MONITORED_CONDITIONS,",
            "    CONF_NAME,",
            "    CONF_PATH,",
            "    CONF_PORT,",
            "    CONF_SENSORS,",
            "    CONF_SSL,",
            "    CONF_VERIFY_SSL,",
            "    EVENT_HOMEASSISTANT_STOP,",
            "    Platform,",
            ")",
            "from homeassistant.core import Event, HomeAssistant, callback",
            "import homeassistant.helpers.config_validation as cv",
            "from homeassistant.helpers.typing import ConfigType",
            "from homeassistant.util import slugify as util_slugify",
            "from homeassistant.util.ssl import get_default_context, get_default_no_verify_context",
            "",
            "from .const import DOMAIN",
            "from .coordinator import OctoprintDataUpdateCoordinator",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "",
            "def has_all_unique_names(value):",
            "    \"\"\"Validate that printers have an unique name.\"\"\"",
            "    names = [util_slugify(printer[\"name\"]) for printer in value]",
            "    vol.Schema(vol.Unique())(names)",
            "    return value",
            "",
            "",
            "def ensure_valid_path(value):",
            "    \"\"\"Validate the path, ensuring it starts and ends with a /.\"\"\"",
            "    vol.Schema(cv.string)(value)",
            "    if value[0] != \"/\":",
            "        value = f\"/{value}\"",
            "    if value[-1] != \"/\":",
            "        value += \"/\"",
            "    return value",
            "",
            "",
            "PLATFORMS = [Platform.BINARY_SENSOR, Platform.BUTTON, Platform.CAMERA, Platform.SENSOR]",
            "DEFAULT_NAME = \"OctoPrint\"",
            "CONF_NUMBER_OF_TOOLS = \"number_of_tools\"",
            "CONF_BED = \"bed\"",
            "",
            "BINARY_SENSOR_TYPES = [",
            "    \"Printing\",",
            "    \"Printing Error\",",
            "]",
            "",
            "BINARY_SENSOR_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(",
            "            CONF_MONITORED_CONDITIONS, default=list(BINARY_SENSOR_TYPES)",
            "        ): vol.All(cv.ensure_list, [vol.In(BINARY_SENSOR_TYPES)]),",
            "        vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "    }",
            ")",
            "",
            "SENSOR_TYPES = [",
            "    \"Temperatures\",",
            "    \"Current State\",",
            "    \"Job Percentage\",",
            "    \"Time Remaining\",",
            "    \"Time Elapsed\",",
            "]",
            "",
            "SENSOR_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(CONF_MONITORED_CONDITIONS, default=list(SENSOR_TYPES)): vol.All(",
            "            cv.ensure_list, [vol.In(SENSOR_TYPES)]",
            "        ),",
            "        vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "    }",
            ")",
            "",
            "CONFIG_SCHEMA = vol.Schema(",
            "    vol.All(",
            "        cv.deprecated(DOMAIN),",
            "        {",
            "            DOMAIN: vol.All(",
            "                cv.ensure_list,",
            "                [",
            "                    vol.Schema(",
            "                        {",
            "                            vol.Required(CONF_API_KEY): cv.string,",
            "                            vol.Required(CONF_HOST): cv.string,",
            "                            vol.Optional(CONF_SSL, default=False): cv.boolean,",
            "                            vol.Optional(CONF_PORT, default=80): cv.port,",
            "                            vol.Optional(CONF_PATH, default=\"/\"): ensure_valid_path,",
            "                            # Following values are not longer used in the configuration",
            "                            # of the integration and are here for historical purposes",
            "                            vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,",
            "                            vol.Optional(",
            "                                CONF_NUMBER_OF_TOOLS, default=0",
            "                            ): cv.positive_int,",
            "                            vol.Optional(CONF_BED, default=False): cv.boolean,",
            "                            vol.Optional(CONF_SENSORS, default={}): SENSOR_SCHEMA,",
            "                            vol.Optional(",
            "                                CONF_BINARY_SENSORS, default={}",
            "                            ): BINARY_SENSOR_SCHEMA,",
            "                        }",
            "                    )",
            "                ],",
            "                has_all_unique_names,",
            "            )",
            "        },",
            "    ),",
            "    extra=vol.ALLOW_EXTRA,",
            ")",
            "",
            "",
            "async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:",
            "    \"\"\"Set up the OctoPrint component.\"\"\"",
            "    if DOMAIN not in config:",
            "        return True",
            "",
            "    domain_config = config[DOMAIN]",
            "",
            "    for conf in domain_config:",
            "        hass.async_create_task(",
            "            hass.config_entries.flow.async_init(",
            "                DOMAIN,",
            "                context={\"source\": SOURCE_IMPORT},",
            "                data={",
            "                    CONF_API_KEY: conf[CONF_API_KEY],",
            "                    CONF_HOST: conf[CONF_HOST],",
            "                    CONF_PATH: conf[CONF_PATH],",
            "                    CONF_PORT: conf[CONF_PORT],",
            "                    CONF_SSL: conf[CONF_SSL],",
            "                },",
            "            )",
            "        )",
            "",
            "    return True",
            "",
            "",
            "async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:",
            "    \"\"\"Set up OctoPrint from a config entry.\"\"\"",
            "",
            "    if DOMAIN not in hass.data:",
            "        hass.data[DOMAIN] = {}",
            "",
            "    if CONF_VERIFY_SSL not in entry.data:",
            "        data = {**entry.data, CONF_VERIFY_SSL: True}",
            "        hass.config_entries.async_update_entry(entry, data=data)",
            "",
            "    connector = aiohttp.TCPConnector(",
            "        force_close=True,",
            "        ssl=get_default_no_verify_context()",
            "        if not entry.data[CONF_VERIFY_SSL]",
            "        else get_default_context(),",
            "    )",
            "    session = aiohttp.ClientSession(connector=connector)",
            "",
            "    @callback",
            "    def _async_close_websession(event: Event) -> None:",
            "        \"\"\"Close websession.\"\"\"",
            "        session.detach()",
            "",
            "    hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, _async_close_websession)",
            "",
            "    client = OctoprintClient(",
            "        host=entry.data[CONF_HOST],",
            "        session=session,",
            "        port=entry.data[CONF_PORT],",
            "        ssl=entry.data[CONF_SSL],",
            "        path=entry.data[CONF_PATH],",
            "    )",
            "",
            "    client.set_api_key(entry.data[CONF_API_KEY])",
            "",
            "    coordinator = OctoprintDataUpdateCoordinator(hass, client, entry, 30)",
            "",
            "    await coordinator.async_config_entry_first_refresh()",
            "",
            "    hass.data[DOMAIN][entry.entry_id] = {",
            "        \"coordinator\": coordinator,",
            "        \"client\": client,",
            "    }",
            "",
            "    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)",
            "",
            "    return True",
            "",
            "",
            "async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:",
            "    \"\"\"Unload a config entry.\"\"\"",
            "    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)",
            "",
            "    if unload_ok:",
            "        hass.data[DOMAIN].pop(entry.entry_id)",
            "",
            "    return unload_ok"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "162": []
        },
        "addLocation": []
    },
    "homeassistant/components/octoprint/config_flow.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " )"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from homeassistant.data_entry_flow import FlowResult"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import homeassistant.helpers.config_validation as cv"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from homeassistant.util.ssl import get_default_context, get_default_no_verify_context"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from .const import DOMAIN"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         connector = aiohttp.TCPConnector("
            },
            "9": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "             force_close=True,"
            },
            "10": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ssl=False if not verify_ssl else None,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+            ssl=get_default_no_verify_context()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            if not verify_ssl"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+            else get_default_context(),"
            },
            "14": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "         )"
            },
            "15": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         session = aiohttp.ClientSession(connector=connector)"
            },
            "16": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "         self._sessions.append(session)"
            }
        },
        "frontPatchFile": [
            "\"\"\"Config flow for OctoPrint integration.\"\"\"",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any",
            "",
            "import aiohttp",
            "from pyoctoprintapi import ApiError, OctoprintClient, OctoprintException",
            "import voluptuous as vol",
            "from yarl import URL",
            "",
            "from homeassistant import config_entries, data_entry_flow, exceptions",
            "from homeassistant.components import ssdp, zeroconf",
            "from homeassistant.const import (",
            "    CONF_API_KEY,",
            "    CONF_HOST,",
            "    CONF_PATH,",
            "    CONF_PORT,",
            "    CONF_SSL,",
            "    CONF_USERNAME,",
            "    CONF_VERIFY_SSL,",
            ")",
            "from homeassistant.data_entry_flow import FlowResult",
            "import homeassistant.helpers.config_validation as cv",
            "",
            "from .const import DOMAIN",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "",
            "def _schema_with_defaults(",
            "    username=\"\", host=\"\", port=80, path=\"/\", ssl=False, verify_ssl=True",
            "):",
            "    return vol.Schema(",
            "        {",
            "            vol.Required(CONF_USERNAME, default=username): str,",
            "            vol.Required(CONF_HOST, default=host): str,",
            "            vol.Required(CONF_PORT, default=port): cv.port,",
            "            vol.Required(CONF_PATH, default=path): str,",
            "            vol.Required(CONF_SSL, default=ssl): bool,",
            "            vol.Required(CONF_VERIFY_SSL, default=verify_ssl): bool,",
            "        },",
            "        extra=vol.ALLOW_EXTRA,",
            "    )",
            "",
            "",
            "class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):",
            "    \"\"\"Handle a config flow for OctoPrint.\"\"\"",
            "",
            "    VERSION = 1",
            "",
            "    api_key_task: asyncio.Task[None] | None = None",
            "    _reauth_data: dict[str, Any] | None = None",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"Handle a config flow for OctoPrint.\"\"\"",
            "        self.discovery_schema = None",
            "        self._user_input = None",
            "        self._sessions: list[aiohttp.ClientSession] = []",
            "",
            "    async def async_step_user(self, user_input=None):",
            "        \"\"\"Handle the initial step.\"\"\"",
            "        # When coming back from the progress steps, the user_input is stored in the",
            "        # instance variable instead of being passed in",
            "        if user_input is None and self._user_input:",
            "            user_input = self._user_input",
            "",
            "        if user_input is None:",
            "            data = self.discovery_schema or _schema_with_defaults()",
            "            return self.async_show_form(step_id=\"user\", data_schema=data)",
            "",
            "        if CONF_API_KEY in user_input:",
            "            errors = {}",
            "            try:",
            "                return await self._finish_config(user_input)",
            "            except data_entry_flow.AbortFlow as err:",
            "                raise err from None",
            "            except CannotConnect:",
            "                errors[\"base\"] = \"cannot_connect\"",
            "            except Exception:  # pylint: disable=broad-except",
            "                errors[\"base\"] = \"unknown\"",
            "",
            "            if errors:",
            "                return self.async_show_form(",
            "                    step_id=\"user\",",
            "                    errors=errors,",
            "                    data_schema=_schema_with_defaults(",
            "                        user_input.get(CONF_USERNAME),",
            "                        user_input[CONF_HOST],",
            "                        user_input[CONF_PORT],",
            "                        user_input[CONF_PATH],",
            "                        user_input[CONF_SSL],",
            "                        user_input[CONF_VERIFY_SSL],",
            "                    ),",
            "                )",
            "",
            "        self.api_key_task = None",
            "        return await self.async_step_get_api_key(user_input)",
            "",
            "    async def async_step_get_api_key(self, user_input):",
            "        \"\"\"Get an Application Api Key.\"\"\"",
            "        if not self.api_key_task:",
            "            self.api_key_task = self.hass.async_create_task(",
            "                self._async_get_auth_key(user_input)",
            "            )",
            "            return self.async_show_progress(",
            "                step_id=\"get_api_key\", progress_action=\"get_api_key\"",
            "            )",
            "",
            "        try:",
            "            await self.api_key_task",
            "        except OctoprintException as err:",
            "            _LOGGER.exception(\"Failed to get an application key: %s\", err)",
            "            return self.async_show_progress_done(next_step_id=\"auth_failed\")",
            "        except Exception as err:  # pylint: disable=broad-except",
            "            _LOGGER.exception(\"Failed to get an application key : %s\", err)",
            "            return self.async_show_progress_done(next_step_id=\"auth_failed\")",
            "",
            "        # store this off here to pick back up in the user step",
            "        self._user_input = user_input",
            "        return self.async_show_progress_done(next_step_id=\"user\")",
            "",
            "    async def _finish_config(self, user_input: dict):",
            "        \"\"\"Finish the configuration setup.\"\"\"",
            "        existing_entry = await self.async_set_unique_id(self.unique_id)",
            "        if existing_entry is not None:",
            "            self.hass.config_entries.async_update_entry(existing_entry, data=user_input)",
            "            # Reload the config entry otherwise devices will remain unavailable",
            "            self.hass.async_create_task(",
            "                self.hass.config_entries.async_reload(existing_entry.entry_id)",
            "            )",
            "",
            "            return self.async_abort(reason=\"reauth_successful\")",
            "",
            "        octoprint = self._get_octoprint_client(user_input)",
            "        octoprint.set_api_key(user_input[CONF_API_KEY])",
            "",
            "        try:",
            "            discovery = await octoprint.get_discovery_info()",
            "        except ApiError as err:",
            "            _LOGGER.error(\"Failed to connect to printer\")",
            "            raise CannotConnect from err",
            "",
            "        await self.async_set_unique_id(discovery.upnp_uuid, raise_on_progress=False)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        return self.async_create_entry(title=user_input[CONF_HOST], data=user_input)",
            "",
            "    async def async_step_auth_failed(self, user_input):",
            "        \"\"\"Handle api fetch failure.\"\"\"",
            "        return self.async_abort(reason=\"auth_failed\")",
            "",
            "    async def async_step_import(self, user_input):",
            "        \"\"\"Handle import.\"\"\"",
            "        return await self.async_step_user(user_input)",
            "",
            "    async def async_step_zeroconf(",
            "        self, discovery_info: zeroconf.ZeroconfServiceInfo",
            "    ) -> data_entry_flow.FlowResult:",
            "        \"\"\"Handle discovery flow.\"\"\"",
            "        uuid = discovery_info.properties[\"uuid\"]",
            "        await self.async_set_unique_id(uuid)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: discovery_info.host},",
            "                \"configuration_url\": (",
            "                    f\"http://{discovery_info.host}:{discovery_info.port}\"",
            "                    f\"{discovery_info.properties[CONF_PATH]}\"",
            "                ),",
            "            }",
            "        )",
            "",
            "        self.discovery_schema = _schema_with_defaults(",
            "            host=discovery_info.host,",
            "            port=discovery_info.port,",
            "            path=discovery_info.properties[CONF_PATH],",
            "        )",
            "",
            "        return await self.async_step_user()",
            "",
            "    async def async_step_ssdp(",
            "        self, discovery_info: ssdp.SsdpServiceInfo",
            "    ) -> data_entry_flow.FlowResult:",
            "        \"\"\"Handle ssdp discovery flow.\"\"\"",
            "        uuid = discovery_info.upnp[\"UDN\"][5:]",
            "        await self.async_set_unique_id(uuid)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        url = URL(discovery_info.upnp[\"presentationURL\"])",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: url.host},",
            "                \"configuration_url\": discovery_info.upnp[\"presentationURL\"],",
            "            }",
            "        )",
            "",
            "        self.discovery_schema = _schema_with_defaults(",
            "            host=url.host,",
            "            path=url.path,",
            "            port=url.port,",
            "            ssl=url.scheme == \"https\",",
            "        )",
            "",
            "        return await self.async_step_user()",
            "",
            "    async def async_step_reauth(self, config: Mapping[str, Any]) -> FlowResult:",
            "        \"\"\"Handle reauthorization request from Octoprint.\"\"\"",
            "        self._reauth_data = dict(config)",
            "",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: config[CONF_HOST]},",
            "            }",
            "        )",
            "",
            "        return await self.async_step_reauth_confirm()",
            "",
            "    async def async_step_reauth_confirm(",
            "        self, user_input: dict[str, Any] | None = None",
            "    ) -> FlowResult:",
            "        \"\"\"Handle reauthorization flow.\"\"\"",
            "        assert self._reauth_data is not None",
            "",
            "        if user_input is None:",
            "            return self.async_show_form(",
            "                step_id=\"reauth_confirm\",",
            "                data_schema=vol.Schema(",
            "                    {",
            "                        vol.Required(",
            "                            CONF_USERNAME, default=self._reauth_data[CONF_USERNAME]",
            "                        ): str,",
            "                    }",
            "                ),",
            "            )",
            "",
            "        self.api_key_task = None",
            "        self._reauth_data[CONF_USERNAME] = user_input[CONF_USERNAME]",
            "",
            "        return await self.async_step_get_api_key(self._reauth_data)",
            "",
            "    async def _async_get_auth_key(self, user_input: dict):",
            "        \"\"\"Get application api key.\"\"\"",
            "        octoprint = self._get_octoprint_client(user_input)",
            "",
            "        try:",
            "            user_input[CONF_API_KEY] = await octoprint.request_app_key(",
            "                \"Home Assistant\", user_input[CONF_USERNAME], 300",
            "            )",
            "        finally:",
            "            # Continue the flow after show progress when the task is done.",
            "            self.hass.async_create_task(",
            "                self.hass.config_entries.flow.async_configure(",
            "                    flow_id=self.flow_id, user_input=user_input",
            "                )",
            "            )",
            "",
            "    def _get_octoprint_client(self, user_input: dict) -> OctoprintClient:",
            "        \"\"\"Build an octoprint client from the user_input.\"\"\"",
            "        verify_ssl = user_input.get(CONF_VERIFY_SSL, True)",
            "",
            "        connector = aiohttp.TCPConnector(",
            "            force_close=True,",
            "            ssl=False if not verify_ssl else None,",
            "        )",
            "        session = aiohttp.ClientSession(connector=connector)",
            "        self._sessions.append(session)",
            "",
            "        return OctoprintClient(",
            "            host=user_input[CONF_HOST],",
            "            session=session,",
            "            port=user_input[CONF_PORT],",
            "            ssl=user_input[CONF_SSL],",
            "            path=user_input[CONF_PATH],",
            "        )",
            "",
            "    def async_remove(self):",
            "        \"\"\"Detach the session.\"\"\"",
            "        for session in self._sessions:",
            "            session.detach()",
            "",
            "",
            "class CannotConnect(exceptions.HomeAssistantError):",
            "    \"\"\"Error to indicate we cannot connect.\"\"\""
        ],
        "afterPatchFile": [
            "\"\"\"Config flow for OctoPrint integration.\"\"\"",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any",
            "",
            "import aiohttp",
            "from pyoctoprintapi import ApiError, OctoprintClient, OctoprintException",
            "import voluptuous as vol",
            "from yarl import URL",
            "",
            "from homeassistant import config_entries, data_entry_flow, exceptions",
            "from homeassistant.components import ssdp, zeroconf",
            "from homeassistant.const import (",
            "    CONF_API_KEY,",
            "    CONF_HOST,",
            "    CONF_PATH,",
            "    CONF_PORT,",
            "    CONF_SSL,",
            "    CONF_USERNAME,",
            "    CONF_VERIFY_SSL,",
            ")",
            "from homeassistant.data_entry_flow import FlowResult",
            "import homeassistant.helpers.config_validation as cv",
            "from homeassistant.util.ssl import get_default_context, get_default_no_verify_context",
            "",
            "from .const import DOMAIN",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "",
            "def _schema_with_defaults(",
            "    username=\"\", host=\"\", port=80, path=\"/\", ssl=False, verify_ssl=True",
            "):",
            "    return vol.Schema(",
            "        {",
            "            vol.Required(CONF_USERNAME, default=username): str,",
            "            vol.Required(CONF_HOST, default=host): str,",
            "            vol.Required(CONF_PORT, default=port): cv.port,",
            "            vol.Required(CONF_PATH, default=path): str,",
            "            vol.Required(CONF_SSL, default=ssl): bool,",
            "            vol.Required(CONF_VERIFY_SSL, default=verify_ssl): bool,",
            "        },",
            "        extra=vol.ALLOW_EXTRA,",
            "    )",
            "",
            "",
            "class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):",
            "    \"\"\"Handle a config flow for OctoPrint.\"\"\"",
            "",
            "    VERSION = 1",
            "",
            "    api_key_task: asyncio.Task[None] | None = None",
            "    _reauth_data: dict[str, Any] | None = None",
            "",
            "    def __init__(self) -> None:",
            "        \"\"\"Handle a config flow for OctoPrint.\"\"\"",
            "        self.discovery_schema = None",
            "        self._user_input = None",
            "        self._sessions: list[aiohttp.ClientSession] = []",
            "",
            "    async def async_step_user(self, user_input=None):",
            "        \"\"\"Handle the initial step.\"\"\"",
            "        # When coming back from the progress steps, the user_input is stored in the",
            "        # instance variable instead of being passed in",
            "        if user_input is None and self._user_input:",
            "            user_input = self._user_input",
            "",
            "        if user_input is None:",
            "            data = self.discovery_schema or _schema_with_defaults()",
            "            return self.async_show_form(step_id=\"user\", data_schema=data)",
            "",
            "        if CONF_API_KEY in user_input:",
            "            errors = {}",
            "            try:",
            "                return await self._finish_config(user_input)",
            "            except data_entry_flow.AbortFlow as err:",
            "                raise err from None",
            "            except CannotConnect:",
            "                errors[\"base\"] = \"cannot_connect\"",
            "            except Exception:  # pylint: disable=broad-except",
            "                errors[\"base\"] = \"unknown\"",
            "",
            "            if errors:",
            "                return self.async_show_form(",
            "                    step_id=\"user\",",
            "                    errors=errors,",
            "                    data_schema=_schema_with_defaults(",
            "                        user_input.get(CONF_USERNAME),",
            "                        user_input[CONF_HOST],",
            "                        user_input[CONF_PORT],",
            "                        user_input[CONF_PATH],",
            "                        user_input[CONF_SSL],",
            "                        user_input[CONF_VERIFY_SSL],",
            "                    ),",
            "                )",
            "",
            "        self.api_key_task = None",
            "        return await self.async_step_get_api_key(user_input)",
            "",
            "    async def async_step_get_api_key(self, user_input):",
            "        \"\"\"Get an Application Api Key.\"\"\"",
            "        if not self.api_key_task:",
            "            self.api_key_task = self.hass.async_create_task(",
            "                self._async_get_auth_key(user_input)",
            "            )",
            "            return self.async_show_progress(",
            "                step_id=\"get_api_key\", progress_action=\"get_api_key\"",
            "            )",
            "",
            "        try:",
            "            await self.api_key_task",
            "        except OctoprintException as err:",
            "            _LOGGER.exception(\"Failed to get an application key: %s\", err)",
            "            return self.async_show_progress_done(next_step_id=\"auth_failed\")",
            "        except Exception as err:  # pylint: disable=broad-except",
            "            _LOGGER.exception(\"Failed to get an application key : %s\", err)",
            "            return self.async_show_progress_done(next_step_id=\"auth_failed\")",
            "",
            "        # store this off here to pick back up in the user step",
            "        self._user_input = user_input",
            "        return self.async_show_progress_done(next_step_id=\"user\")",
            "",
            "    async def _finish_config(self, user_input: dict):",
            "        \"\"\"Finish the configuration setup.\"\"\"",
            "        existing_entry = await self.async_set_unique_id(self.unique_id)",
            "        if existing_entry is not None:",
            "            self.hass.config_entries.async_update_entry(existing_entry, data=user_input)",
            "            # Reload the config entry otherwise devices will remain unavailable",
            "            self.hass.async_create_task(",
            "                self.hass.config_entries.async_reload(existing_entry.entry_id)",
            "            )",
            "",
            "            return self.async_abort(reason=\"reauth_successful\")",
            "",
            "        octoprint = self._get_octoprint_client(user_input)",
            "        octoprint.set_api_key(user_input[CONF_API_KEY])",
            "",
            "        try:",
            "            discovery = await octoprint.get_discovery_info()",
            "        except ApiError as err:",
            "            _LOGGER.error(\"Failed to connect to printer\")",
            "            raise CannotConnect from err",
            "",
            "        await self.async_set_unique_id(discovery.upnp_uuid, raise_on_progress=False)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        return self.async_create_entry(title=user_input[CONF_HOST], data=user_input)",
            "",
            "    async def async_step_auth_failed(self, user_input):",
            "        \"\"\"Handle api fetch failure.\"\"\"",
            "        return self.async_abort(reason=\"auth_failed\")",
            "",
            "    async def async_step_import(self, user_input):",
            "        \"\"\"Handle import.\"\"\"",
            "        return await self.async_step_user(user_input)",
            "",
            "    async def async_step_zeroconf(",
            "        self, discovery_info: zeroconf.ZeroconfServiceInfo",
            "    ) -> data_entry_flow.FlowResult:",
            "        \"\"\"Handle discovery flow.\"\"\"",
            "        uuid = discovery_info.properties[\"uuid\"]",
            "        await self.async_set_unique_id(uuid)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: discovery_info.host},",
            "                \"configuration_url\": (",
            "                    f\"http://{discovery_info.host}:{discovery_info.port}\"",
            "                    f\"{discovery_info.properties[CONF_PATH]}\"",
            "                ),",
            "            }",
            "        )",
            "",
            "        self.discovery_schema = _schema_with_defaults(",
            "            host=discovery_info.host,",
            "            port=discovery_info.port,",
            "            path=discovery_info.properties[CONF_PATH],",
            "        )",
            "",
            "        return await self.async_step_user()",
            "",
            "    async def async_step_ssdp(",
            "        self, discovery_info: ssdp.SsdpServiceInfo",
            "    ) -> data_entry_flow.FlowResult:",
            "        \"\"\"Handle ssdp discovery flow.\"\"\"",
            "        uuid = discovery_info.upnp[\"UDN\"][5:]",
            "        await self.async_set_unique_id(uuid)",
            "        self._abort_if_unique_id_configured()",
            "",
            "        url = URL(discovery_info.upnp[\"presentationURL\"])",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: url.host},",
            "                \"configuration_url\": discovery_info.upnp[\"presentationURL\"],",
            "            }",
            "        )",
            "",
            "        self.discovery_schema = _schema_with_defaults(",
            "            host=url.host,",
            "            path=url.path,",
            "            port=url.port,",
            "            ssl=url.scheme == \"https\",",
            "        )",
            "",
            "        return await self.async_step_user()",
            "",
            "    async def async_step_reauth(self, config: Mapping[str, Any]) -> FlowResult:",
            "        \"\"\"Handle reauthorization request from Octoprint.\"\"\"",
            "        self._reauth_data = dict(config)",
            "",
            "        self.context.update(",
            "            {",
            "                \"title_placeholders\": {CONF_HOST: config[CONF_HOST]},",
            "            }",
            "        )",
            "",
            "        return await self.async_step_reauth_confirm()",
            "",
            "    async def async_step_reauth_confirm(",
            "        self, user_input: dict[str, Any] | None = None",
            "    ) -> FlowResult:",
            "        \"\"\"Handle reauthorization flow.\"\"\"",
            "        assert self._reauth_data is not None",
            "",
            "        if user_input is None:",
            "            return self.async_show_form(",
            "                step_id=\"reauth_confirm\",",
            "                data_schema=vol.Schema(",
            "                    {",
            "                        vol.Required(",
            "                            CONF_USERNAME, default=self._reauth_data[CONF_USERNAME]",
            "                        ): str,",
            "                    }",
            "                ),",
            "            )",
            "",
            "        self.api_key_task = None",
            "        self._reauth_data[CONF_USERNAME] = user_input[CONF_USERNAME]",
            "",
            "        return await self.async_step_get_api_key(self._reauth_data)",
            "",
            "    async def _async_get_auth_key(self, user_input: dict):",
            "        \"\"\"Get application api key.\"\"\"",
            "        octoprint = self._get_octoprint_client(user_input)",
            "",
            "        try:",
            "            user_input[CONF_API_KEY] = await octoprint.request_app_key(",
            "                \"Home Assistant\", user_input[CONF_USERNAME], 300",
            "            )",
            "        finally:",
            "            # Continue the flow after show progress when the task is done.",
            "            self.hass.async_create_task(",
            "                self.hass.config_entries.flow.async_configure(",
            "                    flow_id=self.flow_id, user_input=user_input",
            "                )",
            "            )",
            "",
            "    def _get_octoprint_client(self, user_input: dict) -> OctoprintClient:",
            "        \"\"\"Build an octoprint client from the user_input.\"\"\"",
            "        verify_ssl = user_input.get(CONF_VERIFY_SSL, True)",
            "",
            "        connector = aiohttp.TCPConnector(",
            "            force_close=True,",
            "            ssl=get_default_no_verify_context()",
            "            if not verify_ssl",
            "            else get_default_context(),",
            "        )",
            "        session = aiohttp.ClientSession(connector=connector)",
            "        self._sessions.append(session)",
            "",
            "        return OctoprintClient(",
            "            host=user_input[CONF_HOST],",
            "            session=session,",
            "            port=user_input[CONF_PORT],",
            "            ssl=user_input[CONF_SSL],",
            "            path=user_input[CONF_PATH],",
            "        )",
            "",
            "    def async_remove(self):",
            "        \"\"\"Detach the session.\"\"\"",
            "        for session in self._sessions:",
            "            session.detach()",
            "",
            "",
            "class CannotConnect(exceptions.HomeAssistantError):",
            "    \"\"\"Error to indicate we cannot connect.\"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "267": [
                "ConfigFlow",
                "_get_octoprint_client"
            ]
        },
        "addLocation": []
    }
}