{
    "src/cryptography/hazmat/primitives/serialization/ssh.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 738,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "         _serial: int,"
            },
            "1": {
                "beforePatchRowNumber": 739,
                "afterPatchRowNumber": 739,
                "PatchRowcode": "         _cctype: int,"
            },
            "2": {
                "beforePatchRowNumber": 740,
                "afterPatchRowNumber": 740,
                "PatchRowcode": "         _key_id: memoryview,"
            },
            "3": {
                "beforePatchRowNumber": 741,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _valid_principals: memoryview,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 741,
                "PatchRowcode": "+        _valid_principals: typing.List[bytes],"
            },
            "5": {
                "beforePatchRowNumber": 742,
                "afterPatchRowNumber": 742,
                "PatchRowcode": "         _valid_after: int,"
            },
            "6": {
                "beforePatchRowNumber": 743,
                "afterPatchRowNumber": 743,
                "PatchRowcode": "         _valid_before: int,"
            },
            "7": {
                "beforePatchRowNumber": 744,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _critical_options: memoryview,"
            },
            "8": {
                "beforePatchRowNumber": 745,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _extensions: memoryview,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 744,
                "PatchRowcode": "+        _critical_options: typing.Dict[bytes, bytes],"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 745,
                "PatchRowcode": "+        _extensions: typing.Dict[bytes, bytes],"
            },
            "11": {
                "beforePatchRowNumber": 746,
                "afterPatchRowNumber": 746,
                "PatchRowcode": "         _sig_type: memoryview,"
            },
            "12": {
                "beforePatchRowNumber": 747,
                "afterPatchRowNumber": 747,
                "PatchRowcode": "         _sig_key: memoryview,"
            },
            "13": {
                "beforePatchRowNumber": 748,
                "afterPatchRowNumber": 748,
                "PatchRowcode": "         _inner_sig_type: memoryview,"
            },
            "14": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": 794,
                "PatchRowcode": "     def key_id(self) -> bytes:"
            },
            "15": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": 795,
                "PatchRowcode": "         return bytes(self._key_id)"
            },
            "16": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": 796,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @utils.cached_property"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 797,
                "PatchRowcode": "+    @property"
            },
            "19": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 798,
                "PatchRowcode": "     def valid_principals(self) -> typing.List[bytes]:"
            },
            "20": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rest = self._valid_principals"
            },
            "21": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        principals = []"
            },
            "22": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        while rest:"
            },
            "23": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            principal, rest = _get_sshstr(rest)"
            },
            "24": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            principals.append(bytes(principal))"
            },
            "25": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 805,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return principals"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 799,
                "PatchRowcode": "+        return self._valid_principals"
            },
            "28": {
                "beforePatchRowNumber": 806,
                "afterPatchRowNumber": 800,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 807,
                "afterPatchRowNumber": 801,
                "PatchRowcode": "     @property"
            },
            "30": {
                "beforePatchRowNumber": 808,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "     def valid_before(self) -> datetime.datetime:"
            },
            "31": {
                "beforePatchRowNumber": 812,
                "afterPatchRowNumber": 806,
                "PatchRowcode": "     def valid_after(self) -> datetime.datetime:"
            },
            "32": {
                "beforePatchRowNumber": 813,
                "afterPatchRowNumber": 807,
                "PatchRowcode": "         return self._valid_after"
            },
            "33": {
                "beforePatchRowNumber": 814,
                "afterPatchRowNumber": 808,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @utils.cached_property"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 809,
                "PatchRowcode": "+    @property"
            },
            "36": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 810,
                "PatchRowcode": "     def critical_options(self) -> typing.Dict[bytes, bytes]:"
            },
            "37": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self._parse_exts_opts(self._critical_options)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 811,
                "PatchRowcode": "+        return self._critical_options"
            },
            "39": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": 812,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @utils.cached_property"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+    @property"
            },
            "42": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 814,
                "PatchRowcode": "     def extensions(self) -> typing.Dict[bytes, bytes]:"
            },
            "43": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self._parse_exts_opts(self._extensions)"
            },
            "44": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "45": {
                "beforePatchRowNumber": 823,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _parse_exts_opts("
            },
            "46": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, exts_opts: memoryview"
            },
            "47": {
                "beforePatchRowNumber": 825,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ) -> typing.Dict[bytes, bytes]:"
            },
            "48": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        result: typing.Dict[bytes, bytes] = {}"
            },
            "49": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        last_name = None"
            },
            "50": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        while exts_opts:"
            },
            "51": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            name, exts_opts = _get_sshstr(exts_opts)"
            },
            "52": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            bname: bytes = bytes(name)"
            },
            "53": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if bname in result:"
            },
            "54": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise ValueError(\"Duplicate extension name\")"
            },
            "55": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # dicts in pypy & python 3.6+ are insertion ordered so hooray"
            },
            "56": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if last_name is not None and bname < last_name:"
            },
            "57": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise ValueError(\"Extensions not lexically sorted\")"
            },
            "58": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value, exts_opts = _get_sshstr(exts_opts)"
            },
            "59": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result[bname] = bytes(value)"
            },
            "60": {
                "beforePatchRowNumber": 838,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            last_name = bname"
            },
            "61": {
                "beforePatchRowNumber": 839,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return result"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 815,
                "PatchRowcode": "+        return self._extensions"
            },
            "63": {
                "beforePatchRowNumber": 840,
                "afterPatchRowNumber": 816,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 841,
                "afterPatchRowNumber": 817,
                "PatchRowcode": "     def signature_key(self) -> _SSH_CERT_PUBLIC_KEY_TYPES:"
            },
            "65": {
                "beforePatchRowNumber": 842,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "         sigformat = _lookup_kformat(self._sig_type)"
            },
            "66": {
                "beforePatchRowNumber": 896,
                "afterPatchRowNumber": 872,
                "PatchRowcode": "     return hash_alg"
            },
            "67": {
                "beforePatchRowNumber": 897,
                "afterPatchRowNumber": 873,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 898,
                "afterPatchRowNumber": 874,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 899,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def load_ssh_certificate(data: bytes) -> SSHCertificate:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+def load_ssh_public_identity("
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+    data: bytes,"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+) -> typing.Union[SSHCertificate, _SSH_PUBLIC_KEY_TYPES]:"
            },
            "73": {
                "beforePatchRowNumber": 900,
                "afterPatchRowNumber": 878,
                "PatchRowcode": "     utils._check_byteslike(\"data\", data)"
            },
            "74": {
                "beforePatchRowNumber": 901,
                "afterPatchRowNumber": 879,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 902,
                "afterPatchRowNumber": 880,
                "PatchRowcode": "     m = _SSH_PUBKEY_RC.match(data)"
            },
            "76": {
                "beforePatchRowNumber": 903,
                "afterPatchRowNumber": 881,
                "PatchRowcode": "     if not m:"
            },
            "77": {
                "beforePatchRowNumber": 904,
                "afterPatchRowNumber": 882,
                "PatchRowcode": "         raise ValueError(\"Invalid line format\")"
            },
            "78": {
                "beforePatchRowNumber": 905,
                "afterPatchRowNumber": 883,
                "PatchRowcode": "     key_type = orig_key_type = m.group(1)"
            },
            "79": {
                "beforePatchRowNumber": 906,
                "afterPatchRowNumber": 884,
                "PatchRowcode": "     key_body = m.group(2)"
            },
            "80": {
                "beforePatchRowNumber": 907,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if _CERT_SUFFIX != key_type[-len(_CERT_SUFFIX) :]:"
            },
            "81": {
                "beforePatchRowNumber": 908,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise ValueError(\"Not an SSH certificate\")"
            },
            "82": {
                "beforePatchRowNumber": 909,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+    with_cert = False"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 886,
                "PatchRowcode": "+    if key_type.endswith(_CERT_SUFFIX):"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+        with_cert = True"
            },
            "86": {
                "beforePatchRowNumber": 910,
                "afterPatchRowNumber": 888,
                "PatchRowcode": "         key_type = key_type[: -len(_CERT_SUFFIX)]"
            },
            "87": {
                "beforePatchRowNumber": 911,
                "afterPatchRowNumber": 889,
                "PatchRowcode": "     if key_type == _SSH_DSA:"
            },
            "88": {
                "beforePatchRowNumber": 912,
                "afterPatchRowNumber": 890,
                "PatchRowcode": "         raise UnsupportedAlgorithm("
            },
            "89": {
                "beforePatchRowNumber": 919,
                "afterPatchRowNumber": 897,
                "PatchRowcode": "     except (TypeError, binascii.Error):"
            },
            "90": {
                "beforePatchRowNumber": 920,
                "afterPatchRowNumber": 898,
                "PatchRowcode": "         raise ValueError(\"Invalid format\")"
            },
            "91": {
                "beforePatchRowNumber": 921,
                "afterPatchRowNumber": 899,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 922,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    cert_body = rest"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 900,
                "PatchRowcode": "+    if with_cert:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 901,
                "PatchRowcode": "+        cert_body = rest"
            },
            "95": {
                "beforePatchRowNumber": 923,
                "afterPatchRowNumber": 902,
                "PatchRowcode": "     inner_key_type, rest = _get_sshstr(rest)"
            },
            "96": {
                "beforePatchRowNumber": 924,
                "afterPatchRowNumber": 903,
                "PatchRowcode": "     if inner_key_type != orig_key_type:"
            },
            "97": {
                "beforePatchRowNumber": 925,
                "afterPatchRowNumber": 904,
                "PatchRowcode": "         raise ValueError(\"Invalid key format\")"
            },
            "98": {
                "beforePatchRowNumber": 926,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    nonce, rest = _get_sshstr(rest)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 905,
                "PatchRowcode": "+    if with_cert:"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 906,
                "PatchRowcode": "+        nonce, rest = _get_sshstr(rest)"
            },
            "101": {
                "beforePatchRowNumber": 927,
                "afterPatchRowNumber": 907,
                "PatchRowcode": "     public_key, rest = kformat.load_public(rest)"
            },
            "102": {
                "beforePatchRowNumber": 928,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    serial, rest = _get_u64(rest)"
            },
            "103": {
                "beforePatchRowNumber": 929,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    cctype, rest = _get_u32(rest)"
            },
            "104": {
                "beforePatchRowNumber": 930,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    key_id, rest = _get_sshstr(rest)"
            },
            "105": {
                "beforePatchRowNumber": 931,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    principals, rest = _get_sshstr(rest)"
            },
            "106": {
                "beforePatchRowNumber": 932,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    valid_after, rest = _get_u64(rest)"
            },
            "107": {
                "beforePatchRowNumber": 933,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    valid_before, rest = _get_u64(rest)"
            },
            "108": {
                "beforePatchRowNumber": 934,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    crit_options, rest = _get_sshstr(rest)"
            },
            "109": {
                "beforePatchRowNumber": 935,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    extensions, rest = _get_sshstr(rest)"
            },
            "110": {
                "beforePatchRowNumber": 936,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Get the reserved field, which is unused."
            },
            "111": {
                "beforePatchRowNumber": 937,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _, rest = _get_sshstr(rest)"
            },
            "112": {
                "beforePatchRowNumber": 938,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    sig_key_raw, rest = _get_sshstr(rest)"
            },
            "113": {
                "beforePatchRowNumber": 939,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    sig_type, sig_key = _get_sshstr(sig_key_raw)"
            },
            "114": {
                "beforePatchRowNumber": 940,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if sig_type == _SSH_DSA:"
            },
            "115": {
                "beforePatchRowNumber": 941,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise UnsupportedAlgorithm("
            },
            "116": {
                "beforePatchRowNumber": 942,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"DSA signatures aren't supported in SSH certificates\""
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 908,
                "PatchRowcode": "+    if with_cert:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 909,
                "PatchRowcode": "+        serial, rest = _get_u64(rest)"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 910,
                "PatchRowcode": "+        cctype, rest = _get_u32(rest)"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+        key_id, rest = _get_sshstr(rest)"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 912,
                "PatchRowcode": "+        principals, rest = _get_sshstr(rest)"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 913,
                "PatchRowcode": "+        valid_principals = []"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 914,
                "PatchRowcode": "+        while principals:"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 915,
                "PatchRowcode": "+            principal, principals = _get_sshstr(principals)"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 916,
                "PatchRowcode": "+            valid_principals.append(bytes(principal))"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 917,
                "PatchRowcode": "+        valid_after, rest = _get_u64(rest)"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 918,
                "PatchRowcode": "+        valid_before, rest = _get_u64(rest)"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 919,
                "PatchRowcode": "+        crit_options, rest = _get_sshstr(rest)"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 920,
                "PatchRowcode": "+        critical_options = _parse_exts_opts(crit_options)"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 921,
                "PatchRowcode": "+        exts, rest = _get_sshstr(rest)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 922,
                "PatchRowcode": "+        extensions = _parse_exts_opts(exts)"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 923,
                "PatchRowcode": "+        # Get the reserved field, which is unused."
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 924,
                "PatchRowcode": "+        _, rest = _get_sshstr(rest)"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 925,
                "PatchRowcode": "+        sig_key_raw, rest = _get_sshstr(rest)"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 926,
                "PatchRowcode": "+        sig_type, sig_key = _get_sshstr(sig_key_raw)"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 927,
                "PatchRowcode": "+        if sig_type == _SSH_DSA:"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 928,
                "PatchRowcode": "+            raise UnsupportedAlgorithm("
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 929,
                "PatchRowcode": "+                \"DSA signatures aren't supported in SSH certificates\""
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 930,
                "PatchRowcode": "+            )"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 931,
                "PatchRowcode": "+        # Get the entire cert body and subtract the signature"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 932,
                "PatchRowcode": "+        tbs_cert_body = cert_body[: -len(rest)]"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 933,
                "PatchRowcode": "+        signature_raw, rest = _get_sshstr(rest)"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 934,
                "PatchRowcode": "+        _check_empty(rest)"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 935,
                "PatchRowcode": "+        inner_sig_type, sig_rest = _get_sshstr(signature_raw)"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 936,
                "PatchRowcode": "+        # RSA certs can have multiple algorithm types"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 937,
                "PatchRowcode": "+        if ("
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 938,
                "PatchRowcode": "+            sig_type == _SSH_RSA"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 939,
                "PatchRowcode": "+            and inner_sig_type"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 940,
                "PatchRowcode": "+            not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 941,
                "PatchRowcode": "+        ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 942,
                "PatchRowcode": "+            raise ValueError(\"Signature key type does not match\")"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 943,
                "PatchRowcode": "+        signature, sig_rest = _get_sshstr(sig_rest)"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 944,
                "PatchRowcode": "+        _check_empty(sig_rest)"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 945,
                "PatchRowcode": "+        return SSHCertificate("
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 946,
                "PatchRowcode": "+            nonce,"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 947,
                "PatchRowcode": "+            public_key,"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 948,
                "PatchRowcode": "+            serial,"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 949,
                "PatchRowcode": "+            cctype,"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 950,
                "PatchRowcode": "+            key_id,"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 951,
                "PatchRowcode": "+            valid_principals,"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 952,
                "PatchRowcode": "+            valid_after,"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 953,
                "PatchRowcode": "+            valid_before,"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 954,
                "PatchRowcode": "+            critical_options,"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 955,
                "PatchRowcode": "+            extensions,"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 956,
                "PatchRowcode": "+            sig_type,"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 957,
                "PatchRowcode": "+            sig_key,"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 958,
                "PatchRowcode": "+            inner_sig_type,"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 959,
                "PatchRowcode": "+            signature,"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 960,
                "PatchRowcode": "+            tbs_cert_body,"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 961,
                "PatchRowcode": "+            orig_key_type,"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 962,
                "PatchRowcode": "+            cert_body,"
            },
            "172": {
                "beforePatchRowNumber": 943,
                "afterPatchRowNumber": 963,
                "PatchRowcode": "         )"
            },
            "173": {
                "beforePatchRowNumber": 944,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Get the entire cert body and subtract the signature"
            },
            "174": {
                "beforePatchRowNumber": 945,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    tbs_cert_body = cert_body[: -len(rest)]"
            },
            "175": {
                "beforePatchRowNumber": 946,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    signature_raw, rest = _get_sshstr(rest)"
            },
            "176": {
                "beforePatchRowNumber": 947,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _check_empty(rest)"
            },
            "177": {
                "beforePatchRowNumber": 948,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    inner_sig_type, sig_rest = _get_sshstr(signature_raw)"
            },
            "178": {
                "beforePatchRowNumber": 949,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # RSA certs can have multiple algorithm types"
            },
            "179": {
                "beforePatchRowNumber": 950,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if ("
            },
            "180": {
                "beforePatchRowNumber": 951,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sig_type == _SSH_RSA"
            },
            "181": {
                "beforePatchRowNumber": 952,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        and inner_sig_type not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]"
            },
            "182": {
                "beforePatchRowNumber": 953,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):"
            },
            "183": {
                "beforePatchRowNumber": 954,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise ValueError(\"Signature key type does not match\")"
            },
            "184": {
                "beforePatchRowNumber": 955,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    signature, sig_rest = _get_sshstr(sig_rest)"
            },
            "185": {
                "beforePatchRowNumber": 956,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _check_empty(sig_rest)"
            },
            "186": {
                "beforePatchRowNumber": 957,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return SSHCertificate("
            },
            "187": {
                "beforePatchRowNumber": 958,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        nonce,"
            },
            "188": {
                "beforePatchRowNumber": 959,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        public_key,"
            },
            "189": {
                "beforePatchRowNumber": 960,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        serial,"
            },
            "190": {
                "beforePatchRowNumber": 961,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cctype,"
            },
            "191": {
                "beforePatchRowNumber": 962,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        key_id,"
            },
            "192": {
                "beforePatchRowNumber": 963,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        principals,"
            },
            "193": {
                "beforePatchRowNumber": 964,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        valid_after,"
            },
            "194": {
                "beforePatchRowNumber": 965,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        valid_before,"
            },
            "195": {
                "beforePatchRowNumber": 966,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        crit_options,"
            },
            "196": {
                "beforePatchRowNumber": 967,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        extensions,"
            },
            "197": {
                "beforePatchRowNumber": 968,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sig_type,"
            },
            "198": {
                "beforePatchRowNumber": 969,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sig_key,"
            },
            "199": {
                "beforePatchRowNumber": 970,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inner_sig_type,"
            },
            "200": {
                "beforePatchRowNumber": 971,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        signature,"
            },
            "201": {
                "beforePatchRowNumber": 972,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        tbs_cert_body,"
            },
            "202": {
                "beforePatchRowNumber": 973,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        orig_key_type,"
            },
            "203": {
                "beforePatchRowNumber": 974,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cert_body,"
            },
            "204": {
                "beforePatchRowNumber": 975,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 964,
                "PatchRowcode": "+    else:"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 965,
                "PatchRowcode": "+        _check_empty(rest)"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 966,
                "PatchRowcode": "+        return public_key"
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 967,
                "PatchRowcode": "+"
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 968,
                "PatchRowcode": "+"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 969,
                "PatchRowcode": "+def _parse_exts_opts(exts_opts: memoryview) -> typing.Dict[bytes, bytes]:"
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 970,
                "PatchRowcode": "+    result: typing.Dict[bytes, bytes] = {}"
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 971,
                "PatchRowcode": "+    last_name = None"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 972,
                "PatchRowcode": "+    while exts_opts:"
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 973,
                "PatchRowcode": "+        name, exts_opts = _get_sshstr(exts_opts)"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 974,
                "PatchRowcode": "+        bname: bytes = bytes(name)"
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 975,
                "PatchRowcode": "+        if bname in result:"
            },
            "217": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 976,
                "PatchRowcode": "+            raise ValueError(\"Duplicate name\")"
            },
            "218": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 977,
                "PatchRowcode": "+        if last_name is not None and bname < last_name:"
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 978,
                "PatchRowcode": "+            raise ValueError(\"Fields not lexically sorted\")"
            },
            "220": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 979,
                "PatchRowcode": "+        value, exts_opts = _get_sshstr(exts_opts)"
            },
            "221": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 980,
                "PatchRowcode": "+        result[bname] = bytes(value)"
            },
            "222": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 981,
                "PatchRowcode": "+        last_name = bname"
            },
            "223": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 982,
                "PatchRowcode": "+    return result"
            },
            "224": {
                "beforePatchRowNumber": 976,
                "afterPatchRowNumber": 983,
                "PatchRowcode": " "
            },
            "225": {
                "beforePatchRowNumber": 977,
                "afterPatchRowNumber": 984,
                "PatchRowcode": " "
            },
            "226": {
                "beforePatchRowNumber": 978,
                "afterPatchRowNumber": 985,
                "PatchRowcode": " def load_ssh_public_key("
            }
        },
        "frontPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "",
            "import binascii",
            "import datetime",
            "import enum",
            "import os",
            "import re",
            "import typing",
            "from base64 import encodebytes as _base64_encode",
            "",
            "from cryptography import utils",
            "from cryptography.exceptions import UnsupportedAlgorithm",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import (",
            "    dsa,",
            "    ec,",
            "    ed25519,",
            "    padding,",
            "    rsa,",
            ")",
            "from cryptography.hazmat.primitives.asymmetric import utils as asym_utils",
            "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes",
            "from cryptography.hazmat.primitives.serialization import (",
            "    Encoding,",
            "    KeySerializationEncryption,",
            "    NoEncryption,",
            "    PrivateFormat,",
            "    PublicFormat,",
            "    _KeySerializationEncryption,",
            ")",
            "",
            "try:",
            "    from bcrypt import kdf as _bcrypt_kdf",
            "",
            "    _bcrypt_supported = True",
            "except ImportError:",
            "    _bcrypt_supported = False",
            "",
            "    def _bcrypt_kdf(",
            "        password: bytes,",
            "        salt: bytes,",
            "        desired_key_bytes: int,",
            "        rounds: int,",
            "        ignore_few_rounds: bool = False,",
            "    ) -> bytes:",
            "        raise UnsupportedAlgorithm(\"Need bcrypt module\")",
            "",
            "",
            "_SSH_ED25519 = b\"ssh-ed25519\"",
            "_SSH_RSA = b\"ssh-rsa\"",
            "_SSH_DSA = b\"ssh-dss\"",
            "_ECDSA_NISTP256 = b\"ecdsa-sha2-nistp256\"",
            "_ECDSA_NISTP384 = b\"ecdsa-sha2-nistp384\"",
            "_ECDSA_NISTP521 = b\"ecdsa-sha2-nistp521\"",
            "_CERT_SUFFIX = b\"-cert-v01@openssh.com\"",
            "",
            "# These are not key types, only algorithms, so they cannot appear",
            "# as a public key type",
            "_SSH_RSA_SHA256 = b\"rsa-sha2-256\"",
            "_SSH_RSA_SHA512 = b\"rsa-sha2-512\"",
            "",
            "_SSH_PUBKEY_RC = re.compile(rb\"\\A(\\S+)[ \\t]+(\\S+)\")",
            "_SK_MAGIC = b\"openssh-key-v1\\0\"",
            "_SK_START = b\"-----BEGIN OPENSSH PRIVATE KEY-----\"",
            "_SK_END = b\"-----END OPENSSH PRIVATE KEY-----\"",
            "_BCRYPT = b\"bcrypt\"",
            "_NONE = b\"none\"",
            "_DEFAULT_CIPHER = b\"aes256-ctr\"",
            "_DEFAULT_ROUNDS = 16",
            "",
            "# re is only way to work on bytes-like data",
            "_PEM_RC = re.compile(_SK_START + b\"(.*?)\" + _SK_END, re.DOTALL)",
            "",
            "# padding for max blocksize",
            "_PADDING = memoryview(bytearray(range(1, 1 + 16)))",
            "",
            "# ciphers that are actually used in key wrapping",
            "_SSH_CIPHERS: typing.Dict[",
            "    bytes,",
            "    typing.Tuple[",
            "        typing.Type[algorithms.AES],",
            "        int,",
            "        typing.Union[typing.Type[modes.CTR], typing.Type[modes.CBC]],",
            "        int,",
            "    ],",
            "] = {",
            "    b\"aes256-ctr\": (algorithms.AES, 32, modes.CTR, 16),",
            "    b\"aes256-cbc\": (algorithms.AES, 32, modes.CBC, 16),",
            "}",
            "",
            "# map local curve name to key type",
            "_ECDSA_KEY_TYPE = {",
            "    \"secp256r1\": _ECDSA_NISTP256,",
            "    \"secp384r1\": _ECDSA_NISTP384,",
            "    \"secp521r1\": _ECDSA_NISTP521,",
            "}",
            "",
            "",
            "def _get_ssh_key_type(",
            "    key: typing.Union[\"_SSH_PRIVATE_KEY_TYPES\", \"_SSH_PUBLIC_KEY_TYPES\"]",
            ") -> bytes:",
            "    if isinstance(key, ec.EllipticCurvePrivateKey):",
            "        key_type = _ecdsa_key_type(key.public_key())",
            "    elif isinstance(key, ec.EllipticCurvePublicKey):",
            "        key_type = _ecdsa_key_type(key)",
            "    elif isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):",
            "        key_type = _SSH_RSA",
            "    elif isinstance(key, (dsa.DSAPrivateKey, dsa.DSAPublicKey)):",
            "        key_type = _SSH_DSA",
            "    elif isinstance(",
            "        key, (ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey)",
            "    ):",
            "        key_type = _SSH_ED25519",
            "    else:",
            "        raise ValueError(\"Unsupported key type\")",
            "",
            "    return key_type",
            "",
            "",
            "def _ecdsa_key_type(public_key: ec.EllipticCurvePublicKey) -> bytes:",
            "    \"\"\"Return SSH key_type and curve_name for private key.\"\"\"",
            "    curve = public_key.curve",
            "    if curve.name not in _ECDSA_KEY_TYPE:",
            "        raise ValueError(",
            "            f\"Unsupported curve for ssh private key: {curve.name!r}\"",
            "        )",
            "    return _ECDSA_KEY_TYPE[curve.name]",
            "",
            "",
            "def _ssh_pem_encode(",
            "    data: bytes,",
            "    prefix: bytes = _SK_START + b\"\\n\",",
            "    suffix: bytes = _SK_END + b\"\\n\",",
            ") -> bytes:",
            "    return b\"\".join([prefix, _base64_encode(data), suffix])",
            "",
            "",
            "def _check_block_size(data: bytes, block_len: int) -> None:",
            "    \"\"\"Require data to be full blocks\"\"\"",
            "    if not data or len(data) % block_len != 0:",
            "        raise ValueError(\"Corrupt data: missing padding\")",
            "",
            "",
            "def _check_empty(data: bytes) -> None:",
            "    \"\"\"All data should have been parsed.\"\"\"",
            "    if data:",
            "        raise ValueError(\"Corrupt data: unparsed data\")",
            "",
            "",
            "def _init_cipher(",
            "    ciphername: bytes,",
            "    password: typing.Optional[bytes],",
            "    salt: bytes,",
            "    rounds: int,",
            ") -> Cipher[typing.Union[modes.CBC, modes.CTR]]:",
            "    \"\"\"Generate key + iv and return cipher.\"\"\"",
            "    if not password:",
            "        raise ValueError(\"Key is password-protected.\")",
            "",
            "    algo, key_len, mode, iv_len = _SSH_CIPHERS[ciphername]",
            "    seed = _bcrypt_kdf(password, salt, key_len + iv_len, rounds, True)",
            "    return Cipher(algo(seed[:key_len]), mode(seed[key_len:]))",
            "",
            "",
            "def _get_u32(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Uint32\"\"\"",
            "    if len(data) < 4:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(data[:4], byteorder=\"big\"), data[4:]",
            "",
            "",
            "def _get_u64(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Uint64\"\"\"",
            "    if len(data) < 8:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(data[:8], byteorder=\"big\"), data[8:]",
            "",
            "",
            "def _get_sshstr(data: memoryview) -> typing.Tuple[memoryview, memoryview]:",
            "    \"\"\"Bytes with u32 length prefix\"\"\"",
            "    n, data = _get_u32(data)",
            "    if n > len(data):",
            "        raise ValueError(\"Invalid data\")",
            "    return data[:n], data[n:]",
            "",
            "",
            "def _get_mpint(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Big integer.\"\"\"",
            "    val, data = _get_sshstr(data)",
            "    if val and val[0] > 0x7F:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(val, \"big\"), data",
            "",
            "",
            "def _to_mpint(val: int) -> bytes:",
            "    \"\"\"Storage format for signed bigint.\"\"\"",
            "    if val < 0:",
            "        raise ValueError(\"negative mpint not allowed\")",
            "    if not val:",
            "        return b\"\"",
            "    nbytes = (val.bit_length() + 8) // 8",
            "    return utils.int_to_bytes(val, nbytes)",
            "",
            "",
            "class _FragList:",
            "    \"\"\"Build recursive structure without data copy.\"\"\"",
            "",
            "    flist: typing.List[bytes]",
            "",
            "    def __init__(",
            "        self, init: typing.Optional[typing.List[bytes]] = None",
            "    ) -> None:",
            "        self.flist = []",
            "        if init:",
            "            self.flist.extend(init)",
            "",
            "    def put_raw(self, val: bytes) -> None:",
            "        \"\"\"Add plain bytes\"\"\"",
            "        self.flist.append(val)",
            "",
            "    def put_u32(self, val: int) -> None:",
            "        \"\"\"Big-endian uint32\"\"\"",
            "        self.flist.append(val.to_bytes(length=4, byteorder=\"big\"))",
            "",
            "    def put_sshstr(self, val: typing.Union[bytes, \"_FragList\"]) -> None:",
            "        \"\"\"Bytes prefixed with u32 length\"\"\"",
            "        if isinstance(val, (bytes, memoryview, bytearray)):",
            "            self.put_u32(len(val))",
            "            self.flist.append(val)",
            "        else:",
            "            self.put_u32(val.size())",
            "            self.flist.extend(val.flist)",
            "",
            "    def put_mpint(self, val: int) -> None:",
            "        \"\"\"Big-endian bigint prefixed with u32 length\"\"\"",
            "        self.put_sshstr(_to_mpint(val))",
            "",
            "    def size(self) -> int:",
            "        \"\"\"Current number of bytes\"\"\"",
            "        return sum(map(len, self.flist))",
            "",
            "    def render(self, dstbuf: memoryview, pos: int = 0) -> int:",
            "        \"\"\"Write into bytearray\"\"\"",
            "        for frag in self.flist:",
            "            flen = len(frag)",
            "            start, pos = pos, pos + flen",
            "            dstbuf[start:pos] = frag",
            "        return pos",
            "",
            "    def tobytes(self) -> bytes:",
            "        \"\"\"Return as bytes\"\"\"",
            "        buf = memoryview(bytearray(self.size()))",
            "        self.render(buf)",
            "        return buf.tobytes()",
            "",
            "",
            "class _SSHFormatRSA:",
            "    \"\"\"Format for RSA keys.",
            "",
            "    Public:",
            "        mpint e, n",
            "    Private:",
            "        mpint n, e, d, iqmp, p, q",
            "    \"\"\"",
            "",
            "    def get_public(self, data: memoryview):",
            "        \"\"\"RSA public fields\"\"\"",
            "        e, data = _get_mpint(data)",
            "        n, data = _get_mpint(data)",
            "        return (e, n), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[rsa.RSAPublicKey, memoryview]:",
            "        \"\"\"Make RSA public key from data.\"\"\"",
            "        (e, n), data = self.get_public(data)",
            "        public_numbers = rsa.RSAPublicNumbers(e, n)",
            "        public_key = public_numbers.public_key()",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[rsa.RSAPrivateKey, memoryview]:",
            "        \"\"\"Make RSA private key from data.\"\"\"",
            "        n, data = _get_mpint(data)",
            "        e, data = _get_mpint(data)",
            "        d, data = _get_mpint(data)",
            "        iqmp, data = _get_mpint(data)",
            "        p, data = _get_mpint(data)",
            "        q, data = _get_mpint(data)",
            "",
            "        if (e, n) != pubfields:",
            "            raise ValueError(\"Corrupt data: rsa field mismatch\")",
            "        dmp1 = rsa.rsa_crt_dmp1(d, p)",
            "        dmq1 = rsa.rsa_crt_dmq1(d, q)",
            "        public_numbers = rsa.RSAPublicNumbers(e, n)",
            "        private_numbers = rsa.RSAPrivateNumbers(",
            "            p, q, d, dmp1, dmq1, iqmp, public_numbers",
            "        )",
            "        private_key = private_numbers.private_key()",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: rsa.RSAPublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write RSA public key\"\"\"",
            "        pubn = public_key.public_numbers()",
            "        f_pub.put_mpint(pubn.e)",
            "        f_pub.put_mpint(pubn.n)",
            "",
            "    def encode_private(",
            "        self, private_key: rsa.RSAPrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write RSA private key\"\"\"",
            "        private_numbers = private_key.private_numbers()",
            "        public_numbers = private_numbers.public_numbers",
            "",
            "        f_priv.put_mpint(public_numbers.n)",
            "        f_priv.put_mpint(public_numbers.e)",
            "",
            "        f_priv.put_mpint(private_numbers.d)",
            "        f_priv.put_mpint(private_numbers.iqmp)",
            "        f_priv.put_mpint(private_numbers.p)",
            "        f_priv.put_mpint(private_numbers.q)",
            "",
            "",
            "class _SSHFormatDSA:",
            "    \"\"\"Format for DSA keys.",
            "",
            "    Public:",
            "        mpint p, q, g, y",
            "    Private:",
            "        mpint p, q, g, y, x",
            "    \"\"\"",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"DSA public fields\"\"\"",
            "        p, data = _get_mpint(data)",
            "        q, data = _get_mpint(data)",
            "        g, data = _get_mpint(data)",
            "        y, data = _get_mpint(data)",
            "        return (p, q, g, y), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[dsa.DSAPublicKey, memoryview]:",
            "        \"\"\"Make DSA public key from data.\"\"\"",
            "        (p, q, g, y), data = self.get_public(data)",
            "        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)",
            "        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)",
            "        self._validate(public_numbers)",
            "        public_key = public_numbers.public_key()",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[dsa.DSAPrivateKey, memoryview]:",
            "        \"\"\"Make DSA private key from data.\"\"\"",
            "        (p, q, g, y), data = self.get_public(data)",
            "        x, data = _get_mpint(data)",
            "",
            "        if (p, q, g, y) != pubfields:",
            "            raise ValueError(\"Corrupt data: dsa field mismatch\")",
            "        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)",
            "        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)",
            "        self._validate(public_numbers)",
            "        private_numbers = dsa.DSAPrivateNumbers(x, public_numbers)",
            "        private_key = private_numbers.private_key()",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: dsa.DSAPublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write DSA public key\"\"\"",
            "        public_numbers = public_key.public_numbers()",
            "        parameter_numbers = public_numbers.parameter_numbers",
            "        self._validate(public_numbers)",
            "",
            "        f_pub.put_mpint(parameter_numbers.p)",
            "        f_pub.put_mpint(parameter_numbers.q)",
            "        f_pub.put_mpint(parameter_numbers.g)",
            "        f_pub.put_mpint(public_numbers.y)",
            "",
            "    def encode_private(",
            "        self, private_key: dsa.DSAPrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write DSA private key\"\"\"",
            "        self.encode_public(private_key.public_key(), f_priv)",
            "        f_priv.put_mpint(private_key.private_numbers().x)",
            "",
            "    def _validate(self, public_numbers: dsa.DSAPublicNumbers) -> None:",
            "        parameter_numbers = public_numbers.parameter_numbers",
            "        if parameter_numbers.p.bit_length() != 1024:",
            "            raise ValueError(\"SSH supports only 1024 bit DSA keys\")",
            "",
            "",
            "class _SSHFormatECDSA:",
            "    \"\"\"Format for ECDSA keys.",
            "",
            "    Public:",
            "        str curve",
            "        bytes point",
            "    Private:",
            "        str curve",
            "        bytes point",
            "        mpint secret",
            "    \"\"\"",
            "",
            "    def __init__(self, ssh_curve_name: bytes, curve: ec.EllipticCurve):",
            "        self.ssh_curve_name = ssh_curve_name",
            "        self.curve = curve",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"ECDSA public fields\"\"\"",
            "        curve, data = _get_sshstr(data)",
            "        point, data = _get_sshstr(data)",
            "        if curve != self.ssh_curve_name:",
            "            raise ValueError(\"Curve name mismatch\")",
            "        if point[0] != 4:",
            "            raise NotImplementedError(\"Need uncompressed point\")",
            "        return (curve, point), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[ec.EllipticCurvePublicKey, memoryview]:",
            "        \"\"\"Make ECDSA public key from data.\"\"\"",
            "        (curve_name, point), data = self.get_public(data)",
            "        public_key = ec.EllipticCurvePublicKey.from_encoded_point(",
            "            self.curve, point.tobytes()",
            "        )",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[ec.EllipticCurvePrivateKey, memoryview]:",
            "        \"\"\"Make ECDSA private key from data.\"\"\"",
            "        (curve_name, point), data = self.get_public(data)",
            "        secret, data = _get_mpint(data)",
            "",
            "        if (curve_name, point) != pubfields:",
            "            raise ValueError(\"Corrupt data: ecdsa field mismatch\")",
            "        private_key = ec.derive_private_key(secret, self.curve)",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: ec.EllipticCurvePublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write ECDSA public key\"\"\"",
            "        point = public_key.public_bytes(",
            "            Encoding.X962, PublicFormat.UncompressedPoint",
            "        )",
            "        f_pub.put_sshstr(self.ssh_curve_name)",
            "        f_pub.put_sshstr(point)",
            "",
            "    def encode_private(",
            "        self, private_key: ec.EllipticCurvePrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write ECDSA private key\"\"\"",
            "        public_key = private_key.public_key()",
            "        private_numbers = private_key.private_numbers()",
            "",
            "        self.encode_public(public_key, f_priv)",
            "        f_priv.put_mpint(private_numbers.private_value)",
            "",
            "",
            "class _SSHFormatEd25519:",
            "    \"\"\"Format for Ed25519 keys.",
            "",
            "    Public:",
            "        bytes point",
            "    Private:",
            "        bytes point",
            "        bytes secret_and_point",
            "    \"\"\"",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"Ed25519 public fields\"\"\"",
            "        point, data = _get_sshstr(data)",
            "        return (point,), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[ed25519.Ed25519PublicKey, memoryview]:",
            "        \"\"\"Make Ed25519 public key from data.\"\"\"",
            "        (point,), data = self.get_public(data)",
            "        public_key = ed25519.Ed25519PublicKey.from_public_bytes(",
            "            point.tobytes()",
            "        )",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[ed25519.Ed25519PrivateKey, memoryview]:",
            "        \"\"\"Make Ed25519 private key from data.\"\"\"",
            "        (point,), data = self.get_public(data)",
            "        keypair, data = _get_sshstr(data)",
            "",
            "        secret = keypair[:32]",
            "        point2 = keypair[32:]",
            "        if point != point2 or (point,) != pubfields:",
            "            raise ValueError(\"Corrupt data: ed25519 field mismatch\")",
            "        private_key = ed25519.Ed25519PrivateKey.from_private_bytes(secret)",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: ed25519.Ed25519PublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write Ed25519 public key\"\"\"",
            "        raw_public_key = public_key.public_bytes(",
            "            Encoding.Raw, PublicFormat.Raw",
            "        )",
            "        f_pub.put_sshstr(raw_public_key)",
            "",
            "    def encode_private(",
            "        self, private_key: ed25519.Ed25519PrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write Ed25519 private key\"\"\"",
            "        public_key = private_key.public_key()",
            "        raw_private_key = private_key.private_bytes(",
            "            Encoding.Raw, PrivateFormat.Raw, NoEncryption()",
            "        )",
            "        raw_public_key = public_key.public_bytes(",
            "            Encoding.Raw, PublicFormat.Raw",
            "        )",
            "        f_keypair = _FragList([raw_private_key, raw_public_key])",
            "",
            "        self.encode_public(public_key, f_priv)",
            "        f_priv.put_sshstr(f_keypair)",
            "",
            "",
            "_KEY_FORMATS = {",
            "    _SSH_RSA: _SSHFormatRSA(),",
            "    _SSH_DSA: _SSHFormatDSA(),",
            "    _SSH_ED25519: _SSHFormatEd25519(),",
            "    _ECDSA_NISTP256: _SSHFormatECDSA(b\"nistp256\", ec.SECP256R1()),",
            "    _ECDSA_NISTP384: _SSHFormatECDSA(b\"nistp384\", ec.SECP384R1()),",
            "    _ECDSA_NISTP521: _SSHFormatECDSA(b\"nistp521\", ec.SECP521R1()),",
            "}",
            "",
            "",
            "def _lookup_kformat(key_type: bytes):",
            "    \"\"\"Return valid format or throw error\"\"\"",
            "    if not isinstance(key_type, bytes):",
            "        key_type = memoryview(key_type).tobytes()",
            "    if key_type in _KEY_FORMATS:",
            "        return _KEY_FORMATS[key_type]",
            "    raise UnsupportedAlgorithm(f\"Unsupported key type: {key_type!r}\")",
            "",
            "",
            "_SSH_PRIVATE_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePrivateKey,",
            "    rsa.RSAPrivateKey,",
            "    dsa.DSAPrivateKey,",
            "    ed25519.Ed25519PrivateKey,",
            "]",
            "",
            "",
            "def load_ssh_private_key(",
            "    data: bytes,",
            "    password: typing.Optional[bytes],",
            "    backend: typing.Any = None,",
            ") -> _SSH_PRIVATE_KEY_TYPES:",
            "    \"\"\"Load private key from OpenSSH custom encoding.\"\"\"",
            "    utils._check_byteslike(\"data\", data)",
            "    if password is not None:",
            "        utils._check_bytes(\"password\", password)",
            "",
            "    m = _PEM_RC.search(data)",
            "    if not m:",
            "        raise ValueError(\"Not OpenSSH private key format\")",
            "    p1 = m.start(1)",
            "    p2 = m.end(1)",
            "    data = binascii.a2b_base64(memoryview(data)[p1:p2])",
            "    if not data.startswith(_SK_MAGIC):",
            "        raise ValueError(\"Not OpenSSH private key format\")",
            "    data = memoryview(data)[len(_SK_MAGIC) :]",
            "",
            "    # parse header",
            "    ciphername, data = _get_sshstr(data)",
            "    kdfname, data = _get_sshstr(data)",
            "    kdfoptions, data = _get_sshstr(data)",
            "    nkeys, data = _get_u32(data)",
            "    if nkeys != 1:",
            "        raise ValueError(\"Only one key supported\")",
            "",
            "    # load public key data",
            "    pubdata, data = _get_sshstr(data)",
            "    pub_key_type, pubdata = _get_sshstr(pubdata)",
            "    kformat = _lookup_kformat(pub_key_type)",
            "    pubfields, pubdata = kformat.get_public(pubdata)",
            "    _check_empty(pubdata)",
            "",
            "    # load secret data",
            "    edata, data = _get_sshstr(data)",
            "    _check_empty(data)",
            "",
            "    if (ciphername, kdfname) != (_NONE, _NONE):",
            "        ciphername_bytes = ciphername.tobytes()",
            "        if ciphername_bytes not in _SSH_CIPHERS:",
            "            raise UnsupportedAlgorithm(",
            "                f\"Unsupported cipher: {ciphername_bytes!r}\"",
            "            )",
            "        if kdfname != _BCRYPT:",
            "            raise UnsupportedAlgorithm(f\"Unsupported KDF: {kdfname!r}\")",
            "        blklen = _SSH_CIPHERS[ciphername_bytes][3]",
            "        _check_block_size(edata, blklen)",
            "        salt, kbuf = _get_sshstr(kdfoptions)",
            "        rounds, kbuf = _get_u32(kbuf)",
            "        _check_empty(kbuf)",
            "        ciph = _init_cipher(ciphername_bytes, password, salt.tobytes(), rounds)",
            "        edata = memoryview(ciph.decryptor().update(edata))",
            "    else:",
            "        blklen = 8",
            "        _check_block_size(edata, blklen)",
            "    ck1, edata = _get_u32(edata)",
            "    ck2, edata = _get_u32(edata)",
            "    if ck1 != ck2:",
            "        raise ValueError(\"Corrupt data: broken checksum\")",
            "",
            "    # load per-key struct",
            "    key_type, edata = _get_sshstr(edata)",
            "    if key_type != pub_key_type:",
            "        raise ValueError(\"Corrupt data: key type mismatch\")",
            "    private_key, edata = kformat.load_private(edata, pubfields)",
            "    comment, edata = _get_sshstr(edata)",
            "",
            "    # yes, SSH does padding check *after* all other parsing is done.",
            "    # need to follow as it writes zero-byte padding too.",
            "    if edata != _PADDING[: len(edata)]:",
            "        raise ValueError(\"Corrupt data: invalid padding\")",
            "",
            "    return private_key",
            "",
            "",
            "def _serialize_ssh_private_key(",
            "    private_key: _SSH_PRIVATE_KEY_TYPES,",
            "    password: bytes,",
            "    encryption_algorithm: KeySerializationEncryption,",
            ") -> bytes:",
            "    \"\"\"Serialize private key with OpenSSH custom encoding.\"\"\"",
            "    utils._check_bytes(\"password\", password)",
            "",
            "    key_type = _get_ssh_key_type(private_key)",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    # setup parameters",
            "    f_kdfoptions = _FragList()",
            "    if password:",
            "        ciphername = _DEFAULT_CIPHER",
            "        blklen = _SSH_CIPHERS[ciphername][3]",
            "        kdfname = _BCRYPT",
            "        rounds = _DEFAULT_ROUNDS",
            "        if (",
            "            isinstance(encryption_algorithm, _KeySerializationEncryption)",
            "            and encryption_algorithm._kdf_rounds is not None",
            "        ):",
            "            rounds = encryption_algorithm._kdf_rounds",
            "        salt = os.urandom(16)",
            "        f_kdfoptions.put_sshstr(salt)",
            "        f_kdfoptions.put_u32(rounds)",
            "        ciph = _init_cipher(ciphername, password, salt, rounds)",
            "    else:",
            "        ciphername = kdfname = _NONE",
            "        blklen = 8",
            "        ciph = None",
            "    nkeys = 1",
            "    checkval = os.urandom(4)",
            "    comment = b\"\"",
            "",
            "    # encode public and private parts together",
            "    f_public_key = _FragList()",
            "    f_public_key.put_sshstr(key_type)",
            "    kformat.encode_public(private_key.public_key(), f_public_key)",
            "",
            "    f_secrets = _FragList([checkval, checkval])",
            "    f_secrets.put_sshstr(key_type)",
            "    kformat.encode_private(private_key, f_secrets)",
            "    f_secrets.put_sshstr(comment)",
            "    f_secrets.put_raw(_PADDING[: blklen - (f_secrets.size() % blklen)])",
            "",
            "    # top-level structure",
            "    f_main = _FragList()",
            "    f_main.put_raw(_SK_MAGIC)",
            "    f_main.put_sshstr(ciphername)",
            "    f_main.put_sshstr(kdfname)",
            "    f_main.put_sshstr(f_kdfoptions)",
            "    f_main.put_u32(nkeys)",
            "    f_main.put_sshstr(f_public_key)",
            "    f_main.put_sshstr(f_secrets)",
            "",
            "    # copy result info bytearray",
            "    slen = f_secrets.size()",
            "    mlen = f_main.size()",
            "    buf = memoryview(bytearray(mlen + blklen))",
            "    f_main.render(buf)",
            "    ofs = mlen - slen",
            "",
            "    # encrypt in-place",
            "    if ciph is not None:",
            "        ciph.encryptor().update_into(buf[ofs:mlen], buf[ofs:])",
            "",
            "    return _ssh_pem_encode(buf[:mlen])",
            "",
            "",
            "_SSH_PUBLIC_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePublicKey,",
            "    rsa.RSAPublicKey,",
            "    dsa.DSAPublicKey,",
            "    ed25519.Ed25519PublicKey,",
            "]",
            "",
            "_SSH_CERT_PUBLIC_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePublicKey,",
            "    rsa.RSAPublicKey,",
            "    ed25519.Ed25519PublicKey,",
            "]",
            "",
            "",
            "class SSHCertificateType(enum.Enum):",
            "    USER = 1",
            "    HOST = 2",
            "",
            "",
            "class SSHCertificate:",
            "    def __init__(",
            "        self,",
            "        _nonce: memoryview,",
            "        _public_key: _SSH_PUBLIC_KEY_TYPES,",
            "        _serial: int,",
            "        _cctype: int,",
            "        _key_id: memoryview,",
            "        _valid_principals: memoryview,",
            "        _valid_after: int,",
            "        _valid_before: int,",
            "        _critical_options: memoryview,",
            "        _extensions: memoryview,",
            "        _sig_type: memoryview,",
            "        _sig_key: memoryview,",
            "        _inner_sig_type: memoryview,",
            "        _signature: memoryview,",
            "        _tbs_cert_body: memoryview,",
            "        _cert_key_type: bytes,",
            "        _cert_body: memoryview,",
            "    ):",
            "        self._nonce = _nonce",
            "        self._public_key = _public_key",
            "        self._serial = _serial",
            "        try:",
            "            self._type = SSHCertificateType(_cctype)",
            "        except ValueError:",
            "            raise ValueError(\"Invalid certificate type\")",
            "        self._key_id = _key_id",
            "        self._valid_principals = _valid_principals",
            "        self._valid_after = datetime.datetime.utcfromtimestamp(_valid_after)",
            "        self._valid_before = datetime.datetime.utcfromtimestamp(_valid_before)",
            "        self._critical_options = _critical_options",
            "        self._extensions = _extensions",
            "        self._sig_type = _sig_type",
            "        self._sig_key = _sig_key",
            "        self._inner_sig_type = _inner_sig_type",
            "        self._signature = _signature",
            "        self._cert_key_type = _cert_key_type",
            "        self._cert_body = _cert_body",
            "        self._tbs_cert_body = _tbs_cert_body",
            "",
            "    @property",
            "    def nonce(self) -> bytes:",
            "        return bytes(self._nonce)",
            "",
            "    def public_key(self) -> _SSH_CERT_PUBLIC_KEY_TYPES:",
            "        # make mypy happy until we remove DSA support entirely and",
            "        # the underlying union won't have a disallowed type",
            "        assert not isinstance(self._public_key, dsa.DSAPublicKey)",
            "        return self._public_key",
            "",
            "    @property",
            "    def serial(self) -> int:",
            "        return self._serial",
            "",
            "    @property",
            "    def type(self) -> SSHCertificateType:",
            "        return self._type",
            "",
            "    @property",
            "    def key_id(self) -> bytes:",
            "        return bytes(self._key_id)",
            "",
            "    @utils.cached_property",
            "    def valid_principals(self) -> typing.List[bytes]:",
            "        rest = self._valid_principals",
            "        principals = []",
            "        while rest:",
            "            principal, rest = _get_sshstr(rest)",
            "            principals.append(bytes(principal))",
            "",
            "        return principals",
            "",
            "    @property",
            "    def valid_before(self) -> datetime.datetime:",
            "        return self._valid_before",
            "",
            "    @property",
            "    def valid_after(self) -> datetime.datetime:",
            "        return self._valid_after",
            "",
            "    @utils.cached_property",
            "    def critical_options(self) -> typing.Dict[bytes, bytes]:",
            "        return self._parse_exts_opts(self._critical_options)",
            "",
            "    @utils.cached_property",
            "    def extensions(self) -> typing.Dict[bytes, bytes]:",
            "        return self._parse_exts_opts(self._extensions)",
            "",
            "    def _parse_exts_opts(",
            "        self, exts_opts: memoryview",
            "    ) -> typing.Dict[bytes, bytes]:",
            "        result: typing.Dict[bytes, bytes] = {}",
            "        last_name = None",
            "        while exts_opts:",
            "            name, exts_opts = _get_sshstr(exts_opts)",
            "            bname: bytes = bytes(name)",
            "            if bname in result:",
            "                raise ValueError(\"Duplicate extension name\")",
            "            # dicts in pypy & python 3.6+ are insertion ordered so hooray",
            "            if last_name is not None and bname < last_name:",
            "                raise ValueError(\"Extensions not lexically sorted\")",
            "            value, exts_opts = _get_sshstr(exts_opts)",
            "            result[bname] = bytes(value)",
            "            last_name = bname",
            "        return result",
            "",
            "    def signature_key(self) -> _SSH_CERT_PUBLIC_KEY_TYPES:",
            "        sigformat = _lookup_kformat(self._sig_type)",
            "        signature_key, sigkey_rest = sigformat.load_public(self._sig_key)",
            "        _check_empty(sigkey_rest)",
            "        return signature_key",
            "",
            "    def public_bytes(self) -> bytes:",
            "        return (",
            "            bytes(self._cert_key_type)",
            "            + b\" \"",
            "            + binascii.b2a_base64(bytes(self._cert_body), newline=False)",
            "        )",
            "",
            "    def verify_cert_signature(self) -> None:",
            "        signature_key = self.signature_key()",
            "        if isinstance(signature_key, ed25519.Ed25519PublicKey):",
            "            signature_key.verify(",
            "                bytes(self._signature), bytes(self._tbs_cert_body)",
            "            )",
            "        elif isinstance(signature_key, ec.EllipticCurvePublicKey):",
            "            # The signature is encoded as a pair of big-endian integers",
            "            r, data = _get_mpint(self._signature)",
            "            s, data = _get_mpint(data)",
            "            _check_empty(data)",
            "            computed_sig = asym_utils.encode_dss_signature(r, s)",
            "            hash_alg = _get_ec_hash_alg(signature_key.curve)",
            "            signature_key.verify(",
            "                computed_sig, bytes(self._tbs_cert_body), ec.ECDSA(hash_alg)",
            "            )",
            "        else:",
            "            assert isinstance(signature_key, rsa.RSAPublicKey)",
            "            if self._inner_sig_type == _SSH_RSA:",
            "                hash_alg = hashes.SHA1()",
            "            elif self._inner_sig_type == _SSH_RSA_SHA256:",
            "                hash_alg = hashes.SHA256()",
            "            else:",
            "                assert self._inner_sig_type == _SSH_RSA_SHA512",
            "                hash_alg = hashes.SHA512()",
            "            signature_key.verify(",
            "                bytes(self._signature),",
            "                bytes(self._tbs_cert_body),",
            "                padding.PKCS1v15(),",
            "                hash_alg,",
            "            )",
            "",
            "",
            "def _get_ec_hash_alg(curve: ec.EllipticCurve) -> hashes.HashAlgorithm:",
            "    hash_alg: hashes.HashAlgorithm",
            "    if isinstance(curve, ec.SECP256R1):",
            "        hash_alg = hashes.SHA256()",
            "    elif isinstance(curve, ec.SECP384R1):",
            "        hash_alg = hashes.SHA384()",
            "    else:",
            "        assert isinstance(curve, ec.SECP521R1)",
            "        hash_alg = hashes.SHA512()",
            "    return hash_alg",
            "",
            "",
            "def load_ssh_certificate(data: bytes) -> SSHCertificate:",
            "    utils._check_byteslike(\"data\", data)",
            "",
            "    m = _SSH_PUBKEY_RC.match(data)",
            "    if not m:",
            "        raise ValueError(\"Invalid line format\")",
            "    key_type = orig_key_type = m.group(1)",
            "    key_body = m.group(2)",
            "    if _CERT_SUFFIX != key_type[-len(_CERT_SUFFIX) :]:",
            "        raise ValueError(\"Not an SSH certificate\")",
            "    else:",
            "        key_type = key_type[: -len(_CERT_SUFFIX)]",
            "    if key_type == _SSH_DSA:",
            "        raise UnsupportedAlgorithm(",
            "            \"DSA keys aren't supported in SSH certificates\"",
            "        )",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    try:",
            "        rest = memoryview(binascii.a2b_base64(key_body))",
            "    except (TypeError, binascii.Error):",
            "        raise ValueError(\"Invalid format\")",
            "",
            "    cert_body = rest",
            "    inner_key_type, rest = _get_sshstr(rest)",
            "    if inner_key_type != orig_key_type:",
            "        raise ValueError(\"Invalid key format\")",
            "    nonce, rest = _get_sshstr(rest)",
            "    public_key, rest = kformat.load_public(rest)",
            "    serial, rest = _get_u64(rest)",
            "    cctype, rest = _get_u32(rest)",
            "    key_id, rest = _get_sshstr(rest)",
            "    principals, rest = _get_sshstr(rest)",
            "    valid_after, rest = _get_u64(rest)",
            "    valid_before, rest = _get_u64(rest)",
            "    crit_options, rest = _get_sshstr(rest)",
            "    extensions, rest = _get_sshstr(rest)",
            "    # Get the reserved field, which is unused.",
            "    _, rest = _get_sshstr(rest)",
            "    sig_key_raw, rest = _get_sshstr(rest)",
            "    sig_type, sig_key = _get_sshstr(sig_key_raw)",
            "    if sig_type == _SSH_DSA:",
            "        raise UnsupportedAlgorithm(",
            "            \"DSA signatures aren't supported in SSH certificates\"",
            "        )",
            "    # Get the entire cert body and subtract the signature",
            "    tbs_cert_body = cert_body[: -len(rest)]",
            "    signature_raw, rest = _get_sshstr(rest)",
            "    _check_empty(rest)",
            "    inner_sig_type, sig_rest = _get_sshstr(signature_raw)",
            "    # RSA certs can have multiple algorithm types",
            "    if (",
            "        sig_type == _SSH_RSA",
            "        and inner_sig_type not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]",
            "    ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):",
            "        raise ValueError(\"Signature key type does not match\")",
            "    signature, sig_rest = _get_sshstr(sig_rest)",
            "    _check_empty(sig_rest)",
            "    return SSHCertificate(",
            "        nonce,",
            "        public_key,",
            "        serial,",
            "        cctype,",
            "        key_id,",
            "        principals,",
            "        valid_after,",
            "        valid_before,",
            "        crit_options,",
            "        extensions,",
            "        sig_type,",
            "        sig_key,",
            "        inner_sig_type,",
            "        signature,",
            "        tbs_cert_body,",
            "        orig_key_type,",
            "        cert_body,",
            "    )",
            "",
            "",
            "def load_ssh_public_key(",
            "    data: bytes, backend: typing.Any = None",
            ") -> _SSH_PUBLIC_KEY_TYPES:",
            "    \"\"\"Load public key from OpenSSH one-line format.\"\"\"",
            "    utils._check_byteslike(\"data\", data)",
            "",
            "    m = _SSH_PUBKEY_RC.match(data)",
            "    if not m:",
            "        raise ValueError(\"Invalid line format\")",
            "    key_type = orig_key_type = m.group(1)",
            "    key_body = m.group(2)",
            "    with_cert = False",
            "    if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:",
            "        with_cert = True",
            "        key_type = key_type[: -len(_CERT_SUFFIX)]",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    try:",
            "        rest = memoryview(binascii.a2b_base64(key_body))",
            "    except (TypeError, binascii.Error):",
            "        raise ValueError(\"Invalid key format\")",
            "",
            "    inner_key_type, rest = _get_sshstr(rest)",
            "    if inner_key_type != orig_key_type:",
            "        raise ValueError(\"Invalid key format\")",
            "    if with_cert:",
            "        nonce, rest = _get_sshstr(rest)",
            "    public_key, rest = kformat.load_public(rest)",
            "    if with_cert:",
            "        serial, rest = _get_u64(rest)",
            "        cctype, rest = _get_u32(rest)",
            "        key_id, rest = _get_sshstr(rest)",
            "        principals, rest = _get_sshstr(rest)",
            "        valid_after, rest = _get_u64(rest)",
            "        valid_before, rest = _get_u64(rest)",
            "        crit_options, rest = _get_sshstr(rest)",
            "        extensions, rest = _get_sshstr(rest)",
            "        reserved, rest = _get_sshstr(rest)",
            "        sig_key, rest = _get_sshstr(rest)",
            "        signature, rest = _get_sshstr(rest)",
            "    _check_empty(rest)",
            "    return public_key",
            "",
            "",
            "def serialize_ssh_public_key(public_key: _SSH_PUBLIC_KEY_TYPES) -> bytes:",
            "    \"\"\"One-line public key format for OpenSSH\"\"\"",
            "    key_type = _get_ssh_key_type(public_key)",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    f_pub = _FragList()",
            "    f_pub.put_sshstr(key_type)",
            "    kformat.encode_public(public_key, f_pub)",
            "",
            "    pub = binascii.b2a_base64(f_pub.tobytes()).strip()",
            "    return b\"\".join([key_type, b\" \", pub])"
        ],
        "afterPatchFile": [
            "# This file is dual licensed under the terms of the Apache License, Version",
            "# 2.0, and the BSD License. See the LICENSE file in the root of this repository",
            "# for complete details.",
            "",
            "",
            "import binascii",
            "import datetime",
            "import enum",
            "import os",
            "import re",
            "import typing",
            "from base64 import encodebytes as _base64_encode",
            "",
            "from cryptography import utils",
            "from cryptography.exceptions import UnsupportedAlgorithm",
            "from cryptography.hazmat.primitives import hashes",
            "from cryptography.hazmat.primitives.asymmetric import (",
            "    dsa,",
            "    ec,",
            "    ed25519,",
            "    padding,",
            "    rsa,",
            ")",
            "from cryptography.hazmat.primitives.asymmetric import utils as asym_utils",
            "from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes",
            "from cryptography.hazmat.primitives.serialization import (",
            "    Encoding,",
            "    KeySerializationEncryption,",
            "    NoEncryption,",
            "    PrivateFormat,",
            "    PublicFormat,",
            "    _KeySerializationEncryption,",
            ")",
            "",
            "try:",
            "    from bcrypt import kdf as _bcrypt_kdf",
            "",
            "    _bcrypt_supported = True",
            "except ImportError:",
            "    _bcrypt_supported = False",
            "",
            "    def _bcrypt_kdf(",
            "        password: bytes,",
            "        salt: bytes,",
            "        desired_key_bytes: int,",
            "        rounds: int,",
            "        ignore_few_rounds: bool = False,",
            "    ) -> bytes:",
            "        raise UnsupportedAlgorithm(\"Need bcrypt module\")",
            "",
            "",
            "_SSH_ED25519 = b\"ssh-ed25519\"",
            "_SSH_RSA = b\"ssh-rsa\"",
            "_SSH_DSA = b\"ssh-dss\"",
            "_ECDSA_NISTP256 = b\"ecdsa-sha2-nistp256\"",
            "_ECDSA_NISTP384 = b\"ecdsa-sha2-nistp384\"",
            "_ECDSA_NISTP521 = b\"ecdsa-sha2-nistp521\"",
            "_CERT_SUFFIX = b\"-cert-v01@openssh.com\"",
            "",
            "# These are not key types, only algorithms, so they cannot appear",
            "# as a public key type",
            "_SSH_RSA_SHA256 = b\"rsa-sha2-256\"",
            "_SSH_RSA_SHA512 = b\"rsa-sha2-512\"",
            "",
            "_SSH_PUBKEY_RC = re.compile(rb\"\\A(\\S+)[ \\t]+(\\S+)\")",
            "_SK_MAGIC = b\"openssh-key-v1\\0\"",
            "_SK_START = b\"-----BEGIN OPENSSH PRIVATE KEY-----\"",
            "_SK_END = b\"-----END OPENSSH PRIVATE KEY-----\"",
            "_BCRYPT = b\"bcrypt\"",
            "_NONE = b\"none\"",
            "_DEFAULT_CIPHER = b\"aes256-ctr\"",
            "_DEFAULT_ROUNDS = 16",
            "",
            "# re is only way to work on bytes-like data",
            "_PEM_RC = re.compile(_SK_START + b\"(.*?)\" + _SK_END, re.DOTALL)",
            "",
            "# padding for max blocksize",
            "_PADDING = memoryview(bytearray(range(1, 1 + 16)))",
            "",
            "# ciphers that are actually used in key wrapping",
            "_SSH_CIPHERS: typing.Dict[",
            "    bytes,",
            "    typing.Tuple[",
            "        typing.Type[algorithms.AES],",
            "        int,",
            "        typing.Union[typing.Type[modes.CTR], typing.Type[modes.CBC]],",
            "        int,",
            "    ],",
            "] = {",
            "    b\"aes256-ctr\": (algorithms.AES, 32, modes.CTR, 16),",
            "    b\"aes256-cbc\": (algorithms.AES, 32, modes.CBC, 16),",
            "}",
            "",
            "# map local curve name to key type",
            "_ECDSA_KEY_TYPE = {",
            "    \"secp256r1\": _ECDSA_NISTP256,",
            "    \"secp384r1\": _ECDSA_NISTP384,",
            "    \"secp521r1\": _ECDSA_NISTP521,",
            "}",
            "",
            "",
            "def _get_ssh_key_type(",
            "    key: typing.Union[\"_SSH_PRIVATE_KEY_TYPES\", \"_SSH_PUBLIC_KEY_TYPES\"]",
            ") -> bytes:",
            "    if isinstance(key, ec.EllipticCurvePrivateKey):",
            "        key_type = _ecdsa_key_type(key.public_key())",
            "    elif isinstance(key, ec.EllipticCurvePublicKey):",
            "        key_type = _ecdsa_key_type(key)",
            "    elif isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):",
            "        key_type = _SSH_RSA",
            "    elif isinstance(key, (dsa.DSAPrivateKey, dsa.DSAPublicKey)):",
            "        key_type = _SSH_DSA",
            "    elif isinstance(",
            "        key, (ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey)",
            "    ):",
            "        key_type = _SSH_ED25519",
            "    else:",
            "        raise ValueError(\"Unsupported key type\")",
            "",
            "    return key_type",
            "",
            "",
            "def _ecdsa_key_type(public_key: ec.EllipticCurvePublicKey) -> bytes:",
            "    \"\"\"Return SSH key_type and curve_name for private key.\"\"\"",
            "    curve = public_key.curve",
            "    if curve.name not in _ECDSA_KEY_TYPE:",
            "        raise ValueError(",
            "            f\"Unsupported curve for ssh private key: {curve.name!r}\"",
            "        )",
            "    return _ECDSA_KEY_TYPE[curve.name]",
            "",
            "",
            "def _ssh_pem_encode(",
            "    data: bytes,",
            "    prefix: bytes = _SK_START + b\"\\n\",",
            "    suffix: bytes = _SK_END + b\"\\n\",",
            ") -> bytes:",
            "    return b\"\".join([prefix, _base64_encode(data), suffix])",
            "",
            "",
            "def _check_block_size(data: bytes, block_len: int) -> None:",
            "    \"\"\"Require data to be full blocks\"\"\"",
            "    if not data or len(data) % block_len != 0:",
            "        raise ValueError(\"Corrupt data: missing padding\")",
            "",
            "",
            "def _check_empty(data: bytes) -> None:",
            "    \"\"\"All data should have been parsed.\"\"\"",
            "    if data:",
            "        raise ValueError(\"Corrupt data: unparsed data\")",
            "",
            "",
            "def _init_cipher(",
            "    ciphername: bytes,",
            "    password: typing.Optional[bytes],",
            "    salt: bytes,",
            "    rounds: int,",
            ") -> Cipher[typing.Union[modes.CBC, modes.CTR]]:",
            "    \"\"\"Generate key + iv and return cipher.\"\"\"",
            "    if not password:",
            "        raise ValueError(\"Key is password-protected.\")",
            "",
            "    algo, key_len, mode, iv_len = _SSH_CIPHERS[ciphername]",
            "    seed = _bcrypt_kdf(password, salt, key_len + iv_len, rounds, True)",
            "    return Cipher(algo(seed[:key_len]), mode(seed[key_len:]))",
            "",
            "",
            "def _get_u32(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Uint32\"\"\"",
            "    if len(data) < 4:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(data[:4], byteorder=\"big\"), data[4:]",
            "",
            "",
            "def _get_u64(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Uint64\"\"\"",
            "    if len(data) < 8:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(data[:8], byteorder=\"big\"), data[8:]",
            "",
            "",
            "def _get_sshstr(data: memoryview) -> typing.Tuple[memoryview, memoryview]:",
            "    \"\"\"Bytes with u32 length prefix\"\"\"",
            "    n, data = _get_u32(data)",
            "    if n > len(data):",
            "        raise ValueError(\"Invalid data\")",
            "    return data[:n], data[n:]",
            "",
            "",
            "def _get_mpint(data: memoryview) -> typing.Tuple[int, memoryview]:",
            "    \"\"\"Big integer.\"\"\"",
            "    val, data = _get_sshstr(data)",
            "    if val and val[0] > 0x7F:",
            "        raise ValueError(\"Invalid data\")",
            "    return int.from_bytes(val, \"big\"), data",
            "",
            "",
            "def _to_mpint(val: int) -> bytes:",
            "    \"\"\"Storage format for signed bigint.\"\"\"",
            "    if val < 0:",
            "        raise ValueError(\"negative mpint not allowed\")",
            "    if not val:",
            "        return b\"\"",
            "    nbytes = (val.bit_length() + 8) // 8",
            "    return utils.int_to_bytes(val, nbytes)",
            "",
            "",
            "class _FragList:",
            "    \"\"\"Build recursive structure without data copy.\"\"\"",
            "",
            "    flist: typing.List[bytes]",
            "",
            "    def __init__(",
            "        self, init: typing.Optional[typing.List[bytes]] = None",
            "    ) -> None:",
            "        self.flist = []",
            "        if init:",
            "            self.flist.extend(init)",
            "",
            "    def put_raw(self, val: bytes) -> None:",
            "        \"\"\"Add plain bytes\"\"\"",
            "        self.flist.append(val)",
            "",
            "    def put_u32(self, val: int) -> None:",
            "        \"\"\"Big-endian uint32\"\"\"",
            "        self.flist.append(val.to_bytes(length=4, byteorder=\"big\"))",
            "",
            "    def put_sshstr(self, val: typing.Union[bytes, \"_FragList\"]) -> None:",
            "        \"\"\"Bytes prefixed with u32 length\"\"\"",
            "        if isinstance(val, (bytes, memoryview, bytearray)):",
            "            self.put_u32(len(val))",
            "            self.flist.append(val)",
            "        else:",
            "            self.put_u32(val.size())",
            "            self.flist.extend(val.flist)",
            "",
            "    def put_mpint(self, val: int) -> None:",
            "        \"\"\"Big-endian bigint prefixed with u32 length\"\"\"",
            "        self.put_sshstr(_to_mpint(val))",
            "",
            "    def size(self) -> int:",
            "        \"\"\"Current number of bytes\"\"\"",
            "        return sum(map(len, self.flist))",
            "",
            "    def render(self, dstbuf: memoryview, pos: int = 0) -> int:",
            "        \"\"\"Write into bytearray\"\"\"",
            "        for frag in self.flist:",
            "            flen = len(frag)",
            "            start, pos = pos, pos + flen",
            "            dstbuf[start:pos] = frag",
            "        return pos",
            "",
            "    def tobytes(self) -> bytes:",
            "        \"\"\"Return as bytes\"\"\"",
            "        buf = memoryview(bytearray(self.size()))",
            "        self.render(buf)",
            "        return buf.tobytes()",
            "",
            "",
            "class _SSHFormatRSA:",
            "    \"\"\"Format for RSA keys.",
            "",
            "    Public:",
            "        mpint e, n",
            "    Private:",
            "        mpint n, e, d, iqmp, p, q",
            "    \"\"\"",
            "",
            "    def get_public(self, data: memoryview):",
            "        \"\"\"RSA public fields\"\"\"",
            "        e, data = _get_mpint(data)",
            "        n, data = _get_mpint(data)",
            "        return (e, n), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[rsa.RSAPublicKey, memoryview]:",
            "        \"\"\"Make RSA public key from data.\"\"\"",
            "        (e, n), data = self.get_public(data)",
            "        public_numbers = rsa.RSAPublicNumbers(e, n)",
            "        public_key = public_numbers.public_key()",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[rsa.RSAPrivateKey, memoryview]:",
            "        \"\"\"Make RSA private key from data.\"\"\"",
            "        n, data = _get_mpint(data)",
            "        e, data = _get_mpint(data)",
            "        d, data = _get_mpint(data)",
            "        iqmp, data = _get_mpint(data)",
            "        p, data = _get_mpint(data)",
            "        q, data = _get_mpint(data)",
            "",
            "        if (e, n) != pubfields:",
            "            raise ValueError(\"Corrupt data: rsa field mismatch\")",
            "        dmp1 = rsa.rsa_crt_dmp1(d, p)",
            "        dmq1 = rsa.rsa_crt_dmq1(d, q)",
            "        public_numbers = rsa.RSAPublicNumbers(e, n)",
            "        private_numbers = rsa.RSAPrivateNumbers(",
            "            p, q, d, dmp1, dmq1, iqmp, public_numbers",
            "        )",
            "        private_key = private_numbers.private_key()",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: rsa.RSAPublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write RSA public key\"\"\"",
            "        pubn = public_key.public_numbers()",
            "        f_pub.put_mpint(pubn.e)",
            "        f_pub.put_mpint(pubn.n)",
            "",
            "    def encode_private(",
            "        self, private_key: rsa.RSAPrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write RSA private key\"\"\"",
            "        private_numbers = private_key.private_numbers()",
            "        public_numbers = private_numbers.public_numbers",
            "",
            "        f_priv.put_mpint(public_numbers.n)",
            "        f_priv.put_mpint(public_numbers.e)",
            "",
            "        f_priv.put_mpint(private_numbers.d)",
            "        f_priv.put_mpint(private_numbers.iqmp)",
            "        f_priv.put_mpint(private_numbers.p)",
            "        f_priv.put_mpint(private_numbers.q)",
            "",
            "",
            "class _SSHFormatDSA:",
            "    \"\"\"Format for DSA keys.",
            "",
            "    Public:",
            "        mpint p, q, g, y",
            "    Private:",
            "        mpint p, q, g, y, x",
            "    \"\"\"",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"DSA public fields\"\"\"",
            "        p, data = _get_mpint(data)",
            "        q, data = _get_mpint(data)",
            "        g, data = _get_mpint(data)",
            "        y, data = _get_mpint(data)",
            "        return (p, q, g, y), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[dsa.DSAPublicKey, memoryview]:",
            "        \"\"\"Make DSA public key from data.\"\"\"",
            "        (p, q, g, y), data = self.get_public(data)",
            "        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)",
            "        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)",
            "        self._validate(public_numbers)",
            "        public_key = public_numbers.public_key()",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[dsa.DSAPrivateKey, memoryview]:",
            "        \"\"\"Make DSA private key from data.\"\"\"",
            "        (p, q, g, y), data = self.get_public(data)",
            "        x, data = _get_mpint(data)",
            "",
            "        if (p, q, g, y) != pubfields:",
            "            raise ValueError(\"Corrupt data: dsa field mismatch\")",
            "        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)",
            "        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)",
            "        self._validate(public_numbers)",
            "        private_numbers = dsa.DSAPrivateNumbers(x, public_numbers)",
            "        private_key = private_numbers.private_key()",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: dsa.DSAPublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write DSA public key\"\"\"",
            "        public_numbers = public_key.public_numbers()",
            "        parameter_numbers = public_numbers.parameter_numbers",
            "        self._validate(public_numbers)",
            "",
            "        f_pub.put_mpint(parameter_numbers.p)",
            "        f_pub.put_mpint(parameter_numbers.q)",
            "        f_pub.put_mpint(parameter_numbers.g)",
            "        f_pub.put_mpint(public_numbers.y)",
            "",
            "    def encode_private(",
            "        self, private_key: dsa.DSAPrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write DSA private key\"\"\"",
            "        self.encode_public(private_key.public_key(), f_priv)",
            "        f_priv.put_mpint(private_key.private_numbers().x)",
            "",
            "    def _validate(self, public_numbers: dsa.DSAPublicNumbers) -> None:",
            "        parameter_numbers = public_numbers.parameter_numbers",
            "        if parameter_numbers.p.bit_length() != 1024:",
            "            raise ValueError(\"SSH supports only 1024 bit DSA keys\")",
            "",
            "",
            "class _SSHFormatECDSA:",
            "    \"\"\"Format for ECDSA keys.",
            "",
            "    Public:",
            "        str curve",
            "        bytes point",
            "    Private:",
            "        str curve",
            "        bytes point",
            "        mpint secret",
            "    \"\"\"",
            "",
            "    def __init__(self, ssh_curve_name: bytes, curve: ec.EllipticCurve):",
            "        self.ssh_curve_name = ssh_curve_name",
            "        self.curve = curve",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"ECDSA public fields\"\"\"",
            "        curve, data = _get_sshstr(data)",
            "        point, data = _get_sshstr(data)",
            "        if curve != self.ssh_curve_name:",
            "            raise ValueError(\"Curve name mismatch\")",
            "        if point[0] != 4:",
            "            raise NotImplementedError(\"Need uncompressed point\")",
            "        return (curve, point), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[ec.EllipticCurvePublicKey, memoryview]:",
            "        \"\"\"Make ECDSA public key from data.\"\"\"",
            "        (curve_name, point), data = self.get_public(data)",
            "        public_key = ec.EllipticCurvePublicKey.from_encoded_point(",
            "            self.curve, point.tobytes()",
            "        )",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[ec.EllipticCurvePrivateKey, memoryview]:",
            "        \"\"\"Make ECDSA private key from data.\"\"\"",
            "        (curve_name, point), data = self.get_public(data)",
            "        secret, data = _get_mpint(data)",
            "",
            "        if (curve_name, point) != pubfields:",
            "            raise ValueError(\"Corrupt data: ecdsa field mismatch\")",
            "        private_key = ec.derive_private_key(secret, self.curve)",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: ec.EllipticCurvePublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write ECDSA public key\"\"\"",
            "        point = public_key.public_bytes(",
            "            Encoding.X962, PublicFormat.UncompressedPoint",
            "        )",
            "        f_pub.put_sshstr(self.ssh_curve_name)",
            "        f_pub.put_sshstr(point)",
            "",
            "    def encode_private(",
            "        self, private_key: ec.EllipticCurvePrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write ECDSA private key\"\"\"",
            "        public_key = private_key.public_key()",
            "        private_numbers = private_key.private_numbers()",
            "",
            "        self.encode_public(public_key, f_priv)",
            "        f_priv.put_mpint(private_numbers.private_value)",
            "",
            "",
            "class _SSHFormatEd25519:",
            "    \"\"\"Format for Ed25519 keys.",
            "",
            "    Public:",
            "        bytes point",
            "    Private:",
            "        bytes point",
            "        bytes secret_and_point",
            "    \"\"\"",
            "",
            "    def get_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[typing.Tuple, memoryview]:",
            "        \"\"\"Ed25519 public fields\"\"\"",
            "        point, data = _get_sshstr(data)",
            "        return (point,), data",
            "",
            "    def load_public(",
            "        self, data: memoryview",
            "    ) -> typing.Tuple[ed25519.Ed25519PublicKey, memoryview]:",
            "        \"\"\"Make Ed25519 public key from data.\"\"\"",
            "        (point,), data = self.get_public(data)",
            "        public_key = ed25519.Ed25519PublicKey.from_public_bytes(",
            "            point.tobytes()",
            "        )",
            "        return public_key, data",
            "",
            "    def load_private(",
            "        self, data: memoryview, pubfields",
            "    ) -> typing.Tuple[ed25519.Ed25519PrivateKey, memoryview]:",
            "        \"\"\"Make Ed25519 private key from data.\"\"\"",
            "        (point,), data = self.get_public(data)",
            "        keypair, data = _get_sshstr(data)",
            "",
            "        secret = keypair[:32]",
            "        point2 = keypair[32:]",
            "        if point != point2 or (point,) != pubfields:",
            "            raise ValueError(\"Corrupt data: ed25519 field mismatch\")",
            "        private_key = ed25519.Ed25519PrivateKey.from_private_bytes(secret)",
            "        return private_key, data",
            "",
            "    def encode_public(",
            "        self, public_key: ed25519.Ed25519PublicKey, f_pub: _FragList",
            "    ) -> None:",
            "        \"\"\"Write Ed25519 public key\"\"\"",
            "        raw_public_key = public_key.public_bytes(",
            "            Encoding.Raw, PublicFormat.Raw",
            "        )",
            "        f_pub.put_sshstr(raw_public_key)",
            "",
            "    def encode_private(",
            "        self, private_key: ed25519.Ed25519PrivateKey, f_priv: _FragList",
            "    ) -> None:",
            "        \"\"\"Write Ed25519 private key\"\"\"",
            "        public_key = private_key.public_key()",
            "        raw_private_key = private_key.private_bytes(",
            "            Encoding.Raw, PrivateFormat.Raw, NoEncryption()",
            "        )",
            "        raw_public_key = public_key.public_bytes(",
            "            Encoding.Raw, PublicFormat.Raw",
            "        )",
            "        f_keypair = _FragList([raw_private_key, raw_public_key])",
            "",
            "        self.encode_public(public_key, f_priv)",
            "        f_priv.put_sshstr(f_keypair)",
            "",
            "",
            "_KEY_FORMATS = {",
            "    _SSH_RSA: _SSHFormatRSA(),",
            "    _SSH_DSA: _SSHFormatDSA(),",
            "    _SSH_ED25519: _SSHFormatEd25519(),",
            "    _ECDSA_NISTP256: _SSHFormatECDSA(b\"nistp256\", ec.SECP256R1()),",
            "    _ECDSA_NISTP384: _SSHFormatECDSA(b\"nistp384\", ec.SECP384R1()),",
            "    _ECDSA_NISTP521: _SSHFormatECDSA(b\"nistp521\", ec.SECP521R1()),",
            "}",
            "",
            "",
            "def _lookup_kformat(key_type: bytes):",
            "    \"\"\"Return valid format or throw error\"\"\"",
            "    if not isinstance(key_type, bytes):",
            "        key_type = memoryview(key_type).tobytes()",
            "    if key_type in _KEY_FORMATS:",
            "        return _KEY_FORMATS[key_type]",
            "    raise UnsupportedAlgorithm(f\"Unsupported key type: {key_type!r}\")",
            "",
            "",
            "_SSH_PRIVATE_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePrivateKey,",
            "    rsa.RSAPrivateKey,",
            "    dsa.DSAPrivateKey,",
            "    ed25519.Ed25519PrivateKey,",
            "]",
            "",
            "",
            "def load_ssh_private_key(",
            "    data: bytes,",
            "    password: typing.Optional[bytes],",
            "    backend: typing.Any = None,",
            ") -> _SSH_PRIVATE_KEY_TYPES:",
            "    \"\"\"Load private key from OpenSSH custom encoding.\"\"\"",
            "    utils._check_byteslike(\"data\", data)",
            "    if password is not None:",
            "        utils._check_bytes(\"password\", password)",
            "",
            "    m = _PEM_RC.search(data)",
            "    if not m:",
            "        raise ValueError(\"Not OpenSSH private key format\")",
            "    p1 = m.start(1)",
            "    p2 = m.end(1)",
            "    data = binascii.a2b_base64(memoryview(data)[p1:p2])",
            "    if not data.startswith(_SK_MAGIC):",
            "        raise ValueError(\"Not OpenSSH private key format\")",
            "    data = memoryview(data)[len(_SK_MAGIC) :]",
            "",
            "    # parse header",
            "    ciphername, data = _get_sshstr(data)",
            "    kdfname, data = _get_sshstr(data)",
            "    kdfoptions, data = _get_sshstr(data)",
            "    nkeys, data = _get_u32(data)",
            "    if nkeys != 1:",
            "        raise ValueError(\"Only one key supported\")",
            "",
            "    # load public key data",
            "    pubdata, data = _get_sshstr(data)",
            "    pub_key_type, pubdata = _get_sshstr(pubdata)",
            "    kformat = _lookup_kformat(pub_key_type)",
            "    pubfields, pubdata = kformat.get_public(pubdata)",
            "    _check_empty(pubdata)",
            "",
            "    # load secret data",
            "    edata, data = _get_sshstr(data)",
            "    _check_empty(data)",
            "",
            "    if (ciphername, kdfname) != (_NONE, _NONE):",
            "        ciphername_bytes = ciphername.tobytes()",
            "        if ciphername_bytes not in _SSH_CIPHERS:",
            "            raise UnsupportedAlgorithm(",
            "                f\"Unsupported cipher: {ciphername_bytes!r}\"",
            "            )",
            "        if kdfname != _BCRYPT:",
            "            raise UnsupportedAlgorithm(f\"Unsupported KDF: {kdfname!r}\")",
            "        blklen = _SSH_CIPHERS[ciphername_bytes][3]",
            "        _check_block_size(edata, blklen)",
            "        salt, kbuf = _get_sshstr(kdfoptions)",
            "        rounds, kbuf = _get_u32(kbuf)",
            "        _check_empty(kbuf)",
            "        ciph = _init_cipher(ciphername_bytes, password, salt.tobytes(), rounds)",
            "        edata = memoryview(ciph.decryptor().update(edata))",
            "    else:",
            "        blklen = 8",
            "        _check_block_size(edata, blklen)",
            "    ck1, edata = _get_u32(edata)",
            "    ck2, edata = _get_u32(edata)",
            "    if ck1 != ck2:",
            "        raise ValueError(\"Corrupt data: broken checksum\")",
            "",
            "    # load per-key struct",
            "    key_type, edata = _get_sshstr(edata)",
            "    if key_type != pub_key_type:",
            "        raise ValueError(\"Corrupt data: key type mismatch\")",
            "    private_key, edata = kformat.load_private(edata, pubfields)",
            "    comment, edata = _get_sshstr(edata)",
            "",
            "    # yes, SSH does padding check *after* all other parsing is done.",
            "    # need to follow as it writes zero-byte padding too.",
            "    if edata != _PADDING[: len(edata)]:",
            "        raise ValueError(\"Corrupt data: invalid padding\")",
            "",
            "    return private_key",
            "",
            "",
            "def _serialize_ssh_private_key(",
            "    private_key: _SSH_PRIVATE_KEY_TYPES,",
            "    password: bytes,",
            "    encryption_algorithm: KeySerializationEncryption,",
            ") -> bytes:",
            "    \"\"\"Serialize private key with OpenSSH custom encoding.\"\"\"",
            "    utils._check_bytes(\"password\", password)",
            "",
            "    key_type = _get_ssh_key_type(private_key)",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    # setup parameters",
            "    f_kdfoptions = _FragList()",
            "    if password:",
            "        ciphername = _DEFAULT_CIPHER",
            "        blklen = _SSH_CIPHERS[ciphername][3]",
            "        kdfname = _BCRYPT",
            "        rounds = _DEFAULT_ROUNDS",
            "        if (",
            "            isinstance(encryption_algorithm, _KeySerializationEncryption)",
            "            and encryption_algorithm._kdf_rounds is not None",
            "        ):",
            "            rounds = encryption_algorithm._kdf_rounds",
            "        salt = os.urandom(16)",
            "        f_kdfoptions.put_sshstr(salt)",
            "        f_kdfoptions.put_u32(rounds)",
            "        ciph = _init_cipher(ciphername, password, salt, rounds)",
            "    else:",
            "        ciphername = kdfname = _NONE",
            "        blklen = 8",
            "        ciph = None",
            "    nkeys = 1",
            "    checkval = os.urandom(4)",
            "    comment = b\"\"",
            "",
            "    # encode public and private parts together",
            "    f_public_key = _FragList()",
            "    f_public_key.put_sshstr(key_type)",
            "    kformat.encode_public(private_key.public_key(), f_public_key)",
            "",
            "    f_secrets = _FragList([checkval, checkval])",
            "    f_secrets.put_sshstr(key_type)",
            "    kformat.encode_private(private_key, f_secrets)",
            "    f_secrets.put_sshstr(comment)",
            "    f_secrets.put_raw(_PADDING[: blklen - (f_secrets.size() % blklen)])",
            "",
            "    # top-level structure",
            "    f_main = _FragList()",
            "    f_main.put_raw(_SK_MAGIC)",
            "    f_main.put_sshstr(ciphername)",
            "    f_main.put_sshstr(kdfname)",
            "    f_main.put_sshstr(f_kdfoptions)",
            "    f_main.put_u32(nkeys)",
            "    f_main.put_sshstr(f_public_key)",
            "    f_main.put_sshstr(f_secrets)",
            "",
            "    # copy result info bytearray",
            "    slen = f_secrets.size()",
            "    mlen = f_main.size()",
            "    buf = memoryview(bytearray(mlen + blklen))",
            "    f_main.render(buf)",
            "    ofs = mlen - slen",
            "",
            "    # encrypt in-place",
            "    if ciph is not None:",
            "        ciph.encryptor().update_into(buf[ofs:mlen], buf[ofs:])",
            "",
            "    return _ssh_pem_encode(buf[:mlen])",
            "",
            "",
            "_SSH_PUBLIC_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePublicKey,",
            "    rsa.RSAPublicKey,",
            "    dsa.DSAPublicKey,",
            "    ed25519.Ed25519PublicKey,",
            "]",
            "",
            "_SSH_CERT_PUBLIC_KEY_TYPES = typing.Union[",
            "    ec.EllipticCurvePublicKey,",
            "    rsa.RSAPublicKey,",
            "    ed25519.Ed25519PublicKey,",
            "]",
            "",
            "",
            "class SSHCertificateType(enum.Enum):",
            "    USER = 1",
            "    HOST = 2",
            "",
            "",
            "class SSHCertificate:",
            "    def __init__(",
            "        self,",
            "        _nonce: memoryview,",
            "        _public_key: _SSH_PUBLIC_KEY_TYPES,",
            "        _serial: int,",
            "        _cctype: int,",
            "        _key_id: memoryview,",
            "        _valid_principals: typing.List[bytes],",
            "        _valid_after: int,",
            "        _valid_before: int,",
            "        _critical_options: typing.Dict[bytes, bytes],",
            "        _extensions: typing.Dict[bytes, bytes],",
            "        _sig_type: memoryview,",
            "        _sig_key: memoryview,",
            "        _inner_sig_type: memoryview,",
            "        _signature: memoryview,",
            "        _tbs_cert_body: memoryview,",
            "        _cert_key_type: bytes,",
            "        _cert_body: memoryview,",
            "    ):",
            "        self._nonce = _nonce",
            "        self._public_key = _public_key",
            "        self._serial = _serial",
            "        try:",
            "            self._type = SSHCertificateType(_cctype)",
            "        except ValueError:",
            "            raise ValueError(\"Invalid certificate type\")",
            "        self._key_id = _key_id",
            "        self._valid_principals = _valid_principals",
            "        self._valid_after = datetime.datetime.utcfromtimestamp(_valid_after)",
            "        self._valid_before = datetime.datetime.utcfromtimestamp(_valid_before)",
            "        self._critical_options = _critical_options",
            "        self._extensions = _extensions",
            "        self._sig_type = _sig_type",
            "        self._sig_key = _sig_key",
            "        self._inner_sig_type = _inner_sig_type",
            "        self._signature = _signature",
            "        self._cert_key_type = _cert_key_type",
            "        self._cert_body = _cert_body",
            "        self._tbs_cert_body = _tbs_cert_body",
            "",
            "    @property",
            "    def nonce(self) -> bytes:",
            "        return bytes(self._nonce)",
            "",
            "    def public_key(self) -> _SSH_CERT_PUBLIC_KEY_TYPES:",
            "        # make mypy happy until we remove DSA support entirely and",
            "        # the underlying union won't have a disallowed type",
            "        assert not isinstance(self._public_key, dsa.DSAPublicKey)",
            "        return self._public_key",
            "",
            "    @property",
            "    def serial(self) -> int:",
            "        return self._serial",
            "",
            "    @property",
            "    def type(self) -> SSHCertificateType:",
            "        return self._type",
            "",
            "    @property",
            "    def key_id(self) -> bytes:",
            "        return bytes(self._key_id)",
            "",
            "    @property",
            "    def valid_principals(self) -> typing.List[bytes]:",
            "        return self._valid_principals",
            "",
            "    @property",
            "    def valid_before(self) -> datetime.datetime:",
            "        return self._valid_before",
            "",
            "    @property",
            "    def valid_after(self) -> datetime.datetime:",
            "        return self._valid_after",
            "",
            "    @property",
            "    def critical_options(self) -> typing.Dict[bytes, bytes]:",
            "        return self._critical_options",
            "",
            "    @property",
            "    def extensions(self) -> typing.Dict[bytes, bytes]:",
            "        return self._extensions",
            "",
            "    def signature_key(self) -> _SSH_CERT_PUBLIC_KEY_TYPES:",
            "        sigformat = _lookup_kformat(self._sig_type)",
            "        signature_key, sigkey_rest = sigformat.load_public(self._sig_key)",
            "        _check_empty(sigkey_rest)",
            "        return signature_key",
            "",
            "    def public_bytes(self) -> bytes:",
            "        return (",
            "            bytes(self._cert_key_type)",
            "            + b\" \"",
            "            + binascii.b2a_base64(bytes(self._cert_body), newline=False)",
            "        )",
            "",
            "    def verify_cert_signature(self) -> None:",
            "        signature_key = self.signature_key()",
            "        if isinstance(signature_key, ed25519.Ed25519PublicKey):",
            "            signature_key.verify(",
            "                bytes(self._signature), bytes(self._tbs_cert_body)",
            "            )",
            "        elif isinstance(signature_key, ec.EllipticCurvePublicKey):",
            "            # The signature is encoded as a pair of big-endian integers",
            "            r, data = _get_mpint(self._signature)",
            "            s, data = _get_mpint(data)",
            "            _check_empty(data)",
            "            computed_sig = asym_utils.encode_dss_signature(r, s)",
            "            hash_alg = _get_ec_hash_alg(signature_key.curve)",
            "            signature_key.verify(",
            "                computed_sig, bytes(self._tbs_cert_body), ec.ECDSA(hash_alg)",
            "            )",
            "        else:",
            "            assert isinstance(signature_key, rsa.RSAPublicKey)",
            "            if self._inner_sig_type == _SSH_RSA:",
            "                hash_alg = hashes.SHA1()",
            "            elif self._inner_sig_type == _SSH_RSA_SHA256:",
            "                hash_alg = hashes.SHA256()",
            "            else:",
            "                assert self._inner_sig_type == _SSH_RSA_SHA512",
            "                hash_alg = hashes.SHA512()",
            "            signature_key.verify(",
            "                bytes(self._signature),",
            "                bytes(self._tbs_cert_body),",
            "                padding.PKCS1v15(),",
            "                hash_alg,",
            "            )",
            "",
            "",
            "def _get_ec_hash_alg(curve: ec.EllipticCurve) -> hashes.HashAlgorithm:",
            "    hash_alg: hashes.HashAlgorithm",
            "    if isinstance(curve, ec.SECP256R1):",
            "        hash_alg = hashes.SHA256()",
            "    elif isinstance(curve, ec.SECP384R1):",
            "        hash_alg = hashes.SHA384()",
            "    else:",
            "        assert isinstance(curve, ec.SECP521R1)",
            "        hash_alg = hashes.SHA512()",
            "    return hash_alg",
            "",
            "",
            "def load_ssh_public_identity(",
            "    data: bytes,",
            ") -> typing.Union[SSHCertificate, _SSH_PUBLIC_KEY_TYPES]:",
            "    utils._check_byteslike(\"data\", data)",
            "",
            "    m = _SSH_PUBKEY_RC.match(data)",
            "    if not m:",
            "        raise ValueError(\"Invalid line format\")",
            "    key_type = orig_key_type = m.group(1)",
            "    key_body = m.group(2)",
            "    with_cert = False",
            "    if key_type.endswith(_CERT_SUFFIX):",
            "        with_cert = True",
            "        key_type = key_type[: -len(_CERT_SUFFIX)]",
            "    if key_type == _SSH_DSA:",
            "        raise UnsupportedAlgorithm(",
            "            \"DSA keys aren't supported in SSH certificates\"",
            "        )",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    try:",
            "        rest = memoryview(binascii.a2b_base64(key_body))",
            "    except (TypeError, binascii.Error):",
            "        raise ValueError(\"Invalid format\")",
            "",
            "    if with_cert:",
            "        cert_body = rest",
            "    inner_key_type, rest = _get_sshstr(rest)",
            "    if inner_key_type != orig_key_type:",
            "        raise ValueError(\"Invalid key format\")",
            "    if with_cert:",
            "        nonce, rest = _get_sshstr(rest)",
            "    public_key, rest = kformat.load_public(rest)",
            "    if with_cert:",
            "        serial, rest = _get_u64(rest)",
            "        cctype, rest = _get_u32(rest)",
            "        key_id, rest = _get_sshstr(rest)",
            "        principals, rest = _get_sshstr(rest)",
            "        valid_principals = []",
            "        while principals:",
            "            principal, principals = _get_sshstr(principals)",
            "            valid_principals.append(bytes(principal))",
            "        valid_after, rest = _get_u64(rest)",
            "        valid_before, rest = _get_u64(rest)",
            "        crit_options, rest = _get_sshstr(rest)",
            "        critical_options = _parse_exts_opts(crit_options)",
            "        exts, rest = _get_sshstr(rest)",
            "        extensions = _parse_exts_opts(exts)",
            "        # Get the reserved field, which is unused.",
            "        _, rest = _get_sshstr(rest)",
            "        sig_key_raw, rest = _get_sshstr(rest)",
            "        sig_type, sig_key = _get_sshstr(sig_key_raw)",
            "        if sig_type == _SSH_DSA:",
            "            raise UnsupportedAlgorithm(",
            "                \"DSA signatures aren't supported in SSH certificates\"",
            "            )",
            "        # Get the entire cert body and subtract the signature",
            "        tbs_cert_body = cert_body[: -len(rest)]",
            "        signature_raw, rest = _get_sshstr(rest)",
            "        _check_empty(rest)",
            "        inner_sig_type, sig_rest = _get_sshstr(signature_raw)",
            "        # RSA certs can have multiple algorithm types",
            "        if (",
            "            sig_type == _SSH_RSA",
            "            and inner_sig_type",
            "            not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]",
            "        ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):",
            "            raise ValueError(\"Signature key type does not match\")",
            "        signature, sig_rest = _get_sshstr(sig_rest)",
            "        _check_empty(sig_rest)",
            "        return SSHCertificate(",
            "            nonce,",
            "            public_key,",
            "            serial,",
            "            cctype,",
            "            key_id,",
            "            valid_principals,",
            "            valid_after,",
            "            valid_before,",
            "            critical_options,",
            "            extensions,",
            "            sig_type,",
            "            sig_key,",
            "            inner_sig_type,",
            "            signature,",
            "            tbs_cert_body,",
            "            orig_key_type,",
            "            cert_body,",
            "        )",
            "    else:",
            "        _check_empty(rest)",
            "        return public_key",
            "",
            "",
            "def _parse_exts_opts(exts_opts: memoryview) -> typing.Dict[bytes, bytes]:",
            "    result: typing.Dict[bytes, bytes] = {}",
            "    last_name = None",
            "    while exts_opts:",
            "        name, exts_opts = _get_sshstr(exts_opts)",
            "        bname: bytes = bytes(name)",
            "        if bname in result:",
            "            raise ValueError(\"Duplicate name\")",
            "        if last_name is not None and bname < last_name:",
            "            raise ValueError(\"Fields not lexically sorted\")",
            "        value, exts_opts = _get_sshstr(exts_opts)",
            "        result[bname] = bytes(value)",
            "        last_name = bname",
            "    return result",
            "",
            "",
            "def load_ssh_public_key(",
            "    data: bytes, backend: typing.Any = None",
            ") -> _SSH_PUBLIC_KEY_TYPES:",
            "    \"\"\"Load public key from OpenSSH one-line format.\"\"\"",
            "    utils._check_byteslike(\"data\", data)",
            "",
            "    m = _SSH_PUBKEY_RC.match(data)",
            "    if not m:",
            "        raise ValueError(\"Invalid line format\")",
            "    key_type = orig_key_type = m.group(1)",
            "    key_body = m.group(2)",
            "    with_cert = False",
            "    if _CERT_SUFFIX == key_type[-len(_CERT_SUFFIX) :]:",
            "        with_cert = True",
            "        key_type = key_type[: -len(_CERT_SUFFIX)]",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    try:",
            "        rest = memoryview(binascii.a2b_base64(key_body))",
            "    except (TypeError, binascii.Error):",
            "        raise ValueError(\"Invalid key format\")",
            "",
            "    inner_key_type, rest = _get_sshstr(rest)",
            "    if inner_key_type != orig_key_type:",
            "        raise ValueError(\"Invalid key format\")",
            "    if with_cert:",
            "        nonce, rest = _get_sshstr(rest)",
            "    public_key, rest = kformat.load_public(rest)",
            "    if with_cert:",
            "        serial, rest = _get_u64(rest)",
            "        cctype, rest = _get_u32(rest)",
            "        key_id, rest = _get_sshstr(rest)",
            "        principals, rest = _get_sshstr(rest)",
            "        valid_after, rest = _get_u64(rest)",
            "        valid_before, rest = _get_u64(rest)",
            "        crit_options, rest = _get_sshstr(rest)",
            "        extensions, rest = _get_sshstr(rest)",
            "        reserved, rest = _get_sshstr(rest)",
            "        sig_key, rest = _get_sshstr(rest)",
            "        signature, rest = _get_sshstr(rest)",
            "    _check_empty(rest)",
            "    return public_key",
            "",
            "",
            "def serialize_ssh_public_key(public_key: _SSH_PUBLIC_KEY_TYPES) -> bytes:",
            "    \"\"\"One-line public key format for OpenSSH\"\"\"",
            "    key_type = _get_ssh_key_type(public_key)",
            "    kformat = _lookup_kformat(key_type)",
            "",
            "    f_pub = _FragList()",
            "    f_pub.put_sshstr(key_type)",
            "    kformat.encode_public(public_key, f_pub)",
            "",
            "    pub = binascii.b2a_base64(f_pub.tobytes()).strip()",
            "    return b\"\".join([key_type, b\" \", pub])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "741": [
                "SSHCertificate",
                "__init__"
            ],
            "744": [
                "SSHCertificate",
                "__init__"
            ],
            "745": [
                "SSHCertificate",
                "__init__"
            ],
            "797": [
                "SSHCertificate"
            ],
            "799": [
                "SSHCertificate",
                "valid_principals"
            ],
            "800": [
                "SSHCertificate",
                "valid_principals"
            ],
            "801": [
                "SSHCertificate",
                "valid_principals"
            ],
            "802": [
                "SSHCertificate",
                "valid_principals"
            ],
            "803": [
                "SSHCertificate",
                "valid_principals"
            ],
            "804": [
                "SSHCertificate",
                "valid_principals"
            ],
            "805": [
                "SSHCertificate",
                "valid_principals"
            ],
            "815": [
                "SSHCertificate"
            ],
            "817": [
                "SSHCertificate",
                "critical_options"
            ],
            "819": [
                "SSHCertificate"
            ],
            "821": [
                "SSHCertificate",
                "extensions"
            ],
            "822": [
                "SSHCertificate"
            ],
            "823": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "824": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "825": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "826": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "827": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "828": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "829": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "830": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "831": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "832": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "833": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "834": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "835": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "836": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "837": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "838": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "839": [
                "SSHCertificate",
                "_parse_exts_opts"
            ],
            "899": [
                "load_ssh_certificate"
            ],
            "907": [
                "load_ssh_certificate"
            ],
            "908": [
                "load_ssh_certificate"
            ],
            "909": [
                "load_ssh_certificate"
            ],
            "922": [
                "load_ssh_certificate"
            ],
            "926": [
                "load_ssh_certificate"
            ],
            "928": [
                "load_ssh_certificate"
            ],
            "929": [
                "load_ssh_certificate"
            ],
            "930": [
                "load_ssh_certificate"
            ],
            "931": [
                "load_ssh_certificate"
            ],
            "932": [
                "load_ssh_certificate"
            ],
            "933": [
                "load_ssh_certificate"
            ],
            "934": [
                "load_ssh_certificate"
            ],
            "935": [
                "load_ssh_certificate"
            ],
            "936": [
                "load_ssh_certificate"
            ],
            "937": [
                "load_ssh_certificate"
            ],
            "938": [
                "load_ssh_certificate"
            ],
            "939": [
                "load_ssh_certificate"
            ],
            "940": [
                "load_ssh_certificate"
            ],
            "941": [
                "load_ssh_certificate"
            ],
            "942": [
                "load_ssh_certificate"
            ],
            "944": [
                "load_ssh_certificate"
            ],
            "945": [
                "load_ssh_certificate"
            ],
            "946": [
                "load_ssh_certificate"
            ],
            "947": [
                "load_ssh_certificate"
            ],
            "948": [
                "load_ssh_certificate"
            ],
            "949": [
                "load_ssh_certificate"
            ],
            "950": [
                "load_ssh_certificate"
            ],
            "951": [
                "load_ssh_certificate"
            ],
            "952": [
                "load_ssh_certificate"
            ],
            "953": [
                "load_ssh_certificate"
            ],
            "954": [
                "load_ssh_certificate"
            ],
            "955": [
                "load_ssh_certificate"
            ],
            "956": [
                "load_ssh_certificate"
            ],
            "957": [
                "load_ssh_certificate"
            ],
            "958": [
                "load_ssh_certificate"
            ],
            "959": [
                "load_ssh_certificate"
            ],
            "960": [
                "load_ssh_certificate"
            ],
            "961": [
                "load_ssh_certificate"
            ],
            "962": [
                "load_ssh_certificate"
            ],
            "963": [
                "load_ssh_certificate"
            ],
            "964": [
                "load_ssh_certificate"
            ],
            "965": [
                "load_ssh_certificate"
            ],
            "966": [
                "load_ssh_certificate"
            ],
            "967": [
                "load_ssh_certificate"
            ],
            "968": [
                "load_ssh_certificate"
            ],
            "969": [
                "load_ssh_certificate"
            ],
            "970": [
                "load_ssh_certificate"
            ],
            "971": [
                "load_ssh_certificate"
            ],
            "972": [
                "load_ssh_certificate"
            ],
            "973": [
                "load_ssh_certificate"
            ],
            "974": [
                "load_ssh_certificate"
            ],
            "975": [
                "load_ssh_certificate"
            ]
        },
        "addLocation": []
    }
}