{
    "lollms/security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     if not allow_absolute_path and path.strip().startswith(\"/\"):"
            },
            "1": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         raise HTTPException(status_code=400, detail=exception_text)"
            },
            "2": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+    # Normalize path to use forward slashes"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    path = path.replace('\\\\', '/')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     if path is None:"
            },
            "7": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         return path"
            },
            "8": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     "
            },
            "10": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:"
            },
            "11": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+    and standardizing path separators to prevent directory traversal attacks."
            },
            "15": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     Args:"
            },
            "17": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     -----"
            },
            "18": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     path (str): The file path to sanitize."
            },
            "19": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    error_text (str, optional): The error message to display if a path traversal or unauthorized character is detected. Default is \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\"."
            },
            "20": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    exception_text (str, optional): The exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\"."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\"."
            },
            "23": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     Raises:"
            },
            "25": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     ------"
            },
            "26": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     Returns:"
            },
            "27": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     -------"
            },
            "28": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     str: The sanitized file path."
            },
            "29": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "30": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Note:"
            },
            "31": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    -----"
            },
            "32": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    This function checks for patterns like \"....\" and multiple forward slashes. It also checks for unauthorized punctuation characters, excluding the dot (.) character."
            },
            "33": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     \"\"\""
            },
            "34": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     if path is None:"
            },
            "36": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         return path"
            },
            "37": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    # Normalize path to use forward slashes"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    path = path.replace('\\\\', '/')"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     if path.strip().startswith(\"/\"):"
            },
            "42": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         raise HTTPException(status_code=400, detail=exception_text)"
            },
            "43": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         raise HTTPException(status_code=400, detail=exception_text)"
            },
            "45": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     if suspicious_patterns.search(path) or Path(path).is_absolute():"
            },
            "47": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ASCIIColors.error(error_text)"
            },
            "48": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(status_code=400, detail=exception_text)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        raise HTTPException(status_code=400, detail=error_text)"
            },
            "50": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     path = path.lstrip('/')"
            },
            "52": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "     return path"
            },
            "53": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 196,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):"
            },
            "57": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":"
            },
            "58": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         raise Exception(exception_text)"
            }
        },
        "frontPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,:;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): The error message to display if a path traversal or unauthorized character is detected. Default is \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\".",
            "    exception_text (str, optional): The exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\" and multiple forward slashes. It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,:;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "afterPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,:;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,",
            "    and standardizing path separators to prevent directory traversal attacks.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack.",
            "    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,:;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        raise HTTPException(status_code=400, detail=error_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "152": [
                "sanitize_path_from_endpoint"
            ],
            "157": [
                "sanitize_path_from_endpoint"
            ],
            "158": [
                "sanitize_path_from_endpoint"
            ],
            "167": [
                "sanitize_path_from_endpoint"
            ],
            "168": [
                "sanitize_path_from_endpoint"
            ],
            "169": [
                "sanitize_path_from_endpoint"
            ],
            "170": [
                "sanitize_path_from_endpoint"
            ],
            "188": [
                "sanitize_path_from_endpoint"
            ],
            "189": [
                "sanitize_path_from_endpoint"
            ]
        },
        "addLocation": [
            "src.octoprint.server.api"
        ]
    }
}