{
    "airflow/www/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from airflow.providers_manager import ProvidersManager"
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " from airflow.utils import timezone"
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " from airflow.utils.types import DagRunType"
            },
            "3": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from airflow.www.validators import ValidKey"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+from airflow.www.validators import ReadOnly, ValidKey"
            },
            "5": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " from airflow.www.widgets import ("
            },
            "6": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     AirflowDateTimePickerROWidget,"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     AirflowDateTimePickerWidget,"
            },
            "8": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     We don't actually want to allow editing, so everything is read-only here."
            },
            "9": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     \"\"\""
            },
            "10": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    dag_id = StringField(lazy_gettext(\"Dag Id\"), widget=BS3TextFieldROWidget())"
            },
            "12": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    start_date = DateTimeWithTimezoneField(lazy_gettext(\"Start Date\"), widget=AirflowDateTimePickerROWidget())"
            },
            "13": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    end_date = DateTimeWithTimezoneField(lazy_gettext(\"End Date\"), widget=AirflowDateTimePickerROWidget())"
            },
            "14": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    run_id = StringField(lazy_gettext(\"Run Id\"), widget=BS3TextFieldROWidget())"
            },
            "15": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    state = StringField(lazy_gettext(\"State\"), widget=BS3TextFieldROWidget())"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+    dag_id = StringField(lazy_gettext(\"Dag Id\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    start_date = DateTimeWithTimezoneField("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        lazy_gettext(\"Start Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    )"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    end_date = DateTimeWithTimezoneField("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        lazy_gettext(\"End Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    )"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    run_id = StringField(lazy_gettext(\"Run Id\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    state = StringField(lazy_gettext(\"State\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())"
            },
            "25": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     execution_date = DateTimeWithTimezoneField("
            },
            "26": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         lazy_gettext(\"Logical Date\"),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        validators=[ReadOnly()],"
            },
            "28": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         widget=AirflowDateTimePickerROWidget(),"
            },
            "29": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     )"
            },
            "30": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    conf = TextAreaField(lazy_gettext(\"Conf\"), widget=BS3TextAreaROWidget())"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    conf = TextAreaField(lazy_gettext(\"Conf\"), validators=[ReadOnly()], widget=BS3TextAreaROWidget())"
            },
            "32": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())"
            },
            "33": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     def populate_obj(self, item):"
            },
            "35": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Populates the attributes of the passed obj with data from the form's fields.\"\"\""
            },
            "36": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super().populate_obj(item)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        \"\"\"Populates the attributes of the passed obj with data from the form's not-read-only fields.\"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        for name, field in self._fields.items():"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            if not field.flags.readonly:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                field.populate_obj(item, name)"
            },
            "41": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         item.run_type = DagRunType.from_run_id(item.run_id)"
            },
            "42": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         if item.conf:"
            },
            "43": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             item.conf = json.loads(item.conf)"
            },
            "44": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " class TaskInstanceEditForm(DynamicForm):"
            },
            "45": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     \"\"\"Form for editing TaskInstance.\"\"\""
            },
            "46": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    dag_id = StringField(lazy_gettext(\"Dag Id\"), validators=[InputRequired()], widget=BS3TextFieldROWidget())"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    dag_id = StringField("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        lazy_gettext(\"Dag Id\"), validators=[InputRequired(), ReadOnly()], widget=BS3TextFieldROWidget()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    )"
            },
            "51": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     task_id = StringField("
            },
            "52": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        lazy_gettext(\"Task Id\"), validators=[InputRequired()], widget=BS3TextFieldROWidget()"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        lazy_gettext(\"Task Id\"), validators=[InputRequired(), ReadOnly()], widget=BS3TextFieldROWidget()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+    )"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+    start_date = DateTimeWithTimezoneField("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        lazy_gettext(\"Start Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    )"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    end_date = DateTimeWithTimezoneField("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        lazy_gettext(\"End Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()"
            },
            "60": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     )"
            },
            "61": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    start_date = DateTimeWithTimezoneField(lazy_gettext(\"Start Date\"), widget=AirflowDateTimePickerROWidget())"
            },
            "62": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    end_date = DateTimeWithTimezoneField(lazy_gettext(\"End Date\"), widget=AirflowDateTimePickerROWidget())"
            },
            "63": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     state = SelectField("
            },
            "64": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "         lazy_gettext(\"State\"),"
            },
            "65": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         choices=("
            },
            "66": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     execution_date = DateTimeWithTimezoneField("
            },
            "67": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         lazy_gettext(\"Logical Date\"),"
            },
            "68": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         widget=AirflowDateTimePickerROWidget(),"
            },
            "69": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validators=[InputRequired()],"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        validators=[InputRequired(), ReadOnly()],"
            },
            "71": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     )"
            },
            "72": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())"
            },
            "73": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    def populate_obj(self, item):"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        \"\"\"Populates the attributes of the passed obj with data from the form's not-read-only fields.\"\"\""
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        for name, field in self._fields.items():"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            if not field.flags.readonly:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                field.populate_obj(item, name)"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " @cache"
            },
            "82": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " def create_connection_form_class() -> type[DynamicForm]:"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "import operator",
            "from datetime import datetime as dt",
            "from typing import Iterator",
            "",
            "import pendulum",
            "from flask_appbuilder.fieldwidgets import (",
            "    BS3PasswordFieldWidget,",
            "    BS3TextAreaFieldWidget,",
            "    BS3TextFieldWidget,",
            "    Select2Widget,",
            ")",
            "from flask_appbuilder.forms import DynamicForm",
            "from flask_babel import lazy_gettext",
            "from flask_wtf import FlaskForm",
            "from wtforms import widgets",
            "from wtforms.fields import Field, IntegerField, PasswordField, SelectField, StringField, TextAreaField",
            "from wtforms.validators import InputRequired, Optional",
            "",
            "from airflow.compat.functools import cache",
            "from airflow.configuration import conf",
            "from airflow.providers_manager import ProvidersManager",
            "from airflow.utils import timezone",
            "from airflow.utils.types import DagRunType",
            "from airflow.www.validators import ValidKey",
            "from airflow.www.widgets import (",
            "    AirflowDateTimePickerROWidget,",
            "    AirflowDateTimePickerWidget,",
            "    BS3TextAreaROWidget,",
            "    BS3TextFieldROWidget,",
            ")",
            "",
            "",
            "class DateTimeWithTimezoneField(Field):",
            "    \"\"\"A text field which stores a `datetime.datetime` matching a format.\"\"\"",
            "",
            "    widget = widgets.TextInput()",
            "",
            "    def __init__(self, label=None, validators=None, datetime_format=\"%Y-%m-%d %H:%M:%S%Z\", **kwargs):",
            "        super().__init__(label, validators, **kwargs)",
            "        self.format = datetime_format",
            "        self.data = None",
            "",
            "    def _value(self):",
            "        if self.raw_data:",
            "            return \" \".join(self.raw_data)",
            "        if self.data:",
            "            return self.data.strftime(self.format)",
            "        return \"\"",
            "",
            "    def process_formdata(self, valuelist):",
            "        if not valuelist:",
            "            return",
            "        date_str = \" \".join(valuelist)",
            "        try:",
            "            # Check if the datetime string is in the format without timezone, if so convert it to the",
            "            # default timezone",
            "            if len(date_str) == 19:",
            "                parsed_datetime = dt.strptime(date_str, \"%Y-%m-%d %H:%M:%S\")",
            "                default_timezone = self._get_default_timezone()",
            "                self.data = default_timezone.convert(parsed_datetime)",
            "            else:",
            "                self.data = pendulum.parse(date_str)",
            "        except ValueError:",
            "            self.data = None",
            "            raise ValueError(self.gettext(\"Not a valid datetime value\"))",
            "",
            "    def _get_default_timezone(self):",
            "        current_timezone = conf.get(\"core\", \"default_timezone\")",
            "        if current_timezone == \"system\":",
            "            default_timezone = pendulum.local_timezone()",
            "        else:",
            "            default_timezone = pendulum.timezone(current_timezone)",
            "        return default_timezone",
            "",
            "",
            "class DateTimeForm(FlaskForm):",
            "    \"\"\"Date filter form needed for task views.\"\"\"",
            "",
            "    execution_date = DateTimeWithTimezoneField(\"Logical date\", widget=AirflowDateTimePickerWidget())",
            "",
            "",
            "class DateTimeWithNumRunsForm(FlaskForm):",
            "    \"\"\"Date time and number of runs form for tree view, task duration and landing times.\"\"\"",
            "",
            "    base_date = DateTimeWithTimezoneField(",
            "        \"Anchor date\", widget=AirflowDateTimePickerWidget(), default=timezone.utcnow()",
            "    )",
            "    num_runs = SelectField(",
            "        \"Number of runs\",",
            "        default=25,",
            "        choices=(",
            "            (5, \"5\"),",
            "            (25, \"25\"),",
            "            (50, \"50\"),",
            "            (100, \"100\"),",
            "            (365, \"365\"),",
            "        ),",
            "    )",
            "",
            "",
            "class DagRunEditForm(DynamicForm):",
            "    \"\"\"Form for editing DAG Run.",
            "",
            "    We don't actually want to allow editing, so everything is read-only here.",
            "    \"\"\"",
            "",
            "    dag_id = StringField(lazy_gettext(\"Dag Id\"), widget=BS3TextFieldROWidget())",
            "    start_date = DateTimeWithTimezoneField(lazy_gettext(\"Start Date\"), widget=AirflowDateTimePickerROWidget())",
            "    end_date = DateTimeWithTimezoneField(lazy_gettext(\"End Date\"), widget=AirflowDateTimePickerROWidget())",
            "    run_id = StringField(lazy_gettext(\"Run Id\"), widget=BS3TextFieldROWidget())",
            "    state = StringField(lazy_gettext(\"State\"), widget=BS3TextFieldROWidget())",
            "    execution_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Logical Date\"),",
            "        widget=AirflowDateTimePickerROWidget(),",
            "    )",
            "    conf = TextAreaField(lazy_gettext(\"Conf\"), widget=BS3TextAreaROWidget())",
            "    note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())",
            "",
            "    def populate_obj(self, item):",
            "        \"\"\"Populates the attributes of the passed obj with data from the form's fields.\"\"\"",
            "        super().populate_obj(item)",
            "        item.run_type = DagRunType.from_run_id(item.run_id)",
            "        if item.conf:",
            "            item.conf = json.loads(item.conf)",
            "",
            "",
            "class TaskInstanceEditForm(DynamicForm):",
            "    \"\"\"Form for editing TaskInstance.\"\"\"",
            "",
            "    dag_id = StringField(lazy_gettext(\"Dag Id\"), validators=[InputRequired()], widget=BS3TextFieldROWidget())",
            "    task_id = StringField(",
            "        lazy_gettext(\"Task Id\"), validators=[InputRequired()], widget=BS3TextFieldROWidget()",
            "    )",
            "    start_date = DateTimeWithTimezoneField(lazy_gettext(\"Start Date\"), widget=AirflowDateTimePickerROWidget())",
            "    end_date = DateTimeWithTimezoneField(lazy_gettext(\"End Date\"), widget=AirflowDateTimePickerROWidget())",
            "    state = SelectField(",
            "        lazy_gettext(\"State\"),",
            "        choices=(",
            "            (\"success\", \"success\"),",
            "            (\"running\", \"running\"),",
            "            (\"failed\", \"failed\"),",
            "            (\"up_for_retry\", \"up_for_retry\"),",
            "        ),",
            "        widget=Select2Widget(),",
            "        validators=[InputRequired()],",
            "    )",
            "    execution_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Logical Date\"),",
            "        widget=AirflowDateTimePickerROWidget(),",
            "        validators=[InputRequired()],",
            "    )",
            "    note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())",
            "",
            "",
            "@cache",
            "def create_connection_form_class() -> type[DynamicForm]:",
            "    \"\"\"Create a form class for editing and adding Connection.",
            "",
            "    This class is created dynamically because it relies heavily on run-time",
            "    provider discovery, which slows down webserver startup a lot.",
            "    By creating the class at runtime, we can delay loading the providers until",
            "    when the connection form is first used, which may as well be never for a",
            "    short-lived server.",
            "    \"\"\"",
            "    providers_manager = ProvidersManager()",
            "",
            "    def _iter_connection_types() -> Iterator[tuple[str, str]]:",
            "        \"\"\"List available connection types.\"\"\"",
            "        for connection_type, provider_info in providers_manager.hooks.items():",
            "            if provider_info:",
            "                yield (connection_type, provider_info.hook_name)",
            "",
            "    class ConnectionForm(DynamicForm):",
            "        def process(self, formdata=None, obj=None, **kwargs):",
            "            super().process(formdata=formdata, obj=obj, **kwargs)",
            "            for field in self._fields.values():",
            "                if isinstance(getattr(field, \"data\", None), str):",
            "                    field.data = field.data.strip()",
            "",
            "        conn_id = StringField(",
            "            lazy_gettext(\"Connection Id\"),",
            "            validators=[InputRequired(), ValidKey()],",
            "            widget=BS3TextFieldWidget(),",
            "        )",
            "        conn_type = SelectField(",
            "            lazy_gettext(\"Connection Type\"),",
            "            choices=sorted(_iter_connection_types(), key=operator.itemgetter(1)),",
            "            widget=Select2Widget(),",
            "            validators=[InputRequired()],",
            "            description=(",
            "                \"Connection Type missing? Make sure you've installed the \"",
            "                \"corresponding Airflow Provider Package.\"",
            "            ),",
            "        )",
            "        description = StringField(lazy_gettext(\"Description\"), widget=BS3TextAreaFieldWidget())",
            "        host = StringField(lazy_gettext(\"Host\"), widget=BS3TextFieldWidget())",
            "        schema = StringField(lazy_gettext(\"Schema\"), widget=BS3TextFieldWidget())",
            "        login = StringField(lazy_gettext(\"Login\"), widget=BS3TextFieldWidget())",
            "        password = PasswordField(lazy_gettext(\"Password\"), widget=BS3PasswordFieldWidget())",
            "        port = IntegerField(lazy_gettext(\"Port\"), validators=[Optional()], widget=BS3TextFieldWidget())",
            "        extra = TextAreaField(lazy_gettext(\"Extra\"), widget=BS3TextAreaFieldWidget())",
            "",
            "    for key, value in providers_manager.connection_form_widgets.items():",
            "        setattr(ConnectionForm, key, value.field)",
            "",
            "    return ConnectionForm"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "import operator",
            "from datetime import datetime as dt",
            "from typing import Iterator",
            "",
            "import pendulum",
            "from flask_appbuilder.fieldwidgets import (",
            "    BS3PasswordFieldWidget,",
            "    BS3TextAreaFieldWidget,",
            "    BS3TextFieldWidget,",
            "    Select2Widget,",
            ")",
            "from flask_appbuilder.forms import DynamicForm",
            "from flask_babel import lazy_gettext",
            "from flask_wtf import FlaskForm",
            "from wtforms import widgets",
            "from wtforms.fields import Field, IntegerField, PasswordField, SelectField, StringField, TextAreaField",
            "from wtforms.validators import InputRequired, Optional",
            "",
            "from airflow.compat.functools import cache",
            "from airflow.configuration import conf",
            "from airflow.providers_manager import ProvidersManager",
            "from airflow.utils import timezone",
            "from airflow.utils.types import DagRunType",
            "from airflow.www.validators import ReadOnly, ValidKey",
            "from airflow.www.widgets import (",
            "    AirflowDateTimePickerROWidget,",
            "    AirflowDateTimePickerWidget,",
            "    BS3TextAreaROWidget,",
            "    BS3TextFieldROWidget,",
            ")",
            "",
            "",
            "class DateTimeWithTimezoneField(Field):",
            "    \"\"\"A text field which stores a `datetime.datetime` matching a format.\"\"\"",
            "",
            "    widget = widgets.TextInput()",
            "",
            "    def __init__(self, label=None, validators=None, datetime_format=\"%Y-%m-%d %H:%M:%S%Z\", **kwargs):",
            "        super().__init__(label, validators, **kwargs)",
            "        self.format = datetime_format",
            "        self.data = None",
            "",
            "    def _value(self):",
            "        if self.raw_data:",
            "            return \" \".join(self.raw_data)",
            "        if self.data:",
            "            return self.data.strftime(self.format)",
            "        return \"\"",
            "",
            "    def process_formdata(self, valuelist):",
            "        if not valuelist:",
            "            return",
            "        date_str = \" \".join(valuelist)",
            "        try:",
            "            # Check if the datetime string is in the format without timezone, if so convert it to the",
            "            # default timezone",
            "            if len(date_str) == 19:",
            "                parsed_datetime = dt.strptime(date_str, \"%Y-%m-%d %H:%M:%S\")",
            "                default_timezone = self._get_default_timezone()",
            "                self.data = default_timezone.convert(parsed_datetime)",
            "            else:",
            "                self.data = pendulum.parse(date_str)",
            "        except ValueError:",
            "            self.data = None",
            "            raise ValueError(self.gettext(\"Not a valid datetime value\"))",
            "",
            "    def _get_default_timezone(self):",
            "        current_timezone = conf.get(\"core\", \"default_timezone\")",
            "        if current_timezone == \"system\":",
            "            default_timezone = pendulum.local_timezone()",
            "        else:",
            "            default_timezone = pendulum.timezone(current_timezone)",
            "        return default_timezone",
            "",
            "",
            "class DateTimeForm(FlaskForm):",
            "    \"\"\"Date filter form needed for task views.\"\"\"",
            "",
            "    execution_date = DateTimeWithTimezoneField(\"Logical date\", widget=AirflowDateTimePickerWidget())",
            "",
            "",
            "class DateTimeWithNumRunsForm(FlaskForm):",
            "    \"\"\"Date time and number of runs form for tree view, task duration and landing times.\"\"\"",
            "",
            "    base_date = DateTimeWithTimezoneField(",
            "        \"Anchor date\", widget=AirflowDateTimePickerWidget(), default=timezone.utcnow()",
            "    )",
            "    num_runs = SelectField(",
            "        \"Number of runs\",",
            "        default=25,",
            "        choices=(",
            "            (5, \"5\"),",
            "            (25, \"25\"),",
            "            (50, \"50\"),",
            "            (100, \"100\"),",
            "            (365, \"365\"),",
            "        ),",
            "    )",
            "",
            "",
            "class DagRunEditForm(DynamicForm):",
            "    \"\"\"Form for editing DAG Run.",
            "",
            "    We don't actually want to allow editing, so everything is read-only here.",
            "    \"\"\"",
            "",
            "    dag_id = StringField(lazy_gettext(\"Dag Id\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())",
            "    start_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Start Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()",
            "    )",
            "    end_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"End Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()",
            "    )",
            "    run_id = StringField(lazy_gettext(\"Run Id\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())",
            "    state = StringField(lazy_gettext(\"State\"), validators=[ReadOnly()], widget=BS3TextFieldROWidget())",
            "    execution_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Logical Date\"),",
            "        validators=[ReadOnly()],",
            "        widget=AirflowDateTimePickerROWidget(),",
            "    )",
            "    conf = TextAreaField(lazy_gettext(\"Conf\"), validators=[ReadOnly()], widget=BS3TextAreaROWidget())",
            "    note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())",
            "",
            "    def populate_obj(self, item):",
            "        \"\"\"Populates the attributes of the passed obj with data from the form's not-read-only fields.\"\"\"",
            "        for name, field in self._fields.items():",
            "            if not field.flags.readonly:",
            "                field.populate_obj(item, name)",
            "        item.run_type = DagRunType.from_run_id(item.run_id)",
            "        if item.conf:",
            "            item.conf = json.loads(item.conf)",
            "",
            "",
            "class TaskInstanceEditForm(DynamicForm):",
            "    \"\"\"Form for editing TaskInstance.\"\"\"",
            "",
            "    dag_id = StringField(",
            "        lazy_gettext(\"Dag Id\"), validators=[InputRequired(), ReadOnly()], widget=BS3TextFieldROWidget()",
            "    )",
            "    task_id = StringField(",
            "        lazy_gettext(\"Task Id\"), validators=[InputRequired(), ReadOnly()], widget=BS3TextFieldROWidget()",
            "    )",
            "    start_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Start Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()",
            "    )",
            "    end_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"End Date\"), validators=[ReadOnly()], widget=AirflowDateTimePickerROWidget()",
            "    )",
            "    state = SelectField(",
            "        lazy_gettext(\"State\"),",
            "        choices=(",
            "            (\"success\", \"success\"),",
            "            (\"running\", \"running\"),",
            "            (\"failed\", \"failed\"),",
            "            (\"up_for_retry\", \"up_for_retry\"),",
            "        ),",
            "        widget=Select2Widget(),",
            "        validators=[InputRequired()],",
            "    )",
            "    execution_date = DateTimeWithTimezoneField(",
            "        lazy_gettext(\"Logical Date\"),",
            "        widget=AirflowDateTimePickerROWidget(),",
            "        validators=[InputRequired(), ReadOnly()],",
            "    )",
            "    note = TextAreaField(lazy_gettext(\"User Note\"), widget=BS3TextAreaFieldWidget())",
            "",
            "    def populate_obj(self, item):",
            "        \"\"\"Populates the attributes of the passed obj with data from the form's not-read-only fields.\"\"\"",
            "        for name, field in self._fields.items():",
            "            if not field.flags.readonly:",
            "                field.populate_obj(item, name)",
            "",
            "",
            "@cache",
            "def create_connection_form_class() -> type[DynamicForm]:",
            "    \"\"\"Create a form class for editing and adding Connection.",
            "",
            "    This class is created dynamically because it relies heavily on run-time",
            "    provider discovery, which slows down webserver startup a lot.",
            "    By creating the class at runtime, we can delay loading the providers until",
            "    when the connection form is first used, which may as well be never for a",
            "    short-lived server.",
            "    \"\"\"",
            "    providers_manager = ProvidersManager()",
            "",
            "    def _iter_connection_types() -> Iterator[tuple[str, str]]:",
            "        \"\"\"List available connection types.\"\"\"",
            "        for connection_type, provider_info in providers_manager.hooks.items():",
            "            if provider_info:",
            "                yield (connection_type, provider_info.hook_name)",
            "",
            "    class ConnectionForm(DynamicForm):",
            "        def process(self, formdata=None, obj=None, **kwargs):",
            "            super().process(formdata=formdata, obj=obj, **kwargs)",
            "            for field in self._fields.values():",
            "                if isinstance(getattr(field, \"data\", None), str):",
            "                    field.data = field.data.strip()",
            "",
            "        conn_id = StringField(",
            "            lazy_gettext(\"Connection Id\"),",
            "            validators=[InputRequired(), ValidKey()],",
            "            widget=BS3TextFieldWidget(),",
            "        )",
            "        conn_type = SelectField(",
            "            lazy_gettext(\"Connection Type\"),",
            "            choices=sorted(_iter_connection_types(), key=operator.itemgetter(1)),",
            "            widget=Select2Widget(),",
            "            validators=[InputRequired()],",
            "            description=(",
            "                \"Connection Type missing? Make sure you've installed the \"",
            "                \"corresponding Airflow Provider Package.\"",
            "            ),",
            "        )",
            "        description = StringField(lazy_gettext(\"Description\"), widget=BS3TextAreaFieldWidget())",
            "        host = StringField(lazy_gettext(\"Host\"), widget=BS3TextFieldWidget())",
            "        schema = StringField(lazy_gettext(\"Schema\"), widget=BS3TextFieldWidget())",
            "        login = StringField(lazy_gettext(\"Login\"), widget=BS3TextFieldWidget())",
            "        password = PasswordField(lazy_gettext(\"Password\"), widget=BS3PasswordFieldWidget())",
            "        port = IntegerField(lazy_gettext(\"Port\"), validators=[Optional()], widget=BS3TextFieldWidget())",
            "        extra = TextAreaField(lazy_gettext(\"Extra\"), widget=BS3TextAreaFieldWidget())",
            "",
            "    for key, value in providers_manager.connection_form_widgets.items():",
            "        setattr(ConnectionForm, key, value.field)",
            "",
            "    return ConnectionForm"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "44": [],
            "127": [
                "DagRunEditForm"
            ],
            "128": [
                "DagRunEditForm"
            ],
            "129": [
                "DagRunEditForm"
            ],
            "130": [
                "DagRunEditForm"
            ],
            "131": [
                "DagRunEditForm"
            ],
            "136": [
                "DagRunEditForm"
            ],
            "140": [
                "DagRunEditForm",
                "populate_obj"
            ],
            "141": [
                "DagRunEditForm",
                "populate_obj"
            ],
            "150": [
                "TaskInstanceEditForm"
            ],
            "152": [
                "TaskInstanceEditForm"
            ],
            "154": [
                "TaskInstanceEditForm"
            ],
            "155": [
                "TaskInstanceEditForm"
            ],
            "170": [
                "TaskInstanceEditForm"
            ]
        },
        "addLocation": []
    },
    "airflow/www/validators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "                 helpers.validate_key(field.data, self.max_length)"
            },
            "1": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             except Exception as e:"
            },
            "2": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "                 raise ValidationError(str(e))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+class ReadOnly:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    \"\"\"Adds readonly flag to a field."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    When using this you normally will need to override the form's populate_obj method,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    so field.populate_obj is not called for read-only fields."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    \"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    def __call__(self, form, field):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        field.flags.readonly = True"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "from json import JSONDecodeError",
            "",
            "from wtforms.validators import EqualTo, ValidationError",
            "",
            "from airflow.utils import helpers",
            "",
            "",
            "class GreaterEqualThan(EqualTo):",
            "    \"\"\"Compares the values of two fields.",
            "",
            "    :param fieldname:",
            "        The name of the other field to compare to.",
            "    :param message:",
            "        Error message to raise in case of a validation error. Can be",
            "        interpolated with `%(other_label)s` and `%(other_name)s` to provide a",
            "        more helpful error.",
            "    \"\"\"",
            "",
            "    def __call__(self, form, field):",
            "        try:",
            "            other = form[self.fieldname]",
            "        except KeyError:",
            "            raise ValidationError(field.gettext(f\"Invalid field name '{self.fieldname}'.\"))",
            "",
            "        if field.data is None or other.data is None:",
            "            return",
            "",
            "        if field.data < other.data:",
            "            message_args = {",
            "                \"other_label\": hasattr(other, \"label\") and other.label.text or self.fieldname,",
            "                \"other_name\": self.fieldname,",
            "            }",
            "            message = self.message",
            "            if message is None:",
            "                message = field.gettext(",
            "                    f\"Field must be greater than or equal to {message_args['other_label']}.\"",
            "                )",
            "            else:",
            "                message = message % message_args",
            "",
            "            raise ValidationError(message)",
            "",
            "",
            "class ValidJson:",
            "    \"\"\"Validates data is valid JSON.",
            "",
            "    :param message:",
            "        Error message to raise in case of a validation error.",
            "    \"\"\"",
            "",
            "    def __init__(self, message=None):",
            "        self.message = message",
            "",
            "    def __call__(self, form, field):",
            "        if field.data:",
            "            try:",
            "                json.loads(field.data)",
            "            except JSONDecodeError as ex:",
            "                message = self.message or f\"JSON Validation Error: {ex}\"",
            "                raise ValidationError(message=field.gettext(message.format(field.data)))",
            "",
            "",
            "class ValidKey:",
            "    \"\"\"",
            "    Validates values that will be used as keys.",
            "",
            "    :param max_length:",
            "        The maximum length of the given key",
            "    \"\"\"",
            "",
            "    def __init__(self, max_length=200):",
            "        self.max_length = max_length",
            "",
            "    def __call__(self, form, field):",
            "        if field.data:",
            "            try:",
            "                helpers.validate_key(field.data, self.max_length)",
            "            except Exception as e:",
            "                raise ValidationError(str(e))"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import json",
            "from json import JSONDecodeError",
            "",
            "from wtforms.validators import EqualTo, ValidationError",
            "",
            "from airflow.utils import helpers",
            "",
            "",
            "class GreaterEqualThan(EqualTo):",
            "    \"\"\"Compares the values of two fields.",
            "",
            "    :param fieldname:",
            "        The name of the other field to compare to.",
            "    :param message:",
            "        Error message to raise in case of a validation error. Can be",
            "        interpolated with `%(other_label)s` and `%(other_name)s` to provide a",
            "        more helpful error.",
            "    \"\"\"",
            "",
            "    def __call__(self, form, field):",
            "        try:",
            "            other = form[self.fieldname]",
            "        except KeyError:",
            "            raise ValidationError(field.gettext(f\"Invalid field name '{self.fieldname}'.\"))",
            "",
            "        if field.data is None or other.data is None:",
            "            return",
            "",
            "        if field.data < other.data:",
            "            message_args = {",
            "                \"other_label\": hasattr(other, \"label\") and other.label.text or self.fieldname,",
            "                \"other_name\": self.fieldname,",
            "            }",
            "            message = self.message",
            "            if message is None:",
            "                message = field.gettext(",
            "                    f\"Field must be greater than or equal to {message_args['other_label']}.\"",
            "                )",
            "            else:",
            "                message = message % message_args",
            "",
            "            raise ValidationError(message)",
            "",
            "",
            "class ValidJson:",
            "    \"\"\"Validates data is valid JSON.",
            "",
            "    :param message:",
            "        Error message to raise in case of a validation error.",
            "    \"\"\"",
            "",
            "    def __init__(self, message=None):",
            "        self.message = message",
            "",
            "    def __call__(self, form, field):",
            "        if field.data:",
            "            try:",
            "                json.loads(field.data)",
            "            except JSONDecodeError as ex:",
            "                message = self.message or f\"JSON Validation Error: {ex}\"",
            "                raise ValidationError(message=field.gettext(message.format(field.data)))",
            "",
            "",
            "class ValidKey:",
            "    \"\"\"",
            "    Validates values that will be used as keys.",
            "",
            "    :param max_length:",
            "        The maximum length of the given key",
            "    \"\"\"",
            "",
            "    def __init__(self, max_length=200):",
            "        self.max_length = max_length",
            "",
            "    def __call__(self, form, field):",
            "        if field.data:",
            "            try:",
            "                helpers.validate_key(field.data, self.max_length)",
            "            except Exception as e:",
            "                raise ValidationError(str(e))",
            "",
            "",
            "class ReadOnly:",
            "    \"\"\"Adds readonly flag to a field.",
            "",
            "    When using this you normally will need to override the form's populate_obj method,",
            "    so field.populate_obj is not called for read-only fields.",
            "    \"\"\"",
            "",
            "    def __call__(self, form, field):",
            "        field.flags.readonly = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    }
}