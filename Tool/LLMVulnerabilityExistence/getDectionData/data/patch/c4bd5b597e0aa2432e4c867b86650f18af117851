{
    "django/contrib/admin/helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         except (AttributeError, ValueError, ObjectDoesNotExist):"
            },
            "1": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "             result_repr = self.empty_value_display"
            },
            "2": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         else:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            if field in self.form.fields:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                widget = self.form[field].field.widget"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+                # This isn't elegant but suffices for contrib.auth's"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                # ReadOnlyPasswordHashWidget."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                if getattr(widget, 'read_only', False):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                    return widget.render(field, value)"
            },
            "9": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             if f is None:"
            },
            "10": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "                 if getattr(attr, 'boolean', False):"
            },
            "11": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "                     result_repr = _boolean_icon(value)"
            }
        },
        "frontPatchFile": [
            "import json",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.admin.utils import (",
            "    display_for_field, flatten_fieldsets, help_text_for_field, label_for_field,",
            "    lookup_field,",
            ")",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.db.models.fields.related import ManyToManyRel",
            "from django.forms.utils import flatatt",
            "from django.template.defaultfilters import capfirst, linebreaksbr",
            "from django.utils.html import conditional_escape, format_html",
            "from django.utils.safestring import mark_safe",
            "from django.utils.translation import gettext, gettext_lazy as _",
            "",
            "ACTION_CHECKBOX_NAME = '_selected_action'",
            "",
            "",
            "class ActionForm(forms.Form):",
            "    action = forms.ChoiceField(label=_('Action:'))",
            "    select_across = forms.BooleanField(",
            "        label='',",
            "        required=False,",
            "        initial=0,",
            "        widget=forms.HiddenInput({'class': 'select-across'}),",
            "    )",
            "",
            "",
            "checkbox = forms.CheckboxInput({'class': 'action-select'}, lambda value: False)",
            "",
            "",
            "class AdminForm:",
            "    def __init__(self, form, fieldsets, prepopulated_fields, readonly_fields=None, model_admin=None):",
            "        self.form, self.fieldsets = form, fieldsets",
            "        self.prepopulated_fields = [{",
            "            'field': form[field_name],",
            "            'dependencies': [form[f] for f in dependencies]",
            "        } for field_name, dependencies in prepopulated_fields.items()]",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "",
            "    def __iter__(self):",
            "        for name, options in self.fieldsets:",
            "            yield Fieldset(",
            "                self.form, name,",
            "                readonly_fields=self.readonly_fields,",
            "                model_admin=self.model_admin,",
            "                **options",
            "            )",
            "",
            "    @property",
            "    def errors(self):",
            "        return self.form.errors",
            "",
            "    @property",
            "    def non_field_errors(self):",
            "        return self.form.non_field_errors",
            "",
            "    @property",
            "    def media(self):",
            "        media = self.form.media",
            "        for fs in self:",
            "            media = media + fs.media",
            "        return media",
            "",
            "",
            "class Fieldset:",
            "    def __init__(self, form, name=None, readonly_fields=(), fields=(), classes=(),",
            "                 description=None, model_admin=None):",
            "        self.form = form",
            "        self.name, self.fields = name, fields",
            "        self.classes = ' '.join(classes)",
            "        self.description = description",
            "        self.model_admin = model_admin",
            "        self.readonly_fields = readonly_fields",
            "",
            "    @property",
            "    def media(self):",
            "        if 'collapse' in self.classes:",
            "            extra = '' if settings.DEBUG else '.min'",
            "            js = [",
            "                'vendor/jquery/jquery%s.js' % extra,",
            "                'jquery.init.js',",
            "                'collapse%s.js' % extra,",
            "            ]",
            "            return forms.Media(js=['admin/js/%s' % url for url in js])",
            "        return forms.Media()",
            "",
            "    def __iter__(self):",
            "        for field in self.fields:",
            "            yield Fieldline(self.form, field, self.readonly_fields, model_admin=self.model_admin)",
            "",
            "",
            "class Fieldline:",
            "    def __init__(self, form, field, readonly_fields=None, model_admin=None):",
            "        self.form = form  # A django.forms.Form instance",
            "        if not hasattr(field, \"__iter__\") or isinstance(field, str):",
            "            self.fields = [field]",
            "        else:",
            "            self.fields = field",
            "        self.has_visible_field = not all(",
            "            field in self.form.fields and self.form.fields[field].widget.is_hidden",
            "            for field in self.fields",
            "        )",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "",
            "    def __iter__(self):",
            "        for i, field in enumerate(self.fields):",
            "            if field in self.readonly_fields:",
            "                yield AdminReadonlyField(self.form, field, is_first=(i == 0), model_admin=self.model_admin)",
            "            else:",
            "                yield AdminField(self.form, field, is_first=(i == 0))",
            "",
            "    def errors(self):",
            "        return mark_safe(",
            "            '\\n'.join(",
            "                self.form[f].errors.as_ul() for f in self.fields if f not in self.readonly_fields",
            "            ).strip('\\n')",
            "        )",
            "",
            "",
            "class AdminField:",
            "    def __init__(self, form, field, is_first):",
            "        self.field = form[field]  # A django.forms.BoundField instance",
            "        self.is_first = is_first  # Whether this field is first on the line",
            "        self.is_checkbox = isinstance(self.field.field.widget, forms.CheckboxInput)",
            "        self.is_readonly = False",
            "",
            "    def label_tag(self):",
            "        classes = []",
            "        contents = conditional_escape(self.field.label)",
            "        if self.is_checkbox:",
            "            classes.append('vCheckboxLabel')",
            "",
            "        if self.field.field.required:",
            "            classes.append('required')",
            "        if not self.is_first:",
            "            classes.append('inline')",
            "        attrs = {'class': ' '.join(classes)} if classes else {}",
            "        # checkboxes should not have a label suffix as the checkbox appears",
            "        # to the left of the label.",
            "        return self.field.label_tag(",
            "            contents=mark_safe(contents), attrs=attrs,",
            "            label_suffix='' if self.is_checkbox else None,",
            "        )",
            "",
            "    def errors(self):",
            "        return mark_safe(self.field.errors.as_ul())",
            "",
            "",
            "class AdminReadonlyField:",
            "    def __init__(self, form, field, is_first, model_admin=None):",
            "        # Make self.field look a little bit like a field. This means that",
            "        # {{ field.name }} must be a useful class name to identify the field.",
            "        # For convenience, store other field-related data here too.",
            "        if callable(field):",
            "            class_name = field.__name__ if field.__name__ != '<lambda>' else ''",
            "        else:",
            "            class_name = field",
            "",
            "        if form._meta.labels and class_name in form._meta.labels:",
            "            label = form._meta.labels[class_name]",
            "        else:",
            "            label = label_for_field(field, form._meta.model, model_admin, form=form)",
            "",
            "        if form._meta.help_texts and class_name in form._meta.help_texts:",
            "            help_text = form._meta.help_texts[class_name]",
            "        else:",
            "            help_text = help_text_for_field(class_name, form._meta.model)",
            "",
            "        self.field = {",
            "            'name': class_name,",
            "            'label': label,",
            "            'help_text': help_text,",
            "            'field': field,",
            "        }",
            "        self.form = form",
            "        self.model_admin = model_admin",
            "        self.is_first = is_first",
            "        self.is_checkbox = False",
            "        self.is_readonly = True",
            "        self.empty_value_display = model_admin.get_empty_value_display()",
            "",
            "    def label_tag(self):",
            "        attrs = {}",
            "        if not self.is_first:",
            "            attrs[\"class\"] = \"inline\"",
            "        label = self.field['label']",
            "        return format_html('<label{}>{}:</label>', flatatt(attrs), capfirst(label))",
            "",
            "    def contents(self):",
            "        from django.contrib.admin.templatetags.admin_list import _boolean_icon",
            "        field, obj, model_admin = self.field['field'], self.form.instance, self.model_admin",
            "        try:",
            "            f, attr, value = lookup_field(field, obj, model_admin)",
            "        except (AttributeError, ValueError, ObjectDoesNotExist):",
            "            result_repr = self.empty_value_display",
            "        else:",
            "            if f is None:",
            "                if getattr(attr, 'boolean', False):",
            "                    result_repr = _boolean_icon(value)",
            "                else:",
            "                    if hasattr(value, \"__html__\"):",
            "                        result_repr = value",
            "                    else:",
            "                        result_repr = linebreaksbr(value)",
            "            else:",
            "                if isinstance(f.remote_field, ManyToManyRel) and value is not None:",
            "                    result_repr = \", \".join(map(str, value.all()))",
            "                else:",
            "                    result_repr = display_for_field(value, f, self.empty_value_display)",
            "                result_repr = linebreaksbr(result_repr)",
            "        return conditional_escape(result_repr)",
            "",
            "",
            "class InlineAdminFormSet:",
            "    \"\"\"",
            "    A wrapper around an inline formset for use in the admin system.",
            "    \"\"\"",
            "    def __init__(self, inline, formset, fieldsets, prepopulated_fields=None,",
            "                 readonly_fields=None, model_admin=None, has_add_permission=True,",
            "                 has_change_permission=True, has_delete_permission=True,",
            "                 has_view_permission=True):",
            "        self.opts = inline",
            "        self.formset = formset",
            "        self.fieldsets = fieldsets",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "        if prepopulated_fields is None:",
            "            prepopulated_fields = {}",
            "        self.prepopulated_fields = prepopulated_fields",
            "        self.classes = ' '.join(inline.classes) if inline.classes else ''",
            "        self.has_add_permission = has_add_permission",
            "        self.has_change_permission = has_change_permission",
            "        self.has_delete_permission = has_delete_permission",
            "        self.has_view_permission = has_view_permission",
            "",
            "    def __iter__(self):",
            "        if self.has_change_permission:",
            "            readonly_fields_for_editing = self.readonly_fields",
            "        else:",
            "            readonly_fields_for_editing = self.readonly_fields + flatten_fieldsets(self.fieldsets)",
            "",
            "        for form, original in zip(self.formset.initial_forms, self.formset.get_queryset()):",
            "            view_on_site_url = self.opts.get_view_on_site_url(original)",
            "            yield InlineAdminForm(",
            "                self.formset, form, self.fieldsets, self.prepopulated_fields,",
            "                original, readonly_fields_for_editing, model_admin=self.opts,",
            "                view_on_site_url=view_on_site_url,",
            "            )",
            "        for form in self.formset.extra_forms:",
            "            yield InlineAdminForm(",
            "                self.formset, form, self.fieldsets, self.prepopulated_fields,",
            "                None, self.readonly_fields, model_admin=self.opts,",
            "            )",
            "        if self.has_add_permission:",
            "            yield InlineAdminForm(",
            "                self.formset, self.formset.empty_form,",
            "                self.fieldsets, self.prepopulated_fields, None,",
            "                self.readonly_fields, model_admin=self.opts,",
            "            )",
            "",
            "    def fields(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        empty_form = self.formset.empty_form",
            "        meta_labels = empty_form._meta.labels or {}",
            "        meta_help_texts = empty_form._meta.help_texts or {}",
            "        for i, field_name in enumerate(flatten_fieldsets(self.fieldsets)):",
            "            if fk and fk.name == field_name:",
            "                continue",
            "            if not self.has_change_permission or field_name in self.readonly_fields:",
            "                yield {",
            "                    'label': meta_labels.get(field_name) or label_for_field(field_name, self.opts.model, self.opts),",
            "                    'widget': {'is_hidden': False},",
            "                    'required': False,",
            "                    'help_text': meta_help_texts.get(field_name) or help_text_for_field(field_name, self.opts.model),",
            "                }",
            "            else:",
            "                form_field = empty_form.fields[field_name]",
            "                label = form_field.label",
            "                if label is None:",
            "                    label = label_for_field(field_name, self.opts.model, self.opts)",
            "                yield {",
            "                    'label': label,",
            "                    'widget': form_field.widget,",
            "                    'required': form_field.required,",
            "                    'help_text': form_field.help_text,",
            "                }",
            "",
            "    def inline_formset_data(self):",
            "        verbose_name = self.opts.verbose_name",
            "        return json.dumps({",
            "            'name': '#%s' % self.formset.prefix,",
            "            'options': {",
            "                'prefix': self.formset.prefix,",
            "                'addText': gettext('Add another %(verbose_name)s') % {",
            "                    'verbose_name': capfirst(verbose_name),",
            "                },",
            "                'deleteText': gettext('Remove'),",
            "            }",
            "        })",
            "",
            "    @property",
            "    def forms(self):",
            "        return self.formset.forms",
            "",
            "    @property",
            "    def non_form_errors(self):",
            "        return self.formset.non_form_errors",
            "",
            "    @property",
            "    def media(self):",
            "        media = self.opts.media + self.formset.media",
            "        for fs in self:",
            "            media = media + fs.media",
            "        return media",
            "",
            "",
            "class InlineAdminForm(AdminForm):",
            "    \"\"\"",
            "    A wrapper around an inline form for use in the admin system.",
            "    \"\"\"",
            "    def __init__(self, formset, form, fieldsets, prepopulated_fields, original,",
            "                 readonly_fields=None, model_admin=None, view_on_site_url=None):",
            "        self.formset = formset",
            "        self.model_admin = model_admin",
            "        self.original = original",
            "        self.show_url = original and view_on_site_url is not None",
            "        self.absolute_url = view_on_site_url",
            "        super().__init__(form, fieldsets, prepopulated_fields, readonly_fields, model_admin)",
            "",
            "    def __iter__(self):",
            "        for name, options in self.fieldsets:",
            "            yield InlineFieldset(",
            "                self.formset, self.form, name, self.readonly_fields,",
            "                model_admin=self.model_admin, **options",
            "            )",
            "",
            "    def needs_explicit_pk_field(self):",
            "        return (",
            "            # Auto fields are editable, so check for auto or non-editable pk.",
            "            self.form._meta.model._meta.auto_field or not self.form._meta.model._meta.pk.editable or",
            "            # Also search any parents for an auto field. (The pk info is",
            "            # propagated to child models so that does not need to be checked",
            "            # in parents.)",
            "            any(parent._meta.auto_field or not parent._meta.model._meta.pk.editable",
            "                for parent in self.form._meta.model._meta.get_parent_list())",
            "        )",
            "",
            "    def pk_field(self):",
            "        return AdminField(self.form, self.formset._pk_field.name, False)",
            "",
            "    def fk_field(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        if fk:",
            "            return AdminField(self.form, fk.name, False)",
            "        else:",
            "            return \"\"",
            "",
            "    def deletion_field(self):",
            "        from django.forms.formsets import DELETION_FIELD_NAME",
            "        return AdminField(self.form, DELETION_FIELD_NAME, False)",
            "",
            "    def ordering_field(self):",
            "        from django.forms.formsets import ORDERING_FIELD_NAME",
            "        return AdminField(self.form, ORDERING_FIELD_NAME, False)",
            "",
            "",
            "class InlineFieldset(Fieldset):",
            "    def __init__(self, formset, *args, **kwargs):",
            "        self.formset = formset",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def __iter__(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        for field in self.fields:",
            "            if not fk or fk.name != field:",
            "                yield Fieldline(self.form, field, self.readonly_fields, model_admin=self.model_admin)",
            "",
            "",
            "class AdminErrorList(forms.utils.ErrorList):",
            "    \"\"\"Store errors for the form/formsets in an add/change view.\"\"\"",
            "    def __init__(self, form, inline_formsets):",
            "        super().__init__()",
            "",
            "        if form.is_bound:",
            "            self.extend(form.errors.values())",
            "            for inline_formset in inline_formsets:",
            "                self.extend(inline_formset.non_form_errors())",
            "                for errors_in_inline_form in inline_formset.errors:",
            "                    self.extend(errors_in_inline_form.values())"
        ],
        "afterPatchFile": [
            "import json",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.admin.utils import (",
            "    display_for_field, flatten_fieldsets, help_text_for_field, label_for_field,",
            "    lookup_field,",
            ")",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.db.models.fields.related import ManyToManyRel",
            "from django.forms.utils import flatatt",
            "from django.template.defaultfilters import capfirst, linebreaksbr",
            "from django.utils.html import conditional_escape, format_html",
            "from django.utils.safestring import mark_safe",
            "from django.utils.translation import gettext, gettext_lazy as _",
            "",
            "ACTION_CHECKBOX_NAME = '_selected_action'",
            "",
            "",
            "class ActionForm(forms.Form):",
            "    action = forms.ChoiceField(label=_('Action:'))",
            "    select_across = forms.BooleanField(",
            "        label='',",
            "        required=False,",
            "        initial=0,",
            "        widget=forms.HiddenInput({'class': 'select-across'}),",
            "    )",
            "",
            "",
            "checkbox = forms.CheckboxInput({'class': 'action-select'}, lambda value: False)",
            "",
            "",
            "class AdminForm:",
            "    def __init__(self, form, fieldsets, prepopulated_fields, readonly_fields=None, model_admin=None):",
            "        self.form, self.fieldsets = form, fieldsets",
            "        self.prepopulated_fields = [{",
            "            'field': form[field_name],",
            "            'dependencies': [form[f] for f in dependencies]",
            "        } for field_name, dependencies in prepopulated_fields.items()]",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "",
            "    def __iter__(self):",
            "        for name, options in self.fieldsets:",
            "            yield Fieldset(",
            "                self.form, name,",
            "                readonly_fields=self.readonly_fields,",
            "                model_admin=self.model_admin,",
            "                **options",
            "            )",
            "",
            "    @property",
            "    def errors(self):",
            "        return self.form.errors",
            "",
            "    @property",
            "    def non_field_errors(self):",
            "        return self.form.non_field_errors",
            "",
            "    @property",
            "    def media(self):",
            "        media = self.form.media",
            "        for fs in self:",
            "            media = media + fs.media",
            "        return media",
            "",
            "",
            "class Fieldset:",
            "    def __init__(self, form, name=None, readonly_fields=(), fields=(), classes=(),",
            "                 description=None, model_admin=None):",
            "        self.form = form",
            "        self.name, self.fields = name, fields",
            "        self.classes = ' '.join(classes)",
            "        self.description = description",
            "        self.model_admin = model_admin",
            "        self.readonly_fields = readonly_fields",
            "",
            "    @property",
            "    def media(self):",
            "        if 'collapse' in self.classes:",
            "            extra = '' if settings.DEBUG else '.min'",
            "            js = [",
            "                'vendor/jquery/jquery%s.js' % extra,",
            "                'jquery.init.js',",
            "                'collapse%s.js' % extra,",
            "            ]",
            "            return forms.Media(js=['admin/js/%s' % url for url in js])",
            "        return forms.Media()",
            "",
            "    def __iter__(self):",
            "        for field in self.fields:",
            "            yield Fieldline(self.form, field, self.readonly_fields, model_admin=self.model_admin)",
            "",
            "",
            "class Fieldline:",
            "    def __init__(self, form, field, readonly_fields=None, model_admin=None):",
            "        self.form = form  # A django.forms.Form instance",
            "        if not hasattr(field, \"__iter__\") or isinstance(field, str):",
            "            self.fields = [field]",
            "        else:",
            "            self.fields = field",
            "        self.has_visible_field = not all(",
            "            field in self.form.fields and self.form.fields[field].widget.is_hidden",
            "            for field in self.fields",
            "        )",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "",
            "    def __iter__(self):",
            "        for i, field in enumerate(self.fields):",
            "            if field in self.readonly_fields:",
            "                yield AdminReadonlyField(self.form, field, is_first=(i == 0), model_admin=self.model_admin)",
            "            else:",
            "                yield AdminField(self.form, field, is_first=(i == 0))",
            "",
            "    def errors(self):",
            "        return mark_safe(",
            "            '\\n'.join(",
            "                self.form[f].errors.as_ul() for f in self.fields if f not in self.readonly_fields",
            "            ).strip('\\n')",
            "        )",
            "",
            "",
            "class AdminField:",
            "    def __init__(self, form, field, is_first):",
            "        self.field = form[field]  # A django.forms.BoundField instance",
            "        self.is_first = is_first  # Whether this field is first on the line",
            "        self.is_checkbox = isinstance(self.field.field.widget, forms.CheckboxInput)",
            "        self.is_readonly = False",
            "",
            "    def label_tag(self):",
            "        classes = []",
            "        contents = conditional_escape(self.field.label)",
            "        if self.is_checkbox:",
            "            classes.append('vCheckboxLabel')",
            "",
            "        if self.field.field.required:",
            "            classes.append('required')",
            "        if not self.is_first:",
            "            classes.append('inline')",
            "        attrs = {'class': ' '.join(classes)} if classes else {}",
            "        # checkboxes should not have a label suffix as the checkbox appears",
            "        # to the left of the label.",
            "        return self.field.label_tag(",
            "            contents=mark_safe(contents), attrs=attrs,",
            "            label_suffix='' if self.is_checkbox else None,",
            "        )",
            "",
            "    def errors(self):",
            "        return mark_safe(self.field.errors.as_ul())",
            "",
            "",
            "class AdminReadonlyField:",
            "    def __init__(self, form, field, is_first, model_admin=None):",
            "        # Make self.field look a little bit like a field. This means that",
            "        # {{ field.name }} must be a useful class name to identify the field.",
            "        # For convenience, store other field-related data here too.",
            "        if callable(field):",
            "            class_name = field.__name__ if field.__name__ != '<lambda>' else ''",
            "        else:",
            "            class_name = field",
            "",
            "        if form._meta.labels and class_name in form._meta.labels:",
            "            label = form._meta.labels[class_name]",
            "        else:",
            "            label = label_for_field(field, form._meta.model, model_admin, form=form)",
            "",
            "        if form._meta.help_texts and class_name in form._meta.help_texts:",
            "            help_text = form._meta.help_texts[class_name]",
            "        else:",
            "            help_text = help_text_for_field(class_name, form._meta.model)",
            "",
            "        self.field = {",
            "            'name': class_name,",
            "            'label': label,",
            "            'help_text': help_text,",
            "            'field': field,",
            "        }",
            "        self.form = form",
            "        self.model_admin = model_admin",
            "        self.is_first = is_first",
            "        self.is_checkbox = False",
            "        self.is_readonly = True",
            "        self.empty_value_display = model_admin.get_empty_value_display()",
            "",
            "    def label_tag(self):",
            "        attrs = {}",
            "        if not self.is_first:",
            "            attrs[\"class\"] = \"inline\"",
            "        label = self.field['label']",
            "        return format_html('<label{}>{}:</label>', flatatt(attrs), capfirst(label))",
            "",
            "    def contents(self):",
            "        from django.contrib.admin.templatetags.admin_list import _boolean_icon",
            "        field, obj, model_admin = self.field['field'], self.form.instance, self.model_admin",
            "        try:",
            "            f, attr, value = lookup_field(field, obj, model_admin)",
            "        except (AttributeError, ValueError, ObjectDoesNotExist):",
            "            result_repr = self.empty_value_display",
            "        else:",
            "            if field in self.form.fields:",
            "                widget = self.form[field].field.widget",
            "                # This isn't elegant but suffices for contrib.auth's",
            "                # ReadOnlyPasswordHashWidget.",
            "                if getattr(widget, 'read_only', False):",
            "                    return widget.render(field, value)",
            "            if f is None:",
            "                if getattr(attr, 'boolean', False):",
            "                    result_repr = _boolean_icon(value)",
            "                else:",
            "                    if hasattr(value, \"__html__\"):",
            "                        result_repr = value",
            "                    else:",
            "                        result_repr = linebreaksbr(value)",
            "            else:",
            "                if isinstance(f.remote_field, ManyToManyRel) and value is not None:",
            "                    result_repr = \", \".join(map(str, value.all()))",
            "                else:",
            "                    result_repr = display_for_field(value, f, self.empty_value_display)",
            "                result_repr = linebreaksbr(result_repr)",
            "        return conditional_escape(result_repr)",
            "",
            "",
            "class InlineAdminFormSet:",
            "    \"\"\"",
            "    A wrapper around an inline formset for use in the admin system.",
            "    \"\"\"",
            "    def __init__(self, inline, formset, fieldsets, prepopulated_fields=None,",
            "                 readonly_fields=None, model_admin=None, has_add_permission=True,",
            "                 has_change_permission=True, has_delete_permission=True,",
            "                 has_view_permission=True):",
            "        self.opts = inline",
            "        self.formset = formset",
            "        self.fieldsets = fieldsets",
            "        self.model_admin = model_admin",
            "        if readonly_fields is None:",
            "            readonly_fields = ()",
            "        self.readonly_fields = readonly_fields",
            "        if prepopulated_fields is None:",
            "            prepopulated_fields = {}",
            "        self.prepopulated_fields = prepopulated_fields",
            "        self.classes = ' '.join(inline.classes) if inline.classes else ''",
            "        self.has_add_permission = has_add_permission",
            "        self.has_change_permission = has_change_permission",
            "        self.has_delete_permission = has_delete_permission",
            "        self.has_view_permission = has_view_permission",
            "",
            "    def __iter__(self):",
            "        if self.has_change_permission:",
            "            readonly_fields_for_editing = self.readonly_fields",
            "        else:",
            "            readonly_fields_for_editing = self.readonly_fields + flatten_fieldsets(self.fieldsets)",
            "",
            "        for form, original in zip(self.formset.initial_forms, self.formset.get_queryset()):",
            "            view_on_site_url = self.opts.get_view_on_site_url(original)",
            "            yield InlineAdminForm(",
            "                self.formset, form, self.fieldsets, self.prepopulated_fields,",
            "                original, readonly_fields_for_editing, model_admin=self.opts,",
            "                view_on_site_url=view_on_site_url,",
            "            )",
            "        for form in self.formset.extra_forms:",
            "            yield InlineAdminForm(",
            "                self.formset, form, self.fieldsets, self.prepopulated_fields,",
            "                None, self.readonly_fields, model_admin=self.opts,",
            "            )",
            "        if self.has_add_permission:",
            "            yield InlineAdminForm(",
            "                self.formset, self.formset.empty_form,",
            "                self.fieldsets, self.prepopulated_fields, None,",
            "                self.readonly_fields, model_admin=self.opts,",
            "            )",
            "",
            "    def fields(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        empty_form = self.formset.empty_form",
            "        meta_labels = empty_form._meta.labels or {}",
            "        meta_help_texts = empty_form._meta.help_texts or {}",
            "        for i, field_name in enumerate(flatten_fieldsets(self.fieldsets)):",
            "            if fk and fk.name == field_name:",
            "                continue",
            "            if not self.has_change_permission or field_name in self.readonly_fields:",
            "                yield {",
            "                    'label': meta_labels.get(field_name) or label_for_field(field_name, self.opts.model, self.opts),",
            "                    'widget': {'is_hidden': False},",
            "                    'required': False,",
            "                    'help_text': meta_help_texts.get(field_name) or help_text_for_field(field_name, self.opts.model),",
            "                }",
            "            else:",
            "                form_field = empty_form.fields[field_name]",
            "                label = form_field.label",
            "                if label is None:",
            "                    label = label_for_field(field_name, self.opts.model, self.opts)",
            "                yield {",
            "                    'label': label,",
            "                    'widget': form_field.widget,",
            "                    'required': form_field.required,",
            "                    'help_text': form_field.help_text,",
            "                }",
            "",
            "    def inline_formset_data(self):",
            "        verbose_name = self.opts.verbose_name",
            "        return json.dumps({",
            "            'name': '#%s' % self.formset.prefix,",
            "            'options': {",
            "                'prefix': self.formset.prefix,",
            "                'addText': gettext('Add another %(verbose_name)s') % {",
            "                    'verbose_name': capfirst(verbose_name),",
            "                },",
            "                'deleteText': gettext('Remove'),",
            "            }",
            "        })",
            "",
            "    @property",
            "    def forms(self):",
            "        return self.formset.forms",
            "",
            "    @property",
            "    def non_form_errors(self):",
            "        return self.formset.non_form_errors",
            "",
            "    @property",
            "    def media(self):",
            "        media = self.opts.media + self.formset.media",
            "        for fs in self:",
            "            media = media + fs.media",
            "        return media",
            "",
            "",
            "class InlineAdminForm(AdminForm):",
            "    \"\"\"",
            "    A wrapper around an inline form for use in the admin system.",
            "    \"\"\"",
            "    def __init__(self, formset, form, fieldsets, prepopulated_fields, original,",
            "                 readonly_fields=None, model_admin=None, view_on_site_url=None):",
            "        self.formset = formset",
            "        self.model_admin = model_admin",
            "        self.original = original",
            "        self.show_url = original and view_on_site_url is not None",
            "        self.absolute_url = view_on_site_url",
            "        super().__init__(form, fieldsets, prepopulated_fields, readonly_fields, model_admin)",
            "",
            "    def __iter__(self):",
            "        for name, options in self.fieldsets:",
            "            yield InlineFieldset(",
            "                self.formset, self.form, name, self.readonly_fields,",
            "                model_admin=self.model_admin, **options",
            "            )",
            "",
            "    def needs_explicit_pk_field(self):",
            "        return (",
            "            # Auto fields are editable, so check for auto or non-editable pk.",
            "            self.form._meta.model._meta.auto_field or not self.form._meta.model._meta.pk.editable or",
            "            # Also search any parents for an auto field. (The pk info is",
            "            # propagated to child models so that does not need to be checked",
            "            # in parents.)",
            "            any(parent._meta.auto_field or not parent._meta.model._meta.pk.editable",
            "                for parent in self.form._meta.model._meta.get_parent_list())",
            "        )",
            "",
            "    def pk_field(self):",
            "        return AdminField(self.form, self.formset._pk_field.name, False)",
            "",
            "    def fk_field(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        if fk:",
            "            return AdminField(self.form, fk.name, False)",
            "        else:",
            "            return \"\"",
            "",
            "    def deletion_field(self):",
            "        from django.forms.formsets import DELETION_FIELD_NAME",
            "        return AdminField(self.form, DELETION_FIELD_NAME, False)",
            "",
            "    def ordering_field(self):",
            "        from django.forms.formsets import ORDERING_FIELD_NAME",
            "        return AdminField(self.form, ORDERING_FIELD_NAME, False)",
            "",
            "",
            "class InlineFieldset(Fieldset):",
            "    def __init__(self, formset, *args, **kwargs):",
            "        self.formset = formset",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def __iter__(self):",
            "        fk = getattr(self.formset, \"fk\", None)",
            "        for field in self.fields:",
            "            if not fk or fk.name != field:",
            "                yield Fieldline(self.form, field, self.readonly_fields, model_admin=self.model_admin)",
            "",
            "",
            "class AdminErrorList(forms.utils.ErrorList):",
            "    \"\"\"Store errors for the form/formsets in an add/change view.\"\"\"",
            "    def __init__(self, form, inline_formsets):",
            "        super().__init__()",
            "",
            "        if form.is_bound:",
            "            self.extend(form.errors.values())",
            "            for inline_formset in inline_formsets:",
            "                self.extend(inline_formset.non_form_errors())",
            "                for errors_in_inline_form in inline_formset.errors:",
            "                    self.extend(errors_in_inline_form.values())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "websockets.test_client_server"
        ]
    },
    "django/contrib/auth/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " class ReadOnlyPasswordHashWidget(forms.Widget):"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     template_name = 'auth/widgets/read_only_password_hash.html'"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    read_only = True"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     def get_context(self, name, value, attrs):"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         context = super().get_context(name, value, attrs)"
            }
        },
        "frontPatchFile": [
            "import unicodedata",
            "",
            "from django import forms",
            "from django.contrib.auth import (",
            "    authenticate, get_user_model, password_validation,",
            ")",
            "from django.contrib.auth.hashers import (",
            "    UNUSABLE_PASSWORD_PREFIX, identify_hasher,",
            ")",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.shortcuts import get_current_site",
            "from django.core.mail import EmailMultiAlternatives",
            "from django.template import loader",
            "from django.utils.encoding import force_bytes",
            "from django.utils.http import urlsafe_base64_encode",
            "from django.utils.text import capfirst",
            "from django.utils.translation import gettext, gettext_lazy as _",
            "",
            "UserModel = get_user_model()",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    template_name = 'auth/widgets/read_only_password_hash.html'",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        summary = []",
            "        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):",
            "            summary.append({'label': gettext(\"No password set.\")})",
            "        else:",
            "            try:",
            "                hasher = identify_hasher(value)",
            "            except ValueError:",
            "                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})",
            "            else:",
            "                for key, value_ in hasher.safe_summary(value).items():",
            "                    summary.append({'label': gettext(key), 'value': value_})",
            "        context['summary'] = summary",
            "        return context",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def bound_data(self, data, initial):",
            "        # Always return initial because the widget doesn't",
            "        # render an input field.",
            "        return initial",
            "",
            "    def has_changed(self, initial, data):",
            "        return False",
            "",
            "",
            "class UsernameField(forms.CharField):",
            "    def to_python(self, value):",
            "        return unicodedata.normalize('NFKC', super().to_python(value))",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=_(\"Enter the same password as before, for verification.\"),",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "        field_classes = {'username': UsernameField}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if self._meta.model.USERNAME_FIELD in self.fields:",
            "            self.fields[self._meta.model.USERNAME_FIELD].widget.attrs.update({'autofocus': True})",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\")",
            "        password2 = self.cleaned_data.get(\"password2\")",
            "        if password1 and password2 and password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'],",
            "                code='password_mismatch',",
            "            )",
            "        return password2",
            "",
            "    def _post_clean(self):",
            "        super()._post_clean()",
            "        # Validate the password after self.instance is updated with form data",
            "        # by super().",
            "        password = self.cleaned_data.get('password2')",
            "        if password:",
            "            try:",
            "                password_validation.validate_password(password, self.instance)",
            "            except forms.ValidationError as error:",
            "                self.add_error('password2', error)",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    password = ReadOnlyPasswordHashField(",
            "        label=_(\"Password\"),",
            "        help_text=_(",
            "            \"Raw passwords are not stored, so there is no way to see this \"",
            "            \"user's password, but you can change the password using \"",
            "            \"<a href=\\\"{}\\\">this form</a>.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = '__all__'",
            "        field_classes = {'username': UsernameField}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        password = self.fields.get('password')",
            "        if password:",
            "            password.help_text = password.help_text.format('../password/')",
            "        user_permissions = self.fields.get('user_permissions')",
            "        if user_permissions:",
            "            user_permissions.queryset = user_permissions.queryset.select_related('content_type')",
            "",
            "    def clean_password(self):",
            "        # Regardless of what the user provides, return the initial value.",
            "        # This is done here, rather than on the field, because the",
            "        # field does not have access to the initial value",
            "        return self.initial[\"password\"]",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))",
            "    password = forms.CharField(",
            "        label=_(\"Password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "    )",
            "",
            "    error_messages = {",
            "        'invalid_login': _(",
            "            \"Please enter a correct %(username)s and password. Note that both \"",
            "            \"fields may be case-sensitive.\"",
            "        ),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        The 'request' parameter is set for custom auth use by subclasses.",
            "        The form data comes in via the standard 'data' kwarg.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Set the max length and label for the \"username\" field.",
            "        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)",
            "        self.fields['username'].max_length = self.username_field.max_length or 254",
            "        if self.fields['username'].label is None:",
            "            self.fields['username'].label = capfirst(self.username_field.verbose_name)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username is not None and password:",
            "            self.user_cache = authenticate(self.request, username=username, password=password)",
            "            if self.user_cache is None:",
            "                raise self.get_invalid_login_error()",
            "            else:",
            "                self.confirm_login_allowed(self.user_cache)",
            "",
            "        return self.cleaned_data",
            "",
            "    def confirm_login_allowed(self, user):",
            "        \"\"\"",
            "        Controls whether the given User may log in. This is a policy setting,",
            "        independent of end-user authentication. This default behavior is to",
            "        allow login by active users, and reject login by inactive users.",
            "",
            "        If the given user cannot log in, this method should raise a",
            "        ``forms.ValidationError``.",
            "",
            "        If the given user may log in, this method should return None.",
            "        \"\"\"",
            "        if not user.is_active:",
            "            raise forms.ValidationError(",
            "                self.error_messages['inactive'],",
            "                code='inactive',",
            "            )",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "    def get_invalid_login_error(self):",
            "        return forms.ValidationError(",
            "            self.error_messages['invalid_login'],",
            "            code='invalid_login',",
            "            params={'username': self.username_field.verbose_name},",
            "        )",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    email = forms.EmailField(label=_(\"Email\"), max_length=254)",
            "",
            "    def send_mail(self, subject_template_name, email_template_name,",
            "                  context, from_email, to_email, html_email_template_name=None):",
            "        \"\"\"",
            "        Send a django.core.mail.EmailMultiAlternatives to `to_email`.",
            "        \"\"\"",
            "        subject = loader.render_to_string(subject_template_name, context)",
            "        # Email subject *must not* contain newlines",
            "        subject = ''.join(subject.splitlines())",
            "        body = loader.render_to_string(email_template_name, context)",
            "",
            "        email_message = EmailMultiAlternatives(subject, body, from_email, [to_email])",
            "        if html_email_template_name is not None:",
            "            html_email = loader.render_to_string(html_email_template_name, context)",
            "            email_message.attach_alternative(html_email, 'text/html')",
            "",
            "        email_message.send()",
            "",
            "    def get_users(self, email):",
            "        \"\"\"Given an email, return matching user(s) who should receive a reset.",
            "",
            "        This allows subclasses to more easily customize the default policies",
            "        that prevent inactive users and users with unusable passwords from",
            "        resetting their password.",
            "        \"\"\"",
            "        active_users = UserModel._default_manager.filter(**{",
            "            '%s__iexact' % UserModel.get_email_field_name(): email,",
            "            'is_active': True,",
            "        })",
            "        return (u for u in active_users if u.has_usable_password())",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None, html_email_template_name=None,",
            "             extra_email_context=None):",
            "        \"\"\"",
            "        Generate a one-use only link for resetting password and send it to the",
            "        user.",
            "        \"\"\"",
            "        email = self.cleaned_data[\"email\"]",
            "        for user in self.get_users(email):",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            context = {",
            "                'email': email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': urlsafe_base64_encode(force_bytes(user.pk)).decode(),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': 'https' if use_https else 'http',",
            "                **(extra_email_context or {}),",
            "            }",
            "            self.send_mail(",
            "                subject_template_name, email_template_name, context, from_email,",
            "                email, html_email_template_name=html_email_template_name,",
            "            )",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set their password without entering the old",
            "    password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(",
            "        label=_(\"New password\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    new_password2 = forms.CharField(",
            "        label=_(\"New password confirmation\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'],",
            "                    code='password_mismatch',",
            "                )",
            "        password_validation.validate_password(password2, self.user)",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        password = self.cleaned_data[\"new_password1\"]",
            "        self.user.set_password(password)",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change their password by entering their old",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        **SetPasswordForm.error_messages,",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. Please enter it again.\"),",
            "    }",
            "    old_password = forms.CharField(",
            "        label=_(\"Old password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput(attrs={'autofocus': True}),",
            "    )",
            "",
            "    field_order = ['old_password', 'new_password1', 'new_password2']",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validate that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'],",
            "                code='password_incorrect',",
            "            )",
            "        return old_password",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    required_css_class = 'required'",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput(attrs={'autofocus': True}),",
            "        strip=False,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password (again)\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=_(\"Enter the same password as before, for verification.\"),",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'],",
            "                    code='password_mismatch',",
            "                )",
            "        password_validation.validate_password(password2, self.user)",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"Save the new password.\"\"\"",
            "        password = self.cleaned_data[\"password1\"]",
            "        self.user.set_password(password)",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "    @property",
            "    def changed_data(self):",
            "        data = super().changed_data",
            "        for name in self.fields:",
            "            if name not in data:",
            "                return []",
            "        return ['password']"
        ],
        "afterPatchFile": [
            "import unicodedata",
            "",
            "from django import forms",
            "from django.contrib.auth import (",
            "    authenticate, get_user_model, password_validation,",
            ")",
            "from django.contrib.auth.hashers import (",
            "    UNUSABLE_PASSWORD_PREFIX, identify_hasher,",
            ")",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.shortcuts import get_current_site",
            "from django.core.mail import EmailMultiAlternatives",
            "from django.template import loader",
            "from django.utils.encoding import force_bytes",
            "from django.utils.http import urlsafe_base64_encode",
            "from django.utils.text import capfirst",
            "from django.utils.translation import gettext, gettext_lazy as _",
            "",
            "UserModel = get_user_model()",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    template_name = 'auth/widgets/read_only_password_hash.html'",
            "    read_only = True",
            "",
            "    def get_context(self, name, value, attrs):",
            "        context = super().get_context(name, value, attrs)",
            "        summary = []",
            "        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):",
            "            summary.append({'label': gettext(\"No password set.\")})",
            "        else:",
            "            try:",
            "                hasher = identify_hasher(value)",
            "            except ValueError:",
            "                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})",
            "            else:",
            "                for key, value_ in hasher.safe_summary(value).items():",
            "                    summary.append({'label': gettext(key), 'value': value_})",
            "        context['summary'] = summary",
            "        return context",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def bound_data(self, data, initial):",
            "        # Always return initial because the widget doesn't",
            "        # render an input field.",
            "        return initial",
            "",
            "    def has_changed(self, initial, data):",
            "        return False",
            "",
            "",
            "class UsernameField(forms.CharField):",
            "    def to_python(self, value):",
            "        return unicodedata.normalize('NFKC', super().to_python(value))",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=_(\"Enter the same password as before, for verification.\"),",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "        field_classes = {'username': UsernameField}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if self._meta.model.USERNAME_FIELD in self.fields:",
            "            self.fields[self._meta.model.USERNAME_FIELD].widget.attrs.update({'autofocus': True})",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\")",
            "        password2 = self.cleaned_data.get(\"password2\")",
            "        if password1 and password2 and password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'],",
            "                code='password_mismatch',",
            "            )",
            "        return password2",
            "",
            "    def _post_clean(self):",
            "        super()._post_clean()",
            "        # Validate the password after self.instance is updated with form data",
            "        # by super().",
            "        password = self.cleaned_data.get('password2')",
            "        if password:",
            "            try:",
            "                password_validation.validate_password(password, self.instance)",
            "            except forms.ValidationError as error:",
            "                self.add_error('password2', error)",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    password = ReadOnlyPasswordHashField(",
            "        label=_(\"Password\"),",
            "        help_text=_(",
            "            \"Raw passwords are not stored, so there is no way to see this \"",
            "            \"user's password, but you can change the password using \"",
            "            \"<a href=\\\"{}\\\">this form</a>.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = '__all__'",
            "        field_classes = {'username': UsernameField}",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        password = self.fields.get('password')",
            "        if password:",
            "            password.help_text = password.help_text.format('../password/')",
            "        user_permissions = self.fields.get('user_permissions')",
            "        if user_permissions:",
            "            user_permissions.queryset = user_permissions.queryset.select_related('content_type')",
            "",
            "    def clean_password(self):",
            "        # Regardless of what the user provides, return the initial value.",
            "        # This is done here, rather than on the field, because the",
            "        # field does not have access to the initial value",
            "        return self.initial[\"password\"]",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))",
            "    password = forms.CharField(",
            "        label=_(\"Password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "    )",
            "",
            "    error_messages = {",
            "        'invalid_login': _(",
            "            \"Please enter a correct %(username)s and password. Note that both \"",
            "            \"fields may be case-sensitive.\"",
            "        ),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        The 'request' parameter is set for custom auth use by subclasses.",
            "        The form data comes in via the standard 'data' kwarg.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Set the max length and label for the \"username\" field.",
            "        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)",
            "        self.fields['username'].max_length = self.username_field.max_length or 254",
            "        if self.fields['username'].label is None:",
            "            self.fields['username'].label = capfirst(self.username_field.verbose_name)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username is not None and password:",
            "            self.user_cache = authenticate(self.request, username=username, password=password)",
            "            if self.user_cache is None:",
            "                raise self.get_invalid_login_error()",
            "            else:",
            "                self.confirm_login_allowed(self.user_cache)",
            "",
            "        return self.cleaned_data",
            "",
            "    def confirm_login_allowed(self, user):",
            "        \"\"\"",
            "        Controls whether the given User may log in. This is a policy setting,",
            "        independent of end-user authentication. This default behavior is to",
            "        allow login by active users, and reject login by inactive users.",
            "",
            "        If the given user cannot log in, this method should raise a",
            "        ``forms.ValidationError``.",
            "",
            "        If the given user may log in, this method should return None.",
            "        \"\"\"",
            "        if not user.is_active:",
            "            raise forms.ValidationError(",
            "                self.error_messages['inactive'],",
            "                code='inactive',",
            "            )",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "    def get_invalid_login_error(self):",
            "        return forms.ValidationError(",
            "            self.error_messages['invalid_login'],",
            "            code='invalid_login',",
            "            params={'username': self.username_field.verbose_name},",
            "        )",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    email = forms.EmailField(label=_(\"Email\"), max_length=254)",
            "",
            "    def send_mail(self, subject_template_name, email_template_name,",
            "                  context, from_email, to_email, html_email_template_name=None):",
            "        \"\"\"",
            "        Send a django.core.mail.EmailMultiAlternatives to `to_email`.",
            "        \"\"\"",
            "        subject = loader.render_to_string(subject_template_name, context)",
            "        # Email subject *must not* contain newlines",
            "        subject = ''.join(subject.splitlines())",
            "        body = loader.render_to_string(email_template_name, context)",
            "",
            "        email_message = EmailMultiAlternatives(subject, body, from_email, [to_email])",
            "        if html_email_template_name is not None:",
            "            html_email = loader.render_to_string(html_email_template_name, context)",
            "            email_message.attach_alternative(html_email, 'text/html')",
            "",
            "        email_message.send()",
            "",
            "    def get_users(self, email):",
            "        \"\"\"Given an email, return matching user(s) who should receive a reset.",
            "",
            "        This allows subclasses to more easily customize the default policies",
            "        that prevent inactive users and users with unusable passwords from",
            "        resetting their password.",
            "        \"\"\"",
            "        active_users = UserModel._default_manager.filter(**{",
            "            '%s__iexact' % UserModel.get_email_field_name(): email,",
            "            'is_active': True,",
            "        })",
            "        return (u for u in active_users if u.has_usable_password())",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None, html_email_template_name=None,",
            "             extra_email_context=None):",
            "        \"\"\"",
            "        Generate a one-use only link for resetting password and send it to the",
            "        user.",
            "        \"\"\"",
            "        email = self.cleaned_data[\"email\"]",
            "        for user in self.get_users(email):",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            context = {",
            "                'email': email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': urlsafe_base64_encode(force_bytes(user.pk)).decode(),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': 'https' if use_https else 'http',",
            "                **(extra_email_context or {}),",
            "            }",
            "            self.send_mail(",
            "                subject_template_name, email_template_name, context, from_email,",
            "                email, html_email_template_name=html_email_template_name,",
            "            )",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set their password without entering the old",
            "    password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(",
            "        label=_(\"New password\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    new_password2 = forms.CharField(",
            "        label=_(\"New password confirmation\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'],",
            "                    code='password_mismatch',",
            "                )",
            "        password_validation.validate_password(password2, self.user)",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        password = self.cleaned_data[\"new_password1\"]",
            "        self.user.set_password(password)",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change their password by entering their old",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        **SetPasswordForm.error_messages,",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. Please enter it again.\"),",
            "    }",
            "    old_password = forms.CharField(",
            "        label=_(\"Old password\"),",
            "        strip=False,",
            "        widget=forms.PasswordInput(attrs={'autofocus': True}),",
            "    )",
            "",
            "    field_order = ['old_password', 'new_password1', 'new_password2']",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validate that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'],",
            "                code='password_incorrect',",
            "            )",
            "        return old_password",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    required_css_class = 'required'",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput(attrs={'autofocus': True}),",
            "        strip=False,",
            "        help_text=password_validation.password_validators_help_text_html(),",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password (again)\"),",
            "        widget=forms.PasswordInput,",
            "        strip=False,",
            "        help_text=_(\"Enter the same password as before, for verification.\"),",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'],",
            "                    code='password_mismatch',",
            "                )",
            "        password_validation.validate_password(password2, self.user)",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"Save the new password.\"\"\"",
            "        password = self.cleaned_data[\"password1\"]",
            "        self.user.set_password(password)",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "    @property",
            "    def changed_data(self):",
            "        data = super().changed_data",
            "        for name in self.fields:",
            "            if name not in data:",
            "                return []",
            "        return ['password']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.contrib.auth.forms.ReadOnlyPasswordHashWidget.self",
            "django.contrib.auth.forms.ReadOnlyPasswordHashField.widget"
        ]
    }
}