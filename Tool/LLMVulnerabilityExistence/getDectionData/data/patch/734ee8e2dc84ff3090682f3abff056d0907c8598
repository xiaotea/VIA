{
    "weasyprint/html.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "             if url is None:"
            },
            "1": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "                 LOGGER.error('Missing href in <link rel=\"attachment\">')"
            },
            "2": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             else:"
            },
            "3": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                attachment = Attachment(url=url, description=attachment_title)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+                attachment = Attachment("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+                    url=url, description=attachment_title,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                    url_fetcher=html.url_fetcher)"
            },
            "7": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "                 attachments.append(attachment)"
            },
            "8": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "     return {"
            },
            "9": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         'title': title,"
            }
        },
        "frontPatchFile": [
            "\"\"\"Specific handling for some HTML elements, especially replaced elements.",
            "",
            "Replaced elements (eg. <img> elements) are rendered externally and behave as an",
            "atomic opaque box in CSS. In general, they may or may not have intrinsic",
            "dimensions. But the only replaced elements currently supported in WeasyPrint",
            "are images with intrinsic dimensions.",
            "",
            "\"\"\"",
            "",
            "try:",
            "    # Available in Python 3.9+",
            "    from importlib.resources import files",
            "except ImportError:  # pragma: no cover",
            "    # Deprecated in Python 3.11+",
            "    from importlib.resources import read_text",
            "else:",
            "    def read_text(package, resource):",
            "        return (files(package) / resource).read_text('utf-8')",
            "",
            "import re",
            "",
            "from . import CSS, Attachment, css",
            "from .css import get_child_text",
            "from .css.counters import CounterStyle",
            "from .formatting_structure import boxes",
            "from .images import SVGImage",
            "from .logger import LOGGER",
            "from .urls import get_url_attribute",
            "",
            "HTML5_UA_COUNTER_STYLE = CounterStyle()",
            "HTML5_UA = read_text(css, 'html5_ua.css')",
            "HTML5_UA_FORM = read_text(css, 'html5_ua_form.css')",
            "HTML5_PH = read_text(css, 'html5_ph.css')",
            "HTML5_UA_STYLESHEET = CSS(",
            "    string=HTML5_UA, counter_style=HTML5_UA_COUNTER_STYLE)",
            "HTML5_UA_FORM_STYLESHEET = CSS(",
            "    string=HTML5_UA_FORM, counter_style=HTML5_UA_COUNTER_STYLE)",
            "HTML5_PH_STYLESHEET = CSS(string=HTML5_PH)",
            "",
            "# https://html.spec.whatwg.org/multipage/#space-character",
            "HTML_WHITESPACE = ' \\t\\n\\f\\r'",
            "HTML_SPACE_SEPARATED_TOKENS_RE = re.compile(f'[^{HTML_WHITESPACE}]+')",
            "",
            "",
            "def ascii_lower(string):",
            "    r\"\"\"Transform (only) ASCII letters to lower case: A-Z is mapped to a-z.",
            "",
            "    This is used for `ASCII case-insensitive",
            "    <https://whatwg.org/C#ascii-case-insensitive>`_ matching.",
            "",
            "    This is different from the :meth:`str.lower` method of Unicode strings",
            "    which also affect non-ASCII characters,",
            "    sometimes mapping them into the ASCII range:",
            "",
            "    >>> keyword = 'Bac\\N{KELVIN SIGN}ground'",
            "    >>> assert keyword.lower() == 'background'",
            "    >>> assert ascii_lower(keyword) != keyword.lower()",
            "    >>> assert ascii_lower(keyword) == 'bac\\N{KELVIN SIGN}ground'",
            "",
            "    \"\"\"",
            "    # This turns out to be faster than unicode.translate()",
            "    return string.encode().lower().decode()",
            "",
            "",
            "def element_has_link_type(element, link_type):",
            "    \"\"\"Return whether element has a ``rel`` attribute with given link type.\"\"\"",
            "    tokens = HTML_SPACE_SEPARATED_TOKENS_RE.findall(element.get('rel', ''))",
            "    return any(ascii_lower(token) == link_type for token in tokens)",
            "",
            "",
            "# Maps HTML tag names to function taking an HTML element and returning a Box.",
            "HTML_HANDLERS = {}",
            "",
            "",
            "def handle_element(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle HTML elements that need special care.",
            "",
            "    :returns: a (possibly empty) list of boxes.",
            "    \"\"\"",
            "    if box.element_tag in HTML_HANDLERS:",
            "        return HTML_HANDLERS[element.tag](",
            "            element, box, get_image_from_uri, base_url)",
            "    else:",
            "        return [box]",
            "",
            "",
            "def handler(tag):",
            "    \"\"\"Return a decorator registering a function handling ``tag`` elements.\"\"\"",
            "    def decorator(function):",
            "        \"\"\"Decorator registering a function handling ``tag`` elements.\"\"\"",
            "        HTML_HANDLERS[tag] = function",
            "        return function",
            "    return decorator",
            "",
            "",
            "def make_replaced_box(element, box, image):",
            "    \"\"\"Wrap an image in a replaced box.",
            "",
            "    That box is either block-level or inline-level, depending on what the",
            "    element should be.",
            "",
            "    \"\"\"",
            "    type_ = (",
            "        boxes.BlockReplacedBox if 'block' in box.style['display']",
            "        else boxes.InlineReplacedBox)",
            "    new_box = type_(element.tag, box.style, element, image)",
            "    # TODO: check other attributes that need to be copied",
            "    # TODO: find another solution",
            "    new_box.string_set = box.string_set",
            "    new_box.bookmark_label = box.bookmark_label",
            "    return new_box",
            "",
            "",
            "@handler('img')",
            "def handle_img(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<img>`` elements.",
            "",
            "    Return either an image or the alt-text.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-1.html#the-img-element",
            "",
            "    \"\"\"",
            "    src = get_url_attribute(element, 'src', base_url)",
            "    alt = element.get('alt')",
            "    if src:",
            "        image = get_image_from_uri(",
            "            url=src, orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "        else:",
            "            # Invalid image, use the alt-text.",
            "            if alt:",
            "                box.children = [boxes.TextBox.anonymous_from(box, alt)]",
            "                return [box]",
            "            elif alt == '':",
            "                # The element represents nothing",
            "                return []",
            "            else:",
            "                assert alt is None",
            "                # TODO: find some indicator that an image is missing.",
            "                # For now, just remove the image.",
            "                return []",
            "    else:",
            "        if alt:",
            "            box.children = [boxes.TextBox.anonymous_from(box, alt)]",
            "            return [box]",
            "        else:",
            "            return []",
            "",
            "",
            "@handler('embed')",
            "def handle_embed(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<embed>`` elements, return either an image or nothing.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-0.html#the-embed-element",
            "",
            "    \"\"\"",
            "    src = get_url_attribute(element, 'src', base_url)",
            "    type_ = element.get('type', '').strip()",
            "    if src:",
            "        image = get_image_from_uri(",
            "            url=src, forced_mime_type=type_,",
            "            orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "    # No fallback.",
            "    return []",
            "",
            "",
            "@handler('object')",
            "def handle_object(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<object>`` elements, return either an image or the fallback.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-0.html#the-object-element",
            "",
            "    \"\"\"",
            "    data = get_url_attribute(element, 'data', base_url)",
            "    type_ = element.get('type', '').strip()",
            "    if data:",
            "        image = get_image_from_uri(",
            "            url=data, forced_mime_type=type_,",
            "            orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "    # The element\u2019s children are the fallback.",
            "    return [box]",
            "",
            "",
            "@handler('colgroup')",
            "def handle_colgroup(element, box, _get_image_from_uri, _base_url):",
            "    \"\"\"Handle the ``span`` attribute.\"\"\"",
            "    if isinstance(box, boxes.TableColumnGroupBox):",
            "        if not any(child.tag == 'col' for child in element):",
            "            box.children = [",
            "                boxes.TableColumnBox.anonymous_from(box, [])",
            "                for _ in range(box.span)]",
            "    return [box]",
            "",
            "",
            "@handler('col')",
            "def handle_col(element, box, _get_image_from_uri, _base_url):",
            "    \"\"\"Handle the ``span`` attribute.\"\"\"",
            "    if isinstance(box, boxes.TableColumnBox) and box.span > 1:",
            "        # Generate multiple boxes",
            "        # https://lists.w3.org/Archives/Public/www-style/2011Nov/0293.html",
            "        return [box.copy() for _i in range(box.span)]",
            "    return [box]",
            "",
            "",
            "@handler('{http://www.w3.org/2000/svg}svg')",
            "def handle_svg(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<svg>`` elements.",
            "",
            "    Return either an image or the fallback content.",
            "",
            "    \"\"\"",
            "    # TODO: handle href base for inline svg tags",
            "    url_fetcher = get_image_from_uri.keywords['url_fetcher']",
            "    context = get_image_from_uri.keywords['context']",
            "    try:",
            "        image = SVGImage(element, base_url, url_fetcher, context)",
            "    except Exception as exception:  # pragma: no cover",
            "        LOGGER.error('Failed to load inline SVG: %s', exception)",
            "        return []",
            "    else:",
            "        return [make_replaced_box(element, box, image)]",
            "",
            "",
            "def get_html_metadata(html):",
            "    \"\"\"Get metadata dictionary out of HTML object.",
            "",
            "    Relevant specs:",
            "",
            "    https://www.whatwg.org/html#the-title-element",
            "    https://www.whatwg.org/html#standard-metadata-names",
            "    https://wiki.whatwg.org/wiki/MetaExtensions",
            "    https://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions",
            "",
            "    \"\"\"",
            "    title = None",
            "    description = None",
            "    generator = None",
            "    keywords = []",
            "    authors = []",
            "    created = None",
            "    modified = None",
            "    attachments = []",
            "    custom = {}",
            "    lang = html.etree_element.attrib.get('lang', None)",
            "    for element in html.wrapper_element.query_all('title', 'meta', 'link'):",
            "        element = element.etree_element",
            "        if element.tag == 'title' and title is None:",
            "            title = get_child_text(element)",
            "        elif element.tag == 'meta':",
            "            name = ascii_lower(element.get('name', ''))",
            "            content = element.get('content', '')",
            "            if name == 'keywords':",
            "                for keyword in map(strip_whitespace, content.split(',')):",
            "                    if keyword not in keywords:",
            "                        keywords.append(keyword)",
            "            elif name == 'author':",
            "                authors.append(content)",
            "            elif name == 'description':",
            "                if description is None:",
            "                    description = content",
            "            elif name == 'generator':",
            "                if generator is None:",
            "                    generator = content",
            "            elif name == 'dcterms.created':",
            "                if created is None:",
            "                    created = parse_w3c_date(name, content)",
            "            elif name == 'dcterms.modified':",
            "                if modified is None:",
            "                    modified = parse_w3c_date(name, content)",
            "            elif name and name not in custom:",
            "                custom[name] = content",
            "        elif element.tag == 'link' and element_has_link_type(",
            "                element, 'attachment'):",
            "            url = get_url_attribute(element, 'href', html.base_url)",
            "            attachment_title = element.get('title', None)",
            "            if url is None:",
            "                LOGGER.error('Missing href in <link rel=\"attachment\">')",
            "            else:",
            "                attachment = Attachment(url=url, description=attachment_title)",
            "                attachments.append(attachment)",
            "    return {",
            "        'title': title,",
            "        'description': description,",
            "        'generator': generator,",
            "        'keywords': keywords,",
            "        'authors': authors,",
            "        'created': created,",
            "        'modified': modified,",
            "        'attachments': attachments,",
            "        'lang': lang,",
            "        'custom': custom,",
            "    }",
            "",
            "",
            "def strip_whitespace(string):",
            "    \"\"\"Use the HTML definition of \"space character\",",
            "    not all Unicode Whitespace.",
            "",
            "    https://www.whatwg.org/html#strip-leading-and-trailing-whitespace",
            "    https://www.whatwg.org/html#space-character",
            "",
            "    \"\"\"",
            "    return string.strip(HTML_WHITESPACE)",
            "",
            "",
            "# YYYY (eg 1997)",
            "# YYYY-MM (eg 1997-07)",
            "# YYYY-MM-DD (eg 1997-07-16)",
            "# YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)",
            "# YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)",
            "# YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)",
            "",
            "W3C_DATE_RE = re.compile('''",
            "    ^",
            "    [ \\t\\n\\f\\r]*",
            "    (?P<year>\\\\d\\\\d\\\\d\\\\d)",
            "    (?:",
            "        -(?P<month>0\\\\d|1[012])",
            "        (?:",
            "            -(?P<day>[012]\\\\d|3[01])",
            "            (?:",
            "                T(?P<hour>[01]\\\\d|2[0-3])",
            "                :(?P<minute>[0-5]\\\\d)",
            "                (?:",
            "                    :(?P<second>[0-5]\\\\d)",
            "                    (?:\\\\.\\\\d+)?  # Second fraction, ignored",
            "                )?",
            "                (?:",
            "                    Z |  # UTC",
            "                    (?P<tz_hour>[+-](?:[01]\\\\d|2[0-3]))",
            "                    :(?P<tz_minute>[0-5]\\\\d)",
            "                )",
            "            )?",
            "        )?",
            "    )?",
            "    [ \\t\\n\\f\\r]*",
            "    $",
            "''', re.VERBOSE)",
            "",
            "",
            "def parse_w3c_date(meta_name, string):",
            "    \"\"\"Parse datetimes as defined by the W3C.",
            "",
            "    See https://www.w3.org/TR/NOTE-datetime",
            "",
            "    \"\"\"",
            "    if W3C_DATE_RE.match(string):",
            "        return string",
            "    else:",
            "        LOGGER.warning(",
            "            'Invalid date in <meta name=\"%s\"> %r', meta_name, string)"
        ],
        "afterPatchFile": [
            "\"\"\"Specific handling for some HTML elements, especially replaced elements.",
            "",
            "Replaced elements (eg. <img> elements) are rendered externally and behave as an",
            "atomic opaque box in CSS. In general, they may or may not have intrinsic",
            "dimensions. But the only replaced elements currently supported in WeasyPrint",
            "are images with intrinsic dimensions.",
            "",
            "\"\"\"",
            "",
            "try:",
            "    # Available in Python 3.9+",
            "    from importlib.resources import files",
            "except ImportError:  # pragma: no cover",
            "    # Deprecated in Python 3.11+",
            "    from importlib.resources import read_text",
            "else:",
            "    def read_text(package, resource):",
            "        return (files(package) / resource).read_text('utf-8')",
            "",
            "import re",
            "",
            "from . import CSS, Attachment, css",
            "from .css import get_child_text",
            "from .css.counters import CounterStyle",
            "from .formatting_structure import boxes",
            "from .images import SVGImage",
            "from .logger import LOGGER",
            "from .urls import get_url_attribute",
            "",
            "HTML5_UA_COUNTER_STYLE = CounterStyle()",
            "HTML5_UA = read_text(css, 'html5_ua.css')",
            "HTML5_UA_FORM = read_text(css, 'html5_ua_form.css')",
            "HTML5_PH = read_text(css, 'html5_ph.css')",
            "HTML5_UA_STYLESHEET = CSS(",
            "    string=HTML5_UA, counter_style=HTML5_UA_COUNTER_STYLE)",
            "HTML5_UA_FORM_STYLESHEET = CSS(",
            "    string=HTML5_UA_FORM, counter_style=HTML5_UA_COUNTER_STYLE)",
            "HTML5_PH_STYLESHEET = CSS(string=HTML5_PH)",
            "",
            "# https://html.spec.whatwg.org/multipage/#space-character",
            "HTML_WHITESPACE = ' \\t\\n\\f\\r'",
            "HTML_SPACE_SEPARATED_TOKENS_RE = re.compile(f'[^{HTML_WHITESPACE}]+')",
            "",
            "",
            "def ascii_lower(string):",
            "    r\"\"\"Transform (only) ASCII letters to lower case: A-Z is mapped to a-z.",
            "",
            "    This is used for `ASCII case-insensitive",
            "    <https://whatwg.org/C#ascii-case-insensitive>`_ matching.",
            "",
            "    This is different from the :meth:`str.lower` method of Unicode strings",
            "    which also affect non-ASCII characters,",
            "    sometimes mapping them into the ASCII range:",
            "",
            "    >>> keyword = 'Bac\\N{KELVIN SIGN}ground'",
            "    >>> assert keyword.lower() == 'background'",
            "    >>> assert ascii_lower(keyword) != keyword.lower()",
            "    >>> assert ascii_lower(keyword) == 'bac\\N{KELVIN SIGN}ground'",
            "",
            "    \"\"\"",
            "    # This turns out to be faster than unicode.translate()",
            "    return string.encode().lower().decode()",
            "",
            "",
            "def element_has_link_type(element, link_type):",
            "    \"\"\"Return whether element has a ``rel`` attribute with given link type.\"\"\"",
            "    tokens = HTML_SPACE_SEPARATED_TOKENS_RE.findall(element.get('rel', ''))",
            "    return any(ascii_lower(token) == link_type for token in tokens)",
            "",
            "",
            "# Maps HTML tag names to function taking an HTML element and returning a Box.",
            "HTML_HANDLERS = {}",
            "",
            "",
            "def handle_element(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle HTML elements that need special care.",
            "",
            "    :returns: a (possibly empty) list of boxes.",
            "    \"\"\"",
            "    if box.element_tag in HTML_HANDLERS:",
            "        return HTML_HANDLERS[element.tag](",
            "            element, box, get_image_from_uri, base_url)",
            "    else:",
            "        return [box]",
            "",
            "",
            "def handler(tag):",
            "    \"\"\"Return a decorator registering a function handling ``tag`` elements.\"\"\"",
            "    def decorator(function):",
            "        \"\"\"Decorator registering a function handling ``tag`` elements.\"\"\"",
            "        HTML_HANDLERS[tag] = function",
            "        return function",
            "    return decorator",
            "",
            "",
            "def make_replaced_box(element, box, image):",
            "    \"\"\"Wrap an image in a replaced box.",
            "",
            "    That box is either block-level or inline-level, depending on what the",
            "    element should be.",
            "",
            "    \"\"\"",
            "    type_ = (",
            "        boxes.BlockReplacedBox if 'block' in box.style['display']",
            "        else boxes.InlineReplacedBox)",
            "    new_box = type_(element.tag, box.style, element, image)",
            "    # TODO: check other attributes that need to be copied",
            "    # TODO: find another solution",
            "    new_box.string_set = box.string_set",
            "    new_box.bookmark_label = box.bookmark_label",
            "    return new_box",
            "",
            "",
            "@handler('img')",
            "def handle_img(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<img>`` elements.",
            "",
            "    Return either an image or the alt-text.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-1.html#the-img-element",
            "",
            "    \"\"\"",
            "    src = get_url_attribute(element, 'src', base_url)",
            "    alt = element.get('alt')",
            "    if src:",
            "        image = get_image_from_uri(",
            "            url=src, orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "        else:",
            "            # Invalid image, use the alt-text.",
            "            if alt:",
            "                box.children = [boxes.TextBox.anonymous_from(box, alt)]",
            "                return [box]",
            "            elif alt == '':",
            "                # The element represents nothing",
            "                return []",
            "            else:",
            "                assert alt is None",
            "                # TODO: find some indicator that an image is missing.",
            "                # For now, just remove the image.",
            "                return []",
            "    else:",
            "        if alt:",
            "            box.children = [boxes.TextBox.anonymous_from(box, alt)]",
            "            return [box]",
            "        else:",
            "            return []",
            "",
            "",
            "@handler('embed')",
            "def handle_embed(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<embed>`` elements, return either an image or nothing.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-0.html#the-embed-element",
            "",
            "    \"\"\"",
            "    src = get_url_attribute(element, 'src', base_url)",
            "    type_ = element.get('type', '').strip()",
            "    if src:",
            "        image = get_image_from_uri(",
            "            url=src, forced_mime_type=type_,",
            "            orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "    # No fallback.",
            "    return []",
            "",
            "",
            "@handler('object')",
            "def handle_object(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<object>`` elements, return either an image or the fallback.",
            "",
            "    See: https://www.w3.org/TR/html5/embedded-content-0.html#the-object-element",
            "",
            "    \"\"\"",
            "    data = get_url_attribute(element, 'data', base_url)",
            "    type_ = element.get('type', '').strip()",
            "    if data:",
            "        image = get_image_from_uri(",
            "            url=data, forced_mime_type=type_,",
            "            orientation=box.style['image_orientation'])",
            "        if image is not None:",
            "            return [make_replaced_box(element, box, image)]",
            "    # The element\u2019s children are the fallback.",
            "    return [box]",
            "",
            "",
            "@handler('colgroup')",
            "def handle_colgroup(element, box, _get_image_from_uri, _base_url):",
            "    \"\"\"Handle the ``span`` attribute.\"\"\"",
            "    if isinstance(box, boxes.TableColumnGroupBox):",
            "        if not any(child.tag == 'col' for child in element):",
            "            box.children = [",
            "                boxes.TableColumnBox.anonymous_from(box, [])",
            "                for _ in range(box.span)]",
            "    return [box]",
            "",
            "",
            "@handler('col')",
            "def handle_col(element, box, _get_image_from_uri, _base_url):",
            "    \"\"\"Handle the ``span`` attribute.\"\"\"",
            "    if isinstance(box, boxes.TableColumnBox) and box.span > 1:",
            "        # Generate multiple boxes",
            "        # https://lists.w3.org/Archives/Public/www-style/2011Nov/0293.html",
            "        return [box.copy() for _i in range(box.span)]",
            "    return [box]",
            "",
            "",
            "@handler('{http://www.w3.org/2000/svg}svg')",
            "def handle_svg(element, box, get_image_from_uri, base_url):",
            "    \"\"\"Handle ``<svg>`` elements.",
            "",
            "    Return either an image or the fallback content.",
            "",
            "    \"\"\"",
            "    # TODO: handle href base for inline svg tags",
            "    url_fetcher = get_image_from_uri.keywords['url_fetcher']",
            "    context = get_image_from_uri.keywords['context']",
            "    try:",
            "        image = SVGImage(element, base_url, url_fetcher, context)",
            "    except Exception as exception:  # pragma: no cover",
            "        LOGGER.error('Failed to load inline SVG: %s', exception)",
            "        return []",
            "    else:",
            "        return [make_replaced_box(element, box, image)]",
            "",
            "",
            "def get_html_metadata(html):",
            "    \"\"\"Get metadata dictionary out of HTML object.",
            "",
            "    Relevant specs:",
            "",
            "    https://www.whatwg.org/html#the-title-element",
            "    https://www.whatwg.org/html#standard-metadata-names",
            "    https://wiki.whatwg.org/wiki/MetaExtensions",
            "    https://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions",
            "",
            "    \"\"\"",
            "    title = None",
            "    description = None",
            "    generator = None",
            "    keywords = []",
            "    authors = []",
            "    created = None",
            "    modified = None",
            "    attachments = []",
            "    custom = {}",
            "    lang = html.etree_element.attrib.get('lang', None)",
            "    for element in html.wrapper_element.query_all('title', 'meta', 'link'):",
            "        element = element.etree_element",
            "        if element.tag == 'title' and title is None:",
            "            title = get_child_text(element)",
            "        elif element.tag == 'meta':",
            "            name = ascii_lower(element.get('name', ''))",
            "            content = element.get('content', '')",
            "            if name == 'keywords':",
            "                for keyword in map(strip_whitespace, content.split(',')):",
            "                    if keyword not in keywords:",
            "                        keywords.append(keyword)",
            "            elif name == 'author':",
            "                authors.append(content)",
            "            elif name == 'description':",
            "                if description is None:",
            "                    description = content",
            "            elif name == 'generator':",
            "                if generator is None:",
            "                    generator = content",
            "            elif name == 'dcterms.created':",
            "                if created is None:",
            "                    created = parse_w3c_date(name, content)",
            "            elif name == 'dcterms.modified':",
            "                if modified is None:",
            "                    modified = parse_w3c_date(name, content)",
            "            elif name and name not in custom:",
            "                custom[name] = content",
            "        elif element.tag == 'link' and element_has_link_type(",
            "                element, 'attachment'):",
            "            url = get_url_attribute(element, 'href', html.base_url)",
            "            attachment_title = element.get('title', None)",
            "            if url is None:",
            "                LOGGER.error('Missing href in <link rel=\"attachment\">')",
            "            else:",
            "                attachment = Attachment(",
            "                    url=url, description=attachment_title,",
            "                    url_fetcher=html.url_fetcher)",
            "                attachments.append(attachment)",
            "    return {",
            "        'title': title,",
            "        'description': description,",
            "        'generator': generator,",
            "        'keywords': keywords,",
            "        'authors': authors,",
            "        'created': created,",
            "        'modified': modified,",
            "        'attachments': attachments,",
            "        'lang': lang,",
            "        'custom': custom,",
            "    }",
            "",
            "",
            "def strip_whitespace(string):",
            "    \"\"\"Use the HTML definition of \"space character\",",
            "    not all Unicode Whitespace.",
            "",
            "    https://www.whatwg.org/html#strip-leading-and-trailing-whitespace",
            "    https://www.whatwg.org/html#space-character",
            "",
            "    \"\"\"",
            "    return string.strip(HTML_WHITESPACE)",
            "",
            "",
            "# YYYY (eg 1997)",
            "# YYYY-MM (eg 1997-07)",
            "# YYYY-MM-DD (eg 1997-07-16)",
            "# YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)",
            "# YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)",
            "# YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)",
            "",
            "W3C_DATE_RE = re.compile('''",
            "    ^",
            "    [ \\t\\n\\f\\r]*",
            "    (?P<year>\\\\d\\\\d\\\\d\\\\d)",
            "    (?:",
            "        -(?P<month>0\\\\d|1[012])",
            "        (?:",
            "            -(?P<day>[012]\\\\d|3[01])",
            "            (?:",
            "                T(?P<hour>[01]\\\\d|2[0-3])",
            "                :(?P<minute>[0-5]\\\\d)",
            "                (?:",
            "                    :(?P<second>[0-5]\\\\d)",
            "                    (?:\\\\.\\\\d+)?  # Second fraction, ignored",
            "                )?",
            "                (?:",
            "                    Z |  # UTC",
            "                    (?P<tz_hour>[+-](?:[01]\\\\d|2[0-3]))",
            "                    :(?P<tz_minute>[0-5]\\\\d)",
            "                )",
            "            )?",
            "        )?",
            "    )?",
            "    [ \\t\\n\\f\\r]*",
            "    $",
            "''', re.VERBOSE)",
            "",
            "",
            "def parse_w3c_date(meta_name, string):",
            "    \"\"\"Parse datetimes as defined by the W3C.",
            "",
            "    See https://www.w3.org/TR/NOTE-datetime",
            "",
            "    \"\"\"",
            "    if W3C_DATE_RE.match(string):",
            "        return string",
            "    else:",
            "        LOGGER.warning(",
            "            'Invalid date in <meta name=\"%s\"> %r', meta_name, string)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "284": [
                "get_html_metadata"
            ]
        },
        "addLocation": []
    },
    "weasyprint/pdf/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "     if options['attachments']:"
            },
            "1": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         for attachment in options['attachments']:"
            },
            "2": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             if not isinstance(attachment, Attachment):"
            },
            "3": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                attachment = Attachment(attachment)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+                attachment = Attachment("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                    attachment, url_fetcher=document.url_fetcher)"
            },
            "6": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             attachments.append(attachment)"
            },
            "7": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     pdf_attachments = []"
            },
            "8": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "     for attachment in attachments:"
            }
        },
        "frontPatchFile": [
            "\"\"\"PDF generation management.\"\"\"",
            "",
            "import pydyf",
            "",
            "from .. import VERSION, Attachment",
            "from ..html import W3C_DATE_RE",
            "from ..logger import LOGGER, PROGRESS_LOGGER",
            "from ..matrix import Matrix",
            "from . import pdfa, pdfua",
            "from .anchors import (",
            "    add_annotations, add_inputs, add_links, add_outlines, resolve_links,",
            "    write_pdf_attachment)",
            "from .fonts import build_fonts_dictionary",
            "from .stream import Stream",
            "",
            "VARIANTS = {",
            "    name: data for variants in (pdfa.VARIANTS, pdfua.VARIANTS)",
            "    for (name, data) in variants.items()}",
            "",
            "",
            "def _w3c_date_to_pdf(string, attr_name):",
            "    \"\"\"Tranform W3C date to PDF format.\"\"\"",
            "    if string is None:",
            "        return None",
            "    match = W3C_DATE_RE.match(string)",
            "    if match is None:",
            "        LOGGER.warning(f'Invalid {attr_name} date: {string!r}')",
            "        return None",
            "    groups = match.groupdict()",
            "    pdf_date = ''",
            "    found = groups['hour']",
            "    for key in ('second', 'minute', 'hour', 'day', 'month', 'year'):",
            "        if groups[key]:",
            "            found = True",
            "            pdf_date = groups[key] + pdf_date",
            "        elif found:",
            "            pdf_date = f'{(key in (\"day\", \"month\")):02d}{pdf_date}'",
            "    if groups['hour']:",
            "        assert groups['minute']",
            "        if groups['tz_hour']:",
            "            assert groups['tz_hour'].startswith(('+', '-'))",
            "            assert groups['tz_minute']",
            "            tz_hour = int(groups['tz_hour'])",
            "            tz_minute = int(groups['tz_minute'])",
            "            pdf_date += f\"{tz_hour:+03d}'{tz_minute:02d}\"",
            "        else:",
            "            pdf_date += 'Z'",
            "    return f'D:{pdf_date}'",
            "",
            "",
            "def _reference_resources(pdf, resources, images, fonts):",
            "    if 'Font' in resources:",
            "        assert resources['Font'] is None",
            "        resources['Font'] = fonts",
            "    _use_references(pdf, resources, images)",
            "    pdf.add_object(resources)",
            "    return resources.reference",
            "",
            "",
            "def _use_references(pdf, resources, images):",
            "    # XObjects",
            "    for key, x_object in resources.get('XObject', {}).items():",
            "        # Images",
            "        if x_object is None:",
            "            image_data = images[key]",
            "            x_object = image_data['x_object']",
            "",
            "            if x_object is not None:",
            "                # Image already added to PDF",
            "                resources['XObject'][key] = x_object.reference",
            "                continue",
            "",
            "            image = image_data['image']",
            "            dpi_ratio = max(image_data['dpi_ratios'])",
            "            x_object = image.get_x_object(image_data['interpolate'], dpi_ratio)",
            "            image_data['x_object'] = x_object",
            "",
            "        pdf.add_object(x_object)",
            "        resources['XObject'][key] = x_object.reference",
            "",
            "        # Masks",
            "        if 'SMask' in x_object.extra:",
            "            pdf.add_object(x_object.extra['SMask'])",
            "            x_object.extra['SMask'] = x_object.extra['SMask'].reference",
            "",
            "        # Resources",
            "        if 'Resources' in x_object.extra:",
            "            x_object.extra['Resources'] = _reference_resources(",
            "                pdf, x_object.extra['Resources'], images, resources['Font'])",
            "",
            "    # Patterns",
            "    for key, pattern in resources.get('Pattern', {}).items():",
            "        pdf.add_object(pattern)",
            "        resources['Pattern'][key] = pattern.reference",
            "        if 'Resources' in pattern.extra:",
            "            pattern.extra['Resources'] = _reference_resources(",
            "                pdf, pattern.extra['Resources'], images, resources['Font'])",
            "",
            "    # Shadings",
            "    for key, shading in resources.get('Shading', {}).items():",
            "        pdf.add_object(shading)",
            "        resources['Shading'][key] = shading.reference",
            "",
            "    # Alpha states",
            "    for key, alpha in resources.get('ExtGState', {}).items():",
            "        if 'SMask' in alpha and 'G' in alpha['SMask']:",
            "            alpha['SMask']['G'] = alpha['SMask']['G'].reference",
            "",
            "",
            "def generate_pdf(document, target, zoom, **options):",
            "    # 0.75 = 72 PDF point per inch / 96 CSS pixel per inch",
            "    scale = zoom * 0.75",
            "",
            "    PROGRESS_LOGGER.info('Step 6 - Creating PDF')",
            "",
            "    # Set properties according to PDF variants",
            "    mark = False",
            "    variant, version = options['pdf_variant'], options['pdf_version']",
            "    if variant:",
            "        variant_function, properties = VARIANTS[variant]",
            "        if 'version' in properties:",
            "            version = properties['version']",
            "        if 'mark' in properties:",
            "            mark = properties['mark']",
            "",
            "    identifier = options['pdf_identifier']",
            "    pdf = pydyf.PDF((version or '1.7'), identifier)",
            "    states = pydyf.Dictionary()",
            "    x_objects = pydyf.Dictionary()",
            "    patterns = pydyf.Dictionary()",
            "    shadings = pydyf.Dictionary()",
            "    images = {}",
            "    resources = pydyf.Dictionary({",
            "        'ExtGState': states,",
            "        'XObject': x_objects,",
            "        'Pattern': patterns,",
            "        'Shading': shadings,",
            "    })",
            "    pdf.add_object(resources)",
            "    pdf_names = []",
            "",
            "    # Links and anchors",
            "    page_links_and_anchors = list(resolve_links(document.pages))",
            "",
            "    annot_files = {}",
            "    pdf_pages, page_streams = [], []",
            "    compress = not options['uncompressed_pdf']",
            "    for page_number, (page, links_and_anchors) in enumerate(",
            "            zip(document.pages, page_links_and_anchors)):",
            "        # Draw from the top-left corner",
            "        matrix = Matrix(scale, 0, 0, -scale, 0, page.height * scale)",
            "",
            "        page_width = scale * (",
            "            page.width + page.bleed['left'] + page.bleed['right'])",
            "        page_height = scale * (",
            "            page.height + page.bleed['top'] + page.bleed['bottom'])",
            "        left = -scale * page.bleed['left']",
            "        top = -scale * page.bleed['top']",
            "        right = left + page_width",
            "        bottom = top + page_height",
            "",
            "        page_rectangle = (",
            "            left / scale, top / scale,",
            "            (right - left) / scale, (bottom - top) / scale)",
            "        stream = Stream(",
            "            document.fonts, page_rectangle, states, x_objects, patterns,",
            "            shadings, images, mark, compress=compress)",
            "        stream.transform(d=-1, f=(page.height * scale))",
            "        pdf.add_object(stream)",
            "        page_streams.append(stream)",
            "",
            "        pdf_page = pydyf.Dictionary({",
            "            'Type': '/Page',",
            "            'Parent': pdf.pages.reference,",
            "            'MediaBox': pydyf.Array([left, top, right, bottom]),",
            "            'Contents': stream.reference,",
            "            'Resources': resources.reference,",
            "        })",
            "        if mark:",
            "            pdf_page['Tabs'] = '/S'",
            "            pdf_page['StructParents'] = page_number",
            "        pdf.add_page(pdf_page)",
            "        pdf_pages.append(pdf_page)",
            "",
            "        add_links(links_and_anchors, matrix, pdf, pdf_page, pdf_names, mark)",
            "        add_annotations(",
            "            links_and_anchors[0], matrix, document, pdf, pdf_page, annot_files,",
            "            compress)",
            "        add_inputs(",
            "            page.inputs, matrix, pdf, pdf_page, resources, stream,",
            "            document.font_config.font_map, compress)",
            "        page.paint(stream, scale)",
            "",
            "        # Bleed",
            "        bleed = {key: value * 0.75 for key, value in page.bleed.items()}",
            "",
            "        trim_left = left + bleed['left']",
            "        trim_top = top + bleed['top']",
            "        trim_right = right - bleed['right']",
            "        trim_bottom = bottom - bleed['bottom']",
            "",
            "        # Arbitrarly set PDF BleedBox between CSS bleed box (MediaBox) and",
            "        # CSS page box (TrimBox) at most 10 points from the TrimBox.",
            "        bleed_left = trim_left - min(10, bleed['left'])",
            "        bleed_top = trim_top - min(10, bleed['top'])",
            "        bleed_right = trim_right + min(10, bleed['right'])",
            "        bleed_bottom = trim_bottom + min(10, bleed['bottom'])",
            "",
            "        pdf_page['TrimBox'] = pydyf.Array([",
            "            trim_left, trim_top, trim_right, trim_bottom])",
            "        pdf_page['BleedBox'] = pydyf.Array([",
            "            bleed_left, bleed_top, bleed_right, bleed_bottom])",
            "",
            "    # Outlines",
            "    add_outlines(pdf, document.make_bookmark_tree(scale, transform_pages=True))",
            "",
            "    PROGRESS_LOGGER.info('Step 7 - Adding PDF metadata')",
            "",
            "    # PDF information",
            "    pdf.info['Producer'] = pydyf.String(f'WeasyPrint {VERSION}')",
            "    metadata = document.metadata",
            "    if metadata.title:",
            "        pdf.info['Title'] = pydyf.String(metadata.title)",
            "    if metadata.authors:",
            "        pdf.info['Author'] = pydyf.String(', '.join(metadata.authors))",
            "    if metadata.description:",
            "        pdf.info['Subject'] = pydyf.String(metadata.description)",
            "    if metadata.keywords:",
            "        pdf.info['Keywords'] = pydyf.String(', '.join(metadata.keywords))",
            "    if metadata.generator:",
            "        pdf.info['Creator'] = pydyf.String(metadata.generator)",
            "    if metadata.created:",
            "        pdf.info['CreationDate'] = pydyf.String(",
            "            _w3c_date_to_pdf(metadata.created, 'created'))",
            "    if metadata.modified:",
            "        pdf.info['ModDate'] = pydyf.String(",
            "            _w3c_date_to_pdf(metadata.modified, 'modified'))",
            "    if metadata.lang:",
            "        pdf.catalog['Lang'] = pydyf.String(metadata.lang)",
            "    if options['custom_metadata']:",
            "        for key, value in metadata.custom.items():",
            "            key = ''.join(char for char in key if char.isalnum())",
            "            key = key.encode('ascii', errors='ignore').decode()",
            "            if key:",
            "                pdf.info[key] = pydyf.String(value)",
            "",
            "    # Embedded files",
            "    attachments = metadata.attachments.copy()",
            "    if options['attachments']:",
            "        for attachment in options['attachments']:",
            "            if not isinstance(attachment, Attachment):",
            "                attachment = Attachment(attachment)",
            "            attachments.append(attachment)",
            "    pdf_attachments = []",
            "    for attachment in attachments:",
            "        pdf_attachment = write_pdf_attachment(pdf, attachment, compress)",
            "        if pdf_attachment is not None:",
            "            pdf_attachments.append(pdf_attachment)",
            "    if pdf_attachments:",
            "        content = pydyf.Dictionary({'Names': pydyf.Array()})",
            "        for i, pdf_attachment in enumerate(pdf_attachments):",
            "            content['Names'].append(pydyf.String(f'attachment{i}'))",
            "            content['Names'].append(pdf_attachment.reference)",
            "        pdf.add_object(content)",
            "        if 'Names' not in pdf.catalog:",
            "            pdf.catalog['Names'] = pydyf.Dictionary()",
            "        pdf.catalog['Names']['EmbeddedFiles'] = content.reference",
            "",
            "    # Embedded fonts",
            "    subset = not options['full_fonts']",
            "    hinting = options['hinting']",
            "    pdf_fonts = build_fonts_dictionary(",
            "        pdf, document.fonts, compress, subset, hinting)",
            "    pdf.add_object(pdf_fonts)",
            "    if 'AcroForm' in pdf.catalog:",
            "        # Include Dingbats for forms",
            "        dingbats = pydyf.Dictionary({",
            "            'Type': '/Font',",
            "            'Subtype': '/Type1',",
            "            'BaseFont': '/ZapfDingbats',",
            "        })",
            "        pdf.add_object(dingbats)",
            "        pdf_fonts['ZaDb'] = dingbats.reference",
            "    resources['Font'] = pdf_fonts.reference",
            "    _use_references(pdf, resources, images)",
            "",
            "    # Anchors",
            "    if pdf_names:",
            "        # Anchors are name trees that have to be sorted",
            "        name_array = pydyf.Array()",
            "        for anchor in sorted(pdf_names):",
            "            name_array.append(pydyf.String(anchor[0]))",
            "            name_array.append(anchor[1])",
            "        dests = pydyf.Dictionary({'Names': name_array})",
            "        if 'Names' not in pdf.catalog:",
            "            pdf.catalog['Names'] = pydyf.Dictionary()",
            "        pdf.catalog['Names']['Dests'] = dests",
            "",
            "    # Apply PDF variants functions",
            "    if variant:",
            "        variant_function(",
            "            pdf, metadata, document, page_streams, attachments, compress)",
            "",
            "    return pdf"
        ],
        "afterPatchFile": [
            "\"\"\"PDF generation management.\"\"\"",
            "",
            "import pydyf",
            "",
            "from .. import VERSION, Attachment",
            "from ..html import W3C_DATE_RE",
            "from ..logger import LOGGER, PROGRESS_LOGGER",
            "from ..matrix import Matrix",
            "from . import pdfa, pdfua",
            "from .anchors import (",
            "    add_annotations, add_inputs, add_links, add_outlines, resolve_links,",
            "    write_pdf_attachment)",
            "from .fonts import build_fonts_dictionary",
            "from .stream import Stream",
            "",
            "VARIANTS = {",
            "    name: data for variants in (pdfa.VARIANTS, pdfua.VARIANTS)",
            "    for (name, data) in variants.items()}",
            "",
            "",
            "def _w3c_date_to_pdf(string, attr_name):",
            "    \"\"\"Tranform W3C date to PDF format.\"\"\"",
            "    if string is None:",
            "        return None",
            "    match = W3C_DATE_RE.match(string)",
            "    if match is None:",
            "        LOGGER.warning(f'Invalid {attr_name} date: {string!r}')",
            "        return None",
            "    groups = match.groupdict()",
            "    pdf_date = ''",
            "    found = groups['hour']",
            "    for key in ('second', 'minute', 'hour', 'day', 'month', 'year'):",
            "        if groups[key]:",
            "            found = True",
            "            pdf_date = groups[key] + pdf_date",
            "        elif found:",
            "            pdf_date = f'{(key in (\"day\", \"month\")):02d}{pdf_date}'",
            "    if groups['hour']:",
            "        assert groups['minute']",
            "        if groups['tz_hour']:",
            "            assert groups['tz_hour'].startswith(('+', '-'))",
            "            assert groups['tz_minute']",
            "            tz_hour = int(groups['tz_hour'])",
            "            tz_minute = int(groups['tz_minute'])",
            "            pdf_date += f\"{tz_hour:+03d}'{tz_minute:02d}\"",
            "        else:",
            "            pdf_date += 'Z'",
            "    return f'D:{pdf_date}'",
            "",
            "",
            "def _reference_resources(pdf, resources, images, fonts):",
            "    if 'Font' in resources:",
            "        assert resources['Font'] is None",
            "        resources['Font'] = fonts",
            "    _use_references(pdf, resources, images)",
            "    pdf.add_object(resources)",
            "    return resources.reference",
            "",
            "",
            "def _use_references(pdf, resources, images):",
            "    # XObjects",
            "    for key, x_object in resources.get('XObject', {}).items():",
            "        # Images",
            "        if x_object is None:",
            "            image_data = images[key]",
            "            x_object = image_data['x_object']",
            "",
            "            if x_object is not None:",
            "                # Image already added to PDF",
            "                resources['XObject'][key] = x_object.reference",
            "                continue",
            "",
            "            image = image_data['image']",
            "            dpi_ratio = max(image_data['dpi_ratios'])",
            "            x_object = image.get_x_object(image_data['interpolate'], dpi_ratio)",
            "            image_data['x_object'] = x_object",
            "",
            "        pdf.add_object(x_object)",
            "        resources['XObject'][key] = x_object.reference",
            "",
            "        # Masks",
            "        if 'SMask' in x_object.extra:",
            "            pdf.add_object(x_object.extra['SMask'])",
            "            x_object.extra['SMask'] = x_object.extra['SMask'].reference",
            "",
            "        # Resources",
            "        if 'Resources' in x_object.extra:",
            "            x_object.extra['Resources'] = _reference_resources(",
            "                pdf, x_object.extra['Resources'], images, resources['Font'])",
            "",
            "    # Patterns",
            "    for key, pattern in resources.get('Pattern', {}).items():",
            "        pdf.add_object(pattern)",
            "        resources['Pattern'][key] = pattern.reference",
            "        if 'Resources' in pattern.extra:",
            "            pattern.extra['Resources'] = _reference_resources(",
            "                pdf, pattern.extra['Resources'], images, resources['Font'])",
            "",
            "    # Shadings",
            "    for key, shading in resources.get('Shading', {}).items():",
            "        pdf.add_object(shading)",
            "        resources['Shading'][key] = shading.reference",
            "",
            "    # Alpha states",
            "    for key, alpha in resources.get('ExtGState', {}).items():",
            "        if 'SMask' in alpha and 'G' in alpha['SMask']:",
            "            alpha['SMask']['G'] = alpha['SMask']['G'].reference",
            "",
            "",
            "def generate_pdf(document, target, zoom, **options):",
            "    # 0.75 = 72 PDF point per inch / 96 CSS pixel per inch",
            "    scale = zoom * 0.75",
            "",
            "    PROGRESS_LOGGER.info('Step 6 - Creating PDF')",
            "",
            "    # Set properties according to PDF variants",
            "    mark = False",
            "    variant, version = options['pdf_variant'], options['pdf_version']",
            "    if variant:",
            "        variant_function, properties = VARIANTS[variant]",
            "        if 'version' in properties:",
            "            version = properties['version']",
            "        if 'mark' in properties:",
            "            mark = properties['mark']",
            "",
            "    identifier = options['pdf_identifier']",
            "    pdf = pydyf.PDF((version or '1.7'), identifier)",
            "    states = pydyf.Dictionary()",
            "    x_objects = pydyf.Dictionary()",
            "    patterns = pydyf.Dictionary()",
            "    shadings = pydyf.Dictionary()",
            "    images = {}",
            "    resources = pydyf.Dictionary({",
            "        'ExtGState': states,",
            "        'XObject': x_objects,",
            "        'Pattern': patterns,",
            "        'Shading': shadings,",
            "    })",
            "    pdf.add_object(resources)",
            "    pdf_names = []",
            "",
            "    # Links and anchors",
            "    page_links_and_anchors = list(resolve_links(document.pages))",
            "",
            "    annot_files = {}",
            "    pdf_pages, page_streams = [], []",
            "    compress = not options['uncompressed_pdf']",
            "    for page_number, (page, links_and_anchors) in enumerate(",
            "            zip(document.pages, page_links_and_anchors)):",
            "        # Draw from the top-left corner",
            "        matrix = Matrix(scale, 0, 0, -scale, 0, page.height * scale)",
            "",
            "        page_width = scale * (",
            "            page.width + page.bleed['left'] + page.bleed['right'])",
            "        page_height = scale * (",
            "            page.height + page.bleed['top'] + page.bleed['bottom'])",
            "        left = -scale * page.bleed['left']",
            "        top = -scale * page.bleed['top']",
            "        right = left + page_width",
            "        bottom = top + page_height",
            "",
            "        page_rectangle = (",
            "            left / scale, top / scale,",
            "            (right - left) / scale, (bottom - top) / scale)",
            "        stream = Stream(",
            "            document.fonts, page_rectangle, states, x_objects, patterns,",
            "            shadings, images, mark, compress=compress)",
            "        stream.transform(d=-1, f=(page.height * scale))",
            "        pdf.add_object(stream)",
            "        page_streams.append(stream)",
            "",
            "        pdf_page = pydyf.Dictionary({",
            "            'Type': '/Page',",
            "            'Parent': pdf.pages.reference,",
            "            'MediaBox': pydyf.Array([left, top, right, bottom]),",
            "            'Contents': stream.reference,",
            "            'Resources': resources.reference,",
            "        })",
            "        if mark:",
            "            pdf_page['Tabs'] = '/S'",
            "            pdf_page['StructParents'] = page_number",
            "        pdf.add_page(pdf_page)",
            "        pdf_pages.append(pdf_page)",
            "",
            "        add_links(links_and_anchors, matrix, pdf, pdf_page, pdf_names, mark)",
            "        add_annotations(",
            "            links_and_anchors[0], matrix, document, pdf, pdf_page, annot_files,",
            "            compress)",
            "        add_inputs(",
            "            page.inputs, matrix, pdf, pdf_page, resources, stream,",
            "            document.font_config.font_map, compress)",
            "        page.paint(stream, scale)",
            "",
            "        # Bleed",
            "        bleed = {key: value * 0.75 for key, value in page.bleed.items()}",
            "",
            "        trim_left = left + bleed['left']",
            "        trim_top = top + bleed['top']",
            "        trim_right = right - bleed['right']",
            "        trim_bottom = bottom - bleed['bottom']",
            "",
            "        # Arbitrarly set PDF BleedBox between CSS bleed box (MediaBox) and",
            "        # CSS page box (TrimBox) at most 10 points from the TrimBox.",
            "        bleed_left = trim_left - min(10, bleed['left'])",
            "        bleed_top = trim_top - min(10, bleed['top'])",
            "        bleed_right = trim_right + min(10, bleed['right'])",
            "        bleed_bottom = trim_bottom + min(10, bleed['bottom'])",
            "",
            "        pdf_page['TrimBox'] = pydyf.Array([",
            "            trim_left, trim_top, trim_right, trim_bottom])",
            "        pdf_page['BleedBox'] = pydyf.Array([",
            "            bleed_left, bleed_top, bleed_right, bleed_bottom])",
            "",
            "    # Outlines",
            "    add_outlines(pdf, document.make_bookmark_tree(scale, transform_pages=True))",
            "",
            "    PROGRESS_LOGGER.info('Step 7 - Adding PDF metadata')",
            "",
            "    # PDF information",
            "    pdf.info['Producer'] = pydyf.String(f'WeasyPrint {VERSION}')",
            "    metadata = document.metadata",
            "    if metadata.title:",
            "        pdf.info['Title'] = pydyf.String(metadata.title)",
            "    if metadata.authors:",
            "        pdf.info['Author'] = pydyf.String(', '.join(metadata.authors))",
            "    if metadata.description:",
            "        pdf.info['Subject'] = pydyf.String(metadata.description)",
            "    if metadata.keywords:",
            "        pdf.info['Keywords'] = pydyf.String(', '.join(metadata.keywords))",
            "    if metadata.generator:",
            "        pdf.info['Creator'] = pydyf.String(metadata.generator)",
            "    if metadata.created:",
            "        pdf.info['CreationDate'] = pydyf.String(",
            "            _w3c_date_to_pdf(metadata.created, 'created'))",
            "    if metadata.modified:",
            "        pdf.info['ModDate'] = pydyf.String(",
            "            _w3c_date_to_pdf(metadata.modified, 'modified'))",
            "    if metadata.lang:",
            "        pdf.catalog['Lang'] = pydyf.String(metadata.lang)",
            "    if options['custom_metadata']:",
            "        for key, value in metadata.custom.items():",
            "            key = ''.join(char for char in key if char.isalnum())",
            "            key = key.encode('ascii', errors='ignore').decode()",
            "            if key:",
            "                pdf.info[key] = pydyf.String(value)",
            "",
            "    # Embedded files",
            "    attachments = metadata.attachments.copy()",
            "    if options['attachments']:",
            "        for attachment in options['attachments']:",
            "            if not isinstance(attachment, Attachment):",
            "                attachment = Attachment(",
            "                    attachment, url_fetcher=document.url_fetcher)",
            "            attachments.append(attachment)",
            "    pdf_attachments = []",
            "    for attachment in attachments:",
            "        pdf_attachment = write_pdf_attachment(pdf, attachment, compress)",
            "        if pdf_attachment is not None:",
            "            pdf_attachments.append(pdf_attachment)",
            "    if pdf_attachments:",
            "        content = pydyf.Dictionary({'Names': pydyf.Array()})",
            "        for i, pdf_attachment in enumerate(pdf_attachments):",
            "            content['Names'].append(pydyf.String(f'attachment{i}'))",
            "            content['Names'].append(pdf_attachment.reference)",
            "        pdf.add_object(content)",
            "        if 'Names' not in pdf.catalog:",
            "            pdf.catalog['Names'] = pydyf.Dictionary()",
            "        pdf.catalog['Names']['EmbeddedFiles'] = content.reference",
            "",
            "    # Embedded fonts",
            "    subset = not options['full_fonts']",
            "    hinting = options['hinting']",
            "    pdf_fonts = build_fonts_dictionary(",
            "        pdf, document.fonts, compress, subset, hinting)",
            "    pdf.add_object(pdf_fonts)",
            "    if 'AcroForm' in pdf.catalog:",
            "        # Include Dingbats for forms",
            "        dingbats = pydyf.Dictionary({",
            "            'Type': '/Font',",
            "            'Subtype': '/Type1',",
            "            'BaseFont': '/ZapfDingbats',",
            "        })",
            "        pdf.add_object(dingbats)",
            "        pdf_fonts['ZaDb'] = dingbats.reference",
            "    resources['Font'] = pdf_fonts.reference",
            "    _use_references(pdf, resources, images)",
            "",
            "    # Anchors",
            "    if pdf_names:",
            "        # Anchors are name trees that have to be sorted",
            "        name_array = pydyf.Array()",
            "        for anchor in sorted(pdf_names):",
            "            name_array.append(pydyf.String(anchor[0]))",
            "            name_array.append(anchor[1])",
            "        dests = pydyf.Dictionary({'Names': name_array})",
            "        if 'Names' not in pdf.catalog:",
            "            pdf.catalog['Names'] = pydyf.Dictionary()",
            "        pdf.catalog['Names']['Dests'] = dests",
            "",
            "    # Apply PDF variants functions",
            "    if variant:",
            "        variant_function(",
            "            pdf, metadata, document, page_streams, attachments, compress)",
            "",
            "    return pdf"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "252": [
                "generate_pdf"
            ]
        },
        "addLocation": []
    },
    "weasyprint/pdf/anchors.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "             # TODO: Use the title attribute as description. The comment"
            },
            "1": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             # above about multiple regions won't always be correct, because"
            },
            "2": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             # two links might have the same href, but different titles."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            attachment = Attachment("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                url=annot_target, url_fetcher=document.url_fetcher)"
            },
            "5": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             annot_files[annot_target] = write_pdf_attachment("
            },
            "6": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                pdf, Attachment(annot_target), compress)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+                pdf, attachment, compress)"
            },
            "8": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         annot_file = annot_files[annot_target]"
            },
            "9": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         if annot_file is None:"
            },
            "10": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             continue"
            }
        },
        "frontPatchFile": [
            "\"\"\"Insert anchors, links, bookmarks and inputs in PDFs.\"\"\"",
            "",
            "import hashlib",
            "import io",
            "import mimetypes",
            "from os.path import basename",
            "from urllib.parse import unquote, urlsplit",
            "",
            "import pydyf",
            "",
            "from .. import Attachment",
            "from ..logger import LOGGER",
            "from ..text.ffi import ffi, gobject, pango",
            "from ..text.fonts import get_font_description",
            "from ..urls import URLFetchingError",
            "",
            "",
            "def add_links(links_and_anchors, matrix, pdf, page, names, mark):",
            "    \"\"\"Include hyperlinks in given PDF page.\"\"\"",
            "    links, anchors = links_and_anchors",
            "",
            "    for link_type, link_target, rectangle, box in links:",
            "        x1, y1 = matrix.transform_point(*rectangle[:2])",
            "        x2, y2 = matrix.transform_point(*rectangle[2:])",
            "        if link_type in ('internal', 'external'):",
            "            box.link_annotation = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Link',",
            "                'Rect': pydyf.Array([x1, y1, x2, y2]),",
            "                'BS': pydyf.Dictionary({'W': 0}),",
            "            })",
            "            if mark:",
            "                box.link_annotation['Contents'] = pydyf.String(link_target)",
            "            if link_type == 'internal':",
            "                box.link_annotation['Dest'] = pydyf.String(link_target)",
            "            else:",
            "                box.link_annotation['A'] = pydyf.Dictionary({",
            "                    'Type': '/Action',",
            "                    'S': '/URI',",
            "                    'URI': pydyf.String(link_target),",
            "                })",
            "            pdf.add_object(box.link_annotation)",
            "            if 'Annots' not in page:",
            "                page['Annots'] = pydyf.Array()",
            "            page['Annots'].append(box.link_annotation.reference)",
            "",
            "    for anchor in anchors:",
            "        anchor_name, x, y = anchor",
            "        x, y = matrix.transform_point(x, y)",
            "        names.append([",
            "            anchor_name, pydyf.Array([page.reference, '/XYZ', x, y, 0])])",
            "",
            "",
            "def add_outlines(pdf, bookmarks, parent=None):",
            "    \"\"\"Include bookmark outlines in PDF.\"\"\"",
            "    count = len(bookmarks)",
            "    outlines = []",
            "    for title, (page, x, y), children, state in bookmarks:",
            "        destination = pydyf.Array((pdf.page_references[page], '/XYZ', x, y, 0))",
            "        outline = pydyf.Dictionary({",
            "            'Title': pydyf.String(title), 'Dest': destination})",
            "        pdf.add_object(outline)",
            "        children_outlines, children_count = add_outlines(",
            "            pdf, children, parent=outline)",
            "        outline['Count'] = children_count",
            "        if state == 'closed':",
            "            outline['Count'] *= -1",
            "        else:",
            "            count += children_count",
            "        if outlines:",
            "            outline['Prev'] = outlines[-1].reference",
            "            outlines[-1]['Next'] = outline.reference",
            "        if children_outlines:",
            "            outline['First'] = children_outlines[0].reference",
            "            outline['Last'] = children_outlines[-1].reference",
            "        if parent is not None:",
            "            outline['Parent'] = parent.reference",
            "        outlines.append(outline)",
            "",
            "    if parent is None and outlines:",
            "        outlines_dictionary = pydyf.Dictionary({",
            "            'Count': count,",
            "            'First': outlines[0].reference,",
            "            'Last': outlines[-1].reference,",
            "        })",
            "        pdf.add_object(outlines_dictionary)",
            "        for outline in outlines:",
            "            outline['Parent'] = outlines_dictionary.reference",
            "        pdf.catalog['Outlines'] = outlines_dictionary.reference",
            "",
            "    return outlines, count",
            "",
            "",
            "def add_inputs(inputs, matrix, pdf, page, resources, stream, font_map,",
            "               compress):",
            "    \"\"\"Include form inputs in PDF.\"\"\"",
            "    if not inputs:",
            "        return",
            "",
            "    if 'Annots' not in page:",
            "        page['Annots'] = pydyf.Array()",
            "    if 'AcroForm' not in pdf.catalog:",
            "        pdf.catalog['AcroForm'] = pydyf.Dictionary({",
            "            'Fields': pydyf.Array(),",
            "            'DR': resources.reference,",
            "            'NeedAppearances': 'true',",
            "        })",
            "    page_reference = page['Contents'].split()[0]",
            "    context = ffi.gc(",
            "        pango.pango_font_map_create_context(font_map),",
            "        gobject.g_object_unref)",
            "    for i, (element, style, rectangle) in enumerate(inputs):",
            "        rectangle = (",
            "            *matrix.transform_point(*rectangle[:2]),",
            "            *matrix.transform_point(*rectangle[2:]))",
            "",
            "        input_type = element.attrib.get('type')",
            "        default_name = f'unknown-{page_reference.decode()}-{i}'",
            "        input_name = pydyf.String(element.attrib.get('name', default_name))",
            "        # TODO: where does this 0.75 scale come from?",
            "        font_size = style['font_size'] * 0.75",
            "        field_stream = pydyf.Stream(compress=compress)",
            "        field_stream.set_color_rgb(*style['color'][:3])",
            "        if input_type == 'checkbox':",
            "            # Checkboxes",
            "            width = rectangle[2] - rectangle[0]",
            "            height = rectangle[1] - rectangle[3]",
            "            checked_stream = pydyf.Stream(extra={",
            "                'Resources': resources.reference,",
            "                'Type': '/XObject',",
            "                'Subtype': '/Form',",
            "                'BBox': pydyf.Array((0, 0, width, height)),",
            "            }, compress=compress)",
            "            checked_stream.push_state()",
            "            checked_stream.begin_text()",
            "            checked_stream.set_color_rgb(*style['color'][:3])",
            "            checked_stream.set_font_size('ZaDb', font_size)",
            "            # Center (let\u2019s assume that Dingbat\u2019s check has a 0.8em size)",
            "            x = (width - font_size * 0.8) / 2",
            "            y = (height - font_size * 0.8) / 2",
            "            checked_stream.move_text_to(x, y)",
            "            checked_stream.show_text_string('4')",
            "            checked_stream.end_text()",
            "            checked_stream.pop_state()",
            "            pdf.add_object(checked_stream)",
            "",
            "            checked = 'checked' in element.attrib",
            "            field_stream.set_font_size('ZaDb', font_size)",
            "            field = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Widget',",
            "                'Rect': pydyf.Array(rectangle),",
            "                'FT': '/Btn',",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'P': page.reference,",
            "                'T': pydyf.String(input_name),",
            "                'V': '/Yes' if checked else '/Off',",
            "                'AP': pydyf.Dictionary({'N': pydyf.Dictionary({",
            "                    'Yes': checked_stream.reference,",
            "                })}),",
            "                'AS': '/Yes' if checked else '/Off',",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "            })",
            "        elif element.tag == 'select':",
            "            # Select fields",
            "            font_description = get_font_description(style)",
            "            font = pango.pango_font_map_load_font(",
            "                font_map, context, font_description)",
            "            font = stream.add_font(font)",
            "            font.used_in_forms = True",
            "",
            "            field_stream.set_font_size(font.hash, font_size)",
            "            options = []",
            "            selected_values = []",
            "            for option in element:",
            "                value = pydyf.String(option.attrib.get('value', ''))",
            "                text = pydyf.String(option.text)",
            "                options.append(pydyf.Array([value, text]))",
            "                if 'selected' in option.attrib:",
            "                    selected_values.append(value)",
            "",
            "            field = pydyf.Dictionary({",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'FT': '/Ch',",
            "                'Opt': pydyf.Array(options),",
            "                'P': page.reference,",
            "                'Rect': pydyf.Array(rectangle),",
            "                'Subtype': '/Widget',",
            "                'T': pydyf.String(input_name),",
            "                'Type': '/Annot',",
            "            })",
            "            if 'multiple' in element.attrib:",
            "                field['Ff'] = 1 << (22 - 1)",
            "                field['V'] = pydyf.Array(selected_values)",
            "            else:",
            "                field['Ff'] = 1 << (18 - 1)",
            "                field['V'] = (",
            "                    selected_values[-1] if selected_values",
            "                    else pydyf.String(''))",
            "        else:",
            "            # Text, password, textarea, files, and unknown",
            "            font_description = get_font_description(style)",
            "            font = pango.pango_font_map_load_font(",
            "                font_map, context, font_description)",
            "            font = stream.add_font(font)",
            "            font.used_in_forms = True",
            "",
            "            field_stream.set_font_size(font.hash, font_size)",
            "            value = (",
            "                element.text if element.tag == 'textarea'",
            "                else element.attrib.get('value', ''))",
            "            field = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Widget',",
            "                'Rect': pydyf.Array(rectangle),",
            "                'FT': '/Tx',",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'P': page.reference,",
            "                'T': pydyf.String(input_name),",
            "                'V': pydyf.String(value or ''),",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "            })",
            "            if element.tag == 'textarea':",
            "                field['Ff'] = 1 << (13 - 1)",
            "            elif input_type == 'password':",
            "                field['Ff'] = 1 << (14 - 1)",
            "            elif input_type == 'file':",
            "                field['Ff'] = 1 << (21 - 1)",
            "",
            "        pdf.add_object(field)",
            "        page['Annots'].append(field.reference)",
            "        pdf.catalog['AcroForm']['Fields'].append(field.reference)",
            "",
            "",
            "def add_annotations(links, matrix, document, pdf, page, annot_files, compress):",
            "    \"\"\"Include annotations in PDF.\"\"\"",
            "    # TODO: splitting a link into multiple independent rectangular",
            "    # annotations works well for pure links, but rather mediocre for",
            "    # other annotations and fails completely for transformed (CSS) or",
            "    # complex link shapes (area). It would be better to use /AP for all",
            "    # links and coalesce link shapes that originate from the same HTML",
            "    # link. This would give a feeling similiar to what browsers do with",
            "    # links that span multiple lines.",
            "    for link_type, annot_target, rectangle, _ in links:",
            "        if link_type != 'attachment':",
            "            continue",
            "        if annot_target not in annot_files:",
            "            # A single link can be split in multiple regions. We don't want",
            "            # to embed a file multiple times of course, so keep a reference",
            "            # to every embedded URL and reuse the object number.",
            "            # TODO: Use the title attribute as description. The comment",
            "            # above about multiple regions won't always be correct, because",
            "            # two links might have the same href, but different titles.",
            "            annot_files[annot_target] = write_pdf_attachment(",
            "                pdf, Attachment(annot_target), compress)",
            "        annot_file = annot_files[annot_target]",
            "        if annot_file is None:",
            "            continue",
            "        rectangle = (",
            "            *matrix.transform_point(*rectangle[:2]),",
            "            *matrix.transform_point(*rectangle[2:]))",
            "        stream = pydyf.Stream([], {",
            "            'Type': '/XObject',",
            "            'Subtype': '/Form',",
            "            'BBox': pydyf.Array(rectangle),",
            "        }, compress)",
            "        pdf.add_object(stream)",
            "        annot = pydyf.Dictionary({",
            "            'Type': '/Annot',",
            "            'Rect': pydyf.Array(rectangle),",
            "            'Subtype': '/FileAttachment',",
            "            'T': pydyf.String(),",
            "            'FS': annot_file.reference,",
            "            'AP': pydyf.Dictionary({'N': stream.reference}),",
            "            'AS': '/N',",
            "        })",
            "        pdf.add_object(annot)",
            "        if 'Annots' not in page:",
            "            page['Annots'] = pydyf.Array()",
            "        page['Annots'].append(annot.reference)",
            "",
            "",
            "def write_pdf_attachment(pdf, attachment, compress):",
            "    \"\"\"Write an attachment to the PDF stream.\"\"\"",
            "    # Attachments from document links like <link> or <a> can only be URLs.",
            "    # They're passed in as tuples",
            "    url = None",
            "    uncompressed_length = 0",
            "    stream = b''",
            "    try:",
            "        with attachment.source as (_, source, url, _):",
            "            if isinstance(source, str):",
            "                source = source.encode()",
            "            if isinstance(source, bytes):",
            "                source = io.BytesIO(source)",
            "            for data in iter(lambda: source.read(4096), b''):",
            "                uncompressed_length += len(data)",
            "                stream += data",
            "    except URLFetchingError as exception:",
            "        LOGGER.error('Failed to load attachment: %s', exception)",
            "        return",
            "    attachment.md5 = hashlib.md5(stream).hexdigest()",
            "",
            "    # TODO: Use the result object from a URL fetch operation to provide more",
            "    # details on the possible filename and MIME type.",
            "    if url and urlsplit(url).path:",
            "        filename = basename(unquote(urlsplit(url).path))",
            "    else:",
            "        filename = 'attachment.bin'",
            "    mime_type = mimetypes.guess_type(filename, strict=False)[0]",
            "    if not mime_type:",
            "        mime_type = 'application/octet-stream'",
            "",
            "    creation = pydyf.String(attachment.created.strftime('D:%Y%m%d%H%M%SZ'))",
            "    mod = pydyf.String(attachment.modified.strftime('D:%Y%m%d%H%M%SZ'))",
            "    file_extra = pydyf.Dictionary({",
            "        'Type': '/EmbeddedFile',",
            "        'Subtype': f'/{mime_type.replace(\"/\", \"#2f\")}',",
            "        'Params': pydyf.Dictionary({",
            "            'CheckSum': f'<{attachment.md5}>',",
            "            'Size': uncompressed_length,",
            "            'CreationDate': creation,",
            "            'ModDate': mod,",
            "        })",
            "    })",
            "    file_stream = pydyf.Stream([stream], file_extra, compress=compress)",
            "    pdf.add_object(file_stream)",
            "",
            "    pdf_attachment = pydyf.Dictionary({",
            "        'Type': '/Filespec',",
            "        'F': pydyf.String(),",
            "        'UF': pydyf.String(filename),",
            "        'EF': pydyf.Dictionary({'F': file_stream.reference}),",
            "        'Desc': pydyf.String(attachment.description or ''),",
            "    })",
            "    pdf.add_object(pdf_attachment)",
            "    return pdf_attachment",
            "",
            "",
            "def resolve_links(pages):",
            "    \"\"\"Resolve internal hyperlinks.",
            "",
            "    Links to a missing anchor are removed with a warning.",
            "",
            "    If multiple anchors have the same name, the first one is used.",
            "",
            "    :returns:",
            "        A generator yielding lists (one per page) like :attr:`Page.links`,",
            "        except that ``target`` for internal hyperlinks is",
            "        ``(page_number, x, y)`` instead of an anchor name.",
            "        The page number is a 0-based index into the :attr:`pages` list,",
            "        and ``x, y`` are in CSS pixels from the top-left of the page.",
            "",
            "    \"\"\"",
            "    anchors = set()",
            "    paged_anchors = []",
            "    for i, page in enumerate(pages):",
            "        paged_anchors.append([])",
            "        for anchor_name, (point_x, point_y) in page.anchors.items():",
            "            if anchor_name not in anchors:",
            "                paged_anchors[-1].append((anchor_name, point_x, point_y))",
            "                anchors.add(anchor_name)",
            "    for page in pages:",
            "        page_links = []",
            "        for link in page.links:",
            "            link_type, anchor_name, _, _ = link",
            "            if link_type == 'internal':",
            "                if anchor_name not in anchors:",
            "                    LOGGER.error(",
            "                        'No anchor #%s for internal URI reference',",
            "                        anchor_name)",
            "                else:",
            "                    page_links.append(link)",
            "            else:",
            "                # External link",
            "                page_links.append(link)",
            "        yield page_links, paged_anchors.pop(0)"
        ],
        "afterPatchFile": [
            "\"\"\"Insert anchors, links, bookmarks and inputs in PDFs.\"\"\"",
            "",
            "import hashlib",
            "import io",
            "import mimetypes",
            "from os.path import basename",
            "from urllib.parse import unquote, urlsplit",
            "",
            "import pydyf",
            "",
            "from .. import Attachment",
            "from ..logger import LOGGER",
            "from ..text.ffi import ffi, gobject, pango",
            "from ..text.fonts import get_font_description",
            "from ..urls import URLFetchingError",
            "",
            "",
            "def add_links(links_and_anchors, matrix, pdf, page, names, mark):",
            "    \"\"\"Include hyperlinks in given PDF page.\"\"\"",
            "    links, anchors = links_and_anchors",
            "",
            "    for link_type, link_target, rectangle, box in links:",
            "        x1, y1 = matrix.transform_point(*rectangle[:2])",
            "        x2, y2 = matrix.transform_point(*rectangle[2:])",
            "        if link_type in ('internal', 'external'):",
            "            box.link_annotation = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Link',",
            "                'Rect': pydyf.Array([x1, y1, x2, y2]),",
            "                'BS': pydyf.Dictionary({'W': 0}),",
            "            })",
            "            if mark:",
            "                box.link_annotation['Contents'] = pydyf.String(link_target)",
            "            if link_type == 'internal':",
            "                box.link_annotation['Dest'] = pydyf.String(link_target)",
            "            else:",
            "                box.link_annotation['A'] = pydyf.Dictionary({",
            "                    'Type': '/Action',",
            "                    'S': '/URI',",
            "                    'URI': pydyf.String(link_target),",
            "                })",
            "            pdf.add_object(box.link_annotation)",
            "            if 'Annots' not in page:",
            "                page['Annots'] = pydyf.Array()",
            "            page['Annots'].append(box.link_annotation.reference)",
            "",
            "    for anchor in anchors:",
            "        anchor_name, x, y = anchor",
            "        x, y = matrix.transform_point(x, y)",
            "        names.append([",
            "            anchor_name, pydyf.Array([page.reference, '/XYZ', x, y, 0])])",
            "",
            "",
            "def add_outlines(pdf, bookmarks, parent=None):",
            "    \"\"\"Include bookmark outlines in PDF.\"\"\"",
            "    count = len(bookmarks)",
            "    outlines = []",
            "    for title, (page, x, y), children, state in bookmarks:",
            "        destination = pydyf.Array((pdf.page_references[page], '/XYZ', x, y, 0))",
            "        outline = pydyf.Dictionary({",
            "            'Title': pydyf.String(title), 'Dest': destination})",
            "        pdf.add_object(outline)",
            "        children_outlines, children_count = add_outlines(",
            "            pdf, children, parent=outline)",
            "        outline['Count'] = children_count",
            "        if state == 'closed':",
            "            outline['Count'] *= -1",
            "        else:",
            "            count += children_count",
            "        if outlines:",
            "            outline['Prev'] = outlines[-1].reference",
            "            outlines[-1]['Next'] = outline.reference",
            "        if children_outlines:",
            "            outline['First'] = children_outlines[0].reference",
            "            outline['Last'] = children_outlines[-1].reference",
            "        if parent is not None:",
            "            outline['Parent'] = parent.reference",
            "        outlines.append(outline)",
            "",
            "    if parent is None and outlines:",
            "        outlines_dictionary = pydyf.Dictionary({",
            "            'Count': count,",
            "            'First': outlines[0].reference,",
            "            'Last': outlines[-1].reference,",
            "        })",
            "        pdf.add_object(outlines_dictionary)",
            "        for outline in outlines:",
            "            outline['Parent'] = outlines_dictionary.reference",
            "        pdf.catalog['Outlines'] = outlines_dictionary.reference",
            "",
            "    return outlines, count",
            "",
            "",
            "def add_inputs(inputs, matrix, pdf, page, resources, stream, font_map,",
            "               compress):",
            "    \"\"\"Include form inputs in PDF.\"\"\"",
            "    if not inputs:",
            "        return",
            "",
            "    if 'Annots' not in page:",
            "        page['Annots'] = pydyf.Array()",
            "    if 'AcroForm' not in pdf.catalog:",
            "        pdf.catalog['AcroForm'] = pydyf.Dictionary({",
            "            'Fields': pydyf.Array(),",
            "            'DR': resources.reference,",
            "            'NeedAppearances': 'true',",
            "        })",
            "    page_reference = page['Contents'].split()[0]",
            "    context = ffi.gc(",
            "        pango.pango_font_map_create_context(font_map),",
            "        gobject.g_object_unref)",
            "    for i, (element, style, rectangle) in enumerate(inputs):",
            "        rectangle = (",
            "            *matrix.transform_point(*rectangle[:2]),",
            "            *matrix.transform_point(*rectangle[2:]))",
            "",
            "        input_type = element.attrib.get('type')",
            "        default_name = f'unknown-{page_reference.decode()}-{i}'",
            "        input_name = pydyf.String(element.attrib.get('name', default_name))",
            "        # TODO: where does this 0.75 scale come from?",
            "        font_size = style['font_size'] * 0.75",
            "        field_stream = pydyf.Stream(compress=compress)",
            "        field_stream.set_color_rgb(*style['color'][:3])",
            "        if input_type == 'checkbox':",
            "            # Checkboxes",
            "            width = rectangle[2] - rectangle[0]",
            "            height = rectangle[1] - rectangle[3]",
            "            checked_stream = pydyf.Stream(extra={",
            "                'Resources': resources.reference,",
            "                'Type': '/XObject',",
            "                'Subtype': '/Form',",
            "                'BBox': pydyf.Array((0, 0, width, height)),",
            "            }, compress=compress)",
            "            checked_stream.push_state()",
            "            checked_stream.begin_text()",
            "            checked_stream.set_color_rgb(*style['color'][:3])",
            "            checked_stream.set_font_size('ZaDb', font_size)",
            "            # Center (let\u2019s assume that Dingbat\u2019s check has a 0.8em size)",
            "            x = (width - font_size * 0.8) / 2",
            "            y = (height - font_size * 0.8) / 2",
            "            checked_stream.move_text_to(x, y)",
            "            checked_stream.show_text_string('4')",
            "            checked_stream.end_text()",
            "            checked_stream.pop_state()",
            "            pdf.add_object(checked_stream)",
            "",
            "            checked = 'checked' in element.attrib",
            "            field_stream.set_font_size('ZaDb', font_size)",
            "            field = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Widget',",
            "                'Rect': pydyf.Array(rectangle),",
            "                'FT': '/Btn',",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'P': page.reference,",
            "                'T': pydyf.String(input_name),",
            "                'V': '/Yes' if checked else '/Off',",
            "                'AP': pydyf.Dictionary({'N': pydyf.Dictionary({",
            "                    'Yes': checked_stream.reference,",
            "                })}),",
            "                'AS': '/Yes' if checked else '/Off',",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "            })",
            "        elif element.tag == 'select':",
            "            # Select fields",
            "            font_description = get_font_description(style)",
            "            font = pango.pango_font_map_load_font(",
            "                font_map, context, font_description)",
            "            font = stream.add_font(font)",
            "            font.used_in_forms = True",
            "",
            "            field_stream.set_font_size(font.hash, font_size)",
            "            options = []",
            "            selected_values = []",
            "            for option in element:",
            "                value = pydyf.String(option.attrib.get('value', ''))",
            "                text = pydyf.String(option.text)",
            "                options.append(pydyf.Array([value, text]))",
            "                if 'selected' in option.attrib:",
            "                    selected_values.append(value)",
            "",
            "            field = pydyf.Dictionary({",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'FT': '/Ch',",
            "                'Opt': pydyf.Array(options),",
            "                'P': page.reference,",
            "                'Rect': pydyf.Array(rectangle),",
            "                'Subtype': '/Widget',",
            "                'T': pydyf.String(input_name),",
            "                'Type': '/Annot',",
            "            })",
            "            if 'multiple' in element.attrib:",
            "                field['Ff'] = 1 << (22 - 1)",
            "                field['V'] = pydyf.Array(selected_values)",
            "            else:",
            "                field['Ff'] = 1 << (18 - 1)",
            "                field['V'] = (",
            "                    selected_values[-1] if selected_values",
            "                    else pydyf.String(''))",
            "        else:",
            "            # Text, password, textarea, files, and unknown",
            "            font_description = get_font_description(style)",
            "            font = pango.pango_font_map_load_font(",
            "                font_map, context, font_description)",
            "            font = stream.add_font(font)",
            "            font.used_in_forms = True",
            "",
            "            field_stream.set_font_size(font.hash, font_size)",
            "            value = (",
            "                element.text if element.tag == 'textarea'",
            "                else element.attrib.get('value', ''))",
            "            field = pydyf.Dictionary({",
            "                'Type': '/Annot',",
            "                'Subtype': '/Widget',",
            "                'Rect': pydyf.Array(rectangle),",
            "                'FT': '/Tx',",
            "                'F': 1 << (3 - 1),  # Print flag",
            "                'P': page.reference,",
            "                'T': pydyf.String(input_name),",
            "                'V': pydyf.String(value or ''),",
            "                'DA': pydyf.String(b' '.join(field_stream.stream)),",
            "            })",
            "            if element.tag == 'textarea':",
            "                field['Ff'] = 1 << (13 - 1)",
            "            elif input_type == 'password':",
            "                field['Ff'] = 1 << (14 - 1)",
            "            elif input_type == 'file':",
            "                field['Ff'] = 1 << (21 - 1)",
            "",
            "        pdf.add_object(field)",
            "        page['Annots'].append(field.reference)",
            "        pdf.catalog['AcroForm']['Fields'].append(field.reference)",
            "",
            "",
            "def add_annotations(links, matrix, document, pdf, page, annot_files, compress):",
            "    \"\"\"Include annotations in PDF.\"\"\"",
            "    # TODO: splitting a link into multiple independent rectangular",
            "    # annotations works well for pure links, but rather mediocre for",
            "    # other annotations and fails completely for transformed (CSS) or",
            "    # complex link shapes (area). It would be better to use /AP for all",
            "    # links and coalesce link shapes that originate from the same HTML",
            "    # link. This would give a feeling similiar to what browsers do with",
            "    # links that span multiple lines.",
            "    for link_type, annot_target, rectangle, _ in links:",
            "        if link_type != 'attachment':",
            "            continue",
            "        if annot_target not in annot_files:",
            "            # A single link can be split in multiple regions. We don't want",
            "            # to embed a file multiple times of course, so keep a reference",
            "            # to every embedded URL and reuse the object number.",
            "            # TODO: Use the title attribute as description. The comment",
            "            # above about multiple regions won't always be correct, because",
            "            # two links might have the same href, but different titles.",
            "            attachment = Attachment(",
            "                url=annot_target, url_fetcher=document.url_fetcher)",
            "            annot_files[annot_target] = write_pdf_attachment(",
            "                pdf, attachment, compress)",
            "        annot_file = annot_files[annot_target]",
            "        if annot_file is None:",
            "            continue",
            "        rectangle = (",
            "            *matrix.transform_point(*rectangle[:2]),",
            "            *matrix.transform_point(*rectangle[2:]))",
            "        stream = pydyf.Stream([], {",
            "            'Type': '/XObject',",
            "            'Subtype': '/Form',",
            "            'BBox': pydyf.Array(rectangle),",
            "        }, compress)",
            "        pdf.add_object(stream)",
            "        annot = pydyf.Dictionary({",
            "            'Type': '/Annot',",
            "            'Rect': pydyf.Array(rectangle),",
            "            'Subtype': '/FileAttachment',",
            "            'T': pydyf.String(),",
            "            'FS': annot_file.reference,",
            "            'AP': pydyf.Dictionary({'N': stream.reference}),",
            "            'AS': '/N',",
            "        })",
            "        pdf.add_object(annot)",
            "        if 'Annots' not in page:",
            "            page['Annots'] = pydyf.Array()",
            "        page['Annots'].append(annot.reference)",
            "",
            "",
            "def write_pdf_attachment(pdf, attachment, compress):",
            "    \"\"\"Write an attachment to the PDF stream.\"\"\"",
            "    # Attachments from document links like <link> or <a> can only be URLs.",
            "    # They're passed in as tuples",
            "    url = None",
            "    uncompressed_length = 0",
            "    stream = b''",
            "    try:",
            "        with attachment.source as (_, source, url, _):",
            "            if isinstance(source, str):",
            "                source = source.encode()",
            "            if isinstance(source, bytes):",
            "                source = io.BytesIO(source)",
            "            for data in iter(lambda: source.read(4096), b''):",
            "                uncompressed_length += len(data)",
            "                stream += data",
            "    except URLFetchingError as exception:",
            "        LOGGER.error('Failed to load attachment: %s', exception)",
            "        return",
            "    attachment.md5 = hashlib.md5(stream).hexdigest()",
            "",
            "    # TODO: Use the result object from a URL fetch operation to provide more",
            "    # details on the possible filename and MIME type.",
            "    if url and urlsplit(url).path:",
            "        filename = basename(unquote(urlsplit(url).path))",
            "    else:",
            "        filename = 'attachment.bin'",
            "    mime_type = mimetypes.guess_type(filename, strict=False)[0]",
            "    if not mime_type:",
            "        mime_type = 'application/octet-stream'",
            "",
            "    creation = pydyf.String(attachment.created.strftime('D:%Y%m%d%H%M%SZ'))",
            "    mod = pydyf.String(attachment.modified.strftime('D:%Y%m%d%H%M%SZ'))",
            "    file_extra = pydyf.Dictionary({",
            "        'Type': '/EmbeddedFile',",
            "        'Subtype': f'/{mime_type.replace(\"/\", \"#2f\")}',",
            "        'Params': pydyf.Dictionary({",
            "            'CheckSum': f'<{attachment.md5}>',",
            "            'Size': uncompressed_length,",
            "            'CreationDate': creation,",
            "            'ModDate': mod,",
            "        })",
            "    })",
            "    file_stream = pydyf.Stream([stream], file_extra, compress=compress)",
            "    pdf.add_object(file_stream)",
            "",
            "    pdf_attachment = pydyf.Dictionary({",
            "        'Type': '/Filespec',",
            "        'F': pydyf.String(),",
            "        'UF': pydyf.String(filename),",
            "        'EF': pydyf.Dictionary({'F': file_stream.reference}),",
            "        'Desc': pydyf.String(attachment.description or ''),",
            "    })",
            "    pdf.add_object(pdf_attachment)",
            "    return pdf_attachment",
            "",
            "",
            "def resolve_links(pages):",
            "    \"\"\"Resolve internal hyperlinks.",
            "",
            "    Links to a missing anchor are removed with a warning.",
            "",
            "    If multiple anchors have the same name, the first one is used.",
            "",
            "    :returns:",
            "        A generator yielding lists (one per page) like :attr:`Page.links`,",
            "        except that ``target`` for internal hyperlinks is",
            "        ``(page_number, x, y)`` instead of an anchor name.",
            "        The page number is a 0-based index into the :attr:`pages` list,",
            "        and ``x, y`` are in CSS pixels from the top-left of the page.",
            "",
            "    \"\"\"",
            "    anchors = set()",
            "    paged_anchors = []",
            "    for i, page in enumerate(pages):",
            "        paged_anchors.append([])",
            "        for anchor_name, (point_x, point_y) in page.anchors.items():",
            "            if anchor_name not in anchors:",
            "                paged_anchors[-1].append((anchor_name, point_x, point_y))",
            "                anchors.add(anchor_name)",
            "    for page in pages:",
            "        page_links = []",
            "        for link in page.links:",
            "            link_type, anchor_name, _, _ = link",
            "            if link_type == 'internal':",
            "                if anchor_name not in anchors:",
            "                    LOGGER.error(",
            "                        'No anchor #%s for internal URI reference',",
            "                        anchor_name)",
            "                else:",
            "                    page_links.append(link)",
            "            else:",
            "                # External link",
            "                page_links.append(link)",
            "        yield page_links, paged_anchors.pop(0)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "256": [
                "add_annotations"
            ]
        },
        "addLocation": [
            "wagtail.images.tests.test_admin_views"
        ]
    }
}