{
    "mindsdb/api/http/namespaces/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import requests"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from mindsdb.utilities import log"
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from mindsdb.api.http.utils import http_error"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from mindsdb.api.http.utils import http_error, safe_extract"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from mindsdb.api.http.namespaces.configs.files import ns_conf"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from mindsdb.utilities.config import Config"
            },
            "7": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from mindsdb.utilities.context import context as ctx"
            },
            "8": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                     f.extractall(temp_dir_path)"
            },
            "9": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             elif lp.endswith('.tar.gz'):"
            },
            "10": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                 with tarfile.open(file_path) as f:"
            },
            "11": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f.extractall(temp_dir_path)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+                    safe_extract(f, temp_dir_path)"
            },
            "13": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             os.remove(file_path)"
            },
            "14": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "             files = os.listdir(temp_dir_path)"
            },
            "15": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "             if len(files) != 1:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import zipfile",
            "import tarfile",
            "",
            "from flask import request, current_app as ca",
            "from flask_restx import Resource",
            "import tempfile",
            "import multipart",
            "import requests",
            "",
            "from mindsdb.utilities import log",
            "from mindsdb.api.http.utils import http_error",
            "from mindsdb.api.http.namespaces.configs.files import ns_conf",
            "from mindsdb.utilities.config import Config",
            "from mindsdb.utilities.context import context as ctx",
            "",
            "",
            "@ns_conf.route('/')",
            "class FilesList(Resource):",
            "    @ns_conf.doc('get_files_list')",
            "    def get(self):",
            "        '''List all files'''",
            "        return ca.file_controller.get_files()",
            "",
            "",
            "@ns_conf.route('/<name>')",
            "@ns_conf.param('name', \"MindsDB's name for file\")",
            "class File(Resource):",
            "    @ns_conf.doc('put_file')",
            "    def put(self, name: str):",
            "        ''' add new file",
            "            params in FormData:",
            "                - file",
            "                - original_file_name [optional]",
            "        '''",
            "",
            "        data = {}",
            "        mindsdb_file_name = name",
            "",
            "        existing_file_names = ca.file_controller.get_files_names()",
            "",
            "        def on_field(field):",
            "            name = field.field_name.decode()",
            "            value = field.value.decode()",
            "            data[name] = value",
            "",
            "        file_object = None",
            "",
            "        def on_file(file):",
            "            nonlocal file_object",
            "            data['file'] = file.file_name.decode()",
            "            file_object = file.file_object",
            "",
            "        temp_dir_path = tempfile.mkdtemp(prefix='mindsdb_file_')",
            "",
            "        if request.headers['Content-Type'].startswith('multipart/form-data'):",
            "            parser = multipart.create_form_parser(",
            "                headers=request.headers,",
            "                on_field=on_field,",
            "                on_file=on_file,",
            "                config={",
            "                    'UPLOAD_DIR': temp_dir_path.encode(),    # bytes required",
            "                    'UPLOAD_KEEP_FILENAME': True,",
            "                    'UPLOAD_KEEP_EXTENSIONS': True,",
            "                    'MAX_MEMORY_FILE_SIZE': 0",
            "                }",
            "            )",
            "",
            "            while True:",
            "                chunk = request.stream.read(8192)",
            "                if not chunk:",
            "                    break",
            "                parser.write(chunk)",
            "            parser.finalize()",
            "            parser.close()",
            "",
            "            if file_object is not None and not file_object.closed:",
            "                file_object.close()",
            "        else:",
            "            data = request.json",
            "",
            "        if mindsdb_file_name in existing_file_names:",
            "            return http_error(",
            "                400,",
            "                \"File already exists\",",
            "                f\"File with name '{data['file']}' already exists\"",
            "            )",
            "",
            "        if data.get('source_type') == 'url':",
            "            url = data['source']",
            "            data['file'] = data['name']",
            "",
            "            config = Config()",
            "            is_cloud = config.get('cloud', False)",
            "            if is_cloud is True and ctx.user_class != 1:",
            "                info = requests.head(url)",
            "                file_size = info.headers.get('Content-Length')",
            "                try:",
            "                    file_size = int(file_size)",
            "                except Exception:",
            "                    pass",
            "",
            "                if file_size is None:",
            "                    return http_error(",
            "                        400,",
            "                        \"Error getting file info\",",
            "                        \"\u0421an't determine remote file size\"",
            "                    )",
            "                if file_size > 1024 * 1024 * 100:",
            "                    return http_error(",
            "                        400,",
            "                        \"File is too big\",",
            "                        \"Upload limit for file is 100Mb\"",
            "                    )",
            "            with requests.get(url, stream=True) as r:",
            "                if r.status_code != 200:",
            "                    return http_error(",
            "                        400,",
            "                        \"Error getting file\",",
            "                        f\"Got status code: {r.status_code}\"",
            "                    )",
            "                file_path = os.path.join(temp_dir_path, data['file'])",
            "                with open(file_path, 'wb') as f:",
            "                    for chunk in r.iter_content(chunk_size=8192):",
            "                        f.write(chunk)",
            "",
            "        original_file_name = data.get('original_file_name')",
            "",
            "        file_path = os.path.join(temp_dir_path, data['file'])",
            "        lp = file_path.lower()",
            "        if lp.endswith(('.zip', '.tar.gz')):",
            "            if lp.endswith('.zip'):",
            "                with zipfile.ZipFile(file_path) as f:",
            "                    f.extractall(temp_dir_path)",
            "            elif lp.endswith('.tar.gz'):",
            "                with tarfile.open(file_path) as f:",
            "                    f.extractall(temp_dir_path)",
            "            os.remove(file_path)",
            "            files = os.listdir(temp_dir_path)",
            "            if len(files) != 1:",
            "                os.rmdir(temp_dir_path)",
            "                return http_error(400, 'Wrong content.', 'Archive must contain only one data file.')",
            "            file_path = os.path.join(temp_dir_path, files[0])",
            "            mindsdb_file_name = files[0]",
            "            if not os.path.isfile(file_path):",
            "                os.rmdir(temp_dir_path)",
            "                return http_error(400, 'Wrong content.', 'Archive must contain data file in root.')",
            "",
            "        ca.file_controller.save_file(mindsdb_file_name, file_path, file_name=original_file_name)",
            "",
            "        os.rmdir(temp_dir_path)",
            "",
            "        return '', 200",
            "",
            "    @ns_conf.doc('delete_file')",
            "    def delete(self, name: str):",
            "        '''delete file'''",
            "",
            "        try:",
            "            ca.file_controller.delete_file(name)",
            "        except Exception as e:",
            "            log.logger.error(e)",
            "            return http_error(",
            "                400,",
            "                \"Error deleting file\",",
            "                f\"There was an error while tring to delete file with name '{name}'\"",
            "            )",
            "        return '', 200"
        ],
        "afterPatchFile": [
            "import os",
            "import zipfile",
            "import tarfile",
            "",
            "from flask import request, current_app as ca",
            "from flask_restx import Resource",
            "import tempfile",
            "import multipart",
            "import requests",
            "",
            "from mindsdb.utilities import log",
            "from mindsdb.api.http.utils import http_error, safe_extract",
            "from mindsdb.api.http.namespaces.configs.files import ns_conf",
            "from mindsdb.utilities.config import Config",
            "from mindsdb.utilities.context import context as ctx",
            "",
            "",
            "@ns_conf.route('/')",
            "class FilesList(Resource):",
            "    @ns_conf.doc('get_files_list')",
            "    def get(self):",
            "        '''List all files'''",
            "        return ca.file_controller.get_files()",
            "",
            "",
            "@ns_conf.route('/<name>')",
            "@ns_conf.param('name', \"MindsDB's name for file\")",
            "class File(Resource):",
            "    @ns_conf.doc('put_file')",
            "    def put(self, name: str):",
            "        ''' add new file",
            "            params in FormData:",
            "                - file",
            "                - original_file_name [optional]",
            "        '''",
            "",
            "        data = {}",
            "        mindsdb_file_name = name",
            "",
            "        existing_file_names = ca.file_controller.get_files_names()",
            "",
            "        def on_field(field):",
            "            name = field.field_name.decode()",
            "            value = field.value.decode()",
            "            data[name] = value",
            "",
            "        file_object = None",
            "",
            "        def on_file(file):",
            "            nonlocal file_object",
            "            data['file'] = file.file_name.decode()",
            "            file_object = file.file_object",
            "",
            "        temp_dir_path = tempfile.mkdtemp(prefix='mindsdb_file_')",
            "",
            "        if request.headers['Content-Type'].startswith('multipart/form-data'):",
            "            parser = multipart.create_form_parser(",
            "                headers=request.headers,",
            "                on_field=on_field,",
            "                on_file=on_file,",
            "                config={",
            "                    'UPLOAD_DIR': temp_dir_path.encode(),    # bytes required",
            "                    'UPLOAD_KEEP_FILENAME': True,",
            "                    'UPLOAD_KEEP_EXTENSIONS': True,",
            "                    'MAX_MEMORY_FILE_SIZE': 0",
            "                }",
            "            )",
            "",
            "            while True:",
            "                chunk = request.stream.read(8192)",
            "                if not chunk:",
            "                    break",
            "                parser.write(chunk)",
            "            parser.finalize()",
            "            parser.close()",
            "",
            "            if file_object is not None and not file_object.closed:",
            "                file_object.close()",
            "        else:",
            "            data = request.json",
            "",
            "        if mindsdb_file_name in existing_file_names:",
            "            return http_error(",
            "                400,",
            "                \"File already exists\",",
            "                f\"File with name '{data['file']}' already exists\"",
            "            )",
            "",
            "        if data.get('source_type') == 'url':",
            "            url = data['source']",
            "            data['file'] = data['name']",
            "",
            "            config = Config()",
            "            is_cloud = config.get('cloud', False)",
            "            if is_cloud is True and ctx.user_class != 1:",
            "                info = requests.head(url)",
            "                file_size = info.headers.get('Content-Length')",
            "                try:",
            "                    file_size = int(file_size)",
            "                except Exception:",
            "                    pass",
            "",
            "                if file_size is None:",
            "                    return http_error(",
            "                        400,",
            "                        \"Error getting file info\",",
            "                        \"\u0421an't determine remote file size\"",
            "                    )",
            "                if file_size > 1024 * 1024 * 100:",
            "                    return http_error(",
            "                        400,",
            "                        \"File is too big\",",
            "                        \"Upload limit for file is 100Mb\"",
            "                    )",
            "            with requests.get(url, stream=True) as r:",
            "                if r.status_code != 200:",
            "                    return http_error(",
            "                        400,",
            "                        \"Error getting file\",",
            "                        f\"Got status code: {r.status_code}\"",
            "                    )",
            "                file_path = os.path.join(temp_dir_path, data['file'])",
            "                with open(file_path, 'wb') as f:",
            "                    for chunk in r.iter_content(chunk_size=8192):",
            "                        f.write(chunk)",
            "",
            "        original_file_name = data.get('original_file_name')",
            "",
            "        file_path = os.path.join(temp_dir_path, data['file'])",
            "        lp = file_path.lower()",
            "        if lp.endswith(('.zip', '.tar.gz')):",
            "            if lp.endswith('.zip'):",
            "                with zipfile.ZipFile(file_path) as f:",
            "                    f.extractall(temp_dir_path)",
            "            elif lp.endswith('.tar.gz'):",
            "                with tarfile.open(file_path) as f:",
            "                    safe_extract(f, temp_dir_path)",
            "            os.remove(file_path)",
            "            files = os.listdir(temp_dir_path)",
            "            if len(files) != 1:",
            "                os.rmdir(temp_dir_path)",
            "                return http_error(400, 'Wrong content.', 'Archive must contain only one data file.')",
            "            file_path = os.path.join(temp_dir_path, files[0])",
            "            mindsdb_file_name = files[0]",
            "            if not os.path.isfile(file_path):",
            "                os.rmdir(temp_dir_path)",
            "                return http_error(400, 'Wrong content.', 'Archive must contain data file in root.')",
            "",
            "        ca.file_controller.save_file(mindsdb_file_name, file_path, file_name=original_file_name)",
            "",
            "        os.rmdir(temp_dir_path)",
            "",
            "        return '', 200",
            "",
            "    @ns_conf.doc('delete_file')",
            "    def delete(self, name: str):",
            "        '''delete file'''",
            "",
            "        try:",
            "            ca.file_controller.delete_file(name)",
            "        except Exception as e:",
            "            log.logger.error(e)",
            "            return http_error(",
            "                400,",
            "                \"Error deleting file\",",
            "                f\"There was an error while tring to delete file with name '{name}'\"",
            "            )",
            "        return '', 200"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [],
            "137": [
                "File",
                "put"
            ]
        },
        "addLocation": []
    },
    "mindsdb/api/http/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import os"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from flask import Response"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "             'Content-Type': 'application/problem+json'"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         }"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     )"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+def __is_within_directory(directory, target):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    abs_directory = os.path.abspath(directory)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    abs_target = os.path.abspath(target)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    prefix = os.path.commonprefix([abs_directory, abs_target])"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    return prefix == abs_directory"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+def safe_extract(tar, path=\".\", members=None, *, numeric_owner=False):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    for member in tar.getmembers():"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        member_path = os.path.join(path, member.name)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        if not __is_within_directory(path, member_path):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            raise Exception(\"Attempted Path Traversal in Tar File\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    tar.extractall(path, members, numeric_owner) "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+"
            }
        },
        "frontPatchFile": [
            "import json",
            "",
            "from flask import Response",
            "",
            "",
            "def http_error(status_code, title, detail=''):",
            "    ''' Wrapper for error responce acoording with RFC 7807 (https://tools.ietf.org/html/rfc7807)",
            "",
            "        :param status_code: int - http status code for response",
            "        :param title: str",
            "        :param detail: str",
            "",
            "        :return: flask Response object",
            "    '''",
            "    return Response(",
            "        response=json.dumps({",
            "            'title': title,",
            "            'detail': detail",
            "        }),",
            "        status=status_code,",
            "        headers={",
            "            'Content-Type': 'application/problem+json'",
            "        }",
            "    )"
        ],
        "afterPatchFile": [
            "import json",
            "import os",
            "",
            "from flask import Response",
            "",
            "",
            "def http_error(status_code, title, detail=''):",
            "    ''' Wrapper for error responce acoording with RFC 7807 (https://tools.ietf.org/html/rfc7807)",
            "",
            "        :param status_code: int - http status code for response",
            "        :param title: str",
            "        :param detail: str",
            "",
            "        :return: flask Response object",
            "    '''",
            "    return Response(",
            "        response=json.dumps({",
            "            'title': title,",
            "            'detail': detail",
            "        }),",
            "        status=status_code,",
            "        headers={",
            "            'Content-Type': 'application/problem+json'",
            "        }",
            "    )",
            "",
            "def __is_within_directory(directory, target):",
            "    abs_directory = os.path.abspath(directory)",
            "    abs_target = os.path.abspath(target)",
            "    prefix = os.path.commonprefix([abs_directory, abs_target])",
            "    return prefix == abs_directory",
            "",
            "def safe_extract(tar, path=\".\", members=None, *, numeric_owner=False):",
            "    for member in tar.getmembers():",
            "        member_path = os.path.join(path, member.name)",
            "        if not __is_within_directory(path, member_path):",
            "            raise Exception(\"Attempted Path Traversal in Tar File\")",
            "    tar.extractall(path, members, numeric_owner) "
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "IPython"
        ]
    }
}