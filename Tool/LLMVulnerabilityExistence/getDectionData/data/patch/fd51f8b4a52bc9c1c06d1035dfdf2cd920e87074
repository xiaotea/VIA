{
    "src/psd_tools/compression/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import array"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import io"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import zlib"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from psd_tools.constants import Compression"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from psd_tools.utils import ("
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     be_array_from_bytes, be_array_to_bytes, read_be_array, write_be_array"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " try:"
            },
            "9": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from . import _rle as rle"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    from . import _rle as rle_impl"
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " except ImportError:"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from . import rle"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    from . import rle as rle_impl"
            },
            "14": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " def compress(data, compression, width, height, depth, version=1):"
            },
            "17": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " def encode_rle(data, width, height, depth, version):"
            },
            "18": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     row_size = width * depth // 8"
            },
            "19": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     with io.BytesIO(data) as fp:"
            },
            "20": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rows = [rle.encode(fp.read(row_size)) for _ in range(height)]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        rows = [rle_impl.encode(fp.read(row_size)) for _ in range(height)]"
            },
            "22": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     bytes_counts = array.array(('H', 'I')[version - 1], map(len, rows))"
            },
            "23": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     encoded = b''.join(rows)"
            },
            "24": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     with io.BytesIO(data) as fp:"
            },
            "26": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         bytes_counts = read_be_array(('H', 'I')[version - 1], height, fp)"
            },
            "27": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         return b''.join("
            },
            "28": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            rle.decode(fp.read(count), row_size) for count in bytes_counts"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            rle_impl.decode(fp.read(count), row_size) for count in bytes_counts"
            },
            "30": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         )"
            },
            "31": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Image compression utils.",
            "\"\"\"",
            "from __future__ import absolute_import, unicode_literals",
            "import array",
            "import io",
            "import zlib",
            "",
            "from psd_tools.constants import Compression",
            "from psd_tools.utils import (",
            "    be_array_from_bytes, be_array_to_bytes, read_be_array, write_be_array",
            ")",
            "try:",
            "    from . import _rle as rle",
            "except ImportError:",
            "    from . import rle",
            "",
            "",
            "def compress(data, compression, width, height, depth, version=1):",
            "    \"\"\"Compress raw data.",
            "",
            "    :param data: raw data bytes to write.",
            "    :param compression: compression type, see :py:class:`.Compression`.",
            "    :param width: width.",
            "    :param height: height.",
            "    :param depth: bit depth of the pixel.",
            "    :param version: psd file version.",
            "    :return: compressed data bytes.",
            "    \"\"\"",
            "    if compression == Compression.RAW:",
            "        result = data",
            "    elif compression == Compression.RLE:",
            "        result = encode_rle(data, width, height, depth, version)",
            "    elif compression == Compression.ZIP:",
            "        result = zlib.compress(data)",
            "    else:",
            "        encoded = encode_prediction(data, width, height, depth)",
            "        result = zlib.compress(encoded)",
            "",
            "    return result",
            "",
            "",
            "def decompress(data, compression, width, height, depth, version=1):",
            "    \"\"\"Decompress raw data.",
            "",
            "    :param data: compressed data bytes.",
            "    :param compression: compression type,",
            "            see :py:class:`~psd_tools.constants.Compression`.",
            "    :param width: width.",
            "    :param height: height.",
            "    :param depth: bit depth of the pixel.",
            "    :param version: psd file version.",
            "    :return: decompressed data bytes.",
            "    \"\"\"",
            "    length = width * height * max(1, depth // 8)",
            "",
            "    result = None",
            "    if compression == Compression.RAW:",
            "        result = data[:length]",
            "    elif compression == Compression.RLE:",
            "        result = decode_rle(data, width, height, depth, version)",
            "    elif compression == Compression.ZIP:",
            "        result = zlib.decompress(data)",
            "    else:",
            "        decompressed = zlib.decompress(data)",
            "        result = decode_prediction(decompressed, width, height, depth)",
            "",
            "    if depth >= 8:",
            "        assert len(result) == length, (",
            "            'len=%d, expected=%d' % (len(result), length)",
            "        )",
            "",
            "    return result",
            "",
            "",
            "def encode_rle(data, width, height, depth, version):",
            "    row_size = width * depth // 8",
            "    with io.BytesIO(data) as fp:",
            "        rows = [rle.encode(fp.read(row_size)) for _ in range(height)]",
            "    bytes_counts = array.array(('H', 'I')[version - 1], map(len, rows))",
            "    encoded = b''.join(rows)",
            "",
            "    with io.BytesIO() as fp:",
            "        write_be_array(fp, bytes_counts)",
            "        fp.write(encoded)",
            "        result = fp.getvalue()",
            "",
            "    return result",
            "",
            "",
            "def decode_rle(data, width, height, depth, version):",
            "    row_size = max(width * depth // 8, 1)",
            "    with io.BytesIO(data) as fp:",
            "        bytes_counts = read_be_array(('H', 'I')[version - 1], height, fp)",
            "        return b''.join(",
            "            rle.decode(fp.read(count), row_size) for count in bytes_counts",
            "        )",
            "",
            "",
            "def encode_prediction(data, w, h, depth):",
            "    if depth == 8:",
            "        arr = array.array('B', data)",
            "        arr = _delta_encode(arr, 0x100, w, h)",
            "        return be_array_to_bytes(arr)",
            "    elif depth == 16:",
            "        arr = array.array('H', data)",
            "        arr = _delta_encode(arr, 0x10000, w, h)",
            "        return be_array_to_bytes(arr)",
            "    elif depth == 32:",
            "        arr = array.array('B', data)",
            "        arr = _shuffle_byte_order(arr, w, h)",
            "        arr = _delta_encode(arr, 0x100, w * 4, h)",
            "        return getattr(arr, 'tobytes', getattr(arr, 'tostring'))()",
            "    else:",
            "        raise ValueError('Invalid pixel size %d' % (depth))",
            "",
            "",
            "def decode_prediction(data, w, h, depth):",
            "    if depth == 8:",
            "        arr = be_array_from_bytes('B', data)",
            "        arr = _delta_decode(arr, 0x100, w, h)",
            "    elif depth == 16:",
            "        arr = be_array_from_bytes('H', data)",
            "        arr = _delta_decode(arr, 0x10000, w, h)",
            "    elif depth == 32:",
            "        arr = array.array('B', data)",
            "        arr = _delta_decode(arr, 0x100, w * 4, h)",
            "        arr = _restore_byte_order(arr, w, h)",
            "    else:",
            "        raise ValueError('Invalid pixel size %d' % (depth))",
            "",
            "    return getattr(arr, 'tobytes', getattr(arr, 'tostring'))()",
            "",
            "",
            "def _delta_encode(arr, mod, w, h):",
            "    arr.byteswap()",
            "    for y in reversed(range(h)):",
            "        offset = y * w",
            "        for x in reversed(range(w - 1)):",
            "            pos = offset + x",
            "            next_value = (arr[pos + 1] - arr[pos]) % mod",
            "            arr[pos + 1] = next_value",
            "    return arr",
            "",
            "",
            "def _delta_decode(arr, mod, w, h):",
            "    for y in range(h):",
            "        offset = y * w",
            "        for x in range(w - 1):",
            "            pos = offset + x",
            "            next_value = (arr[pos + 1] + arr[pos]) % mod",
            "            arr[pos + 1] = next_value",
            "    arr.byteswap()",
            "    return arr",
            "",
            "",
            "def _shuffled_order(w, h):",
            "    \"\"\"",
            "    Generator for the order of 4-byte values.",
            "",
            "    32bit channels are also encoded using delta encoding,",
            "    but it make no sense to apply delta compression to bytes.",
            "    It is possible to apply delta compression to 2-byte or 4-byte",
            "    words, but it seems it is not the best way either.",
            "    In PSD, each 4-byte item is split into 4 bytes and these",
            "    bytes are packed together: \"123412341234\" becomes \"111222333444\";",
            "    delta compression is applied to the packed data.",
            "",
            "    So we have to (a) decompress data from the delta compression",
            "    and (b) recombine data back to 4-byte values.",
            "    \"\"\"",
            "    rowsize = 4 * w",
            "    for row in range(0, rowsize * h, rowsize):",
            "        for offset in range(row, row + w):",
            "            for x in range(offset, offset + rowsize, w):",
            "                yield x",
            "",
            "",
            "def _shuffle_byte_order(bytes_array, w, h):",
            "    arr = bytes_array[:]",
            "    for src, dst in enumerate(_shuffled_order(w, h)):",
            "        arr[dst] = bytes_array[src]",
            "    return arr",
            "",
            "",
            "def _restore_byte_order(bytes_array, w, h):",
            "    arr = bytes_array[:]",
            "    for dst, src in enumerate(_shuffled_order(w, h)):",
            "        arr[dst] = bytes_array[src]",
            "    return arr"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Image compression utils.",
            "\"\"\"",
            "from __future__ import absolute_import, unicode_literals",
            "import array",
            "import io",
            "import zlib",
            "from psd_tools.constants import Compression",
            "from psd_tools.utils import (",
            "    be_array_from_bytes, be_array_to_bytes, read_be_array, write_be_array",
            ")",
            "try:",
            "    from . import _rle as rle_impl",
            "except ImportError:",
            "    from . import rle as rle_impl",
            "",
            "",
            "def compress(data, compression, width, height, depth, version=1):",
            "    \"\"\"Compress raw data.",
            "",
            "    :param data: raw data bytes to write.",
            "    :param compression: compression type, see :py:class:`.Compression`.",
            "    :param width: width.",
            "    :param height: height.",
            "    :param depth: bit depth of the pixel.",
            "    :param version: psd file version.",
            "    :return: compressed data bytes.",
            "    \"\"\"",
            "    if compression == Compression.RAW:",
            "        result = data",
            "    elif compression == Compression.RLE:",
            "        result = encode_rle(data, width, height, depth, version)",
            "    elif compression == Compression.ZIP:",
            "        result = zlib.compress(data)",
            "    else:",
            "        encoded = encode_prediction(data, width, height, depth)",
            "        result = zlib.compress(encoded)",
            "",
            "    return result",
            "",
            "",
            "def decompress(data, compression, width, height, depth, version=1):",
            "    \"\"\"Decompress raw data.",
            "",
            "    :param data: compressed data bytes.",
            "    :param compression: compression type,",
            "            see :py:class:`~psd_tools.constants.Compression`.",
            "    :param width: width.",
            "    :param height: height.",
            "    :param depth: bit depth of the pixel.",
            "    :param version: psd file version.",
            "    :return: decompressed data bytes.",
            "    \"\"\"",
            "    length = width * height * max(1, depth // 8)",
            "",
            "    result = None",
            "    if compression == Compression.RAW:",
            "        result = data[:length]",
            "    elif compression == Compression.RLE:",
            "        result = decode_rle(data, width, height, depth, version)",
            "    elif compression == Compression.ZIP:",
            "        result = zlib.decompress(data)",
            "    else:",
            "        decompressed = zlib.decompress(data)",
            "        result = decode_prediction(decompressed, width, height, depth)",
            "",
            "    if depth >= 8:",
            "        assert len(result) == length, (",
            "            'len=%d, expected=%d' % (len(result), length)",
            "        )",
            "",
            "    return result",
            "",
            "",
            "def encode_rle(data, width, height, depth, version):",
            "    row_size = width * depth // 8",
            "    with io.BytesIO(data) as fp:",
            "        rows = [rle_impl.encode(fp.read(row_size)) for _ in range(height)]",
            "    bytes_counts = array.array(('H', 'I')[version - 1], map(len, rows))",
            "    encoded = b''.join(rows)",
            "",
            "    with io.BytesIO() as fp:",
            "        write_be_array(fp, bytes_counts)",
            "        fp.write(encoded)",
            "        result = fp.getvalue()",
            "",
            "    return result",
            "",
            "",
            "def decode_rle(data, width, height, depth, version):",
            "    row_size = max(width * depth // 8, 1)",
            "    with io.BytesIO(data) as fp:",
            "        bytes_counts = read_be_array(('H', 'I')[version - 1], height, fp)",
            "        return b''.join(",
            "            rle_impl.decode(fp.read(count), row_size) for count in bytes_counts",
            "        )",
            "",
            "",
            "def encode_prediction(data, w, h, depth):",
            "    if depth == 8:",
            "        arr = array.array('B', data)",
            "        arr = _delta_encode(arr, 0x100, w, h)",
            "        return be_array_to_bytes(arr)",
            "    elif depth == 16:",
            "        arr = array.array('H', data)",
            "        arr = _delta_encode(arr, 0x10000, w, h)",
            "        return be_array_to_bytes(arr)",
            "    elif depth == 32:",
            "        arr = array.array('B', data)",
            "        arr = _shuffle_byte_order(arr, w, h)",
            "        arr = _delta_encode(arr, 0x100, w * 4, h)",
            "        return getattr(arr, 'tobytes', getattr(arr, 'tostring'))()",
            "    else:",
            "        raise ValueError('Invalid pixel size %d' % (depth))",
            "",
            "",
            "def decode_prediction(data, w, h, depth):",
            "    if depth == 8:",
            "        arr = be_array_from_bytes('B', data)",
            "        arr = _delta_decode(arr, 0x100, w, h)",
            "    elif depth == 16:",
            "        arr = be_array_from_bytes('H', data)",
            "        arr = _delta_decode(arr, 0x10000, w, h)",
            "    elif depth == 32:",
            "        arr = array.array('B', data)",
            "        arr = _delta_decode(arr, 0x100, w * 4, h)",
            "        arr = _restore_byte_order(arr, w, h)",
            "    else:",
            "        raise ValueError('Invalid pixel size %d' % (depth))",
            "",
            "    return getattr(arr, 'tobytes', getattr(arr, 'tostring'))()",
            "",
            "",
            "def _delta_encode(arr, mod, w, h):",
            "    arr.byteswap()",
            "    for y in reversed(range(h)):",
            "        offset = y * w",
            "        for x in reversed(range(w - 1)):",
            "            pos = offset + x",
            "            next_value = (arr[pos + 1] - arr[pos]) % mod",
            "            arr[pos + 1] = next_value",
            "    return arr",
            "",
            "",
            "def _delta_decode(arr, mod, w, h):",
            "    for y in range(h):",
            "        offset = y * w",
            "        for x in range(w - 1):",
            "            pos = offset + x",
            "            next_value = (arr[pos + 1] + arr[pos]) % mod",
            "            arr[pos + 1] = next_value",
            "    arr.byteswap()",
            "    return arr",
            "",
            "",
            "def _shuffled_order(w, h):",
            "    \"\"\"",
            "    Generator for the order of 4-byte values.",
            "",
            "    32bit channels are also encoded using delta encoding,",
            "    but it make no sense to apply delta compression to bytes.",
            "    It is possible to apply delta compression to 2-byte or 4-byte",
            "    words, but it seems it is not the best way either.",
            "    In PSD, each 4-byte item is split into 4 bytes and these",
            "    bytes are packed together: \"123412341234\" becomes \"111222333444\";",
            "    delta compression is applied to the packed data.",
            "",
            "    So we have to (a) decompress data from the delta compression",
            "    and (b) recombine data back to 4-byte values.",
            "    \"\"\"",
            "    rowsize = 4 * w",
            "    for row in range(0, rowsize * h, rowsize):",
            "        for offset in range(row, row + w):",
            "            for x in range(offset, offset + rowsize, w):",
            "                yield x",
            "",
            "",
            "def _shuffle_byte_order(bytes_array, w, h):",
            "    arr = bytes_array[:]",
            "    for src, dst in enumerate(_shuffled_order(w, h)):",
            "        arr[dst] = bytes_array[src]",
            "    return arr",
            "",
            "",
            "def _restore_byte_order(bytes_array, w, h):",
            "    arr = bytes_array[:]",
            "    for dst, src in enumerate(_shuffled_order(w, h)):",
            "        arr[dst] = bytes_array[src]",
            "    return arr"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [],
            "14": [],
            "16": [],
            "79": [
                "encode_rle"
            ],
            "96": [
                "decode_rle"
            ]
        },
        "addLocation": []
    },
    "src/psd_tools/compression/rle.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " def decode(data, size):"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Decodes a PackBit encoded data."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+    Decodes RLE encoded data."
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": "     \"\"\""
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": "     data = bytearray(data)  # <- python 2/3 compatibility fix"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": "     result = bytearray(size)"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "         src += 1"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "         if 0 <= header <= 127:"
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result[dst:dst + header + 1] = data[src:src + header + 1]"
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            src += header + 1"
            },
            "12": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dst += header + 1"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+            length = header + 1"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+            if src + length <= len(data) and dst + length <= size:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+                result[dst:dst + header + 1] = data[src:src + length]"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+                src += length"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+                dst += length"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+            else:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+                raise ValueError('Invalid RLE compression')"
            },
            "20": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         elif header == -128:"
            },
            "21": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "             pass"
            },
            "22": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         else:"
            },
            "23": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result[dst:dst + 1 - header] = [data[src]] * (1 - header)"
            },
            "24": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            src += 1"
            },
            "25": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dst += 1 - header"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+            length = 1 - header"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            if src + 1 <= len(data) and dst + length <= size:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+                result[dst:dst + length] = [data[src]] * length"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+                src += 1"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+                dst += length"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+            else:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+                raise ValueError('Invalid RLE compression')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    if dst < size:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        raise ValueError('Expected %d bytes but decoded only %d bytes' % ("
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            size, dst))"
            },
            "36": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     return bytes(result)"
            },
            "38": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " def encode(data):"
            },
            "41": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     \"\"\""
            },
            "42": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Encodes data using PackBits encoding."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    Encodes data using RLE encoding."
            },
            "44": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     \"\"\""
            },
            "45": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     if len(data) == 0:"
            },
            "46": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         return data"
            }
        },
        "frontPatchFile": [
            "def decode(data, size):",
            "    \"\"\"",
            "    Decodes a PackBit encoded data.",
            "    \"\"\"",
            "    data = bytearray(data)  # <- python 2/3 compatibility fix",
            "    result = bytearray(size)",
            "    src = 0",
            "    dst = 0",
            "    while src < len(data):",
            "        header = data[src]",
            "        if header > 127:",
            "            header -= 256",
            "        src += 1",
            "",
            "        if 0 <= header <= 127:",
            "            result[dst:dst + header + 1] = data[src:src + header + 1]",
            "            src += header + 1",
            "            dst += header + 1",
            "        elif header == -128:",
            "            pass",
            "        else:",
            "            result[dst:dst + 1 - header] = [data[src]] * (1 - header)",
            "            src += 1",
            "            dst += 1 - header",
            "",
            "    return bytes(result)",
            "",
            "",
            "def encode(data):",
            "    \"\"\"",
            "    Encodes data using PackBits encoding.",
            "    \"\"\"",
            "    if len(data) == 0:",
            "        return data",
            "",
            "    if len(data) == 1:",
            "        return b'\\x00' + data",
            "",
            "    data = bytearray(data)",
            "",
            "    result = bytearray()",
            "    buf = bytearray()",
            "    pos = 0",
            "    repeat_count = 0",
            "    MAX_LENGTH = 127",
            "",
            "    # we can safely start with RAW as empty RAW sequences",
            "    # are handled by finish_raw(buf, result)",
            "    state = 'RAW'",
            "",
            "    while pos < len(data) - 1:",
            "        current_byte = data[pos]",
            "",
            "        if data[pos] == data[pos + 1]:",
            "            if state == 'RAW':",
            "                # end of RAW data",
            "                finish_raw(buf, result)",
            "                state = 'RLE'",
            "                repeat_count = 1",
            "            elif state == 'RLE':",
            "                if repeat_count == MAX_LENGTH:",
            "                    # restart the encoding",
            "                    finish_rle(result, repeat_count, data, pos)",
            "                    repeat_count = 0",
            "                # move to next byte",
            "                repeat_count += 1",
            "",
            "        else:",
            "            if state == 'RLE':",
            "                repeat_count += 1",
            "                finish_rle(result, repeat_count, data, pos)",
            "                state = 'RAW'",
            "                repeat_count = 0",
            "            elif state == 'RAW':",
            "                if len(buf) == MAX_LENGTH:",
            "                    # restart the encoding",
            "                    finish_raw(buf, result)",
            "",
            "                buf.append(current_byte)",
            "",
            "        pos += 1",
            "",
            "    if state == 'RAW':",
            "        buf.append(data[pos])",
            "        finish_raw(buf, result)",
            "    else:",
            "        repeat_count += 1",
            "        finish_rle(result, repeat_count, data, pos)",
            "",
            "    return bytes(result)",
            "",
            "",
            "def finish_raw(buf, result):",
            "    if len(buf) == 0:",
            "        return",
            "    result.append(len(buf) - 1)",
            "    result.extend(buf)",
            "    buf[:] = bytearray()",
            "",
            "",
            "def finish_rle(result, repeat_count, data, pos):",
            "    result.append(256 - (repeat_count - 1))",
            "    result.append(data[pos])"
        ],
        "afterPatchFile": [
            "def decode(data, size):",
            "    \"\"\"",
            "    Decodes RLE encoded data.",
            "    \"\"\"",
            "    data = bytearray(data)  # <- python 2/3 compatibility fix",
            "    result = bytearray(size)",
            "    src = 0",
            "    dst = 0",
            "    while src < len(data):",
            "        header = data[src]",
            "        if header > 127:",
            "            header -= 256",
            "        src += 1",
            "",
            "        if 0 <= header <= 127:",
            "            length = header + 1",
            "            if src + length <= len(data) and dst + length <= size:",
            "                result[dst:dst + header + 1] = data[src:src + length]",
            "                src += length",
            "                dst += length",
            "            else:",
            "                raise ValueError('Invalid RLE compression')",
            "        elif header == -128:",
            "            pass",
            "        else:",
            "            length = 1 - header",
            "            if src + 1 <= len(data) and dst + length <= size:",
            "                result[dst:dst + length] = [data[src]] * length",
            "                src += 1",
            "                dst += length",
            "            else:",
            "                raise ValueError('Invalid RLE compression')",
            "    if dst < size:",
            "        raise ValueError('Expected %d bytes but decoded only %d bytes' % (",
            "            size, dst))",
            "",
            "    return bytes(result)",
            "",
            "",
            "def encode(data):",
            "    \"\"\"",
            "    Encodes data using RLE encoding.",
            "    \"\"\"",
            "    if len(data) == 0:",
            "        return data",
            "",
            "    if len(data) == 1:",
            "        return b'\\x00' + data",
            "",
            "    data = bytearray(data)",
            "",
            "    result = bytearray()",
            "    buf = bytearray()",
            "    pos = 0",
            "    repeat_count = 0",
            "    MAX_LENGTH = 127",
            "",
            "    # we can safely start with RAW as empty RAW sequences",
            "    # are handled by finish_raw(buf, result)",
            "    state = 'RAW'",
            "",
            "    while pos < len(data) - 1:",
            "        current_byte = data[pos]",
            "",
            "        if data[pos] == data[pos + 1]:",
            "            if state == 'RAW':",
            "                # end of RAW data",
            "                finish_raw(buf, result)",
            "                state = 'RLE'",
            "                repeat_count = 1",
            "            elif state == 'RLE':",
            "                if repeat_count == MAX_LENGTH:",
            "                    # restart the encoding",
            "                    finish_rle(result, repeat_count, data, pos)",
            "                    repeat_count = 0",
            "                # move to next byte",
            "                repeat_count += 1",
            "",
            "        else:",
            "            if state == 'RLE':",
            "                repeat_count += 1",
            "                finish_rle(result, repeat_count, data, pos)",
            "                state = 'RAW'",
            "                repeat_count = 0",
            "            elif state == 'RAW':",
            "                if len(buf) == MAX_LENGTH:",
            "                    # restart the encoding",
            "                    finish_raw(buf, result)",
            "",
            "                buf.append(current_byte)",
            "",
            "        pos += 1",
            "",
            "    if state == 'RAW':",
            "        buf.append(data[pos])",
            "        finish_raw(buf, result)",
            "    else:",
            "        repeat_count += 1",
            "        finish_rle(result, repeat_count, data, pos)",
            "",
            "    return bytes(result)",
            "",
            "",
            "def finish_raw(buf, result):",
            "    if len(buf) == 0:",
            "        return",
            "    result.append(len(buf) - 1)",
            "    result.extend(buf)",
            "    buf[:] = bytearray()",
            "",
            "",
            "def finish_rle(result, repeat_count, data, pos):",
            "    result.append(256 - (repeat_count - 1))",
            "    result.append(data[pos])"
        ],
        "action": [
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "3": [
                "decode"
            ],
            "16": [
                "decode"
            ],
            "17": [
                "decode"
            ],
            "18": [
                "decode"
            ],
            "22": [
                "decode"
            ],
            "23": [
                "decode"
            ],
            "24": [
                "decode"
            ],
            "31": [
                "encode"
            ]
        },
        "addLocation": []
    },
    "src/psd_tools/version.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = '1.9.3'"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+__version__ = '1.9.4'"
            }
        },
        "frontPatchFile": [
            "__version__ = '1.9.3'"
        ],
        "afterPatchFile": [
            "__version__ = '1.9.4'"
        ],
        "action": [
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "1": [
                "__version__"
            ]
        },
        "addLocation": []
    }
}