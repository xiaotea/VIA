{
    "mlflow/data/http_dataset_source.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import posixpath"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import re"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from typing import Any, Dict"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from urllib.parse import urlparse"
            },
            "5": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     def _get_source_type() -> str:"
            },
            "6": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         return \"http\""
            },
            "7": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    def _extract_filename(self, response) -> str:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        Extracts a filename from the Content-Disposition header or the URL's path."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        if content_disposition := response.headers.get(\"Content-Disposition\"):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            for match in re.finditer(r\"filename=(.+)\", content_disposition):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                filename = match[1].strip(\"'\\\"\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                if _is_path(filename):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                    raise MlflowException.invalid_parameter_value("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                        f\"Invalid filename in Content-Disposition header: {filename}. \""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                        \"It must be a file name, not a path.\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                    )"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                return filename"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        # Extract basename from URL if no valid filename in Content-Disposition"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        return os.path.basename(urlparse(self.url).path)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     def load(self, dst_path=None) -> str:"
            },
            "26": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         \"\"\""
            },
            "27": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         Downloads the dataset source to the local filesystem."
            },
            "28": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         )"
            },
            "29": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         augmented_raise_for_status(resp)"
            },
            "30": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path = urlparse(self.url).path"
            },
            "32": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        content_disposition = resp.headers.get(\"Content-Disposition\")"
            },
            "33": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if content_disposition is not None and ("
            },
            "34": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file_name := next(re.finditer(r\"filename=(.+)\", content_disposition), None)"
            },
            "35": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ):"
            },
            "36": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # NB: If the filename is quoted, unquote it"
            },
            "37": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            basename = file_name[1].strip(\"'\\\"\")"
            },
            "38": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if _is_path(basename):"
            },
            "39": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise MlflowException.invalid_parameter_value("
            },
            "40": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"Invalid filename in Content-Disposition header: {basename}. \""
            },
            "41": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"It must be a file name, not a path.\""
            },
            "42": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "43": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif path is not None and len(posixpath.basename(path)) > 0:"
            },
            "44": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            basename = posixpath.basename(path)"
            },
            "45": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        basename = self._extract_filename(resp)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        if not basename:"
            },
            "49": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "             basename = \"dataset_source\""
            },
            "50": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         if dst_path is None:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import posixpath",
            "import re",
            "from typing import Any, Dict",
            "from urllib.parse import urlparse",
            "",
            "from mlflow.data.dataset_source import DatasetSource",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.utils.file_utils import create_tmp_dir",
            "from mlflow.utils.rest_utils import augmented_raise_for_status, cloud_storage_http_request",
            "",
            "",
            "def _is_path(filename: str) -> bool:",
            "    \"\"\"",
            "    Return True if `filename` is a path, False otherwise. For example,",
            "    \"foo/bar\" is a path, but \"bar\" is not.",
            "    \"\"\"",
            "    return os.path.basename(filename) != filename",
            "",
            "",
            "class HTTPDatasetSource(DatasetSource):",
            "    \"\"\"",
            "    Represents the source of a dataset stored at a web location and referred to",
            "    by an HTTP or HTTPS URL.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        self._url = url",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        The HTTP/S URL referring to the dataset source location.",
            "",
            "        :return: The HTTP/S URL referring to the dataset source location.",
            "        \"\"\"",
            "        return self._url",
            "",
            "    @staticmethod",
            "    def _get_source_type() -> str:",
            "        return \"http\"",
            "",
            "    def load(self, dst_path=None) -> str:",
            "        \"\"\"",
            "        Downloads the dataset source to the local filesystem.",
            "",
            "        :param dst_path: Path of the local filesystem destination directory to which to download the",
            "                         dataset source. If the directory does not exist, it is created. If",
            "                         unspecified, the dataset source is downloaded to a new uniquely-named",
            "                         directory on the local filesystem.",
            "        :return: The path to the downloaded dataset source on the local filesystem.",
            "        \"\"\"",
            "        resp = cloud_storage_http_request(",
            "            method=\"GET\",",
            "            url=self.url,",
            "            stream=True,",
            "        )",
            "        augmented_raise_for_status(resp)",
            "",
            "        path = urlparse(self.url).path",
            "        content_disposition = resp.headers.get(\"Content-Disposition\")",
            "        if content_disposition is not None and (",
            "            file_name := next(re.finditer(r\"filename=(.+)\", content_disposition), None)",
            "        ):",
            "            # NB: If the filename is quoted, unquote it",
            "            basename = file_name[1].strip(\"'\\\"\")",
            "            if _is_path(basename):",
            "                raise MlflowException.invalid_parameter_value(",
            "                    f\"Invalid filename in Content-Disposition header: {basename}. \"",
            "                    \"It must be a file name, not a path.\"",
            "                )",
            "        elif path is not None and len(posixpath.basename(path)) > 0:",
            "            basename = posixpath.basename(path)",
            "        else:",
            "            basename = \"dataset_source\"",
            "",
            "        if dst_path is None:",
            "            dst_path = create_tmp_dir()",
            "",
            "        dst_path = os.path.join(dst_path, basename)",
            "        with open(dst_path, \"wb\") as f:",
            "            chunk_size = 1024 * 1024  # 1 MB",
            "            for chunk in resp.iter_content(chunk_size=chunk_size):",
            "                f.write(chunk)",
            "",
            "        return dst_path",
            "",
            "    @staticmethod",
            "    def _can_resolve(raw_source: Any) -> bool:",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        :return: True if this DatsetSource can resolve the raw source, False otherwise.",
            "        \"\"\"",
            "        if not isinstance(raw_source, str):",
            "            return False",
            "",
            "        try:",
            "            parsed_source = urlparse(str(raw_source))",
            "            return parsed_source.scheme in [\"http\", \"https\"]",
            "        except Exception:",
            "            return False",
            "",
            "    @classmethod",
            "    def _resolve(cls, raw_source: Any) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        \"\"\"",
            "        return HTTPDatasetSource(raw_source)",
            "",
            "    def _to_dict(self) -> Dict[Any, Any]:",
            "        \"\"\"",
            "        :return: A JSON-compatible dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        return {",
            "            \"url\": self.url,",
            "        }",
            "",
            "    @classmethod",
            "    def _from_dict(cls, source_dict: Dict[Any, Any]) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param source_dict: A dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        url = source_dict.get(\"url\")",
            "        if url is None:",
            "            raise MlflowException(",
            "                'Failed to parse HTTPDatasetSource. Missing expected key: \"url\"',",
            "                INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        return cls(url=url)"
        ],
        "afterPatchFile": [
            "import os",
            "import re",
            "from typing import Any, Dict",
            "from urllib.parse import urlparse",
            "",
            "from mlflow.data.dataset_source import DatasetSource",
            "from mlflow.exceptions import MlflowException",
            "from mlflow.protos.databricks_pb2 import INVALID_PARAMETER_VALUE",
            "from mlflow.utils.file_utils import create_tmp_dir",
            "from mlflow.utils.rest_utils import augmented_raise_for_status, cloud_storage_http_request",
            "",
            "",
            "def _is_path(filename: str) -> bool:",
            "    \"\"\"",
            "    Return True if `filename` is a path, False otherwise. For example,",
            "    \"foo/bar\" is a path, but \"bar\" is not.",
            "    \"\"\"",
            "    return os.path.basename(filename) != filename",
            "",
            "",
            "class HTTPDatasetSource(DatasetSource):",
            "    \"\"\"",
            "    Represents the source of a dataset stored at a web location and referred to",
            "    by an HTTP or HTTPS URL.",
            "    \"\"\"",
            "",
            "    def __init__(self, url):",
            "        self._url = url",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        The HTTP/S URL referring to the dataset source location.",
            "",
            "        :return: The HTTP/S URL referring to the dataset source location.",
            "        \"\"\"",
            "        return self._url",
            "",
            "    @staticmethod",
            "    def _get_source_type() -> str:",
            "        return \"http\"",
            "",
            "    def _extract_filename(self, response) -> str:",
            "        \"\"\"",
            "        Extracts a filename from the Content-Disposition header or the URL's path.",
            "        \"\"\"",
            "        if content_disposition := response.headers.get(\"Content-Disposition\"):",
            "            for match in re.finditer(r\"filename=(.+)\", content_disposition):",
            "                filename = match[1].strip(\"'\\\"\")",
            "                if _is_path(filename):",
            "                    raise MlflowException.invalid_parameter_value(",
            "                        f\"Invalid filename in Content-Disposition header: {filename}. \"",
            "                        \"It must be a file name, not a path.\"",
            "                    )",
            "                return filename",
            "",
            "        # Extract basename from URL if no valid filename in Content-Disposition",
            "        return os.path.basename(urlparse(self.url).path)",
            "",
            "    def load(self, dst_path=None) -> str:",
            "        \"\"\"",
            "        Downloads the dataset source to the local filesystem.",
            "",
            "        :param dst_path: Path of the local filesystem destination directory to which to download the",
            "                         dataset source. If the directory does not exist, it is created. If",
            "                         unspecified, the dataset source is downloaded to a new uniquely-named",
            "                         directory on the local filesystem.",
            "        :return: The path to the downloaded dataset source on the local filesystem.",
            "        \"\"\"",
            "        resp = cloud_storage_http_request(",
            "            method=\"GET\",",
            "            url=self.url,",
            "            stream=True,",
            "        )",
            "        augmented_raise_for_status(resp)",
            "",
            "        basename = self._extract_filename(resp)",
            "",
            "        if not basename:",
            "            basename = \"dataset_source\"",
            "",
            "        if dst_path is None:",
            "            dst_path = create_tmp_dir()",
            "",
            "        dst_path = os.path.join(dst_path, basename)",
            "        with open(dst_path, \"wb\") as f:",
            "            chunk_size = 1024 * 1024  # 1 MB",
            "            for chunk in resp.iter_content(chunk_size=chunk_size):",
            "                f.write(chunk)",
            "",
            "        return dst_path",
            "",
            "    @staticmethod",
            "    def _can_resolve(raw_source: Any) -> bool:",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        :return: True if this DatsetSource can resolve the raw source, False otherwise.",
            "        \"\"\"",
            "        if not isinstance(raw_source, str):",
            "            return False",
            "",
            "        try:",
            "            parsed_source = urlparse(str(raw_source))",
            "            return parsed_source.scheme in [\"http\", \"https\"]",
            "        except Exception:",
            "            return False",
            "",
            "    @classmethod",
            "    def _resolve(cls, raw_source: Any) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param raw_source: The raw source, e.g. a string like \"http://mysite/mydata.tar.gz\".",
            "        \"\"\"",
            "        return HTTPDatasetSource(raw_source)",
            "",
            "    def _to_dict(self) -> Dict[Any, Any]:",
            "        \"\"\"",
            "        :return: A JSON-compatible dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        return {",
            "            \"url\": self.url,",
            "        }",
            "",
            "    @classmethod",
            "    def _from_dict(cls, source_dict: Dict[Any, Any]) -> \"HTTPDatasetSource\":",
            "        \"\"\"",
            "        :param source_dict: A dictionary representation of the HTTPDatasetSource.",
            "        \"\"\"",
            "        url = source_dict.get(\"url\")",
            "        if url is None:",
            "            raise MlflowException(",
            "                'Failed to parse HTTPDatasetSource. Missing expected key: \"url\"',",
            "                INVALID_PARAMETER_VALUE,",
            "            )",
            "",
            "        return cls(url=url)"
        ],
        "action": [
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": [],
            "61": [
                "HTTPDatasetSource",
                "load"
            ],
            "62": [
                "HTTPDatasetSource",
                "load"
            ],
            "63": [
                "HTTPDatasetSource",
                "load"
            ],
            "64": [
                "HTTPDatasetSource",
                "load"
            ],
            "65": [
                "HTTPDatasetSource",
                "load"
            ],
            "66": [
                "HTTPDatasetSource",
                "load"
            ],
            "67": [
                "HTTPDatasetSource",
                "load"
            ],
            "68": [
                "HTTPDatasetSource",
                "load"
            ],
            "69": [
                "HTTPDatasetSource",
                "load"
            ],
            "70": [
                "HTTPDatasetSource",
                "load"
            ],
            "71": [
                "HTTPDatasetSource",
                "load"
            ],
            "72": [
                "HTTPDatasetSource",
                "load"
            ],
            "73": [
                "HTTPDatasetSource",
                "load"
            ],
            "74": [
                "HTTPDatasetSource",
                "load"
            ],
            "75": [
                "HTTPDatasetSource",
                "load"
            ]
        },
        "addLocation": []
    }
}