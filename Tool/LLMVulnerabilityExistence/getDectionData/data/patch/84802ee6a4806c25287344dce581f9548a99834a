{
    "gradio/route_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from dataclasses import dataclass as python_dataclass"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from tempfile import NamedTemporaryFile, _TemporaryFileWrapper"
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from typing import TYPE_CHECKING, AsyncGenerator, BinaryIO, List, Optional, Tuple, Union"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "4": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import fastapi"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import httpx"
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from multipart.multipart import parse_options_header"
            },
            "8": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from starlette.datastructures import FormData, Headers, UploadFile"
            },
            "9": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from starlette.formparsers import MultiPartException, MultipartPart"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from starlette.middleware.base import BaseHTTPMiddleware"
            },
            "11": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from gradio import processing_utils, utils"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from gradio.data_classes import PredictBody"
            },
            "14": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "     pattern = r\"^[a-zA-Z][a-zA-Z0-9+\\-.]*://\""
            },
            "16": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "     return re.match(pattern, string) is not None"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 589,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 590,
                "PatchRowcode": "+def get_hostname(url: str) -> str:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 591,
                "PatchRowcode": "+    \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 592,
                "PatchRowcode": "+    Returns the hostname of a given url, or an empty string if the url cannot be parsed."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 593,
                "PatchRowcode": "+    Examples:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 594,
                "PatchRowcode": "+        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+        get_hostname(\"localhost:7860\") -> \"localhost\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+    \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+    if not url:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+        return \"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+    if \"://\" not in url:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+        url = \"http://\" + url"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+    try:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+        return urlparse(url).hostname or \"\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+    except Exception:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+        return \"\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+class CustomCORSMiddleware(BaseHTTPMiddleware):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+    async def dispatch(self, request: fastapi.Request, call_next):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+        host: str = request.headers.get(\"host\", \"\")"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+        origin: str = request.headers.get(\"origin\", \"\")"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+        host_name = get_hostname(host)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 613,
                "PatchRowcode": "+        origin_name = get_hostname(origin)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 614,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        # Any of these hosts suggests that the Gradio app is running locally."
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+        # Note: \"null\" is a special case that happens if a Gradio app is running"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+        # as an embedded web component in a local static webpage."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+        localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"null\"]"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+        is_preflight = ("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+            request.method == \"OPTIONS\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+            and \"access-control-request-method\" in request.headers"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+        )"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+        if host_name in localhost_aliases and origin_name not in localhost_aliases:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+            allow_origin_header = None"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+        else:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+            allow_origin_header = origin"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+        if is_preflight:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 630,
                "PatchRowcode": "+            response = fastapi.Response()"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+        else:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 632,
                "PatchRowcode": "+            response = await call_next(request)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 633,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+        if allow_origin_header:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+            response.headers[\"Access-Control-Allow-Origin\"] = allow_origin_header"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+        response.headers["
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+            \"Access-Control-Allow-Methods\""
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+        ] = \"GET, POST, PUT, DELETE, OPTIONS\""
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+        response.headers["
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+            \"Access-Control-Allow-Headers\""
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+        ] = \"Origin, Content-Type, Accept\""
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+        return response"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import hashlib",
            "import hmac",
            "import json",
            "import re",
            "import shutil",
            "from collections import deque",
            "from dataclasses import dataclass as python_dataclass",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import TYPE_CHECKING, AsyncGenerator, BinaryIO, List, Optional, Tuple, Union",
            "",
            "import fastapi",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import PredictBody",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def infer_fn_index(app: App, api_name: str, body: PredictBody) -> int:",
            "    if body.fn_index is None:",
            "        for i, fn in enumerate(app.get_blocks().dependencies):",
            "            if fn[\"api_name\"] == api_name:",
            "                return i",
            "",
            "        raise FnIndexInferError(f\"Could not infer fn_index for api_name {api_name}.\")",
            "    else:",
            "        return body.fn_index",
            "",
            "",
            "def compile_gr_request(",
            "    app: App,",
            "    body: PredictBody,",
            "    fn_index_inferred: int,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if app.get_blocks().dependencies[fn_index_inferred][\"cancels\"]:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(username=username, request=body.request)",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(username=username, request=request)",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn_index_inferred: int,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    dependency = app.get_blocks().dependencies[fn_index_inferred]",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and dependency[\"batch\"]",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                fn_index=fn_index_inferred,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, list] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.append(None)",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the request, stripping off any query parameters, the route_path, and trailing slashes.",
            "    Also ensures that the root url is https if the request is https. If root_path is provided, it is appended to the root url.",
            "    The final root url will not have a trailing slash.",
            "    \"\"\"",
            "    root_url = str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if request.headers.get(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0:",
            "        root_url = root_url[: -len(route_path)]",
            "    return (root_url.rstrip(\"/\") + (root_path or \"\")).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, self._charset),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: dict, root: str) -> dict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    previous_root = config.get(\"root\")",
            "    if previous_root is None or previous_root != root:",
            "        config[\"root\"] = root",
            "        config = processing_utils.add_root_url(config, root, previous_root)",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://",
            "    \"\"\"",
            "    pattern = r\"^[a-zA-Z][a-zA-Z0-9+\\-.]*://\"",
            "    return re.match(pattern, string) is not None"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import hashlib",
            "import hmac",
            "import json",
            "import re",
            "import shutil",
            "from collections import deque",
            "from dataclasses import dataclass as python_dataclass",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import TYPE_CHECKING, AsyncGenerator, BinaryIO, List, Optional, Tuple, Union",
            "from urllib.parse import urlparse",
            "",
            "import fastapi",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "from starlette.middleware.base import BaseHTTPMiddleware",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import PredictBody",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def infer_fn_index(app: App, api_name: str, body: PredictBody) -> int:",
            "    if body.fn_index is None:",
            "        for i, fn in enumerate(app.get_blocks().dependencies):",
            "            if fn[\"api_name\"] == api_name:",
            "                return i",
            "",
            "        raise FnIndexInferError(f\"Could not infer fn_index for api_name {api_name}.\")",
            "    else:",
            "        return body.fn_index",
            "",
            "",
            "def compile_gr_request(",
            "    app: App,",
            "    body: PredictBody,",
            "    fn_index_inferred: int,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if app.get_blocks().dependencies[fn_index_inferred][\"cancels\"]:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(username=username, request=body.request)",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(username=username, request=request)",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn_index_inferred: int,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    dependency = app.get_blocks().dependencies[fn_index_inferred]",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and dependency[\"batch\"]",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                fn_index=fn_index_inferred,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, list] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.append(None)",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the request, stripping off any query parameters, the route_path, and trailing slashes.",
            "    Also ensures that the root url is https if the request is https. If root_path is provided, it is appended to the root url.",
            "    The final root url will not have a trailing slash.",
            "    \"\"\"",
            "    root_url = str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if request.headers.get(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0:",
            "        root_url = root_url[: -len(route_path)]",
            "    return (root_url.rstrip(\"/\") + (root_path or \"\")).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, self._charset),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: dict, root: str) -> dict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    previous_root = config.get(\"root\")",
            "    if previous_root is None or previous_root != root:",
            "        config[\"root\"] = root",
            "        config = processing_utils.add_root_url(config, root, previous_root)",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://",
            "    \"\"\"",
            "    pattern = r\"^[a-zA-Z][a-zA-Z0-9+\\-.]*://\"",
            "    return re.match(pattern, string) is not None",
            "",
            "",
            "def get_hostname(url: str) -> str:",
            "    \"\"\"",
            "    Returns the hostname of a given url, or an empty string if the url cannot be parsed.",
            "    Examples:",
            "        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\"",
            "        get_hostname(\"localhost:7860\") -> \"localhost\"",
            "        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\"",
            "    \"\"\"",
            "    if not url:",
            "        return \"\"",
            "    if \"://\" not in url:",
            "        url = \"http://\" + url",
            "    try:",
            "        return urlparse(url).hostname or \"\"",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "class CustomCORSMiddleware(BaseHTTPMiddleware):",
            "    async def dispatch(self, request: fastapi.Request, call_next):",
            "        host: str = request.headers.get(\"host\", \"\")",
            "        origin: str = request.headers.get(\"origin\", \"\")",
            "        host_name = get_hostname(host)",
            "        origin_name = get_hostname(origin)",
            "",
            "        # Any of these hosts suggests that the Gradio app is running locally.",
            "        # Note: \"null\" is a special case that happens if a Gradio app is running",
            "        # as an embedded web component in a local static webpage.",
            "        localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"null\"]",
            "        is_preflight = (",
            "            request.method == \"OPTIONS\"",
            "            and \"access-control-request-method\" in request.headers",
            "        )",
            "",
            "        if host_name in localhost_aliases and origin_name not in localhost_aliases:",
            "            allow_origin_header = None",
            "        else:",
            "            allow_origin_header = origin",
            "",
            "        if is_preflight:",
            "            response = fastapi.Response()",
            "        else:",
            "            response = await call_next(request)",
            "",
            "        if allow_origin_header:",
            "            response.headers[\"Access-Control-Allow-Origin\"] = allow_origin_header",
            "        response.headers[",
            "            \"Access-Control-Allow-Methods\"",
            "        ] = \"GET, POST, PUT, DELETE, OPTIONS\"",
            "        response.headers[",
            "            \"Access-Control-Allow-Headers\"",
            "        ] = \"Origin, Content-Type, Accept\"",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.contrib.auth.tests.test_views.PasswordResetTest.test_confirm_redirect_default"
        ]
    },
    "gradio/routes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " import markupsafe"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import orjson"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status"
            },
            "3": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from fastapi.middleware.cors import CORSMiddleware"
            },
            "4": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from fastapi.responses import ("
            },
            "5": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     FileResponse,"
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     HTMLResponse,"
            },
            "7": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from gradio.processing_utils import add_root_url"
            },
            "8": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " from gradio.queueing import Estimation"
            },
            "9": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from gradio.route_utils import (  # noqa: F401"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    CustomCORSMiddleware,"
            },
            "11": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     FileUploadProgress,"
            },
            "12": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     FileUploadProgressNotQueuedError,"
            },
            "13": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     FileUploadProgressNotTrackedError,"
            },
            "14": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         app.configure_app(blocks)"
            },
            "15": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         if not wasm_utils.IS_WASM:"
            },
            "17": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            app.add_middleware("
            },
            "18": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                CORSMiddleware,"
            },
            "19": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                allow_origins=[\"*\"],"
            },
            "20": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                allow_methods=[\"*\"],"
            },
            "21": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                allow_headers=[\"*\"],"
            },
            "22": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+            app.add_middleware(CustomCORSMiddleware)"
            },
            "24": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 200,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         @app.get(\"/user\")"
            },
            "26": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         @app.get(\"/user/\")"
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements a FastAPI server to run the gradio interface. Note that some types in this",
            "module use the Optional/Union notation so that they work correctly with pydantic.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import contextlib",
            "import sys",
            "",
            "if sys.version_info >= (3, 9):",
            "    from importlib.resources import files",
            "else:",
            "    from importlib_resources import files",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import posixpath",
            "import secrets",
            "import threading",
            "import time",
            "import traceback",
            "from pathlib import Path",
            "from queue import Empty as EmptyQueue",
            "from typing import TYPE_CHECKING, Any, AsyncIterator, Dict, List, Optional, Type",
            "",
            "import fastapi",
            "import httpx",
            "import markupsafe",
            "import orjson",
            "from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status",
            "from fastapi.middleware.cors import CORSMiddleware",
            "from fastapi.responses import (",
            "    FileResponse,",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            ")",
            "from fastapi.security import OAuth2PasswordRequestForm",
            "from fastapi.templating import Jinja2Templates",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import ServerMessage",
            "from jinja2.exceptions import TemplateNotFound",
            "from multipart.multipart import parse_options_header",
            "from starlette.background import BackgroundTask",
            "from starlette.responses import RedirectResponse, StreamingResponse",
            "",
            "import gradio",
            "from gradio import ranged_response, route_utils, utils, wasm_utils",
            "from gradio.context import Context",
            "from gradio.data_classes import ComponentServerBody, PredictBody, ResetBody",
            "from gradio.exceptions import Error",
            "from gradio.oauth import attach_oauth",
            "from gradio.processing_utils import add_root_url",
            "from gradio.queueing import Estimation",
            "from gradio.route_utils import (  # noqa: F401",
            "    FileUploadProgress,",
            "    FileUploadProgressNotQueuedError,",
            "    FileUploadProgressNotTrackedError,",
            "    GradioMultiPartParser,",
            "    GradioUploadFile,",
            "    MultiPartException,",
            "    Request,",
            "    compare_passwords_securely,",
            "    move_uploaded_files_to_cache,",
            ")",
            "from gradio.state_holder import StateHolder",
            "from gradio.utils import get_package_version, get_upload_folder",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "mimetypes.init()",
            "",
            "STATIC_TEMPLATE_LIB = files(\"gradio\").joinpath(\"templates\").as_posix()  # type: ignore",
            "STATIC_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix()  # type: ignore",
            "BUILD_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix()  # type: ignore",
            "VERSION = get_package_version()",
            "",
            "",
            "class ORJSONResponse(JSONResponse):",
            "    media_type = \"application/json\"",
            "",
            "    @staticmethod",
            "    def _render(content: Any) -> bytes:",
            "        return orjson.dumps(",
            "            content,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "            default=str,",
            "        )",
            "",
            "    def render(self, content: Any) -> bytes:",
            "        return ORJSONResponse._render(content)",
            "",
            "    @staticmethod",
            "    def _render_str(content: Any) -> str:",
            "        return ORJSONResponse._render(content).decode(\"utf-8\")",
            "",
            "",
            "def toorjson(value):",
            "    return markupsafe.Markup(",
            "        ORJSONResponse._render_str(value)",
            "        .replace(\"<\", \"\\\\u003c\")",
            "        .replace(\">\", \"\\\\u003e\")",
            "        .replace(\"&\", \"\\\\u0026\")",
            "        .replace(\"'\", \"\\\\u0027\")",
            "    )",
            "",
            "",
            "templates = Jinja2Templates(directory=STATIC_TEMPLATE_LIB)",
            "templates.env.filters[\"toorjson\"] = toorjson",
            "",
            "client = httpx.AsyncClient()",
            "",
            "file_upload_statuses = FileUploadProgress()",
            "",
            "",
            "class App(FastAPI):",
            "    \"\"\"",
            "    FastAPI App Wrapper",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        self.tokens = {}",
            "        self.auth = None",
            "        self.blocks: gradio.Blocks | None = None",
            "        self.state_holder = StateHolder()",
            "        self.iterators: dict[str, AsyncIterator] = {}",
            "        self.iterators_to_reset: set[str] = set()",
            "        self.lock = utils.safe_get_lock()",
            "        self.cookie_id = secrets.token_urlsafe(32)",
            "        self.queue_token = secrets.token_urlsafe(32)",
            "        self.startup_events_triggered = False",
            "        self.uploaded_file_dir = get_upload_folder()",
            "        self.change_event: None | threading.Event = None",
            "        self._asyncio_tasks: list[asyncio.Task] = []",
            "        # Allow user to manually set `docs_url` and `redoc_url`",
            "        # when instantiating an App; when they're not set, disable docs and redoc.",
            "        kwargs.setdefault(\"docs_url\", None)",
            "        kwargs.setdefault(\"redoc_url\", None)",
            "        super().__init__(**kwargs)",
            "",
            "    def configure_app(self, blocks: gradio.Blocks) -> None:",
            "        auth = blocks.auth",
            "        if auth is not None:",
            "            if not callable(auth):",
            "                self.auth = {account[0]: account[1] for account in auth}",
            "            else:",
            "                self.auth = auth",
            "        else:",
            "            self.auth = None",
            "",
            "        self.blocks = blocks",
            "        self.cwd = os.getcwd()",
            "        self.favicon_path = blocks.favicon_path",
            "        self.tokens = {}",
            "        self.root_path = blocks.root_path",
            "        self.state_holder.set_blocks(blocks)",
            "",
            "    def get_blocks(self) -> gradio.Blocks:",
            "        if self.blocks is None:",
            "            raise ValueError(\"No Blocks has been configured for this app.\")",
            "        return self.blocks",
            "",
            "    def build_proxy_request(self, url_path):",
            "        url = httpx.URL(url_path)",
            "        assert self.blocks  # noqa: S101",
            "        # Don't proxy a URL unless it's a URL specifically loaded by the user using",
            "        # gr.load() to prevent SSRF or harvesting of HF tokens by malicious Spaces.",
            "        is_safe_url = any(",
            "            url.host == httpx.URL(root).host for root in self.blocks.proxy_urls",
            "        )",
            "        if not is_safe_url:",
            "            raise PermissionError(\"This URL cannot be proxied.\")",
            "        is_hf_url = url.host.endswith(\".hf.space\")",
            "        headers = {}",
            "        if Context.hf_token is not None and is_hf_url:",
            "            headers[\"Authorization\"] = f\"Bearer {Context.hf_token}\"",
            "        rp_req = client.build_request(\"GET\", url, headers=headers)",
            "        return rp_req",
            "",
            "    def _cancel_asyncio_tasks(self):",
            "        for task in self._asyncio_tasks:",
            "            task.cancel()",
            "        self._asyncio_tasks = []",
            "",
            "    @staticmethod",
            "    def create_app(",
            "        blocks: gradio.Blocks, app_kwargs: Dict[str, Any] | None = None",
            "    ) -> App:",
            "        app_kwargs = app_kwargs or {}",
            "        app_kwargs.setdefault(\"default_response_class\", ORJSONResponse)",
            "        app = App(**app_kwargs)",
            "        app.configure_app(blocks)",
            "",
            "        if not wasm_utils.IS_WASM:",
            "            app.add_middleware(",
            "                CORSMiddleware,",
            "                allow_origins=[\"*\"],",
            "                allow_methods=[\"*\"],",
            "                allow_headers=[\"*\"],",
            "            )",
            "",
            "        @app.get(\"/user\")",
            "        @app.get(\"/user/\")",
            "        def get_current_user(request: fastapi.Request) -> Optional[str]:",
            "            token = request.cookies.get(",
            "                f\"access-token-{app.cookie_id}\"",
            "            ) or request.cookies.get(f\"access-token-unsecure-{app.cookie_id}\")",
            "            return app.tokens.get(token)",
            "",
            "        @app.get(\"/login_check\")",
            "        @app.get(\"/login_check/\")",
            "        def login_check(user: str = Depends(get_current_user)):",
            "            if app.auth is None or user is not None:",
            "                return",
            "            raise HTTPException(",
            "                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "            )",
            "",
            "        @app.get(\"/token\")",
            "        @app.get(\"/token/\")",
            "        def get_token(request: fastapi.Request) -> dict:",
            "            token = request.cookies.get(f\"access-token-{app.cookie_id}\")",
            "            return {\"token\": token, \"user\": app.tokens.get(token)}",
            "",
            "        @app.get(\"/app_id\")",
            "        @app.get(\"/app_id/\")",
            "        def app_id(request: fastapi.Request) -> dict:  # noqa: ARG001",
            "            return {\"app_id\": app.get_blocks().app_id}",
            "",
            "        @app.get(\"/dev/reload\", dependencies=[Depends(login_check)])",
            "        async def notify_changes(",
            "            request: fastapi.Request,",
            "        ):",
            "            async def reload_checker(request: fastapi.Request):",
            "                heartbeat_rate = 15",
            "                check_rate = 0.05",
            "                last_heartbeat = time.perf_counter()",
            "",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        return",
            "",
            "                    if app.change_event and app.change_event.is_set():",
            "                        app.change_event.clear()",
            "                        yield \"\"\"data: CHANGE\\n\\n\"\"\"",
            "",
            "                    await asyncio.sleep(check_rate)",
            "                    if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                        yield \"\"\"data: HEARTBEAT\\n\\n\"\"\"",
            "                        last_heartbeat = time.time()",
            "",
            "            return StreamingResponse(",
            "                reload_checker(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/login\")",
            "        @app.post(\"/login/\")",
            "        def login(form_data: OAuth2PasswordRequestForm = Depends()):",
            "            username, password = form_data.username.strip(), form_data.password",
            "            if app.auth is None:",
            "                return RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "            if (",
            "                not callable(app.auth)",
            "                and username in app.auth",
            "                and compare_passwords_securely(password, app.auth[username])  # type: ignore",
            "            ) or (callable(app.auth) and app.auth.__call__(username, password)):",
            "                token = secrets.token_urlsafe(16)",
            "                app.tokens[token] = username",
            "                response = JSONResponse(content={\"success\": True})",
            "                response.set_cookie(",
            "                    key=f\"access-token-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                    samesite=\"none\",",
            "                    secure=True,",
            "                )",
            "                response.set_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                )",
            "                return response",
            "            else:",
            "                raise HTTPException(status_code=400, detail=\"Incorrect credentials.\")",
            "",
            "        ###############",
            "        # OAuth Routes",
            "        ###############",
            "",
            "        # Define OAuth routes if the app expects it (i.e. a LoginButton is defined).",
            "        # It allows users to \"Sign in with HuggingFace\".",
            "        if app.blocks is not None and app.blocks.expects_oauth:",
            "            attach_oauth(app)",
            "",
            "        ###############",
            "        # Main Routes",
            "        ###############",
            "",
            "        @app.head(\"/\", response_class=HTMLResponse)",
            "        @app.get(\"/\", response_class=HTMLResponse)",
            "        def main(request: fastapi.Request, user: str = Depends(get_current_user)):",
            "            mimetypes.add_type(\"application/javascript\", \".js\")",
            "            blocks = app.get_blocks()",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/\", root_path=app.root_path",
            "            )",
            "            if app.auth is None or user is not None:",
            "                config = app.get_blocks().config",
            "                config = route_utils.update_root_in_config(config, root)",
            "            else:",
            "                config = {",
            "                    \"auth_required\": True,",
            "                    \"auth_message\": blocks.auth_message,",
            "                    \"space_id\": app.get_blocks().space_id,",
            "                    \"root\": root,",
            "                }",
            "",
            "            try:",
            "                template = (",
            "                    \"frontend/share.html\" if blocks.share else \"frontend/index.html\"",
            "                )",
            "                return templates.TemplateResponse(",
            "                    template,",
            "                    {\"request\": request, \"config\": config},",
            "                )",
            "            except TemplateNotFound as err:",
            "                if blocks.share:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? Share mode only \"",
            "                        \"works when Gradio is installed through the pip package.\"",
            "                    ) from err",
            "                else:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? You need to build \"",
            "                        \"the frontend by running /scripts/build_frontend.sh\"",
            "                    ) from err",
            "",
            "        @app.get(\"/info/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/info\", dependencies=[Depends(login_check)])",
            "        def api_info():",
            "            return app.get_blocks().get_api_info()  # type: ignore",
            "",
            "        @app.get(\"/config/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/config\", dependencies=[Depends(login_check)])",
            "        def get_config(request: fastapi.Request):",
            "            config = app.get_blocks().config",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/config\", root_path=app.root_path",
            "            )",
            "            config = route_utils.update_root_in_config(config, root)",
            "            return ORJSONResponse(content=config)",
            "",
            "        @app.get(\"/static/{path:path}\")",
            "        def static_resource(path: str):",
            "            static_file = safe_join(STATIC_PATH_LIB, path)",
            "            return FileResponse(static_file)",
            "",
            "        @app.get(\"/custom_component/{id}/{type}/{file_name}\")",
            "        def custom_component_path(id: str, type: str, file_name: str):",
            "            config = app.get_blocks().config",
            "            components = config[\"components\"]",
            "            location = next(",
            "                (item for item in components if item[\"component_class_id\"] == id), None",
            "            )",
            "",
            "            if location is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            component_instance = app.get_blocks().get_component(location[\"id\"])",
            "",
            "            module_name = component_instance.__class__.__module__",
            "            module_path = sys.modules[module_name].__file__",
            "",
            "            if module_path is None or component_instance is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            return FileResponse(",
            "                safe_join(",
            "                    str(Path(module_path).parent),",
            "                    f\"{component_instance.__class__.TEMPLATE_DIR}/{type}/{file_name}\",",
            "                )",
            "            )",
            "",
            "        @app.get(\"/assets/{path:path}\")",
            "        def build_resource(path: str):",
            "            build_file = safe_join(BUILD_PATH_LIB, path)",
            "            return FileResponse(build_file)",
            "",
            "        @app.get(\"/favicon.ico\")",
            "        async def favicon():",
            "            blocks = app.get_blocks()",
            "            if blocks.favicon_path is None:",
            "                return static_resource(\"img/logo.svg\")",
            "            else:",
            "                return FileResponse(blocks.favicon_path)",
            "",
            "        @app.head(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        async def reverse_proxy(url_path: str):",
            "            # Adapted from: https://github.com/tiangolo/fastapi/issues/1788",
            "            try:",
            "                rp_req = app.build_proxy_request(url_path)",
            "            except PermissionError as err:",
            "                raise HTTPException(status_code=400, detail=str(err)) from err",
            "            rp_resp = await client.send(rp_req, stream=True)",
            "            return StreamingResponse(",
            "                rp_resp.aiter_raw(),",
            "                status_code=rp_resp.status_code,",
            "                headers=rp_resp.headers,  # type: ignore",
            "                background=BackgroundTask(rp_resp.aclose),",
            "            )",
            "",
            "        @app.head(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        async def file(path_or_url: str, request: fastapi.Request):",
            "            blocks = app.get_blocks()",
            "            if client_utils.is_http_url_like(path_or_url):",
            "                return RedirectResponse(",
            "                    url=path_or_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "",
            "            if route_utils.starts_with_protocol(path_or_url):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            abs_path = utils.abspath(path_or_url)",
            "",
            "            in_blocklist = any(",
            "                utils.is_in_or_equal(abs_path, blocked_path)",
            "                for blocked_path in blocks.blocked_paths",
            "            )",
            "",
            "            is_dir = abs_path.is_dir()",
            "",
            "            if in_blocklist or is_dir:",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            created_by_app = False",
            "            for temp_file_set in blocks.temp_file_sets:",
            "                if abs_path in temp_file_set:",
            "                    created_by_app = True",
            "                    break",
            "            in_allowlist = any(",
            "                utils.is_in_or_equal(abs_path, allowed_path)",
            "                for allowed_path in blocks.allowed_paths",
            "            )",
            "            was_uploaded = utils.is_in_or_equal(abs_path, app.uploaded_file_dir)",
            "            is_cached_example = utils.is_in_or_equal(",
            "                abs_path, utils.abspath(utils.get_cache_folder())",
            "            )",
            "",
            "            if not (",
            "                created_by_app or in_allowlist or was_uploaded or is_cached_example",
            "            ):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            if not abs_path.exists():",
            "                raise HTTPException(404, f\"File not found: {path_or_url}.\")",
            "",
            "            range_val = request.headers.get(\"Range\", \"\").strip()",
            "            if range_val.startswith(\"bytes=\") and \"-\" in range_val:",
            "                range_val = range_val[6:]",
            "                start, end = range_val.split(\"-\")",
            "                if start.isnumeric() and end.isnumeric():",
            "                    start = int(start)",
            "                    end = int(end)",
            "                    response = ranged_response.RangedFileResponse(",
            "                        abs_path,",
            "                        ranged_response.OpenRange(start, end),",
            "                        dict(request.headers),",
            "                        stat_result=os.stat(abs_path),",
            "                    )",
            "                    return response",
            "",
            "            return FileResponse(abs_path, headers={\"Accept-Ranges\": \"bytes\"})",
            "",
            "        @app.get(",
            "            \"/stream/{session_hash}/{run}/{component_id}\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def stream(",
            "            session_hash: str,",
            "            run: int,",
            "            component_id: int,",
            "            request: fastapi.Request,  # noqa: ARG001",
            "        ):",
            "            stream: list = (",
            "                app.get_blocks()",
            "                .pending_streams[session_hash]",
            "                .get(run, {})",
            "                .get(component_id, None)",
            "            )",
            "            if stream is None:",
            "                raise HTTPException(404, \"Stream not found.\")",
            "",
            "            def stream_wrapper():",
            "                check_stream_rate = 0.01",
            "                max_wait_time = 120  # maximum wait between yields - assume generator thread has crashed otherwise.",
            "                wait_time = 0",
            "                while True:",
            "                    if len(stream) == 0:",
            "                        if wait_time > max_wait_time:",
            "                            return",
            "                        wait_time += check_stream_rate",
            "                        time.sleep(check_stream_rate)",
            "                        continue",
            "                    wait_time = 0",
            "                    next_stream = stream.pop(0)",
            "                    if next_stream is None:",
            "                        return",
            "                    yield next_stream",
            "",
            "            return StreamingResponse(stream_wrapper())",
            "",
            "        @app.get(\"/file/{path:path}\", dependencies=[Depends(login_check)])",
            "        async def file_deprecated(path: str, request: fastapi.Request):",
            "            return await file(path, request)",
            "",
            "        @app.post(\"/reset/\")",
            "        @app.post(\"/reset\")",
            "        async def reset_iterator(body: ResetBody):",
            "            if body.event_id not in app.iterators:",
            "                return {\"success\": False}",
            "            async with app.lock:",
            "                del app.iterators[body.event_id]",
            "                app.iterators_to_reset.add(body.event_id)",
            "                await app.get_blocks()._queue.clean_events(event_id=body.event_id)",
            "            return {\"success\": True}",
            "",
            "        # had to use '/run' endpoint for Colab compatibility, '/api' supported for backwards compatibility",
            "        @app.post(\"/run/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/run/{api_name}/\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def predict(",
            "            api_name: str,",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            fn_index_inferred = route_utils.infer_fn_index(",
            "                app=app, api_name=api_name, body=body",
            "            )",
            "",
            "            if not app.get_blocks().api_open and app.get_blocks().queue_enabled_for_fn(",
            "                fn_index_inferred",
            "            ):",
            "                raise HTTPException(",
            "                    detail=\"This API endpoint does not accept direct HTTP POST requests. Please join the queue to use this API.\",",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                )",
            "",
            "            gr_request = route_utils.compile_gr_request(",
            "                app,",
            "                body,",
            "                fn_index_inferred=fn_index_inferred,",
            "                username=username,",
            "                request=request,",
            "            )",
            "",
            "            try:",
            "                output = await route_utils.call_process_api(",
            "                    app=app,",
            "                    body=body,",
            "                    gr_request=gr_request,",
            "                    fn_index_inferred=fn_index_inferred,",
            "                )",
            "            except BaseException as error:",
            "                show_error = app.get_blocks().show_error or isinstance(error, Error)",
            "                traceback.print_exc()",
            "                return JSONResponse(",
            "                    content={\"error\": str(error) if show_error else None},",
            "                    status_code=500,",
            "                )",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=f\"/api/{api_name}\", root_path=app.root_path",
            "            )",
            "            output = add_root_url(output, root_path, None)",
            "            return output",
            "",
            "        @app.get(\"/queue/data\", dependencies=[Depends(login_check)])",
            "        async def queue_data(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "        ):",
            "            blocks = app.get_blocks()",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=\"/queue/data\", root_path=app.root_path",
            "            )",
            "",
            "            async def sse_stream(request: fastapi.Request):",
            "                try:",
            "                    last_heartbeat = time.perf_counter()",
            "                    while True:",
            "                        if await request.is_disconnected():",
            "                            await blocks._queue.clean_events(session_hash=session_hash)",
            "                            return",
            "",
            "                        if (",
            "                            session_hash",
            "                            not in blocks._queue.pending_messages_per_session",
            "                        ):",
            "                            raise HTTPException(",
            "                                status_code=status.HTTP_404_NOT_FOUND,",
            "                                detail=\"Session not found.\",",
            "                            )",
            "",
            "                        heartbeat_rate = 15",
            "                        check_rate = 0.05",
            "                        message = None",
            "                        try:",
            "                            messages = blocks._queue.pending_messages_per_session[",
            "                                session_hash",
            "                            ]",
            "                            message = messages.get_nowait()",
            "                        except EmptyQueue:",
            "                            await asyncio.sleep(check_rate)",
            "                            if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                                # Fix this",
            "                                message = {",
            "                                    \"msg\": ServerMessage.heartbeat,",
            "                                }",
            "                                # Need to reset last_heartbeat with perf_counter",
            "                                # otherwise only a single hearbeat msg will be sent",
            "                                # and then the stream will retry leading to infinite queue \ud83d\ude2c",
            "                                last_heartbeat = time.perf_counter()",
            "",
            "                        if blocks._queue.stopped:",
            "                            message = {",
            "                                \"msg\": \"unexpected_error\",",
            "                                \"message\": \"Server stopped unexpectedly.\",",
            "                                \"success\": False,",
            "                            }",
            "                        if message:",
            "                            add_root_url(message, root_path, None)",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            if message[\"msg\"] == ServerMessage.process_completed:",
            "                                blocks._queue.pending_event_ids_session[",
            "                                    session_hash",
            "                                ].remove(message[\"event_id\"])",
            "                                if message[\"msg\"] == ServerMessage.server_stopped or (",
            "                                    message[\"msg\"] == ServerMessage.process_completed",
            "                                    and (",
            "                                        len(",
            "                                            blocks._queue.pending_event_ids_session[",
            "                                                session_hash",
            "                                            ]",
            "                                        )",
            "                                        == 0",
            "                                    )",
            "                                ):",
            "                                    return",
            "                except BaseException as e:",
            "                    message = {",
            "                        \"msg\": \"unexpected_error\",",
            "                        \"success\": False,",
            "                        \"message\": str(e),",
            "                    }",
            "                    yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    if isinstance(e, asyncio.CancelledError):",
            "                        del blocks._queue.pending_messages_per_session[session_hash]",
            "                        await blocks._queue.clean_events(session_hash=session_hash)",
            "                    raise e",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/queue/join\", dependencies=[Depends(login_check)])",
            "        async def queue_join(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            if blocks._queue.server_app is None:",
            "                blocks._queue.set_server_app(app)",
            "",
            "            if blocks._queue.stopped:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,",
            "                    detail=\"Queue is stopped.\",",
            "                )",
            "",
            "            success, event_id = await blocks._queue.push(body, request, username)",
            "            if not success:",
            "                status_code = (",
            "                    status.HTTP_503_SERVICE_UNAVAILABLE",
            "                    if \"Queue is full.\" in event_id",
            "                    else status.HTTP_400_BAD_REQUEST",
            "                )",
            "                raise HTTPException(status_code=status_code, detail=event_id)",
            "            return {\"event_id\": event_id}",
            "",
            "        @app.post(\"/component_server\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/component_server/\", dependencies=[Depends(login_check)])",
            "        def component_server(body: ComponentServerBody):",
            "            state = app.state_holder[body.session_hash]",
            "            component_id = body.component_id",
            "            block: Block",
            "            if component_id in state:",
            "                block = state[component_id]",
            "            else:",
            "                block = app.get_blocks().blocks[component_id]",
            "            fn = getattr(block, body.fn_name, None)",
            "            if fn is None or not getattr(fn, \"_is_server_fn\", False):",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                    detail=\"Function not found.\",",
            "                )",
            "            return fn(body.data)",
            "",
            "        @app.get(",
            "            \"/queue/status\",",
            "            dependencies=[Depends(login_check)],",
            "            response_model=Estimation,",
            "        )",
            "        async def get_queue_status():",
            "            return app.get_blocks()._queue.get_status()",
            "",
            "        @app.get(\"/upload_progress\")",
            "        def get_upload_progress(upload_id: str, request: fastapi.Request):",
            "            async def sse_stream(request: fastapi.Request):",
            "                last_heartbeat = time.perf_counter()",
            "                is_done = False",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "                    if is_done:",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "",
            "                    heartbeat_rate = 15",
            "                    check_rate = 0.05",
            "                    try:",
            "                        if file_upload_statuses.is_done(upload_id):",
            "                            message = {\"msg\": \"done\"}",
            "                            is_done = True",
            "                        else:",
            "                            update = file_upload_statuses.pop(upload_id)",
            "                            message = {",
            "                                \"msg\": \"update\",",
            "                                \"orig_name\": update.filename,",
            "                                \"chunk_size\": update.chunk_size,",
            "                            }",
            "                        yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    except FileUploadProgressNotTrackedError:",
            "                        return",
            "                    except FileUploadProgressNotQueuedError:",
            "                        await asyncio.sleep(check_rate)",
            "                        if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                            message = {\"msg\": \"heartbeat\"}",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            last_heartbeat = time.perf_counter()",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/upload\", dependencies=[Depends(login_check)])",
            "        async def upload_file(",
            "            request: fastapi.Request,",
            "            bg_tasks: BackgroundTasks,",
            "            upload_id: Optional[str] = None,",
            "        ):",
            "            content_type_header = request.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header or \"\")",
            "            if content_type != b\"multipart/form-data\":",
            "                raise HTTPException(status_code=400, detail=\"Invalid content type.\")",
            "",
            "            try:",
            "                if upload_id:",
            "                    file_upload_statuses.track(upload_id)",
            "                multipart_parser = GradioMultiPartParser(",
            "                    request.headers,",
            "                    request.stream(),",
            "                    max_files=1000,",
            "                    max_fields=1000,",
            "                    upload_id=upload_id if upload_id else None,",
            "                    upload_progress=file_upload_statuses if upload_id else None,",
            "                )",
            "                form = await multipart_parser.parse()",
            "            except MultiPartException as exc:",
            "                raise HTTPException(status_code=400, detail=exc.message) from exc",
            "",
            "            output_files = []",
            "            files_to_copy = []",
            "            locations: list[str] = []",
            "            for temp_file in form.getlist(\"files\"):",
            "                if not isinstance(temp_file, GradioUploadFile):",
            "                    raise TypeError(\"File is not an instance of GradioUploadFile\")",
            "                if temp_file.filename:",
            "                    file_name = Path(temp_file.filename).name",
            "                    name = client_utils.strip_invalid_filename_characters(file_name)",
            "                else:",
            "                    name = f\"tmp{secrets.token_hex(5)}\"",
            "                directory = Path(app.uploaded_file_dir) / temp_file.sha.hexdigest()",
            "                directory.mkdir(exist_ok=True, parents=True)",
            "                dest = (directory / name).resolve()",
            "                temp_file.file.close()",
            "                # we need to move the temp file to the cache directory",
            "                # but that's possibly blocking and we're in an async function",
            "                # so we try to rename (this is what shutil.move tries first)",
            "                # which should be super fast.",
            "                # if that fails, we move in the background.",
            "                try:",
            "                    os.rename(temp_file.file.name, dest)",
            "                except OSError:",
            "                    files_to_copy.append(temp_file.file.name)",
            "                    locations.append(str(dest))",
            "                output_files.append(dest)",
            "            if files_to_copy:",
            "                bg_tasks.add_task(",
            "                    move_uploaded_files_to_cache, files_to_copy, locations",
            "                )",
            "            return output_files",
            "",
            "        @app.on_event(\"startup\")",
            "        @app.get(\"/startup-events\")",
            "        async def startup_events():",
            "            if not app.startup_events_triggered:",
            "                app.get_blocks().startup_events()",
            "                app.startup_events_triggered = True",
            "                return True",
            "            return False",
            "",
            "        @app.get(\"/theme.css\", response_class=PlainTextResponse)",
            "        def theme_css():",
            "            return PlainTextResponse(app.get_blocks().theme_css, media_type=\"text/css\")",
            "",
            "        @app.get(\"/robots.txt\", response_class=PlainTextResponse)",
            "        def robots_txt():",
            "            if app.get_blocks().share:",
            "                return \"User-agent: *\\nDisallow: /\"",
            "            else:",
            "                return \"User-agent: *\\nDisallow: \"",
            "",
            "        return app",
            "",
            "",
            "########",
            "# Helper functions",
            "########",
            "",
            "",
            "def safe_join(directory: str, path: str) -> str:",
            "    \"\"\"Safely path to a base directory to avoid escaping the base directory.",
            "    Borrowed from: werkzeug.security.safe_join\"\"\"",
            "    _os_alt_seps: List[str] = [",
            "        sep for sep in [os.path.sep, os.path.altsep] if sep is not None and sep != \"/\"",
            "    ]",
            "",
            "    if path == \"\":",
            "        raise HTTPException(400)",
            "",
            "    filename = posixpath.normpath(path)",
            "    fullpath = os.path.join(directory, filename)",
            "    if (",
            "        any(sep in filename for sep in _os_alt_seps)",
            "        or os.path.isabs(filename)",
            "        or filename == \"..\"",
            "        or filename.startswith(\"../\")",
            "        or os.path.isdir(fullpath)",
            "    ):",
            "        raise HTTPException(403)",
            "",
            "    if not os.path.exists(fullpath):",
            "        raise HTTPException(404, \"File not found\")",
            "",
            "    return fullpath",
            "",
            "",
            "def get_types(cls_set: List[Type]):",
            "    docset = []",
            "    types = []",
            "    for cls in cls_set:",
            "        doc = inspect.getdoc(cls) or \"\"",
            "        doc_lines = doc.split(\"\\n\")",
            "        for line in doc_lines:",
            "            if \"value (\" in line:",
            "                types.append(line.split(\"value (\")[1].split(\")\")[0])",
            "        docset.append(doc_lines[1].split(\":\")[-1])",
            "    return docset, types",
            "",
            "",
            "@document()",
            "def mount_gradio_app(",
            "    app: fastapi.FastAPI,",
            "    blocks: gradio.Blocks,",
            "    path: str,",
            "    app_kwargs: dict[str, Any] | None = None,",
            ") -> fastapi.FastAPI:",
            "    \"\"\"Mount a gradio.Blocks to an existing FastAPI application.",
            "",
            "    Parameters:",
            "        app: The parent FastAPI application.",
            "        blocks: The blocks object we want to mount to the parent app.",
            "        path: The path at which the gradio application will be mounted.",
            "        app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "    Example:",
            "        from fastapi import FastAPI",
            "        import gradio as gr",
            "        app = FastAPI()",
            "        @app.get(\"/\")",
            "        def read_main():",
            "            return {\"message\": \"This is your main app\"}",
            "        io = gr.Interface(lambda x: \"Hello, \" + x + \"!\", \"textbox\", \"textbox\")",
            "        app = gr.mount_gradio_app(app, io, path=\"/gradio\")",
            "        # Then run `uvicorn run:app` from the terminal and navigate to http://localhost:8000/gradio.",
            "    \"\"\"",
            "    blocks.dev_mode = False",
            "    blocks.config = blocks.get_config_file()",
            "    blocks.validate_queue_settings()",
            "    gradio_app = App.create_app(blocks, app_kwargs=app_kwargs)",
            "",
            "    old_lifespan = app.router.lifespan_context",
            "",
            "    @contextlib.asynccontextmanager",
            "    async def new_lifespan(app: FastAPI):",
            "        async with old_lifespan(",
            "            app",
            "        ):  # Instert the startup events inside the FastAPI context manager",
            "            gradio_app.get_blocks().startup_events()",
            "            yield",
            "",
            "    app.router.lifespan_context = new_lifespan",
            "",
            "    app.mount(path, gradio_app)",
            "    return app"
        ],
        "afterPatchFile": [
            "\"\"\"Implements a FastAPI server to run the gradio interface. Note that some types in this",
            "module use the Optional/Union notation so that they work correctly with pydantic.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import contextlib",
            "import sys",
            "",
            "if sys.version_info >= (3, 9):",
            "    from importlib.resources import files",
            "else:",
            "    from importlib_resources import files",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import posixpath",
            "import secrets",
            "import threading",
            "import time",
            "import traceback",
            "from pathlib import Path",
            "from queue import Empty as EmptyQueue",
            "from typing import TYPE_CHECKING, Any, AsyncIterator, Dict, List, Optional, Type",
            "",
            "import fastapi",
            "import httpx",
            "import markupsafe",
            "import orjson",
            "from fastapi import BackgroundTasks, Depends, FastAPI, HTTPException, status",
            "from fastapi.responses import (",
            "    FileResponse,",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            ")",
            "from fastapi.security import OAuth2PasswordRequestForm",
            "from fastapi.templating import Jinja2Templates",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import ServerMessage",
            "from jinja2.exceptions import TemplateNotFound",
            "from multipart.multipart import parse_options_header",
            "from starlette.background import BackgroundTask",
            "from starlette.responses import RedirectResponse, StreamingResponse",
            "",
            "import gradio",
            "from gradio import ranged_response, route_utils, utils, wasm_utils",
            "from gradio.context import Context",
            "from gradio.data_classes import ComponentServerBody, PredictBody, ResetBody",
            "from gradio.exceptions import Error",
            "from gradio.oauth import attach_oauth",
            "from gradio.processing_utils import add_root_url",
            "from gradio.queueing import Estimation",
            "from gradio.route_utils import (  # noqa: F401",
            "    CustomCORSMiddleware,",
            "    FileUploadProgress,",
            "    FileUploadProgressNotQueuedError,",
            "    FileUploadProgressNotTrackedError,",
            "    GradioMultiPartParser,",
            "    GradioUploadFile,",
            "    MultiPartException,",
            "    Request,",
            "    compare_passwords_securely,",
            "    move_uploaded_files_to_cache,",
            ")",
            "from gradio.state_holder import StateHolder",
            "from gradio.utils import get_package_version, get_upload_folder",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "mimetypes.init()",
            "",
            "STATIC_TEMPLATE_LIB = files(\"gradio\").joinpath(\"templates\").as_posix()  # type: ignore",
            "STATIC_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix()  # type: ignore",
            "BUILD_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix()  # type: ignore",
            "VERSION = get_package_version()",
            "",
            "",
            "class ORJSONResponse(JSONResponse):",
            "    media_type = \"application/json\"",
            "",
            "    @staticmethod",
            "    def _render(content: Any) -> bytes:",
            "        return orjson.dumps(",
            "            content,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "            default=str,",
            "        )",
            "",
            "    def render(self, content: Any) -> bytes:",
            "        return ORJSONResponse._render(content)",
            "",
            "    @staticmethod",
            "    def _render_str(content: Any) -> str:",
            "        return ORJSONResponse._render(content).decode(\"utf-8\")",
            "",
            "",
            "def toorjson(value):",
            "    return markupsafe.Markup(",
            "        ORJSONResponse._render_str(value)",
            "        .replace(\"<\", \"\\\\u003c\")",
            "        .replace(\">\", \"\\\\u003e\")",
            "        .replace(\"&\", \"\\\\u0026\")",
            "        .replace(\"'\", \"\\\\u0027\")",
            "    )",
            "",
            "",
            "templates = Jinja2Templates(directory=STATIC_TEMPLATE_LIB)",
            "templates.env.filters[\"toorjson\"] = toorjson",
            "",
            "client = httpx.AsyncClient()",
            "",
            "file_upload_statuses = FileUploadProgress()",
            "",
            "",
            "class App(FastAPI):",
            "    \"\"\"",
            "    FastAPI App Wrapper",
            "    \"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        self.tokens = {}",
            "        self.auth = None",
            "        self.blocks: gradio.Blocks | None = None",
            "        self.state_holder = StateHolder()",
            "        self.iterators: dict[str, AsyncIterator] = {}",
            "        self.iterators_to_reset: set[str] = set()",
            "        self.lock = utils.safe_get_lock()",
            "        self.cookie_id = secrets.token_urlsafe(32)",
            "        self.queue_token = secrets.token_urlsafe(32)",
            "        self.startup_events_triggered = False",
            "        self.uploaded_file_dir = get_upload_folder()",
            "        self.change_event: None | threading.Event = None",
            "        self._asyncio_tasks: list[asyncio.Task] = []",
            "        # Allow user to manually set `docs_url` and `redoc_url`",
            "        # when instantiating an App; when they're not set, disable docs and redoc.",
            "        kwargs.setdefault(\"docs_url\", None)",
            "        kwargs.setdefault(\"redoc_url\", None)",
            "        super().__init__(**kwargs)",
            "",
            "    def configure_app(self, blocks: gradio.Blocks) -> None:",
            "        auth = blocks.auth",
            "        if auth is not None:",
            "            if not callable(auth):",
            "                self.auth = {account[0]: account[1] for account in auth}",
            "            else:",
            "                self.auth = auth",
            "        else:",
            "            self.auth = None",
            "",
            "        self.blocks = blocks",
            "        self.cwd = os.getcwd()",
            "        self.favicon_path = blocks.favicon_path",
            "        self.tokens = {}",
            "        self.root_path = blocks.root_path",
            "        self.state_holder.set_blocks(blocks)",
            "",
            "    def get_blocks(self) -> gradio.Blocks:",
            "        if self.blocks is None:",
            "            raise ValueError(\"No Blocks has been configured for this app.\")",
            "        return self.blocks",
            "",
            "    def build_proxy_request(self, url_path):",
            "        url = httpx.URL(url_path)",
            "        assert self.blocks  # noqa: S101",
            "        # Don't proxy a URL unless it's a URL specifically loaded by the user using",
            "        # gr.load() to prevent SSRF or harvesting of HF tokens by malicious Spaces.",
            "        is_safe_url = any(",
            "            url.host == httpx.URL(root).host for root in self.blocks.proxy_urls",
            "        )",
            "        if not is_safe_url:",
            "            raise PermissionError(\"This URL cannot be proxied.\")",
            "        is_hf_url = url.host.endswith(\".hf.space\")",
            "        headers = {}",
            "        if Context.hf_token is not None and is_hf_url:",
            "            headers[\"Authorization\"] = f\"Bearer {Context.hf_token}\"",
            "        rp_req = client.build_request(\"GET\", url, headers=headers)",
            "        return rp_req",
            "",
            "    def _cancel_asyncio_tasks(self):",
            "        for task in self._asyncio_tasks:",
            "            task.cancel()",
            "        self._asyncio_tasks = []",
            "",
            "    @staticmethod",
            "    def create_app(",
            "        blocks: gradio.Blocks, app_kwargs: Dict[str, Any] | None = None",
            "    ) -> App:",
            "        app_kwargs = app_kwargs or {}",
            "        app_kwargs.setdefault(\"default_response_class\", ORJSONResponse)",
            "        app = App(**app_kwargs)",
            "        app.configure_app(blocks)",
            "",
            "        if not wasm_utils.IS_WASM:",
            "            app.add_middleware(CustomCORSMiddleware)",
            "",
            "        @app.get(\"/user\")",
            "        @app.get(\"/user/\")",
            "        def get_current_user(request: fastapi.Request) -> Optional[str]:",
            "            token = request.cookies.get(",
            "                f\"access-token-{app.cookie_id}\"",
            "            ) or request.cookies.get(f\"access-token-unsecure-{app.cookie_id}\")",
            "            return app.tokens.get(token)",
            "",
            "        @app.get(\"/login_check\")",
            "        @app.get(\"/login_check/\")",
            "        def login_check(user: str = Depends(get_current_user)):",
            "            if app.auth is None or user is not None:",
            "                return",
            "            raise HTTPException(",
            "                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "            )",
            "",
            "        @app.get(\"/token\")",
            "        @app.get(\"/token/\")",
            "        def get_token(request: fastapi.Request) -> dict:",
            "            token = request.cookies.get(f\"access-token-{app.cookie_id}\")",
            "            return {\"token\": token, \"user\": app.tokens.get(token)}",
            "",
            "        @app.get(\"/app_id\")",
            "        @app.get(\"/app_id/\")",
            "        def app_id(request: fastapi.Request) -> dict:  # noqa: ARG001",
            "            return {\"app_id\": app.get_blocks().app_id}",
            "",
            "        @app.get(\"/dev/reload\", dependencies=[Depends(login_check)])",
            "        async def notify_changes(",
            "            request: fastapi.Request,",
            "        ):",
            "            async def reload_checker(request: fastapi.Request):",
            "                heartbeat_rate = 15",
            "                check_rate = 0.05",
            "                last_heartbeat = time.perf_counter()",
            "",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        return",
            "",
            "                    if app.change_event and app.change_event.is_set():",
            "                        app.change_event.clear()",
            "                        yield \"\"\"data: CHANGE\\n\\n\"\"\"",
            "",
            "                    await asyncio.sleep(check_rate)",
            "                    if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                        yield \"\"\"data: HEARTBEAT\\n\\n\"\"\"",
            "                        last_heartbeat = time.time()",
            "",
            "            return StreamingResponse(",
            "                reload_checker(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/login\")",
            "        @app.post(\"/login/\")",
            "        def login(form_data: OAuth2PasswordRequestForm = Depends()):",
            "            username, password = form_data.username.strip(), form_data.password",
            "            if app.auth is None:",
            "                return RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "            if (",
            "                not callable(app.auth)",
            "                and username in app.auth",
            "                and compare_passwords_securely(password, app.auth[username])  # type: ignore",
            "            ) or (callable(app.auth) and app.auth.__call__(username, password)):",
            "                token = secrets.token_urlsafe(16)",
            "                app.tokens[token] = username",
            "                response = JSONResponse(content={\"success\": True})",
            "                response.set_cookie(",
            "                    key=f\"access-token-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                    samesite=\"none\",",
            "                    secure=True,",
            "                )",
            "                response.set_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                )",
            "                return response",
            "            else:",
            "                raise HTTPException(status_code=400, detail=\"Incorrect credentials.\")",
            "",
            "        ###############",
            "        # OAuth Routes",
            "        ###############",
            "",
            "        # Define OAuth routes if the app expects it (i.e. a LoginButton is defined).",
            "        # It allows users to \"Sign in with HuggingFace\".",
            "        if app.blocks is not None and app.blocks.expects_oauth:",
            "            attach_oauth(app)",
            "",
            "        ###############",
            "        # Main Routes",
            "        ###############",
            "",
            "        @app.head(\"/\", response_class=HTMLResponse)",
            "        @app.get(\"/\", response_class=HTMLResponse)",
            "        def main(request: fastapi.Request, user: str = Depends(get_current_user)):",
            "            mimetypes.add_type(\"application/javascript\", \".js\")",
            "            blocks = app.get_blocks()",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/\", root_path=app.root_path",
            "            )",
            "            if app.auth is None or user is not None:",
            "                config = app.get_blocks().config",
            "                config = route_utils.update_root_in_config(config, root)",
            "            else:",
            "                config = {",
            "                    \"auth_required\": True,",
            "                    \"auth_message\": blocks.auth_message,",
            "                    \"space_id\": app.get_blocks().space_id,",
            "                    \"root\": root,",
            "                }",
            "",
            "            try:",
            "                template = (",
            "                    \"frontend/share.html\" if blocks.share else \"frontend/index.html\"",
            "                )",
            "                return templates.TemplateResponse(",
            "                    template,",
            "                    {\"request\": request, \"config\": config},",
            "                )",
            "            except TemplateNotFound as err:",
            "                if blocks.share:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? Share mode only \"",
            "                        \"works when Gradio is installed through the pip package.\"",
            "                    ) from err",
            "                else:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? You need to build \"",
            "                        \"the frontend by running /scripts/build_frontend.sh\"",
            "                    ) from err",
            "",
            "        @app.get(\"/info/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/info\", dependencies=[Depends(login_check)])",
            "        def api_info():",
            "            return app.get_blocks().get_api_info()  # type: ignore",
            "",
            "        @app.get(\"/config/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/config\", dependencies=[Depends(login_check)])",
            "        def get_config(request: fastapi.Request):",
            "            config = app.get_blocks().config",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/config\", root_path=app.root_path",
            "            )",
            "            config = route_utils.update_root_in_config(config, root)",
            "            return ORJSONResponse(content=config)",
            "",
            "        @app.get(\"/static/{path:path}\")",
            "        def static_resource(path: str):",
            "            static_file = safe_join(STATIC_PATH_LIB, path)",
            "            return FileResponse(static_file)",
            "",
            "        @app.get(\"/custom_component/{id}/{type}/{file_name}\")",
            "        def custom_component_path(id: str, type: str, file_name: str):",
            "            config = app.get_blocks().config",
            "            components = config[\"components\"]",
            "            location = next(",
            "                (item for item in components if item[\"component_class_id\"] == id), None",
            "            )",
            "",
            "            if location is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            component_instance = app.get_blocks().get_component(location[\"id\"])",
            "",
            "            module_name = component_instance.__class__.__module__",
            "            module_path = sys.modules[module_name].__file__",
            "",
            "            if module_path is None or component_instance is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            return FileResponse(",
            "                safe_join(",
            "                    str(Path(module_path).parent),",
            "                    f\"{component_instance.__class__.TEMPLATE_DIR}/{type}/{file_name}\",",
            "                )",
            "            )",
            "",
            "        @app.get(\"/assets/{path:path}\")",
            "        def build_resource(path: str):",
            "            build_file = safe_join(BUILD_PATH_LIB, path)",
            "            return FileResponse(build_file)",
            "",
            "        @app.get(\"/favicon.ico\")",
            "        async def favicon():",
            "            blocks = app.get_blocks()",
            "            if blocks.favicon_path is None:",
            "                return static_resource(\"img/logo.svg\")",
            "            else:",
            "                return FileResponse(blocks.favicon_path)",
            "",
            "        @app.head(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        async def reverse_proxy(url_path: str):",
            "            # Adapted from: https://github.com/tiangolo/fastapi/issues/1788",
            "            try:",
            "                rp_req = app.build_proxy_request(url_path)",
            "            except PermissionError as err:",
            "                raise HTTPException(status_code=400, detail=str(err)) from err",
            "            rp_resp = await client.send(rp_req, stream=True)",
            "            return StreamingResponse(",
            "                rp_resp.aiter_raw(),",
            "                status_code=rp_resp.status_code,",
            "                headers=rp_resp.headers,  # type: ignore",
            "                background=BackgroundTask(rp_resp.aclose),",
            "            )",
            "",
            "        @app.head(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        async def file(path_or_url: str, request: fastapi.Request):",
            "            blocks = app.get_blocks()",
            "            if client_utils.is_http_url_like(path_or_url):",
            "                return RedirectResponse(",
            "                    url=path_or_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "",
            "            if route_utils.starts_with_protocol(path_or_url):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            abs_path = utils.abspath(path_or_url)",
            "",
            "            in_blocklist = any(",
            "                utils.is_in_or_equal(abs_path, blocked_path)",
            "                for blocked_path in blocks.blocked_paths",
            "            )",
            "",
            "            is_dir = abs_path.is_dir()",
            "",
            "            if in_blocklist or is_dir:",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            created_by_app = False",
            "            for temp_file_set in blocks.temp_file_sets:",
            "                if abs_path in temp_file_set:",
            "                    created_by_app = True",
            "                    break",
            "            in_allowlist = any(",
            "                utils.is_in_or_equal(abs_path, allowed_path)",
            "                for allowed_path in blocks.allowed_paths",
            "            )",
            "            was_uploaded = utils.is_in_or_equal(abs_path, app.uploaded_file_dir)",
            "            is_cached_example = utils.is_in_or_equal(",
            "                abs_path, utils.abspath(utils.get_cache_folder())",
            "            )",
            "",
            "            if not (",
            "                created_by_app or in_allowlist or was_uploaded or is_cached_example",
            "            ):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            if not abs_path.exists():",
            "                raise HTTPException(404, f\"File not found: {path_or_url}.\")",
            "",
            "            range_val = request.headers.get(\"Range\", \"\").strip()",
            "            if range_val.startswith(\"bytes=\") and \"-\" in range_val:",
            "                range_val = range_val[6:]",
            "                start, end = range_val.split(\"-\")",
            "                if start.isnumeric() and end.isnumeric():",
            "                    start = int(start)",
            "                    end = int(end)",
            "                    response = ranged_response.RangedFileResponse(",
            "                        abs_path,",
            "                        ranged_response.OpenRange(start, end),",
            "                        dict(request.headers),",
            "                        stat_result=os.stat(abs_path),",
            "                    )",
            "                    return response",
            "",
            "            return FileResponse(abs_path, headers={\"Accept-Ranges\": \"bytes\"})",
            "",
            "        @app.get(",
            "            \"/stream/{session_hash}/{run}/{component_id}\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def stream(",
            "            session_hash: str,",
            "            run: int,",
            "            component_id: int,",
            "            request: fastapi.Request,  # noqa: ARG001",
            "        ):",
            "            stream: list = (",
            "                app.get_blocks()",
            "                .pending_streams[session_hash]",
            "                .get(run, {})",
            "                .get(component_id, None)",
            "            )",
            "            if stream is None:",
            "                raise HTTPException(404, \"Stream not found.\")",
            "",
            "            def stream_wrapper():",
            "                check_stream_rate = 0.01",
            "                max_wait_time = 120  # maximum wait between yields - assume generator thread has crashed otherwise.",
            "                wait_time = 0",
            "                while True:",
            "                    if len(stream) == 0:",
            "                        if wait_time > max_wait_time:",
            "                            return",
            "                        wait_time += check_stream_rate",
            "                        time.sleep(check_stream_rate)",
            "                        continue",
            "                    wait_time = 0",
            "                    next_stream = stream.pop(0)",
            "                    if next_stream is None:",
            "                        return",
            "                    yield next_stream",
            "",
            "            return StreamingResponse(stream_wrapper())",
            "",
            "        @app.get(\"/file/{path:path}\", dependencies=[Depends(login_check)])",
            "        async def file_deprecated(path: str, request: fastapi.Request):",
            "            return await file(path, request)",
            "",
            "        @app.post(\"/reset/\")",
            "        @app.post(\"/reset\")",
            "        async def reset_iterator(body: ResetBody):",
            "            if body.event_id not in app.iterators:",
            "                return {\"success\": False}",
            "            async with app.lock:",
            "                del app.iterators[body.event_id]",
            "                app.iterators_to_reset.add(body.event_id)",
            "                await app.get_blocks()._queue.clean_events(event_id=body.event_id)",
            "            return {\"success\": True}",
            "",
            "        # had to use '/run' endpoint for Colab compatibility, '/api' supported for backwards compatibility",
            "        @app.post(\"/run/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/run/{api_name}/\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def predict(",
            "            api_name: str,",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            fn_index_inferred = route_utils.infer_fn_index(",
            "                app=app, api_name=api_name, body=body",
            "            )",
            "",
            "            if not app.get_blocks().api_open and app.get_blocks().queue_enabled_for_fn(",
            "                fn_index_inferred",
            "            ):",
            "                raise HTTPException(",
            "                    detail=\"This API endpoint does not accept direct HTTP POST requests. Please join the queue to use this API.\",",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                )",
            "",
            "            gr_request = route_utils.compile_gr_request(",
            "                app,",
            "                body,",
            "                fn_index_inferred=fn_index_inferred,",
            "                username=username,",
            "                request=request,",
            "            )",
            "",
            "            try:",
            "                output = await route_utils.call_process_api(",
            "                    app=app,",
            "                    body=body,",
            "                    gr_request=gr_request,",
            "                    fn_index_inferred=fn_index_inferred,",
            "                )",
            "            except BaseException as error:",
            "                show_error = app.get_blocks().show_error or isinstance(error, Error)",
            "                traceback.print_exc()",
            "                return JSONResponse(",
            "                    content={\"error\": str(error) if show_error else None},",
            "                    status_code=500,",
            "                )",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=f\"/api/{api_name}\", root_path=app.root_path",
            "            )",
            "            output = add_root_url(output, root_path, None)",
            "            return output",
            "",
            "        @app.get(\"/queue/data\", dependencies=[Depends(login_check)])",
            "        async def queue_data(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "        ):",
            "            blocks = app.get_blocks()",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=\"/queue/data\", root_path=app.root_path",
            "            )",
            "",
            "            async def sse_stream(request: fastapi.Request):",
            "                try:",
            "                    last_heartbeat = time.perf_counter()",
            "                    while True:",
            "                        if await request.is_disconnected():",
            "                            await blocks._queue.clean_events(session_hash=session_hash)",
            "                            return",
            "",
            "                        if (",
            "                            session_hash",
            "                            not in blocks._queue.pending_messages_per_session",
            "                        ):",
            "                            raise HTTPException(",
            "                                status_code=status.HTTP_404_NOT_FOUND,",
            "                                detail=\"Session not found.\",",
            "                            )",
            "",
            "                        heartbeat_rate = 15",
            "                        check_rate = 0.05",
            "                        message = None",
            "                        try:",
            "                            messages = blocks._queue.pending_messages_per_session[",
            "                                session_hash",
            "                            ]",
            "                            message = messages.get_nowait()",
            "                        except EmptyQueue:",
            "                            await asyncio.sleep(check_rate)",
            "                            if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                                # Fix this",
            "                                message = {",
            "                                    \"msg\": ServerMessage.heartbeat,",
            "                                }",
            "                                # Need to reset last_heartbeat with perf_counter",
            "                                # otherwise only a single hearbeat msg will be sent",
            "                                # and then the stream will retry leading to infinite queue \ud83d\ude2c",
            "                                last_heartbeat = time.perf_counter()",
            "",
            "                        if blocks._queue.stopped:",
            "                            message = {",
            "                                \"msg\": \"unexpected_error\",",
            "                                \"message\": \"Server stopped unexpectedly.\",",
            "                                \"success\": False,",
            "                            }",
            "                        if message:",
            "                            add_root_url(message, root_path, None)",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            if message[\"msg\"] == ServerMessage.process_completed:",
            "                                blocks._queue.pending_event_ids_session[",
            "                                    session_hash",
            "                                ].remove(message[\"event_id\"])",
            "                                if message[\"msg\"] == ServerMessage.server_stopped or (",
            "                                    message[\"msg\"] == ServerMessage.process_completed",
            "                                    and (",
            "                                        len(",
            "                                            blocks._queue.pending_event_ids_session[",
            "                                                session_hash",
            "                                            ]",
            "                                        )",
            "                                        == 0",
            "                                    )",
            "                                ):",
            "                                    return",
            "                except BaseException as e:",
            "                    message = {",
            "                        \"msg\": \"unexpected_error\",",
            "                        \"success\": False,",
            "                        \"message\": str(e),",
            "                    }",
            "                    yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    if isinstance(e, asyncio.CancelledError):",
            "                        del blocks._queue.pending_messages_per_session[session_hash]",
            "                        await blocks._queue.clean_events(session_hash=session_hash)",
            "                    raise e",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/queue/join\", dependencies=[Depends(login_check)])",
            "        async def queue_join(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            if blocks._queue.server_app is None:",
            "                blocks._queue.set_server_app(app)",
            "",
            "            if blocks._queue.stopped:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,",
            "                    detail=\"Queue is stopped.\",",
            "                )",
            "",
            "            success, event_id = await blocks._queue.push(body, request, username)",
            "            if not success:",
            "                status_code = (",
            "                    status.HTTP_503_SERVICE_UNAVAILABLE",
            "                    if \"Queue is full.\" in event_id",
            "                    else status.HTTP_400_BAD_REQUEST",
            "                )",
            "                raise HTTPException(status_code=status_code, detail=event_id)",
            "            return {\"event_id\": event_id}",
            "",
            "        @app.post(\"/component_server\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/component_server/\", dependencies=[Depends(login_check)])",
            "        def component_server(body: ComponentServerBody):",
            "            state = app.state_holder[body.session_hash]",
            "            component_id = body.component_id",
            "            block: Block",
            "            if component_id in state:",
            "                block = state[component_id]",
            "            else:",
            "                block = app.get_blocks().blocks[component_id]",
            "            fn = getattr(block, body.fn_name, None)",
            "            if fn is None or not getattr(fn, \"_is_server_fn\", False):",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                    detail=\"Function not found.\",",
            "                )",
            "            return fn(body.data)",
            "",
            "        @app.get(",
            "            \"/queue/status\",",
            "            dependencies=[Depends(login_check)],",
            "            response_model=Estimation,",
            "        )",
            "        async def get_queue_status():",
            "            return app.get_blocks()._queue.get_status()",
            "",
            "        @app.get(\"/upload_progress\")",
            "        def get_upload_progress(upload_id: str, request: fastapi.Request):",
            "            async def sse_stream(request: fastapi.Request):",
            "                last_heartbeat = time.perf_counter()",
            "                is_done = False",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "                    if is_done:",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "",
            "                    heartbeat_rate = 15",
            "                    check_rate = 0.05",
            "                    try:",
            "                        if file_upload_statuses.is_done(upload_id):",
            "                            message = {\"msg\": \"done\"}",
            "                            is_done = True",
            "                        else:",
            "                            update = file_upload_statuses.pop(upload_id)",
            "                            message = {",
            "                                \"msg\": \"update\",",
            "                                \"orig_name\": update.filename,",
            "                                \"chunk_size\": update.chunk_size,",
            "                            }",
            "                        yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    except FileUploadProgressNotTrackedError:",
            "                        return",
            "                    except FileUploadProgressNotQueuedError:",
            "                        await asyncio.sleep(check_rate)",
            "                        if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                            message = {\"msg\": \"heartbeat\"}",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            last_heartbeat = time.perf_counter()",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/upload\", dependencies=[Depends(login_check)])",
            "        async def upload_file(",
            "            request: fastapi.Request,",
            "            bg_tasks: BackgroundTasks,",
            "            upload_id: Optional[str] = None,",
            "        ):",
            "            content_type_header = request.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header or \"\")",
            "            if content_type != b\"multipart/form-data\":",
            "                raise HTTPException(status_code=400, detail=\"Invalid content type.\")",
            "",
            "            try:",
            "                if upload_id:",
            "                    file_upload_statuses.track(upload_id)",
            "                multipart_parser = GradioMultiPartParser(",
            "                    request.headers,",
            "                    request.stream(),",
            "                    max_files=1000,",
            "                    max_fields=1000,",
            "                    upload_id=upload_id if upload_id else None,",
            "                    upload_progress=file_upload_statuses if upload_id else None,",
            "                )",
            "                form = await multipart_parser.parse()",
            "            except MultiPartException as exc:",
            "                raise HTTPException(status_code=400, detail=exc.message) from exc",
            "",
            "            output_files = []",
            "            files_to_copy = []",
            "            locations: list[str] = []",
            "            for temp_file in form.getlist(\"files\"):",
            "                if not isinstance(temp_file, GradioUploadFile):",
            "                    raise TypeError(\"File is not an instance of GradioUploadFile\")",
            "                if temp_file.filename:",
            "                    file_name = Path(temp_file.filename).name",
            "                    name = client_utils.strip_invalid_filename_characters(file_name)",
            "                else:",
            "                    name = f\"tmp{secrets.token_hex(5)}\"",
            "                directory = Path(app.uploaded_file_dir) / temp_file.sha.hexdigest()",
            "                directory.mkdir(exist_ok=True, parents=True)",
            "                dest = (directory / name).resolve()",
            "                temp_file.file.close()",
            "                # we need to move the temp file to the cache directory",
            "                # but that's possibly blocking and we're in an async function",
            "                # so we try to rename (this is what shutil.move tries first)",
            "                # which should be super fast.",
            "                # if that fails, we move in the background.",
            "                try:",
            "                    os.rename(temp_file.file.name, dest)",
            "                except OSError:",
            "                    files_to_copy.append(temp_file.file.name)",
            "                    locations.append(str(dest))",
            "                output_files.append(dest)",
            "            if files_to_copy:",
            "                bg_tasks.add_task(",
            "                    move_uploaded_files_to_cache, files_to_copy, locations",
            "                )",
            "            return output_files",
            "",
            "        @app.on_event(\"startup\")",
            "        @app.get(\"/startup-events\")",
            "        async def startup_events():",
            "            if not app.startup_events_triggered:",
            "                app.get_blocks().startup_events()",
            "                app.startup_events_triggered = True",
            "                return True",
            "            return False",
            "",
            "        @app.get(\"/theme.css\", response_class=PlainTextResponse)",
            "        def theme_css():",
            "            return PlainTextResponse(app.get_blocks().theme_css, media_type=\"text/css\")",
            "",
            "        @app.get(\"/robots.txt\", response_class=PlainTextResponse)",
            "        def robots_txt():",
            "            if app.get_blocks().share:",
            "                return \"User-agent: *\\nDisallow: /\"",
            "            else:",
            "                return \"User-agent: *\\nDisallow: \"",
            "",
            "        return app",
            "",
            "",
            "########",
            "# Helper functions",
            "########",
            "",
            "",
            "def safe_join(directory: str, path: str) -> str:",
            "    \"\"\"Safely path to a base directory to avoid escaping the base directory.",
            "    Borrowed from: werkzeug.security.safe_join\"\"\"",
            "    _os_alt_seps: List[str] = [",
            "        sep for sep in [os.path.sep, os.path.altsep] if sep is not None and sep != \"/\"",
            "    ]",
            "",
            "    if path == \"\":",
            "        raise HTTPException(400)",
            "",
            "    filename = posixpath.normpath(path)",
            "    fullpath = os.path.join(directory, filename)",
            "    if (",
            "        any(sep in filename for sep in _os_alt_seps)",
            "        or os.path.isabs(filename)",
            "        or filename == \"..\"",
            "        or filename.startswith(\"../\")",
            "        or os.path.isdir(fullpath)",
            "    ):",
            "        raise HTTPException(403)",
            "",
            "    if not os.path.exists(fullpath):",
            "        raise HTTPException(404, \"File not found\")",
            "",
            "    return fullpath",
            "",
            "",
            "def get_types(cls_set: List[Type]):",
            "    docset = []",
            "    types = []",
            "    for cls in cls_set:",
            "        doc = inspect.getdoc(cls) or \"\"",
            "        doc_lines = doc.split(\"\\n\")",
            "        for line in doc_lines:",
            "            if \"value (\" in line:",
            "                types.append(line.split(\"value (\")[1].split(\")\")[0])",
            "        docset.append(doc_lines[1].split(\":\")[-1])",
            "    return docset, types",
            "",
            "",
            "@document()",
            "def mount_gradio_app(",
            "    app: fastapi.FastAPI,",
            "    blocks: gradio.Blocks,",
            "    path: str,",
            "    app_kwargs: dict[str, Any] | None = None,",
            ") -> fastapi.FastAPI:",
            "    \"\"\"Mount a gradio.Blocks to an existing FastAPI application.",
            "",
            "    Parameters:",
            "        app: The parent FastAPI application.",
            "        blocks: The blocks object we want to mount to the parent app.",
            "        path: The path at which the gradio application will be mounted.",
            "        app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "    Example:",
            "        from fastapi import FastAPI",
            "        import gradio as gr",
            "        app = FastAPI()",
            "        @app.get(\"/\")",
            "        def read_main():",
            "            return {\"message\": \"This is your main app\"}",
            "        io = gr.Interface(lambda x: \"Hello, \" + x + \"!\", \"textbox\", \"textbox\")",
            "        app = gr.mount_gradio_app(app, io, path=\"/gradio\")",
            "        # Then run `uvicorn run:app` from the terminal and navigate to http://localhost:8000/gradio.",
            "    \"\"\"",
            "    blocks.dev_mode = False",
            "    blocks.config = blocks.get_config_file()",
            "    blocks.validate_queue_settings()",
            "    gradio_app = App.create_app(blocks, app_kwargs=app_kwargs)",
            "",
            "    old_lifespan = app.router.lifespan_context",
            "",
            "    @contextlib.asynccontextmanager",
            "    async def new_lifespan(app: FastAPI):",
            "        async with old_lifespan(",
            "            app",
            "        ):  # Instert the startup events inside the FastAPI context manager",
            "            gradio_app.get_blocks().startup_events()",
            "            yield",
            "",
            "    app.router.lifespan_context = new_lifespan",
            "",
            "    app.mount(path, gradio_app)",
            "    return app"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "32": [],
            "199": [
                "App",
                "create_app"
            ],
            "200": [
                "App",
                "create_app"
            ],
            "201": [
                "App",
                "create_app"
            ],
            "202": [
                "App",
                "create_app"
            ],
            "203": [
                "App",
                "create_app"
            ],
            "204": [
                "App",
                "create_app"
            ]
        },
        "addLocation": []
    }
}