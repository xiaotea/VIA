{
    "archivy/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from flask import Flask"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from flask_compress import Compress"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from flask_login import LoginManager"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from flask_wtf.csrf import CSRFProtect"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from archivy import helpers"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from archivy.api import api_bp"
            },
            "7": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " login_manager.login_view = \"login\""
            },
            "8": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " login_manager.init_app(app)"
            },
            "9": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " app.register_blueprint(api_bp, url_prefix=\"/api\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+csrf = CSRFProtect(app)"
            },
            "11": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " # compress files"
            },
            "13": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " Compress(app)"
            }
        },
        "frontPatchFile": [
            "import logging",
            "from pathlib import Path",
            "from shutil import which",
            "",
            "from elasticsearch.exceptions import RequestError",
            "from flask import Flask",
            "from flask_compress import Compress",
            "from flask_login import LoginManager",
            "",
            "from archivy import helpers",
            "from archivy.api import api_bp",
            "from archivy.models import User",
            "from archivy.config import Config",
            "from archivy.helpers import load_config, get_elastic_client",
            "",
            "app = Flask(__name__)",
            "app.logger.setLevel(logging.INFO)",
            "config = Config()",
            "try:",
            "    # if it exists, load user config",
            "    config.override(load_config(config.INTERNAL_DIR))",
            "except FileNotFoundError:",
            "    pass",
            "",
            "app.config.from_object(config)",
            "(Path(app.config[\"USER_DIR\"]) / \"data\").mkdir(parents=True, exist_ok=True)",
            "(Path(app.config[\"USER_DIR\"]) / \"images\").mkdir(parents=True, exist_ok=True)",
            "",
            "with app.app_context():",
            "    app.config[\"RG_INSTALLED\"] = which(\"rg\") != None",
            "    app.config[\"HOOKS\"] = helpers.load_hooks()",
            "    app.config[\"SCRAPING_PATTERNS\"] = helpers.load_scraper()",
            "if app.config[\"SEARCH_CONF\"][\"enabled\"]:",
            "    with app.app_context():",
            "        search_engines = [\"elasticsearch\", \"ripgrep\"]",
            "        es = None",
            "        if (",
            "            \"engine\" not in app.config[\"SEARCH_CONF\"]",
            "            or app.config[\"SEARCH_CONF\"][\"engine\"] not in search_engines",
            "        ):",
            "            # try to guess desired search engine if present",
            "            app.logger.warning(",
            "                \"Search is enabled but engine option is invalid or absent. Archivy will\"",
            "                \" try to guess preferred search engine.\"",
            "            )",
            "            app.config[\"SEARCH_CONF\"][\"engine\"] = \"none\"",
            "",
            "            es = get_elastic_client(error_if_invalid=False)",
            "            if es:",
            "                app.config[\"SEARCH_CONF\"][\"engine\"] = \"elasticsearch\"",
            "            else:",
            "                if which(\"rg\"):",
            "                    app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"",
            "            engine = app.config[\"SEARCH_CONF\"][\"engine\"]",
            "            if engine == \"none\":",
            "                app.logger.warning(\"No working search engine found. Disabling search.\")",
            "                app.config[\"SEARCH_CONF\"][\"enabled\"] = 0",
            "            else:",
            "                app.logger.info(f\"Running {engine} installation found.\")",
            "",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"elasticsearch\":",
            "            es = es or get_elastic_client()",
            "            try:",
            "                es.indices.create(",
            "                    index=app.config[\"SEARCH_CONF\"][\"index_name\"],",
            "                    body=app.config[\"SEARCH_CONF\"][\"es_processing_conf\"],",
            "                )",
            "            except RequestError:",
            "                app.logger.info(\"Elasticsearch index already created\")",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):",
            "            app.logger.info(\"Ripgrep not found on system. Disabling search.\")",
            "            app.config[\"SEARCH_CONF\"][\"enabled\"] = 0",
            "",
            "",
            "# login routes / setup",
            "login_manager = LoginManager()",
            "login_manager.login_view = \"login\"",
            "login_manager.init_app(app)",
            "app.register_blueprint(api_bp, url_prefix=\"/api\")",
            "",
            "# compress files",
            "Compress(app)",
            "",
            "",
            "@login_manager.user_loader",
            "def load_user(user_id):",
            "    db = helpers.get_db()",
            "    res = db.get(doc_id=int(user_id))",
            "    if res and res[\"type\"] == \"user\":",
            "        return User.from_db(res)",
            "    return None",
            "",
            "",
            "app.jinja_options[\"extensions\"].append(\"jinja2.ext.do\")",
            "",
            "",
            "@app.template_filter(\"pluralize\")",
            "def pluralize(number, singular=\"\", plural=\"s\"):",
            "    if number == 1:",
            "        return singular",
            "    else:",
            "        return plural",
            "",
            "",
            "from archivy import routes  # noqa:"
        ],
        "afterPatchFile": [
            "import logging",
            "from pathlib import Path",
            "from shutil import which",
            "",
            "from elasticsearch.exceptions import RequestError",
            "from flask import Flask",
            "from flask_compress import Compress",
            "from flask_login import LoginManager",
            "from flask_wtf.csrf import CSRFProtect",
            "",
            "from archivy import helpers",
            "from archivy.api import api_bp",
            "from archivy.models import User",
            "from archivy.config import Config",
            "from archivy.helpers import load_config, get_elastic_client",
            "",
            "app = Flask(__name__)",
            "app.logger.setLevel(logging.INFO)",
            "config = Config()",
            "try:",
            "    # if it exists, load user config",
            "    config.override(load_config(config.INTERNAL_DIR))",
            "except FileNotFoundError:",
            "    pass",
            "",
            "app.config.from_object(config)",
            "(Path(app.config[\"USER_DIR\"]) / \"data\").mkdir(parents=True, exist_ok=True)",
            "(Path(app.config[\"USER_DIR\"]) / \"images\").mkdir(parents=True, exist_ok=True)",
            "",
            "with app.app_context():",
            "    app.config[\"RG_INSTALLED\"] = which(\"rg\") != None",
            "    app.config[\"HOOKS\"] = helpers.load_hooks()",
            "    app.config[\"SCRAPING_PATTERNS\"] = helpers.load_scraper()",
            "if app.config[\"SEARCH_CONF\"][\"enabled\"]:",
            "    with app.app_context():",
            "        search_engines = [\"elasticsearch\", \"ripgrep\"]",
            "        es = None",
            "        if (",
            "            \"engine\" not in app.config[\"SEARCH_CONF\"]",
            "            or app.config[\"SEARCH_CONF\"][\"engine\"] not in search_engines",
            "        ):",
            "            # try to guess desired search engine if present",
            "            app.logger.warning(",
            "                \"Search is enabled but engine option is invalid or absent. Archivy will\"",
            "                \" try to guess preferred search engine.\"",
            "            )",
            "            app.config[\"SEARCH_CONF\"][\"engine\"] = \"none\"",
            "",
            "            es = get_elastic_client(error_if_invalid=False)",
            "            if es:",
            "                app.config[\"SEARCH_CONF\"][\"engine\"] = \"elasticsearch\"",
            "            else:",
            "                if which(\"rg\"):",
            "                    app.config[\"SEARCH_CONF\"][\"engine\"] = \"ripgrep\"",
            "            engine = app.config[\"SEARCH_CONF\"][\"engine\"]",
            "            if engine == \"none\":",
            "                app.logger.warning(\"No working search engine found. Disabling search.\")",
            "                app.config[\"SEARCH_CONF\"][\"enabled\"] = 0",
            "            else:",
            "                app.logger.info(f\"Running {engine} installation found.\")",
            "",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"elasticsearch\":",
            "            es = es or get_elastic_client()",
            "            try:",
            "                es.indices.create(",
            "                    index=app.config[\"SEARCH_CONF\"][\"index_name\"],",
            "                    body=app.config[\"SEARCH_CONF\"][\"es_processing_conf\"],",
            "                )",
            "            except RequestError:",
            "                app.logger.info(\"Elasticsearch index already created\")",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):",
            "            app.logger.info(\"Ripgrep not found on system. Disabling search.\")",
            "            app.config[\"SEARCH_CONF\"][\"enabled\"] = 0",
            "",
            "",
            "# login routes / setup",
            "login_manager = LoginManager()",
            "login_manager.login_view = \"login\"",
            "login_manager.init_app(app)",
            "app.register_blueprint(api_bp, url_prefix=\"/api\")",
            "csrf = CSRFProtect(app)",
            "",
            "# compress files",
            "Compress(app)",
            "",
            "",
            "@login_manager.user_loader",
            "def load_user(user_id):",
            "    db = helpers.get_db()",
            "    res = db.get(doc_id=int(user_id))",
            "    if res and res[\"type\"] == \"user\":",
            "        return User.from_db(res)",
            "    return None",
            "",
            "",
            "app.jinja_options[\"extensions\"].append(\"jinja2.ext.do\")",
            "",
            "",
            "@app.template_filter(\"pluralize\")",
            "def pluralize(number, singular=\"\", plural=\"s\"):",
            "    if number == 1:",
            "        return singular",
            "    else:",
            "        return plural",
            "",
            "",
            "from archivy import routes  # noqa:"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "archivy/click_web/resources/cmd_exec.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " \r"
            },
            "1": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " class RequestToCommandArgs:\r"
            },
            "2": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     def __init__(self):\r"
            },
            "3": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        field_infos = [\r"
            },
            "4": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            FieldInfo.factory(key)\r"
            },
            "5": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for key in list(request.form.keys()) + list(request.files.keys())\r"
            },
            "6": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]\r"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        keys = [key for key in list(request.form.keys()) + list(request.files.keys())]\r"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        field_infos = [FieldInfo.factory(key) for key in keys if key != \"csrf_token\"]\r"
            },
            "9": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         # important to sort them so they will be in expected order on command line\r"
            },
            "10": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         self.field_infos = list(sorted(field_infos))\r"
            },
            "11": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " \r"
            }
        },
        "frontPatchFile": [
            "import os\r",
            "import shutil\r",
            "import subprocess\r",
            "import sys\r",
            "import tempfile\r",
            "import traceback\r",
            "from pathlib import Path\r",
            "from typing import List\r",
            "\r",
            "from flask import Response, request\r",
            "from werkzeug.utils import secure_filename\r",
            "\r",
            "from archivy import click_web\r",
            "\r",
            "from .input_fields import FieldId\r",
            "\r",
            "logger = None\r",
            "\r",
            "\r",
            "def exec(command_path):\r",
            "    \"\"\"\r",
            "    Execute the command and stream the output from it as response\r",
            "    :param command_path:\r",
            "    \"\"\"\r",
            "    command_path = \"cli/\" + command_path\r",
            "    global logger\r",
            "    logger = click_web.logger\r",
            "\r",
            "    omitted = [\"shell\", \"run\", \"routes\", \"create-admin\"]\r",
            "    root_command, *commands = command_path.split(\"/\")\r",
            "    cmd = [\"archivy\"]\r",
            "    req_to_args = RequestToCommandArgs()\r",
            "    # root command_index should not add a command\r",
            "    cmd.extend(req_to_args.command_args(0))\r",
            "    for i, command in enumerate(commands):\r",
            "        if command in omitted:\r",
            "            return Response(status=400)\r",
            "        cmd.append(command)\r",
            "        cmd.extend(req_to_args.command_args(i + 1))\r",
            "\r",
            "    def _generate_output():\r",
            "        yield _create_cmd_header(commands)\r",
            "        try:\r",
            "            yield from _run_script_and_generate_stream(req_to_args, cmd)\r",
            "        except Exception as e:\r",
            "            # exited prematurely, show the error to user\r",
            "            yield f\"\\nERROR: Got exception when reading output from script: {type(e)}\\n\"\r",
            "            yield traceback.format_exc()\r",
            "            raise\r",
            "\r",
            "    return Response(_generate_output(), mimetype=\"text/plain\")\r",
            "\r",
            "\r",
            "def _run_script_and_generate_stream(\r",
            "    req_to_args: \"RequestToCommandArgs\", cmd: List[str]\r",
            "):\r",
            "    \"\"\"\r",
            "    Execute the command the via Popen and yield output\r",
            "    \"\"\"\r",
            "    logger.info(\"Executing archivy command\")\r",
            "    if not os.environ.get(\"PYTHONIOENCODING\"):\r",
            "        # Fix unicode on windows\r",
            "        os.environ[\"PYTHONIOENCODING\"] = \"UTF-8\"\r",
            "\r",
            "    process = subprocess.Popen(\r",
            "        cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\r",
            "    )\r",
            "    logger.info(\"script running Pid: %d\", process.pid)\r",
            "\r",
            "    encoding = sys.getdefaultencoding()\r",
            "    with process.stdout:\r",
            "        for line in iter(process.stdout.readline, b\"\"):\r",
            "            yield line.decode(encoding)\r",
            "\r",
            "    process.wait()  # wait for the subprocess to exit\r",
            "    logger.info(\"script finished Pid: %d\", process.pid)\r",
            "    for fi in req_to_args.field_infos:\r",
            "        fi.after_script_executed()\r",
            "\r",
            "\r",
            "def _create_cmd_header(commands: List[str]):\r",
            "    \"\"\"\r",
            "    Generate a command header.\r",
            "    Note:\r",
            "        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r",
            "        This way the JS frontend can insert it in the correct place in the DOM.\r",
            "    \"\"\"\r",
            "\r",
            "    def generate():\r",
            "        yield \"<!-- CLICK_WEB START HEADER -->\"\r",
            "        yield '<div class=\"command-line\">Executing: {}</div>'.format(\"/\".join(commands))\r",
            "        yield \"<!-- CLICK_WEB END HEADER -->\"\r",
            "\r",
            "    # important yield this block as one string so it pushed to client in one go.\r",
            "    # so the whole block can be treated as html.\r",
            "    html_str = \"\\n\".join(generate())\r",
            "    return html_str\r",
            "\r",
            "\r",
            "def _create_result_footer(req_to_args: \"RequestToCommandArgs\"):\r",
            "    \"\"\"\r",
            "    Generate a footer.\r",
            "    Note:\r",
            "        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r",
            "        This way the JS frontend can insert it in the correct place in the DOM.\r",
            "    \"\"\"\r",
            "    to_download = [\r",
            "        fi\r",
            "        for fi in req_to_args.field_infos\r",
            "        if fi.generate_download_link and fi.link_name\r",
            "    ]\r",
            "    # important yield this block as one string so it pushed to client in one go.\r",
            "    # This is so the whole block can be treated as html if JS frontend.\r",
            "    lines = []\r",
            "    lines.append(\"<!-- CLICK_WEB START FOOTER -->\")\r",
            "    if to_download:\r",
            "        lines.append(\"<b>Result files:</b><br>\")\r",
            "        for fi in to_download:\r",
            "            lines.append(\"<ul> \")\r",
            "            lines.append(f\"<li>{_get_download_link(fi)}<br>\")\r",
            "            lines.append(\"</ul>\")\r",
            "\r",
            "    else:\r",
            "        lines.append(\"<b>DONE</b>\")\r",
            "    lines.append(\"<!-- CLICK_WEB END FOOTER -->\")\r",
            "    html_str = \"\\n\".join(lines)\r",
            "    yield html_str\r",
            "\r",
            "\r",
            "def _get_download_link(field_info):\r",
            "    \"\"\"Hack as url_for need request context\"\"\"\r",
            "\r",
            "    rel_file_path = Path(field_info.file_path).relative_to(click_web.OUTPUT_FOLDER)\r",
            "    uri = f\"/static/results/{rel_file_path.as_posix()}\"\r",
            "    return f'<a href=\"{uri}\">{field_info.link_name}</a>'\r",
            "\r",
            "\r",
            "class RequestToCommandArgs:\r",
            "    def __init__(self):\r",
            "        field_infos = [\r",
            "            FieldInfo.factory(key)\r",
            "            for key in list(request.form.keys()) + list(request.files.keys())\r",
            "        ]\r",
            "        # important to sort them so they will be in expected order on command line\r",
            "        self.field_infos = list(sorted(field_infos))\r",
            "\r",
            "    def command_args(self, command_index) -> List[str]:\r",
            "        \"\"\"\r",
            "        Convert the post request into a list of command line arguments\r",
            "\r",
            "        :param command_index: (int) the index for the command to get arguments for.\r",
            "        :return: list of command line arguments for command at that cmd_index\r",
            "        \"\"\"\r",
            "        args = []\r",
            "\r",
            "        # only include relevant fields for this command index\r",
            "        commands_field_infos = [\r",
            "            fi for fi in self.field_infos if fi.param.command_index == command_index\r",
            "        ]\r",
            "        commands_field_infos = sorted(commands_field_infos)\r",
            "\r",
            "        for fi in commands_field_infos:\r",
            "\r",
            "            # must be called mostly for saving and preparing file output.\r",
            "            fi.before_script_execute()\r",
            "\r",
            "            if fi.cmd_opt.startswith(\"--\"):\r",
            "                # it's an option\r",
            "                args.extend(self._process_option(fi))\r",
            "\r",
            "            else:\r",
            "                # argument(s)\r",
            "                if isinstance(fi, FieldFileInfo):\r",
            "                    # it's a file, append the written temp file path\r",
            "                    # TODO: does file upload support multiple keys? In that case support it.\r",
            "                    args.append(fi.file_path)\r",
            "                else:\r",
            "                    arg_values = request.form.getlist(fi.key)\r",
            "                    has_values = bool(\"\".join(arg_values))\r",
            "                    if has_values:\r",
            "                        if fi.param.nargs == -1:\r",
            "                            # Variadic argument, in html form each argument\r",
            "                            # is a separate line in a textarea.\r",
            "                            # treat each line we get from text area as a separate argument.\r",
            "                            for value in arg_values:\r",
            "                                values = value.splitlines()\r",
            "                                logger.info(\r",
            "                                    f'variadic arguments, split into: \"{values}\"'\r",
            "                                )\r",
            "                                args.extend(values)\r",
            "                        else:\r",
            "                            logger.info(f'arg_value: \"{arg_values}\"')\r",
            "                            args.extend(arg_values)\r",
            "        return args\r",
            "\r",
            "    def _process_option(self, field_info):\r",
            "        vals = request.form.getlist(field_info.key)\r",
            "        if field_info.is_file:\r",
            "            if field_info.link_name:\r",
            "                # it's a file, append the file path\r",
            "                yield field_info.cmd_opt\r",
            "                yield field_info.file_path\r",
            "        elif field_info.param.param_type == \"flag\":\r",
            "            # To work with flag that is default True\r",
            "            # a hidden field with same name is also sent by form.\r",
            "            # This is to detect if checkbox was not checked as then\r",
            "            # we will get the field anyway with the \"off flag\" as value.\r",
            "            if len(vals) == 1:\r",
            "                off_flag = vals[0]\r",
            "                flag_on_cmd_line = off_flag\r",
            "            else:\r",
            "                # we got both off and on flags, checkbox is checked.\r",
            "                on_flag = vals[1]\r",
            "                flag_on_cmd_line = on_flag\r",
            "\r",
            "            yield flag_on_cmd_line\r",
            "        elif \"\".join(vals):\r",
            "            # opt with value, if option was given multiple times get the values for each.\r",
            "            # flag options should always be set if we get them\r",
            "            # for normal options they must have a non empty value\r",
            "            yield field_info.cmd_opt\r",
            "            for val in vals:\r",
            "                if val:\r",
            "                    yield val\r",
            "        else:\r",
            "            # option with empty values, should not be added to command line.\r",
            "            pass\r",
            "\r",
            "\r",
            "class FieldInfo:\r",
            "    \"\"\"\r",
            "    Extract information from the encoded form input field name\r",
            "    the parts:\r",
            "        [command_index].[opt_or_arg_index].[click_type].[html_input_type].[opt_or_arg_name]\r",
            "    e.g.\r",
            "        \"0.0.option.text.text.--an-option\"\r",
            "        \"0.1.argument.file[rb].text.an-argument\"\r",
            "    \"\"\"\r",
            "\r",
            "    @staticmethod\r",
            "    def factory(key):\r",
            "        field_id = FieldId.from_string(key)\r",
            "        is_file = field_id.click_type.startswith(\"file\")\r",
            "        is_path = field_id.click_type.startswith(\"path\")\r",
            "        is_uploaded = key in request.files\r",
            "        if is_file:\r",
            "            if is_uploaded:\r",
            "                field_info = FieldFileInfo(field_id)\r",
            "            else:\r",
            "                field_info = FieldOutFileInfo(field_id)\r",
            "        elif is_path:\r",
            "            if is_uploaded:\r",
            "                field_info = FieldPathInfo(field_id)\r",
            "            else:\r",
            "                field_info = FieldPathOutInfo(field_id)\r",
            "        else:\r",
            "            field_info = FieldInfo(field_id)\r",
            "        return field_info\r",
            "\r",
            "    def __init__(self, param: FieldId):\r",
            "        self.param = param\r",
            "        self.key = param.key\r",
            "\r",
            "        \"Type of option (file, text)\"\r",
            "        self.is_file = self.param.click_type.startswith(\"file\")\r",
            "\r",
            "        \"The actual command line option (--debug)\"\r",
            "        self.cmd_opt = param.name\r",
            "\r",
            "        self.generate_download_link = False\r",
            "\r",
            "    def before_script_execute(self):\r",
            "        pass\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        pass\r",
            "\r",
            "    def __str__(self):\r",
            "        return str(self.param)\r",
            "\r",
            "    def __lt__(self, other):\r",
            "        \"Make class sortable\"\r",
            "        return (self.param.command_index, self.param.param_index) < (\r",
            "            other.param.command_index,\r",
            "            other.param.param_index,\r",
            "        )\r",
            "\r",
            "    def __eq__(self, other):\r",
            "        return self.key == other.key\r",
            "\r",
            "\r",
            "class FieldFileInfo(FieldInfo):\r",
            "    \"\"\"\r",
            "    Use for processing input fields of file type.\r",
            "    Saves the posted data to a temp file.\r",
            "    \"\"\"\r",
            "\r",
            "    \"temp dir is on class in order to be uniqe for each request\"\r",
            "    _temp_dir = None\r",
            "\r",
            "    def __init__(self, fimeta):\r",
            "        super().__init__(fimeta)\r",
            "        # Extract the file mode that is in the type e.g file[rw]\r",
            "        self.mode = self.param.click_type.split(\"[\")[1][:-1]\r",
            "        self.generate_download_link = True if \"w\" in self.mode else False\r",
            "        self.link_name = f\"{self.cmd_opt}.out\"\r",
            "\r",
            "        logger.info(f\"File mode for {self.key} is {self.mode}\")\r",
            "\r",
            "    def before_script_execute(self):\r",
            "        self.save()\r",
            "\r",
            "    @classmethod\r",
            "    def temp_dir(cls):\r",
            "        if not cls._temp_dir:\r",
            "            cls._temp_dir = tempfile.mkdtemp(dir=click_web.OUTPUT_FOLDER)\r",
            "        logger.info(f\"Temp dir: {cls._temp_dir}\")\r",
            "        return cls._temp_dir\r",
            "\r",
            "    def save(self):\r",
            "        logger.info(\"Saving...\")\r",
            "\r",
            "        logger.info(\"field value is a file! %s\", self.key)\r",
            "        file = request.files[self.key]\r",
            "        # if user does not select file, browser also\r",
            "        # submit a empty part without filename\r",
            "        if file.filename == \"\":\r",
            "            raise ValueError(\"No selected file\")\r",
            "        elif file and file.filename:\r",
            "            filename = secure_filename(file.filename)\r",
            "            name, suffix = os.path.splitext(filename)\r",
            "\r",
            "            fd, filename = tempfile.mkstemp(\r",
            "                dir=self.temp_dir(), prefix=name, suffix=suffix\r",
            "            )\r",
            "            self.file_path = filename\r",
            "            logger.info(f\"Saving {self.key} to {filename}\")\r",
            "            file.save(filename)\r",
            "\r",
            "    def __str__(self):\r",
            "\r",
            "        res = [super().__str__()]\r",
            "        res.append(f\"file_path: {self.file_path}\")\r",
            "        return \", \".join(res)\r",
            "\r",
            "\r",
            "class FieldOutFileInfo(FieldFileInfo):\r",
            "    \"\"\"\r",
            "    Used when file option is just for output and form posted it as hidden or text field.\r",
            "    Just create a empty temp file to give it's path to command.\r",
            "    \"\"\"\r",
            "\r",
            "    def __init__(self, fimeta):\r",
            "        super().__init__(fimeta)\r",
            "        if self.param.form_type == \"text\":\r",
            "            self.link_name = request.form[self.key]\r",
            "            # set the postfix to name name provided from form\r",
            "            # this way it will at least have the same extension when downloaded\r",
            "            self.file_suffix = request.form[self.key]\r",
            "        else:\r",
            "            # hidden no preferred file name can be provided by user\r",
            "            self.file_suffix = \".out\"\r",
            "\r",
            "    def save(self):\r",
            "        name = secure_filename(self.key)\r",
            "\r",
            "        filename = tempfile.mkstemp(\r",
            "            dir=self.temp_dir(), prefix=name, suffix=self.file_suffix\r",
            "        )\r",
            "        logger.info(f\"Creating empty file for {self.key} as {filename}\")\r",
            "        self.file_path = filename\r",
            "\r",
            "\r",
            "class FieldPathInfo(FieldFileInfo):\r",
            "    \"\"\"\r",
            "    Use for processing input fields of path type.\r",
            "    Extracts the posted data to a temp folder.\r",
            "    When script finished zip that folder and provide download link to zip file.\r",
            "    \"\"\"\r",
            "\r",
            "    def save(self):\r",
            "        super().save()\r",
            "        zip_extract_dir = tempfile.mkdtemp(dir=self.temp_dir())\r",
            "\r",
            "        logger.info(f\"Extracting: {self.file_path} to {zip_extract_dir}\")\r",
            "        shutil.unpack_archive(self.file_path, zip_extract_dir, \"zip\")\r",
            "        self.file_path = zip_extract_dir\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        super().after_script_executed()\r",
            "        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r",
            "        folder_path = self.file_path\r",
            "        self.file_path = filename\r",
            "\r",
            "        logger.info(f\"Zipping {self.key} to {filename}\")\r",
            "        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r",
            "        logger.info(f\"Zip file created {self.file_path}\")\r",
            "        self.generate_download_link = True\r",
            "\r",
            "\r",
            "class FieldPathOutInfo(FieldOutFileInfo):\r",
            "    \"\"\"\r",
            "    Use for processing output fields of path type.\r",
            "    Create a folder and use as path to script.\r",
            "    When script finished zip that folder and provide download link to zip file.\r",
            "    \"\"\"\r",
            "\r",
            "    def save(self):\r",
            "        super().save()\r",
            "        self.file_path = tempfile.mkdtemp(dir=self.temp_dir())\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        super().after_script_executed()\r",
            "        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r",
            "        folder_path = self.file_path\r",
            "        self.file_path = filename\r",
            "        logger.info(f\"Zipping {self.key} to {filename}\")\r",
            "        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r",
            "        logger.info(f\"Zip file created {self.file_path}\")\r",
            "        self.generate_download_link = True\r"
        ],
        "afterPatchFile": [
            "import os\r",
            "import shutil\r",
            "import subprocess\r",
            "import sys\r",
            "import tempfile\r",
            "import traceback\r",
            "from pathlib import Path\r",
            "from typing import List\r",
            "\r",
            "from flask import Response, request\r",
            "from werkzeug.utils import secure_filename\r",
            "\r",
            "from archivy import click_web\r",
            "\r",
            "from .input_fields import FieldId\r",
            "\r",
            "logger = None\r",
            "\r",
            "\r",
            "def exec(command_path):\r",
            "    \"\"\"\r",
            "    Execute the command and stream the output from it as response\r",
            "    :param command_path:\r",
            "    \"\"\"\r",
            "    command_path = \"cli/\" + command_path\r",
            "    global logger\r",
            "    logger = click_web.logger\r",
            "\r",
            "    omitted = [\"shell\", \"run\", \"routes\", \"create-admin\"]\r",
            "    root_command, *commands = command_path.split(\"/\")\r",
            "    cmd = [\"archivy\"]\r",
            "    req_to_args = RequestToCommandArgs()\r",
            "    # root command_index should not add a command\r",
            "    cmd.extend(req_to_args.command_args(0))\r",
            "    for i, command in enumerate(commands):\r",
            "        if command in omitted:\r",
            "            return Response(status=400)\r",
            "        cmd.append(command)\r",
            "        cmd.extend(req_to_args.command_args(i + 1))\r",
            "\r",
            "    def _generate_output():\r",
            "        yield _create_cmd_header(commands)\r",
            "        try:\r",
            "            yield from _run_script_and_generate_stream(req_to_args, cmd)\r",
            "        except Exception as e:\r",
            "            # exited prematurely, show the error to user\r",
            "            yield f\"\\nERROR: Got exception when reading output from script: {type(e)}\\n\"\r",
            "            yield traceback.format_exc()\r",
            "            raise\r",
            "\r",
            "    return Response(_generate_output(), mimetype=\"text/plain\")\r",
            "\r",
            "\r",
            "def _run_script_and_generate_stream(\r",
            "    req_to_args: \"RequestToCommandArgs\", cmd: List[str]\r",
            "):\r",
            "    \"\"\"\r",
            "    Execute the command the via Popen and yield output\r",
            "    \"\"\"\r",
            "    logger.info(\"Executing archivy command\")\r",
            "    if not os.environ.get(\"PYTHONIOENCODING\"):\r",
            "        # Fix unicode on windows\r",
            "        os.environ[\"PYTHONIOENCODING\"] = \"UTF-8\"\r",
            "\r",
            "    process = subprocess.Popen(\r",
            "        cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.STDOUT\r",
            "    )\r",
            "    logger.info(\"script running Pid: %d\", process.pid)\r",
            "\r",
            "    encoding = sys.getdefaultencoding()\r",
            "    with process.stdout:\r",
            "        for line in iter(process.stdout.readline, b\"\"):\r",
            "            yield line.decode(encoding)\r",
            "\r",
            "    process.wait()  # wait for the subprocess to exit\r",
            "    logger.info(\"script finished Pid: %d\", process.pid)\r",
            "    for fi in req_to_args.field_infos:\r",
            "        fi.after_script_executed()\r",
            "\r",
            "\r",
            "def _create_cmd_header(commands: List[str]):\r",
            "    \"\"\"\r",
            "    Generate a command header.\r",
            "    Note:\r",
            "        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r",
            "        This way the JS frontend can insert it in the correct place in the DOM.\r",
            "    \"\"\"\r",
            "\r",
            "    def generate():\r",
            "        yield \"<!-- CLICK_WEB START HEADER -->\"\r",
            "        yield '<div class=\"command-line\">Executing: {}</div>'.format(\"/\".join(commands))\r",
            "        yield \"<!-- CLICK_WEB END HEADER -->\"\r",
            "\r",
            "    # important yield this block as one string so it pushed to client in one go.\r",
            "    # so the whole block can be treated as html.\r",
            "    html_str = \"\\n\".join(generate())\r",
            "    return html_str\r",
            "\r",
            "\r",
            "def _create_result_footer(req_to_args: \"RequestToCommandArgs\"):\r",
            "    \"\"\"\r",
            "    Generate a footer.\r",
            "    Note:\r",
            "        here we always allow to generate HTML as long as we have it between CLICK-WEB comments.\r",
            "        This way the JS frontend can insert it in the correct place in the DOM.\r",
            "    \"\"\"\r",
            "    to_download = [\r",
            "        fi\r",
            "        for fi in req_to_args.field_infos\r",
            "        if fi.generate_download_link and fi.link_name\r",
            "    ]\r",
            "    # important yield this block as one string so it pushed to client in one go.\r",
            "    # This is so the whole block can be treated as html if JS frontend.\r",
            "    lines = []\r",
            "    lines.append(\"<!-- CLICK_WEB START FOOTER -->\")\r",
            "    if to_download:\r",
            "        lines.append(\"<b>Result files:</b><br>\")\r",
            "        for fi in to_download:\r",
            "            lines.append(\"<ul> \")\r",
            "            lines.append(f\"<li>{_get_download_link(fi)}<br>\")\r",
            "            lines.append(\"</ul>\")\r",
            "\r",
            "    else:\r",
            "        lines.append(\"<b>DONE</b>\")\r",
            "    lines.append(\"<!-- CLICK_WEB END FOOTER -->\")\r",
            "    html_str = \"\\n\".join(lines)\r",
            "    yield html_str\r",
            "\r",
            "\r",
            "def _get_download_link(field_info):\r",
            "    \"\"\"Hack as url_for need request context\"\"\"\r",
            "\r",
            "    rel_file_path = Path(field_info.file_path).relative_to(click_web.OUTPUT_FOLDER)\r",
            "    uri = f\"/static/results/{rel_file_path.as_posix()}\"\r",
            "    return f'<a href=\"{uri}\">{field_info.link_name}</a>'\r",
            "\r",
            "\r",
            "class RequestToCommandArgs:\r",
            "    def __init__(self):\r",
            "        keys = [key for key in list(request.form.keys()) + list(request.files.keys())]\r",
            "        field_infos = [FieldInfo.factory(key) for key in keys if key != \"csrf_token\"]\r",
            "        # important to sort them so they will be in expected order on command line\r",
            "        self.field_infos = list(sorted(field_infos))\r",
            "\r",
            "    def command_args(self, command_index) -> List[str]:\r",
            "        \"\"\"\r",
            "        Convert the post request into a list of command line arguments\r",
            "\r",
            "        :param command_index: (int) the index for the command to get arguments for.\r",
            "        :return: list of command line arguments for command at that cmd_index\r",
            "        \"\"\"\r",
            "        args = []\r",
            "\r",
            "        # only include relevant fields for this command index\r",
            "        commands_field_infos = [\r",
            "            fi for fi in self.field_infos if fi.param.command_index == command_index\r",
            "        ]\r",
            "        commands_field_infos = sorted(commands_field_infos)\r",
            "\r",
            "        for fi in commands_field_infos:\r",
            "\r",
            "            # must be called mostly for saving and preparing file output.\r",
            "            fi.before_script_execute()\r",
            "\r",
            "            if fi.cmd_opt.startswith(\"--\"):\r",
            "                # it's an option\r",
            "                args.extend(self._process_option(fi))\r",
            "\r",
            "            else:\r",
            "                # argument(s)\r",
            "                if isinstance(fi, FieldFileInfo):\r",
            "                    # it's a file, append the written temp file path\r",
            "                    # TODO: does file upload support multiple keys? In that case support it.\r",
            "                    args.append(fi.file_path)\r",
            "                else:\r",
            "                    arg_values = request.form.getlist(fi.key)\r",
            "                    has_values = bool(\"\".join(arg_values))\r",
            "                    if has_values:\r",
            "                        if fi.param.nargs == -1:\r",
            "                            # Variadic argument, in html form each argument\r",
            "                            # is a separate line in a textarea.\r",
            "                            # treat each line we get from text area as a separate argument.\r",
            "                            for value in arg_values:\r",
            "                                values = value.splitlines()\r",
            "                                logger.info(\r",
            "                                    f'variadic arguments, split into: \"{values}\"'\r",
            "                                )\r",
            "                                args.extend(values)\r",
            "                        else:\r",
            "                            logger.info(f'arg_value: \"{arg_values}\"')\r",
            "                            args.extend(arg_values)\r",
            "        return args\r",
            "\r",
            "    def _process_option(self, field_info):\r",
            "        vals = request.form.getlist(field_info.key)\r",
            "        if field_info.is_file:\r",
            "            if field_info.link_name:\r",
            "                # it's a file, append the file path\r",
            "                yield field_info.cmd_opt\r",
            "                yield field_info.file_path\r",
            "        elif field_info.param.param_type == \"flag\":\r",
            "            # To work with flag that is default True\r",
            "            # a hidden field with same name is also sent by form.\r",
            "            # This is to detect if checkbox was not checked as then\r",
            "            # we will get the field anyway with the \"off flag\" as value.\r",
            "            if len(vals) == 1:\r",
            "                off_flag = vals[0]\r",
            "                flag_on_cmd_line = off_flag\r",
            "            else:\r",
            "                # we got both off and on flags, checkbox is checked.\r",
            "                on_flag = vals[1]\r",
            "                flag_on_cmd_line = on_flag\r",
            "\r",
            "            yield flag_on_cmd_line\r",
            "        elif \"\".join(vals):\r",
            "            # opt with value, if option was given multiple times get the values for each.\r",
            "            # flag options should always be set if we get them\r",
            "            # for normal options they must have a non empty value\r",
            "            yield field_info.cmd_opt\r",
            "            for val in vals:\r",
            "                if val:\r",
            "                    yield val\r",
            "        else:\r",
            "            # option with empty values, should not be added to command line.\r",
            "            pass\r",
            "\r",
            "\r",
            "class FieldInfo:\r",
            "    \"\"\"\r",
            "    Extract information from the encoded form input field name\r",
            "    the parts:\r",
            "        [command_index].[opt_or_arg_index].[click_type].[html_input_type].[opt_or_arg_name]\r",
            "    e.g.\r",
            "        \"0.0.option.text.text.--an-option\"\r",
            "        \"0.1.argument.file[rb].text.an-argument\"\r",
            "    \"\"\"\r",
            "\r",
            "    @staticmethod\r",
            "    def factory(key):\r",
            "        field_id = FieldId.from_string(key)\r",
            "        is_file = field_id.click_type.startswith(\"file\")\r",
            "        is_path = field_id.click_type.startswith(\"path\")\r",
            "        is_uploaded = key in request.files\r",
            "        if is_file:\r",
            "            if is_uploaded:\r",
            "                field_info = FieldFileInfo(field_id)\r",
            "            else:\r",
            "                field_info = FieldOutFileInfo(field_id)\r",
            "        elif is_path:\r",
            "            if is_uploaded:\r",
            "                field_info = FieldPathInfo(field_id)\r",
            "            else:\r",
            "                field_info = FieldPathOutInfo(field_id)\r",
            "        else:\r",
            "            field_info = FieldInfo(field_id)\r",
            "        return field_info\r",
            "\r",
            "    def __init__(self, param: FieldId):\r",
            "        self.param = param\r",
            "        self.key = param.key\r",
            "\r",
            "        \"Type of option (file, text)\"\r",
            "        self.is_file = self.param.click_type.startswith(\"file\")\r",
            "\r",
            "        \"The actual command line option (--debug)\"\r",
            "        self.cmd_opt = param.name\r",
            "\r",
            "        self.generate_download_link = False\r",
            "\r",
            "    def before_script_execute(self):\r",
            "        pass\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        pass\r",
            "\r",
            "    def __str__(self):\r",
            "        return str(self.param)\r",
            "\r",
            "    def __lt__(self, other):\r",
            "        \"Make class sortable\"\r",
            "        return (self.param.command_index, self.param.param_index) < (\r",
            "            other.param.command_index,\r",
            "            other.param.param_index,\r",
            "        )\r",
            "\r",
            "    def __eq__(self, other):\r",
            "        return self.key == other.key\r",
            "\r",
            "\r",
            "class FieldFileInfo(FieldInfo):\r",
            "    \"\"\"\r",
            "    Use for processing input fields of file type.\r",
            "    Saves the posted data to a temp file.\r",
            "    \"\"\"\r",
            "\r",
            "    \"temp dir is on class in order to be uniqe for each request\"\r",
            "    _temp_dir = None\r",
            "\r",
            "    def __init__(self, fimeta):\r",
            "        super().__init__(fimeta)\r",
            "        # Extract the file mode that is in the type e.g file[rw]\r",
            "        self.mode = self.param.click_type.split(\"[\")[1][:-1]\r",
            "        self.generate_download_link = True if \"w\" in self.mode else False\r",
            "        self.link_name = f\"{self.cmd_opt}.out\"\r",
            "\r",
            "        logger.info(f\"File mode for {self.key} is {self.mode}\")\r",
            "\r",
            "    def before_script_execute(self):\r",
            "        self.save()\r",
            "\r",
            "    @classmethod\r",
            "    def temp_dir(cls):\r",
            "        if not cls._temp_dir:\r",
            "            cls._temp_dir = tempfile.mkdtemp(dir=click_web.OUTPUT_FOLDER)\r",
            "        logger.info(f\"Temp dir: {cls._temp_dir}\")\r",
            "        return cls._temp_dir\r",
            "\r",
            "    def save(self):\r",
            "        logger.info(\"Saving...\")\r",
            "\r",
            "        logger.info(\"field value is a file! %s\", self.key)\r",
            "        file = request.files[self.key]\r",
            "        # if user does not select file, browser also\r",
            "        # submit a empty part without filename\r",
            "        if file.filename == \"\":\r",
            "            raise ValueError(\"No selected file\")\r",
            "        elif file and file.filename:\r",
            "            filename = secure_filename(file.filename)\r",
            "            name, suffix = os.path.splitext(filename)\r",
            "\r",
            "            fd, filename = tempfile.mkstemp(\r",
            "                dir=self.temp_dir(), prefix=name, suffix=suffix\r",
            "            )\r",
            "            self.file_path = filename\r",
            "            logger.info(f\"Saving {self.key} to {filename}\")\r",
            "            file.save(filename)\r",
            "\r",
            "    def __str__(self):\r",
            "\r",
            "        res = [super().__str__()]\r",
            "        res.append(f\"file_path: {self.file_path}\")\r",
            "        return \", \".join(res)\r",
            "\r",
            "\r",
            "class FieldOutFileInfo(FieldFileInfo):\r",
            "    \"\"\"\r",
            "    Used when file option is just for output and form posted it as hidden or text field.\r",
            "    Just create a empty temp file to give it's path to command.\r",
            "    \"\"\"\r",
            "\r",
            "    def __init__(self, fimeta):\r",
            "        super().__init__(fimeta)\r",
            "        if self.param.form_type == \"text\":\r",
            "            self.link_name = request.form[self.key]\r",
            "            # set the postfix to name name provided from form\r",
            "            # this way it will at least have the same extension when downloaded\r",
            "            self.file_suffix = request.form[self.key]\r",
            "        else:\r",
            "            # hidden no preferred file name can be provided by user\r",
            "            self.file_suffix = \".out\"\r",
            "\r",
            "    def save(self):\r",
            "        name = secure_filename(self.key)\r",
            "\r",
            "        filename = tempfile.mkstemp(\r",
            "            dir=self.temp_dir(), prefix=name, suffix=self.file_suffix\r",
            "        )\r",
            "        logger.info(f\"Creating empty file for {self.key} as {filename}\")\r",
            "        self.file_path = filename\r",
            "\r",
            "\r",
            "class FieldPathInfo(FieldFileInfo):\r",
            "    \"\"\"\r",
            "    Use for processing input fields of path type.\r",
            "    Extracts the posted data to a temp folder.\r",
            "    When script finished zip that folder and provide download link to zip file.\r",
            "    \"\"\"\r",
            "\r",
            "    def save(self):\r",
            "        super().save()\r",
            "        zip_extract_dir = tempfile.mkdtemp(dir=self.temp_dir())\r",
            "\r",
            "        logger.info(f\"Extracting: {self.file_path} to {zip_extract_dir}\")\r",
            "        shutil.unpack_archive(self.file_path, zip_extract_dir, \"zip\")\r",
            "        self.file_path = zip_extract_dir\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        super().after_script_executed()\r",
            "        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r",
            "        folder_path = self.file_path\r",
            "        self.file_path = filename\r",
            "\r",
            "        logger.info(f\"Zipping {self.key} to {filename}\")\r",
            "        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r",
            "        logger.info(f\"Zip file created {self.file_path}\")\r",
            "        self.generate_download_link = True\r",
            "\r",
            "\r",
            "class FieldPathOutInfo(FieldOutFileInfo):\r",
            "    \"\"\"\r",
            "    Use for processing output fields of path type.\r",
            "    Create a folder and use as path to script.\r",
            "    When script finished zip that folder and provide download link to zip file.\r",
            "    \"\"\"\r",
            "\r",
            "    def save(self):\r",
            "        super().save()\r",
            "        self.file_path = tempfile.mkdtemp(dir=self.temp_dir())\r",
            "\r",
            "    def after_script_executed(self):\r",
            "        super().after_script_executed()\r",
            "        fd, filename = tempfile.mkstemp(dir=self.temp_dir(), prefix=self.key)\r",
            "        folder_path = self.file_path\r",
            "        self.file_path = filename\r",
            "        logger.info(f\"Zipping {self.key} to {filename}\")\r",
            "        self.file_path = shutil.make_archive(self.file_path, \"zip\", folder_path)\r",
            "        logger.info(f\"Zip file created {self.file_path}\")\r",
            "        self.generate_download_link = True\r"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "140": [
                "RequestToCommandArgs",
                "__init__"
            ],
            "141": [
                "RequestToCommandArgs",
                "__init__"
            ],
            "142": [
                "RequestToCommandArgs",
                "__init__"
            ],
            "143": [
                "RequestToCommandArgs",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "archivy/routes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         return redirect(f\"/dataobj/{dataobj_id}\")"
            },
            "1": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"DELETE\", \"GET\"])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])"
            },
            "5": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " def delete_data(dataobj_id):"
            },
            "6": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     try:"
            },
            "7": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         data.delete_item(dataobj_id)"
            }
        },
        "frontPatchFile": [
            "from pathlib import Path",
            "from os.path import sep",
            "from pkg_resources import require",
            "from shutil import which",
            "",
            "import frontmatter",
            "from flask import (",
            "    render_template,",
            "    flash,",
            "    redirect,",
            "    request,",
            "    url_for,",
            "    send_file,",
            "    send_from_directory,",
            ")",
            "from flask_login import login_user, current_user, logout_user",
            "from tinydb import Query",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from archivy.models import DataObj, User",
            "from archivy import data, app, forms",
            "from archivy.helpers import get_db, write_config",
            "from archivy.tags import get_all_tags",
            "from archivy.search import search",
            "from archivy.config import Config",
            "",
            "import re",
            "",
            "",
            "@app.context_processor",
            "def pass_defaults():",
            "    dataobjs = data.get_items(load_content=False)",
            "    version = require(\"archivy\")[0].version",
            "    SEP = sep",
            "    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)",
            "    if SEP == \"\\\\\":",
            "        SEP += \"\\\\\"",
            "    return dict(dataobjs=dataobjs, SEP=SEP, version=version)",
            "",
            "",
            "@app.before_request",
            "def check_perms():",
            "    allowed_path = (",
            "        request.path.startswith(\"/login\")",
            "        or request.path.startswith(\"/static\")",
            "        or request.path.startswith(\"/api/login\")",
            "    )",
            "    if not current_user.is_authenticated and not allowed_path:",
            "        return redirect(url_for(\"login\", next=request.path))",
            "    return",
            "",
            "",
            "@app.route(\"/\")",
            "@app.route(\"/index\")",
            "def index():",
            "    path = request.args.get(\"path\", \"\").lstrip(\"/\")",
            "    try:",
            "        files = data.get_items(path=path)",
            "    except FileNotFoundError:",
            "        flash(\"Directory does not exist.\", \"error\")",
            "        return redirect(\"/\")",
            "",
            "    return render_template(",
            "        \"home.html\",",
            "        title=path or \"root\",",
            "        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],",
            "        dir=files,",
            "        current_path=path,",
            "        new_folder_form=forms.NewFolderForm(),",
            "        delete_form=forms.DeleteFolderForm(),",
            "        rename_form=forms.RenameDirectoryForm(),",
            "        view_only=0,",
            "        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],",
            "    )",
            "",
            "",
            "# TODO: refactor two following methods",
            "@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])",
            "def new_bookmark():",
            "    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")",
            "    form = forms.NewBookmarkForm(path=default_dir)",
            "    form.path.choices = [(\"\", \"root directory\")] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "    if form.validate_on_submit():",
            "        path = form.path.data",
            "        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []",
            "        tags = [tag.strip() for tag in tags]",
            "        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")",
            "        bookmark.process_bookmark_url()",
            "        bookmark_id = bookmark.insert()",
            "        if bookmark_id:",
            "            flash(\"Bookmark Saved!\", \"success\")",
            "            return redirect(f\"/dataobj/{bookmark_id}\")",
            "        else:",
            "            flash(bookmark.error, \"error\")",
            "            return redirect(\"/bookmarks/new\")",
            "    # for bookmarklet",
            "    form.url.data = request.args.get(\"url\", \"\")",
            "    path = request.args.get(\"path\", default_dir).strip(\"/\")",
            "    # handle empty argument",
            "    form.path.data = path",
            "    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)",
            "",
            "",
            "@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])",
            "def new_note():",
            "    form = forms.NewNoteForm()",
            "    default_dir = \"root directory\"",
            "    form.path.choices = [(\"\", default_dir)] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "    if form.validate_on_submit():",
            "        path = form.path.data",
            "        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []",
            "        tags = [tag.strip() for tag in tags]",
            "        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")",
            "        note_id = note.insert()",
            "        if note_id:",
            "            flash(\"Note Saved!\", \"success\")",
            "            return redirect(f\"/dataobj/{note_id}\")",
            "    path = request.args.get(\"path\", default_dir).strip(\"/\")",
            "    # handle empty argument",
            "    form.path.data = path",
            "    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)",
            "",
            "",
            "@app.route(\"/tags\")",
            "def show_all_tags():",
            "    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):",
            "        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")",
            "        return redirect(\"/\")",
            "    tags = sorted(get_all_tags(force=True))",
            "    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)",
            "",
            "",
            "@app.route(\"/tags/<tag_name>\")",
            "def show_tag(tag_name):",
            "    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):",
            "        flash(",
            "            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",",
            "            \"error\",",
            "        )",
            "        return redirect(\"/\")",
            "",
            "    search_results = search(f\"#{tag_name}#\", strict=True)",
            "",
            "    return render_template(",
            "        \"tags/show.html\",",
            "        title=f\"Tags - {tag_name}\",",
            "        tag_name=tag_name,",
            "        search_result=search_results,",
            "    )",
            "",
            "",
            "@app.route(\"/dataobj/<int:dataobj_id>\")",
            "def show_dataobj(dataobj_id):",
            "    dataobj = data.get_item(dataobj_id)",
            "    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])",
            "    titles = list(",
            "        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))",
            "    )",
            "",
            "    if not dataobj:",
            "        flash(\"Data could not be found!\", \"error\")",
            "        return redirect(\"/\")",
            "",
            "    if request.args.get(\"raw\") == \"1\":",
            "        return frontmatter.dumps(dataobj)",
            "",
            "    backlinks = []",
            "    if app.config[\"SEARCH_CONF\"][\"enabled\"]:",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":",
            "            query = f\"\\|{dataobj_id}]]\"",
            "        else:",
            "            query = f\"|{dataobj_id})]]\"",
            "        backlinks = search(query, strict=True)",
            "",
            "    # Form for moving data into another folder",
            "    move_form = forms.MoveItemForm()",
            "    move_form.path.choices = [(\"\", \"root directory\")] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "",
            "    post_title_form = forms.TitleForm()",
            "    post_title_form.title.data = dataobj[\"title\"]",
            "",
            "    # Get all tags",
            "    tag_list = get_all_tags()",
            "    # and the ones present in this dataobj",
            "    embedded_tags = set()",
            "    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"",
            "    for match in re.finditer(PATTERN, dataobj.content):",
            "        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())",
            "",
            "    return render_template(",
            "        \"dataobjs/show.html\",",
            "        title=dataobj[\"title\"],",
            "        dataobj=dataobj,",
            "        backlinks=backlinks,",
            "        current_path=dataobj[\"dir\"],",
            "        form=forms.DeleteDataForm(),",
            "        view_only=0,",
            "        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],",
            "        post_title_form=post_title_form,",
            "        move_form=move_form,",
            "        tag_list=tag_list,",
            "        embedded_tags=embedded_tags,",
            "        titles=titles,",
            "    )",
            "",
            "",
            "@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])",
            "def move_item(dataobj_id):",
            "    form = forms.MoveItemForm()",
            "    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"",
            "    if form.path.data == None:",
            "        flash(\"No path specified.\")",
            "        return redirect(f\"/dataobj/{dataobj_id}\")",
            "    try:",
            "        if data.move_item(dataobj_id, form.path.data):",
            "            flash(f\"Data successfully moved to {out_dir}.\", \"success\")",
            "            return redirect(f\"/dataobj/{dataobj_id}\")",
            "        else:",
            "            flash(f\"Data could not be moved to {out_dir}.\", \"error\")",
            "            return redirect(f\"/dataobj/{dataobj_id}\")",
            "    except FileNotFoundError:",
            "        flash(\"Data not found.\", \"error\")",
            "        return redirect(\"/\")",
            "    except FileExistsError:",
            "        flash(\"Data already in target directory.\", \"error\")",
            "        return redirect(f\"/dataobj/{dataobj_id}\")",
            "",
            "",
            "@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"DELETE\", \"GET\"])",
            "def delete_data(dataobj_id):",
            "    try:",
            "        data.delete_item(dataobj_id)",
            "    except BaseException:",
            "        flash(\"Data could not be found!\", \"error\")",
            "        return redirect(\"/\")",
            "    flash(\"Data deleted!\", \"success\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/login\", methods=[\"GET\", \"POST\"])",
            "def login():",
            "    form = forms.UserForm()",
            "    if form.validate_on_submit():",
            "        db = get_db()",
            "        user = db.search(",
            "            (Query().username == form.username.data) & (Query().type == \"user\")",
            "        )",
            "",
            "        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):",
            "            user = User.from_db(user[0])",
            "            login_user(user, remember=True)",
            "            flash(\"Login successful!\", \"success\")",
            "",
            "            next_url = request.args.get(\"next\")",
            "            return redirect(next_url or \"/\")",
            "",
            "        flash(\"Invalid credentials\", \"error\")",
            "        return redirect(\"/login\")",
            "    return render_template(\"users/login.html\", form=form, title=\"Login\")",
            "",
            "",
            "@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])",
            "def logout():",
            "    logout_user()",
            "    flash(\"Logged out successfully\", \"success\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])",
            "def edit_user():",
            "    form = forms.UserForm()",
            "    if form.validate_on_submit():",
            "        db = get_db()",
            "        db.update(",
            "            {",
            "                \"username\": form.username.data,",
            "                \"hashed_password\": generate_password_hash(form.password.data),",
            "            },",
            "            doc_ids=[current_user.id],",
            "        )",
            "        flash(\"Information saved!\", \"success\")",
            "        return redirect(\"/\")",
            "    form.username.data = current_user.username",
            "    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")",
            "",
            "",
            "@app.route(\"/folders/create\", methods=[\"POST\"])",
            "def create_folder():",
            "    form = forms.NewFolderForm()",
            "    if form.validate_on_submit():",
            "        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data",
            "        new_path = data.create_dir(str(path))",
            "        flash(\"Folder successfully created.\", \"success\")",
            "        return redirect(f\"/?path={new_path}\")",
            "    flash(\"Could not create folder.\", \"error\")",
            "    return redirect(request.referrer or \"/\")",
            "",
            "",
            "@app.route(\"/folders/delete\", methods=[\"POST\"])",
            "def delete_folder():",
            "    form = forms.DeleteFolderForm()",
            "    if form.validate_on_submit():",
            "        if data.delete_dir(form.dir_name.data):",
            "            flash(\"Folder successfully deleted.\", \"success\")",
            "            return redirect(\"/\")",
            "        else:",
            "            flash(\"Folder not found.\", \"error\")",
            "            return redirect(request.referrer or \"/\", 404)",
            "    flash(\"Could not delete folder.\", \"error\")",
            "    return redirect(request.referrer or \"/\")",
            "",
            "",
            "@app.route(\"/folders/rename\", methods=[\"POST\"])",
            "def rename_folder():",
            "    form = forms.RenameDirectoryForm()",
            "    if form.validate_on_submit():",
            "        try:",
            "            new_path = data.rename_folder(form.current_path.data, form.new_name.data)",
            "            if not new_path:",
            "                flash(\"Invalid input.\", \"error\")",
            "            else:",
            "                flash(\"Renamed successfully.\", \"success\")",
            "                return redirect(f\"/?path={new_path}\")",
            "        except FileNotFoundError:",
            "            flash(\"Directory not found.\", \"error\")",
            "        except FileExistsError:",
            "            flash(\"Target directory exists.\", \"error\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/bookmarklet\")",
            "def bookmarklet():",
            "    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")",
            "",
            "",
            "@app.route(\"/images/<filename>\")",
            "def serve_image(filename):",
            "    if filename and data.valid_image_filename(filename):",
            "        image_path = data.image_exists(filename)",
            "        if image_path:",
            "            return send_file(image_path)",
            "        else:",
            "            return \"Image not found\", 404",
            "    else:",
            "        return \"Invalid file request\", 413",
            "",
            "",
            "@app.route(\"/static/custom.css\")",
            "def custom_css():",
            "    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):",
            "        return \"\"",
            "    return send_from_directory(",
            "        Path(app.config[\"USER_DIR\"]) / \"css\",",
            "        app.config[\"THEME_CONF\"][\"custom_css_file\"],",
            "    )",
            "",
            "",
            "@app.route(\"/config\", methods=[\"GET\", \"POST\"])",
            "def config():",
            "    \"\"\"",
            "    Web View to edit and update configuration.",
            "    \"\"\"",
            "",
            "    def update_config_value(key, val, dictionary):",
            "        if key != \"SECRET_KEY\":",
            "            if type(val) is dict:",
            "                for k, v in val.items():",
            "                    update_config_value(k, v, dictionary[key])",
            "            else:",
            "                dictionary[key] = val",
            "",
            "    form = forms.config_form(app.config)",
            "    default = vars(Config())",
            "    if form.validate_on_submit():",
            "        changed_config = Config()",
            "        changed_config.override(form.data)",
            "        for k, v in vars(changed_config).items():",
            "            # propagate changes to configuration",
            "            update_config_value(k, v, app.config)",
            "        write_config(vars(changed_config))  # save to filesystem config",
            "        flash(\"Config successfully updated.\", \"success\")",
            "    elif request.method == \"POST\":",
            "        flash(\"Could not update config.\", \"error\")",
            "    return render_template(",
            "        \"config.html\", conf=form, default=default, title=\"Edit Config\"",
            "    )"
        ],
        "afterPatchFile": [
            "from pathlib import Path",
            "from os.path import sep",
            "from pkg_resources import require",
            "from shutil import which",
            "",
            "import frontmatter",
            "from flask import (",
            "    render_template,",
            "    flash,",
            "    redirect,",
            "    request,",
            "    url_for,",
            "    send_file,",
            "    send_from_directory,",
            ")",
            "from flask_login import login_user, current_user, logout_user",
            "from tinydb import Query",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from archivy.models import DataObj, User",
            "from archivy import data, app, forms",
            "from archivy.helpers import get_db, write_config",
            "from archivy.tags import get_all_tags",
            "from archivy.search import search",
            "from archivy.config import Config",
            "",
            "import re",
            "",
            "",
            "@app.context_processor",
            "def pass_defaults():",
            "    dataobjs = data.get_items(load_content=False)",
            "    version = require(\"archivy\")[0].version",
            "    SEP = sep",
            "    # check windows parsing for js (https://github.com/Uzay-G/archivy/issues/115)",
            "    if SEP == \"\\\\\":",
            "        SEP += \"\\\\\"",
            "    return dict(dataobjs=dataobjs, SEP=SEP, version=version)",
            "",
            "",
            "@app.before_request",
            "def check_perms():",
            "    allowed_path = (",
            "        request.path.startswith(\"/login\")",
            "        or request.path.startswith(\"/static\")",
            "        or request.path.startswith(\"/api/login\")",
            "    )",
            "    if not current_user.is_authenticated and not allowed_path:",
            "        return redirect(url_for(\"login\", next=request.path))",
            "    return",
            "",
            "",
            "@app.route(\"/\")",
            "@app.route(\"/index\")",
            "def index():",
            "    path = request.args.get(\"path\", \"\").lstrip(\"/\")",
            "    try:",
            "        files = data.get_items(path=path)",
            "    except FileNotFoundError:",
            "        flash(\"Directory does not exist.\", \"error\")",
            "        return redirect(\"/\")",
            "",
            "    return render_template(",
            "        \"home.html\",",
            "        title=path or \"root\",",
            "        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],",
            "        dir=files,",
            "        current_path=path,",
            "        new_folder_form=forms.NewFolderForm(),",
            "        delete_form=forms.DeleteFolderForm(),",
            "        rename_form=forms.RenameDirectoryForm(),",
            "        view_only=0,",
            "        search_engine=app.config[\"SEARCH_CONF\"][\"engine\"],",
            "    )",
            "",
            "",
            "# TODO: refactor two following methods",
            "@app.route(\"/bookmarks/new\", methods=[\"GET\", \"POST\"])",
            "def new_bookmark():",
            "    default_dir = app.config.get(\"DEFAULT_BOOKMARKS_DIR\", \"root directory\")",
            "    form = forms.NewBookmarkForm(path=default_dir)",
            "    form.path.choices = [(\"\", \"root directory\")] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "    if form.validate_on_submit():",
            "        path = form.path.data",
            "        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []",
            "        tags = [tag.strip() for tag in tags]",
            "        bookmark = DataObj(url=form.url.data, tags=tags, path=path, type=\"bookmark\")",
            "        bookmark.process_bookmark_url()",
            "        bookmark_id = bookmark.insert()",
            "        if bookmark_id:",
            "            flash(\"Bookmark Saved!\", \"success\")",
            "            return redirect(f\"/dataobj/{bookmark_id}\")",
            "        else:",
            "            flash(bookmark.error, \"error\")",
            "            return redirect(\"/bookmarks/new\")",
            "    # for bookmarklet",
            "    form.url.data = request.args.get(\"url\", \"\")",
            "    path = request.args.get(\"path\", default_dir).strip(\"/\")",
            "    # handle empty argument",
            "    form.path.data = path",
            "    return render_template(\"dataobjs/new.html\", title=\"New Bookmark\", form=form)",
            "",
            "",
            "@app.route(\"/notes/new\", methods=[\"GET\", \"POST\"])",
            "def new_note():",
            "    form = forms.NewNoteForm()",
            "    default_dir = \"root directory\"",
            "    form.path.choices = [(\"\", default_dir)] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "    if form.validate_on_submit():",
            "        path = form.path.data",
            "        tags = form.tags.data.split(\",\") if form.tags.data != \"\" else []",
            "        tags = [tag.strip() for tag in tags]",
            "        note = DataObj(title=form.title.data, path=path, tags=tags, type=\"note\")",
            "        note_id = note.insert()",
            "        if note_id:",
            "            flash(\"Note Saved!\", \"success\")",
            "            return redirect(f\"/dataobj/{note_id}\")",
            "    path = request.args.get(\"path\", default_dir).strip(\"/\")",
            "    # handle empty argument",
            "    form.path.data = path",
            "    return render_template(\"/dataobjs/new.html\", title=\"New Note\", form=form)",
            "",
            "",
            "@app.route(\"/tags\")",
            "def show_all_tags():",
            "    if not app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\" and not which(\"rg\"):",
            "        flash(\"Ripgrep must be installed to view pages about embedded tags.\", \"error\")",
            "        return redirect(\"/\")",
            "    tags = sorted(get_all_tags(force=True))",
            "    return render_template(\"tags/all.html\", title=\"All Tags\", tags=tags)",
            "",
            "",
            "@app.route(\"/tags/<tag_name>\")",
            "def show_tag(tag_name):",
            "    if not app.config[\"SEARCH_CONF\"][\"enabled\"] and not which(\"rg\"):",
            "        flash(",
            "            \"Search (for example ripgrep) must be installed to view pages about embedded tags.\",",
            "            \"error\",",
            "        )",
            "        return redirect(\"/\")",
            "",
            "    search_results = search(f\"#{tag_name}#\", strict=True)",
            "",
            "    return render_template(",
            "        \"tags/show.html\",",
            "        title=f\"Tags - {tag_name}\",",
            "        tag_name=tag_name,",
            "        search_result=search_results,",
            "    )",
            "",
            "",
            "@app.route(\"/dataobj/<int:dataobj_id>\")",
            "def show_dataobj(dataobj_id):",
            "    dataobj = data.get_item(dataobj_id)",
            "    get_title_id_pairs = lambda x: (x[\"title\"], x[\"id\"])",
            "    titles = list(",
            "        map(get_title_id_pairs, data.get_items(structured=False, load_content=False))",
            "    )",
            "",
            "    if not dataobj:",
            "        flash(\"Data could not be found!\", \"error\")",
            "        return redirect(\"/\")",
            "",
            "    if request.args.get(\"raw\") == \"1\":",
            "        return frontmatter.dumps(dataobj)",
            "",
            "    backlinks = []",
            "    if app.config[\"SEARCH_CONF\"][\"enabled\"]:",
            "        if app.config[\"SEARCH_CONF\"][\"engine\"] == \"ripgrep\":",
            "            query = f\"\\|{dataobj_id}]]\"",
            "        else:",
            "            query = f\"|{dataobj_id})]]\"",
            "        backlinks = search(query, strict=True)",
            "",
            "    # Form for moving data into another folder",
            "    move_form = forms.MoveItemForm()",
            "    move_form.path.choices = [(\"\", \"root directory\")] + [",
            "        (pathname, pathname) for pathname in data.get_dirs()",
            "    ]",
            "",
            "    post_title_form = forms.TitleForm()",
            "    post_title_form.title.data = dataobj[\"title\"]",
            "",
            "    # Get all tags",
            "    tag_list = get_all_tags()",
            "    # and the ones present in this dataobj",
            "    embedded_tags = set()",
            "    PATTERN = r\"(?:^|\\n| )#(?:[-_a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9]+)#\"",
            "    for match in re.finditer(PATTERN, dataobj.content):",
            "        embedded_tags.add(match.group(0).replace(\"#\", \"\").lstrip())",
            "",
            "    return render_template(",
            "        \"dataobjs/show.html\",",
            "        title=dataobj[\"title\"],",
            "        dataobj=dataobj,",
            "        backlinks=backlinks,",
            "        current_path=dataobj[\"dir\"],",
            "        form=forms.DeleteDataForm(),",
            "        view_only=0,",
            "        search_enabled=app.config[\"SEARCH_CONF\"][\"enabled\"],",
            "        post_title_form=post_title_form,",
            "        move_form=move_form,",
            "        tag_list=tag_list,",
            "        embedded_tags=embedded_tags,",
            "        titles=titles,",
            "    )",
            "",
            "",
            "@app.route(\"/dataobj/move/<int:dataobj_id>\", methods=[\"POST\"])",
            "def move_item(dataobj_id):",
            "    form = forms.MoveItemForm()",
            "    out_dir = form.path.data if form.path.data != \"\" else \"root directory\"",
            "    if form.path.data == None:",
            "        flash(\"No path specified.\")",
            "        return redirect(f\"/dataobj/{dataobj_id}\")",
            "    try:",
            "        if data.move_item(dataobj_id, form.path.data):",
            "            flash(f\"Data successfully moved to {out_dir}.\", \"success\")",
            "            return redirect(f\"/dataobj/{dataobj_id}\")",
            "        else:",
            "            flash(f\"Data could not be moved to {out_dir}.\", \"error\")",
            "            return redirect(f\"/dataobj/{dataobj_id}\")",
            "    except FileNotFoundError:",
            "        flash(\"Data not found.\", \"error\")",
            "        return redirect(\"/\")",
            "    except FileExistsError:",
            "        flash(\"Data already in target directory.\", \"error\")",
            "        return redirect(f\"/dataobj/{dataobj_id}\")",
            "",
            "",
            "@app.route(\"/dataobj/delete/<int:dataobj_id>\", methods=[\"POST\"])",
            "def delete_data(dataobj_id):",
            "    try:",
            "        data.delete_item(dataobj_id)",
            "    except BaseException:",
            "        flash(\"Data could not be found!\", \"error\")",
            "        return redirect(\"/\")",
            "    flash(\"Data deleted!\", \"success\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/login\", methods=[\"GET\", \"POST\"])",
            "def login():",
            "    form = forms.UserForm()",
            "    if form.validate_on_submit():",
            "        db = get_db()",
            "        user = db.search(",
            "            (Query().username == form.username.data) & (Query().type == \"user\")",
            "        )",
            "",
            "        if user and check_password_hash(user[0][\"hashed_password\"], form.password.data):",
            "            user = User.from_db(user[0])",
            "            login_user(user, remember=True)",
            "            flash(\"Login successful!\", \"success\")",
            "",
            "            next_url = request.args.get(\"next\")",
            "            return redirect(next_url or \"/\")",
            "",
            "        flash(\"Invalid credentials\", \"error\")",
            "        return redirect(\"/login\")",
            "    return render_template(\"users/login.html\", form=form, title=\"Login\")",
            "",
            "",
            "@app.route(\"/logout\", methods=[\"DELETE\", \"GET\"])",
            "def logout():",
            "    logout_user()",
            "    flash(\"Logged out successfully\", \"success\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/user/edit\", methods=[\"GET\", \"POST\"])",
            "def edit_user():",
            "    form = forms.UserForm()",
            "    if form.validate_on_submit():",
            "        db = get_db()",
            "        db.update(",
            "            {",
            "                \"username\": form.username.data,",
            "                \"hashed_password\": generate_password_hash(form.password.data),",
            "            },",
            "            doc_ids=[current_user.id],",
            "        )",
            "        flash(\"Information saved!\", \"success\")",
            "        return redirect(\"/\")",
            "    form.username.data = current_user.username",
            "    return render_template(\"users/edit.html\", form=form, title=\"Edit Profile\")",
            "",
            "",
            "@app.route(\"/folders/create\", methods=[\"POST\"])",
            "def create_folder():",
            "    form = forms.NewFolderForm()",
            "    if form.validate_on_submit():",
            "        path = Path(form.parent_dir.data.strip(\"/\")) / form.new_dir.data",
            "        new_path = data.create_dir(str(path))",
            "        flash(\"Folder successfully created.\", \"success\")",
            "        return redirect(f\"/?path={new_path}\")",
            "    flash(\"Could not create folder.\", \"error\")",
            "    return redirect(request.referrer or \"/\")",
            "",
            "",
            "@app.route(\"/folders/delete\", methods=[\"POST\"])",
            "def delete_folder():",
            "    form = forms.DeleteFolderForm()",
            "    if form.validate_on_submit():",
            "        if data.delete_dir(form.dir_name.data):",
            "            flash(\"Folder successfully deleted.\", \"success\")",
            "            return redirect(\"/\")",
            "        else:",
            "            flash(\"Folder not found.\", \"error\")",
            "            return redirect(request.referrer or \"/\", 404)",
            "    flash(\"Could not delete folder.\", \"error\")",
            "    return redirect(request.referrer or \"/\")",
            "",
            "",
            "@app.route(\"/folders/rename\", methods=[\"POST\"])",
            "def rename_folder():",
            "    form = forms.RenameDirectoryForm()",
            "    if form.validate_on_submit():",
            "        try:",
            "            new_path = data.rename_folder(form.current_path.data, form.new_name.data)",
            "            if not new_path:",
            "                flash(\"Invalid input.\", \"error\")",
            "            else:",
            "                flash(\"Renamed successfully.\", \"success\")",
            "                return redirect(f\"/?path={new_path}\")",
            "        except FileNotFoundError:",
            "            flash(\"Directory not found.\", \"error\")",
            "        except FileExistsError:",
            "            flash(\"Target directory exists.\", \"error\")",
            "    return redirect(\"/\")",
            "",
            "",
            "@app.route(\"/bookmarklet\")",
            "def bookmarklet():",
            "    return render_template(\"bookmarklet.html\", title=\"Bookmarklet\")",
            "",
            "",
            "@app.route(\"/images/<filename>\")",
            "def serve_image(filename):",
            "    if filename and data.valid_image_filename(filename):",
            "        image_path = data.image_exists(filename)",
            "        if image_path:",
            "            return send_file(image_path)",
            "        else:",
            "            return \"Image not found\", 404",
            "    else:",
            "        return \"Invalid file request\", 413",
            "",
            "",
            "@app.route(\"/static/custom.css\")",
            "def custom_css():",
            "    if not app.config[\"THEME_CONF\"].get(\"use_custom_css\", False):",
            "        return \"\"",
            "    return send_from_directory(",
            "        Path(app.config[\"USER_DIR\"]) / \"css\",",
            "        app.config[\"THEME_CONF\"][\"custom_css_file\"],",
            "    )",
            "",
            "",
            "@app.route(\"/config\", methods=[\"GET\", \"POST\"])",
            "def config():",
            "    \"\"\"",
            "    Web View to edit and update configuration.",
            "    \"\"\"",
            "",
            "    def update_config_value(key, val, dictionary):",
            "        if key != \"SECRET_KEY\":",
            "            if type(val) is dict:",
            "                for k, v in val.items():",
            "                    update_config_value(k, v, dictionary[key])",
            "            else:",
            "                dictionary[key] = val",
            "",
            "    form = forms.config_form(app.config)",
            "    default = vars(Config())",
            "    if form.validate_on_submit():",
            "        changed_config = Config()",
            "        changed_config.override(form.data)",
            "        for k, v in vars(changed_config).items():",
            "            # propagate changes to configuration",
            "            update_config_value(k, v, app.config)",
            "        write_config(vars(changed_config))  # save to filesystem config",
            "        flash(\"Config successfully updated.\", \"success\")",
            "    elif request.method == \"POST\":",
            "        flash(\"Could not update config.\", \"error\")",
            "    return render_template(",
            "        \"config.html\", conf=form, default=default, title=\"Edit Config\"",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "235": []
        },
        "addLocation": []
    }
}