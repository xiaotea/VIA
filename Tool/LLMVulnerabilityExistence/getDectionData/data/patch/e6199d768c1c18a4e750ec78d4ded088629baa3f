{
    "lib/ansible/modules/net_tools/ldap/ldap_attr.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     rules. This should work out in most cases, but it is theoretically"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     possible to see spurious changes when target and actual values are"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     semantically identical but lexically distinct."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+  - \"The I(params) parameter is deprecated in Ansible-2.7 due to circumventing Ansible's parameter"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+     handling. The I(params) parameter started disallowing setting the I(bind_pw) parameter in Ansible-2.7"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+     as it was insecure to set the parameter that way.\""
            },
            "6": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " version_added: '2.3'"
            },
            "7": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " author:"
            },
            "8": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "   - Jiri Tyr (@jtyr)"
            },
            "9": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         a list of strings (see examples)."
            },
            "10": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     type: raw"
            },
            "11": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     required: true"
            },
            "12": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  params:"
            },
            "13": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    description:"
            },
            "14": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    - Additional module parameters."
            },
            "15": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    type: dict"
            },
            "16": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " extends_documentation_fragment:"
            },
            "17": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " - ldap.documentation"
            },
            "18": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " '''"
            },
            "19": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " #   server_uri: ldap://localhost/"
            },
            "20": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " #   bind_dn: cn=admin,dc=example,dc=com"
            },
            "21": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " #   bind_pw: password"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+#"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+# In the example below, 'args' is a task keyword, passed at the same level as the module"
            },
            "24": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " - name: Get rid of an unneeded attribute"
            },
            "25": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "   ldap_attr:"
            },
            "26": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     dn: uid=jdoe,ou=people,dc=example,dc=com"
            },
            "27": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     name: shadowExpire"
            },
            "28": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     values: []"
            },
            "29": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     state: exact"
            },
            "30": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    params: \"{{ ldap_auth }}\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+  args: \"{{ ldap_auth }}\""
            },
            "32": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " '''"
            },
            "33": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " RETURN = r'''"
            },
            "35": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " '''"
            },
            "36": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " import traceback"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+from distutils.version import LooseVersion"
            },
            "39": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " from ansible.module_utils.basic import AnsibleModule, missing_required_lib"
            },
            "41": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " from ansible.module_utils._text import to_native, to_bytes"
            },
            "42": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         module.fail_json(msg=missing_required_lib('python-ldap'),"
            },
            "43": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "                          exception=LDAP_IMP_ERR)"
            },
            "44": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Update module parameters with user's parameters if defined"
            },
            "46": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'params' in module.params and isinstance(module.params['params'], dict):"
            },
            "47": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        module.params.update(module.params['params'])"
            },
            "48": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Remove the params"
            },
            "49": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        module.params.pop('params', None)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+    # For Ansible-2.9.x and below, allow the params module parameter with a warning"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    if LooseVersion(module.ansible_version) < LooseVersion('2.10'):"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        if module.params['params']:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            module.deprecate(\"The `params` option to ldap_attr will be removed in Ansible 2.10\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+                             \" since it circumvents Ansible's option handling\", version='2.10')"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+            # However, the bind_pw parameter contains a password so it **must** go through the normal"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            # argument parsing even though removing it breaks backwards compat."
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+            if 'bind_pw' in module.params['params']:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                module.fail_json(msg=\"Using `bind_pw` with the `params` option has been disallowed since\""
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                                 \" it is insecure.  Use the `bind_pw` option directly.  The `params`\""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                                 \" option will be removed in Ansible-2.10\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+            # Update module parameters with user's parameters if defined"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            module.params.update(module.params['params'])"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+            # Remove params itself"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            module.params.pop('params', None)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    else:"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+        # For Ansible 2.10 and above"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        if module.params['params']:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+            module.fail_json(msg=\"The `params` option to ldap_attr was removed in Ansible-2.10 since\""
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                             \" it circumvents Ansible's option handling\")"
            },
            "72": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "     # Instantiate the LdapAttr object"
            },
            "74": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "     ldap = LdapAttr(module)"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright: (c) 2016, Peter Sagerson <psagers@ignorare.net>",
            "# Copyright: (c) 2016, Jiri Tyr <jiri.tyr@gmail.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: ldap_attr",
            "short_description: Add or remove LDAP attribute values",
            "description:",
            "  - Add or remove LDAP attribute values.",
            "notes:",
            "  - This only deals with attributes on existing entries. To add or remove",
            "    whole entries, see M(ldap_entry).",
            "  - The default authentication settings will attempt to use a SASL EXTERNAL",
            "    bind over a UNIX domain socket. This works well with the default Ubuntu",
            "    install for example, which includes a cn=peercred,cn=external,cn=auth ACL",
            "    rule allowing root to modify the server configuration. If you need to use",
            "    a simple bind to access your server, pass the credentials in I(bind_dn)",
            "    and I(bind_pw).",
            "  - For I(state=present) and I(state=absent), all value comparisons are",
            "    performed on the server for maximum accuracy. For I(state=exact), values",
            "    have to be compared in Python, which obviously ignores LDAP matching",
            "    rules. This should work out in most cases, but it is theoretically",
            "    possible to see spurious changes when target and actual values are",
            "    semantically identical but lexically distinct.",
            "version_added: '2.3'",
            "author:",
            "  - Jiri Tyr (@jtyr)",
            "requirements:",
            "  - python-ldap",
            "options:",
            "  name:",
            "    description:",
            "      - The name of the attribute to modify.",
            "    type: str",
            "    required: true",
            "  state:",
            "    description:",
            "      - The state of the attribute values.",
            "      - If C(present), all given values will be added if they're missing.",
            "      - If C(absent), all given values will be removed if present.",
            "      - If C(exact), the set of values will be forced to exactly those provided and no others.",
            "      - If I(state=exact) and I(value) is an empty list, all values for this attribute will be removed.",
            "    choices: [ absent, exact, present ]",
            "    default: present",
            "  values:",
            "    description:",
            "      - The value(s) to add or remove. This can be a string or a list of",
            "        strings. The complex argument format is required in order to pass",
            "        a list of strings (see examples).",
            "    type: raw",
            "    required: true",
            "  params:",
            "    description:",
            "    - Additional module parameters.",
            "    type: dict",
            "extends_documentation_fragment:",
            "- ldap.documentation",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Configure directory number 1 for example.com",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcSuffix",
            "    values: dc=example,dc=com",
            "    state: exact",
            "",
            "# The complex argument format is required here to pass a list of ACL strings.",
            "- name: Set up the ACL",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcAccess",
            "    values:",
            "      - >-",
            "        {0}to attrs=userPassword,shadowLastChange",
            "        by self write",
            "        by anonymous auth",
            "        by dn=\"cn=admin,dc=example,dc=com\" write",
            "        by * none'",
            "      - >-",
            "        {1}to dn.base=\"dc=example,dc=com\"",
            "        by dn=\"cn=admin,dc=example,dc=com\" write",
            "        by * read",
            "    state: exact",
            "",
            "- name: Declare some indexes",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcDbIndex",
            "    values: \"{{ item }}\"",
            "  with_items:",
            "    - objectClass eq",
            "    - uid eq",
            "",
            "- name: Set up a root user, which we can use later to bootstrap the directory",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: \"{{ item.key }}\"",
            "    values: \"{{ item.value }}\"",
            "    state: exact",
            "  with_dict:",
            "    olcRootDN: cn=root,dc=example,dc=com",
            "    olcRootPW: \"{SSHA}tabyipcHzhwESzRaGA7oQ/SDoBZQOGND\"",
            "",
            "- name: Get rid of an unneeded attribute",
            "  ldap_attr:",
            "    dn: uid=jdoe,ou=people,dc=example,dc=com",
            "    name: shadowExpire",
            "    values: []",
            "    state: exact",
            "    server_uri: ldap://localhost/",
            "    bind_dn: cn=admin,dc=example,dc=com",
            "    bind_pw: password",
            "",
            "#",
            "# The same as in the previous example but with the authentication details",
            "# stored in the ldap_auth variable:",
            "#",
            "# ldap_auth:",
            "#   server_uri: ldap://localhost/",
            "#   bind_dn: cn=admin,dc=example,dc=com",
            "#   bind_pw: password",
            "- name: Get rid of an unneeded attribute",
            "  ldap_attr:",
            "    dn: uid=jdoe,ou=people,dc=example,dc=com",
            "    name: shadowExpire",
            "    values: []",
            "    state: exact",
            "    params: \"{{ ldap_auth }}\"",
            "'''",
            "",
            "RETURN = r'''",
            "modlist:",
            "  description: list of modified parameters",
            "  returned: success",
            "  type: list",
            "  sample: '[[2, \"olcRootDN\", [\"cn=root,dc=example,dc=com\"]]]'",
            "'''",
            "",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils._text import to_native, to_bytes",
            "from ansible.module_utils.ldap import LdapGeneric, gen_specs",
            "",
            "LDAP_IMP_ERR = None",
            "try:",
            "    import ldap",
            "",
            "    HAS_LDAP = True",
            "except ImportError:",
            "    LDAP_IMP_ERR = traceback.format_exc()",
            "    HAS_LDAP = False",
            "",
            "",
            "class LdapAttr(LdapGeneric):",
            "    def __init__(self, module):",
            "        LdapGeneric.__init__(self, module)",
            "",
            "        # Shortcuts",
            "        self.name = self.module.params['name']",
            "        self.state = self.module.params['state']",
            "",
            "        # Normalize values",
            "        if isinstance(self.module.params['values'], list):",
            "            self.values = list(map(to_bytes, self.module.params['values']))",
            "        else:",
            "            self.values = [to_bytes(self.module.params['values'])]",
            "",
            "    def add(self):",
            "        values_to_add = list(filter(self._is_value_absent, self.values))",
            "",
            "        if len(values_to_add) > 0:",
            "            modlist = [(ldap.MOD_ADD, self.name, values_to_add)]",
            "        else:",
            "            modlist = []",
            "",
            "        return modlist",
            "",
            "    def delete(self):",
            "        values_to_delete = list(filter(self._is_value_present, self.values))",
            "",
            "        if len(values_to_delete) > 0:",
            "            modlist = [(ldap.MOD_DELETE, self.name, values_to_delete)]",
            "        else:",
            "            modlist = []",
            "",
            "        return modlist",
            "",
            "    def exact(self):",
            "        try:",
            "            results = self.connection.search_s(",
            "                self.dn, ldap.SCOPE_BASE, attrlist=[self.name])",
            "        except ldap.LDAPError as e:",
            "            self.fail(\"Cannot search for attribute %s\" % self.name, e)",
            "",
            "        current = results[0][1].get(self.name, [])",
            "        modlist = []",
            "",
            "        if frozenset(self.values) != frozenset(current):",
            "            if len(current) == 0:",
            "                modlist = [(ldap.MOD_ADD, self.name, self.values)]",
            "            elif len(self.values) == 0:",
            "                modlist = [(ldap.MOD_DELETE, self.name, None)]",
            "            else:",
            "                modlist = [(ldap.MOD_REPLACE, self.name, self.values)]",
            "",
            "        return modlist",
            "",
            "    def _is_value_present(self, value):",
            "        \"\"\" True if the target attribute has the given value. \"\"\"",
            "        try:",
            "            is_present = bool(",
            "                self.connection.compare_s(self.dn, self.name, value))",
            "        except ldap.NO_SUCH_ATTRIBUTE:",
            "            is_present = False",
            "",
            "        return is_present",
            "",
            "    def _is_value_absent(self, value):",
            "        \"\"\" True if the target attribute doesn't have the given value. \"\"\"",
            "        return not self._is_value_present(value)",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=gen_specs(",
            "            name=dict(type='str', required=True),",
            "            params=dict(type='dict'),",
            "            state=dict(type='str', default='present', choices=['absent', 'exact', 'present']),",
            "            values=dict(type='raw', required=True),",
            "        ),",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    if not HAS_LDAP:",
            "        module.fail_json(msg=missing_required_lib('python-ldap'),",
            "                         exception=LDAP_IMP_ERR)",
            "",
            "    # Update module parameters with user's parameters if defined",
            "    if 'params' in module.params and isinstance(module.params['params'], dict):",
            "        module.params.update(module.params['params'])",
            "        # Remove the params",
            "        module.params.pop('params', None)",
            "",
            "    # Instantiate the LdapAttr object",
            "    ldap = LdapAttr(module)",
            "",
            "    state = module.params['state']",
            "",
            "    # Perform action",
            "    if state == 'present':",
            "        modlist = ldap.add()",
            "    elif state == 'absent':",
            "        modlist = ldap.delete()",
            "    elif state == 'exact':",
            "        modlist = ldap.exact()",
            "",
            "    changed = False",
            "",
            "    if len(modlist) > 0:",
            "        changed = True",
            "",
            "        if not module.check_mode:",
            "            try:",
            "                ldap.connection.modify_s(ldap.dn, modlist)",
            "            except Exception as e:",
            "                module.fail_json(msg=\"Attribute action failed.\", details=to_native(e))",
            "",
            "    module.exit_json(changed=changed, modlist=modlist)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright: (c) 2016, Peter Sagerson <psagers@ignorare.net>",
            "# Copyright: (c) 2016, Jiri Tyr <jiri.tyr@gmail.com>",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "DOCUMENTATION = r'''",
            "---",
            "module: ldap_attr",
            "short_description: Add or remove LDAP attribute values",
            "description:",
            "  - Add or remove LDAP attribute values.",
            "notes:",
            "  - This only deals with attributes on existing entries. To add or remove",
            "    whole entries, see M(ldap_entry).",
            "  - The default authentication settings will attempt to use a SASL EXTERNAL",
            "    bind over a UNIX domain socket. This works well with the default Ubuntu",
            "    install for example, which includes a cn=peercred,cn=external,cn=auth ACL",
            "    rule allowing root to modify the server configuration. If you need to use",
            "    a simple bind to access your server, pass the credentials in I(bind_dn)",
            "    and I(bind_pw).",
            "  - For I(state=present) and I(state=absent), all value comparisons are",
            "    performed on the server for maximum accuracy. For I(state=exact), values",
            "    have to be compared in Python, which obviously ignores LDAP matching",
            "    rules. This should work out in most cases, but it is theoretically",
            "    possible to see spurious changes when target and actual values are",
            "    semantically identical but lexically distinct.",
            "  - \"The I(params) parameter is deprecated in Ansible-2.7 due to circumventing Ansible's parameter",
            "     handling. The I(params) parameter started disallowing setting the I(bind_pw) parameter in Ansible-2.7",
            "     as it was insecure to set the parameter that way.\"",
            "version_added: '2.3'",
            "author:",
            "  - Jiri Tyr (@jtyr)",
            "requirements:",
            "  - python-ldap",
            "options:",
            "  name:",
            "    description:",
            "      - The name of the attribute to modify.",
            "    type: str",
            "    required: true",
            "  state:",
            "    description:",
            "      - The state of the attribute values.",
            "      - If C(present), all given values will be added if they're missing.",
            "      - If C(absent), all given values will be removed if present.",
            "      - If C(exact), the set of values will be forced to exactly those provided and no others.",
            "      - If I(state=exact) and I(value) is an empty list, all values for this attribute will be removed.",
            "    choices: [ absent, exact, present ]",
            "    default: present",
            "  values:",
            "    description:",
            "      - The value(s) to add or remove. This can be a string or a list of",
            "        strings. The complex argument format is required in order to pass",
            "        a list of strings (see examples).",
            "    type: raw",
            "    required: true",
            "extends_documentation_fragment:",
            "- ldap.documentation",
            "'''",
            "",
            "EXAMPLES = r'''",
            "- name: Configure directory number 1 for example.com",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcSuffix",
            "    values: dc=example,dc=com",
            "    state: exact",
            "",
            "# The complex argument format is required here to pass a list of ACL strings.",
            "- name: Set up the ACL",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcAccess",
            "    values:",
            "      - >-",
            "        {0}to attrs=userPassword,shadowLastChange",
            "        by self write",
            "        by anonymous auth",
            "        by dn=\"cn=admin,dc=example,dc=com\" write",
            "        by * none'",
            "      - >-",
            "        {1}to dn.base=\"dc=example,dc=com\"",
            "        by dn=\"cn=admin,dc=example,dc=com\" write",
            "        by * read",
            "    state: exact",
            "",
            "- name: Declare some indexes",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: olcDbIndex",
            "    values: \"{{ item }}\"",
            "  with_items:",
            "    - objectClass eq",
            "    - uid eq",
            "",
            "- name: Set up a root user, which we can use later to bootstrap the directory",
            "  ldap_attr:",
            "    dn: olcDatabase={1}hdb,cn=config",
            "    name: \"{{ item.key }}\"",
            "    values: \"{{ item.value }}\"",
            "    state: exact",
            "  with_dict:",
            "    olcRootDN: cn=root,dc=example,dc=com",
            "    olcRootPW: \"{SSHA}tabyipcHzhwESzRaGA7oQ/SDoBZQOGND\"",
            "",
            "- name: Get rid of an unneeded attribute",
            "  ldap_attr:",
            "    dn: uid=jdoe,ou=people,dc=example,dc=com",
            "    name: shadowExpire",
            "    values: []",
            "    state: exact",
            "    server_uri: ldap://localhost/",
            "    bind_dn: cn=admin,dc=example,dc=com",
            "    bind_pw: password",
            "",
            "#",
            "# The same as in the previous example but with the authentication details",
            "# stored in the ldap_auth variable:",
            "#",
            "# ldap_auth:",
            "#   server_uri: ldap://localhost/",
            "#   bind_dn: cn=admin,dc=example,dc=com",
            "#   bind_pw: password",
            "#",
            "# In the example below, 'args' is a task keyword, passed at the same level as the module",
            "- name: Get rid of an unneeded attribute",
            "  ldap_attr:",
            "    dn: uid=jdoe,ou=people,dc=example,dc=com",
            "    name: shadowExpire",
            "    values: []",
            "    state: exact",
            "  args: \"{{ ldap_auth }}\"",
            "'''",
            "",
            "RETURN = r'''",
            "modlist:",
            "  description: list of modified parameters",
            "  returned: success",
            "  type: list",
            "  sample: '[[2, \"olcRootDN\", [\"cn=root,dc=example,dc=com\"]]]'",
            "'''",
            "",
            "import traceback",
            "from distutils.version import LooseVersion",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils._text import to_native, to_bytes",
            "from ansible.module_utils.ldap import LdapGeneric, gen_specs",
            "",
            "LDAP_IMP_ERR = None",
            "try:",
            "    import ldap",
            "",
            "    HAS_LDAP = True",
            "except ImportError:",
            "    LDAP_IMP_ERR = traceback.format_exc()",
            "    HAS_LDAP = False",
            "",
            "",
            "class LdapAttr(LdapGeneric):",
            "    def __init__(self, module):",
            "        LdapGeneric.__init__(self, module)",
            "",
            "        # Shortcuts",
            "        self.name = self.module.params['name']",
            "        self.state = self.module.params['state']",
            "",
            "        # Normalize values",
            "        if isinstance(self.module.params['values'], list):",
            "            self.values = list(map(to_bytes, self.module.params['values']))",
            "        else:",
            "            self.values = [to_bytes(self.module.params['values'])]",
            "",
            "    def add(self):",
            "        values_to_add = list(filter(self._is_value_absent, self.values))",
            "",
            "        if len(values_to_add) > 0:",
            "            modlist = [(ldap.MOD_ADD, self.name, values_to_add)]",
            "        else:",
            "            modlist = []",
            "",
            "        return modlist",
            "",
            "    def delete(self):",
            "        values_to_delete = list(filter(self._is_value_present, self.values))",
            "",
            "        if len(values_to_delete) > 0:",
            "            modlist = [(ldap.MOD_DELETE, self.name, values_to_delete)]",
            "        else:",
            "            modlist = []",
            "",
            "        return modlist",
            "",
            "    def exact(self):",
            "        try:",
            "            results = self.connection.search_s(",
            "                self.dn, ldap.SCOPE_BASE, attrlist=[self.name])",
            "        except ldap.LDAPError as e:",
            "            self.fail(\"Cannot search for attribute %s\" % self.name, e)",
            "",
            "        current = results[0][1].get(self.name, [])",
            "        modlist = []",
            "",
            "        if frozenset(self.values) != frozenset(current):",
            "            if len(current) == 0:",
            "                modlist = [(ldap.MOD_ADD, self.name, self.values)]",
            "            elif len(self.values) == 0:",
            "                modlist = [(ldap.MOD_DELETE, self.name, None)]",
            "            else:",
            "                modlist = [(ldap.MOD_REPLACE, self.name, self.values)]",
            "",
            "        return modlist",
            "",
            "    def _is_value_present(self, value):",
            "        \"\"\" True if the target attribute has the given value. \"\"\"",
            "        try:",
            "            is_present = bool(",
            "                self.connection.compare_s(self.dn, self.name, value))",
            "        except ldap.NO_SUCH_ATTRIBUTE:",
            "            is_present = False",
            "",
            "        return is_present",
            "",
            "    def _is_value_absent(self, value):",
            "        \"\"\" True if the target attribute doesn't have the given value. \"\"\"",
            "        return not self._is_value_present(value)",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=gen_specs(",
            "            name=dict(type='str', required=True),",
            "            params=dict(type='dict'),",
            "            state=dict(type='str', default='present', choices=['absent', 'exact', 'present']),",
            "            values=dict(type='raw', required=True),",
            "        ),",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    if not HAS_LDAP:",
            "        module.fail_json(msg=missing_required_lib('python-ldap'),",
            "                         exception=LDAP_IMP_ERR)",
            "",
            "    # For Ansible-2.9.x and below, allow the params module parameter with a warning",
            "    if LooseVersion(module.ansible_version) < LooseVersion('2.10'):",
            "        if module.params['params']:",
            "            module.deprecate(\"The `params` option to ldap_attr will be removed in Ansible 2.10\"",
            "                             \" since it circumvents Ansible's option handling\", version='2.10')",
            "",
            "            # However, the bind_pw parameter contains a password so it **must** go through the normal",
            "            # argument parsing even though removing it breaks backwards compat.",
            "            if 'bind_pw' in module.params['params']:",
            "                module.fail_json(msg=\"Using `bind_pw` with the `params` option has been disallowed since\"",
            "                                 \" it is insecure.  Use the `bind_pw` option directly.  The `params`\"",
            "                                 \" option will be removed in Ansible-2.10\")",
            "",
            "            # Update module parameters with user's parameters if defined",
            "            module.params.update(module.params['params'])",
            "            # Remove params itself",
            "            module.params.pop('params', None)",
            "    else:",
            "        # For Ansible 2.10 and above",
            "        if module.params['params']:",
            "            module.fail_json(msg=\"The `params` option to ldap_attr was removed in Ansible-2.10 since\"",
            "                             \" it circumvents Ansible's option handling\")",
            "",
            "    # Instantiate the LdapAttr object",
            "    ldap = LdapAttr(module)",
            "",
            "    state = module.params['state']",
            "",
            "    # Perform action",
            "    if state == 'present':",
            "        modlist = ldap.add()",
            "    elif state == 'absent':",
            "        modlist = ldap.delete()",
            "    elif state == 'exact':",
            "        modlist = ldap.exact()",
            "",
            "    changed = False",
            "",
            "    if len(modlist) > 0:",
            "        changed = True",
            "",
            "        if not module.check_mode:",
            "            try:",
            "                ldap.connection.modify_s(ldap.dn, modlist)",
            "            except Exception as e:",
            "                module.fail_json(msg=\"Attribute action failed.\", details=to_native(e))",
            "",
            "    module.exit_json(changed=changed, modlist=modlist)",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "65": [],
            "66": [],
            "67": [],
            "68": [],
            "142": [],
            "253": [
                "main"
            ],
            "254": [
                "main"
            ],
            "255": [
                "main"
            ],
            "256": [
                "main"
            ],
            "257": [
                "main"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/modules/net_tools/ldap/ldap_entry.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     rule allowing root to modify the server configuration. If you need to use"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     a simple bind to access your server, pass the credentials in I(bind_dn)"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     and I(bind_pw)."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+  - \"The I(params) parameter is deprecated in Ansible-2.7 due to circumventing Ansible's parameter"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+     handling. The I(params) parameter started disallowing setting the I(bind_pw) parameter in Ansible-2.7"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+     as it was insecure to set the parameter that way.\""
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " version_added: '2.3'"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " author:"
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "   - Jiri Tyr (@jtyr)"
            },
            "9": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "       - If I(state=present), value or list of values to use when creating"
            },
            "10": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         the entry. It can either be a string or an actual list of"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         strings."
            },
            "12": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  params:"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    description:"
            },
            "14": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-      - List of options which allows to overwrite any of the task or the"
            },
            "15": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        I(attributes) options. To remove an option, set the value of the option"
            },
            "16": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        to C(null)."
            },
            "17": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "   state:"
            },
            "18": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     description:"
            },
            "19": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "       - The target state of the entry."
            },
            "20": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " #   server_uri: ldap://localhost/"
            },
            "21": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " #   bind_dn: cn=admin,dc=example,dc=com"
            },
            "22": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " #   bind_pw: password"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+#"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+# In the example below, 'args' is a task keyword, passed at the same level as the module"
            },
            "25": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " - name: Get rid of an old entry"
            },
            "26": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "   ldap_entry:"
            },
            "27": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     dn: ou=stuff,dc=example,dc=com"
            },
            "28": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     state: absent"
            },
            "29": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    params: \"{{ ldap_auth }}\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+  args: \"{{ ldap_auth }}\""
            },
            "31": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " \"\"\""
            },
            "32": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " \"\"\""
            },
            "35": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " import traceback"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+from distutils.version import LooseVersion"
            },
            "38": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " from ansible.module_utils.basic import AnsibleModule, missing_required_lib"
            },
            "40": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " from ansible.module_utils.six import string_types"
            },
            "41": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         module.fail_json(msg=missing_required_lib('python-ldap'),"
            },
            "42": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                          exception=LDAP_IMP_ERR)"
            },
            "43": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+    # For Ansible-2.9.x and below, allow the params module parameter with a warning"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+    if LooseVersion(module.ansible_version) < LooseVersion('2.10'):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        if module.params['params']:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            module.deprecate(\"The `params` option to ldap_attr will be removed in Ansible 2.10\""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                             \" since it circumvents Ansible's option handling\", version='2.10')"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            # However, the bind_pw parameter contains a password so it **must** go through the normal"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            # argument parsing even though removing it breaks backwards compat."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            if 'bind_pw' in module.params['params']:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+                module.fail_json(msg=\"Using `bind_pw` with the `params` option has been disallowed since\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+                                 \" it is insecure.  Use the `bind_pw` option directly.  The `params`\""
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                                 \" option will be removed in Ansible-2.10\")"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            # Update module parameters with user's parameters if defined"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            module.params.update(module.params['params'])"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            # Remove params itself"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            module.params.pop('params', None)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+    else:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        # For Ansible 2.10 and above"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        if module.params['params']:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            module.fail_json(msg=\"The `params` option to ldap_attr was removed in Ansible-2.10 since\""
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+                             \" it circumvents Ansible's option handling\")"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "     state = module.params['state']"
            },
            "68": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     # Check if objectClass is present when needed"
            },
            "70": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                 isinstance(module.params['objectClass'], list))):"
            },
            "71": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         module.fail_json(msg=\"objectClass must be either a string or a list.\")"
            },
            "72": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Update module parameters with user's parameters if defined"
            },
            "74": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'params' in module.params and isinstance(module.params['params'], dict):"
            },
            "75": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for key, val in module.params['params'].items():"
            },
            "76": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if key in module.argument_spec:"
            },
            "77": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                module.params[key] = val"
            },
            "78": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "79": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                module.params['attributes'][key] = val"
            },
            "80": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "81": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Remove the params"
            },
            "82": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        module.params.pop('params', None)"
            },
            "83": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "84": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "     # Instantiate the LdapEntry object"
            },
            "85": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "     ldap = LdapEntry(module)"
            },
            "86": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright: (c) 2016, Peter Sagerson <psagers@ignorare.net>",
            "# Copyright: (c) 2016, Jiri Tyr <jiri.tyr@gmail.com>",
            "#",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: ldap_entry",
            "short_description: Add or remove LDAP entries.",
            "description:",
            "  - Add or remove LDAP entries. This module only asserts the existence or",
            "    non-existence of an LDAP entry, not its attributes. To assert the",
            "    attribute values of an entry, see M(ldap_attr).",
            "notes:",
            "  - The default authentication settings will attempt to use a SASL EXTERNAL",
            "    bind over a UNIX domain socket. This works well with the default Ubuntu",
            "    install for example, which includes a cn=peercred,cn=external,cn=auth ACL",
            "    rule allowing root to modify the server configuration. If you need to use",
            "    a simple bind to access your server, pass the credentials in I(bind_dn)",
            "    and I(bind_pw).",
            "version_added: '2.3'",
            "author:",
            "  - Jiri Tyr (@jtyr)",
            "requirements:",
            "  - python-ldap",
            "options:",
            "  attributes:",
            "    description:",
            "      - If I(state=present), attributes necessary to create an entry. Existing",
            "        entries are never modified. To assert specific attribute values on an",
            "        existing entry, use M(ldap_attr) module instead.",
            "  objectClass:",
            "    description:",
            "      - If I(state=present), value or list of values to use when creating",
            "        the entry. It can either be a string or an actual list of",
            "        strings.",
            "  params:",
            "    description:",
            "      - List of options which allows to overwrite any of the task or the",
            "        I(attributes) options. To remove an option, set the value of the option",
            "        to C(null).",
            "  state:",
            "    description:",
            "      - The target state of the entry.",
            "    choices: [present, absent]",
            "    default: present",
            "extends_documentation_fragment: ldap.documentation",
            "\"\"\"",
            "",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Make sure we have a parent entry for users",
            "  ldap_entry:",
            "    dn: ou=users,dc=example,dc=com",
            "    objectClass: organizationalUnit",
            "",
            "- name: Make sure we have an admin user",
            "  ldap_entry:",
            "    dn: cn=admin,dc=example,dc=com",
            "    objectClass:",
            "      - simpleSecurityObject",
            "      - organizationalRole",
            "    attributes:",
            "      description: An LDAP administrator",
            "      userPassword: \"{SSHA}tabyipcHzhwESzRaGA7oQ/SDoBZQOGND\"",
            "",
            "- name: Get rid of an old entry",
            "  ldap_entry:",
            "    dn: ou=stuff,dc=example,dc=com",
            "    state: absent",
            "    server_uri: ldap://localhost/",
            "    bind_dn: cn=admin,dc=example,dc=com",
            "    bind_pw: password",
            "",
            "#",
            "# The same as in the previous example but with the authentication details",
            "# stored in the ldap_auth variable:",
            "#",
            "# ldap_auth:",
            "#   server_uri: ldap://localhost/",
            "#   bind_dn: cn=admin,dc=example,dc=com",
            "#   bind_pw: password",
            "- name: Get rid of an old entry",
            "  ldap_entry:",
            "    dn: ou=stuff,dc=example,dc=com",
            "    state: absent",
            "    params: \"{{ ldap_auth }}\"",
            "\"\"\"",
            "",
            "",
            "RETURN = \"\"\"",
            "# Default return values",
            "\"\"\"",
            "",
            "import traceback",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils._text import to_native, to_bytes",
            "from ansible.module_utils.ldap import LdapGeneric, gen_specs",
            "",
            "LDAP_IMP_ERR = None",
            "try:",
            "    import ldap.modlist",
            "",
            "    HAS_LDAP = True",
            "except ImportError:",
            "    LDAP_IMP_ERR = traceback.format_exc()",
            "    HAS_LDAP = False",
            "",
            "",
            "class LdapEntry(LdapGeneric):",
            "    def __init__(self, module):",
            "        LdapGeneric.__init__(self, module)",
            "",
            "        # Shortcuts",
            "        self.state = self.module.params['state']",
            "",
            "        # Add the objectClass into the list of attributes",
            "        self.module.params['attributes']['objectClass'] = (",
            "            self.module.params['objectClass'])",
            "",
            "        # Load attributes",
            "        if self.state == 'present':",
            "            self.attrs = self._load_attrs()",
            "",
            "    def _load_attrs(self):",
            "        \"\"\" Turn attribute's value to array. \"\"\"",
            "        attrs = {}",
            "",
            "        for name, value in self.module.params['attributes'].items():",
            "            if name not in attrs:",
            "                attrs[name] = []",
            "",
            "            if isinstance(value, list):",
            "                attrs[name] = list(map(to_bytes, value))",
            "            else:",
            "                attrs[name].append(to_bytes(value))",
            "",
            "        return attrs",
            "",
            "    def add(self):",
            "        \"\"\" If self.dn does not exist, returns a callable that will add it. \"\"\"",
            "        def _add():",
            "            self.connection.add_s(self.dn, modlist)",
            "",
            "        if not self._is_entry_present():",
            "            modlist = ldap.modlist.addModlist(self.attrs)",
            "            action = _add",
            "        else:",
            "            action = None",
            "",
            "        return action",
            "",
            "    def delete(self):",
            "        \"\"\" If self.dn exists, returns a callable that will delete it. \"\"\"",
            "        def _delete():",
            "            self.connection.delete_s(self.dn)",
            "",
            "        if self._is_entry_present():",
            "            action = _delete",
            "        else:",
            "            action = None",
            "",
            "        return action",
            "",
            "    def _is_entry_present(self):",
            "        try:",
            "            self.connection.search_s(self.dn, ldap.SCOPE_BASE)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            is_present = False",
            "        else:",
            "            is_present = True",
            "",
            "        return is_present",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=gen_specs(",
            "            attributes=dict(default={}, type='dict'),",
            "            objectClass=dict(type='raw'),",
            "            params=dict(type='dict'),",
            "            state=dict(default='present', choices=['present', 'absent']),",
            "        ),",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    if not HAS_LDAP:",
            "        module.fail_json(msg=missing_required_lib('python-ldap'),",
            "                         exception=LDAP_IMP_ERR)",
            "",
            "    state = module.params['state']",
            "",
            "    # Check if objectClass is present when needed",
            "    if state == 'present' and module.params['objectClass'] is None:",
            "        module.fail_json(msg=\"At least one objectClass must be provided.\")",
            "",
            "    # Check if objectClass is of the correct type",
            "    if (",
            "            module.params['objectClass'] is not None and not (",
            "                isinstance(module.params['objectClass'], string_types) or",
            "                isinstance(module.params['objectClass'], list))):",
            "        module.fail_json(msg=\"objectClass must be either a string or a list.\")",
            "",
            "    # Update module parameters with user's parameters if defined",
            "    if 'params' in module.params and isinstance(module.params['params'], dict):",
            "        for key, val in module.params['params'].items():",
            "            if key in module.argument_spec:",
            "                module.params[key] = val",
            "            else:",
            "                module.params['attributes'][key] = val",
            "",
            "        # Remove the params",
            "        module.params.pop('params', None)",
            "",
            "    # Instantiate the LdapEntry object",
            "    ldap = LdapEntry(module)",
            "",
            "    # Get the action function",
            "    if state == 'present':",
            "        action = ldap.add()",
            "    elif state == 'absent':",
            "        action = ldap.delete()",
            "",
            "    # Perform the action",
            "    if action is not None and not module.check_mode:",
            "        try:",
            "            action()",
            "        except Exception as e:",
            "            module.fail_json(msg=\"Entry action failed.\", details=to_native(e), exception=traceback.format_exc())",
            "",
            "    module.exit_json(changed=(action is not None))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/python",
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright: (c) 2016, Peter Sagerson <psagers@ignorare.net>",
            "# Copyright: (c) 2016, Jiri Tyr <jiri.tyr@gmail.com>",
            "#",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import absolute_import, division, print_function",
            "__metaclass__ = type",
            "",
            "",
            "ANSIBLE_METADATA = {",
            "    'metadata_version': '1.1',",
            "    'status': ['preview'],",
            "    'supported_by': 'community'",
            "}",
            "",
            "",
            "DOCUMENTATION = \"\"\"",
            "---",
            "module: ldap_entry",
            "short_description: Add or remove LDAP entries.",
            "description:",
            "  - Add or remove LDAP entries. This module only asserts the existence or",
            "    non-existence of an LDAP entry, not its attributes. To assert the",
            "    attribute values of an entry, see M(ldap_attr).",
            "notes:",
            "  - The default authentication settings will attempt to use a SASL EXTERNAL",
            "    bind over a UNIX domain socket. This works well with the default Ubuntu",
            "    install for example, which includes a cn=peercred,cn=external,cn=auth ACL",
            "    rule allowing root to modify the server configuration. If you need to use",
            "    a simple bind to access your server, pass the credentials in I(bind_dn)",
            "    and I(bind_pw).",
            "  - \"The I(params) parameter is deprecated in Ansible-2.7 due to circumventing Ansible's parameter",
            "     handling. The I(params) parameter started disallowing setting the I(bind_pw) parameter in Ansible-2.7",
            "     as it was insecure to set the parameter that way.\"",
            "version_added: '2.3'",
            "author:",
            "  - Jiri Tyr (@jtyr)",
            "requirements:",
            "  - python-ldap",
            "options:",
            "  attributes:",
            "    description:",
            "      - If I(state=present), attributes necessary to create an entry. Existing",
            "        entries are never modified. To assert specific attribute values on an",
            "        existing entry, use M(ldap_attr) module instead.",
            "  objectClass:",
            "    description:",
            "      - If I(state=present), value or list of values to use when creating",
            "        the entry. It can either be a string or an actual list of",
            "        strings.",
            "  state:",
            "    description:",
            "      - The target state of the entry.",
            "    choices: [present, absent]",
            "    default: present",
            "extends_documentation_fragment: ldap.documentation",
            "\"\"\"",
            "",
            "",
            "EXAMPLES = \"\"\"",
            "- name: Make sure we have a parent entry for users",
            "  ldap_entry:",
            "    dn: ou=users,dc=example,dc=com",
            "    objectClass: organizationalUnit",
            "",
            "- name: Make sure we have an admin user",
            "  ldap_entry:",
            "    dn: cn=admin,dc=example,dc=com",
            "    objectClass:",
            "      - simpleSecurityObject",
            "      - organizationalRole",
            "    attributes:",
            "      description: An LDAP administrator",
            "      userPassword: \"{SSHA}tabyipcHzhwESzRaGA7oQ/SDoBZQOGND\"",
            "",
            "- name: Get rid of an old entry",
            "  ldap_entry:",
            "    dn: ou=stuff,dc=example,dc=com",
            "    state: absent",
            "    server_uri: ldap://localhost/",
            "    bind_dn: cn=admin,dc=example,dc=com",
            "    bind_pw: password",
            "",
            "#",
            "# The same as in the previous example but with the authentication details",
            "# stored in the ldap_auth variable:",
            "#",
            "# ldap_auth:",
            "#   server_uri: ldap://localhost/",
            "#   bind_dn: cn=admin,dc=example,dc=com",
            "#   bind_pw: password",
            "#",
            "# In the example below, 'args' is a task keyword, passed at the same level as the module",
            "- name: Get rid of an old entry",
            "  ldap_entry:",
            "    dn: ou=stuff,dc=example,dc=com",
            "    state: absent",
            "  args: \"{{ ldap_auth }}\"",
            "\"\"\"",
            "",
            "",
            "RETURN = \"\"\"",
            "# Default return values",
            "\"\"\"",
            "",
            "import traceback",
            "from distutils.version import LooseVersion",
            "",
            "from ansible.module_utils.basic import AnsibleModule, missing_required_lib",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils._text import to_native, to_bytes",
            "from ansible.module_utils.ldap import LdapGeneric, gen_specs",
            "",
            "LDAP_IMP_ERR = None",
            "try:",
            "    import ldap.modlist",
            "",
            "    HAS_LDAP = True",
            "except ImportError:",
            "    LDAP_IMP_ERR = traceback.format_exc()",
            "    HAS_LDAP = False",
            "",
            "",
            "class LdapEntry(LdapGeneric):",
            "    def __init__(self, module):",
            "        LdapGeneric.__init__(self, module)",
            "",
            "        # Shortcuts",
            "        self.state = self.module.params['state']",
            "",
            "        # Add the objectClass into the list of attributes",
            "        self.module.params['attributes']['objectClass'] = (",
            "            self.module.params['objectClass'])",
            "",
            "        # Load attributes",
            "        if self.state == 'present':",
            "            self.attrs = self._load_attrs()",
            "",
            "    def _load_attrs(self):",
            "        \"\"\" Turn attribute's value to array. \"\"\"",
            "        attrs = {}",
            "",
            "        for name, value in self.module.params['attributes'].items():",
            "            if name not in attrs:",
            "                attrs[name] = []",
            "",
            "            if isinstance(value, list):",
            "                attrs[name] = list(map(to_bytes, value))",
            "            else:",
            "                attrs[name].append(to_bytes(value))",
            "",
            "        return attrs",
            "",
            "    def add(self):",
            "        \"\"\" If self.dn does not exist, returns a callable that will add it. \"\"\"",
            "        def _add():",
            "            self.connection.add_s(self.dn, modlist)",
            "",
            "        if not self._is_entry_present():",
            "            modlist = ldap.modlist.addModlist(self.attrs)",
            "            action = _add",
            "        else:",
            "            action = None",
            "",
            "        return action",
            "",
            "    def delete(self):",
            "        \"\"\" If self.dn exists, returns a callable that will delete it. \"\"\"",
            "        def _delete():",
            "            self.connection.delete_s(self.dn)",
            "",
            "        if self._is_entry_present():",
            "            action = _delete",
            "        else:",
            "            action = None",
            "",
            "        return action",
            "",
            "    def _is_entry_present(self):",
            "        try:",
            "            self.connection.search_s(self.dn, ldap.SCOPE_BASE)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            is_present = False",
            "        else:",
            "            is_present = True",
            "",
            "        return is_present",
            "",
            "",
            "def main():",
            "    module = AnsibleModule(",
            "        argument_spec=gen_specs(",
            "            attributes=dict(default={}, type='dict'),",
            "            objectClass=dict(type='raw'),",
            "            params=dict(type='dict'),",
            "            state=dict(default='present', choices=['present', 'absent']),",
            "        ),",
            "        supports_check_mode=True,",
            "    )",
            "",
            "    if not HAS_LDAP:",
            "        module.fail_json(msg=missing_required_lib('python-ldap'),",
            "                         exception=LDAP_IMP_ERR)",
            "",
            "    # For Ansible-2.9.x and below, allow the params module parameter with a warning",
            "    if LooseVersion(module.ansible_version) < LooseVersion('2.10'):",
            "        if module.params['params']:",
            "            module.deprecate(\"The `params` option to ldap_attr will be removed in Ansible 2.10\"",
            "                             \" since it circumvents Ansible's option handling\", version='2.10')",
            "",
            "            # However, the bind_pw parameter contains a password so it **must** go through the normal",
            "            # argument parsing even though removing it breaks backwards compat.",
            "            if 'bind_pw' in module.params['params']:",
            "                module.fail_json(msg=\"Using `bind_pw` with the `params` option has been disallowed since\"",
            "                                 \" it is insecure.  Use the `bind_pw` option directly.  The `params`\"",
            "                                 \" option will be removed in Ansible-2.10\")",
            "",
            "            # Update module parameters with user's parameters if defined",
            "            module.params.update(module.params['params'])",
            "            # Remove params itself",
            "            module.params.pop('params', None)",
            "    else:",
            "        # For Ansible 2.10 and above",
            "        if module.params['params']:",
            "            module.fail_json(msg=\"The `params` option to ldap_attr was removed in Ansible-2.10 since\"",
            "                             \" it circumvents Ansible's option handling\")",
            "",
            "    state = module.params['state']",
            "",
            "    # Check if objectClass is present when needed",
            "    if state == 'present' and module.params['objectClass'] is None:",
            "        module.fail_json(msg=\"At least one objectClass must be provided.\")",
            "",
            "    # Check if objectClass is of the correct type",
            "    if (",
            "            module.params['objectClass'] is not None and not (",
            "                isinstance(module.params['objectClass'], string_types) or",
            "                isinstance(module.params['objectClass'], list))):",
            "        module.fail_json(msg=\"objectClass must be either a string or a list.\")",
            "",
            "    # Instantiate the LdapEntry object",
            "    ldap = LdapEntry(module)",
            "",
            "    # Get the action function",
            "    if state == 'present':",
            "        action = ldap.add()",
            "    elif state == 'absent':",
            "        action = ldap.delete()",
            "",
            "    # Perform the action",
            "    if action is not None and not module.check_mode:",
            "        try:",
            "            action()",
            "        except Exception as e:",
            "            module.fail_json(msg=\"Entry action failed.\", details=to_native(e), exception=traceback.format_exc())",
            "",
            "    module.exit_json(changed=(action is not None))",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "51": [],
            "52": [],
            "53": [],
            "54": [],
            "55": [],
            "101": [],
            "220": [
                "main"
            ],
            "221": [
                "main"
            ],
            "222": [
                "main"
            ],
            "223": [
                "main"
            ],
            "224": [
                "main"
            ],
            "225": [
                "main"
            ],
            "226": [
                "main"
            ],
            "227": [
                "main"
            ],
            "228": [
                "main"
            ],
            "229": [
                "main"
            ],
            "230": [
                "main"
            ]
        },
        "addLocation": []
    }
}