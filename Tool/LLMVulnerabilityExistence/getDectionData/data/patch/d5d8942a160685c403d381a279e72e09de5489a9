{
    "django/contrib/auth/tests/tokens.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         p2 = Mocked(date.today() + timedelta(settings.PASSWORD_RESET_TIMEOUT_DAYS + 1))"
            },
            "2": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self.assertFalse(p2.check_token(user, tk1))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    def test_date_length(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        \"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        Make sure we don't allow overly long dates, causing a potential DoS."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        user = User.objects.create_user('ima1337h4x0r', 'test4@example.com', 'p4ssw0rd')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        p0 = PasswordResetTokenGenerator()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        # This will put a 14-digit base36 timestamp into the token, which is too large."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        tk1 = p0._make_token_with_timestamp(user, 175455491841851871349)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        self.assertFalse(p0.check_token(user, tk1))"
            }
        },
        "frontPatchFile": [
            "from datetime import date, timedelta",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import User, AnonymousUser",
            "from django.contrib.auth.tokens import PasswordResetTokenGenerator",
            "from django.test import TestCase",
            "",
            "",
            "class TokenGeneratorTest(TestCase):",
            "",
            "    def test_make_token(self):",
            "        \"\"\"",
            "        Ensure that we can make a token and that it is valid",
            "        \"\"\"",
            "        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        self.assertTrue(p0.check_token(user, tk1))",
            "",
            "    def test_10265(self):",
            "        \"\"\"",
            "        Ensure that the token generated for a user created in the same request",
            "        will work correctly.",
            "        \"\"\"",
            "        # See ticket #10265",
            "        user = User.objects.create_user('comebackkid', 'test3@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        reload = User.objects.get(username='comebackkid')",
            "        tk2 = p0.make_token(reload)",
            "        self.assertEqual(tk1, tk2)",
            "",
            "    def test_timeout(self):",
            "        \"\"\"",
            "        Ensure we can use the token after n days, but no greater.",
            "        \"\"\"",
            "        # Uses a mocked version of PasswordResetTokenGenerator so we can change",
            "        # the value of 'today'",
            "        class Mocked(PasswordResetTokenGenerator):",
            "            def __init__(self, today):",
            "                self._today_val = today",
            "            def _today(self):",
            "                return self._today_val",
            "",
            "        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        p1 = Mocked(date.today() + timedelta(settings.PASSWORD_RESET_TIMEOUT_DAYS))",
            "        self.assertTrue(p1.check_token(user, tk1))",
            "",
            "        p2 = Mocked(date.today() + timedelta(settings.PASSWORD_RESET_TIMEOUT_DAYS + 1))",
            "        self.assertFalse(p2.check_token(user, tk1))"
        ],
        "afterPatchFile": [
            "from datetime import date, timedelta",
            "",
            "from django.conf import settings",
            "from django.contrib.auth.models import User, AnonymousUser",
            "from django.contrib.auth.tokens import PasswordResetTokenGenerator",
            "from django.test import TestCase",
            "",
            "",
            "class TokenGeneratorTest(TestCase):",
            "",
            "    def test_make_token(self):",
            "        \"\"\"",
            "        Ensure that we can make a token and that it is valid",
            "        \"\"\"",
            "        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        self.assertTrue(p0.check_token(user, tk1))",
            "",
            "    def test_10265(self):",
            "        \"\"\"",
            "        Ensure that the token generated for a user created in the same request",
            "        will work correctly.",
            "        \"\"\"",
            "        # See ticket #10265",
            "        user = User.objects.create_user('comebackkid', 'test3@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        reload = User.objects.get(username='comebackkid')",
            "        tk2 = p0.make_token(reload)",
            "        self.assertEqual(tk1, tk2)",
            "",
            "    def test_timeout(self):",
            "        \"\"\"",
            "        Ensure we can use the token after n days, but no greater.",
            "        \"\"\"",
            "        # Uses a mocked version of PasswordResetTokenGenerator so we can change",
            "        # the value of 'today'",
            "        class Mocked(PasswordResetTokenGenerator):",
            "            def __init__(self, today):",
            "                self._today_val = today",
            "            def _today(self):",
            "                return self._today_val",
            "",
            "        user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')",
            "        p0 = PasswordResetTokenGenerator()",
            "        tk1 = p0.make_token(user)",
            "        p1 = Mocked(date.today() + timedelta(settings.PASSWORD_RESET_TIMEOUT_DAYS))",
            "        self.assertTrue(p1.check_token(user, tk1))",
            "",
            "        p2 = Mocked(date.today() + timedelta(settings.PASSWORD_RESET_TIMEOUT_DAYS + 1))",
            "        self.assertFalse(p2.check_token(user, tk1))",
            "",
            "    def test_date_length(self):",
            "        \"\"\"",
            "        Make sure we don't allow overly long dates, causing a potential DoS.",
            "        \"\"\"",
            "        user = User.objects.create_user('ima1337h4x0r', 'test4@example.com', 'p4ssw0rd')",
            "        p0 = PasswordResetTokenGenerator()",
            "",
            "        # This will put a 14-digit base36 timestamp into the token, which is too large.",
            "        tk1 = p0._make_token_with_timestamp(user, 175455491841851871349)",
            "        self.assertFalse(p0.check_token(user, tk1))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "yt_dlp.YoutubeDL",
            "django.contrib.auth.tests.tokens.TokenGeneratorTest.self"
        ]
    },
    "django/contrib/auth/urls.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# These URLs are normally mapped to /admin/urls.py. This URLs file is "
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+# These URLs are normally mapped to /admin/urls.py. This URLs file is"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # provided as a convenience to those who want to deploy these URLs elsewhere."
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # This file is also used to provide a reliable view deployment for test purposes."
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     (r'^password_change/done/$', 'django.contrib.auth.views.password_change_done'),"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     (r'^password_reset/$', 'django.contrib.auth.views.password_reset'),"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     (r'^password_reset/done/$', 'django.contrib.auth.views.password_reset_done'),"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    (r'^reset/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$', 'django.contrib.auth.views.password_reset_confirm'),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    (r'^reset/(?P<uidb36>[0-9A-Za-z]{1,13})-(?P<token>[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$', 'django.contrib.auth.views.password_reset_confirm'),"
            },
            "10": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     (r'^reset/done/$', 'django.contrib.auth.views.password_reset_complete'),"
            },
            "11": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " )"
            },
            "12": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# These URLs are normally mapped to /admin/urls.py. This URLs file is ",
            "# provided as a convenience to those who want to deploy these URLs elsewhere.",
            "# This file is also used to provide a reliable view deployment for test purposes.",
            "",
            "from django.conf.urls.defaults import *",
            "",
            "urlpatterns = patterns('',",
            "    (r'^login/$', 'django.contrib.auth.views.login'),",
            "    (r'^logout/$', 'django.contrib.auth.views.logout'),",
            "    (r'^password_change/$', 'django.contrib.auth.views.password_change'),",
            "    (r'^password_change/done/$', 'django.contrib.auth.views.password_change_done'),",
            "    (r'^password_reset/$', 'django.contrib.auth.views.password_reset'),",
            "    (r'^password_reset/done/$', 'django.contrib.auth.views.password_reset_done'),",
            "    (r'^reset/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$', 'django.contrib.auth.views.password_reset_confirm'),",
            "    (r'^reset/done/$', 'django.contrib.auth.views.password_reset_complete'),",
            ")"
        ],
        "afterPatchFile": [
            "# These URLs are normally mapped to /admin/urls.py. This URLs file is",
            "# provided as a convenience to those who want to deploy these URLs elsewhere.",
            "# This file is also used to provide a reliable view deployment for test purposes.",
            "",
            "from django.conf.urls.defaults import *",
            "",
            "urlpatterns = patterns('',",
            "    (r'^login/$', 'django.contrib.auth.views.login'),",
            "    (r'^logout/$', 'django.contrib.auth.views.logout'),",
            "    (r'^password_change/$', 'django.contrib.auth.views.password_change'),",
            "    (r'^password_change/done/$', 'django.contrib.auth.views.password_change_done'),",
            "    (r'^password_reset/$', 'django.contrib.auth.views.password_reset'),",
            "    (r'^password_reset/done/$', 'django.contrib.auth.views.password_reset_done'),",
            "    (r'^reset/(?P<uidb36>[0-9A-Za-z]{1,13})-(?P<token>[0-9A-Za-z]{1,13}-[0-9A-Za-z]{1,20})/$', 'django.contrib.auth.views.password_reset_confirm'),",
            "    (r'^reset/done/$', 'django.contrib.auth.views.password_reset_complete'),",
            ")"
        ],
        "action": [
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [],
            "14": []
        },
        "addLocation": []
    },
    "django/utils/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " def base36_to_int(s):"
            },
            "2": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Convertd a base 36 string to an integer"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    Converts a base 36 string to an ``int``. To prevent"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    overconsumption of server resources, raises ``ValueError` if the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    input is longer than 13 base36 digits (13 digits is sufficient to"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    base36-encode any 64-bit integer)."
            },
            "8": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    if len(s) > 13:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        raise ValueError(\"Base36 input too large\")"
            },
            "11": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     return int(s, 36)"
            },
            "12": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " def int_to_base36(i):"
            }
        },
        "frontPatchFile": [
            "import re",
            "import urllib",
            "from email.Utils import formatdate",
            "",
            "from django.utils.encoding import smart_str, force_unicode",
            "from django.utils.functional import allow_lazy",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote(smart_str(url), safe))",
            "",
            "urlquote = allow_lazy(urlquote, unicode)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote_plus(smart_str(url), safe))",
            "urlquote_plus = allow_lazy(urlquote_plus, unicode)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib.urlencode(",
            "        [(smart_str(k),",
            "         isinstance(v, (list,tuple)) and [smart_str(i) for i in v] or smart_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Convertd a base 36 string to an integer",
            "    \"\"\"",
            "    return int(s, 36)",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i / j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.decode('string_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necesary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')"
        ],
        "afterPatchFile": [
            "import re",
            "import urllib",
            "from email.Utils import formatdate",
            "",
            "from django.utils.encoding import smart_str, force_unicode",
            "from django.utils.functional import allow_lazy",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote(smart_str(url), safe))",
            "",
            "urlquote = allow_lazy(urlquote, unicode)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_unicode(urllib.quote_plus(smart_str(url), safe))",
            "urlquote_plus = allow_lazy(urlquote_plus, unicode)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first case to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib.urlencode(",
            "        [(smart_str(k),",
            "         isinstance(v, (list,tuple)) and [smart_str(i) for i in v] or smart_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s GMT' % rfcdate[:25]",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. To prevent",
            "    overconsumption of server resources, raises ``ValueError` if the",
            "    input is longer than 13 base36 digits (13 digits is sufficient to",
            "    base36-encode any 64-bit integer).",
            "    \"\"\"",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return int(s, 36)",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i / j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.decode('string_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necesary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "76": [
                "base36_to_int"
            ]
        },
        "addLocation": []
    }
}