{
    "libtaxii/common.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import dateutil.parser"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from lxml import etree"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import six"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from six.moves.urllib.parse import urlparse"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " try:"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     import simplejson as json"
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " _XML_PARSER = None"
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def parse(s):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+def parse(s, allow_file=True, allow_url=False):"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     Uses the default parser to parse a string or file-like object"
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :param s: The XML String or File-like object to parse"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    :param s: The XML String or File-like object to parse."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    :param allow_file: Allow `s` to be a file path."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    :param allow_url: Allow `s` to be a URL."
            },
            "19": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     :return: an etree._Element"
            },
            "20": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    # Do a simple validation that the given string (or URL)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    # has no protocol specified. Anything without parseable protocol"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    # will be interpreted by lxml as string instead or path of external URL."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    if not allow_url and isinstance(s, six.string_types):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        parsed = urlparse(s)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        if parsed.scheme:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            raise ValueError('external URLs are not allowed')"
            },
            "28": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    parser = get_xml_parser()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    # parse from string if no external paths allowed"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    if not allow_file and not allow_url:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        return etree.fromstring(s, parser)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    # try to parse from file or string if files are allowed"
            },
            "36": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     try:"
            },
            "37": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        e = etree.parse(s, get_xml_parser()).getroot()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        return etree.parse(s, parser).getroot()"
            },
            "39": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     except IOError:"
            },
            "40": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        e = etree.XML(s, get_xml_parser())"
            },
            "41": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "42": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return e"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        return etree.XML(s, parser)"
            },
            "44": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " def parse_xml_string(xmlstr):"
            },
            "47": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         else:"
            },
            "48": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             xmlstr = six.StringIO(xmlstr)"
            },
            "49": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return parse(xmlstr)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    return parse(xmlstr, allow_file=True)"
            },
            "52": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " def get_xml_parser():"
            },
            "55": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 437,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "     if hasattr(content, 'read'):  # The content is file-like"
            },
            "57": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "         try:  # Try to parse as XML"
            },
            "58": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            xml = parse(content)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+            xml = parse(content, allow_file=True)"
            },
            "60": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "             return xml, True"
            },
            "61": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "         except etree.XMLSyntaxError:  # Content is not well-formed XML; just treat as a string"
            },
            "62": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "             return content.read(), False"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Common utility classes and functions used throughout libtaxii.",
            "\"\"\"",
            "",
            "from operator import attrgetter",
            "import re",
            "import sys",
            "from uuid import uuid4",
            "",
            "import dateutil.parser",
            "from lxml import etree",
            "import six",
            "",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "",
            "from libtaxii.constants import *",
            "",
            "_XML_PARSER = None",
            "",
            "",
            "def parse(s):",
            "    \"\"\"",
            "    Uses the default parser to parse a string or file-like object",
            "",
            "    :param s: The XML String or File-like object to parse",
            "    :return: an etree._Element",
            "    \"\"\"",
            "",
            "    try:",
            "        e = etree.parse(s, get_xml_parser()).getroot()",
            "    except IOError:",
            "        e = etree.XML(s, get_xml_parser())",
            "",
            "    return e",
            "",
            "",
            "def parse_xml_string(xmlstr):",
            "    \"\"\"Parse an XML string (binary or unicode) with the default parser.",
            "",
            "    :param xmlstr: An XML String to parse",
            "    :return: an etree._Element",
            "    \"\"\"",
            "    if isinstance(xmlstr, six.binary_type):",
            "        xmlstr = six.BytesIO(xmlstr)",
            "    elif isinstance(xmlstr, six.text_type):",
            "        # LXML doesn't accept Unicode strings with an explicit encoding, so",
            "        # try to detect and encode to bytes before passing to LXML.",
            "        encoding = re.findall(r'encoding=\"([0-9A-Za-z_\\-]+)\"', xmlstr[:50], re.I)",
            "        # re.findall returns a list of matching strings. We only care about the",
            "        # first one.",
            "        if encoding:",
            "            xmlstr = six.BytesIO(xmlstr.encode(encoding[0]))",
            "        else:",
            "            xmlstr = six.StringIO(xmlstr)",
            "",
            "    return parse(xmlstr)",
            "",
            "",
            "def get_xml_parser():",
            "    \"\"\"Return the XML parser currently in use.",
            "",
            "    If one has not already been set (via :py:func:`set_xml_parser()`), a new",
            "    ``etree.XMLParser`` is constructed with ``no_network=True`` and",
            "    ``huge_tree=False``.",
            "    \"\"\"",
            "    global _XML_PARSER",
            "    if _XML_PARSER is None:",
            "        _XML_PARSER = etree.XMLParser(",
            "            attribute_defaults=False,",
            "            dtd_validation=False,",
            "            load_dtd=False,",
            "            no_network=True,",
            "            ns_clean=True,",
            "            recover=False,",
            "            remove_blank_text=False,",
            "            remove_comments=False,",
            "            remove_pis=False,",
            "            strip_cdata=True,",
            "            compact=True,",
            "            # collect_ids=True,",
            "            resolve_entities=False,",
            "            huge_tree=False",
            "        )",
            "    return _XML_PARSER.copy()",
            "",
            "",
            "def set_xml_parser(xml_parser=None):",
            "    \"\"\"Set the libtaxii.messages XML parser.",
            "",
            "    Args:",
            "        xml_parser (etree.XMLParser): The parser to use to parse TAXII XML.",
            "    \"\"\"",
            "    global _XML_PARSER",
            "    _XML_PARSER = xml_parser",
            "",
            "",
            "def parse_datetime_string(datetime_string):",
            "    \"\"\"Parse a string into a :py:class:`datetime.datetime`.",
            "",
            "    libtaxii users should not need to use this function directly.",
            "    \"\"\"",
            "    if not datetime_string:",
            "        return None",
            "    return dateutil.parser.parse(datetime_string)",
            "",
            "",
            "def generate_message_id(maxlen=5, version=VID_TAXII_SERVICES_10):",
            "    \"\"\"Generate a TAXII Message ID.",
            "",
            "    Args:",
            "        maxlen (int): maximum length of the ID, in characters",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            msg_id = tm11.generate_message_id()",
            "            message = tm11.DiscoveryRequest(msg_id)",
            "            # Or...",
            "            message = tm11.DiscoveryRequest(tm11.generate_message_id())",
            "    \"\"\"",
            "    if version == VID_TAXII_SERVICES_10:",
            "        message_id = str(uuid4().int % sys.maxsize)",
            "    elif version == VID_TAXII_SERVICES_11:",
            "        message_id = str(uuid4())",
            "    else:",
            "        raise ValueError('Unknown TAXII Version: %s. Must be a TAXII Services Version ID!' % version)",
            "    return message_id",
            "",
            "",
            "def append_any_content_etree(etree_elt, content):",
            "    \"\"\"",
            "    General method for adding content to an etree element. This method can handle:",
            "    * etree._ElementTree",
            "    * etree._Element",
            "    * any python type that can be cast to str",
            "    * str",
            "",
            "",
            "    :param etree_elt: The etree to append the content to",
            "    :param content: The content to append",
            "    :return: The etree_elt",
            "    \"\"\"",
            "",
            "    if isinstance(content, etree._ElementTree):  # If content is an element tree, append the root element",
            "        etree_elt.append(content.getroot())",
            "        return etree_elt",
            "",
            "    if isinstance(content, etree._Element):  # If content is an element, append it",
            "        etree_elt.append(content)",
            "        return etree_elt",
            "",
            "    if not isinstance(content, six.string_types):  # If content is a non-string, cast it to string and set etree_elt.text",
            "        etree_elt.text = str(content)",
            "        return etree_elt",
            "",
            "    # If content is a string, need to check if it's XML or not",
            "    try:",
            "        etree_elt.append(etree.XML(content, get_xml_parser()))",
            "    except etree.XMLSyntaxError:",
            "        etree_elt.text = content",
            "",
            "    return etree_elt",
            "",
            "",
            "def gen_filename(collection_name, format_part, date_string, extension):",
            "    \"\"\"",
            "    Creates a filename based on various properties of a Poll Request and Content Block",
            "",
            "    :param collection_name: The collection name",
            "    :param format_part: The format part (e.g., '_STIX_10_')",
            "    :param date_string: A datestring",
            "    :param extension: The file extension to use",
            "    :return: A string containing the generated filename",
            "    \"\"\"",
            "    if six.PY3:",
            "        return (collection_name.lstrip(\".\") +",
            "                format_part +",
            "                re.sub(r\"[^a-zA-Z0-9]\", \"_\", date_string) + extension",
            "                ).translate('/\\\\:*?\"<>|')",
            "    else:",
            "        return (collection_name.lstrip(\".\") +",
            "                format_part +",
            "                re.sub(r\"[^a-zA-Z0-9]\", \"_\", date_string) + extension",
            "                ).translate(None, '/\\\\:*?\"<>|')",
            "",
            "",
            "class TAXIIBase(object):",
            "",
            "    \"\"\"",
            "    Base class for all TAXII Messages and Message component types.",
            "",
            "    libtaxii users should not need to use this class directly.",
            "    \"\"\"",
            "",
            "    @property",
            "    def sort_key(self):",
            "        \"\"\"",
            "        This property allows list of TAXII objects to be compared efficiently.",
            "        The __eq__ method uses this property to sort the lists before",
            "        comparisons are made.",
            "",
            "        Subclasses must implement this property.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_etree(self):",
            "        \"\"\"Create an etree representation of this class.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create a dictionary representation of this class.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_json(self):",
            "        \"\"\"Create a JSON object of this class.",
            "",
            "        Assumes any binary content will be UTF-8 encoded.",
            "        \"\"\"",
            "        content_dict = self.to_dict()",
            "",
            "        _decode_binary_fields(content_dict)",
            "",
            "        return json.dumps(content_dict)",
            "",
            "    def to_xml(self, pretty_print=False):",
            "        \"\"\"Create an XML representation of this class.",
            "",
            "        Subclasses should not need to implement this method.",
            "        \"\"\"",
            "        return etree.tostring(self.to_etree(), pretty_print=pretty_print, encoding='utf-8')",
            "",
            "    def to_text(self, line_prepend=''):",
            "        \"\"\"Create a nice looking (this is a subjective term!)",
            "        textual representation of this class. Subclasses should",
            "        implement this method.",
            "",
            "        Note that this is just a convenience method for making",
            "        TAXII Messages nice to read for humans and may change",
            "        drastically in future versions of libtaxii.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree):",
            "        \"\"\"Create an instance of this class from an etree.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        \"\"\"Create an instance of this class from a dictionary.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_xml(cls, xml):",
            "        \"\"\"Create an instance of this class from XML.",
            "",
            "        Subclasses should not need to implement this method.",
            "        \"\"\"",
            "        etree_xml = parse_xml_string(xml)",
            "        return cls.from_etree(etree_xml)",
            "",
            "    # Just noting that there is not a from_text() method. I also",
            "    # don't think there will ever be one.",
            "",
            "    def __str__(self):",
            "        return self.to_xml(pretty_print=True)",
            "",
            "    def __eq__(self, other, debug=False):",
            "        \"\"\"",
            "        Generic method used to check equality of objects of any TAXII type.",
            "",
            "        Also allows for ``print``-based debugging output showing differences.",
            "",
            "        In order for subclasses to use this function, they must meet the",
            "        following criteria:",
            "        1. All class properties start with one underscore.",
            "        2. The sort_key property is implemented.",
            "",
            "        Args:",
            "            self (object): this object",
            "            other (object): the object to compare ``self`` against.",
            "            debug (bool): Whether or not to print debug statements as the",
            "                equality comparison is performed.",
            "        \"\"\"",
            "        if other is None:",
            "            if debug:",
            "                print('other was None!')",
            "            return False",
            "",
            "        if self.__class__.__name__ != other.__class__.__name__:",
            "            if debug:",
            "                print('class names not equal: %s != %s' % (self.__class__.__name__, other.__class__.__name__))",
            "            return False",
            "",
            "        # Get all member properties that start with '_'",
            "        members = [attr for attr in vars(self) if attr.startswith('_') and not attr.startswith('__')]",
            "        for member in members:",
            "            if debug:",
            "                print('member name: %s' % member)",
            "            self_value = getattr(self, member)",
            "            other_value = getattr(other, member)",
            "",
            "            if isinstance(self_value, TAXIIBase):",
            "                # A debuggable equals comparison can be made",
            "                eq = self_value.__eq__(other_value, debug)",
            "            elif isinstance(self_value, list):",
            "                # We have lists to compare",
            "                if len(self_value) != len(other_value):",
            "                    # Lengths not equal",
            "                    member = member + ' lengths'",
            "                    self_value = len(self_value)",
            "                    other_value = len(other_value)",
            "                    eq = False",
            "                elif len(self_value) == 0:",
            "                    # Both lists are of size 0, and therefore equal",
            "                    eq = True",
            "                else:",
            "                    # Equal sized, non-0 length lists. The list might contain",
            "                    # TAXIIBase objects, or it might not. Peek at the first",
            "                    # item to see whether it is a TAXIIBase object or not.",
            "                    if isinstance(self_value[0], TAXIIBase):",
            "                        # All TAXIIBase objects have the 'sort_key' property implemented",
            "                        self_value = sorted(self_value, key=attrgetter('sort_key'))",
            "                        other_value = sorted(other_value, key=attrgetter('sort_key'))",
            "                        for self_item, other_item in six.moves.zip(self_value, other_value):",
            "                            # Compare the ordered lists element by element",
            "                            eq = self_item.__eq__(other_item, debug)",
            "                    else:",
            "                        # Assume they don't... just do a set comparison",
            "                        eq = set(self_value) == set(other_value)",
            "            elif isinstance(self_value, dict):",
            "                # Dictionary to compare",
            "                if len(set(self_value.keys()) - set(other_value.keys())) != 0:",
            "                    if debug:",
            "                        print('dict keys not equal: %s != %s' % (self_value, other_value))",
            "                    eq = False",
            "                for k, v in six.iteritems(self_value):",
            "                    if other_value[k] != v:",
            "                        if debug:",
            "                            print('dict values not equal: %s != %s' % (v, other_value[k]))",
            "                        eq = False",
            "                eq = True",
            "            elif isinstance(self_value, etree._Element):",
            "                # Non-TAXII etree element (i.e. STIX)",
            "                eq = (etree.tostring(self_value, encoding='utf-8') == etree.tostring(other_value, encoding='utf-8'))",
            "            else:",
            "                # Do a direct comparison",
            "                eq = (self_value == other_value)",
            "",
            "            # TODO: is this duplicate?",
            "            if not eq:",
            "                if debug:",
            "                    print('%s was not equal: %s != %s' % (member, self_value, other_value))",
            "                return False",
            "",
            "        return True",
            "",
            "    def __ne__(self, other, debug=False):",
            "        return not self.__eq__(other, debug)",
            "",
            "",
            "def get_required(etree_xml, xpath, ns_map):",
            "    elements = etree_xml.xpath(xpath, namespaces=ns_map)",
            "    if len(elements) == 0:",
            "        raise ValueError('Element \"%s\" is required' % xpath)",
            "    return elements[0]",
            "",
            "",
            "def get_optional(etree_xml, xpath, ns_map):",
            "    try:",
            "        return get_required(etree_xml, xpath, ns_map)",
            "    except ValueError:",
            "        pass",
            "",
            "",
            "def get_optional_text(etree_xml, xpath, ns_map):",
            "    try:",
            "        return get_required(etree_xml, xpath, ns_map).text",
            "    except ValueError:",
            "        pass",
            "",
            "",
            "def _decode_binary_fields(dict_obj):",
            "    \"\"\"Given a dict, decode any binary values, assuming UTF-8 encoding.",
            "    Will recurse into nested dicts.",
            "    Modifies the values in-place.",
            "    \"\"\"",
            "    for key, value in dict_obj.items():",
            "",
            "        if isinstance(value, six.binary_type):",
            "            dict_obj[key] = value.decode('utf-8')",
            "",
            "        elif isinstance(value, dict):",
            "            _decode_binary_fields(value)",
            "",
            "",
            "def stringify_content(content):",
            "    \"\"\"Always a string or raises an error.",
            "    Returns the string representation and whether the data is XML.",
            "    \"\"\"",
            "    # If it's an etree, it's definitely XML",
            "    if isinstance(content, etree._ElementTree):",
            "        return content.getroot(), True",
            "",
            "    if isinstance(content, etree._Element):",
            "        return content, True",
            "",
            "    if hasattr(content, 'read'):  # The content is file-like",
            "        try:  # Try to parse as XML",
            "            xml = parse(content)",
            "            return xml, True",
            "        except etree.XMLSyntaxError:  # Content is not well-formed XML; just treat as a string",
            "            return content.read(), False",
            "    else:  # The Content is not file-like",
            "        try:  # Attempt to parse string as XML",
            "            xml = parse_xml_string(content)",
            "            return xml, True",
            "        except etree.XMLSyntaxError:  # Content is not well-formed XML; just treat as a string",
            "            if isinstance(content, six.string_types):  # It's a string of some kind, unicode or otherwise",
            "                return content, False",
            "            else:  # It's some other datatype that needs casting to string",
            "                return str(content), False"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Common utility classes and functions used throughout libtaxii.",
            "\"\"\"",
            "",
            "from operator import attrgetter",
            "import re",
            "import sys",
            "from uuid import uuid4",
            "",
            "import dateutil.parser",
            "from lxml import etree",
            "import six",
            "from six.moves.urllib.parse import urlparse",
            "",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "",
            "from libtaxii.constants import *",
            "",
            "_XML_PARSER = None",
            "",
            "",
            "def parse(s, allow_file=True, allow_url=False):",
            "    \"\"\"",
            "    Uses the default parser to parse a string or file-like object",
            "",
            "    :param s: The XML String or File-like object to parse.",
            "    :param allow_file: Allow `s` to be a file path.",
            "    :param allow_url: Allow `s` to be a URL.",
            "    :return: an etree._Element",
            "    \"\"\"",
            "    # Do a simple validation that the given string (or URL)",
            "    # has no protocol specified. Anything without parseable protocol",
            "    # will be interpreted by lxml as string instead or path of external URL.",
            "    if not allow_url and isinstance(s, six.string_types):",
            "        parsed = urlparse(s)",
            "        if parsed.scheme:",
            "            raise ValueError('external URLs are not allowed')",
            "",
            "    parser = get_xml_parser()",
            "",
            "    # parse from string if no external paths allowed",
            "    if not allow_file and not allow_url:",
            "        return etree.fromstring(s, parser)",
            "",
            "    # try to parse from file or string if files are allowed",
            "    try:",
            "        return etree.parse(s, parser).getroot()",
            "    except IOError:",
            "        return etree.XML(s, parser)",
            "",
            "",
            "def parse_xml_string(xmlstr):",
            "    \"\"\"Parse an XML string (binary or unicode) with the default parser.",
            "",
            "    :param xmlstr: An XML String to parse",
            "    :return: an etree._Element",
            "    \"\"\"",
            "    if isinstance(xmlstr, six.binary_type):",
            "        xmlstr = six.BytesIO(xmlstr)",
            "    elif isinstance(xmlstr, six.text_type):",
            "        # LXML doesn't accept Unicode strings with an explicit encoding, so",
            "        # try to detect and encode to bytes before passing to LXML.",
            "        encoding = re.findall(r'encoding=\"([0-9A-Za-z_\\-]+)\"', xmlstr[:50], re.I)",
            "        # re.findall returns a list of matching strings. We only care about the",
            "        # first one.",
            "        if encoding:",
            "            xmlstr = six.BytesIO(xmlstr.encode(encoding[0]))",
            "        else:",
            "            xmlstr = six.StringIO(xmlstr)",
            "",
            "    return parse(xmlstr, allow_file=True)",
            "",
            "",
            "def get_xml_parser():",
            "    \"\"\"Return the XML parser currently in use.",
            "",
            "    If one has not already been set (via :py:func:`set_xml_parser()`), a new",
            "    ``etree.XMLParser`` is constructed with ``no_network=True`` and",
            "    ``huge_tree=False``.",
            "    \"\"\"",
            "    global _XML_PARSER",
            "    if _XML_PARSER is None:",
            "        _XML_PARSER = etree.XMLParser(",
            "            attribute_defaults=False,",
            "            dtd_validation=False,",
            "            load_dtd=False,",
            "            no_network=True,",
            "            ns_clean=True,",
            "            recover=False,",
            "            remove_blank_text=False,",
            "            remove_comments=False,",
            "            remove_pis=False,",
            "            strip_cdata=True,",
            "            compact=True,",
            "            # collect_ids=True,",
            "            resolve_entities=False,",
            "            huge_tree=False",
            "        )",
            "    return _XML_PARSER.copy()",
            "",
            "",
            "def set_xml_parser(xml_parser=None):",
            "    \"\"\"Set the libtaxii.messages XML parser.",
            "",
            "    Args:",
            "        xml_parser (etree.XMLParser): The parser to use to parse TAXII XML.",
            "    \"\"\"",
            "    global _XML_PARSER",
            "    _XML_PARSER = xml_parser",
            "",
            "",
            "def parse_datetime_string(datetime_string):",
            "    \"\"\"Parse a string into a :py:class:`datetime.datetime`.",
            "",
            "    libtaxii users should not need to use this function directly.",
            "    \"\"\"",
            "    if not datetime_string:",
            "        return None",
            "    return dateutil.parser.parse(datetime_string)",
            "",
            "",
            "def generate_message_id(maxlen=5, version=VID_TAXII_SERVICES_10):",
            "    \"\"\"Generate a TAXII Message ID.",
            "",
            "    Args:",
            "        maxlen (int): maximum length of the ID, in characters",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            msg_id = tm11.generate_message_id()",
            "            message = tm11.DiscoveryRequest(msg_id)",
            "            # Or...",
            "            message = tm11.DiscoveryRequest(tm11.generate_message_id())",
            "    \"\"\"",
            "    if version == VID_TAXII_SERVICES_10:",
            "        message_id = str(uuid4().int % sys.maxsize)",
            "    elif version == VID_TAXII_SERVICES_11:",
            "        message_id = str(uuid4())",
            "    else:",
            "        raise ValueError('Unknown TAXII Version: %s. Must be a TAXII Services Version ID!' % version)",
            "    return message_id",
            "",
            "",
            "def append_any_content_etree(etree_elt, content):",
            "    \"\"\"",
            "    General method for adding content to an etree element. This method can handle:",
            "    * etree._ElementTree",
            "    * etree._Element",
            "    * any python type that can be cast to str",
            "    * str",
            "",
            "",
            "    :param etree_elt: The etree to append the content to",
            "    :param content: The content to append",
            "    :return: The etree_elt",
            "    \"\"\"",
            "",
            "    if isinstance(content, etree._ElementTree):  # If content is an element tree, append the root element",
            "        etree_elt.append(content.getroot())",
            "        return etree_elt",
            "",
            "    if isinstance(content, etree._Element):  # If content is an element, append it",
            "        etree_elt.append(content)",
            "        return etree_elt",
            "",
            "    if not isinstance(content, six.string_types):  # If content is a non-string, cast it to string and set etree_elt.text",
            "        etree_elt.text = str(content)",
            "        return etree_elt",
            "",
            "    # If content is a string, need to check if it's XML or not",
            "    try:",
            "        etree_elt.append(etree.XML(content, get_xml_parser()))",
            "    except etree.XMLSyntaxError:",
            "        etree_elt.text = content",
            "",
            "    return etree_elt",
            "",
            "",
            "def gen_filename(collection_name, format_part, date_string, extension):",
            "    \"\"\"",
            "    Creates a filename based on various properties of a Poll Request and Content Block",
            "",
            "    :param collection_name: The collection name",
            "    :param format_part: The format part (e.g., '_STIX_10_')",
            "    :param date_string: A datestring",
            "    :param extension: The file extension to use",
            "    :return: A string containing the generated filename",
            "    \"\"\"",
            "    if six.PY3:",
            "        return (collection_name.lstrip(\".\") +",
            "                format_part +",
            "                re.sub(r\"[^a-zA-Z0-9]\", \"_\", date_string) + extension",
            "                ).translate('/\\\\:*?\"<>|')",
            "    else:",
            "        return (collection_name.lstrip(\".\") +",
            "                format_part +",
            "                re.sub(r\"[^a-zA-Z0-9]\", \"_\", date_string) + extension",
            "                ).translate(None, '/\\\\:*?\"<>|')",
            "",
            "",
            "class TAXIIBase(object):",
            "",
            "    \"\"\"",
            "    Base class for all TAXII Messages and Message component types.",
            "",
            "    libtaxii users should not need to use this class directly.",
            "    \"\"\"",
            "",
            "    @property",
            "    def sort_key(self):",
            "        \"\"\"",
            "        This property allows list of TAXII objects to be compared efficiently.",
            "        The __eq__ method uses this property to sort the lists before",
            "        comparisons are made.",
            "",
            "        Subclasses must implement this property.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_etree(self):",
            "        \"\"\"Create an etree representation of this class.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create a dictionary representation of this class.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def to_json(self):",
            "        \"\"\"Create a JSON object of this class.",
            "",
            "        Assumes any binary content will be UTF-8 encoded.",
            "        \"\"\"",
            "        content_dict = self.to_dict()",
            "",
            "        _decode_binary_fields(content_dict)",
            "",
            "        return json.dumps(content_dict)",
            "",
            "    def to_xml(self, pretty_print=False):",
            "        \"\"\"Create an XML representation of this class.",
            "",
            "        Subclasses should not need to implement this method.",
            "        \"\"\"",
            "        return etree.tostring(self.to_etree(), pretty_print=pretty_print, encoding='utf-8')",
            "",
            "    def to_text(self, line_prepend=''):",
            "        \"\"\"Create a nice looking (this is a subjective term!)",
            "        textual representation of this class. Subclasses should",
            "        implement this method.",
            "",
            "        Note that this is just a convenience method for making",
            "        TAXII Messages nice to read for humans and may change",
            "        drastically in future versions of libtaxii.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree):",
            "        \"\"\"Create an instance of this class from an etree.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        \"\"\"Create an instance of this class from a dictionary.",
            "",
            "        Subclasses must implement this method.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    @classmethod",
            "    def from_xml(cls, xml):",
            "        \"\"\"Create an instance of this class from XML.",
            "",
            "        Subclasses should not need to implement this method.",
            "        \"\"\"",
            "        etree_xml = parse_xml_string(xml)",
            "        return cls.from_etree(etree_xml)",
            "",
            "    # Just noting that there is not a from_text() method. I also",
            "    # don't think there will ever be one.",
            "",
            "    def __str__(self):",
            "        return self.to_xml(pretty_print=True)",
            "",
            "    def __eq__(self, other, debug=False):",
            "        \"\"\"",
            "        Generic method used to check equality of objects of any TAXII type.",
            "",
            "        Also allows for ``print``-based debugging output showing differences.",
            "",
            "        In order for subclasses to use this function, they must meet the",
            "        following criteria:",
            "        1. All class properties start with one underscore.",
            "        2. The sort_key property is implemented.",
            "",
            "        Args:",
            "            self (object): this object",
            "            other (object): the object to compare ``self`` against.",
            "            debug (bool): Whether or not to print debug statements as the",
            "                equality comparison is performed.",
            "        \"\"\"",
            "        if other is None:",
            "            if debug:",
            "                print('other was None!')",
            "            return False",
            "",
            "        if self.__class__.__name__ != other.__class__.__name__:",
            "            if debug:",
            "                print('class names not equal: %s != %s' % (self.__class__.__name__, other.__class__.__name__))",
            "            return False",
            "",
            "        # Get all member properties that start with '_'",
            "        members = [attr for attr in vars(self) if attr.startswith('_') and not attr.startswith('__')]",
            "        for member in members:",
            "            if debug:",
            "                print('member name: %s' % member)",
            "            self_value = getattr(self, member)",
            "            other_value = getattr(other, member)",
            "",
            "            if isinstance(self_value, TAXIIBase):",
            "                # A debuggable equals comparison can be made",
            "                eq = self_value.__eq__(other_value, debug)",
            "            elif isinstance(self_value, list):",
            "                # We have lists to compare",
            "                if len(self_value) != len(other_value):",
            "                    # Lengths not equal",
            "                    member = member + ' lengths'",
            "                    self_value = len(self_value)",
            "                    other_value = len(other_value)",
            "                    eq = False",
            "                elif len(self_value) == 0:",
            "                    # Both lists are of size 0, and therefore equal",
            "                    eq = True",
            "                else:",
            "                    # Equal sized, non-0 length lists. The list might contain",
            "                    # TAXIIBase objects, or it might not. Peek at the first",
            "                    # item to see whether it is a TAXIIBase object or not.",
            "                    if isinstance(self_value[0], TAXIIBase):",
            "                        # All TAXIIBase objects have the 'sort_key' property implemented",
            "                        self_value = sorted(self_value, key=attrgetter('sort_key'))",
            "                        other_value = sorted(other_value, key=attrgetter('sort_key'))",
            "                        for self_item, other_item in six.moves.zip(self_value, other_value):",
            "                            # Compare the ordered lists element by element",
            "                            eq = self_item.__eq__(other_item, debug)",
            "                    else:",
            "                        # Assume they don't... just do a set comparison",
            "                        eq = set(self_value) == set(other_value)",
            "            elif isinstance(self_value, dict):",
            "                # Dictionary to compare",
            "                if len(set(self_value.keys()) - set(other_value.keys())) != 0:",
            "                    if debug:",
            "                        print('dict keys not equal: %s != %s' % (self_value, other_value))",
            "                    eq = False",
            "                for k, v in six.iteritems(self_value):",
            "                    if other_value[k] != v:",
            "                        if debug:",
            "                            print('dict values not equal: %s != %s' % (v, other_value[k]))",
            "                        eq = False",
            "                eq = True",
            "            elif isinstance(self_value, etree._Element):",
            "                # Non-TAXII etree element (i.e. STIX)",
            "                eq = (etree.tostring(self_value, encoding='utf-8') == etree.tostring(other_value, encoding='utf-8'))",
            "            else:",
            "                # Do a direct comparison",
            "                eq = (self_value == other_value)",
            "",
            "            # TODO: is this duplicate?",
            "            if not eq:",
            "                if debug:",
            "                    print('%s was not equal: %s != %s' % (member, self_value, other_value))",
            "                return False",
            "",
            "        return True",
            "",
            "    def __ne__(self, other, debug=False):",
            "        return not self.__eq__(other, debug)",
            "",
            "",
            "def get_required(etree_xml, xpath, ns_map):",
            "    elements = etree_xml.xpath(xpath, namespaces=ns_map)",
            "    if len(elements) == 0:",
            "        raise ValueError('Element \"%s\" is required' % xpath)",
            "    return elements[0]",
            "",
            "",
            "def get_optional(etree_xml, xpath, ns_map):",
            "    try:",
            "        return get_required(etree_xml, xpath, ns_map)",
            "    except ValueError:",
            "        pass",
            "",
            "",
            "def get_optional_text(etree_xml, xpath, ns_map):",
            "    try:",
            "        return get_required(etree_xml, xpath, ns_map).text",
            "    except ValueError:",
            "        pass",
            "",
            "",
            "def _decode_binary_fields(dict_obj):",
            "    \"\"\"Given a dict, decode any binary values, assuming UTF-8 encoding.",
            "    Will recurse into nested dicts.",
            "    Modifies the values in-place.",
            "    \"\"\"",
            "    for key, value in dict_obj.items():",
            "",
            "        if isinstance(value, six.binary_type):",
            "            dict_obj[key] = value.decode('utf-8')",
            "",
            "        elif isinstance(value, dict):",
            "            _decode_binary_fields(value)",
            "",
            "",
            "def stringify_content(content):",
            "    \"\"\"Always a string or raises an error.",
            "    Returns the string representation and whether the data is XML.",
            "    \"\"\"",
            "    # If it's an etree, it's definitely XML",
            "    if isinstance(content, etree._ElementTree):",
            "        return content.getroot(), True",
            "",
            "    if isinstance(content, etree._Element):",
            "        return content, True",
            "",
            "    if hasattr(content, 'read'):  # The content is file-like",
            "        try:  # Try to parse as XML",
            "            xml = parse(content, allow_file=True)",
            "            return xml, True",
            "        except etree.XMLSyntaxError:  # Content is not well-formed XML; just treat as a string",
            "            return content.read(), False",
            "    else:  # The Content is not file-like",
            "        try:  # Attempt to parse string as XML",
            "            xml = parse_xml_string(content)",
            "            return xml, True",
            "        except etree.XMLSyntaxError:  # Content is not well-formed XML; just treat as a string",
            "            if isinstance(content, six.string_types):  # It's a string of some kind, unicode or otherwise",
            "                return content, False",
            "            else:  # It's some other datatype that needs casting to string",
            "                return str(content), False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [
                "parse"
            ],
            "28": [
                "parse"
            ],
            "33": [
                "parse"
            ],
            "35": [
                "parse"
            ],
            "36": [
                "parse"
            ],
            "37": [
                "parse"
            ],
            "59": [
                "parse_xml_string"
            ],
            "425": [
                "stringify_content"
            ]
        },
        "addLocation": []
    },
    "libtaxii/messages_10.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     etree_xml = parse_xml_string(xml_string)"
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     package_dir, package_filename = os.path.split(__file__)"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema.xsd\")"
            },
            "3": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    taxii_schema_doc = parse(schema_file)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    taxii_schema_doc = parse(schema_file, allow_file=True)"
            },
            "5": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     xml_schema = etree.XMLSchema(taxii_schema_doc)"
            },
            "6": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     valid = xml_schema.validate(etree_xml)"
            },
            "7": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     if not valid:"
            },
            "8": {
                "beforePatchRowNumber": 479,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "         extended_headers = {}"
            },
            "9": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "         for k, v in six.iteritems(d['extended_headers']):"
            },
            "10": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "             try:"
            },
            "11": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                v = parse(v)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+                v = parse(v, allow_file=False)"
            },
            "13": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": 483,
                "PatchRowcode": "             except etree.XMLSyntaxError:"
            },
            "14": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "                 pass"
            },
            "15": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 485,
                "PatchRowcode": "             extended_headers[k] = v"
            },
            "16": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 646,
                "PatchRowcode": "         is_xml = d.get('content_is_xml', False)"
            },
            "17": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "         if is_xml:"
            },
            "18": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 648,
                "PatchRowcode": "             #FIXME: to parse or not to parse the content - this should be configurable"
            },
            "19": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kwargs['content'] = parse(d['content'])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+            kwargs['content'] = parse(d['content'], allow_file=False)"
            },
            "21": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 650,
                "PatchRowcode": "         else:"
            },
            "22": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 651,
                "PatchRowcode": "             kwargs['content'] = d['content']"
            },
            "23": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 652,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Creating, handling, and parsing TAXII 1.0 messages.",
            "\"\"\"",
            "",
            "import six",
            "",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "import os",
            "import warnings",
            "",
            "from lxml import etree",
            "",
            "from .common import (parse, parse_datetime_string, append_any_content_etree, TAXIIBase,",
            "                     get_required, get_optional, get_optional_text, parse_xml_string,",
            "                     stringify_content)",
            "from .validation import do_check, uri_regex, check_timestamp_label, message_id_regex_10",
            "from .constants import *",
            "",
            "",
            "def validate_xml(xml_string):",
            "    \"\"\"",
            "    Note that this function has been deprecated. Please see",
            "    libtaxii.validators.SchemaValidator.",
            "",
            "    Validate XML with the TAXII XML Schema 1.0.",
            "",
            "    Args:",
            "        xml_string (str): The XML to validate.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            is_valid = tm10.validate_xml(message.to_xml())",
            "    \"\"\"",
            "",
            "    warnings.warn('Call to deprecated function: libtaxii.messages_10.validate_xml()',",
            "                  category=DeprecationWarning)",
            "",
            "    etree_xml = parse_xml_string(xml_string)",
            "    package_dir, package_filename = os.path.split(__file__)",
            "    schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema.xsd\")",
            "    taxii_schema_doc = parse(schema_file)",
            "    xml_schema = etree.XMLSchema(taxii_schema_doc)",
            "    valid = xml_schema.validate(etree_xml)",
            "    if not valid:",
            "        return xml_schema.error_log.last_error",
            "    return valid",
            "",
            "",
            "def get_message_from_xml(xml_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from an XML string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the XML.",
            "",
            "    Args:",
            "        xml_string (str): The XML to parse into a TAXII message.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_xml = message.to_xml()",
            "            new_message = tm10.get_message_from_xml(message_xml)",
            "    \"\"\"",
            "    if isinstance(xml_string, six.binary_type):",
            "        xml_string = xml_string.decode(encoding, 'replace')",
            "    etree_xml = parse_xml_string(xml_string)",
            "    qn = etree.QName(etree_xml)",
            "    if qn.namespace != ns_map['taxii']:",
            "        raise ValueError('Unsupported namespace: %s' % qn.namespace)",
            "",
            "    message_type = qn.localname",
            "",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_etree(etree_xml)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_etree(etree_xml)",
            "    if message_type == MSG_FEED_INFORMATION_REQUEST:",
            "        return FeedInformationRequest.from_etree(etree_xml)",
            "    if message_type == MSG_FEED_INFORMATION_RESPONSE:",
            "        return FeedInformationResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_etree(etree_xml)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_etree(etree_xml)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST:",
            "        return ManageFeedSubscriptionRequest.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE:",
            "        return ManageFeedSubscriptionResponse.from_etree(etree_xml)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_dict(d):",
            "    \"\"\"Create a TAXIIMessage object from a dictonary.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the 'message_type' key in the dictionary.",
            "",
            "    Args:",
            "        d (dict): The dictionary to build the TAXII message from.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_dict = message.to_dict()",
            "            new_message = tm10.get_message_from_dict(message_dict)",
            "    \"\"\"",
            "    if 'message_type' not in d:",
            "        raise ValueError('message_type is a required field!')",
            "",
            "    message_type = d['message_type']",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_dict(d)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_dict(d)",
            "    if message_type == MSG_FEED_INFORMATION_REQUEST:",
            "        return FeedInformationRequest.from_dict(d)",
            "    if message_type == MSG_FEED_INFORMATION_RESPONSE:",
            "        return FeedInformationResponse.from_dict(d)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_dict(d)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_dict(d)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_dict(d)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_dict(d)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST:",
            "        return ManageFeedSubscriptionRequest.from_dict(d)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE:",
            "        return ManageFeedSubscriptionResponse.from_dict(d)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_json(json_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from a JSON string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the JSON.",
            "",
            "    Args:",
            "        json_string (str): The JSON to parse into a TAXII message.",
            "    \"\"\"",
            "    decoded_string = json_string.decode(encoding, 'replace')",
            "    return get_message_from_dict(json.loads(decoded_string))",
            "",
            "",
            "class TAXIIBase10(TAXIIBase):",
            "    version = VID_TAXII_XML_10",
            "",
            "",
            "class DeliveryParameters(TAXIIBase10):",
            "",
            "    \"\"\"Delivery Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Feed content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Feed to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "        content_bindings (list of str): contains Content Binding IDs",
            "            indicating which types of contents the Consumer requests to",
            "            receive for this TAXII Data Feed. **Optional**",
            "    \"\"\"",
            "",
            "    # TODO: Should the default arguments of these change? I'm not sure these are",
            "    # actually optional",
            "",
            "    def __init__(self, inbox_protocol=None, inbox_address=None,",
            "                 delivery_message_binding=None, content_bindings=None):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.delivery_message_binding = delivery_message_binding",
            "        self.content_bindings = content_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        # TODO: Can inbox_address be validated?",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def delivery_message_binding(self):",
            "        return self._delivery_message_binding",
            "",
            "    @delivery_message_binding.setter",
            "    def delivery_message_binding(self, value):",
            "        do_check(value, 'delivery_message_binding', regex_tuple=uri_regex)",
            "        self._delivery_message_binding = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        do_check(value, 'content_bindings', regex_tuple=uri_regex)",
            "        self._content_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Push_Parameters' % ns_map['taxii'])",
            "",
            "        if self.inbox_protocol is not None:",
            "            pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "            pb.text = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii'])",
            "            a.text = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii'])",
            "            mb.text = self.delivery_message_binding",
            "",
            "        for binding in self.content_bindings:",
            "            cb = etree.SubElement(xml, '{%s}Content_Binding' % ns_map['taxii'])",
            "            cb.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        if self.inbox_protocol is not None:",
            "            d['inbox_protocol'] = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            d['inbox_address'] = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            d['delivery_message_binding'] = self.delivery_message_binding",
            "",
            "        d['content_bindings'] = []",
            "        for binding in self.content_bindings:",
            "            d['content_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Parameters ===\\n\"",
            "        s += line_prepend + \"  Inbox Protocol: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.inbox_address",
            "        s += line_prepend + \"  Message Binding: %s\\n\" % self.delivery_message_binding",
            "        if len(self.content_bindings) > 0:",
            "            s += line_prepend + \"  Content Bindings: Any Content\\n\"",
            "        for cb in self.content_bindings:",
            "            s += line_prepend + \"  Content Binding: %s\\n\" % str(cb)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "",
            "        inbox_protocol = get_optional_text(etree_xml, './taxii:Protocol_Binding', ns_map)",
            "        inbox_address = get_optional_text(etree_xml, './taxii:Address', ns_map)",
            "        delivery_message_binding = get_optional_text(etree_xml, './taxii:Message_Binding', ns_map)",
            "",
            "        content_bindings = []",
            "        for binding in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            content_bindings.append(binding.text)",
            "",
            "        return DeliveryParameters(inbox_protocol, inbox_address, delivery_message_binding, content_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return DeliveryParameters(**d)",
            "",
            "",
            "class TAXIIMessage(TAXIIBase10):",
            "",
            "    \"\"\"Encapsulate properties common to all TAXII Messages (such as headers).",
            "",
            "    This class is extended by each Message Type (e.g., DiscoveryRequest), with",
            "    each subclass containing subclass-specific information",
            "    \"\"\"",
            "",
            "    message_type = 'TAXIIMessage'",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None):",
            "        \"\"\"Create a new TAXIIMessage",
            "",
            "        Arguments:",
            "        - message_id (string) - A value identifying this message.",
            "        - in_response_to (string) - Contains the Message ID of the message to",
            "          which this is a response.",
            "        - extended_headers (dictionary) - A dictionary of name/value pairs for",
            "          use as Extended Headers",
            "        \"\"\"",
            "        self.message_id = message_id",
            "        self.in_response_to = in_response_to",
            "        if extended_headers is None:",
            "            self.extended_headers = {}",
            "        else:",
            "            self.extended_headers = extended_headers",
            "",
            "    @property",
            "    def message_id(self):",
            "        return self._message_id",
            "",
            "    @message_id.setter",
            "    def message_id(self, value):",
            "        do_check(value, 'message_id', regex_tuple=message_id_regex_10)",
            "        self._message_id = value",
            "",
            "    @property",
            "    def in_response_to(self):",
            "        return self._in_response_to",
            "",
            "    @in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=message_id_regex_10, can_be_none=True)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def extended_headers(self):",
            "        return self._extended_headers",
            "",
            "    @extended_headers.setter",
            "    def extended_headers(self, value):",
            "        do_check(list(value.keys()), 'extended_headers.keys()', regex_tuple=uri_regex)",
            "        self._extended_headers = value",
            "",
            "    def to_etree(self):",
            "        \"\"\"Creates the base etree for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to XML, subclasses should call this method",
            "        first, then create their specific XML constructs.",
            "        \"\"\"",
            "        root_elt = etree.Element('{%s}%s' % (ns_map['taxii'], self.message_type), nsmap=ns_map)",
            "        root_elt.attrib['message_id'] = str(self.message_id)",
            "",
            "        if self.in_response_to is not None:",
            "            root_elt.attrib['in_response_to'] = str(self.in_response_to)",
            "",
            "        if len(self.extended_headers) > 0:",
            "            eh = etree.SubElement(root_elt, '{%s}Extended_Headers' % ns_map['taxii'])",
            "",
            "            for name, value in list(self.extended_headers.items()):",
            "                h = etree.SubElement(eh, '{%s}Extended_Header' % ns_map['taxii'])",
            "                h.attrib['name'] = name",
            "                append_any_content_etree(h, value)",
            "                # h.text = value",
            "        return root_elt",
            "",
            "    def to_xml(self, pretty_print=False):",
            "        \"\"\"Convert a message to XML.",
            "",
            "        Subclasses shouldn't implement this method, as it is mainly a wrapper",
            "        for cls.to_etree.",
            "        \"\"\"",
            "        return etree.tostring(self.to_etree(), pretty_print=pretty_print, encoding='utf-8')",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create the base dictionary for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to dictionary, subclasses should call this",
            "        method first, then create their specific dictionary constructs.",
            "        \"\"\"",
            "        d = {}",
            "        d['message_type'] = self.message_type",
            "        d['message_id'] = self.message_id",
            "        if self.in_response_to is not None:",
            "            d['in_response_to'] = self.in_response_to",
            "        d['extended_headers'] = {}",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            if isinstance(v, etree._Element) or isinstance(v, etree._ElementTree):",
            "                v = etree.tostring(v, encoding='utf-8')",
            "            elif not isinstance(v, six.string_types):",
            "                v = str(v)",
            "            d['extended_headers'][k] = v",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"Message Type: %s\\n\" % self.message_type",
            "        s += line_prepend + \"Message ID: %s\" % self.message_id",
            "        if self.in_response_to:",
            "            s += \"; In Response To: %s\" % self.in_response_to",
            "        s += \"\\n\"",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            s += line_prepend + \"Extended Header: %s = %s\" % (k, v)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from an etree.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from etree, subclasses should call this method",
            "        first, then parse their specific XML constructs.",
            "        \"\"\"",
            "",
            "        # Check namespace and element name of the root element",
            "        expected_tag = '{%s}%s' % (ns_map['taxii'], cls.message_type)",
            "        tag = src_etree.tag",
            "        if tag != expected_tag:",
            "            raise ValueError('%s != %s' % (tag, expected_tag))",
            "",
            "        # Get the message ID",
            "        message_id = get_required(src_etree, '/taxii:*/@message_id', ns_map)",
            "",
            "        # Get in response to, if present",
            "        in_response_to = get_optional(src_etree, '/taxii:*/@in_response_to', ns_map)",
            "        if in_response_to is not None:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        # Get the Extended headers",
            "        extended_header_list = src_etree.xpath('/taxii:*/taxii:Extended_Headers/taxii:Extended_Header', namespaces=ns_map)",
            "        extended_headers = {}",
            "        for header in extended_header_list:",
            "            eh_name = header.xpath('./@name')[0]",
            "            # eh_value = header.text",
            "            if len(header) == 0:  # This has string content",
            "                eh_value = header.text",
            "            else:  # This has XML content",
            "                eh_value = header[0]",
            "",
            "            extended_headers[eh_name] = eh_value",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_xml(cls, xml):",
            "        \"\"\"Parse a Message from XML.",
            "",
            "        Subclasses shouldn't implemnet this method, as it is mainly a wrapper",
            "        for cls.from_etree.",
            "        \"\"\"",
            "        etree_xml = parse_xml_string(xml)",
            "        return cls.from_etree(etree_xml)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from a dictionary.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from dictionary, subclasses should call this",
            "        method first, then parse their specific dictionary constructs.",
            "        \"\"\"",
            "        message_type = d['message_type']",
            "        if message_type != cls.message_type:",
            "            raise ValueError('%s != %s' % (message_type, cls.message_type))",
            "        message_id = d['message_id']",
            "        extended_headers = {}",
            "        for k, v in six.iteritems(d['extended_headers']):",
            "            try:",
            "                v = parse(v)",
            "            except etree.XMLSyntaxError:",
            "                pass",
            "            extended_headers[k] = v",
            "",
            "        in_response_to = d.get('in_response_to')",
            "        if in_response_to:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class ContentBlock(TAXIIBase10):",
            "",
            "    \"\"\"A TAXII Content Block.",
            "",
            "    Args:",
            "        content_binding (str): a Content Binding ID or nesting expression",
            "            indicating the type of content contained in the Content field of this",
            "            Content Block. **Required**",
            "        content (string or etree): a piece of content of the type specified",
            "            by the Content Binding. **Required**",
            "        timestamp_label (datetime): the Timestamp Label associated with this",
            "            Content Block. **Optional**",
            "        padding (string): an arbitrary amount of padding for this Content",
            "            Block. **Optional**",
            "    \"\"\"",
            "",
            "    NAME = 'Content_Block'",
            "",
            "    def __init__(self, content_binding, content, timestamp_label=None, padding=None):",
            "        self.content_binding = content_binding",
            "        self.content = content",
            "        self.timestamp_label = timestamp_label",
            "        self.padding = padding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.content[:25]",
            "",
            "    @property",
            "    def content_binding(self):",
            "        return self._content_binding",
            "",
            "    @content_binding.setter",
            "    def content_binding(self, value):",
            "        do_check(value, 'content_binding', regex_tuple=uri_regex)",
            "        self._content_binding = value",
            "",
            "    @property",
            "    def content(self):",
            "        if self.content_is_xml:",
            "            return etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            return self._content",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        do_check(value, 'content')  # Just check for not None",
            "        self._content, self.content_is_xml = stringify_content(value)",
            "",
            "    @property",
            "    def content_is_xml(self):",
            "        return self._content_is_xml",
            "",
            "    @content_is_xml.setter",
            "    def content_is_xml(self, value):",
            "        do_check(value, 'content_is_xml', value_tuple=(True, False))",
            "        self._content_is_xml = value",
            "",
            "    @property",
            "    def timestamp_label(self):",
            "        return self._timestamp_label",
            "",
            "    @timestamp_label.setter",
            "    def timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'timestamp_label', can_be_none=True)",
            "        self._timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        block = etree.Element('{%s}Content_Block' % ns_map['taxii'], nsmap=ns_map)",
            "        cb = etree.SubElement(block, '{%s}Content_Binding' % ns_map['taxii'])",
            "        cb.text = self.content_binding",
            "        c = etree.SubElement(block, '{%s}Content' % ns_map['taxii'])",
            "",
            "        if self.content_is_xml:",
            "            c.append(self._content)",
            "        else:",
            "            c.text = self._content",
            "",
            "        if self.timestamp_label:",
            "            tl = etree.SubElement(block, '{%s}Timestamp_Label' % ns_map['taxii'])",
            "            tl.text = self.timestamp_label.isoformat()",
            "",
            "        if self.padding is not None:",
            "            p = etree.SubElement(block, '{%s}Padding' % ns_map['taxii'])",
            "            p.text = self.padding",
            "",
            "        return block",
            "",
            "    def to_dict(self):",
            "        block = {}",
            "        block['content_binding'] = self.content_binding",
            "",
            "        if self.content_is_xml:",
            "            block['content'] = etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            block['content'] = self._content",
            "        block['content_is_xml'] = self.content_is_xml",
            "",
            "        if self.timestamp_label:",
            "            block['timestamp_label'] = self.timestamp_label.isoformat()",
            "",
            "        if self.padding is not None:",
            "            block['padding'] = self.padding",
            "",
            "        return block",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Content Block ===\\n\"",
            "        s += line_prepend + \"  Content Binding: %s\\n\" % self.content_binding",
            "        s += line_prepend + \"  Content Length: %s\\n\" % len(self.content)",
            "        s += line_prepend + \"  (Only content length is shown for brevity)\\n\"",
            "        if self.timestamp_label:",
            "            s += line_prepend + \"  Timestamp Label: %s\\n\" % self.timestamp_label.isoformat()",
            "        s += line_prepend + \"  Padding: %s\\n\" % self.padding",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['content_binding'] = get_required(etree_xml, './taxii:Content_Binding', ns_map).text",
            "",
            "        kwargs['padding'] = get_optional_text(etree_xml, './taxii:Padding', ns_map)",
            "",
            "        ts_text = get_optional_text(etree_xml, './taxii:Timestamp_Label', ns_map)",
            "        if ts_text:",
            "            kwargs['timestamp_label'] = parse_datetime_string(ts_text)",
            "",
            "        content = get_required(etree_xml, './taxii:Content', ns_map)",
            "",
            "        if len(content) == 0:  # This has string content",
            "            kwargs['content'] = content.text",
            "        else:  # This has XML content",
            "            kwargs['content'] = content[0]",
            "",
            "        return ContentBlock(**kwargs)",
            "",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['content_binding'] = d['content_binding']",
            "        kwargs['padding'] = d.get('padding')",
            "",
            "        if d.get('timestamp_label'):",
            "            kwargs['timestamp_label'] = parse_datetime_string(d['timestamp_label'])",
            "",
            "        is_xml = d.get('content_is_xml', False)",
            "        if is_xml:",
            "            #FIXME: to parse or not to parse the content - this should be configurable",
            "            kwargs['content'] = parse(d['content'])",
            "        else:",
            "            kwargs['content'] = d['content']",
            "",
            "        cb = ContentBlock(**kwargs)",
            "        return cb",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "# TAXII Message Classes #",
            "",
            "class DiscoveryRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_REQUEST",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class DiscoveryResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        service_instances (list of `ServiceInstance`): a list of",
            "            service instances that this response contains. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_DISCOVERY_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, service_instances=None):",
            "        super(DiscoveryResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.service_instances = service_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def service_instances(self):",
            "        return self._service_instances",
            "",
            "    @service_instances.setter",
            "    def service_instances(self, value):",
            "        do_check(value, 'service_instances', type=ServiceInstance)",
            "        self._service_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(DiscoveryResponse, self).to_etree()",
            "        for service_instance in self.service_instances:",
            "            xml.append(service_instance.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(DiscoveryResponse, self).to_dict()",
            "        d['service_instances'] = []",
            "        for service_instance in self.service_instances:",
            "            d['service_instances'].append(service_instance.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(DiscoveryResponse, self).to_text(line_prepend)",
            "        for si in self.service_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(DiscoveryResponse, cls).from_etree(etree_xml)",
            "        msg.service_instances = []",
            "        for service_instance in etree_xml.xpath('./taxii:Service_Instance', namespaces=ns_map):",
            "            si = ServiceInstance.from_etree(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(DiscoveryResponse, cls).from_dict(d)",
            "        msg.service_instances = []",
            "        for service_instance in d['service_instances']:",
            "            si = ServiceInstance.from_dict(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "",
            "class ServiceInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Service Instance component of a TAXII Discovery Response Message.",
            "",
            "    Args:",
            "        service_type (string): identifies the Service Type of this",
            "            Service Instance. **Required**",
            "        services_version (string): identifies the TAXII Services",
            "            Specification to which this Service conforms. **Required**",
            "        protocol_binding (string): identifies the protocol binding",
            "            supported by this Service. **Required**",
            "        service_address (string): identifies the network address of the",
            "            TAXII Daemon that hosts this Service. **Required**",
            "        message_bindings (list of strings): identifies the message",
            "            bindings supported by this Service instance. **Required**",
            "        inbox_service_accepted_content (list of strings): identifies",
            "            content bindings that this Inbox Service is willing to accept.",
            "            **Optional**",
            "        available (boolean): indicates whether the identity of the",
            "            requester (authenticated or otherwise) is allowed to access this",
            "            TAXII Service. **Optional**",
            "        message (string): contains a message regarding this Service",
            "            instance. **Optional**",
            "",
            "    The ``message_bindings`` list must contain at least one value.",
            "    \"\"\"",
            "",
            "    def __init__(self, service_type, services_version, protocol_binding,",
            "                 service_address, message_bindings,",
            "                 inbox_service_accepted_content=None, available=None,",
            "                 message=None):",
            "        self.service_type = service_type",
            "        self.services_version = services_version",
            "        self.protocol_binding = protocol_binding",
            "        self.service_address = service_address",
            "        self.message_bindings = message_bindings",
            "        self.inbox_service_accepted_content = inbox_service_accepted_content or []",
            "        self.available = available",
            "        self.message = message",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.service_address",
            "",
            "    @property",
            "    def service_type(self):",
            "        return self._service_type",
            "",
            "    @service_type.setter",
            "    def service_type(self, value):",
            "        do_check(value, 'service_type', value_tuple=SVC_TYPES)",
            "        self._service_type = value",
            "",
            "    @property",
            "    def services_version(self):",
            "        return self._services_version",
            "",
            "    @services_version.setter",
            "    def services_version(self, value):",
            "        do_check(value, 'services_version', regex_tuple=uri_regex)",
            "        self._services_version = value",
            "",
            "    @property",
            "    def protocol_binding(self):",
            "        return self._protocol_binding",
            "",
            "    @protocol_binding.setter",
            "    def protocol_binding(self, value):",
            "        do_check(value, 'protocol_binding', regex_tuple=uri_regex)",
            "        self._protocol_binding = value",
            "",
            "    @property",
            "    def service_address(self):",
            "        return self._service_address",
            "",
            "    @service_address.setter",
            "    def service_address(self, value):",
            "        self._service_address = value",
            "",
            "    @property",
            "    def message_bindings(self):",
            "        return self._message_bindings",
            "",
            "    @message_bindings.setter",
            "    def message_bindings(self, value):",
            "        do_check(value, 'message_bindings', regex_tuple=uri_regex)",
            "        self._message_bindings = value",
            "",
            "    @property",
            "    def inbox_service_accepted_content(self):",
            "        return self._inbox_service_accepted_content",
            "",
            "    @inbox_service_accepted_content.setter",
            "    def inbox_service_accepted_content(self, value):",
            "        do_check(value, 'inbox_service_accepted_content', regex_tuple=uri_regex)",
            "        self._inbox_service_accepted_content = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Service_Instance' % ns_map['taxii'])",
            "        si.attrib['service_type'] = self.service_type",
            "        si.attrib['service_version'] = self.services_version",
            "        if self.available:",
            "            si.attrib['available'] = str(self.available).lower()",
            "",
            "        protocol_binding = etree.SubElement(si, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        protocol_binding.text = self.protocol_binding",
            "",
            "        service_address = etree.SubElement(si, '{%s}Address' % ns_map['taxii'])",
            "        service_address.text = self.service_address",
            "",
            "        for mb in self.message_bindings:",
            "            message_binding = etree.SubElement(si, '{%s}Message_Binding' % ns_map['taxii'])",
            "            message_binding.text = mb",
            "",
            "        for cb in self.inbox_service_accepted_content:",
            "            content_binding = etree.SubElement(si, '{%s}Content_Binding' % ns_map['taxii'])",
            "            content_binding.text = cb",
            "",
            "        if self.message is not None:",
            "            message = etree.SubElement(si, '{%s}Message' % ns_map['taxii'])",
            "            message.text = self.message",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['service_type'] = self.service_type",
            "        d['services_version'] = self.services_version",
            "        d['protocol_binding'] = self.protocol_binding",
            "        d['service_address'] = self.service_address",
            "        d['message_bindings'] = self.message_bindings",
            "        d['inbox_service_accepted_content'] = self.inbox_service_accepted_content",
            "        d['available'] = self.available",
            "        d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Service Instance===\\n\"",
            "        s += line_prepend + \"  Service Type: %s\\n\" % self.service_type",
            "        s += line_prepend + \"  Services Version: %s\\n\" % self.services_version",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.protocol_binding",
            "        s += line_prepend + \"  Address: %s\\n\" % self.service_address",
            "        for mb in self.message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if len(self.inbox_service_accepted_content) == 0:",
            "            s += line_prepend + \"  Inbox Service Accepts: %s\\n\" % None",
            "        for isac in self.inbox_service_accepted_content:",
            "            s += line_prepend + \"  Inbox Service Accepts: %s\\n\" % isac",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):  # Expects a taxii:Service_Instance element",
            "        service_type = etree_xml.attrib['service_type']",
            "        services_version = etree_xml.attrib['service_version']",
            "        available = None",
            "        if etree_xml.attrib.get('available'):",
            "            tmp_available = etree_xml.attrib['available']",
            "            available = tmp_available.lower() == 'true'",
            "",
            "        protocol_binding = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        service_address = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        for mb in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            message_bindings.append(mb.text)",
            "",
            "        inbox_service_accepted_contents = []",
            "        for cb in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            inbox_service_accepted_contents.append(cb.text)",
            "",
            "        message = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        return ServiceInstance(service_type, services_version, protocol_binding,",
            "                service_address, message_bindings, inbox_service_accepted_contents,",
            "                available, message)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return ServiceInstance(**d)",
            "",
            "",
            "class FeedInformationRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Feed Information Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_FEED_INFORMATION_REQUEST",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class FeedInformationResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Feed Information Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_informations (list of FeedInformation): A list",
            "            of FeedInformation objects to be contained in this response.",
            "            **Optional**",
            "    \"\"\"",
            "    message_type = MSG_FEED_INFORMATION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, feed_informations=None):",
            "        super(FeedInformationResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.feed_informations = feed_informations or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=message_id_regex_10)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_informations(self):",
            "        return self._feed_informations",
            "",
            "    @feed_informations.setter",
            "    def feed_informations(self, value):",
            "        do_check(value, 'feed_informations', type=FeedInformation)",
            "        self._feed_informations = value",
            "",
            "    def to_etree(self):",
            "        xml = super(FeedInformationResponse, self).to_etree()",
            "        for feed in self.feed_informations:",
            "            xml.append(feed.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(FeedInformationResponse, self).to_dict()",
            "        d['feed_informations'] = []",
            "        for feed in self.feed_informations:",
            "            d['feed_informations'].append(feed.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(FeedInformationResponse, self).to_text(line_prepend)",
            "        for feed in self.feed_informations:",
            "            s += feed.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(FeedInformationResponse, cls).from_etree(etree_xml)",
            "        msg.feed_informations = []",
            "        feed_informations = etree_xml.xpath('./taxii:Feed', namespaces=ns_map)",
            "        for feed in feed_informations:",
            "            msg.feed_informations.append(FeedInformation.from_etree(feed))",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(FeedInformationResponse, cls).from_dict(d)",
            "        msg.feed_informations = []",
            "        for feed in d['feed_informations']:",
            "            msg.feed_informations.append(FeedInformation.from_dict(feed))",
            "        return msg",
            "",
            "",
            "class FeedInformation(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Feed Information component of a TAXII Feed Information Response",
            "    Message.",
            "",
            "    Arguments:",
            "        feed_name (str): the name by which this TAXII Data Feed is",
            "            identified. **Required**",
            "        feed_description (str): a prose description of this TAXII",
            "            Data Feed. **Required**",
            "        supported_contents (list of str): Content Binding IDs",
            "            indicating which types of content are currently expressed in this",
            "            TAXII Data Feed. **Required**",
            "        available (boolean): whether the identity of the requester",
            "            (authenticated or otherwise) is allowed to access this TAXII",
            "            Service. **Optional** Default: ``None``, indicating \"unknown\"",
            "        push_methods (list of PushMethod objects): the protocols that",
            "            can be used to push content via a subscription. **Optional**",
            "        polling_service_instances (list of PollingServiceInstance objects):",
            "            the bindings and address a Consumer can use to interact with a",
            "            Poll Service instance that supports this TAXII Data Feed.",
            "            **Optional**",
            "        subscription_methods (list of SubscriptionMethod objects): the",
            "            protocol and address of the TAXII Daemon hosting the Feed",
            "            Management Service that can process subscriptions for this TAXII",
            "            Data Feed. **Optional**",
            "",
            "    The absense of ``push_methods`` indicates no push methods.  The absense",
            "    of ``polling_service_instances`` indicates no polling services.  At",
            "    least one of ``push_methods`` and ``polling_service_instances`` must not",
            "    be empty. The absense of ``subscription_methods`` indicates no",
            "    subscription services.",
            "    \"\"\"",
            "",
            "    def __init__(self, feed_name, feed_description, supported_contents,",
            "                 available=None, push_methods=None,",
            "                 polling_service_instances=None, subscription_methods=None):",
            "",
            "        self.feed_name = feed_name",
            "        self.available = available",
            "        self.feed_description = feed_description",
            "        self.supported_contents = supported_contents",
            "        self.push_methods = push_methods or []",
            "        self.polling_service_instances = polling_service_instances or []",
            "        self.subscription_methods = subscription_methods or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.feed_name",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        do_check(value, 'supported_contents', regex_tuple=uri_regex)",
            "        self._supported_contents = value",
            "",
            "    @property",
            "    def push_methods(self):",
            "        return self._push_methods",
            "",
            "    @push_methods.setter",
            "    def push_methods(self, value):",
            "        do_check(value, 'push_methods', type=PushMethod)",
            "        self._push_methods = value",
            "",
            "    @property",
            "    def polling_service_instances(self):",
            "        return self._polling_service_instances",
            "",
            "    @polling_service_instances.setter",
            "    def polling_service_instances(self, value):",
            "        do_check(value, 'polling_service_instances', type=PollingServiceInstance)",
            "        self._polling_service_instances = value",
            "",
            "    @property",
            "    def subscription_methods(self):",
            "        return self._subscription_methods",
            "",
            "    @subscription_methods.setter",
            "    def subscription_methods(self, value):",
            "        do_check(value, 'subscription_methods', type=SubscriptionMethod)",
            "        self._subscription_methods = value",
            "",
            "    def to_etree(self):",
            "        f = etree.Element('{%s}Feed' % ns_map['taxii'])",
            "        f.attrib['feed_name'] = self.feed_name",
            "        if self.available:",
            "            f.attrib['available'] = str(self.available).lower()",
            "        feed_description = etree.SubElement(f, '{%s}Description' % ns_map['taxii'])",
            "        feed_description.text = self.feed_description",
            "",
            "        for binding in self.supported_contents:",
            "            cb = etree.SubElement(f, '{%s}Content_Binding' % ns_map['taxii'])",
            "            cb.text = binding",
            "",
            "        for push_method in self.push_methods:",
            "            f.append(push_method.to_etree())",
            "",
            "        for polling_service in self.polling_service_instances:",
            "            f.append(polling_service.to_etree())",
            "",
            "        for subscription_method in self.subscription_methods:",
            "            f.append(subscription_method.to_etree())",
            "",
            "        return f",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['feed_name'] = self.feed_name",
            "        if self.available:",
            "            d['available'] = self.available",
            "        d['feed_description'] = self.feed_description",
            "        d['supported_contents'] = self.supported_contents",
            "        d['push_methods'] = []",
            "        for push_method in self.push_methods:",
            "            d['push_methods'].append(push_method.to_dict())",
            "        d['polling_service_instances'] = []",
            "        for polling_service in self.polling_service_instances:",
            "            d['polling_service_instances'].append(polling_service.to_dict())",
            "        d['subscription_methods'] = []",
            "        for subscription_method in self.subscription_methods:",
            "            d['subscription_methods'].append(subscription_method.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Data Feed ===\\n\"",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.available:",
            "            s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Feed Description: %s\\n\" % self.feed_description",
            "        for sc in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % sc",
            "        for pm in self.push_methods:",
            "            s += pm.to_text(line_prepend + STD_INDENT)",
            "        for ps in self.polling_service_instances:",
            "            s += ps.to_text(line_prepend + STD_INDENT)",
            "        for sm in self.subscription_methods:",
            "            s += sm.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = etree_xml.attrib['feed_name']",
            "        kwargs['available'] = None",
            "        if 'available' in etree_xml.attrib:",
            "            tmp = etree_xml.attrib['available']",
            "            kwargs['available'] = tmp.lower() == 'true'",
            "",
            "        kwargs['feed_description'] = get_required(etree_xml, './taxii:Description', ns_map).text",
            "",
            "        kwargs['supported_contents'] = []",
            "        for binding_elt in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            kwargs['supported_contents'].append(binding_elt.text)",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method_elt in etree_xml.xpath('./taxii:Push_Method', namespaces=ns_map):",
            "            kwargs['push_methods'].append(PushMethod.from_etree(push_method_elt))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling_elt in etree_xml.xpath('./taxii:Polling_Service', namespaces=ns_map):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_etree(polling_elt))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_elt in etree_xml.xpath('./taxii:Subscription_Service', namespaces=ns_map):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_etree(subscription_elt))",
            "",
            "        return FeedInformation(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "        kwargs['available'] = d.get('available')",
            "",
            "        kwargs['feed_description'] = d['feed_description']",
            "        kwargs['supported_contents'] = []",
            "        for binding in d.get('supported_contents', []):",
            "            kwargs['supported_contents'].append(binding)",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method in d.get('push_methods', []):",
            "            kwargs['push_methods'].append(PushMethod.from_dict(push_method))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling in d.get('polling_service_instances', []):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_dict(polling))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_method in d.get('subscription_methods', []):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_dict(subscription_method))",
            "",
            "        return FeedInformation(**kwargs)",
            "",
            "",
            "class PushMethod(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Push Method component of a TAXII Feed Information",
            "    component.",
            "",
            "    Args:",
            "        push_protocol (str): a protocol binding that can be used",
            "            to push content to an Inbox Service instance. **Required**",
            "        push_message_bindings (list of str): the message bindings that",
            "            can be used to push content to an Inbox Service instance",
            "            using the protocol identified in the Push Protocol field.",
            "            **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, push_protocol, push_message_bindings):",
            "        self.push_protocol = push_protocol",
            "        self.push_message_bindings = push_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.push_protocol",
            "",
            "    @property",
            "    def push_protocol(self):",
            "        return self._push_protocol",
            "",
            "    @push_protocol.setter",
            "    def push_protocol(self, value):",
            "        do_check(value, 'push_protocol', regex_tuple=uri_regex)",
            "        self._push_protocol = value",
            "",
            "    @property",
            "    def push_message_bindings(self):",
            "        return self._push_message_bindings",
            "",
            "    @push_message_bindings.setter",
            "    def push_message_bindings(self, value):",
            "        do_check(value, 'push_message_bindings', regex_tuple=uri_regex)",
            "        self._push_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Push_Method' % ns_map['taxii'])",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.push_protocol",
            "        for binding in self.push_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['push_protocol'] = self.push_protocol",
            "        d['push_message_bindings'] = []",
            "        for binding in self.push_message_bindings:",
            "            d['push_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.push_protocol",
            "        for mb in self.push_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['push_protocol'] = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        kwargs['push_message_bindings'] = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            kwargs['push_message_bindings'].append(message_binding.text)",
            "        return PushMethod(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PushMethod(**d)",
            "",
            "",
            "class PollingServiceInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Polling Service Instance component of a TAXII Feed",
            "    Information component.",
            "",
            "    Args:",
            "        poll_protocol (str): the protocol binding supported by",
            "            this Poll Service instance. **Required**",
            "        poll_address (str): the address of the TAXII Daemon",
            "            hosting this Poll Service instance. **Required**",
            "        poll_message_bindings (list of str): the message bindings",
            "            supported by this Poll Service instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Polling_Service'",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Polling_Service' % ns_map['taxii'])",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.poll_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii'])",
            "        address.text = self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Service Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        bindings = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class SubscriptionMethod(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Method component of a TAXII Feed Information",
            "    component.",
            "",
            "    Args:",
            "        subscription_protocol (str): the protocol binding supported by",
            "            this Feed Management Service instance. **Required**",
            "        subscription_address (str): the address of the TAXII Daemon",
            "            hosting this Feed Management Service instance.",
            "            **Required**.",
            "        subscription_message_bindings (list of str): the message",
            "            bindings supported by this Feed Management Service",
            "            Instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Subscription_Service'",
            "",
            "    def __init__(self, subscription_protocol, subscription_address,",
            "                 subscription_message_bindings):",
            "        self.subscription_protocol = subscription_protocol",
            "        self.subscription_address = subscription_address",
            "        self.subscription_message_bindings = subscription_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_address",
            "",
            "    @property",
            "    def subscription_protocol(self):",
            "        return self._subscription_protocol",
            "",
            "    @subscription_protocol.setter",
            "    def subscription_protocol(self, value):",
            "        do_check(value, 'subscription_protocol', regex_tuple=uri_regex)",
            "        self._subscription_protocol = value",
            "",
            "    @property",
            "    def subscription_message_bindings(self):",
            "        return self._subscription_message_bindings",
            "",
            "    @subscription_message_bindings.setter",
            "    def subscription_message_bindings(self, value):",
            "        do_check(value, 'subscription_message_bindings', regex_tuple=uri_regex)",
            "        self._subscription_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}%s' % (ns_map['taxii'], self.NAME))",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.subscription_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii'])",
            "        address.text = self.subscription_address",
            "        for binding in self.subscription_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_protocol'] = self.subscription_protocol",
            "        d['subscription_address'] = self.subscription_address",
            "        d['subscription_message_bindings'] = []",
            "        for binding in self.subscription_message_bindings:",
            "            d['subscription_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.subscription_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.subscription_address",
            "        for mb in self.subscription_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii:Address', ns_map).text",
            "        bindings = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class PollRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Request message.",
            "",
            "    Arguments:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed that is being",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional**",
            "        subscription_id (str): the existing subscription the Consumer",
            "            wishes to poll. **Optional**",
            "        content_bindings (list of str): the type of content that is",
            "            requested in the response to this poll. **Optional**, defaults to",
            "            accepting all content bindings.",
            "    \"\"\"",
            "    message_type = MSG_POLL_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 feed_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 content_bindings=None):",
            "        super(PollRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.content_bindings = content_bindings or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        do_check(value, 'content_bindings', regex_tuple=uri_regex)",
            "        self._content_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollRequest, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ebt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii'])",
            "            # TODO: Add TZ Info",
            "            ebt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "            # TODO: Add TZ Info",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for binding in self.content_bindings:",
            "            b = etree.SubElement(xml, '{%s}Content_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollRequest, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label:  # TODO: Add TZ Info",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:  # TODO: Add TZ Info",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_bindings'] = []",
            "        for bind in self.content_bindings:",
            "            d['content_bindings'].append(bind)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin Timestamp Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Excl. Begin Timestamp Label: %s\\n\" % None",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % None",
            "",
            "        if len(self.content_bindings) == 0:",
            "            s += line_prepend + \"  Content Binding: Any Content\\n\"",
            "",
            "        for cb in self.content_bindings:",
            "            s += line_prepend + \"  Content Binding: %s\\n\" % cb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = get_required(etree_xml, './@feed_name', ns_map)",
            "        kwargs['subscription_id'] = get_optional(etree_xml, './@subscription_id', ns_map)",
            "",
            "        ebt_text = get_optional_text(etree_xml, './taxii:Exclusive_Begin_Timestamp', ns_map)",
            "        if ebt_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(ebt_text)",
            "",
            "        iet_text = get_optional_text(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map)",
            "        if iet_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iet_text)",
            "",
            "        kwargs['content_bindings'] = []",
            "        for binding in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            kwargs['content_bindings'].append(binding.text)",
            "",
            "        msg = super(PollRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if d.get('exclusive_begin_timestamp_label'):",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if d.get('inclusive_end_timestamp_label'):",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_bindings'] = d.get('content_bindings', [])",
            "",
            "        msg = super(PollRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class PollResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed that was polled.",
            "            **Required**",
            "        inclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range this response covers.",
            "            **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range this response covers. **Required**",
            "        subscription_id (str): the Subscription ID for which this content",
            "            is being provided. **Optional**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        content_blocks (list of ContentBlock): piece of content",
            "            and additional information related to the content. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_POLL_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 feed_name=None, inclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 message=None, content_blocks=None):",
            "        super(PollResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.feed_name = feed_name",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.inclusive_begin_timestamp_label = inclusive_begin_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label')",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label', can_be_none=True)",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollResponse, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        if self.inclusive_begin_timestamp_label:",
            "            ibt = etree.SubElement(xml, '{%s}Inclusive_Begin_Timestamp' % ns_map['taxii'])",
            "            ibt.text = self.inclusive_begin_timestamp_label.isoformat()",
            "",
            "        iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "        iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollResponse, self).to_dict()",
            "",
            "        d['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        if self.inclusive_begin_timestamp_label:",
            "            d['inclusive_begin_timestamp_label'] = self.inclusive_begin_timestamp_label.isoformat()",
            "        d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "",
            "        if self.inclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Incl. Begin Timestamp Label: %s\\n\" % self.inclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. Begin Timestamp Label: %s\\n\" % None",
            "",
            "        s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['feed_name'] = get_required(etree_xml, './@feed_name', ns_map)",
            "        kwargs['subscription_id'] = get_optional(etree_xml, './@subscription_id', ns_map)",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        ibts_text = get_optional_text(etree_xml, './taxii:Inclusive_Begin_Timestamp', ns_map)",
            "        if ibts_text:",
            "            kwargs['inclusive_begin_timestamp_label'] = parse_datetime_string(ibts_text)",
            "",
            "        iets_text = get_required(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map).text",
            "        kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iets_text)",
            "",
            "        kwargs['content_blocks'] = []",
            "        blocks = etree_xml.xpath('./taxii:Content_Block', namespaces=ns_map)",
            "        for block in blocks:",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        msg = super(PollResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "",
            "        kwargs['message'] = d.get('message')",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['inclusive_begin_timestamp_label'] = None",
            "        if d.get('inclusive_begin_timestamp_label'):",
            "            kwargs['inclusive_begin_timestamp_label'] = parse_datetime_string(d['inclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "        msg = super(PollResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class StatusMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Status message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        status_type (str): One of the defined Status Types or a third-party-",
            "            defined Status Type. **Required**",
            "        status_detail (str): A field for additional information about",
            "            this status in a machine-readable format. **Optional or Prohibited**",
            "            depending on ``status_type``. See TAXII Specification for details.",
            "        message (str): Additional information for the status. There is no",
            "            expectation that this field be interpretable by a machine; it is",
            "            instead targeted to a human operator. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_STATUS_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 status_type=None, status_detail=None, message=None):",
            "        super(StatusMessage, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.status_type = status_type",
            "        self.status_detail = status_detail",
            "        self.message = message",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def status_type(self):",
            "        return self._status_type",
            "",
            "    @status_type.setter",
            "    def status_type(self, value):",
            "        do_check(value, 'status_type')",
            "        self._status_type = value",
            "",
            "    # TODO: is it possible to check the status detail?",
            "",
            "    def to_etree(self):",
            "        xml = super(StatusMessage, self).to_etree()",
            "        xml.attrib['status_type'] = self.status_type",
            "",
            "        if self.status_detail is not None:",
            "            sd = etree.SubElement(xml, '{%s}Status_Detail' % ns_map['taxii'])",
            "            sd.text = self.status_detail",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(StatusMessage, self).to_dict()",
            "        d['status_type'] = self.status_type",
            "        if self.status_detail is not None:",
            "            d['status_detail'] = self.status_detail",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(StatusMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Status Type: %s\\n\" % self.status_type",
            "        if self.status_detail:",
            "            s += line_prepend + \"  Status Detail: %s\\n\" % self.status_detail",
            "        s += line_prepend + \"  Status Message: %s\\n\" % self.message",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = dict(",
            "            status_type=etree_xml.attrib['status_type'],",
            "            status_detail=get_optional_text(etree_xml, './taxii:Status_Detail', ns_map),",
            "            message=get_optional_text(etree_xml, './taxii:Message', ns_map),",
            "        )",
            "",
            "        msg = super(StatusMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = dict(",
            "            status_type=d['status_type'],",
            "            status_detail=d.get('status_detail'),",
            "            message=d.get('message')",
            "        )",
            "",
            "        msg = super(StatusMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class InboxMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Inbox message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        message (str): prose information for the message recipient. **Optional**",
            "        subscription_information (libtaxii.messages_10.SubscriptionInformation): This",
            "            field is only present if this message is being sent to provide",
            "            content in accordance with an existing TAXII Data Feed",
            "            subscription. **Optional**",
            "        content_blocks (list of ContentBlock): Inbox content. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_INBOX_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None,",
            "                 message=None, subscription_information=None,",
            "                 content_blocks=None):",
            "",
            "        super(InboxMessage, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.subscription_information = subscription_information",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def subscription_information(self):",
            "        return self._subscription_information",
            "",
            "    @subscription_information.setter",
            "    def subscription_information(self, value):",
            "        do_check(value, 'subscription_information', type=SubscriptionInformation, can_be_none=True)",
            "        self._subscription_information = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    def to_etree(self):",
            "        xml = super(InboxMessage, self).to_etree()",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        if self.subscription_information:",
            "            xml.append(self.subscription_information.to_etree())",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(InboxMessage, self).to_dict()",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        if self.subscription_information:",
            "            d['subscription_information'] = self.subscription_information.to_dict()",
            "",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(InboxMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.subscription_information:",
            "            s += self.subscription_information.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"  Message has %s Content Blocks\\n\" % len(self.content_blocks)",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(InboxMessage, cls).from_etree(etree_xml)",
            "",
            "        msg.message = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        subs_info = get_optional(etree_xml, './taxii:Source_Subscription', ns_map)",
            "        if subs_info is not None:",
            "            msg.subscription_information = SubscriptionInformation.from_etree(subs_info)",
            "",
            "        content_blocks = etree_xml.xpath('./taxii:Content_Block', namespaces=ns_map)",
            "        msg.content_blocks = []",
            "        for block in content_blocks:",
            "            msg.content_blocks.append(ContentBlock.from_etree(block))",
            "",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(InboxMessage, cls).from_dict(d)",
            "",
            "        msg.message = d.get('message')",
            "",
            "        msg.subscription_information = None",
            "        if 'subscription_information' in d:",
            "            msg.subscription_information = SubscriptionInformation.from_dict(d['subscription_information'])",
            "",
            "        msg.content_blocks = []",
            "        for block in d['content_blocks']:",
            "            msg.content_blocks.append(ContentBlock.from_dict(block))",
            "",
            "        return msg",
            "",
            "",
            "class SubscriptionInformation(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Information component of a TAXII Inbox message.",
            "",
            "    Arguments:",
            "        feed_name (str): the name of the TAXII Data Feed from",
            "            which this content is being provided. **Required**",
            "        subscription_id (str): the Subscription ID for which this",
            "            content is being provided. **Required**",
            "        inclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the time range this Inbox Message",
            "            covers. **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the time range this Inbox Message covers.",
            "            **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, feed_name, subscription_id,",
            "                 inclusive_begin_timestamp_label,",
            "                 inclusive_end_timestamp_label):",
            "        self.feed_name = feed_name",
            "        self.subscription_id = subscription_id",
            "        self.inclusive_begin_timestamp_label = inclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label')",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label')",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Source_Subscription' % ns_map['taxii'])",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        ibtl = etree.SubElement(xml, '{%s}Inclusive_Begin_Timestamp' % ns_map['taxii'])",
            "        ibtl.text = self.inclusive_begin_timestamp_label.isoformat()",
            "",
            "        ietl = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "        ietl.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['feed_name'] = self.feed_name",
            "        d['subscription_id'] = self.subscription_id",
            "        d['inclusive_begin_timestamp_label'] = self.inclusive_begin_timestamp_label.isoformat()",
            "        d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Information ===\\n\"",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Incl. Begin TS Label: %s\\n\" % self.inclusive_begin_timestamp_label.isoformat()",
            "        s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        feed_name = etree_xml.attrib['feed_name']",
            "        subscription_id = etree_xml.attrib['subscription_id']",
            "",
            "        ibtl = parse_datetime_string(get_required(etree_xml, './taxii:Inclusive_Begin_Timestamp', ns_map).text)",
            "        ietl = parse_datetime_string(get_required(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map).text)",
            "",
            "        return SubscriptionInformation(feed_name, subscription_id, ibtl, ietl)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        feed_name = d['feed_name']",
            "        subscription_id = d['subscription_id']",
            "",
            "        ibtl = parse_datetime_string(d['inclusive_begin_timestamp_label'])",
            "        ietl = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        return SubscriptionInformation(feed_name, subscription_id, ibtl, ietl)",
            "",
            "",
            "class ManageFeedSubscriptionRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Feed Subscription Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed to which the",
            "            action applies. **Required**",
            "        action (str): the requested action to take. **Required**",
            "        subscription_id (str): the ID of a previously created subscription.",
            "            **Required** if ``action==``:py:data:`ACT_UNSUBSCRIBE`, else",
            "            **Prohibited**.",
            "        delivery_parameters (list of DeliveryParameters): the delivery parameters",
            "            for this request. **Optional** Absence means delivery is not requested.",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 feed_name=None, action=None, subscription_id=None,",
            "                 delivery_parameters=None):",
            "        super(ManageFeedSubscriptionRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.action = action",
            "        self.subscription_id = subscription_id",
            "        self.delivery_parameters = delivery_parameters",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def action(self):",
            "        return self._action",
            "",
            "    @action.setter",
            "    def action(self, value):",
            "        do_check(value, 'action', value_tuple=ACT_TYPES)",
            "        self._action = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageFeedSubscriptionRequest, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        xml.attrib['action'] = self.action",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageFeedSubscriptionRequest, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        d['action'] = self.action",
            "        d['subscription_id'] = self.subscription_id",
            "        d['delivery_parameters'] = None",
            "        if self.delivery_parameters:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageFeedSubscriptionRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Action: %s\\n\" % self.action",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = dict(",
            "            feed_name=get_required(etree_xml, './@feed_name', ns_map),",
            "            action=get_required(etree_xml, './@action', ns_map),",
            "",
            "            # subscription_id is not required for action 'SUBSCRIBE'",
            "            subscription_id=get_optional(etree_xml, './@subscription_id', ns_map),",
            "        )",
            "",
            "        # marked as required in spec but as optional is XSD",
            "        delivery = get_optional(etree_xml, './taxii:Push_Parameters', ns_map)",
            "        if delivery is not None:",
            "            kwargs['delivery_parameters'] = DeliveryParameters.from_etree(delivery)",
            "",
            "        msg = super(ManageFeedSubscriptionRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = dict(",
            "            feed_name=d['feed_name'],",
            "            action=d['action'],",
            "            subscription_id=d['subscription_id'],",
            "            delivery_parameters=DeliveryParameters.from_dict(d['delivery_parameters'])",
            "        )",
            "",
            "        msg = super(ManageFeedSubscriptionRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class ManageFeedSubscriptionResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Feed Subscription Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed to which",
            "            the action applies. **Required**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        subscription_instances (list of SubscriptionInstance): **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 feed_name=None, message=None, subscription_instances=None):",
            "        super(ManageFeedSubscriptionResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.message = message",
            "        self.subscription_instances = subscription_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def subscription_instances(self):",
            "        return self._subscription_instances",
            "",
            "    @subscription_instances.setter",
            "    def subscription_instances(self, value):",
            "        do_check(value, 'subscription_instances', type=SubscriptionInstance)",
            "        self._subscription_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageFeedSubscriptionResponse, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        for subscription_instance in self.subscription_instances:",
            "            xml.append(subscription_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageFeedSubscriptionResponse, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        d['subscription_instances'] = []",
            "        for subscription_instance in self.subscription_instances:",
            "            d['subscription_instances'].append(subscription_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageFeedSubscriptionResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for si in self.subscription_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = etree_xml.attrib['feed_name']",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for si in etree_xml.xpath('./taxii:Subscription', namespaces=ns_map):",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_etree(si))",
            "",
            "        msg = super(ManageFeedSubscriptionResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for instance in d['subscription_instances']:",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_dict(instance))",
            "",
            "        msg = super(ManageFeedSubscriptionResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Instance component of the Manage Feed Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        subscription_id (str): the id of the subscription. **Required**",
            "        delivery_parameters (libtaxii.messages_10.DeliveryParameters): the parameters",
            "            for this subscription. **Required** if responding to message",
            "            with ``action==``:py:data:`ACT_STATUS`, otherwise **Prohibited**",
            "        poll_instances (list of PollInstance): Each Poll",
            "            Instance represents an instance of a Poll Service that can be",
            "            contacted to retrieve content associated with the new",
            "            Subscription. **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, subscription_id, delivery_parameters=None,",
            "                 poll_instances=None):",
            "        self.subscription_id = subscription_id",
            "        self.delivery_parameters = delivery_parameters",
            "        self.poll_instances = poll_instances or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_id",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    @property",
            "    def poll_instances(self):",
            "        return self._poll_instances",
            "",
            "    @poll_instances.setter",
            "    def poll_instances(self, value):",
            "        do_check(value, 'poll_instances', type=PollInstance, can_be_none=False)",
            "        self._poll_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Subscription' % ns_map['taxii'])",
            "        xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "",
            "        for poll_instance in self.poll_instances:",
            "            xml.append(poll_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        else:",
            "            d['delivery_parameters'] = None",
            "",
            "        d['poll_instances'] = []",
            "        for poll_instance in self.poll_instances:",
            "            d['poll_instances'].append(poll_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_indent=''):",
            "        s = line_indent + \"=== Subscription Instance ===\\n\"",
            "        s += line_indent + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_indent + STD_INDENT)",
            "        for pi in self.poll_instances:",
            "            s += pi.to_text(line_indent + STD_INDENT)",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        subscription_id = etree_xml.attrib['subscription_id']",
            "",
            "        _delivery_parameters = get_optional(etree_xml, './taxii:Push_Parameters', ns_map)",
            "        if _delivery_parameters is not None:",
            "            delivery_parameters = DeliveryParameters.from_etree(_delivery_parameters)",
            "        else:",
            "            delivery_parameters = None",
            "",
            "        poll_instances = []",
            "        for poll_instance in etree_xml.xpath('./taxii:Poll_Instance', namespaces=ns_map):",
            "            poll_instances.append(PollInstance.from_etree(poll_instance))",
            "",
            "        return SubscriptionInstance(subscription_id, delivery_parameters, poll_instances)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        subscription_id = d['subscription_id']",
            "",
            "        if d.get('delivery_parameters'):",
            "            delivery_parameters = DeliveryParameters.from_dict(d['delivery_parameters'])",
            "        else:",
            "            delivery_parameters = None",
            "",
            "        poll_instances = []",
            "        for poll_instance in d['poll_instances']:",
            "            poll_instances.append(PollInstance.from_dict(poll_instance))",
            "",
            "        return SubscriptionInstance(subscription_id, delivery_parameters, poll_instances)",
            "",
            "",
            "class PollInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Poll Instance component of the Manage Feed Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        poll_protocol (str): The protocol binding supported by this",
            "            instance of a Polling Service. **Required**",
            "        poll_address (str): the address of the TAXII Daemon hosting",
            "            this Poll Service. **Required**",
            "        poll_message_bindings (list of str): one or more message bindings",
            "            that can be used when interacting with this Poll Service",
            "            instance. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings=None):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self._poll_message_bindings = poll_message_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Poll_Instance' % ns_map['taxii'])",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        pb.text = self.poll_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii'])",
            "        a.text = self.poll_address",
            "",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        poll_protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        address = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        poll_message_bindings = []",
            "        for b in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            poll_message_bindings.append(b.text)",
            "",
            "        return PollInstance(poll_protocol, address, poll_message_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PollInstance(**d)",
            "",
            "########################################################",
            "# EVERYTHING BELOW HERE IS FOR BACKWARDS COMPATIBILITY #",
            "########################################################",
            "",
            "# Add top-level classes as nested classes for backwards compatibility",
            "DiscoveryResponse.ServiceInstance = ServiceInstance",
            "FeedInformationResponse.FeedInformation = FeedInformation",
            "FeedInformation.PushMethod = PushMethod",
            "FeedInformation.PollingServiceInstance = PollingServiceInstance",
            "FeedInformation.SubscriptionMethod = SubscriptionMethod",
            "ManageFeedSubscriptionResponse.PollInstance = PollInstance",
            "ManageFeedSubscriptionResponse.SubscriptionInstance = SubscriptionInstance",
            "InboxMessage.SubscriptionInformation = SubscriptionInformation",
            "",
            "# Constants not imported in `from constants import *`",
            "MSG_TYPES = MSG_TYPES_10",
            "ST_TYPES = ST_TYPES_10",
            "ACT_TYPES = ACT_TYPES_10",
            "SVC_TYPES = SVC_TYPES_10",
            "",
            "from .common import (generate_message_id)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Creating, handling, and parsing TAXII 1.0 messages.",
            "\"\"\"",
            "",
            "import six",
            "",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "import os",
            "import warnings",
            "",
            "from lxml import etree",
            "",
            "from .common import (parse, parse_datetime_string, append_any_content_etree, TAXIIBase,",
            "                     get_required, get_optional, get_optional_text, parse_xml_string,",
            "                     stringify_content)",
            "from .validation import do_check, uri_regex, check_timestamp_label, message_id_regex_10",
            "from .constants import *",
            "",
            "",
            "def validate_xml(xml_string):",
            "    \"\"\"",
            "    Note that this function has been deprecated. Please see",
            "    libtaxii.validators.SchemaValidator.",
            "",
            "    Validate XML with the TAXII XML Schema 1.0.",
            "",
            "    Args:",
            "        xml_string (str): The XML to validate.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            is_valid = tm10.validate_xml(message.to_xml())",
            "    \"\"\"",
            "",
            "    warnings.warn('Call to deprecated function: libtaxii.messages_10.validate_xml()',",
            "                  category=DeprecationWarning)",
            "",
            "    etree_xml = parse_xml_string(xml_string)",
            "    package_dir, package_filename = os.path.split(__file__)",
            "    schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema.xsd\")",
            "    taxii_schema_doc = parse(schema_file, allow_file=True)",
            "    xml_schema = etree.XMLSchema(taxii_schema_doc)",
            "    valid = xml_schema.validate(etree_xml)",
            "    if not valid:",
            "        return xml_schema.error_log.last_error",
            "    return valid",
            "",
            "",
            "def get_message_from_xml(xml_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from an XML string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the XML.",
            "",
            "    Args:",
            "        xml_string (str): The XML to parse into a TAXII message.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_xml = message.to_xml()",
            "            new_message = tm10.get_message_from_xml(message_xml)",
            "    \"\"\"",
            "    if isinstance(xml_string, six.binary_type):",
            "        xml_string = xml_string.decode(encoding, 'replace')",
            "    etree_xml = parse_xml_string(xml_string)",
            "    qn = etree.QName(etree_xml)",
            "    if qn.namespace != ns_map['taxii']:",
            "        raise ValueError('Unsupported namespace: %s' % qn.namespace)",
            "",
            "    message_type = qn.localname",
            "",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_etree(etree_xml)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_etree(etree_xml)",
            "    if message_type == MSG_FEED_INFORMATION_REQUEST:",
            "        return FeedInformationRequest.from_etree(etree_xml)",
            "    if message_type == MSG_FEED_INFORMATION_RESPONSE:",
            "        return FeedInformationResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_etree(etree_xml)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_etree(etree_xml)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST:",
            "        return ManageFeedSubscriptionRequest.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE:",
            "        return ManageFeedSubscriptionResponse.from_etree(etree_xml)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_dict(d):",
            "    \"\"\"Create a TAXIIMessage object from a dictonary.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the 'message_type' key in the dictionary.",
            "",
            "    Args:",
            "        d (dict): The dictionary to build the TAXII message from.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_dict = message.to_dict()",
            "            new_message = tm10.get_message_from_dict(message_dict)",
            "    \"\"\"",
            "    if 'message_type' not in d:",
            "        raise ValueError('message_type is a required field!')",
            "",
            "    message_type = d['message_type']",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_dict(d)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_dict(d)",
            "    if message_type == MSG_FEED_INFORMATION_REQUEST:",
            "        return FeedInformationRequest.from_dict(d)",
            "    if message_type == MSG_FEED_INFORMATION_RESPONSE:",
            "        return FeedInformationResponse.from_dict(d)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_dict(d)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_dict(d)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_dict(d)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_dict(d)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST:",
            "        return ManageFeedSubscriptionRequest.from_dict(d)",
            "    if message_type == MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE:",
            "        return ManageFeedSubscriptionResponse.from_dict(d)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_json(json_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from a JSON string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the JSON.",
            "",
            "    Args:",
            "        json_string (str): The JSON to parse into a TAXII message.",
            "    \"\"\"",
            "    decoded_string = json_string.decode(encoding, 'replace')",
            "    return get_message_from_dict(json.loads(decoded_string))",
            "",
            "",
            "class TAXIIBase10(TAXIIBase):",
            "    version = VID_TAXII_XML_10",
            "",
            "",
            "class DeliveryParameters(TAXIIBase10):",
            "",
            "    \"\"\"Delivery Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Feed content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Feed to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "        content_bindings (list of str): contains Content Binding IDs",
            "            indicating which types of contents the Consumer requests to",
            "            receive for this TAXII Data Feed. **Optional**",
            "    \"\"\"",
            "",
            "    # TODO: Should the default arguments of these change? I'm not sure these are",
            "    # actually optional",
            "",
            "    def __init__(self, inbox_protocol=None, inbox_address=None,",
            "                 delivery_message_binding=None, content_bindings=None):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.delivery_message_binding = delivery_message_binding",
            "        self.content_bindings = content_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        # TODO: Can inbox_address be validated?",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def delivery_message_binding(self):",
            "        return self._delivery_message_binding",
            "",
            "    @delivery_message_binding.setter",
            "    def delivery_message_binding(self, value):",
            "        do_check(value, 'delivery_message_binding', regex_tuple=uri_regex)",
            "        self._delivery_message_binding = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        do_check(value, 'content_bindings', regex_tuple=uri_regex)",
            "        self._content_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Push_Parameters' % ns_map['taxii'])",
            "",
            "        if self.inbox_protocol is not None:",
            "            pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "            pb.text = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii'])",
            "            a.text = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii'])",
            "            mb.text = self.delivery_message_binding",
            "",
            "        for binding in self.content_bindings:",
            "            cb = etree.SubElement(xml, '{%s}Content_Binding' % ns_map['taxii'])",
            "            cb.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        if self.inbox_protocol is not None:",
            "            d['inbox_protocol'] = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            d['inbox_address'] = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            d['delivery_message_binding'] = self.delivery_message_binding",
            "",
            "        d['content_bindings'] = []",
            "        for binding in self.content_bindings:",
            "            d['content_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Parameters ===\\n\"",
            "        s += line_prepend + \"  Inbox Protocol: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.inbox_address",
            "        s += line_prepend + \"  Message Binding: %s\\n\" % self.delivery_message_binding",
            "        if len(self.content_bindings) > 0:",
            "            s += line_prepend + \"  Content Bindings: Any Content\\n\"",
            "        for cb in self.content_bindings:",
            "            s += line_prepend + \"  Content Binding: %s\\n\" % str(cb)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "",
            "        inbox_protocol = get_optional_text(etree_xml, './taxii:Protocol_Binding', ns_map)",
            "        inbox_address = get_optional_text(etree_xml, './taxii:Address', ns_map)",
            "        delivery_message_binding = get_optional_text(etree_xml, './taxii:Message_Binding', ns_map)",
            "",
            "        content_bindings = []",
            "        for binding in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            content_bindings.append(binding.text)",
            "",
            "        return DeliveryParameters(inbox_protocol, inbox_address, delivery_message_binding, content_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return DeliveryParameters(**d)",
            "",
            "",
            "class TAXIIMessage(TAXIIBase10):",
            "",
            "    \"\"\"Encapsulate properties common to all TAXII Messages (such as headers).",
            "",
            "    This class is extended by each Message Type (e.g., DiscoveryRequest), with",
            "    each subclass containing subclass-specific information",
            "    \"\"\"",
            "",
            "    message_type = 'TAXIIMessage'",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None):",
            "        \"\"\"Create a new TAXIIMessage",
            "",
            "        Arguments:",
            "        - message_id (string) - A value identifying this message.",
            "        - in_response_to (string) - Contains the Message ID of the message to",
            "          which this is a response.",
            "        - extended_headers (dictionary) - A dictionary of name/value pairs for",
            "          use as Extended Headers",
            "        \"\"\"",
            "        self.message_id = message_id",
            "        self.in_response_to = in_response_to",
            "        if extended_headers is None:",
            "            self.extended_headers = {}",
            "        else:",
            "            self.extended_headers = extended_headers",
            "",
            "    @property",
            "    def message_id(self):",
            "        return self._message_id",
            "",
            "    @message_id.setter",
            "    def message_id(self, value):",
            "        do_check(value, 'message_id', regex_tuple=message_id_regex_10)",
            "        self._message_id = value",
            "",
            "    @property",
            "    def in_response_to(self):",
            "        return self._in_response_to",
            "",
            "    @in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=message_id_regex_10, can_be_none=True)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def extended_headers(self):",
            "        return self._extended_headers",
            "",
            "    @extended_headers.setter",
            "    def extended_headers(self, value):",
            "        do_check(list(value.keys()), 'extended_headers.keys()', regex_tuple=uri_regex)",
            "        self._extended_headers = value",
            "",
            "    def to_etree(self):",
            "        \"\"\"Creates the base etree for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to XML, subclasses should call this method",
            "        first, then create their specific XML constructs.",
            "        \"\"\"",
            "        root_elt = etree.Element('{%s}%s' % (ns_map['taxii'], self.message_type), nsmap=ns_map)",
            "        root_elt.attrib['message_id'] = str(self.message_id)",
            "",
            "        if self.in_response_to is not None:",
            "            root_elt.attrib['in_response_to'] = str(self.in_response_to)",
            "",
            "        if len(self.extended_headers) > 0:",
            "            eh = etree.SubElement(root_elt, '{%s}Extended_Headers' % ns_map['taxii'])",
            "",
            "            for name, value in list(self.extended_headers.items()):",
            "                h = etree.SubElement(eh, '{%s}Extended_Header' % ns_map['taxii'])",
            "                h.attrib['name'] = name",
            "                append_any_content_etree(h, value)",
            "                # h.text = value",
            "        return root_elt",
            "",
            "    def to_xml(self, pretty_print=False):",
            "        \"\"\"Convert a message to XML.",
            "",
            "        Subclasses shouldn't implement this method, as it is mainly a wrapper",
            "        for cls.to_etree.",
            "        \"\"\"",
            "        return etree.tostring(self.to_etree(), pretty_print=pretty_print, encoding='utf-8')",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create the base dictionary for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to dictionary, subclasses should call this",
            "        method first, then create their specific dictionary constructs.",
            "        \"\"\"",
            "        d = {}",
            "        d['message_type'] = self.message_type",
            "        d['message_id'] = self.message_id",
            "        if self.in_response_to is not None:",
            "            d['in_response_to'] = self.in_response_to",
            "        d['extended_headers'] = {}",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            if isinstance(v, etree._Element) or isinstance(v, etree._ElementTree):",
            "                v = etree.tostring(v, encoding='utf-8')",
            "            elif not isinstance(v, six.string_types):",
            "                v = str(v)",
            "            d['extended_headers'][k] = v",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"Message Type: %s\\n\" % self.message_type",
            "        s += line_prepend + \"Message ID: %s\" % self.message_id",
            "        if self.in_response_to:",
            "            s += \"; In Response To: %s\" % self.in_response_to",
            "        s += \"\\n\"",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            s += line_prepend + \"Extended Header: %s = %s\" % (k, v)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from an etree.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from etree, subclasses should call this method",
            "        first, then parse their specific XML constructs.",
            "        \"\"\"",
            "",
            "        # Check namespace and element name of the root element",
            "        expected_tag = '{%s}%s' % (ns_map['taxii'], cls.message_type)",
            "        tag = src_etree.tag",
            "        if tag != expected_tag:",
            "            raise ValueError('%s != %s' % (tag, expected_tag))",
            "",
            "        # Get the message ID",
            "        message_id = get_required(src_etree, '/taxii:*/@message_id', ns_map)",
            "",
            "        # Get in response to, if present",
            "        in_response_to = get_optional(src_etree, '/taxii:*/@in_response_to', ns_map)",
            "        if in_response_to is not None:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        # Get the Extended headers",
            "        extended_header_list = src_etree.xpath('/taxii:*/taxii:Extended_Headers/taxii:Extended_Header', namespaces=ns_map)",
            "        extended_headers = {}",
            "        for header in extended_header_list:",
            "            eh_name = header.xpath('./@name')[0]",
            "            # eh_value = header.text",
            "            if len(header) == 0:  # This has string content",
            "                eh_value = header.text",
            "            else:  # This has XML content",
            "                eh_value = header[0]",
            "",
            "            extended_headers[eh_name] = eh_value",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_xml(cls, xml):",
            "        \"\"\"Parse a Message from XML.",
            "",
            "        Subclasses shouldn't implemnet this method, as it is mainly a wrapper",
            "        for cls.from_etree.",
            "        \"\"\"",
            "        etree_xml = parse_xml_string(xml)",
            "        return cls.from_etree(etree_xml)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from a dictionary.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from dictionary, subclasses should call this",
            "        method first, then parse their specific dictionary constructs.",
            "        \"\"\"",
            "        message_type = d['message_type']",
            "        if message_type != cls.message_type:",
            "            raise ValueError('%s != %s' % (message_type, cls.message_type))",
            "        message_id = d['message_id']",
            "        extended_headers = {}",
            "        for k, v in six.iteritems(d['extended_headers']):",
            "            try:",
            "                v = parse(v, allow_file=False)",
            "            except etree.XMLSyntaxError:",
            "                pass",
            "            extended_headers[k] = v",
            "",
            "        in_response_to = d.get('in_response_to')",
            "        if in_response_to:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class ContentBlock(TAXIIBase10):",
            "",
            "    \"\"\"A TAXII Content Block.",
            "",
            "    Args:",
            "        content_binding (str): a Content Binding ID or nesting expression",
            "            indicating the type of content contained in the Content field of this",
            "            Content Block. **Required**",
            "        content (string or etree): a piece of content of the type specified",
            "            by the Content Binding. **Required**",
            "        timestamp_label (datetime): the Timestamp Label associated with this",
            "            Content Block. **Optional**",
            "        padding (string): an arbitrary amount of padding for this Content",
            "            Block. **Optional**",
            "    \"\"\"",
            "",
            "    NAME = 'Content_Block'",
            "",
            "    def __init__(self, content_binding, content, timestamp_label=None, padding=None):",
            "        self.content_binding = content_binding",
            "        self.content = content",
            "        self.timestamp_label = timestamp_label",
            "        self.padding = padding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.content[:25]",
            "",
            "    @property",
            "    def content_binding(self):",
            "        return self._content_binding",
            "",
            "    @content_binding.setter",
            "    def content_binding(self, value):",
            "        do_check(value, 'content_binding', regex_tuple=uri_regex)",
            "        self._content_binding = value",
            "",
            "    @property",
            "    def content(self):",
            "        if self.content_is_xml:",
            "            return etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            return self._content",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        do_check(value, 'content')  # Just check for not None",
            "        self._content, self.content_is_xml = stringify_content(value)",
            "",
            "    @property",
            "    def content_is_xml(self):",
            "        return self._content_is_xml",
            "",
            "    @content_is_xml.setter",
            "    def content_is_xml(self, value):",
            "        do_check(value, 'content_is_xml', value_tuple=(True, False))",
            "        self._content_is_xml = value",
            "",
            "    @property",
            "    def timestamp_label(self):",
            "        return self._timestamp_label",
            "",
            "    @timestamp_label.setter",
            "    def timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'timestamp_label', can_be_none=True)",
            "        self._timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        block = etree.Element('{%s}Content_Block' % ns_map['taxii'], nsmap=ns_map)",
            "        cb = etree.SubElement(block, '{%s}Content_Binding' % ns_map['taxii'])",
            "        cb.text = self.content_binding",
            "        c = etree.SubElement(block, '{%s}Content' % ns_map['taxii'])",
            "",
            "        if self.content_is_xml:",
            "            c.append(self._content)",
            "        else:",
            "            c.text = self._content",
            "",
            "        if self.timestamp_label:",
            "            tl = etree.SubElement(block, '{%s}Timestamp_Label' % ns_map['taxii'])",
            "            tl.text = self.timestamp_label.isoformat()",
            "",
            "        if self.padding is not None:",
            "            p = etree.SubElement(block, '{%s}Padding' % ns_map['taxii'])",
            "            p.text = self.padding",
            "",
            "        return block",
            "",
            "    def to_dict(self):",
            "        block = {}",
            "        block['content_binding'] = self.content_binding",
            "",
            "        if self.content_is_xml:",
            "            block['content'] = etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            block['content'] = self._content",
            "        block['content_is_xml'] = self.content_is_xml",
            "",
            "        if self.timestamp_label:",
            "            block['timestamp_label'] = self.timestamp_label.isoformat()",
            "",
            "        if self.padding is not None:",
            "            block['padding'] = self.padding",
            "",
            "        return block",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Content Block ===\\n\"",
            "        s += line_prepend + \"  Content Binding: %s\\n\" % self.content_binding",
            "        s += line_prepend + \"  Content Length: %s\\n\" % len(self.content)",
            "        s += line_prepend + \"  (Only content length is shown for brevity)\\n\"",
            "        if self.timestamp_label:",
            "            s += line_prepend + \"  Timestamp Label: %s\\n\" % self.timestamp_label.isoformat()",
            "        s += line_prepend + \"  Padding: %s\\n\" % self.padding",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['content_binding'] = get_required(etree_xml, './taxii:Content_Binding', ns_map).text",
            "",
            "        kwargs['padding'] = get_optional_text(etree_xml, './taxii:Padding', ns_map)",
            "",
            "        ts_text = get_optional_text(etree_xml, './taxii:Timestamp_Label', ns_map)",
            "        if ts_text:",
            "            kwargs['timestamp_label'] = parse_datetime_string(ts_text)",
            "",
            "        content = get_required(etree_xml, './taxii:Content', ns_map)",
            "",
            "        if len(content) == 0:  # This has string content",
            "            kwargs['content'] = content.text",
            "        else:  # This has XML content",
            "            kwargs['content'] = content[0]",
            "",
            "        return ContentBlock(**kwargs)",
            "",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['content_binding'] = d['content_binding']",
            "        kwargs['padding'] = d.get('padding')",
            "",
            "        if d.get('timestamp_label'):",
            "            kwargs['timestamp_label'] = parse_datetime_string(d['timestamp_label'])",
            "",
            "        is_xml = d.get('content_is_xml', False)",
            "        if is_xml:",
            "            #FIXME: to parse or not to parse the content - this should be configurable",
            "            kwargs['content'] = parse(d['content'], allow_file=False)",
            "        else:",
            "            kwargs['content'] = d['content']",
            "",
            "        cb = ContentBlock(**kwargs)",
            "        return cb",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "# TAXII Message Classes #",
            "",
            "class DiscoveryRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_REQUEST",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class DiscoveryResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        service_instances (list of `ServiceInstance`): a list of",
            "            service instances that this response contains. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_DISCOVERY_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, service_instances=None):",
            "        super(DiscoveryResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.service_instances = service_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def service_instances(self):",
            "        return self._service_instances",
            "",
            "    @service_instances.setter",
            "    def service_instances(self, value):",
            "        do_check(value, 'service_instances', type=ServiceInstance)",
            "        self._service_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(DiscoveryResponse, self).to_etree()",
            "        for service_instance in self.service_instances:",
            "            xml.append(service_instance.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(DiscoveryResponse, self).to_dict()",
            "        d['service_instances'] = []",
            "        for service_instance in self.service_instances:",
            "            d['service_instances'].append(service_instance.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(DiscoveryResponse, self).to_text(line_prepend)",
            "        for si in self.service_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(DiscoveryResponse, cls).from_etree(etree_xml)",
            "        msg.service_instances = []",
            "        for service_instance in etree_xml.xpath('./taxii:Service_Instance', namespaces=ns_map):",
            "            si = ServiceInstance.from_etree(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(DiscoveryResponse, cls).from_dict(d)",
            "        msg.service_instances = []",
            "        for service_instance in d['service_instances']:",
            "            si = ServiceInstance.from_dict(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "",
            "class ServiceInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Service Instance component of a TAXII Discovery Response Message.",
            "",
            "    Args:",
            "        service_type (string): identifies the Service Type of this",
            "            Service Instance. **Required**",
            "        services_version (string): identifies the TAXII Services",
            "            Specification to which this Service conforms. **Required**",
            "        protocol_binding (string): identifies the protocol binding",
            "            supported by this Service. **Required**",
            "        service_address (string): identifies the network address of the",
            "            TAXII Daemon that hosts this Service. **Required**",
            "        message_bindings (list of strings): identifies the message",
            "            bindings supported by this Service instance. **Required**",
            "        inbox_service_accepted_content (list of strings): identifies",
            "            content bindings that this Inbox Service is willing to accept.",
            "            **Optional**",
            "        available (boolean): indicates whether the identity of the",
            "            requester (authenticated or otherwise) is allowed to access this",
            "            TAXII Service. **Optional**",
            "        message (string): contains a message regarding this Service",
            "            instance. **Optional**",
            "",
            "    The ``message_bindings`` list must contain at least one value.",
            "    \"\"\"",
            "",
            "    def __init__(self, service_type, services_version, protocol_binding,",
            "                 service_address, message_bindings,",
            "                 inbox_service_accepted_content=None, available=None,",
            "                 message=None):",
            "        self.service_type = service_type",
            "        self.services_version = services_version",
            "        self.protocol_binding = protocol_binding",
            "        self.service_address = service_address",
            "        self.message_bindings = message_bindings",
            "        self.inbox_service_accepted_content = inbox_service_accepted_content or []",
            "        self.available = available",
            "        self.message = message",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.service_address",
            "",
            "    @property",
            "    def service_type(self):",
            "        return self._service_type",
            "",
            "    @service_type.setter",
            "    def service_type(self, value):",
            "        do_check(value, 'service_type', value_tuple=SVC_TYPES)",
            "        self._service_type = value",
            "",
            "    @property",
            "    def services_version(self):",
            "        return self._services_version",
            "",
            "    @services_version.setter",
            "    def services_version(self, value):",
            "        do_check(value, 'services_version', regex_tuple=uri_regex)",
            "        self._services_version = value",
            "",
            "    @property",
            "    def protocol_binding(self):",
            "        return self._protocol_binding",
            "",
            "    @protocol_binding.setter",
            "    def protocol_binding(self, value):",
            "        do_check(value, 'protocol_binding', regex_tuple=uri_regex)",
            "        self._protocol_binding = value",
            "",
            "    @property",
            "    def service_address(self):",
            "        return self._service_address",
            "",
            "    @service_address.setter",
            "    def service_address(self, value):",
            "        self._service_address = value",
            "",
            "    @property",
            "    def message_bindings(self):",
            "        return self._message_bindings",
            "",
            "    @message_bindings.setter",
            "    def message_bindings(self, value):",
            "        do_check(value, 'message_bindings', regex_tuple=uri_regex)",
            "        self._message_bindings = value",
            "",
            "    @property",
            "    def inbox_service_accepted_content(self):",
            "        return self._inbox_service_accepted_content",
            "",
            "    @inbox_service_accepted_content.setter",
            "    def inbox_service_accepted_content(self, value):",
            "        do_check(value, 'inbox_service_accepted_content', regex_tuple=uri_regex)",
            "        self._inbox_service_accepted_content = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Service_Instance' % ns_map['taxii'])",
            "        si.attrib['service_type'] = self.service_type",
            "        si.attrib['service_version'] = self.services_version",
            "        if self.available:",
            "            si.attrib['available'] = str(self.available).lower()",
            "",
            "        protocol_binding = etree.SubElement(si, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        protocol_binding.text = self.protocol_binding",
            "",
            "        service_address = etree.SubElement(si, '{%s}Address' % ns_map['taxii'])",
            "        service_address.text = self.service_address",
            "",
            "        for mb in self.message_bindings:",
            "            message_binding = etree.SubElement(si, '{%s}Message_Binding' % ns_map['taxii'])",
            "            message_binding.text = mb",
            "",
            "        for cb in self.inbox_service_accepted_content:",
            "            content_binding = etree.SubElement(si, '{%s}Content_Binding' % ns_map['taxii'])",
            "            content_binding.text = cb",
            "",
            "        if self.message is not None:",
            "            message = etree.SubElement(si, '{%s}Message' % ns_map['taxii'])",
            "            message.text = self.message",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['service_type'] = self.service_type",
            "        d['services_version'] = self.services_version",
            "        d['protocol_binding'] = self.protocol_binding",
            "        d['service_address'] = self.service_address",
            "        d['message_bindings'] = self.message_bindings",
            "        d['inbox_service_accepted_content'] = self.inbox_service_accepted_content",
            "        d['available'] = self.available",
            "        d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Service Instance===\\n\"",
            "        s += line_prepend + \"  Service Type: %s\\n\" % self.service_type",
            "        s += line_prepend + \"  Services Version: %s\\n\" % self.services_version",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.protocol_binding",
            "        s += line_prepend + \"  Address: %s\\n\" % self.service_address",
            "        for mb in self.message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if len(self.inbox_service_accepted_content) == 0:",
            "            s += line_prepend + \"  Inbox Service Accepts: %s\\n\" % None",
            "        for isac in self.inbox_service_accepted_content:",
            "            s += line_prepend + \"  Inbox Service Accepts: %s\\n\" % isac",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):  # Expects a taxii:Service_Instance element",
            "        service_type = etree_xml.attrib['service_type']",
            "        services_version = etree_xml.attrib['service_version']",
            "        available = None",
            "        if etree_xml.attrib.get('available'):",
            "            tmp_available = etree_xml.attrib['available']",
            "            available = tmp_available.lower() == 'true'",
            "",
            "        protocol_binding = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        service_address = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        for mb in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            message_bindings.append(mb.text)",
            "",
            "        inbox_service_accepted_contents = []",
            "        for cb in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            inbox_service_accepted_contents.append(cb.text)",
            "",
            "        message = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        return ServiceInstance(service_type, services_version, protocol_binding,",
            "                service_address, message_bindings, inbox_service_accepted_contents,",
            "                available, message)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return ServiceInstance(**d)",
            "",
            "",
            "class FeedInformationRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Feed Information Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_FEED_INFORMATION_REQUEST",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class FeedInformationResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Feed Information Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_informations (list of FeedInformation): A list",
            "            of FeedInformation objects to be contained in this response.",
            "            **Optional**",
            "    \"\"\"",
            "    message_type = MSG_FEED_INFORMATION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, feed_informations=None):",
            "        super(FeedInformationResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.feed_informations = feed_informations or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=message_id_regex_10)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_informations(self):",
            "        return self._feed_informations",
            "",
            "    @feed_informations.setter",
            "    def feed_informations(self, value):",
            "        do_check(value, 'feed_informations', type=FeedInformation)",
            "        self._feed_informations = value",
            "",
            "    def to_etree(self):",
            "        xml = super(FeedInformationResponse, self).to_etree()",
            "        for feed in self.feed_informations:",
            "            xml.append(feed.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(FeedInformationResponse, self).to_dict()",
            "        d['feed_informations'] = []",
            "        for feed in self.feed_informations:",
            "            d['feed_informations'].append(feed.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(FeedInformationResponse, self).to_text(line_prepend)",
            "        for feed in self.feed_informations:",
            "            s += feed.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(FeedInformationResponse, cls).from_etree(etree_xml)",
            "        msg.feed_informations = []",
            "        feed_informations = etree_xml.xpath('./taxii:Feed', namespaces=ns_map)",
            "        for feed in feed_informations:",
            "            msg.feed_informations.append(FeedInformation.from_etree(feed))",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(FeedInformationResponse, cls).from_dict(d)",
            "        msg.feed_informations = []",
            "        for feed in d['feed_informations']:",
            "            msg.feed_informations.append(FeedInformation.from_dict(feed))",
            "        return msg",
            "",
            "",
            "class FeedInformation(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Feed Information component of a TAXII Feed Information Response",
            "    Message.",
            "",
            "    Arguments:",
            "        feed_name (str): the name by which this TAXII Data Feed is",
            "            identified. **Required**",
            "        feed_description (str): a prose description of this TAXII",
            "            Data Feed. **Required**",
            "        supported_contents (list of str): Content Binding IDs",
            "            indicating which types of content are currently expressed in this",
            "            TAXII Data Feed. **Required**",
            "        available (boolean): whether the identity of the requester",
            "            (authenticated or otherwise) is allowed to access this TAXII",
            "            Service. **Optional** Default: ``None``, indicating \"unknown\"",
            "        push_methods (list of PushMethod objects): the protocols that",
            "            can be used to push content via a subscription. **Optional**",
            "        polling_service_instances (list of PollingServiceInstance objects):",
            "            the bindings and address a Consumer can use to interact with a",
            "            Poll Service instance that supports this TAXII Data Feed.",
            "            **Optional**",
            "        subscription_methods (list of SubscriptionMethod objects): the",
            "            protocol and address of the TAXII Daemon hosting the Feed",
            "            Management Service that can process subscriptions for this TAXII",
            "            Data Feed. **Optional**",
            "",
            "    The absense of ``push_methods`` indicates no push methods.  The absense",
            "    of ``polling_service_instances`` indicates no polling services.  At",
            "    least one of ``push_methods`` and ``polling_service_instances`` must not",
            "    be empty. The absense of ``subscription_methods`` indicates no",
            "    subscription services.",
            "    \"\"\"",
            "",
            "    def __init__(self, feed_name, feed_description, supported_contents,",
            "                 available=None, push_methods=None,",
            "                 polling_service_instances=None, subscription_methods=None):",
            "",
            "        self.feed_name = feed_name",
            "        self.available = available",
            "        self.feed_description = feed_description",
            "        self.supported_contents = supported_contents",
            "        self.push_methods = push_methods or []",
            "        self.polling_service_instances = polling_service_instances or []",
            "        self.subscription_methods = subscription_methods or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.feed_name",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        do_check(value, 'supported_contents', regex_tuple=uri_regex)",
            "        self._supported_contents = value",
            "",
            "    @property",
            "    def push_methods(self):",
            "        return self._push_methods",
            "",
            "    @push_methods.setter",
            "    def push_methods(self, value):",
            "        do_check(value, 'push_methods', type=PushMethod)",
            "        self._push_methods = value",
            "",
            "    @property",
            "    def polling_service_instances(self):",
            "        return self._polling_service_instances",
            "",
            "    @polling_service_instances.setter",
            "    def polling_service_instances(self, value):",
            "        do_check(value, 'polling_service_instances', type=PollingServiceInstance)",
            "        self._polling_service_instances = value",
            "",
            "    @property",
            "    def subscription_methods(self):",
            "        return self._subscription_methods",
            "",
            "    @subscription_methods.setter",
            "    def subscription_methods(self, value):",
            "        do_check(value, 'subscription_methods', type=SubscriptionMethod)",
            "        self._subscription_methods = value",
            "",
            "    def to_etree(self):",
            "        f = etree.Element('{%s}Feed' % ns_map['taxii'])",
            "        f.attrib['feed_name'] = self.feed_name",
            "        if self.available:",
            "            f.attrib['available'] = str(self.available).lower()",
            "        feed_description = etree.SubElement(f, '{%s}Description' % ns_map['taxii'])",
            "        feed_description.text = self.feed_description",
            "",
            "        for binding in self.supported_contents:",
            "            cb = etree.SubElement(f, '{%s}Content_Binding' % ns_map['taxii'])",
            "            cb.text = binding",
            "",
            "        for push_method in self.push_methods:",
            "            f.append(push_method.to_etree())",
            "",
            "        for polling_service in self.polling_service_instances:",
            "            f.append(polling_service.to_etree())",
            "",
            "        for subscription_method in self.subscription_methods:",
            "            f.append(subscription_method.to_etree())",
            "",
            "        return f",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['feed_name'] = self.feed_name",
            "        if self.available:",
            "            d['available'] = self.available",
            "        d['feed_description'] = self.feed_description",
            "        d['supported_contents'] = self.supported_contents",
            "        d['push_methods'] = []",
            "        for push_method in self.push_methods:",
            "            d['push_methods'].append(push_method.to_dict())",
            "        d['polling_service_instances'] = []",
            "        for polling_service in self.polling_service_instances:",
            "            d['polling_service_instances'].append(polling_service.to_dict())",
            "        d['subscription_methods'] = []",
            "        for subscription_method in self.subscription_methods:",
            "            d['subscription_methods'].append(subscription_method.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Data Feed ===\\n\"",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.available:",
            "            s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Feed Description: %s\\n\" % self.feed_description",
            "        for sc in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % sc",
            "        for pm in self.push_methods:",
            "            s += pm.to_text(line_prepend + STD_INDENT)",
            "        for ps in self.polling_service_instances:",
            "            s += ps.to_text(line_prepend + STD_INDENT)",
            "        for sm in self.subscription_methods:",
            "            s += sm.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = etree_xml.attrib['feed_name']",
            "        kwargs['available'] = None",
            "        if 'available' in etree_xml.attrib:",
            "            tmp = etree_xml.attrib['available']",
            "            kwargs['available'] = tmp.lower() == 'true'",
            "",
            "        kwargs['feed_description'] = get_required(etree_xml, './taxii:Description', ns_map).text",
            "",
            "        kwargs['supported_contents'] = []",
            "        for binding_elt in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            kwargs['supported_contents'].append(binding_elt.text)",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method_elt in etree_xml.xpath('./taxii:Push_Method', namespaces=ns_map):",
            "            kwargs['push_methods'].append(PushMethod.from_etree(push_method_elt))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling_elt in etree_xml.xpath('./taxii:Polling_Service', namespaces=ns_map):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_etree(polling_elt))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_elt in etree_xml.xpath('./taxii:Subscription_Service', namespaces=ns_map):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_etree(subscription_elt))",
            "",
            "        return FeedInformation(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "        kwargs['available'] = d.get('available')",
            "",
            "        kwargs['feed_description'] = d['feed_description']",
            "        kwargs['supported_contents'] = []",
            "        for binding in d.get('supported_contents', []):",
            "            kwargs['supported_contents'].append(binding)",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method in d.get('push_methods', []):",
            "            kwargs['push_methods'].append(PushMethod.from_dict(push_method))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling in d.get('polling_service_instances', []):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_dict(polling))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_method in d.get('subscription_methods', []):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_dict(subscription_method))",
            "",
            "        return FeedInformation(**kwargs)",
            "",
            "",
            "class PushMethod(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Push Method component of a TAXII Feed Information",
            "    component.",
            "",
            "    Args:",
            "        push_protocol (str): a protocol binding that can be used",
            "            to push content to an Inbox Service instance. **Required**",
            "        push_message_bindings (list of str): the message bindings that",
            "            can be used to push content to an Inbox Service instance",
            "            using the protocol identified in the Push Protocol field.",
            "            **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, push_protocol, push_message_bindings):",
            "        self.push_protocol = push_protocol",
            "        self.push_message_bindings = push_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.push_protocol",
            "",
            "    @property",
            "    def push_protocol(self):",
            "        return self._push_protocol",
            "",
            "    @push_protocol.setter",
            "    def push_protocol(self, value):",
            "        do_check(value, 'push_protocol', regex_tuple=uri_regex)",
            "        self._push_protocol = value",
            "",
            "    @property",
            "    def push_message_bindings(self):",
            "        return self._push_message_bindings",
            "",
            "    @push_message_bindings.setter",
            "    def push_message_bindings(self, value):",
            "        do_check(value, 'push_message_bindings', regex_tuple=uri_regex)",
            "        self._push_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Push_Method' % ns_map['taxii'])",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.push_protocol",
            "        for binding in self.push_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['push_protocol'] = self.push_protocol",
            "        d['push_message_bindings'] = []",
            "        for binding in self.push_message_bindings:",
            "            d['push_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.push_protocol",
            "        for mb in self.push_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['push_protocol'] = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        kwargs['push_message_bindings'] = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            kwargs['push_message_bindings'].append(message_binding.text)",
            "        return PushMethod(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PushMethod(**d)",
            "",
            "",
            "class PollingServiceInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Polling Service Instance component of a TAXII Feed",
            "    Information component.",
            "",
            "    Args:",
            "        poll_protocol (str): the protocol binding supported by",
            "            this Poll Service instance. **Required**",
            "        poll_address (str): the address of the TAXII Daemon",
            "            hosting this Poll Service instance. **Required**",
            "        poll_message_bindings (list of str): the message bindings",
            "            supported by this Poll Service instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Polling_Service'",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Polling_Service' % ns_map['taxii'])",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.poll_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii'])",
            "        address.text = self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Service Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        bindings = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class SubscriptionMethod(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Method component of a TAXII Feed Information",
            "    component.",
            "",
            "    Args:",
            "        subscription_protocol (str): the protocol binding supported by",
            "            this Feed Management Service instance. **Required**",
            "        subscription_address (str): the address of the TAXII Daemon",
            "            hosting this Feed Management Service instance.",
            "            **Required**.",
            "        subscription_message_bindings (list of str): the message",
            "            bindings supported by this Feed Management Service",
            "            Instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Subscription_Service'",
            "",
            "    def __init__(self, subscription_protocol, subscription_address,",
            "                 subscription_message_bindings):",
            "        self.subscription_protocol = subscription_protocol",
            "        self.subscription_address = subscription_address",
            "        self.subscription_message_bindings = subscription_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_address",
            "",
            "    @property",
            "    def subscription_protocol(self):",
            "        return self._subscription_protocol",
            "",
            "    @subscription_protocol.setter",
            "    def subscription_protocol(self, value):",
            "        do_check(value, 'subscription_protocol', regex_tuple=uri_regex)",
            "        self._subscription_protocol = value",
            "",
            "    @property",
            "    def subscription_message_bindings(self):",
            "        return self._subscription_message_bindings",
            "",
            "    @subscription_message_bindings.setter",
            "    def subscription_message_bindings(self, value):",
            "        do_check(value, 'subscription_message_bindings', regex_tuple=uri_regex)",
            "        self._subscription_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}%s' % (ns_map['taxii'], self.NAME))",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        proto_bind.text = self.subscription_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii'])",
            "        address.text = self.subscription_address",
            "        for binding in self.subscription_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_protocol'] = self.subscription_protocol",
            "        d['subscription_address'] = self.subscription_address",
            "        d['subscription_message_bindings'] = []",
            "        for binding in self.subscription_message_bindings:",
            "            d['subscription_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.subscription_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.subscription_address",
            "        for mb in self.subscription_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii:Address', ns_map).text",
            "        bindings = []",
            "        for message_binding in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class PollRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Request message.",
            "",
            "    Arguments:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed that is being",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional**",
            "        subscription_id (str): the existing subscription the Consumer",
            "            wishes to poll. **Optional**",
            "        content_bindings (list of str): the type of content that is",
            "            requested in the response to this poll. **Optional**, defaults to",
            "            accepting all content bindings.",
            "    \"\"\"",
            "    message_type = MSG_POLL_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 feed_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 content_bindings=None):",
            "        super(PollRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.content_bindings = content_bindings or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        do_check(value, 'content_bindings', regex_tuple=uri_regex)",
            "        self._content_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollRequest, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ebt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii'])",
            "            # TODO: Add TZ Info",
            "            ebt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "            # TODO: Add TZ Info",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for binding in self.content_bindings:",
            "            b = etree.SubElement(xml, '{%s}Content_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollRequest, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label:  # TODO: Add TZ Info",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:  # TODO: Add TZ Info",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_bindings'] = []",
            "        for bind in self.content_bindings:",
            "            d['content_bindings'].append(bind)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin Timestamp Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Excl. Begin Timestamp Label: %s\\n\" % None",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % None",
            "",
            "        if len(self.content_bindings) == 0:",
            "            s += line_prepend + \"  Content Binding: Any Content\\n\"",
            "",
            "        for cb in self.content_bindings:",
            "            s += line_prepend + \"  Content Binding: %s\\n\" % cb",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = get_required(etree_xml, './@feed_name', ns_map)",
            "        kwargs['subscription_id'] = get_optional(etree_xml, './@subscription_id', ns_map)",
            "",
            "        ebt_text = get_optional_text(etree_xml, './taxii:Exclusive_Begin_Timestamp', ns_map)",
            "        if ebt_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(ebt_text)",
            "",
            "        iet_text = get_optional_text(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map)",
            "        if iet_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iet_text)",
            "",
            "        kwargs['content_bindings'] = []",
            "        for binding in etree_xml.xpath('./taxii:Content_Binding', namespaces=ns_map):",
            "            kwargs['content_bindings'].append(binding.text)",
            "",
            "        msg = super(PollRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if d.get('exclusive_begin_timestamp_label'):",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if d.get('inclusive_end_timestamp_label'):",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_bindings'] = d.get('content_bindings', [])",
            "",
            "        msg = super(PollRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class PollResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed that was polled.",
            "            **Required**",
            "        inclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range this response covers.",
            "            **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range this response covers. **Required**",
            "        subscription_id (str): the Subscription ID for which this content",
            "            is being provided. **Optional**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        content_blocks (list of ContentBlock): piece of content",
            "            and additional information related to the content. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_POLL_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 feed_name=None, inclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 message=None, content_blocks=None):",
            "        super(PollResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.feed_name = feed_name",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.inclusive_begin_timestamp_label = inclusive_begin_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label')",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label', can_be_none=True)",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollResponse, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        if self.inclusive_begin_timestamp_label:",
            "            ibt = etree.SubElement(xml, '{%s}Inclusive_Begin_Timestamp' % ns_map['taxii'])",
            "            ibt.text = self.inclusive_begin_timestamp_label.isoformat()",
            "",
            "        iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "        iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollResponse, self).to_dict()",
            "",
            "        d['feed_name'] = self.feed_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        if self.inclusive_begin_timestamp_label:",
            "            d['inclusive_begin_timestamp_label'] = self.inclusive_begin_timestamp_label.isoformat()",
            "        d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "",
            "        if self.inclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Incl. Begin Timestamp Label: %s\\n\" % self.inclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. Begin Timestamp Label: %s\\n\" % None",
            "",
            "        s += line_prepend + \"  Incl. End Timestamp Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['feed_name'] = get_required(etree_xml, './@feed_name', ns_map)",
            "        kwargs['subscription_id'] = get_optional(etree_xml, './@subscription_id', ns_map)",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        ibts_text = get_optional_text(etree_xml, './taxii:Inclusive_Begin_Timestamp', ns_map)",
            "        if ibts_text:",
            "            kwargs['inclusive_begin_timestamp_label'] = parse_datetime_string(ibts_text)",
            "",
            "        iets_text = get_required(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map).text",
            "        kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iets_text)",
            "",
            "        kwargs['content_blocks'] = []",
            "        blocks = etree_xml.xpath('./taxii:Content_Block', namespaces=ns_map)",
            "        for block in blocks:",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        msg = super(PollResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "",
            "        kwargs['message'] = d.get('message')",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['inclusive_begin_timestamp_label'] = None",
            "        if d.get('inclusive_begin_timestamp_label'):",
            "            kwargs['inclusive_begin_timestamp_label'] = parse_datetime_string(d['inclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "        msg = super(PollResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class StatusMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Status message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        status_type (str): One of the defined Status Types or a third-party-",
            "            defined Status Type. **Required**",
            "        status_detail (str): A field for additional information about",
            "            this status in a machine-readable format. **Optional or Prohibited**",
            "            depending on ``status_type``. See TAXII Specification for details.",
            "        message (str): Additional information for the status. There is no",
            "            expectation that this field be interpretable by a machine; it is",
            "            instead targeted to a human operator. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_STATUS_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 status_type=None, status_detail=None, message=None):",
            "        super(StatusMessage, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.status_type = status_type",
            "        self.status_detail = status_detail",
            "        self.message = message",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def status_type(self):",
            "        return self._status_type",
            "",
            "    @status_type.setter",
            "    def status_type(self, value):",
            "        do_check(value, 'status_type')",
            "        self._status_type = value",
            "",
            "    # TODO: is it possible to check the status detail?",
            "",
            "    def to_etree(self):",
            "        xml = super(StatusMessage, self).to_etree()",
            "        xml.attrib['status_type'] = self.status_type",
            "",
            "        if self.status_detail is not None:",
            "            sd = etree.SubElement(xml, '{%s}Status_Detail' % ns_map['taxii'])",
            "            sd.text = self.status_detail",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(StatusMessage, self).to_dict()",
            "        d['status_type'] = self.status_type",
            "        if self.status_detail is not None:",
            "            d['status_detail'] = self.status_detail",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(StatusMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Status Type: %s\\n\" % self.status_type",
            "        if self.status_detail:",
            "            s += line_prepend + \"  Status Detail: %s\\n\" % self.status_detail",
            "        s += line_prepend + \"  Status Message: %s\\n\" % self.message",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = dict(",
            "            status_type=etree_xml.attrib['status_type'],",
            "            status_detail=get_optional_text(etree_xml, './taxii:Status_Detail', ns_map),",
            "            message=get_optional_text(etree_xml, './taxii:Message', ns_map),",
            "        )",
            "",
            "        msg = super(StatusMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = dict(",
            "            status_type=d['status_type'],",
            "            status_detail=d.get('status_detail'),",
            "            message=d.get('message')",
            "        )",
            "",
            "        msg = super(StatusMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class InboxMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Inbox message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        message (str): prose information for the message recipient. **Optional**",
            "        subscription_information (libtaxii.messages_10.SubscriptionInformation): This",
            "            field is only present if this message is being sent to provide",
            "            content in accordance with an existing TAXII Data Feed",
            "            subscription. **Optional**",
            "        content_blocks (list of ContentBlock): Inbox content. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_INBOX_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None,",
            "                 message=None, subscription_information=None,",
            "                 content_blocks=None):",
            "",
            "        super(InboxMessage, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.subscription_information = subscription_information",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def subscription_information(self):",
            "        return self._subscription_information",
            "",
            "    @subscription_information.setter",
            "    def subscription_information(self, value):",
            "        do_check(value, 'subscription_information', type=SubscriptionInformation, can_be_none=True)",
            "        self._subscription_information = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    def to_etree(self):",
            "        xml = super(InboxMessage, self).to_etree()",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        if self.subscription_information:",
            "            xml.append(self.subscription_information.to_etree())",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(InboxMessage, self).to_dict()",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        if self.subscription_information:",
            "            d['subscription_information'] = self.subscription_information.to_dict()",
            "",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(InboxMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.subscription_information:",
            "            s += self.subscription_information.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"  Message has %s Content Blocks\\n\" % len(self.content_blocks)",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(InboxMessage, cls).from_etree(etree_xml)",
            "",
            "        msg.message = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        subs_info = get_optional(etree_xml, './taxii:Source_Subscription', ns_map)",
            "        if subs_info is not None:",
            "            msg.subscription_information = SubscriptionInformation.from_etree(subs_info)",
            "",
            "        content_blocks = etree_xml.xpath('./taxii:Content_Block', namespaces=ns_map)",
            "        msg.content_blocks = []",
            "        for block in content_blocks:",
            "            msg.content_blocks.append(ContentBlock.from_etree(block))",
            "",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(InboxMessage, cls).from_dict(d)",
            "",
            "        msg.message = d.get('message')",
            "",
            "        msg.subscription_information = None",
            "        if 'subscription_information' in d:",
            "            msg.subscription_information = SubscriptionInformation.from_dict(d['subscription_information'])",
            "",
            "        msg.content_blocks = []",
            "        for block in d['content_blocks']:",
            "            msg.content_blocks.append(ContentBlock.from_dict(block))",
            "",
            "        return msg",
            "",
            "",
            "class SubscriptionInformation(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Information component of a TAXII Inbox message.",
            "",
            "    Arguments:",
            "        feed_name (str): the name of the TAXII Data Feed from",
            "            which this content is being provided. **Required**",
            "        subscription_id (str): the Subscription ID for which this",
            "            content is being provided. **Required**",
            "        inclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the time range this Inbox Message",
            "            covers. **Optional**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the time range this Inbox Message covers.",
            "            **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, feed_name, subscription_id,",
            "                 inclusive_begin_timestamp_label,",
            "                 inclusive_end_timestamp_label):",
            "        self.feed_name = feed_name",
            "        self.subscription_id = subscription_id",
            "        self.inclusive_begin_timestamp_label = inclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label')",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label')",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Source_Subscription' % ns_map['taxii'])",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        ibtl = etree.SubElement(xml, '{%s}Inclusive_Begin_Timestamp' % ns_map['taxii'])",
            "        ibtl.text = self.inclusive_begin_timestamp_label.isoformat()",
            "",
            "        ietl = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii'])",
            "        ietl.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['feed_name'] = self.feed_name",
            "        d['subscription_id'] = self.subscription_id",
            "        d['inclusive_begin_timestamp_label'] = self.inclusive_begin_timestamp_label.isoformat()",
            "        d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Information ===\\n\"",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Incl. Begin TS Label: %s\\n\" % self.inclusive_begin_timestamp_label.isoformat()",
            "        s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        feed_name = etree_xml.attrib['feed_name']",
            "        subscription_id = etree_xml.attrib['subscription_id']",
            "",
            "        ibtl = parse_datetime_string(get_required(etree_xml, './taxii:Inclusive_Begin_Timestamp', ns_map).text)",
            "        ietl = parse_datetime_string(get_required(etree_xml, './taxii:Inclusive_End_Timestamp', ns_map).text)",
            "",
            "        return SubscriptionInformation(feed_name, subscription_id, ibtl, ietl)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        feed_name = d['feed_name']",
            "        subscription_id = d['subscription_id']",
            "",
            "        ibtl = parse_datetime_string(d['inclusive_begin_timestamp_label'])",
            "        ietl = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        return SubscriptionInformation(feed_name, subscription_id, ibtl, ietl)",
            "",
            "",
            "class ManageFeedSubscriptionRequest(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Feed Subscription Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed to which the",
            "            action applies. **Required**",
            "        action (str): the requested action to take. **Required**",
            "        subscription_id (str): the ID of a previously created subscription.",
            "            **Required** if ``action==``:py:data:`ACT_UNSUBSCRIBE`, else",
            "            **Prohibited**.",
            "        delivery_parameters (list of DeliveryParameters): the delivery parameters",
            "            for this request. **Optional** Absence means delivery is not requested.",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_FEED_SUBSCRIPTION_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 feed_name=None, action=None, subscription_id=None,",
            "                 delivery_parameters=None):",
            "        super(ManageFeedSubscriptionRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.action = action",
            "        self.subscription_id = subscription_id",
            "        self.delivery_parameters = delivery_parameters",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def action(self):",
            "        return self._action",
            "",
            "    @action.setter",
            "    def action(self, value):",
            "        do_check(value, 'action', value_tuple=ACT_TYPES)",
            "        self._action = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageFeedSubscriptionRequest, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        xml.attrib['action'] = self.action",
            "        if self.subscription_id is not None:",
            "            xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageFeedSubscriptionRequest, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        d['action'] = self.action",
            "        d['subscription_id'] = self.subscription_id",
            "        d['delivery_parameters'] = None",
            "        if self.delivery_parameters:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageFeedSubscriptionRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Action: %s\\n\" % self.action",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = dict(",
            "            feed_name=get_required(etree_xml, './@feed_name', ns_map),",
            "            action=get_required(etree_xml, './@action', ns_map),",
            "",
            "            # subscription_id is not required for action 'SUBSCRIBE'",
            "            subscription_id=get_optional(etree_xml, './@subscription_id', ns_map),",
            "        )",
            "",
            "        # marked as required in spec but as optional is XSD",
            "        delivery = get_optional(etree_xml, './taxii:Push_Parameters', ns_map)",
            "        if delivery is not None:",
            "            kwargs['delivery_parameters'] = DeliveryParameters.from_etree(delivery)",
            "",
            "        msg = super(ManageFeedSubscriptionRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = dict(",
            "            feed_name=d['feed_name'],",
            "            action=d['action'],",
            "            subscription_id=d['subscription_id'],",
            "            delivery_parameters=DeliveryParameters.from_dict(d['delivery_parameters'])",
            "        )",
            "",
            "        msg = super(ManageFeedSubscriptionRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class ManageFeedSubscriptionResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Feed Subscription Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        feed_name (str): the name of the TAXII Data Feed to which",
            "            the action applies. **Required**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        subscription_instances (list of SubscriptionInstance): **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_FEED_SUBSCRIPTION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 feed_name=None, message=None, subscription_instances=None):",
            "        super(ManageFeedSubscriptionResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.feed_name = feed_name",
            "        self.message = message",
            "        self.subscription_instances = subscription_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def feed_name(self):",
            "        return self._feed_name",
            "",
            "    @feed_name.setter",
            "    def feed_name(self, value):",
            "        do_check(value, 'feed_name', regex_tuple=uri_regex)",
            "        self._feed_name = value",
            "",
            "    @property",
            "    def subscription_instances(self):",
            "        return self._subscription_instances",
            "",
            "    @subscription_instances.setter",
            "    def subscription_instances(self, value):",
            "        do_check(value, 'subscription_instances', type=SubscriptionInstance)",
            "        self._subscription_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageFeedSubscriptionResponse, self).to_etree()",
            "        xml.attrib['feed_name'] = self.feed_name",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii'])",
            "            m.text = self.message",
            "",
            "        for subscription_instance in self.subscription_instances:",
            "            xml.append(subscription_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageFeedSubscriptionResponse, self).to_dict()",
            "        d['feed_name'] = self.feed_name",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        d['subscription_instances'] = []",
            "        for subscription_instance in self.subscription_instances:",
            "            d['subscription_instances'].append(subscription_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageFeedSubscriptionResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Feed Name: %s\\n\" % self.feed_name",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for si in self.subscription_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = etree_xml.attrib['feed_name']",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii:Message', ns_map)",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for si in etree_xml.xpath('./taxii:Subscription', namespaces=ns_map):",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_etree(si))",
            "",
            "        msg = super(ManageFeedSubscriptionResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['feed_name'] = d['feed_name']",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for instance in d['subscription_instances']:",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_dict(instance))",
            "",
            "        msg = super(ManageFeedSubscriptionResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Subscription Instance component of the Manage Feed Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        subscription_id (str): the id of the subscription. **Required**",
            "        delivery_parameters (libtaxii.messages_10.DeliveryParameters): the parameters",
            "            for this subscription. **Required** if responding to message",
            "            with ``action==``:py:data:`ACT_STATUS`, otherwise **Prohibited**",
            "        poll_instances (list of PollInstance): Each Poll",
            "            Instance represents an instance of a Poll Service that can be",
            "            contacted to retrieve content associated with the new",
            "            Subscription. **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, subscription_id, delivery_parameters=None,",
            "                 poll_instances=None):",
            "        self.subscription_id = subscription_id",
            "        self.delivery_parameters = delivery_parameters",
            "        self.poll_instances = poll_instances or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_id",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    @property",
            "    def poll_instances(self):",
            "        return self._poll_instances",
            "",
            "    @poll_instances.setter",
            "    def poll_instances(self, value):",
            "        do_check(value, 'poll_instances', type=PollInstance, can_be_none=False)",
            "        self._poll_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Subscription' % ns_map['taxii'])",
            "        xml.attrib['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "",
            "        for poll_instance in self.poll_instances:",
            "            xml.append(poll_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_id'] = self.subscription_id",
            "",
            "        if self.delivery_parameters:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        else:",
            "            d['delivery_parameters'] = None",
            "",
            "        d['poll_instances'] = []",
            "        for poll_instance in self.poll_instances:",
            "            d['poll_instances'].append(poll_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_indent=''):",
            "        s = line_indent + \"=== Subscription Instance ===\\n\"",
            "        s += line_indent + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_indent + STD_INDENT)",
            "        for pi in self.poll_instances:",
            "            s += pi.to_text(line_indent + STD_INDENT)",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        subscription_id = etree_xml.attrib['subscription_id']",
            "",
            "        _delivery_parameters = get_optional(etree_xml, './taxii:Push_Parameters', ns_map)",
            "        if _delivery_parameters is not None:",
            "            delivery_parameters = DeliveryParameters.from_etree(_delivery_parameters)",
            "        else:",
            "            delivery_parameters = None",
            "",
            "        poll_instances = []",
            "        for poll_instance in etree_xml.xpath('./taxii:Poll_Instance', namespaces=ns_map):",
            "            poll_instances.append(PollInstance.from_etree(poll_instance))",
            "",
            "        return SubscriptionInstance(subscription_id, delivery_parameters, poll_instances)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        subscription_id = d['subscription_id']",
            "",
            "        if d.get('delivery_parameters'):",
            "            delivery_parameters = DeliveryParameters.from_dict(d['delivery_parameters'])",
            "        else:",
            "            delivery_parameters = None",
            "",
            "        poll_instances = []",
            "        for poll_instance in d['poll_instances']:",
            "            poll_instances.append(PollInstance.from_dict(poll_instance))",
            "",
            "        return SubscriptionInstance(subscription_id, delivery_parameters, poll_instances)",
            "",
            "",
            "class PollInstance(TAXIIBase10):",
            "",
            "    \"\"\"",
            "    The Poll Instance component of the Manage Feed Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        poll_protocol (str): The protocol binding supported by this",
            "            instance of a Polling Service. **Required**",
            "        poll_address (str): the address of the TAXII Daemon hosting",
            "            this Poll Service. **Required**",
            "        poll_message_bindings (list of str): one or more message bindings",
            "            that can be used when interacting with this Poll Service",
            "            instance. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings=None):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self._poll_message_bindings = poll_message_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Poll_Instance' % ns_map['taxii'])",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii'])",
            "        pb.text = self.poll_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii'])",
            "        a.text = self.poll_address",
            "",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        poll_protocol = get_required(etree_xml, './taxii:Protocol_Binding', ns_map).text",
            "        address = get_required(etree_xml, './taxii:Address', ns_map).text",
            "",
            "        poll_message_bindings = []",
            "        for b in etree_xml.xpath('./taxii:Message_Binding', namespaces=ns_map):",
            "            poll_message_bindings.append(b.text)",
            "",
            "        return PollInstance(poll_protocol, address, poll_message_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PollInstance(**d)",
            "",
            "########################################################",
            "# EVERYTHING BELOW HERE IS FOR BACKWARDS COMPATIBILITY #",
            "########################################################",
            "",
            "# Add top-level classes as nested classes for backwards compatibility",
            "DiscoveryResponse.ServiceInstance = ServiceInstance",
            "FeedInformationResponse.FeedInformation = FeedInformation",
            "FeedInformation.PushMethod = PushMethod",
            "FeedInformation.PollingServiceInstance = PollingServiceInstance",
            "FeedInformation.SubscriptionMethod = SubscriptionMethod",
            "ManageFeedSubscriptionResponse.PollInstance = PollInstance",
            "ManageFeedSubscriptionResponse.SubscriptionInstance = SubscriptionInstance",
            "InboxMessage.SubscriptionInformation = SubscriptionInformation",
            "",
            "# Constants not imported in `from constants import *`",
            "MSG_TYPES = MSG_TYPES_10",
            "ST_TYPES = ST_TYPES_10",
            "ACT_TYPES = ACT_TYPES_10",
            "SVC_TYPES = SVC_TYPES_10",
            "",
            "from .common import (generate_message_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "48": [
                "validate_xml"
            ],
            "482": [
                "TAXIIMessage",
                "from_dict"
            ],
            "649": [
                "ContentBlock",
                "from_dict"
            ]
        },
        "addLocation": []
    },
    "libtaxii/messages_11.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     etree_xml = parse_xml_string(xml_string)"
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     package_dir, package_filename = os.path.split(__file__)"
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema_11.xsd\")"
            },
            "3": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    taxii_schema_doc = parse(schema_file)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    taxii_schema_doc = parse(schema_file, allow_file=True)"
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     xml_schema = etree.XMLSchema(taxii_schema_doc)"
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     valid = xml_schema.validate(etree_xml)"
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     # TODO: Additionally, validate the Query stuff"
            },
            "8": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "         kwargs['message'] = d.get('message')"
            },
            "9": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": 819,
                "PatchRowcode": "         is_xml = d.get('content_is_xml', False)"
            },
            "10": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 820,
                "PatchRowcode": "         if is_xml:"
            },
            "11": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kwargs['content'] = parse(d['content'])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 821,
                "PatchRowcode": "+            kwargs['content'] = parse(d['content'], allow_file=False)"
            },
            "13": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": 822,
                "PatchRowcode": "         else:"
            },
            "14": {
                "beforePatchRowNumber": 823,
                "afterPatchRowNumber": 823,
                "PatchRowcode": "             kwargs['content'] = d['content']"
            },
            "15": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": 824,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 1109,
                "afterPatchRowNumber": 1109,
                "PatchRowcode": "         extended_headers = {}"
            },
            "17": {
                "beforePatchRowNumber": 1110,
                "afterPatchRowNumber": 1110,
                "PatchRowcode": "         for k, v in six.iteritems(d['extended_headers']):"
            },
            "18": {
                "beforePatchRowNumber": 1111,
                "afterPatchRowNumber": 1111,
                "PatchRowcode": "             try:"
            },
            "19": {
                "beforePatchRowNumber": 1112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                v = parse(v)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1112,
                "PatchRowcode": "+                v = parse(v, allow_file=False)"
            },
            "21": {
                "beforePatchRowNumber": 1113,
                "afterPatchRowNumber": 1113,
                "PatchRowcode": "             except etree.XMLSyntaxError:"
            },
            "22": {
                "beforePatchRowNumber": 1114,
                "afterPatchRowNumber": 1114,
                "PatchRowcode": "                 pass"
            },
            "23": {
                "beforePatchRowNumber": 1115,
                "afterPatchRowNumber": 1115,
                "PatchRowcode": "             extended_headers[k] = v"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Creating, handling, and parsing TAXII 1.1 messages.",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import six",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "import os",
            "import warnings",
            "",
            "from lxml import etree",
            "",
            "from .common import (parse, parse_datetime_string, append_any_content_etree, TAXIIBase,",
            "                     get_required, get_optional, get_optional_text, parse_xml_string,",
            "                     stringify_content)",
            "from .validation import do_check, uri_regex, check_timestamp_label",
            "from .constants import *",
            "",
            "",
            "def validate_xml(xml_string):",
            "    \"\"\"",
            "    Note that this function has been deprecated. Please see",
            "    libtaxii.validators.SchemaValidator.",
            "",
            "    Validate XML with the TAXII XML Schema 1.1.",
            "",
            "    Args:",
            "        xml_string (str): The XML to validate.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            is_valid = tm11.validate_xml(message.to_xml())",
            "    \"\"\"",
            "",
            "    warnings.warn('Call to deprecated function: libtaxii.messages_11.validate_xml()',",
            "                  category=DeprecationWarning)",
            "",
            "    etree_xml = parse_xml_string(xml_string)",
            "    package_dir, package_filename = os.path.split(__file__)",
            "    schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema_11.xsd\")",
            "    taxii_schema_doc = parse(schema_file)",
            "    xml_schema = etree.XMLSchema(taxii_schema_doc)",
            "    valid = xml_schema.validate(etree_xml)",
            "    # TODO: Additionally, validate the Query stuff",
            "    if not valid:",
            "        return xml_schema.error_log.last_error",
            "    return valid",
            "",
            "",
            "def get_message_from_xml(xml_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from an XML string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the XML.",
            "",
            "    Args:",
            "        xml_string (str): The XML to parse into a TAXII message.",
            "        encoding (str): The encoding of the string; defaults to UTF-8",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_xml = message.to_xml()",
            "            new_message = tm11.get_message_from_xml(message_xml)",
            "    \"\"\"",
            "    if isinstance(xml_string, six.binary_type):",
            "        xml_string = xml_string.decode(encoding, 'replace')",
            "    etree_xml = parse_xml_string(xml_string)",
            "    qn = etree.QName(etree_xml)",
            "    if qn.namespace != ns_map['taxii_11']:",
            "        raise ValueError('Unsupported namespace: %s' % qn.namespace)",
            "",
            "    message_type = qn.localname",
            "",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_etree(etree_xml)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_etree(etree_xml)",
            "    if message_type == MSG_COLLECTION_INFORMATION_REQUEST:",
            "        return CollectionInformationRequest.from_etree(etree_xml)",
            "    if message_type == MSG_COLLECTION_INFORMATION_RESPONSE:",
            "        return CollectionInformationResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_etree(etree_xml)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_etree(etree_xml)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST:",
            "        return ManageCollectionSubscriptionRequest.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE:",
            "        return ManageCollectionSubscriptionResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_FULFILLMENT_REQUEST:",
            "        return PollFulfillmentRequest.from_etree(etree_xml)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_dict(d):",
            "    \"\"\"Create a TAXIIMessage object from a dictonary.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the 'message_type' key in the dictionary.",
            "",
            "    Args:",
            "        d (dict): The dictionary to build the TAXII message from.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_dict = message.to_dict()",
            "            new_message = tm11.get_message_from_dict(message_dict)",
            "    \"\"\"",
            "    if 'message_type' not in d:",
            "        raise ValueError('message_type is a required field!')",
            "",
            "    message_type = d['message_type']",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_dict(d)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_dict(d)",
            "    if message_type == MSG_COLLECTION_INFORMATION_REQUEST:",
            "        return CollectionInformationRequest.from_dict(d)",
            "    if message_type == MSG_COLLECTION_INFORMATION_RESPONSE:",
            "        return CollectionInformationResponse.from_dict(d)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_dict(d)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_dict(d)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_dict(d)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_dict(d)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST:",
            "        return ManageCollectionSubscriptionRequest.from_dict(d)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE:",
            "        return ManageCollectionSubscriptionResponse.from_dict(d)",
            "    if message_type == MSG_POLL_FULFILLMENT_REQUEST:",
            "        return PollFulfillmentRequest.from_dict(d)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_json(json_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from a JSON string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the JSON.",
            "",
            "    Args:",
            "        json_string (str): The JSON to parse into a TAXII message.",
            "    \"\"\"",
            "    decoded_string = json_string.decode(encoding, 'replace')",
            "    return get_message_from_dict(json.loads(decoded_string))",
            "",
            "",
            "def _sanitize_content_binding(binding):",
            "    \"\"\"",
            "    Takes in one of:",
            "    1. ContentBinding object",
            "    2. string",
            "    3. dict",
            "    and returns a ContentBinding object.",
            "",
            "    This supports function calls where a string or ContentBinding can be",
            "    used to specify a content binding.",
            "    \"\"\"",
            "    if isinstance(binding, ContentBinding):  # It's already good to go",
            "        return binding",
            "    elif isinstance(binding, six.string_types):  # Convert it to a ContentBinding",
            "        return ContentBinding.from_string(binding)",
            "    elif isinstance(binding, dict):  # Convert it to a ContentBinding",
            "        return ContentBinding.from_dict(binding)",
            "    else:  # Don't know what to do with it.",
            "        raise ValueError('Type cannot be converted to ContentBinding: %s' % binding.__class__.__name__)",
            "",
            "",
            "def _sanitize_content_bindings(binding_list):",
            "    bindings = []",
            "    for item in binding_list:",
            "        bindings.append(_sanitize_content_binding(item))",
            "",
            "    return bindings",
            "",
            "",
            "class UnsupportedQueryException(Exception):",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "",
            "    def __str__(self):",
            "        return repr(self.value)",
            "",
            "",
            "# Start with the 'default' deserializer",
            "query_deserializers = {}",
            "",
            "",
            "def register_query_format(format_id, query, query_info, schema=None):",
            "    \"\"\"",
            "    This function registers a query format with libtaxii.messages_11.",
            "    Arguments:",
            "        format_id (string) - The format ID of the query",
            "        query (messages_11.Query subclass) - the Query object associated with the format_id",
            "        query_info (messages_11.SupportedQuery subclass) - the SupportedQuery object associated with the format_id",
            "        schema (xml schema) - The XML schema for validating the query",
            "    \"\"\"",
            "    query_deserializers[format_id] = {'query': query, 'query_info': query_info, 'schema': schema}",
            "",
            "",
            "def get_deserializer(format_id, type):",
            "    do_check(type, 'type', value_tuple=('query', 'query_info'))",
            "",
            "    if format_id not in query_deserializers:",
            "        raise UnsupportedQueryException('A deserializer for the query format \\'%s\\' is not registered.' % format_id)",
            "",
            "    return query_deserializers[format_id][type]",
            "",
            "# TODO: Consider using this",
            "# def _create_element(name, namespace=ns_map['taxii_11'], value=None, attrs=None, parent=None):",
            "    # \"\"\"",
            "    # Helper method for appending a new element to an existing element.",
            "",
            "    # Assumes the namespace is TAXII 1.1",
            "",
            "    # Arguments:",
            "    #     name (string) - The name of the element",
            "    #     namespace (string) - The namespace of the element",
            "    #     value (string) - The text value of the element",
            "    #     attrs (dict) - A dictionary of attributes",
            "    #     parent (Element) - The parent element",
            "    # \"\"\"",
            "    # if value is None and attrs is None:",
            "    #     return",
            "",
            "    # if parent is None:",
            "    #     elt = etree.Element('{%s}%s' % (namespace, name), nsmap=ns_map)",
            "    # else:",
            "    #     elt = etree.SubElement(parent, '{%s}%s' % (namespace, name), nsmap=ns_map)",
            "",
            "    # if value is not None:",
            "    #     elt.text = value",
            "",
            "    # if attrs is not None:",
            "    #     for k, v in attrs.items():",
            "    #         elt.attrib[k] = v",
            "",
            "    # return elt",
            "",
            "",
            "class TAXIIBase11(TAXIIBase):",
            "    version = VID_TAXII_XML_11",
            "",
            "",
            "class SupportedQuery(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    This class contains an instance of a supported query. It",
            "    is expected that, generally, messages_11.SupportedQuery",
            "    subclasses will be used in place of this class",
            "    to represent a query",
            "    \"\"\"",
            "",
            "    def __init__(self, format_id):",
            "        \"\"\"",
            "        Arguments:",
            "            format_id (string) - The format_id of this supported query",
            "        \"\"\"",
            "        self.format_id = format_id",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.format_id",
            "",
            "    @property",
            "    def format_id(self):",
            "        return self._format_id",
            "",
            "    @format_id.setter",
            "    def format_id(self, value):",
            "        do_check(value, 'format_id', regex_tuple=uri_regex)",
            "        self._format_id = value",
            "",
            "    def to_etree(self):",
            "        q = etree.Element('{%s}Supported_Query' % ns_map['taxii_11'], nsmap=ns_map)",
            "        q.attrib['format_id'] = self.format_id",
            "        return q",
            "",
            "    def to_dict(self):",
            "        return {'format_id': self.format_id}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Supported Query Information ===\\n\"",
            "        s += line_prepend + \"  Query Format: %s\\n\" % self.format_id",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        format_id = get_required(etree_xml, './@format_id', ns_map)",
            "        return SupportedQuery(format_id)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return SupportedQuery(**d)",
            "",
            "",
            "class Query(TAXIIBase11):",
            "",
            "    \"\"\"This class contains an instance of a query.",
            "",
            "    It is expected that, generally, messages_11.Query subclasses will be used",
            "    in place of this class to represent a query.",
            "    \"\"\"",
            "",
            "    def __init__(self, format_id):",
            "        \"\"\"",
            "        Arguments:",
            "            format_id (string) - The format_id of this query",
            "        \"\"\"",
            "        self.format_id = format_id",
            "",
            "    @property",
            "    def format_id(self):",
            "        return self._format_id",
            "",
            "    @format_id.setter",
            "    def format_id(self, value):",
            "        do_check(value, 'format_id', regex_tuple=uri_regex)",
            "        self._format_id = value",
            "",
            "    def to_etree(self):",
            "        q = etree.Element('{%s}Query' % ns_map['taxii_11'], nsmap=ns_map)",
            "        q.attrib['format_id'] = self.format_id",
            "        return q",
            "",
            "    def to_dict(self):",
            "        return {'format_id': self.format_id}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Query ===\\n\"",
            "        s += line_prepend + \"  Query Format: %s\\n\" % self.format_id",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml, kwargs):",
            "        format_id = get_required(etree_xml, './@format_id', ns_map)",
            "        return cls(format_id, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, kwargs):",
            "        return cls(d, **kwargs)",
            "",
            "",
            "# A value can be one of:",
            "# - a dictionary, where each key is a content_binding_id and each value is a list of subtypes",
            "#   (This is the default representation)",
            "# - a \"content_binding_id[>subtype]\" structure",
            "# - a list of \"content_binding_id[>subtype]\" structures",
            "",
            "",
            "class ContentBinding(TAXIIBase11):",
            "",
            "    \"\"\"TAXII Content Binding component",
            "",
            "    Args:",
            "        binding_id (str): The content binding ID. **Required**",
            "        subtype_ids (list of str): the subtype IDs. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, binding_id, subtype_ids=None):",
            "        self.binding_id = binding_id",
            "        self.subtype_ids = subtype_ids or []",
            "",
            "    def __str__(self):",
            "        s = self.binding_id",
            "        if len(self.subtype_ids) > 0:",
            "            s += '>' + ','.join(self.subtype_ids)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_string(s):",
            "        if '>' not in s:",
            "            return ContentBinding(s)",
            "",
            "        parts = s.split('>')",
            "        binding_id = parts[0]",
            "        subtype_ids = parts[1].split(',')",
            "        return ContentBinding(binding_id, subtype_ids)",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return str(self)",
            "",
            "    @property",
            "    def binding_id(self):",
            "        return self._binding_id",
            "",
            "    @binding_id.setter",
            "    def binding_id(self, value):",
            "        do_check(value, 'binding_id', regex_tuple=uri_regex)",
            "        self._binding_id = value",
            "",
            "    @property",
            "    def subtype_ids(self):",
            "        return self._subtype_ids",
            "",
            "    @subtype_ids.setter",
            "    def subtype_ids(self, value):",
            "        do_check(value, 'subtype_ids', regex_tuple=uri_regex)",
            "        self._subtype_ids = value",
            "",
            "    def to_etree(self):",
            "        cb = etree.Element('{%s}Content_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        cb.attrib['binding_id'] = self.binding_id",
            "        for subtype_id in self.subtype_ids:",
            "            s = etree.SubElement(cb, '{%s}Subtype' % ns_map['taxii_11'], nsmap=ns_map)",
            "            s.attrib['subtype_id'] = subtype_id",
            "        return cb",
            "",
            "    def to_dict(self):",
            "        return {'binding_id': self.binding_id, 'subtype_ids': self.subtype_ids}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        return line_prepend + str(self)",
            "",
            "    def __hash__(self):",
            "        return hash(str(self.to_dict()))",
            "",
            "    @classmethod",
            "    def from_etree(self, etree_xml):",
            "        binding_id = etree_xml.attrib['binding_id']",
            "        subtype_ids = []",
            "        subtype_elts = etree_xml.xpath('./taxii_11:Subtype', namespaces=ns_map)",
            "        for elt in subtype_elts:",
            "            subtype_ids.append(elt.attrib['subtype_id'])",
            "        return ContentBinding(binding_id, subtype_ids)",
            "",
            "    @classmethod",
            "    def from_dict(self, d):",
            "        return ContentBinding(**d)",
            "",
            "",
            "class RecordCount(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    Information summarizing the number of records.",
            "",
            "    Args:",
            "        record_count (int): The number of records",
            "        partial_count (bool): Whether the number of records is a partial count",
            "    \"\"\"",
            "",
            "    def __init__(self, record_count, partial_count=False):",
            "        self.record_count = record_count",
            "        self.partial_count = partial_count",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=int)",
            "        self._record_count = value",
            "",
            "    @property",
            "    def partial_count(self):",
            "        return self._partial_count",
            "",
            "    @partial_count.setter",
            "    def partial_count(self, value):",
            "        do_check(value, 'partial_count', value_tuple=(True, False), can_be_none=True)",
            "        self._partial_count = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Record_Count' % ns_map['taxii_11'], nsmap=ns_map)",
            "        xml.text = str(self.record_count)",
            "",
            "        if self.partial_count is not None:",
            "            xml.attrib['partial_count'] = str(self.partial_count).lower()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['record_count'] = self.record_count",
            "        if self.partial_count is not None:",
            "            d['partial_count'] = self.partial_count",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Record Count ===\\n\"",
            "        s += line_prepend + \"  Record Count: %s\\n\" % self.record_count",
            "        if self.partial_count:",
            "            s += line_prepend + \"  Partial Count: %s\\n\" % self.partial_count",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        record_count = int(etree_xml.text)",
            "        partial_count = etree_xml.attrib.get('partial_count', 'false') == 'true'",
            "",
            "        return RecordCount(record_count, partial_count)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return RecordCount(**d)",
            "",
            "",
            "class _GenericParameters(TAXIIBase11):",
            "    name = 'Generic_Parameters'",
            "",
            "    def __init__(self, response_type=RT_FULL, content_bindings=None, query=None):",
            "        self.response_type = response_type",
            "        self.content_bindings = content_bindings or []",
            "        self.query = query",
            "",
            "    @property",
            "    def response_type(self):",
            "        return self._response_type",
            "",
            "    @response_type.setter",
            "    def response_type(self, value):",
            "        do_check(value, 'response_type', value_tuple=(RT_FULL, RT_COUNT_ONLY), can_be_none=True)",
            "        self._response_type = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'content_bindings', type=ContentBinding)",
            "        self._content_bindings = value",
            "",
            "    @property",
            "    def query(self):",
            "        return self._query",
            "",
            "    @query.setter",
            "    def query(self, value):",
            "        # TODO: Can i do more validation?",
            "        do_check(value, 'query', type=Query, can_be_none=True)",
            "        self._query = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.name), nsmap=ns_map)",
            "        if self.response_type is not None:",
            "            rt = etree.SubElement(xml, '{%s}Response_Type' % ns_map['taxii_11'], nsmap=ns_map)",
            "            rt.text = self.response_type",
            "",
            "        for binding in self.content_bindings:",
            "            xml.append(binding.to_etree())",
            "",
            "        if self.query is not None:",
            "            xml.append(self.query.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        if self.response_type is not None:",
            "            d['response_type'] = self.response_type",
            "",
            "        d['content_bindings'] = []",
            "        for binding in self.content_bindings:",
            "            d['content_bindings'].append(binding.to_dict())",
            "",
            "        d['query'] = None",
            "        if self.query is not None:",
            "            d['query'] = self.query.to_dict()",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== %s ===\\n\" % self.name",
            "        for binding in self.content_bindings:",
            "            s += \"  Content Binding: %s\\n\" % str(binding)",
            "",
            "        if self.query:",
            "            s += self.query.to_text(line_prepend + STD_INDENT)",
            "",
            "        if self.response_type:",
            "            s += line_prepend + \"  Response type: %s\\n\" % str(self.response_type)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml, **kwargs):",
            "",
            "        response_type = get_optional_text(etree_xml, './taxii_11:Response_Type', ns_map)",
            "        if response_type is None:",
            "            response_type = RT_FULL",
            "",
            "        content_bindings = []",
            "        for binding in etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map):",
            "            content_bindings.append(ContentBinding.from_etree(binding))",
            "",
            "        query = None",
            "        query_el = get_optional(etree_xml, './taxii_11:Query', ns_map)",
            "        if query_el is not None:",
            "            format_id = query_el.attrib['format_id']",
            "            query = get_deserializer(format_id, 'query').from_etree(query_el)",
            "",
            "        return cls(response_type, content_bindings, query, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        response_type = d.get('response_type', RT_FULL)",
            "        content_bindings = []",
            "        for binding in d['content_bindings']:",
            "            content_bindings.append(ContentBinding.from_dict(binding))",
            "",
            "        query = None",
            "        if 'query' in d and d['query'] is not None:",
            "            format_id = d['query']['format_id']",
            "            query = get_deserializer(format_id, 'query').from_dict(d['query'])",
            "",
            "        return cls(response_type, content_bindings, query, **kwargs)",
            "",
            "",
            "class SubscriptionParameters(_GenericParameters):",
            "",
            "    \"\"\"",
            "    TAXII Subscription Parameters.",
            "",
            "    Args:",
            "        response_type (str): The requested response type. Must be either",
            "            :py:data:`RT_FULL` or :py:data:`RT_COUNT_ONLY`. **Optional**,",
            "            defaults to :py:data:`RT_FULL`",
            "        content_bindings (list of ContentBinding objects): A list of Content",
            "            Bindings acceptable in response. **Optional**",
            "        query (Query): The query for this poll parameters. **Optional**",
            "    \"\"\"",
            "    name = 'Subscription_Parameters'",
            "",
            "",
            "class ContentBlock(TAXIIBase11):",
            "",
            "    \"\"\"A TAXII Content Block.",
            "",
            "    Args:",
            "        content_binding (ContentBinding): a Content Binding ID or nesting expression",
            "            indicating the type of content contained in the Content field of this",
            "            Content Block. **Required**",
            "        content (string or etree): a piece of content of the type specified",
            "            by the Content Binding. **Required**",
            "        timestamp_label (datetime): the Timestamp Label associated with this",
            "            Content Block. **Optional**",
            "        padding (string): an arbitrary amount of padding for this Content",
            "            Block. **Optional**",
            "        message (string): a message associated with this ContentBlock. **Optional**",
            "    \"\"\"",
            "    NAME = 'Content_Block'",
            "",
            "    def __init__(self, content_binding, content, timestamp_label=None,",
            "                 padding=None, message=None):",
            "        self.content_binding = content_binding",
            "        self.content = content",
            "        self.timestamp_label = timestamp_label",
            "        self.message = message",
            "        self.padding = padding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.content[:25]",
            "",
            "    @property",
            "    def content_binding(self):",
            "        return self._content_binding",
            "",
            "    @content_binding.setter",
            "    def content_binding(self, value):",
            "        value = _sanitize_content_binding(value)",
            "        do_check(value, 'content_binding', type=ContentBinding)",
            "        self._content_binding = value",
            "",
            "    @property",
            "    def content(self):",
            "        if self.content_is_xml:",
            "            return etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            return self._content",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        do_check(value, 'content')  # Just check for not None",
            "        self._content, self.content_is_xml = stringify_content(value)",
            "",
            "    @property",
            "    def content_is_xml(self):",
            "        return self._content_is_xml",
            "",
            "    @content_is_xml.setter",
            "    def content_is_xml(self, value):",
            "        do_check(value, 'content_is_xml', value_tuple=(True, False))",
            "        self._content_is_xml = value",
            "",
            "    @property",
            "    def timestamp_label(self):",
            "        return self._timestamp_label",
            "",
            "    @timestamp_label.setter",
            "    def timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'timestamp_label', can_be_none=True)",
            "        self._timestamp_label = value",
            "",
            "    @property",
            "    def message(self):",
            "        return self._message",
            "",
            "    @message.setter",
            "    def message(self, value):",
            "        do_check(value, 'message', type=six.string_types, can_be_none=True)",
            "        self._message = value",
            "",
            "    def to_etree(self):",
            "        block = etree.Element('{%s}Content_Block' % ns_map['taxii_11'], nsmap=ns_map)",
            "        block.append(self.content_binding.to_etree())",
            "        c = etree.SubElement(block, '{%s}Content' % ns_map['taxii_11'])",
            "",
            "        if self.content_is_xml:",
            "            c.append(self._content)",
            "        else:",
            "            c.text = self._content",
            "",
            "        if self.timestamp_label is not None:",
            "            tl = etree.SubElement(block, '{%s}Timestamp_Label' % ns_map['taxii_11'])",
            "            tl.text = self.timestamp_label.isoformat()",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(block, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        if self.padding is not None:",
            "            p = etree.SubElement(block, '{%s}Padding' % ns_map['taxii_11'])",
            "            p.text = self.padding",
            "",
            "        return block",
            "",
            "    def to_dict(self):",
            "        block = {}",
            "        block['content_binding'] = self.content_binding.to_dict()",
            "",
            "        if self.content_is_xml:",
            "            block['content'] = etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            block['content'] = self._content",
            "        block['content_is_xml'] = self.content_is_xml",
            "",
            "        if self.timestamp_label is not None:",
            "            block['timestamp_label'] = self.timestamp_label.isoformat()",
            "",
            "        if self.message is not None:",
            "            block['message'] = self.message",
            "",
            "        if self.padding is not None:",
            "            block['padding'] = self.padding",
            "",
            "        return block",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Content Block ===\\n\"",
            "        s += line_prepend + \"  Content Binding: %s\\n\" % str(self.content_binding)",
            "        s += line_prepend + \"  Content length: %s\\n\" % len(self.content)",
            "        s += line_prepend + \"  (Content not printed for brevity)\\n\"",
            "        if self.timestamp_label:",
            "            s += line_prepend + \"  Timestamp Label: %s\\n\" % self.timestamp_label",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        s += line_prepend + \"  Padding: %s\\n\" % self.padding",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['content_binding'] = ContentBinding.from_etree(",
            "                get_required(etree_xml, './taxii_11:Content_Binding', ns_map))",
            "",
            "        kwargs['padding'] = get_optional_text(etree_xml, './taxii_11:Padding', ns_map)",
            "",
            "        ts_text = get_optional_text(etree_xml, './taxii_11:Timestamp_Label', ns_map)",
            "        if ts_text:",
            "            kwargs['timestamp_label'] = parse_datetime_string(ts_text)",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        content = get_required(etree_xml, './taxii_11:Content', ns_map)",
            "        if len(content) == 0:  # This has string content",
            "            kwargs['content'] = content.text",
            "        else:  # This has XML content",
            "            kwargs['content'] = content[0]",
            "",
            "        return ContentBlock(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['content_binding'] = ContentBinding.from_dict(d['content_binding'])",
            "        kwargs['padding'] = d.get('padding')",
            "        if 'timestamp_label' in d:",
            "            kwargs['timestamp_label'] = parse_datetime_string(d['timestamp_label'])",
            "        kwargs['message'] = d.get('message')",
            "        is_xml = d.get('content_is_xml', False)",
            "        if is_xml:",
            "            kwargs['content'] = parse(d['content'])",
            "        else:",
            "            kwargs['content'] = d['content']",
            "",
            "        cb = ContentBlock(**kwargs)",
            "        return cb",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class PushParameters(TAXIIBase11):",
            "",
            "    \"\"\"Set up Push Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Collection content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Collection to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "    \"\"\"",
            "",
            "    name = 'Push_Parameters'",
            "",
            "    def __init__(self, inbox_protocol, inbox_address, delivery_message_binding):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.delivery_message_binding = delivery_message_binding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def delivery_message_binding(self):",
            "        return self._delivery_message_binding",
            "",
            "    @delivery_message_binding.setter",
            "    def delivery_message_binding(self, value):",
            "        do_check(value, 'delivery_message_binding', regex_tuple=uri_regex)",
            "        self._delivery_message_binding = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.name))",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.inbox_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.inbox_address",
            "",
            "        mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "        mb.text = self.delivery_message_binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        if self.inbox_protocol is not None:",
            "            d['inbox_protocol'] = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            d['inbox_address'] = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            d['delivery_message_binding'] = self.delivery_message_binding",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Parameters ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Inbox Address: %s\\n\" % self.inbox_address",
            "        s += line_prepend + \"  Message Binding: %s\\n\" % self.delivery_message_binding",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        inbox_protocol = get_optional_text(etree_xml, './taxii_11:Protocol_Binding', ns_map)",
            "        inbox_address = get_optional_text(etree_xml, './taxii_11:Address', ns_map)",
            "        delivery_message_binding = get_optional_text(etree_xml, './taxii_11:Message_Binding', ns_map)",
            "",
            "        return cls(inbox_protocol, inbox_address, delivery_message_binding)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "# TODO: Check docstring",
            "class DeliveryParameters(PushParameters):",
            "",
            "    \"\"\"Set up Delivery Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Collection content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Collection to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "    \"\"\"",
            "",
            "    name = 'Delivery_Parameters'",
            "",
            "",
            "class TAXIIMessage(TAXIIBase11):",
            "",
            "    \"\"\"Encapsulate properties common to all TAXII Messages (such as headers).",
            "",
            "    This class is extended by each Message Type (e.g., DiscoveryRequest), with",
            "    each subclass containing subclass-specific information",
            "    \"\"\"",
            "",
            "    message_type = 'TAXIIMessage'",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None):",
            "        \"\"\"Create a new TAXIIMessage",
            "",
            "        Args:",
            "            message_id (str): A value identifying this message.",
            "            in_response_to (str): Contains the Message ID of the message to",
            "                which this is a response.",
            "            extended_headers (dict): A dictionary of name/value pairs for",
            "                use as Extended Headers",
            "        \"\"\"",
            "        self.message_id = message_id",
            "        self.in_response_to = in_response_to",
            "        self.extended_headers = extended_headers or {}",
            "",
            "    @property",
            "    def message_id(self):",
            "        return self._message_id",
            "",
            "    @message_id.setter",
            "    def message_id(self, value):",
            "        do_check(value, 'message_id', regex_tuple=uri_regex)",
            "        self._message_id = value",
            "",
            "    @property",
            "    def in_response_to(self):",
            "        return self._in_response_to",
            "",
            "    @in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def extended_headers(self):",
            "        return self._extended_headers",
            "",
            "    @extended_headers.setter",
            "    def extended_headers(self, value):",
            "        do_check(list(value.keys()), 'extended_headers.keys()', regex_tuple=uri_regex)",
            "        self._extended_headers = value",
            "",
            "    def to_etree(self):",
            "        \"\"\"Creates the base etree for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to XML, subclasses should call this method",
            "        first, then create their specific XML constructs.",
            "        \"\"\"",
            "        root_elt = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.message_type), nsmap=ns_map)",
            "        root_elt.attrib['message_id'] = str(self.message_id)",
            "",
            "        if self.in_response_to is not None:",
            "            root_elt.attrib['in_response_to'] = str(self.in_response_to)",
            "",
            "        if len(self.extended_headers) > 0:",
            "            eh = etree.SubElement(root_elt, '{%s}Extended_Headers' % ns_map['taxii_11'], nsmap=ns_map)",
            "",
            "            for name, value in list(self.extended_headers.items()):",
            "                h = etree.SubElement(eh, '{%s}Extended_Header' % ns_map['taxii_11'], nsmap=ns_map)",
            "                h.attrib['name'] = name",
            "                append_any_content_etree(h, value)",
            "                # h.text = value",
            "        return root_elt",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create the base dictionary for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to dictionary, subclasses should call this",
            "        method first, then create their specific dictionary constructs.",
            "        \"\"\"",
            "        d = {}",
            "        d['message_type'] = self.message_type",
            "        d['message_id'] = self.message_id",
            "        if self.in_response_to is not None:",
            "            d['in_response_to'] = self.in_response_to",
            "        d['extended_headers'] = {}",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            if isinstance(v, etree._Element) or isinstance(v, etree._ElementTree):",
            "                v = etree.tostring(v, encoding='utf-8')",
            "            elif not isinstance(v, six.string_types):",
            "                v = str(v)",
            "            d['extended_headers'][k] = v",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"Message Type: %s\\n\" % self.message_type",
            "        s += line_prepend + \"Message ID: %s\" % self.message_id",
            "        if self.in_response_to:",
            "            s += \"; In Response To: %s\" % self.in_response_to",
            "        s += \"\\n\"",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            s += line_prepend + \"Extended Header: %s = %s\\n\" % (k, v)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from an etree.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from etree, subclasses should call this method",
            "        first, then parse their specific XML constructs.",
            "        \"\"\"",
            "",
            "        # Check namespace and element name of the root element",
            "        expected_tag = '{%s}%s' % (ns_map['taxii_11'], cls.message_type)",
            "        tag = src_etree.tag",
            "        if tag != expected_tag:",
            "            raise ValueError('%s != %s' % (tag, expected_tag))",
            "",
            "        # Get the message ID",
            "        message_id = get_required(src_etree, '/taxii_11:*/@message_id', ns_map)",
            "",
            "        # Get in response to, if present",
            "        in_response_to = get_optional(src_etree, '/taxii_11:*/@in_response_to', ns_map)",
            "        if in_response_to is not None:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        # Get the Extended headers",
            "        extended_header_list = src_etree.xpath('/taxii_11:*/taxii_11:Extended_Headers/taxii_11:Extended_Header', namespaces=ns_map)",
            "        extended_headers = {}",
            "        for header in extended_header_list:",
            "            eh_name = header.xpath('./@name')[0]",
            "            if len(header) == 0:  # This has string content",
            "                eh_value = header.text",
            "            else:  # This has XML content",
            "                eh_value = header[0]",
            "",
            "            extended_headers[eh_name] = eh_value",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from a dictionary.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from dictionary, subclasses should call this",
            "        method first, then parse their specific dictionary constructs.",
            "        \"\"\"",
            "        message_type = d['message_type']",
            "        if message_type != cls.message_type:",
            "            raise ValueError('%s != %s' % (message_type, cls.message_type))",
            "        message_id = d['message_id']",
            "        extended_headers = {}",
            "        for k, v in six.iteritems(d['extended_headers']):",
            "            try:",
            "                v = parse(v)",
            "            except etree.XMLSyntaxError:",
            "                pass",
            "            extended_headers[k] = v",
            "",
            "        in_response_to = d.get('in_response_to')",
            "        if in_response_to:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class TAXIIRequestMessage(TAXIIMessage):",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class DiscoveryRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_REQUEST",
            "",
            "",
            "class DiscoveryResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        service_instances (list of `ServiceInstance`): a list of",
            "            service instances that this response contains. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, service_instances=None):",
            "        super(DiscoveryResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.service_instances = service_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def service_instances(self):",
            "        return self._service_instances",
            "",
            "    @service_instances.setter",
            "    def service_instances(self, value):",
            "        do_check(value, 'service_instances', type=ServiceInstance)",
            "        self._service_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(DiscoveryResponse, self).to_etree()",
            "        for service_instance in self.service_instances:",
            "            xml.append(service_instance.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(DiscoveryResponse, self).to_dict()",
            "        d['service_instances'] = []",
            "        for service_instance in self.service_instances:",
            "            d['service_instances'].append(service_instance.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(DiscoveryResponse, self).to_text()",
            "        for si in self.service_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['service_instances'] = []",
            "        service_instance_set = etree_xml.xpath('./taxii_11:Service_Instance', namespaces=ns_map)",
            "        for service_instance in service_instance_set:",
            "            si = ServiceInstance.from_etree(service_instance)",
            "            kwargs['service_instances'].append(si)",
            "",
            "        return super(DiscoveryResponse, cls).from_etree(etree_xml, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(DiscoveryResponse, cls).from_dict(d)",
            "        msg.service_instances = []",
            "        service_instance_set = d['service_instances']",
            "        for service_instance in service_instance_set:",
            "            si = ServiceInstance.from_dict(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "",
            "class ServiceInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Service Instance component of a TAXII Discovery Response Message.",
            "",
            "    Args:",
            "        service_type (string): identifies the Service Type of this",
            "            Service Instance. **Required**",
            "        services_version (string): identifies the TAXII Services",
            "            Specification to which this Service conforms. **Required**",
            "        protocol_binding (string): identifies the protocol binding",
            "            supported by this Service. **Required**",
            "        service_address (string): identifies the network address of the",
            "            TAXII Daemon that hosts this Service. **Required**",
            "        message_bindings (list of strings): identifies the message",
            "            bindings supported by this Service instance. **Required**",
            "        inbox_service_accepted_content (list of ContentBinding objects): identifies",
            "            content bindings that this Inbox Service is willing to accept.",
            "            **Optional**",
            "        available (boolean): indicates whether the identity of the",
            "            requester (authenticated or otherwise) is allowed to access this",
            "            TAXII Service. **Optional**",
            "        message (string): contains a message regarding this Service",
            "            instance. **Optional**",
            "        supported_query (SupportedQuery): contains a structure indicating a",
            "            supported query. **Optional**",
            "",
            "    The ``message_bindings`` list must contain at least one value. The",
            "    ``supported_query`` parameter is optional when",
            "    ``service_type`` is :py:data:`SVC_POLL`.",
            "    \"\"\"",
            "",
            "    def __init__(self, service_type, services_version, protocol_binding,",
            "                 service_address, message_bindings,",
            "                 inbox_service_accepted_content=None, available=None,",
            "                 message=None, supported_query=None):",
            "        self.service_type = service_type",
            "        self.services_version = services_version",
            "        self.protocol_binding = protocol_binding",
            "        self.service_address = service_address",
            "        self.message_bindings = message_bindings",
            "        self.inbox_service_accepted_content = inbox_service_accepted_content or []",
            "        self.available = available",
            "        self.message = message",
            "        self.supported_query = supported_query or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.service_address",
            "",
            "    @property",
            "    def service_type(self):",
            "        return self._service_type",
            "",
            "    @service_type.setter",
            "    def service_type(self, value):",
            "        do_check(value, 'service_type', value_tuple=SVC_TYPES)",
            "        self._service_type = value",
            "",
            "    @property",
            "    def services_version(self):",
            "        return self._services_version",
            "",
            "    @services_version.setter",
            "    def services_version(self, value):",
            "        do_check(value, 'services_version', regex_tuple=uri_regex)",
            "        self._services_version = value",
            "",
            "    @property",
            "    def protocol_binding(self):",
            "        return self._protocol_binding",
            "",
            "    @protocol_binding.setter",
            "    def protocol_binding(self, value):",
            "        do_check(value, 'protocol_binding', regex_tuple=uri_regex)",
            "        self._protocol_binding = value",
            "",
            "    @property",
            "    def service_address(self):",
            "        return self._service_address",
            "",
            "    @service_address.setter",
            "    def service_address(self, value):",
            "        self._service_address = value",
            "",
            "    @property",
            "    def message_bindings(self):",
            "        return self._message_bindings",
            "",
            "    @message_bindings.setter",
            "    def message_bindings(self, value):",
            "        do_check(value, 'message_bindings', regex_tuple=uri_regex)",
            "        self._message_bindings = value",
            "",
            "    @property",
            "    def supported_query(self):",
            "        return self._supported_query",
            "",
            "    @supported_query.setter",
            "    def supported_query(self, value):",
            "        do_check(value, 'supported_query', type=SupportedQuery)",
            "        self._supported_query = value",
            "",
            "    @property",
            "    def inbox_service_accepted_content(self):",
            "        return self._inbox_service_accepted_content",
            "",
            "    @inbox_service_accepted_content.setter",
            "    def inbox_service_accepted_content(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'inbox_service_accepted_content', type=ContentBinding)",
            "        self._inbox_service_accepted_content = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Service_Instance' % ns_map['taxii_11'], nsmap=ns_map)",
            "        si.attrib['service_type'] = self.service_type",
            "        si.attrib['service_version'] = self.services_version",
            "        if self.available is not None:",
            "            si.attrib['available'] = str(self.available).lower()",
            "",
            "        protocol_binding = etree.SubElement(si, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        protocol_binding.text = self.protocol_binding",
            "",
            "        service_address = etree.SubElement(si, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        service_address.text = self.service_address",
            "",
            "        for mb in self.message_bindings:",
            "            message_binding = etree.SubElement(si, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            message_binding.text = mb",
            "",
            "        for sq in self.supported_query:",
            "            si.append(sq.to_etree())",
            "",
            "        for cb in self.inbox_service_accepted_content:",
            "            content_binding = cb.to_etree()",
            "            si.append(content_binding)",
            "",
            "        if self.message is not None:",
            "            message = etree.SubElement(si, '{%s}Message' % ns_map['taxii_11'], nsmap=ns_map)",
            "            message.text = self.message",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['service_type'] = self.service_type",
            "        d['services_version'] = self.services_version",
            "        d['protocol_binding'] = self.protocol_binding",
            "        d['service_address'] = self.service_address",
            "        d['message_bindings'] = self.message_bindings",
            "        d['supported_query'] = []",
            "        for sq in self.supported_query:",
            "            d['supported_query'].append(sq.to_dict())",
            "        d['inbox_service_accepted_content'] = self.inbox_service_accepted_content",
            "        d['available'] = self.available",
            "        d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Service Instance ===\\n\"",
            "        s += line_prepend + \"  Service Type: %s\\n\" % self.service_type",
            "        s += line_prepend + \"  Service Version: %s\\n\" % self.services_version",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.protocol_binding",
            "        s += line_prepend + \"  Service Address: %s\\n\" % self.service_address",
            "        for mb in self.message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if self.service_type == SVC_INBOX:",
            "            s += line_prepend + \"  Inbox Service AC: %s\\n\" % [ac.to_text() for ac in self.inbox_service_accepted_content]",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for q in self.supported_query:",
            "            s += q.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):  # Expects a taxii_11:Service_Instance element",
            "        service_type = etree_xml.attrib['service_type']",
            "        services_version = etree_xml.attrib['service_version']",
            "        available = None",
            "        if etree_xml.attrib.get('available'):",
            "            tmp_available = etree_xml.attrib['available']",
            "            available = tmp_available == 'true'",
            "",
            "        protocol_binding = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        service_address = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for mb in message_binding_set:",
            "            message_bindings.append(mb.text)",
            "",
            "        inbox_service_accepted_content = []",
            "        inbox_service_accepted_content_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for cb in inbox_service_accepted_content_set:",
            "            inbox_service_accepted_content.append(ContentBinding.from_etree(cb))",
            "",
            "        supported_query = []",
            "        supported_query_set = etree_xml.xpath('./taxii_11:Supported_Query', namespaces=ns_map)",
            "        for sq in supported_query_set:",
            "            format_id = sq.xpath('./@format_id')[0]",
            "            query_obj = get_deserializer(format_id, 'query_info').from_etree(sq)",
            "            supported_query.append(query_obj)",
            "",
            "        message = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        return ServiceInstance(service_type,",
            "                               services_version,",
            "                               protocol_binding,",
            "                               service_address,",
            "                               message_bindings,",
            "                               inbox_service_accepted_content,",
            "                               available,",
            "                               message,",
            "                               supported_query)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        service_type = d['service_type']",
            "        services_version = d['services_version']",
            "        protocol_binding = d['protocol_binding']",
            "        service_address = d['service_address']",
            "        message_bindings = d['message_bindings']",
            "        supported_query = []",
            "        sq_list = d.get('supported_query')",
            "        if sq_list is not None:",
            "            for sq in sq_list:",
            "                format_id = sq['format_id']",
            "                query_obj = get_deserializer(format_id, 'query_info').from_dict(sq)",
            "                supported_query.append(query_obj)",
            "        inbox_service_accepted_content = d.get('inbox_service_accepted_content')",
            "        available = d.get('available')",
            "        message = d.get('message')",
            "",
            "        return ServiceInstance(service_type,",
            "                               services_version,",
            "                               protocol_binding,",
            "                               service_address,",
            "                               message_bindings,",
            "                               inbox_service_accepted_content,",
            "                               available,",
            "                               message,",
            "                               supported_query)",
            "",
            "",
            "class CollectionInformationRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Collection Information Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_COLLECTION_INFORMATION_REQUEST",
            "",
            "",
            "class CollectionInformationResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Collection Information Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_informations (list of CollectionInformation objects): A list",
            "            of CollectionInformation objects to be contained in this response.",
            "            **Optional**",
            "    \"\"\"",
            "    message_type = MSG_COLLECTION_INFORMATION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, collection_informations=None):",
            "        super(CollectionInformationResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.collection_informations = collection_informations or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_informations(self):",
            "        return self._collection_informations",
            "",
            "    @collection_informations.setter",
            "    def collection_informations(self, value):",
            "        do_check(value, 'collection_informations', type=CollectionInformation)",
            "        self._collection_informations = value",
            "",
            "    def to_etree(self):",
            "        xml = super(CollectionInformationResponse, self).to_etree()",
            "        for collection in self.collection_informations:",
            "            xml.append(collection.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(CollectionInformationResponse, self).to_dict()",
            "        d['collection_informations'] = []",
            "        for collection in self.collection_informations:",
            "            d['collection_informations'].append(collection.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(CollectionInformationResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"Contains %s Collection Informations\\n\" % len(self.collection_informations)",
            "        for collection in self.collection_informations:",
            "            s += collection.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(CollectionInformationResponse, cls).from_etree(etree_xml)",
            "        msg.collection_informations = []",
            "        collection_informations = etree_xml.xpath('./taxii_11:Collection', namespaces=ns_map)",
            "        for collection in collection_informations:",
            "            msg.collection_informations.append(CollectionInformation.from_etree(collection))",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(CollectionInformationResponse, cls).from_dict(d)",
            "        msg.collection_informations = []",
            "        for collection in d['collection_informations']:",
            "            msg.collection_informations.append(CollectionInformation.from_dict(collection))",
            "        return msg",
            "",
            "",
            "class CollectionInformation(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Collection Information component of a TAXII Collection Information",
            "    Response Message.",
            "",
            "    Arguments:",
            "        collection_name (str): the name by which this TAXII Data Collection is",
            "            identified. **Required**",
            "        collection_description (str): a prose description of this TAXII",
            "            Data Collection. **Required**",
            "        supported_contents (list of str): Content Binding IDs",
            "            indicating which types of content are currently expressed in this",
            "            TAXII Data Collection. **Optional**",
            "        available (boolean): whether the identity of the requester",
            "            (authenticated or otherwise) is allowed to access this TAXII",
            "            Service. **Optional** Default: ``None``, indicating \"unknown\"",
            "        push_methods (list of PushMethod objects): the protocols that",
            "            can be used to push content via a subscription. **Optional**",
            "        polling_service_instances (list of PollingServiceInstance objects):",
            "            the bindings and address a Consumer can use to interact with a",
            "            Poll Service instance that supports this TAXII Data Collection.",
            "            **Optional**",
            "        subscription_methods (list of SubscriptionMethod objects): the",
            "            protocol and address of the TAXII Daemon hosting the Collection",
            "            Management Service that can process subscriptions for this TAXII",
            "            Data Collection. **Optional**",
            "        collection_volume (int): the typical number of messages per day.",
            "            **Optional**",
            "        collection_type (str): the type ofo this collection. **Optional**,",
            "            defaults to :py:data:`CT_DATA_FEED`.",
            "        receiving_inbox_services (list of ReceivingInboxService objects):",
            "            TODO: FILL THIS IN. **Optional**",
            "",
            "    If ``supported_contents`` is omitted, then the collection supports all",
            "    content bindings.  The absense of ``push_methods`` indicates no push",
            "    methods.  The absense of ``polling_service_instances`` indicates no",
            "    polling services.  The absense of ``subscription_methods`` indicates no",
            "    subscription services.  The absense of ``receiving_inbox_services``",
            "    indicates no receiving inbox services.",
            "    \"\"\"",
            "",
            "    def __init__(self, collection_name, collection_description,",
            "                 supported_contents=None, available=None, push_methods=None,",
            "                 polling_service_instances=None, subscription_methods=None,",
            "                 collection_volume=None, collection_type=CT_DATA_FEED,",
            "                 receiving_inbox_services=None):",
            "        self.collection_name = collection_name",
            "        self.available = available",
            "        self.collection_description = collection_description",
            "        self.supported_contents = supported_contents or []",
            "        self.push_methods = push_methods or []",
            "        self.polling_service_instances = polling_service_instances or []",
            "        self.subscription_methods = subscription_methods or []",
            "        self.receiving_inbox_services = receiving_inbox_services or []",
            "        self.collection_volume = collection_volume",
            "        self.collection_type = collection_type",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.collection_name",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'supported_contents', type=ContentBinding)",
            "        self._supported_contents = value",
            "",
            "    @property",
            "    def push_methods(self):",
            "        return self._push_methods",
            "",
            "    @push_methods.setter",
            "    def push_methods(self, value):",
            "        do_check(value, 'push_methods', type=PushMethod)",
            "        self._push_methods = value",
            "",
            "    @property",
            "    def polling_service_instances(self):",
            "        return self._polling_service_instances",
            "",
            "    @polling_service_instances.setter",
            "    def polling_service_instances(self, value):",
            "        do_check(value, 'polling_service_instances', type=PollingServiceInstance)",
            "        self._polling_service_instances = value",
            "",
            "    @property",
            "    def subscription_methods(self):",
            "        return self._subscription_methods",
            "",
            "    @subscription_methods.setter",
            "    def subscription_methods(self, value):",
            "        do_check(value, 'subscription_methods', type=SubscriptionMethod)",
            "        self._subscription_methods = value",
            "",
            "    @property",
            "    def receiving_inbox_services(self):",
            "        return self._receiving_inbox_services",
            "",
            "    @receiving_inbox_services.setter",
            "    def receiving_inbox_services(self, value):",
            "        do_check(value, 'receiving_inbox_services', type=ReceivingInboxService)",
            "        self._receiving_inbox_services = value",
            "",
            "    @property",
            "    def collection_volume(self):",
            "        return self._collection_volume",
            "",
            "    @collection_volume.setter",
            "    def collection_volume(self, value):",
            "        do_check(value, 'collection_volume', type=int, can_be_none=True)",
            "        self._collection_volume = value",
            "",
            "    @property",
            "    def collection_type(self):",
            "        return self._collection_type",
            "",
            "    @collection_type.setter",
            "    def collection_type(self, value):",
            "        do_check(value, 'collection_type', value_tuple=CT_TYPES, can_be_none=True)",
            "        self._collection_type = value",
            "",
            "    def to_etree(self):",
            "        c = etree.Element('{%s}Collection' % ns_map['taxii_11'], nsmap=ns_map)",
            "        c.attrib['collection_name'] = self.collection_name",
            "        if self.collection_type is not None:",
            "            c.attrib['collection_type'] = self.collection_type",
            "        if self.available is not None:",
            "            c.attrib['available'] = str(self.available).lower()",
            "        collection_description = etree.SubElement(c, '{%s}Description' % ns_map['taxii_11'], nsmap=ns_map)",
            "        collection_description.text = self.collection_description",
            "",
            "        if self.collection_volume is not None:",
            "            collection_volume = etree.SubElement(c, '{%s}Collection_Volume' % ns_map['taxii_11'], nsmap=ns_map)",
            "            collection_volume.text = str(self.collection_volume)",
            "",
            "        for binding in self.supported_contents:",
            "            c.append(binding.to_etree())",
            "",
            "        for push_method in self.push_methods:",
            "            c.append(push_method.to_etree())",
            "",
            "        for polling_service in self.polling_service_instances:",
            "            c.append(polling_service.to_etree())",
            "",
            "        for subscription_method in self.subscription_methods:",
            "            c.append(subscription_method.to_etree())",
            "",
            "        for receiving_inbox_service in self.receiving_inbox_services:",
            "            c.append(receiving_inbox_service.to_etree())",
            "",
            "        return c",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['collection_name'] = self.collection_name",
            "        if self.collection_type is not None:",
            "            d['collection_type'] = self.collection_type",
            "        if self.available is not None:",
            "            d['available'] = self.available",
            "        d['collection_description'] = self.collection_description",
            "        if self.collection_volume is not None:",
            "            d['collection_volume'] = self.collection_volume",
            "        # TODO: I think this isn't a good serialization, I think a for loop is necessary",
            "        # This is probably a bug",
            "        d['supported_contents'] = self.supported_contents",
            "",
            "        d['push_methods'] = []",
            "        for push_method in self.push_methods:",
            "            d['push_methods'].append(push_method.to_dict())",
            "",
            "        d['polling_service_instances'] = []",
            "        for polling_service in self.polling_service_instances:",
            "            d['polling_service_instances'].append(polling_service.to_dict())",
            "",
            "        d['subscription_methods'] = []",
            "        for subscription_method in self.subscription_methods:",
            "            d['subscription_methods'].append(subscription_method.to_dict())",
            "",
            "        d['receiving_inbox_services'] = []",
            "        for receiving_inbox_service in self.receiving_inbox_services:",
            "            d['receiving_inbox_services'].append(receiving_inbox_service.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Data Collection Information ===\\n\"",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Collection Type: %s\\n\" % (self.collection_type if (None != self.collection_type) else CT_DATA_FEED)",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Collection Description: %s\\n\" % self.collection_description",
            "        if self.collection_volume:",
            "            s += line_prepend + \"  Volume: %s\\n\" % self.collection_volume",
            "        if len(self.supported_contents) == 0:  # All contents supported:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % \"All\"",
            "        for contents in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % contents.to_text(line_prepend + STD_INDENT)",
            "        for psi in self.polling_service_instances:",
            "            s += psi.to_text(line_prepend + STD_INDENT)",
            "        for sm in self.subscription_methods:",
            "            s += sm.to_text(line_prepend + STD_INDENT)",
            "        for ris in self.receiving_inbox_services:",
            "            s += ris.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"==================================\\n\\n\"",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "        kwargs['collection_type'] = etree_xml.attrib.get('collection_type', None)",
            "",
            "        kwargs['available'] = None",
            "        if 'available' in etree_xml.attrib:",
            "            tmp = etree_xml.attrib['available']",
            "            kwargs['available'] = tmp.lower() == 'true'",
            "",
            "        kwargs['collection_description'] = get_required(etree_xml, './taxii_11:Description', ns_map).text",
            "",
            "        collection_volume_text = get_optional_text(etree_xml, './taxii_11:Collection_Volume', ns_map)",
            "        if collection_volume_text:",
            "            kwargs['collection_volume'] = int(collection_volume_text)",
            "",
            "        kwargs['supported_contents'] = []",
            "        supported_content_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for binding_elt in supported_content_set:",
            "            kwargs['supported_contents'].append(ContentBinding.from_etree(binding_elt))",
            "",
            "        kwargs['push_methods'] = []",
            "        push_method_set = etree_xml.xpath('./taxii_11:Push_Method', namespaces=ns_map)",
            "        for push_method_elt in push_method_set:",
            "            kwargs['push_methods'].append(PushMethod.from_etree(push_method_elt))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        polling_service_set = etree_xml.xpath('./taxii_11:Polling_Service', namespaces=ns_map)",
            "        for polling_elt in polling_service_set:",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_etree(polling_elt))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        subscription_method_set = etree_xml.xpath('./taxii_11:Subscription_Service', namespaces=ns_map)",
            "        for subscription_elt in subscription_method_set:",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_etree(subscription_elt))",
            "",
            "        kwargs['receiving_inbox_services'] = []",
            "        receiving_inbox_services_set = etree_xml.xpath('./taxii_11:Receiving_Inbox_Service', namespaces=ns_map)",
            "        for receiving_inbox_service in receiving_inbox_services_set:",
            "            kwargs['receiving_inbox_services'].append(ReceivingInboxService.from_etree(receiving_inbox_service))",
            "",
            "        return CollectionInformation(**kwargs)",
            "",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['collection_type'] = d.get('collection_type')",
            "        kwargs['available'] = d.get('available')",
            "        kwargs['collection_description'] = d['collection_description']",
            "        kwargs['collection_volume'] = d.get('collection_volume')",
            "",
            "        kwargs['supported_contents'] = d.get('supported_contents', [])",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method in d.get('push_methods', []):",
            "            kwargs['push_methods'].append(PushMethod.from_dict(push_method))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling in d.get('polling_service_instances', []):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_dict(polling))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_method in d.get('subscription_methods', []):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_dict(subscription_method))",
            "",
            "        kwargs['receiving_inbox_services'] = []",
            "        receiving_inbox_services_set = d.get('receiving_inbox_services', [])",
            "        for receiving_inbox_service in receiving_inbox_services_set:",
            "            kwargs['receiving_inbox_services'].append(ReceivingInboxService.from_dict(receiving_inbox_service))",
            "",
            "        return CollectionInformation(**kwargs)",
            "",
            "",
            "class PushMethod(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Push Method component of a TAXII Collection Information",
            "    component.",
            "",
            "    Args:",
            "        push_protocol (str): a protocol binding that can be used",
            "            to push content to an Inbox Service instance. **Required**",
            "        push_message_bindings (list of str): the message bindings that",
            "            can be used to push content to an Inbox Service instance",
            "            using the protocol identified in the Push Protocol field.",
            "            **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, push_protocol, push_message_bindings):",
            "        self.push_protocol = push_protocol",
            "        self.push_message_bindings = push_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.push_protocol",
            "",
            "    @property",
            "    def push_protocol(self):",
            "        return self._push_protocol",
            "",
            "    @push_protocol.setter",
            "    def push_protocol(self, value):",
            "        do_check(value, 'push_protocol', regex_tuple=uri_regex)",
            "        self._push_protocol = value",
            "",
            "    @property",
            "    def push_message_bindings(self):",
            "        return self._push_message_bindings",
            "",
            "    @push_message_bindings.setter",
            "    def push_message_bindings(self, value):",
            "        do_check(value, 'push_message_bindings', regex_tuple=uri_regex)",
            "        self._push_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Push_Method' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.push_protocol",
            "        for binding in self.push_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['push_protocol'] = self.push_protocol",
            "        d['push_message_bindings'] = []",
            "        for binding in self.push_message_bindings:",
            "            d['push_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.push_protocol",
            "        for mb in self.push_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['push_protocol'] = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "",
            "        kwargs['push_message_bindings'] = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            kwargs['push_message_bindings'].append(message_binding.text)",
            "        return PushMethod(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PushMethod(**d)",
            "",
            "",
            "class PollingServiceInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Polling Service Instance component of a TAXII Collection",
            "    Information component.",
            "",
            "    Args:",
            "        poll_protocol (str): the protocol binding supported by",
            "            this Poll Service instance. **Required**",
            "        poll_address (str): the address of the TAXII Daemon",
            "            hosting this Poll Service instance. **Required**",
            "        poll_message_bindings (list of str): the message bindings",
            "            supported by this Poll Service instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Polling_Service'",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Polling_Service' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.poll_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        address.text = self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Polling Service Instance ===\\n\"",
            "        s += line_prepend + \"  Poll Protocol: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Poll Address: %s\\n\" % self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % binding",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class SubscriptionMethod(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Method component of a TAXII Collection Information",
            "    component.",
            "",
            "    Args:",
            "        subscription_protocol (str): the protocol binding supported by",
            "            this Collection Management Service instance. **Required**",
            "        subscription_address (str): the address of the TAXII Daemon",
            "            hosting this Collection Management Service instance.",
            "            **Required**.",
            "        subscription_message_bindings (list of str): the message",
            "            bindings supported by this Collection Management Service",
            "            Instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Subscription_Service'",
            "",
            "    def __init__(self, subscription_protocol, subscription_address,",
            "                 subscription_message_bindings):",
            "        self.subscription_protocol = subscription_protocol",
            "        self.subscription_address = subscription_address",
            "        self.subscription_message_bindings = subscription_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_address",
            "",
            "    @property",
            "    def subscription_protocol(self):",
            "        return self._subscription_protocol",
            "",
            "    @subscription_protocol.setter",
            "    def subscription_protocol(self, value):",
            "        do_check(value, 'subscription_protocol', regex_tuple=uri_regex)",
            "        self._subscription_protocol = value",
            "",
            "    @property",
            "    def subscription_message_bindings(self):",
            "        return self._subscription_message_bindings",
            "",
            "    @subscription_message_bindings.setter",
            "    def subscription_message_bindings(self, value):",
            "        do_check(value, 'subscription_message_bindings', regex_tuple=uri_regex)",
            "        self._subscription_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.NAME))",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.subscription_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        address.text = self.subscription_address",
            "        for binding in self.subscription_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_protocol'] = self.subscription_protocol",
            "        d['subscription_address'] = self.subscription_address",
            "        d['subscription_message_bindings'] = []",
            "        for binding in self.subscription_message_bindings:",
            "            d['subscription_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Service ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.subscription_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.subscription_address",
            "        for mb in self.subscription_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "        bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class ReceivingInboxService(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Receiving Inbox Service component of a TAXII Collection",
            "    Information component.",
            "",
            "    Args:",
            "        inbox_protocol (str): Indicates the protocol this Inbox Service",
            "            uses. **Required**",
            "        inbox address (str): Indicates the address of this Inbox Service.",
            "            **Required**",
            "        inbox_message_bindings (list of str): Each string indicates a",
            "            message binding that this inbox service uses. **Required**",
            "        supported_contents (list of ContentBinding objects): Each object",
            "            indicates a Content Binding this inbox service can receive.",
            "            **Optional**.  Setting to ``None`` means that all Content",
            "            Bindings are supported.",
            "    \"\"\"",
            "",
            "    def __init__(self, inbox_protocol, inbox_address,",
            "                 inbox_message_bindings, supported_contents=None):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.inbox_message_bindings = inbox_message_bindings",
            "        self.supported_contents = supported_contents or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', type=six.string_types, regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def inbox_message_bindings(self):",
            "        return self._inbox_message_bindings",
            "",
            "    @inbox_message_bindings.setter",
            "    def inbox_message_bindings(self, value):",
            "        do_check(value, 'inbox_message_bindings', regex_tuple=uri_regex)",
            "        self._inbox_message_bindings = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'supported_contents', type=ContentBinding)",
            "        self._supported_contents = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Receiving_Inbox_Service' % ns_map['taxii_11'], nsmap=ns_map)",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.inbox_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.inbox_address",
            "",
            "        for binding in self.inbox_message_bindings:",
            "            mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "            mb.text = binding",
            "",
            "        for binding in self.supported_contents:",
            "            xml.append(binding.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['inbox_protocol'] = self.inbox_protocol",
            "        d['inbox_address'] = self.inbox_address",
            "        d['inbox_message_bindings'] = self.inbox_message_bindings",
            "        d['supported_contents'] = []",
            "        for supported_content in self.supported_contents:",
            "            d['supported_contents'].append(supported_content.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Receiving Inbox Service ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.inbox_address",
            "        for mb in self.inbox_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if len(self.supported_contents) == 0:",
            "            s += line_prepend + \"  Supported Contents: All\\n\"",
            "        for sc in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % str(sc)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        proto = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for mb in message_binding_set:",
            "            message_bindings.append(mb.text)",
            "",
            "        supported_contents = []",
            "        supported_contents_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for cb in supported_contents_set:",
            "            supported_contents.append(ContentBinding.from_etree(cb))",
            "",
            "        return ReceivingInboxService(proto, addr, message_bindings, supported_contents)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['inbox_protocol'] = d['inbox_protocol']",
            "        kwargs['inbox_address'] = d['inbox_address']",
            "        kwargs['inbox_message_bindings'] = d['inbox_message_bindings']",
            "        kwargs['supported_contents'] = []",
            "        for binding in d['supported_contents']:",
            "            kwargs['supported_contents'].append(ContentBinding.from_dict(binding))",
            "",
            "        return ReceivingInboxService(**kwargs)",
            "",
            "",
            "class PollRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Request message.",
            "",
            "    Arguments:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection that is being",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional for a Data Feed, Prohibited",
            "            for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional for a Data Feed, Probited",
            "            for a Data Set**",
            "        subscription_id (str): the existing subscription the Consumer",
            "            wishes to poll. **Optional**",
            "        poll_parameters (list of PollParameters objects): the poll parameters",
            "            for this request. **Optional**",
            "",
            "    Exactly one of ``subscription_id`` and ``poll_parameters`` is **Required**.",
            "    \"\"\"",
            "    message_type = MSG_POLL_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 poll_parameters=None):",
            "        super(PollRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.poll_parameters = poll_parameters",
            "",
            "        if subscription_id is None and poll_parameters is None:",
            "            raise ValueError('One of subscription_id or poll_parameters must not be None')",
            "        if subscription_id is not None and poll_parameters is not None:",
            "            raise ValueError('Only one of subscription_id and poll_parameters can be present')",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', value_tuple=(None, None), can_be_none=True)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def poll_parameters(self):",
            "        return self._poll_parameters",
            "",
            "    @poll_parameters.setter",
            "    def poll_parameters(self, value):",
            "        do_check(value, 'poll_parameters', type=PollParameters, can_be_none=True)",
            "        self._poll_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "",
            "        if self.exclusive_begin_timestamp_label is not None:",
            "            ebt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'], nsmap=ns_map)",
            "            # TODO: Add TZ Info",
            "            ebt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label is not None:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'], nsmap=ns_map)",
            "            # TODO: Add TZ Info",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'], nsmap=ns_map)",
            "            si.text = self.subscription_id",
            "",
            "        if self.poll_parameters is not None:",
            "            xml.append(self.poll_parameters.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label is not None:  # TODO: Add TZ Info",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label is not None:  # TODO: Add TZ Info",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['poll_parameters'] = None",
            "        if self.poll_parameters is not None:",
            "            d['poll_parameters'] = self.poll_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label",
            "        s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label",
            "        if self.poll_parameters:",
            "            s += self.poll_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "",
            "        begin_ts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        if begin_ts_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(begin_ts_text)",
            "",
            "        end_ts_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        if end_ts_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(end_ts_text)",
            "",
            "        poll_parameter_el = get_optional(etree_xml, './taxii_11:Poll_Parameters', ns_map)",
            "        if poll_parameter_el is not None:",
            "            kwargs['poll_parameters'] = PollParameters.from_etree(poll_parameter_el)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "",
            "        msg = super(PollRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if 'exclusive_begin_timestamp_label' in d:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if 'inclusive_end_timestamp_label' in d:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['poll_parameters'] = None",
            "        if 'poll_parameters' in d and d['poll_parameters'] is not None:",
            "            kwargs['poll_parameters'] = PollParameters.from_dict(d['poll_parameters'])",
            "",
            "        msg = super(PollRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class PollParameters(_GenericParameters):",
            "",
            "    \"\"\"",
            "    The Poll Parameters component of a TAXII Poll Request message.",
            "",
            "    Args:",
            "        response_type (str): The requested response type. Must be either",
            "            :py:data:`RT_FULL` or :py:data:`RT_COUNT_ONLY`. **Optional**,",
            "            defaults to :py:data:`RT_FULL`",
            "        content_bindings (list of ContentBinding objects): A list of Content",
            "            Bindings acceptable in response. **Optional**",
            "        query (Query): The query for this poll parameters. **Optional**",
            "        allow_asynch (bool): Indicates whether the client supports",
            "            asynchronous polling. **Optional**, defaults to ``False``",
            "        delivery_parameters (libtaxii.messages_11.DeliveryParameters): The requested delivery",
            "            parameters for this object. **Optional**",
            "",
            "    If ``content_bindings`` in not provided, this indicates that all",
            "    bindings are accepted as a response.",
            "    \"\"\"",
            "    name = 'Poll_Parameters'",
            "",
            "    def __init__(self, response_type=RT_FULL, content_bindings=None,",
            "                 query=None, allow_asynch=False, delivery_parameters=None):",
            "        super(PollParameters, self).__init__(response_type, content_bindings, query)",
            "        self.allow_asynch = allow_asynch",
            "        self.delivery_parameters = delivery_parameters",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    @property",
            "    def allow_asynch(self):",
            "        return self._allow_asynch",
            "",
            "    @allow_asynch.setter",
            "    def allow_asynch(self, value):",
            "        do_check(value, 'allow_asynch', value_tuple=(True, False), can_be_none=True)",
            "        self._allow_asynch = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollParameters, self).to_etree()",
            "",
            "        if self.allow_asynch is not None:",
            "            xml.attrib['allow_asynch'] = str(self.allow_asynch).lower()",
            "",
            "        if self.delivery_parameters is not None:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollParameters, self).to_dict()",
            "        if self.allow_asynch is not None:",
            "            d['allow_asynch'] = str(self.allow_asynch).lower()",
            "        d['delivery_parameters'] = None",
            "        if self.delivery_parameters is not None:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollParameters, self).to_text(line_prepend)",
            "        if self.allow_asynch:",
            "            s += line_prepend + \"  Allow Asynch: %s\\n\" % self.allow_asynch",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        poll_parameters = super(PollParameters, cls).from_etree(etree_xml)",
            "",
            "        allow_asynch_el = get_optional(etree_xml, './@allow_asynch', ns_map)",
            "        poll_parameters.allow_asynch = allow_asynch_el == 'true'",
            "",
            "        delivery_parameters_el = get_optional(etree_xml, './taxii_11:Delivery_Parameters', ns_map)",
            "        if delivery_parameters_el is not None:",
            "            poll_parameters.delivery_parameters = DeliveryParameters.from_etree(delivery_parameters_el)",
            "",
            "        return poll_parameters",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        poll_parameters = super(PollParameters, cls).from_dict(d)",
            "",
            "        aa = d.get('allow_asynch')",
            "        if aa is not None:",
            "            poll_parameters.allow_asynch = aa == 'true'",
            "",
            "        delivery_parameters = d.get('delivery_parameters')",
            "        if delivery_parameters is not None:",
            "            poll_parameters.delivery_parameters = DeliveryParameters.from_dict(delivery_parameters)",
            "",
            "        return poll_parameters",
            "",
            "",
            "class PollResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection that was",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range this response covers.",
            "            **Optional for a Data Feed, Prohibited for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range this response covers. **Optional",
            "            for a Data Feed, Prohibited for a Data Set**",
            "        subscription_id (str): the Subscription ID for which this content",
            "            is being provided. **Optional**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        content_blocks (list of ContentBlock): piece of content",
            "            and additional information related to the content. **Optional**",
            "        more (bool): Whether there are more result parts. **Optional**, defaults",
            "            to ``False``",
            "        result_id (str): The ID of this result. **Optional**",
            "        result_part_number (int): The result part number of this response.",
            "             **Optional**",
            "        record_count (RecordCount): The number of records and whether",
            "             the count is a lower bound. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_POLL_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 collection_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 message=None, content_blocks=None, more=False, result_id=None,",
            "                 result_part_number=1, record_count=None):",
            "        super(PollResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.collection_name = collection_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "        self.more = more",
            "        self.result_part_number = result_part_number",
            "        self.result_id = result_id",
            "        self.record_count = record_count",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label', can_be_none=True)",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    @property",
            "    def more(self):",
            "        return self._more",
            "",
            "    @more.setter",
            "    def more(self, value):",
            "        do_check(value, 'more', value_tuple=(True, False))",
            "        self._more = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def result_part_number(self):",
            "        return self._result_part_number",
            "",
            "    @result_part_number.setter",
            "    def result_part_number(self, value):",
            "        do_check(value, 'result_part_number', type=int, can_be_none=True)",
            "        self._result_part_number = value",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=RecordCount, can_be_none=True)",
            "        self._record_count = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollResponse, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        if self.result_id is not None:",
            "            xml.attrib['result_id'] = self.result_id",
            "",
            "        if self.more is not None:",
            "            xml.attrib['more'] = str(self.more).lower()",
            "",
            "        if self.result_part_number is not None:",
            "            xml.attrib['result_part_number'] = str(self.result_part_number)",
            "",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "            si.text = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ibt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'])",
            "            ibt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'])",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        if self.record_count:",
            "            xml.append(self.record_count.to_etree())",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollResponse, self).to_dict()",
            "",
            "        d['collection_name'] = self.collection_name",
            "        d['more'] = self.more",
            "        d['result_id'] = self.result_id",
            "        d['result_part_number'] = self.result_part_number",
            "        if self.record_count is not None:",
            "            d['record_count'] = self.record_count.to_dict()",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        if self.exclusive_begin_timestamp_label is not None:",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label is not None:",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  More: %s\\n\" % self.more",
            "        s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        if self.result_part_number:",
            "            s += line_prepend + \"  Result Part Num: %s\\n\" % self.result_part_number",
            "        if self.record_count:",
            "            s += self.record_count.to_text(line_prepend + STD_INDENT)",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.message:",
            "            s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "        kwargs['more'] = etree_xml.attrib.get('more', 'false') == 'true'",
            "        kwargs['subscription_id'] = None",
            "        kwargs['result_id'] = etree_xml.attrib.get('result_id')",
            "        rpn = etree_xml.attrib.get('result_part_number', None)",
            "        if rpn:",
            "            kwargs['result_part_number'] = int(rpn)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        ebts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        if ebts_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(ebts_text)",
            "",
            "        iets_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        if iets_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iets_text)",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in etree_xml.xpath('./taxii_11:Content_Block', namespaces=ns_map):",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        record_count_el = get_optional(etree_xml, './taxii_11:Record_Count', ns_map)",
            "        if record_count_el is not None:",
            "            kwargs['record_count'] = RecordCount.from_etree(record_count_el)",
            "",
            "        msg = super(PollResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['result_id'] = d.get('result_id')",
            "        kwargs['result_part_number'] = d.get('result_part_number')",
            "        kwargs['message'] = None",
            "        if 'message' in d:",
            "            kwargs['message'] = d['message']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "        kwargs['more'] = d.get('more', False)",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if 'exclusive_begin_timestamp_label' in d:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['record_count'] = None",
            "        if 'record_count' in d:",
            "            kwargs['record_count'] = RecordCount.from_dict(d['record_count'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if 'inclusive_end_timestamp_label' in d:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "        msg = super(PollResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "_StatusDetail = collections.namedtuple('_StatusDetail', ['name', 'required', 'type', 'multiple'])",
            "_DCE_AcceptableDestination = _StatusDetail(SD_ACCEPTABLE_DESTINATION, False, str, True)",
            "_IRP_MaxPartNumber = _StatusDetail(SD_MAX_PART_NUMBER, True, int, False)",
            "_NF_Item = _StatusDetail(SD_ITEM, False, str, False)",
            "_P_EstimatedWait = _StatusDetail(SD_ESTIMATED_WAIT, True, int, False)",
            "_P_ResultId = _StatusDetail(SD_RESULT_ID, True, str, False)",
            "_P_WillPush = _StatusDetail(SD_WILL_PUSH, True, bool, False)",
            "_R_EstimatedWait = _StatusDetail(SD_ESTIMATED_WAIT, False, int, False)",
            "_UM_SupportedBinding = _StatusDetail(SD_SUPPORTED_BINDING, False, str, True)",
            "_UC_SupportedContent = _StatusDetail(SD_SUPPORTED_CONTENT, False, ContentBinding, True)",
            "_UP_SupportedProtocol = _StatusDetail(SD_SUPPORTED_PROTOCOL, False, str, True)",
            "_UQ_SupportedQuery = _StatusDetail(SD_SUPPORTED_QUERY, False, str, True)",
            "",
            "",
            "status_details = {",
            "    ST_ASYNCHRONOUS_POLL_ERROR: {},",
            "    ST_BAD_MESSAGE: {},",
            "    ST_DENIED: {},",
            "    ST_DESTINATION_COLLECTION_ERROR: {SD_ACCEPTABLE_DESTINATION: _DCE_AcceptableDestination},",
            "    ST_FAILURE: {},",
            "    ST_INVALID_RESPONSE_PART: {SD_MAX_PART_NUMBER: _IRP_MaxPartNumber},",
            "    ST_NETWORK_ERROR: {},",
            "    ST_NOT_FOUND: {SD_ITEM: _NF_Item},",
            "    ST_PENDING: {SD_ESTIMATED_WAIT: _P_EstimatedWait,",
            "                 SD_RESULT_ID: _P_ResultId,",
            "                 SD_WILL_PUSH: _P_WillPush},",
            "    ST_POLLING_UNSUPPORTED: {},",
            "    ST_RETRY: {SD_ESTIMATED_WAIT: _R_EstimatedWait},",
            "    ST_SUCCESS: {},",
            "    ST_UNAUTHORIZED: {},",
            "    ST_UNSUPPORTED_MESSAGE_BINDING: {SD_SUPPORTED_BINDING: _UM_SupportedBinding},",
            "    ST_UNSUPPORTED_CONTENT_BINDING: {SD_SUPPORTED_CONTENT: _UC_SupportedContent},",
            "    ST_UNSUPPORTED_PROTOCOL: {SD_SUPPORTED_PROTOCOL: _UP_SupportedProtocol},",
            "    ST_UNSUPPORTED_QUERY: {SD_SUPPORTED_QUERY: _UQ_SupportedQuery}",
            "}",
            "",
            "",
            "class StatusMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Status message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        status_type (str): One of the defined Status Types or a third-party-",
            "            defined Status Type. **Required**",
            "        status_detail (dict): A field for additional information about",
            "            this status in a machine-readable format. **Required or Optional**",
            "            depending on ``status_type``. See TAXII Specification for details.",
            "        message (str): Additional information for the status. There is no",
            "            expectation that this field be interpretable by a machine; it is",
            "            instead targeted to a human operator. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_STATUS_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 status_type=None, status_detail=None, message=None):",
            "        super(StatusMessage, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.status_type = status_type",
            "        self.status_detail = status_detail or {}",
            "        self.message = message",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def status_type(self):",
            "        return self._status_type",
            "",
            "    @status_type.setter",
            "    def status_type(self, value):",
            "        do_check(value, 'status_type')",
            "        self._status_type = value",
            "",
            "    @property",
            "    def status_detail(self):",
            "        return self._status_detail",
            "",
            "    @status_detail.setter",
            "    def status_detail(self, value):",
            "        do_check(list(value.keys()), 'status_detail.keys()', regex_tuple=uri_regex)",
            "        detail_rules = status_details.get(self.status_type, {})",
            "        # Check defined status types for conformance",
            "        for sd_name, rules in six.iteritems(detail_rules):",
            "            do_check(value.get(sd_name, None),",
            "                     'status_detail[\\'%s\\']' % sd_name,",
            "                     type=rules.type,",
            "                     can_be_none=(not rules.required))",
            "",
            "        self._status_detail = value",
            "",
            "    @property",
            "    def message(self):",
            "        return self._message",
            "",
            "    @message.setter",
            "    def message(self, value):",
            "        do_check(value, 'message', type=six.string_types, can_be_none=True)",
            "        self._message = value",
            "",
            "    def to_etree(self):",
            "        xml = super(StatusMessage, self).to_etree()",
            "        xml.attrib['status_type'] = self.status_type",
            "",
            "        if len(self.status_detail) > 0:",
            "            sd = etree.SubElement(xml, '{%s}Status_Detail' % ns_map['taxii_11'])",
            "            for k, v in six.iteritems(self.status_detail):",
            "                if not isinstance(v, list):",
            "                    v = [v]",
            "                for item in v:",
            "                    d = etree.SubElement(sd, '{%s}Detail' % ns_map['taxii_11'])",
            "                    d.attrib['name'] = k",
            "                    if item in (True, False):",
            "                        d.text = str(item).lower()",
            "                    else:",
            "                        d.text = str(item)",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(StatusMessage, self).to_dict()",
            "        d['status_type'] = self.status_type",
            "        if self.status_detail is not None:",
            "            d['status_detail'] = self.status_detail",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(StatusMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"Status Type: %s\\n\" % self.status_type",
            "        for k, v in six.iteritems(self.status_detail):",
            "            s += line_prepend + \"Status Detail: %s = %s\\n\" % (k, v)",
            "        if self.message:",
            "            s += line_prepend + \"Message: %s\\n\" % self.message",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        status_type = etree_xml.attrib['status_type']",
            "        kwargs['status_type'] = status_type",
            "",
            "        kwargs['status_detail'] = {}",
            "        detail_set = etree_xml.xpath('./taxii_11:Status_Detail/taxii_11:Detail', namespaces=ns_map)",
            "        for detail in detail_set:",
            "            # TODO: This seems kind of hacky and should probably be improved",
            "            name = detail.attrib['name']",
            "",
            "            if status_type in status_details and name in status_details[status_type]:  # We have information for this status detail",
            "                detail_info = status_details[status_type][name]",
            "            else:  # We don't have information, so make something up",
            "                detail_info = _StatusDetail('PlaceholderDetail', False, str, True)",
            "",
            "            if detail_info.type == bool:",
            "                v = detail.text.lower() == 'true'",
            "            else:",
            "                v = detail_info.type(detail.text)",
            "            if detail_info.multiple:  # There can be multiple instances of this item",
            "                if name not in kwargs['status_detail']:",
            "                    kwargs['status_detail'][name] = v",
            "                else:  # It already exists",
            "                    if not isinstance(kwargs['status_detail'][name], list):",
            "                        kwargs['status_detail'][name] = [kwargs['status_detail'][name]]  # Make it a list",
            "                    kwargs['status_detail'][name].append(v)",
            "            else:",
            "                kwargs['status_detail'][name] = v",
            "",
            "        kwargs['message'] = None",
            "        m_set = etree_xml.xpath('./taxii_11:Message', namespaces=ns_map)",
            "        if len(m_set) > 0:",
            "            kwargs['message'] = m_set[0].text",
            "",
            "        msg = super(StatusMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['status_type'] = d['status_type']",
            "        kwargs['status_detail'] = d.get('status_detail')",
            "        kwargs['message'] = d.get('message')",
            "",
            "        msg = super(StatusMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class InboxMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Inbox message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        message (str): prose information for the message recipient. **Optional**",
            "        result_id (str): the result id. **Optional**",
            "        destination_collection_names (list of str): Each string indicates a",
            "             destination collection name. **Optional**",
            "        subscription_information (libtaxii.messages_11.SubscriptionInformation): This",
            "            field is only present if this message is being sent to provide",
            "            content in accordance with an existing TAXII Data Collection",
            "            subscription. **Optional**",
            "        record_count (RecordCount): The number of records and whether",
            "             the count is a lower bound. **Optional**",
            "        content_blocks (list of ContentBlock): Inbox content. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_INBOX_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None,",
            "                 message=None, result_id=None, destination_collection_names=None,",
            "                 subscription_information=None, record_count=None,",
            "                 content_blocks=None):",
            "",
            "        super(InboxMessage, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.subscription_information = subscription_information",
            "        self.message = message",
            "        self.result_id = result_id",
            "        self.destination_collection_names = destination_collection_names or []",
            "        self.subscription_information = subscription_information",
            "        self.record_count = record_count",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def subscription_information(self):",
            "        return self._subscription_information",
            "",
            "    @subscription_information.setter",
            "    def subscription_information(self, value):",
            "        do_check(value, 'subscription_information', type=SubscriptionInformation, can_be_none=True)",
            "        self._subscription_information = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def destination_collection_names(self):",
            "        return self._destination_collection_names",
            "",
            "    @destination_collection_names.setter",
            "    def destination_collection_names(self, value):",
            "        do_check(value, 'destination_collection_names', regex_tuple=uri_regex)",
            "        self._destination_collection_names = value",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=RecordCount, can_be_none=True)",
            "        self._record_count = value",
            "",
            "    def to_etree(self):",
            "        xml = super(InboxMessage, self).to_etree()",
            "",
            "        if self.result_id is not None:",
            "            xml.attrib['result_id'] = self.result_id",
            "",
            "        for dcn in self.destination_collection_names:",
            "            d = etree.SubElement(xml, '{%s}Destination_Collection_Name' % ns_map['taxii_11'], nsmap=ns_map)",
            "            d.text = dcn",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        if self.subscription_information is not None:",
            "            xml.append(self.subscription_information.to_etree())",
            "",
            "        if self.record_count is not None:",
            "            xml.append(self.record_count.to_etree())",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(InboxMessage, self).to_dict()",
            "",
            "        if self.result_id is not None:",
            "            d['result_id'] = self.result_id",
            "",
            "        d['destination_collection_names'] = []",
            "        for dcn in self.destination_collection_names:",
            "            d['destination_collection_names'].append(dcn)",
            "",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        if self.subscription_information is not None:",
            "            d['subscription_information'] = self.subscription_information.to_dict()",
            "",
            "        if self.record_count is not None:",
            "            d['record_count'] = self.record_count.to_dict()",
            "",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(InboxMessage, self).to_text(line_prepend)",
            "        if self.result_id:",
            "            s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        for dcn in self.destination_collection_names:",
            "            s += line_prepend + \"  Destination Collection Name: %s\\n\" % dcn",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.subscription_information:",
            "            s += self.subscription_information.to_text(line_prepend + STD_INDENT)",
            "        if self.record_count:",
            "            s += self.record_count.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"  Message has %s Content Blocks\\n\" % len(self.content_blocks)",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        result_id_set = etree_xml.xpath('./@result_id')",
            "        if len(result_id_set) > 0:",
            "            kwargs['result_id'] = result_id_set[0]",
            "",
            "        kwargs['destination_collection_names'] = []",
            "        dcn_set = etree_xml.xpath('./taxii_11:Destination_Collection_Name', namespaces=ns_map)",
            "        for dcn in dcn_set:",
            "            kwargs['destination_collection_names'].append(dcn.text)",
            "",
            "        msg_set = etree_xml.xpath('./taxii_11:Message', namespaces=ns_map)",
            "        if len(msg_set) > 0:",
            "            kwargs['message'] = msg_set[0].text",
            "",
            "        subs_infos = etree_xml.xpath('./taxii_11:Source_Subscription', namespaces=ns_map)",
            "        if len(subs_infos) > 0:",
            "            kwargs['subscription_information'] = SubscriptionInformation.from_etree(subs_infos[0])",
            "",
            "        record_count_set = etree_xml.xpath('./taxii_11:Record_Count', namespaces=ns_map)",
            "        if len(record_count_set) > 0:",
            "            kwargs['record_count'] = RecordCount.from_etree(record_count_set[0])",
            "",
            "        content_blocks = etree_xml.xpath('./taxii_11:Content_Block', namespaces=ns_map)",
            "        kwargs['content_blocks'] = []",
            "        for block in content_blocks:",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        msg = super(InboxMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "",
            "        kwargs = {}",
            "",
            "        kwargs['result_id'] = d.get('result_id')",
            "",
            "        kwargs['destination_collection_names'] = []",
            "        if 'destination_collection_names' in d:",
            "            for dcn in d['destination_collection_names']:",
            "                kwargs['destination_collection_names'].append(dcn)",
            "",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_information'] = None",
            "        if 'subscription_information' in d:",
            "            kwargs['subscription_information'] = SubscriptionInformation.from_dict(d['subscription_information'])",
            "",
            "        if 'record_count' in d:",
            "            kwargs['record_count'] = RecordCount.from_dict(d['record_count'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "",
            "        msg = super(InboxMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInformation(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Information component of a TAXII Inbox message.",
            "",
            "    Arguments:",
            "        collection_name (str): the name of the TAXII Data Collection from",
            "            which this content is being provided. **Required**",
            "        subscription_id (str): the Subscription ID for which this",
            "            content is being provided. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the time range this Inbox Message",
            "            covers. **Optional for a Data Feed, Prohibited for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the time range this Inbox Message covers.",
            "            **Optional for a Data Feed, Prohibited for a Data Set**",
            "    \"\"\"",
            "",
            "    def __init__(self, collection_name, subscription_id, exclusive_begin_timestamp_label=None, inclusive_end_timestamp_label=None):",
            "        self.collection_name = collection_name",
            "        self.subscription_id = subscription_id",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Source_Subscription' % ns_map['taxii_11'])",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "        si.text = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ebtl = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'])",
            "            ebtl.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            ietl = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'])",
            "            ietl.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['collection_name'] = self.collection_name",
            "        d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label:",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Source Subscription ===\\n\"",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % None",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % None",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        collection_name = etree_xml.attrib['collection_name']",
            "        subscription_id = get_required(etree_xml, './taxii_11:Subscription_ID', ns_map).text",
            "",
            "        begin_ts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        ebtl = parse_datetime_string(begin_ts_text) if begin_ts_text else None",
            "",
            "        end_ts_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        ietl = parse_datetime_string(end_ts_text) if end_ts_text else None",
            "",
            "        return SubscriptionInformation(collection_name, subscription_id, ebtl, ietl)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        collection_name = d['collection_name']",
            "        subscription_id = d['subscription_id']",
            "",
            "        ebtl = parse_datetime_string(d.get('exclusive_begin_timestamp_label'))",
            "        ietl = parse_datetime_string(d.get('inclusive_end_timestamp_label'))",
            "",
            "        return SubscriptionInformation(collection_name, subscription_id, ebtl, ietl)",
            "",
            "",
            "class ManageCollectionSubscriptionRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Collection Subscription Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which the",
            "            action applies. **Required**",
            "        action (str): the requested action to take. **Required**",
            "        subscription_id (str): the ID of a previously created subscription.",
            "            **Probibited** if ``action==``:py:data:`ACT_SUBSCRIBE`, else",
            "            **Required**",
            "        subscription_parameters (SubscriptionParameters): The parameters for",
            "            this subscription. **Optional**",
            "        push_parameters (list of PushParameter): the push parameters for this",
            "            request. **Optional** Absence means push is not requested.",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, action=None, subscription_id=None,",
            "                 subscription_parameters=None, push_parameters=None):",
            "",
            "        super(ManageCollectionSubscriptionRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.action = action",
            "        self.subscription_id = subscription_id",
            "        self.subscription_parameters = subscription_parameters or SubscriptionParameters()",
            "        self.push_parameters = push_parameters",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def action(self):",
            "        return self._action",
            "",
            "    @action.setter",
            "    def action(self, value):",
            "        do_check(value, 'action', value_tuple=ACT_TYPES)",
            "        self._action = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def subscription_parameters(self):",
            "        return self._subscription_parameters",
            "",
            "    @subscription_parameters.setter",
            "    def subscription_parameters(self, value):",
            "        do_check(value, 'subscription_parameters', type=SubscriptionParameters, can_be_none=True)",
            "        self._subscription_parameters = value",
            "",
            "    @property",
            "    def push_parameters(self):",
            "        return self._push_parameters",
            "",
            "    @push_parameters.setter",
            "    def push_parameters(self, value):",
            "        do_check(value, 'push_parameters', type=PushParameters, can_be_none=True)",
            "        self._push_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageCollectionSubscriptionRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        xml.attrib['action'] = self.action",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "            si.text = self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            xml.append(self.subscription_parameters.to_etree())",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            xml.append(self.push_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageCollectionSubscriptionRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        d['action'] = self.action",
            "",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            d['subscription_parameters'] = self.subscription_parameters.to_dict()",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            d['push_parameters'] = self.push_parameters.to_dict()",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageCollectionSubscriptionRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Action: %s\\n\" % self.action",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            s += self.subscription_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            s += self.push_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "        kwargs['action'] = get_required(etree_xml, './@action', ns_map)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "",
            "        subscription_parameters_el = get_optional(etree_xml, './taxii_11:Subscription_Parameters', ns_map)",
            "        if subscription_parameters_el is not None:",
            "            kwargs['subscription_parameters'] = SubscriptionParameters.from_etree(subscription_parameters_el)",
            "",
            "        push_parameters_el = get_optional(etree_xml, './taxii_11:Push_Parameters', ns_map)",
            "        if push_parameters_el is not None:",
            "            kwargs['push_parameters'] = PushParameters.from_etree(push_parameters_el)",
            "",
            "        msg = super(ManageCollectionSubscriptionRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['action'] = d['action']",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['subscription_parameters'] = None",
            "        if 'subscription_parameters' in d:",
            "            kwargs['subscription_parameters'] = SubscriptionParameters.from_dict(d['subscription_parameters'])",
            "",
            "        kwargs['push_parameters'] = None",
            "        if 'push_parameters' in d:",
            "            kwargs['push_parameters'] = PushParameters.from_dict(d['push_parameters'])",
            "",
            "        msg = super(ManageCollectionSubscriptionRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class ManageCollectionSubscriptionResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Collection Subscription Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which",
            "            the action applies. **Required**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        subscription_instances (list of SubscriptionInstance): **Optional**",
            "    \"\"\"",
            "    message_type = MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, collection_name=None, message=None, subscription_instances=None):",
            "        super(ManageCollectionSubscriptionResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.message = message",
            "        self.subscription_instances = subscription_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def subscription_instances(self):",
            "        return self._subscription_instances",
            "",
            "    @subscription_instances.setter",
            "    def subscription_instances(self, value):",
            "        do_check(value, 'subscription_instances', type=SubscriptionInstance)",
            "        self._subscription_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageCollectionSubscriptionResponse, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        for subscription_instance in self.subscription_instances:",
            "            xml.append(subscription_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageCollectionSubscriptionResponse, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        d['subscription_instances'] = []",
            "        for subscription_instance in self.subscription_instances:",
            "            d['subscription_instances'].append(subscription_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageCollectionSubscriptionResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for si in self.subscription_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for si in etree_xml.xpath('./taxii_11:Subscription', namespaces=ns_map):",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_etree(si))",
            "",
            "        msg = super(ManageCollectionSubscriptionResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for instance in d['subscription_instances']:",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_dict(instance))",
            "",
            "        msg = super(ManageCollectionSubscriptionResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Instance component of the Manage Collection Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        subscription_id (str): the id of the subscription. **Required**",
            "        status (str): One of :py:data:`SS_ACTIVE`, :py:data:`SS_PAUSED`, or",
            "                :py:data:`SS_UNSUBSCRIBED`. **Optional**, defaults to \"ACTIVE\"",
            "        subscription_parameters (SubscriptionParameters): the parameters",
            "            for this subscription. **Optional** If provided, should match",
            "            the request.",
            "        push_parameters (PushParameters): the push parameters for this",
            "            subscription. **Optional** If provided, should match the request.",
            "        poll_instances (list of PollInstance): The Poll Services that can be",
            "                polled to fulfill this subscription. **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, subscription_id, status=SS_ACTIVE,",
            "                 subscription_parameters=None, push_parameters=None,",
            "                 poll_instances=None):",
            "        self.subscription_id = subscription_id",
            "        self.status = status",
            "        self.subscription_parameters = subscription_parameters",
            "        self.push_parameters = push_parameters",
            "        self.poll_instances = poll_instances or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_id",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def status(self):",
            "        return self._status",
            "",
            "    @status.setter",
            "    def status(self, value):",
            "        do_check(value, 'status', value_tuple=SS_TYPES, can_be_none=True)",
            "        self._status = value",
            "",
            "    @property",
            "    def subscription_parameters(self):",
            "        return self._subscription_parameters",
            "",
            "    @subscription_parameters.setter",
            "    def subscription_parameters(self, value):",
            "        do_check(value, 'subscription_parameters', type=SubscriptionParameters, can_be_none=True)",
            "        self._subscription_parameters = value",
            "",
            "    @property",
            "    def push_parameters(self):",
            "        return self._push_parameters",
            "",
            "    @push_parameters.setter",
            "    def push_parameters(self, value):",
            "        do_check(value, 'push_parameters', type=PushParameters, can_be_none=True)",
            "        self._push_parameters = value",
            "",
            "    @property",
            "    def poll_instances(self):",
            "        return self._poll_instances",
            "",
            "    @poll_instances.setter",
            "    def poll_instances(self, value):",
            "        do_check(value, 'poll_instances', type=PollInstance)",
            "        self._poll_instances = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Subscription' % ns_map['taxii_11'], nsmap=ns_map)",
            "        if self.status is not None:",
            "            si.attrib['status'] = self.status",
            "",
            "        subs_id = etree.SubElement(si, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "        subs_id.text = self.subscription_id",
            "",
            "        if self.subscription_parameters is not None:",
            "            si.append(self.subscription_parameters.to_etree())",
            "",
            "        if self.push_parameters is not None:",
            "            si.append(self.push_parameters.to_etree())",
            "",
            "        for pi in self.poll_instances:",
            "            si.append(pi.to_etree())",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['status'] = self.status",
            "        d['subscription_id'] = self.subscription_id",
            "        d['subscription_parameters'] = None",
            "        if self.subscription_parameters is not None:",
            "            d['subscription_parameters'] = self.subscription_parameters.to_dict()",
            "",
            "        d['push_parameters'] = None",
            "        if self.push_parameters is not None:",
            "            d['push_parameters'] = self.push_parameters.to_dict()",
            "",
            "        d['poll_instances'] = []",
            "        for pi in self.poll_instances:",
            "            d['poll_instances'].append(pi.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Instance ===\\n\"",
            "        s += line_prepend + \"  Status: %s\\n\" % self.status",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.subscription_parameters:",
            "            s += self.subscription_parameters.to_text(line_prepend + STD_INDENT)",
            "        if self.push_parameters:",
            "            s += self.push_parameters.to_text(line_prepend + STD_INDENT)",
            "        for pi in self.poll_instances:",
            "            s += pi.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "",
            "        status = get_optional(etree_xml, './@status', ns_map)",
            "",
            "        subscription_id = get_required(etree_xml, './taxii_11:Subscription_ID', ns_map).text",
            "",
            "        subscription_parameters = None",
            "        subscription_parameters_el = get_optional(etree_xml, './taxii_11:Subscription_Parameters', ns_map)",
            "        if subscription_parameters_el is not None:",
            "            subscription_parameters = SubscriptionParameters.from_etree(subscription_parameters_el)",
            "",
            "        push_parameters = None",
            "        push_parameters_el = get_optional(etree_xml, './taxii_11:Push_Parameters', ns_map)",
            "        if push_parameters_el is not None:",
            "            push_parameters = PushParameters.from_etree(push_parameters_el)",
            "",
            "        poll_instances = []",
            "        for pi in etree_xml.xpath('./taxii_11:Poll_Instance', namespaces=ns_map):",
            "            poll_instances.append(PollInstance.from_etree(pi))",
            "",
            "        return SubscriptionInstance(subscription_id, status, subscription_parameters, push_parameters, poll_instances)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        subscription_id = d['subscription_id']",
            "        status = d.get('status')",
            "",
            "        subscription_parameters = None",
            "        if d.get('subscription_parameters') is not None:",
            "            subscription_parameters = SubscriptionParameters.from_dict(d['subscription_parameters'])",
            "",
            "        push_parameters = None",
            "        if d.get('push_parameters') is not None:",
            "            push_parameters = PushParameters.from_dict(d['push_parameters'])",
            "",
            "        poll_instances = []",
            "        if 'poll_instances' in d:",
            "            for pi in d['poll_instances']:",
            "                poll_instances.append(PollInstance.from_dict(pi))",
            "",
            "        return SubscriptionInstance(subscription_id, status, subscription_parameters, push_parameters, poll_instances)",
            "",
            "",
            "class PollInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Poll Instance component of the Manage Collection Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        poll_protocol (str): The protocol binding supported by this",
            "            instance of a Polling Service. **Required**",
            "        poll_address (str): the address of the TAXII Daemon hosting",
            "            this Poll Service. **Required**",
            "        poll_message_bindings (list of str): one or more message bindings",
            "            that can be used when interacting with this Poll Service",
            "            instance. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings=None):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Poll_Instance' % ns_map['taxii_11'])",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.poll_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.poll_address",
            "",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        poll_protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        address = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        poll_message_bindings = []",
            "        for b in etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map):",
            "            poll_message_bindings.append(b.text)",
            "",
            "        return PollInstance(poll_protocol, address, poll_message_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PollInstance(**d)",
            "",
            "",
            "class PollFulfillmentRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Fulfillment Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which the",
            "            action applies. **Required**",
            "        result_id (str): The result id of the requested result. **Required**",
            "        result_part_number (int): The part number being requested. **Required**",
            "    \"\"\"",
            "    message_type = MSG_POLL_FULFILLMENT_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, result_id=None, result_part_number=None):",
            "        super(PollFulfillmentRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.result_id = result_id",
            "        self.result_part_number = result_part_number",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def result_part_number(self):",
            "        return self._result_part_number",
            "",
            "    @result_part_number.setter",
            "    def result_part_number(self, value):",
            "        do_check(value, 'result_part_number', type=int)",
            "        self._result_part_number = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollFulfillmentRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        xml.attrib['result_id'] = self.result_id",
            "        xml.attrib['result_part_number'] = str(self.result_part_number)",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollFulfillmentRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        d['result_id'] = self.result_id",
            "        d['result_part_number'] = self.result_part_number",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollFulfillmentRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        s += line_prepend + \"  Result Part Number: %s\\n\" % self.result_part_number",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "        kwargs['result_id'] = etree_xml.attrib['result_id']",
            "        kwargs['result_part_number'] = int(etree_xml.attrib['result_part_number'])",
            "",
            "        return super(PollFulfillmentRequest, cls).from_etree(etree_xml, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['result_id'] = d['result_id']",
            "        kwargs['result_part_number'] = int(d['result_part_number'])",
            "",
            "        return super(PollFulfillmentRequest, cls).from_dict(d, **kwargs)",
            "",
            "",
            "########################################################",
            "# EVERYTHING BELOW HERE IS FOR BACKWARDS COMPATIBILITY #",
            "########################################################",
            "",
            "# Add top-level classes as nested classes for backwards compatibility",
            "DiscoveryResponse.ServiceInstance = ServiceInstance",
            "CollectionInformationResponse.CollectionInformation = CollectionInformation",
            "CollectionInformation.PushMethod = PushMethod",
            "CollectionInformation.PollingServiceInstance = PollingServiceInstance",
            "CollectionInformation.SubscriptionMethod = SubscriptionMethod",
            "CollectionInformation.ReceivingInboxService = ReceivingInboxService",
            "ManageCollectionSubscriptionResponse.PollInstance = PollInstance",
            "ManageCollectionSubscriptionResponse.SubscriptionInstance = SubscriptionInstance",
            "PollRequest.PollParameters = PollParameters",
            "InboxMessage.SubscriptionInformation = SubscriptionInformation",
            "",
            "# Constants not imported in `from constants import *`",
            "",
            "MSG_TYPES = MSG_TYPES_11",
            "ST_TYPES = ST_TYPES_11",
            "ACT_TYPES = ACT_TYPES_11",
            "SS_TYPES = SS_TYPES_11",
            "RT_TYPES = RT_TYPES_11",
            "CT_TYPES = CT_TYPES_11",
            "SVC_TYPES = SVC_TYPES_11",
            "SD_TYPES = SD_TYPES_11",
            "",
            "from .common import (generate_message_id)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Creating, handling, and parsing TAXII 1.1 messages.",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import six",
            "try:",
            "    import simplejson as json",
            "except ImportError:",
            "    import json",
            "import os",
            "import warnings",
            "",
            "from lxml import etree",
            "",
            "from .common import (parse, parse_datetime_string, append_any_content_etree, TAXIIBase,",
            "                     get_required, get_optional, get_optional_text, parse_xml_string,",
            "                     stringify_content)",
            "from .validation import do_check, uri_regex, check_timestamp_label",
            "from .constants import *",
            "",
            "",
            "def validate_xml(xml_string):",
            "    \"\"\"",
            "    Note that this function has been deprecated. Please see",
            "    libtaxii.validators.SchemaValidator.",
            "",
            "    Validate XML with the TAXII XML Schema 1.1.",
            "",
            "    Args:",
            "        xml_string (str): The XML to validate.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            is_valid = tm11.validate_xml(message.to_xml())",
            "    \"\"\"",
            "",
            "    warnings.warn('Call to deprecated function: libtaxii.messages_11.validate_xml()',",
            "                  category=DeprecationWarning)",
            "",
            "    etree_xml = parse_xml_string(xml_string)",
            "    package_dir, package_filename = os.path.split(__file__)",
            "    schema_file = os.path.join(package_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema_11.xsd\")",
            "    taxii_schema_doc = parse(schema_file, allow_file=True)",
            "    xml_schema = etree.XMLSchema(taxii_schema_doc)",
            "    valid = xml_schema.validate(etree_xml)",
            "    # TODO: Additionally, validate the Query stuff",
            "    if not valid:",
            "        return xml_schema.error_log.last_error",
            "    return valid",
            "",
            "",
            "def get_message_from_xml(xml_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from an XML string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the XML.",
            "",
            "    Args:",
            "        xml_string (str): The XML to parse into a TAXII message.",
            "        encoding (str): The encoding of the string; defaults to UTF-8",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_xml = message.to_xml()",
            "            new_message = tm11.get_message_from_xml(message_xml)",
            "    \"\"\"",
            "    if isinstance(xml_string, six.binary_type):",
            "        xml_string = xml_string.decode(encoding, 'replace')",
            "    etree_xml = parse_xml_string(xml_string)",
            "    qn = etree.QName(etree_xml)",
            "    if qn.namespace != ns_map['taxii_11']:",
            "        raise ValueError('Unsupported namespace: %s' % qn.namespace)",
            "",
            "    message_type = qn.localname",
            "",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_etree(etree_xml)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_etree(etree_xml)",
            "    if message_type == MSG_COLLECTION_INFORMATION_REQUEST:",
            "        return CollectionInformationRequest.from_etree(etree_xml)",
            "    if message_type == MSG_COLLECTION_INFORMATION_RESPONSE:",
            "        return CollectionInformationResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_etree(etree_xml)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_etree(etree_xml)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST:",
            "        return ManageCollectionSubscriptionRequest.from_etree(etree_xml)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE:",
            "        return ManageCollectionSubscriptionResponse.from_etree(etree_xml)",
            "    if message_type == MSG_POLL_FULFILLMENT_REQUEST:",
            "        return PollFulfillmentRequest.from_etree(etree_xml)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_dict(d):",
            "    \"\"\"Create a TAXIIMessage object from a dictonary.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the 'message_type' key in the dictionary.",
            "",
            "    Args:",
            "        d (dict): The dictionary to build the TAXII message from.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            message_dict = message.to_dict()",
            "            new_message = tm11.get_message_from_dict(message_dict)",
            "    \"\"\"",
            "    if 'message_type' not in d:",
            "        raise ValueError('message_type is a required field!')",
            "",
            "    message_type = d['message_type']",
            "    if message_type == MSG_DISCOVERY_REQUEST:",
            "        return DiscoveryRequest.from_dict(d)",
            "    if message_type == MSG_DISCOVERY_RESPONSE:",
            "        return DiscoveryResponse.from_dict(d)",
            "    if message_type == MSG_COLLECTION_INFORMATION_REQUEST:",
            "        return CollectionInformationRequest.from_dict(d)",
            "    if message_type == MSG_COLLECTION_INFORMATION_RESPONSE:",
            "        return CollectionInformationResponse.from_dict(d)",
            "    if message_type == MSG_POLL_REQUEST:",
            "        return PollRequest.from_dict(d)",
            "    if message_type == MSG_POLL_RESPONSE:",
            "        return PollResponse.from_dict(d)",
            "    if message_type == MSG_STATUS_MESSAGE:",
            "        return StatusMessage.from_dict(d)",
            "    if message_type == MSG_INBOX_MESSAGE:",
            "        return InboxMessage.from_dict(d)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST:",
            "        return ManageCollectionSubscriptionRequest.from_dict(d)",
            "    if message_type == MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE:",
            "        return ManageCollectionSubscriptionResponse.from_dict(d)",
            "    if message_type == MSG_POLL_FULFILLMENT_REQUEST:",
            "        return PollFulfillmentRequest.from_dict(d)",
            "",
            "    raise ValueError('Unknown message_type: %s' % message_type)",
            "",
            "",
            "def get_message_from_json(json_string, encoding='utf_8'):",
            "    \"\"\"Create a TAXIIMessage object from a JSON string.",
            "",
            "    This function automatically detects which type of Message should be created",
            "    based on the JSON.",
            "",
            "    Args:",
            "        json_string (str): The JSON to parse into a TAXII message.",
            "    \"\"\"",
            "    decoded_string = json_string.decode(encoding, 'replace')",
            "    return get_message_from_dict(json.loads(decoded_string))",
            "",
            "",
            "def _sanitize_content_binding(binding):",
            "    \"\"\"",
            "    Takes in one of:",
            "    1. ContentBinding object",
            "    2. string",
            "    3. dict",
            "    and returns a ContentBinding object.",
            "",
            "    This supports function calls where a string or ContentBinding can be",
            "    used to specify a content binding.",
            "    \"\"\"",
            "    if isinstance(binding, ContentBinding):  # It's already good to go",
            "        return binding",
            "    elif isinstance(binding, six.string_types):  # Convert it to a ContentBinding",
            "        return ContentBinding.from_string(binding)",
            "    elif isinstance(binding, dict):  # Convert it to a ContentBinding",
            "        return ContentBinding.from_dict(binding)",
            "    else:  # Don't know what to do with it.",
            "        raise ValueError('Type cannot be converted to ContentBinding: %s' % binding.__class__.__name__)",
            "",
            "",
            "def _sanitize_content_bindings(binding_list):",
            "    bindings = []",
            "    for item in binding_list:",
            "        bindings.append(_sanitize_content_binding(item))",
            "",
            "    return bindings",
            "",
            "",
            "class UnsupportedQueryException(Exception):",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "",
            "    def __str__(self):",
            "        return repr(self.value)",
            "",
            "",
            "# Start with the 'default' deserializer",
            "query_deserializers = {}",
            "",
            "",
            "def register_query_format(format_id, query, query_info, schema=None):",
            "    \"\"\"",
            "    This function registers a query format with libtaxii.messages_11.",
            "    Arguments:",
            "        format_id (string) - The format ID of the query",
            "        query (messages_11.Query subclass) - the Query object associated with the format_id",
            "        query_info (messages_11.SupportedQuery subclass) - the SupportedQuery object associated with the format_id",
            "        schema (xml schema) - The XML schema for validating the query",
            "    \"\"\"",
            "    query_deserializers[format_id] = {'query': query, 'query_info': query_info, 'schema': schema}",
            "",
            "",
            "def get_deserializer(format_id, type):",
            "    do_check(type, 'type', value_tuple=('query', 'query_info'))",
            "",
            "    if format_id not in query_deserializers:",
            "        raise UnsupportedQueryException('A deserializer for the query format \\'%s\\' is not registered.' % format_id)",
            "",
            "    return query_deserializers[format_id][type]",
            "",
            "# TODO: Consider using this",
            "# def _create_element(name, namespace=ns_map['taxii_11'], value=None, attrs=None, parent=None):",
            "    # \"\"\"",
            "    # Helper method for appending a new element to an existing element.",
            "",
            "    # Assumes the namespace is TAXII 1.1",
            "",
            "    # Arguments:",
            "    #     name (string) - The name of the element",
            "    #     namespace (string) - The namespace of the element",
            "    #     value (string) - The text value of the element",
            "    #     attrs (dict) - A dictionary of attributes",
            "    #     parent (Element) - The parent element",
            "    # \"\"\"",
            "    # if value is None and attrs is None:",
            "    #     return",
            "",
            "    # if parent is None:",
            "    #     elt = etree.Element('{%s}%s' % (namespace, name), nsmap=ns_map)",
            "    # else:",
            "    #     elt = etree.SubElement(parent, '{%s}%s' % (namespace, name), nsmap=ns_map)",
            "",
            "    # if value is not None:",
            "    #     elt.text = value",
            "",
            "    # if attrs is not None:",
            "    #     for k, v in attrs.items():",
            "    #         elt.attrib[k] = v",
            "",
            "    # return elt",
            "",
            "",
            "class TAXIIBase11(TAXIIBase):",
            "    version = VID_TAXII_XML_11",
            "",
            "",
            "class SupportedQuery(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    This class contains an instance of a supported query. It",
            "    is expected that, generally, messages_11.SupportedQuery",
            "    subclasses will be used in place of this class",
            "    to represent a query",
            "    \"\"\"",
            "",
            "    def __init__(self, format_id):",
            "        \"\"\"",
            "        Arguments:",
            "            format_id (string) - The format_id of this supported query",
            "        \"\"\"",
            "        self.format_id = format_id",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.format_id",
            "",
            "    @property",
            "    def format_id(self):",
            "        return self._format_id",
            "",
            "    @format_id.setter",
            "    def format_id(self, value):",
            "        do_check(value, 'format_id', regex_tuple=uri_regex)",
            "        self._format_id = value",
            "",
            "    def to_etree(self):",
            "        q = etree.Element('{%s}Supported_Query' % ns_map['taxii_11'], nsmap=ns_map)",
            "        q.attrib['format_id'] = self.format_id",
            "        return q",
            "",
            "    def to_dict(self):",
            "        return {'format_id': self.format_id}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Supported Query Information ===\\n\"",
            "        s += line_prepend + \"  Query Format: %s\\n\" % self.format_id",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        format_id = get_required(etree_xml, './@format_id', ns_map)",
            "        return SupportedQuery(format_id)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return SupportedQuery(**d)",
            "",
            "",
            "class Query(TAXIIBase11):",
            "",
            "    \"\"\"This class contains an instance of a query.",
            "",
            "    It is expected that, generally, messages_11.Query subclasses will be used",
            "    in place of this class to represent a query.",
            "    \"\"\"",
            "",
            "    def __init__(self, format_id):",
            "        \"\"\"",
            "        Arguments:",
            "            format_id (string) - The format_id of this query",
            "        \"\"\"",
            "        self.format_id = format_id",
            "",
            "    @property",
            "    def format_id(self):",
            "        return self._format_id",
            "",
            "    @format_id.setter",
            "    def format_id(self, value):",
            "        do_check(value, 'format_id', regex_tuple=uri_regex)",
            "        self._format_id = value",
            "",
            "    def to_etree(self):",
            "        q = etree.Element('{%s}Query' % ns_map['taxii_11'], nsmap=ns_map)",
            "        q.attrib['format_id'] = self.format_id",
            "        return q",
            "",
            "    def to_dict(self):",
            "        return {'format_id': self.format_id}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Query ===\\n\"",
            "        s += line_prepend + \"  Query Format: %s\\n\" % self.format_id",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml, kwargs):",
            "        format_id = get_required(etree_xml, './@format_id', ns_map)",
            "        return cls(format_id, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, kwargs):",
            "        return cls(d, **kwargs)",
            "",
            "",
            "# A value can be one of:",
            "# - a dictionary, where each key is a content_binding_id and each value is a list of subtypes",
            "#   (This is the default representation)",
            "# - a \"content_binding_id[>subtype]\" structure",
            "# - a list of \"content_binding_id[>subtype]\" structures",
            "",
            "",
            "class ContentBinding(TAXIIBase11):",
            "",
            "    \"\"\"TAXII Content Binding component",
            "",
            "    Args:",
            "        binding_id (str): The content binding ID. **Required**",
            "        subtype_ids (list of str): the subtype IDs. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, binding_id, subtype_ids=None):",
            "        self.binding_id = binding_id",
            "        self.subtype_ids = subtype_ids or []",
            "",
            "    def __str__(self):",
            "        s = self.binding_id",
            "        if len(self.subtype_ids) > 0:",
            "            s += '>' + ','.join(self.subtype_ids)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_string(s):",
            "        if '>' not in s:",
            "            return ContentBinding(s)",
            "",
            "        parts = s.split('>')",
            "        binding_id = parts[0]",
            "        subtype_ids = parts[1].split(',')",
            "        return ContentBinding(binding_id, subtype_ids)",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return str(self)",
            "",
            "    @property",
            "    def binding_id(self):",
            "        return self._binding_id",
            "",
            "    @binding_id.setter",
            "    def binding_id(self, value):",
            "        do_check(value, 'binding_id', regex_tuple=uri_regex)",
            "        self._binding_id = value",
            "",
            "    @property",
            "    def subtype_ids(self):",
            "        return self._subtype_ids",
            "",
            "    @subtype_ids.setter",
            "    def subtype_ids(self, value):",
            "        do_check(value, 'subtype_ids', regex_tuple=uri_regex)",
            "        self._subtype_ids = value",
            "",
            "    def to_etree(self):",
            "        cb = etree.Element('{%s}Content_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        cb.attrib['binding_id'] = self.binding_id",
            "        for subtype_id in self.subtype_ids:",
            "            s = etree.SubElement(cb, '{%s}Subtype' % ns_map['taxii_11'], nsmap=ns_map)",
            "            s.attrib['subtype_id'] = subtype_id",
            "        return cb",
            "",
            "    def to_dict(self):",
            "        return {'binding_id': self.binding_id, 'subtype_ids': self.subtype_ids}",
            "",
            "    def to_text(self, line_prepend=''):",
            "        return line_prepend + str(self)",
            "",
            "    def __hash__(self):",
            "        return hash(str(self.to_dict()))",
            "",
            "    @classmethod",
            "    def from_etree(self, etree_xml):",
            "        binding_id = etree_xml.attrib['binding_id']",
            "        subtype_ids = []",
            "        subtype_elts = etree_xml.xpath('./taxii_11:Subtype', namespaces=ns_map)",
            "        for elt in subtype_elts:",
            "            subtype_ids.append(elt.attrib['subtype_id'])",
            "        return ContentBinding(binding_id, subtype_ids)",
            "",
            "    @classmethod",
            "    def from_dict(self, d):",
            "        return ContentBinding(**d)",
            "",
            "",
            "class RecordCount(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    Information summarizing the number of records.",
            "",
            "    Args:",
            "        record_count (int): The number of records",
            "        partial_count (bool): Whether the number of records is a partial count",
            "    \"\"\"",
            "",
            "    def __init__(self, record_count, partial_count=False):",
            "        self.record_count = record_count",
            "        self.partial_count = partial_count",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=int)",
            "        self._record_count = value",
            "",
            "    @property",
            "    def partial_count(self):",
            "        return self._partial_count",
            "",
            "    @partial_count.setter",
            "    def partial_count(self, value):",
            "        do_check(value, 'partial_count', value_tuple=(True, False), can_be_none=True)",
            "        self._partial_count = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Record_Count' % ns_map['taxii_11'], nsmap=ns_map)",
            "        xml.text = str(self.record_count)",
            "",
            "        if self.partial_count is not None:",
            "            xml.attrib['partial_count'] = str(self.partial_count).lower()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['record_count'] = self.record_count",
            "        if self.partial_count is not None:",
            "            d['partial_count'] = self.partial_count",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Record Count ===\\n\"",
            "        s += line_prepend + \"  Record Count: %s\\n\" % self.record_count",
            "        if self.partial_count:",
            "            s += line_prepend + \"  Partial Count: %s\\n\" % self.partial_count",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        record_count = int(etree_xml.text)",
            "        partial_count = etree_xml.attrib.get('partial_count', 'false') == 'true'",
            "",
            "        return RecordCount(record_count, partial_count)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return RecordCount(**d)",
            "",
            "",
            "class _GenericParameters(TAXIIBase11):",
            "    name = 'Generic_Parameters'",
            "",
            "    def __init__(self, response_type=RT_FULL, content_bindings=None, query=None):",
            "        self.response_type = response_type",
            "        self.content_bindings = content_bindings or []",
            "        self.query = query",
            "",
            "    @property",
            "    def response_type(self):",
            "        return self._response_type",
            "",
            "    @response_type.setter",
            "    def response_type(self, value):",
            "        do_check(value, 'response_type', value_tuple=(RT_FULL, RT_COUNT_ONLY), can_be_none=True)",
            "        self._response_type = value",
            "",
            "    @property",
            "    def content_bindings(self):",
            "        return self._content_bindings",
            "",
            "    @content_bindings.setter",
            "    def content_bindings(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'content_bindings', type=ContentBinding)",
            "        self._content_bindings = value",
            "",
            "    @property",
            "    def query(self):",
            "        return self._query",
            "",
            "    @query.setter",
            "    def query(self, value):",
            "        # TODO: Can i do more validation?",
            "        do_check(value, 'query', type=Query, can_be_none=True)",
            "        self._query = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.name), nsmap=ns_map)",
            "        if self.response_type is not None:",
            "            rt = etree.SubElement(xml, '{%s}Response_Type' % ns_map['taxii_11'], nsmap=ns_map)",
            "            rt.text = self.response_type",
            "",
            "        for binding in self.content_bindings:",
            "            xml.append(binding.to_etree())",
            "",
            "        if self.query is not None:",
            "            xml.append(self.query.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        if self.response_type is not None:",
            "            d['response_type'] = self.response_type",
            "",
            "        d['content_bindings'] = []",
            "        for binding in self.content_bindings:",
            "            d['content_bindings'].append(binding.to_dict())",
            "",
            "        d['query'] = None",
            "        if self.query is not None:",
            "            d['query'] = self.query.to_dict()",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== %s ===\\n\" % self.name",
            "        for binding in self.content_bindings:",
            "            s += \"  Content Binding: %s\\n\" % str(binding)",
            "",
            "        if self.query:",
            "            s += self.query.to_text(line_prepend + STD_INDENT)",
            "",
            "        if self.response_type:",
            "            s += line_prepend + \"  Response type: %s\\n\" % str(self.response_type)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml, **kwargs):",
            "",
            "        response_type = get_optional_text(etree_xml, './taxii_11:Response_Type', ns_map)",
            "        if response_type is None:",
            "            response_type = RT_FULL",
            "",
            "        content_bindings = []",
            "        for binding in etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map):",
            "            content_bindings.append(ContentBinding.from_etree(binding))",
            "",
            "        query = None",
            "        query_el = get_optional(etree_xml, './taxii_11:Query', ns_map)",
            "        if query_el is not None:",
            "            format_id = query_el.attrib['format_id']",
            "            query = get_deserializer(format_id, 'query').from_etree(query_el)",
            "",
            "        return cls(response_type, content_bindings, query, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        response_type = d.get('response_type', RT_FULL)",
            "        content_bindings = []",
            "        for binding in d['content_bindings']:",
            "            content_bindings.append(ContentBinding.from_dict(binding))",
            "",
            "        query = None",
            "        if 'query' in d and d['query'] is not None:",
            "            format_id = d['query']['format_id']",
            "            query = get_deserializer(format_id, 'query').from_dict(d['query'])",
            "",
            "        return cls(response_type, content_bindings, query, **kwargs)",
            "",
            "",
            "class SubscriptionParameters(_GenericParameters):",
            "",
            "    \"\"\"",
            "    TAXII Subscription Parameters.",
            "",
            "    Args:",
            "        response_type (str): The requested response type. Must be either",
            "            :py:data:`RT_FULL` or :py:data:`RT_COUNT_ONLY`. **Optional**,",
            "            defaults to :py:data:`RT_FULL`",
            "        content_bindings (list of ContentBinding objects): A list of Content",
            "            Bindings acceptable in response. **Optional**",
            "        query (Query): The query for this poll parameters. **Optional**",
            "    \"\"\"",
            "    name = 'Subscription_Parameters'",
            "",
            "",
            "class ContentBlock(TAXIIBase11):",
            "",
            "    \"\"\"A TAXII Content Block.",
            "",
            "    Args:",
            "        content_binding (ContentBinding): a Content Binding ID or nesting expression",
            "            indicating the type of content contained in the Content field of this",
            "            Content Block. **Required**",
            "        content (string or etree): a piece of content of the type specified",
            "            by the Content Binding. **Required**",
            "        timestamp_label (datetime): the Timestamp Label associated with this",
            "            Content Block. **Optional**",
            "        padding (string): an arbitrary amount of padding for this Content",
            "            Block. **Optional**",
            "        message (string): a message associated with this ContentBlock. **Optional**",
            "    \"\"\"",
            "    NAME = 'Content_Block'",
            "",
            "    def __init__(self, content_binding, content, timestamp_label=None,",
            "                 padding=None, message=None):",
            "        self.content_binding = content_binding",
            "        self.content = content",
            "        self.timestamp_label = timestamp_label",
            "        self.message = message",
            "        self.padding = padding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.content[:25]",
            "",
            "    @property",
            "    def content_binding(self):",
            "        return self._content_binding",
            "",
            "    @content_binding.setter",
            "    def content_binding(self, value):",
            "        value = _sanitize_content_binding(value)",
            "        do_check(value, 'content_binding', type=ContentBinding)",
            "        self._content_binding = value",
            "",
            "    @property",
            "    def content(self):",
            "        if self.content_is_xml:",
            "            return etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            return self._content",
            "",
            "    @content.setter",
            "    def content(self, value):",
            "        do_check(value, 'content')  # Just check for not None",
            "        self._content, self.content_is_xml = stringify_content(value)",
            "",
            "    @property",
            "    def content_is_xml(self):",
            "        return self._content_is_xml",
            "",
            "    @content_is_xml.setter",
            "    def content_is_xml(self, value):",
            "        do_check(value, 'content_is_xml', value_tuple=(True, False))",
            "        self._content_is_xml = value",
            "",
            "    @property",
            "    def timestamp_label(self):",
            "        return self._timestamp_label",
            "",
            "    @timestamp_label.setter",
            "    def timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'timestamp_label', can_be_none=True)",
            "        self._timestamp_label = value",
            "",
            "    @property",
            "    def message(self):",
            "        return self._message",
            "",
            "    @message.setter",
            "    def message(self, value):",
            "        do_check(value, 'message', type=six.string_types, can_be_none=True)",
            "        self._message = value",
            "",
            "    def to_etree(self):",
            "        block = etree.Element('{%s}Content_Block' % ns_map['taxii_11'], nsmap=ns_map)",
            "        block.append(self.content_binding.to_etree())",
            "        c = etree.SubElement(block, '{%s}Content' % ns_map['taxii_11'])",
            "",
            "        if self.content_is_xml:",
            "            c.append(self._content)",
            "        else:",
            "            c.text = self._content",
            "",
            "        if self.timestamp_label is not None:",
            "            tl = etree.SubElement(block, '{%s}Timestamp_Label' % ns_map['taxii_11'])",
            "            tl.text = self.timestamp_label.isoformat()",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(block, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        if self.padding is not None:",
            "            p = etree.SubElement(block, '{%s}Padding' % ns_map['taxii_11'])",
            "            p.text = self.padding",
            "",
            "        return block",
            "",
            "    def to_dict(self):",
            "        block = {}",
            "        block['content_binding'] = self.content_binding.to_dict()",
            "",
            "        if self.content_is_xml:",
            "            block['content'] = etree.tostring(self._content, encoding='utf-8')",
            "        else:",
            "            block['content'] = self._content",
            "        block['content_is_xml'] = self.content_is_xml",
            "",
            "        if self.timestamp_label is not None:",
            "            block['timestamp_label'] = self.timestamp_label.isoformat()",
            "",
            "        if self.message is not None:",
            "            block['message'] = self.message",
            "",
            "        if self.padding is not None:",
            "            block['padding'] = self.padding",
            "",
            "        return block",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Content Block ===\\n\"",
            "        s += line_prepend + \"  Content Binding: %s\\n\" % str(self.content_binding)",
            "        s += line_prepend + \"  Content length: %s\\n\" % len(self.content)",
            "        s += line_prepend + \"  (Content not printed for brevity)\\n\"",
            "        if self.timestamp_label:",
            "            s += line_prepend + \"  Timestamp Label: %s\\n\" % self.timestamp_label",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        s += line_prepend + \"  Padding: %s\\n\" % self.padding",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['content_binding'] = ContentBinding.from_etree(",
            "                get_required(etree_xml, './taxii_11:Content_Binding', ns_map))",
            "",
            "        kwargs['padding'] = get_optional_text(etree_xml, './taxii_11:Padding', ns_map)",
            "",
            "        ts_text = get_optional_text(etree_xml, './taxii_11:Timestamp_Label', ns_map)",
            "        if ts_text:",
            "            kwargs['timestamp_label'] = parse_datetime_string(ts_text)",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        content = get_required(etree_xml, './taxii_11:Content', ns_map)",
            "        if len(content) == 0:  # This has string content",
            "            kwargs['content'] = content.text",
            "        else:  # This has XML content",
            "            kwargs['content'] = content[0]",
            "",
            "        return ContentBlock(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['content_binding'] = ContentBinding.from_dict(d['content_binding'])",
            "        kwargs['padding'] = d.get('padding')",
            "        if 'timestamp_label' in d:",
            "            kwargs['timestamp_label'] = parse_datetime_string(d['timestamp_label'])",
            "        kwargs['message'] = d.get('message')",
            "        is_xml = d.get('content_is_xml', False)",
            "        if is_xml:",
            "            kwargs['content'] = parse(d['content'], allow_file=False)",
            "        else:",
            "            kwargs['content'] = d['content']",
            "",
            "        cb = ContentBlock(**kwargs)",
            "        return cb",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class PushParameters(TAXIIBase11):",
            "",
            "    \"\"\"Set up Push Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Collection content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Collection to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "    \"\"\"",
            "",
            "    name = 'Push_Parameters'",
            "",
            "    def __init__(self, inbox_protocol, inbox_address, delivery_message_binding):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.delivery_message_binding = delivery_message_binding",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def delivery_message_binding(self):",
            "        return self._delivery_message_binding",
            "",
            "    @delivery_message_binding.setter",
            "    def delivery_message_binding(self, value):",
            "        do_check(value, 'delivery_message_binding', regex_tuple=uri_regex)",
            "        self._delivery_message_binding = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.name))",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.inbox_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.inbox_address",
            "",
            "        mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "        mb.text = self.delivery_message_binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        if self.inbox_protocol is not None:",
            "            d['inbox_protocol'] = self.inbox_protocol",
            "",
            "        if self.inbox_address is not None:",
            "            d['inbox_address'] = self.inbox_address",
            "",
            "        if self.delivery_message_binding is not None:",
            "            d['delivery_message_binding'] = self.delivery_message_binding",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Parameters ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Inbox Address: %s\\n\" % self.inbox_address",
            "        s += line_prepend + \"  Message Binding: %s\\n\" % self.delivery_message_binding",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        inbox_protocol = get_optional_text(etree_xml, './taxii_11:Protocol_Binding', ns_map)",
            "        inbox_address = get_optional_text(etree_xml, './taxii_11:Address', ns_map)",
            "        delivery_message_binding = get_optional_text(etree_xml, './taxii_11:Message_Binding', ns_map)",
            "",
            "        return cls(inbox_protocol, inbox_address, delivery_message_binding)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "# TODO: Check docstring",
            "class DeliveryParameters(PushParameters):",
            "",
            "    \"\"\"Set up Delivery Parameters.",
            "",
            "    Args:",
            "        inbox_protocol (str): identifies the protocol to be used when pushing",
            "            TAXII Data Collection content to a Consumer's TAXII Inbox Service",
            "            implementation. **Required**",
            "        inbox_address (str): identifies the address of the TAXII Daemon hosting",
            "            the Inbox Service to which the Consumer requests content for this",
            "            TAXII Data Collection to be delivered. **Required**",
            "        delivery_message_binding (str): identifies the message binding to be",
            "             used to send pushed content for this subscription. **Required**",
            "    \"\"\"",
            "",
            "    name = 'Delivery_Parameters'",
            "",
            "",
            "class TAXIIMessage(TAXIIBase11):",
            "",
            "    \"\"\"Encapsulate properties common to all TAXII Messages (such as headers).",
            "",
            "    This class is extended by each Message Type (e.g., DiscoveryRequest), with",
            "    each subclass containing subclass-specific information",
            "    \"\"\"",
            "",
            "    message_type = 'TAXIIMessage'",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None):",
            "        \"\"\"Create a new TAXIIMessage",
            "",
            "        Args:",
            "            message_id (str): A value identifying this message.",
            "            in_response_to (str): Contains the Message ID of the message to",
            "                which this is a response.",
            "            extended_headers (dict): A dictionary of name/value pairs for",
            "                use as Extended Headers",
            "        \"\"\"",
            "        self.message_id = message_id",
            "        self.in_response_to = in_response_to",
            "        self.extended_headers = extended_headers or {}",
            "",
            "    @property",
            "    def message_id(self):",
            "        return self._message_id",
            "",
            "    @message_id.setter",
            "    def message_id(self, value):",
            "        do_check(value, 'message_id', regex_tuple=uri_regex)",
            "        self._message_id = value",
            "",
            "    @property",
            "    def in_response_to(self):",
            "        return self._in_response_to",
            "",
            "    @in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def extended_headers(self):",
            "        return self._extended_headers",
            "",
            "    @extended_headers.setter",
            "    def extended_headers(self, value):",
            "        do_check(list(value.keys()), 'extended_headers.keys()', regex_tuple=uri_regex)",
            "        self._extended_headers = value",
            "",
            "    def to_etree(self):",
            "        \"\"\"Creates the base etree for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to XML, subclasses should call this method",
            "        first, then create their specific XML constructs.",
            "        \"\"\"",
            "        root_elt = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.message_type), nsmap=ns_map)",
            "        root_elt.attrib['message_id'] = str(self.message_id)",
            "",
            "        if self.in_response_to is not None:",
            "            root_elt.attrib['in_response_to'] = str(self.in_response_to)",
            "",
            "        if len(self.extended_headers) > 0:",
            "            eh = etree.SubElement(root_elt, '{%s}Extended_Headers' % ns_map['taxii_11'], nsmap=ns_map)",
            "",
            "            for name, value in list(self.extended_headers.items()):",
            "                h = etree.SubElement(eh, '{%s}Extended_Header' % ns_map['taxii_11'], nsmap=ns_map)",
            "                h.attrib['name'] = name",
            "                append_any_content_etree(h, value)",
            "                # h.text = value",
            "        return root_elt",
            "",
            "    def to_dict(self):",
            "        \"\"\"Create the base dictionary for the TAXII Message.",
            "",
            "        Message-specific constructs must be added by each Message class. In",
            "        general, when converting to dictionary, subclasses should call this",
            "        method first, then create their specific dictionary constructs.",
            "        \"\"\"",
            "        d = {}",
            "        d['message_type'] = self.message_type",
            "        d['message_id'] = self.message_id",
            "        if self.in_response_to is not None:",
            "            d['in_response_to'] = self.in_response_to",
            "        d['extended_headers'] = {}",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            if isinstance(v, etree._Element) or isinstance(v, etree._ElementTree):",
            "                v = etree.tostring(v, encoding='utf-8')",
            "            elif not isinstance(v, six.string_types):",
            "                v = str(v)",
            "            d['extended_headers'][k] = v",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"Message Type: %s\\n\" % self.message_type",
            "        s += line_prepend + \"Message ID: %s\" % self.message_id",
            "        if self.in_response_to:",
            "            s += \"; In Response To: %s\" % self.in_response_to",
            "        s += \"\\n\"",
            "        for k, v in six.iteritems(self.extended_headers):",
            "            s += line_prepend + \"Extended Header: %s = %s\\n\" % (k, v)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, src_etree, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from an etree.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from etree, subclasses should call this method",
            "        first, then parse their specific XML constructs.",
            "        \"\"\"",
            "",
            "        # Check namespace and element name of the root element",
            "        expected_tag = '{%s}%s' % (ns_map['taxii_11'], cls.message_type)",
            "        tag = src_etree.tag",
            "        if tag != expected_tag:",
            "            raise ValueError('%s != %s' % (tag, expected_tag))",
            "",
            "        # Get the message ID",
            "        message_id = get_required(src_etree, '/taxii_11:*/@message_id', ns_map)",
            "",
            "        # Get in response to, if present",
            "        in_response_to = get_optional(src_etree, '/taxii_11:*/@in_response_to', ns_map)",
            "        if in_response_to is not None:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        # Get the Extended headers",
            "        extended_header_list = src_etree.xpath('/taxii_11:*/taxii_11:Extended_Headers/taxii_11:Extended_Header', namespaces=ns_map)",
            "        extended_headers = {}",
            "        for header in extended_header_list:",
            "            eh_name = header.xpath('./@name')[0]",
            "            if len(header) == 0:  # This has string content",
            "                eh_value = header.text",
            "            else:  # This has XML content",
            "                eh_value = header[0]",
            "",
            "            extended_headers[eh_name] = eh_value",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "",
            "    @classmethod",
            "    def from_dict(cls, d, **kwargs):",
            "        \"\"\"Pulls properties of a TAXII Message from a dictionary.",
            "",
            "        Message-specific constructs must be pulled by each Message class. In",
            "        general, when converting from dictionary, subclasses should call this",
            "        method first, then parse their specific dictionary constructs.",
            "        \"\"\"",
            "        message_type = d['message_type']",
            "        if message_type != cls.message_type:",
            "            raise ValueError('%s != %s' % (message_type, cls.message_type))",
            "        message_id = d['message_id']",
            "        extended_headers = {}",
            "        for k, v in six.iteritems(d['extended_headers']):",
            "            try:",
            "                v = parse(v, allow_file=False)",
            "            except etree.XMLSyntaxError:",
            "                pass",
            "            extended_headers[k] = v",
            "",
            "        in_response_to = d.get('in_response_to')",
            "        if in_response_to:",
            "            kwargs['in_response_to'] = in_response_to",
            "",
            "        return cls(message_id, extended_headers=extended_headers, **kwargs)",
            "",
            "    @classmethod",
            "    def from_json(cls, json_string):",
            "        return cls.from_dict(json.loads(json_string))",
            "",
            "",
            "class TAXIIRequestMessage(TAXIIMessage):",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "",
            "class DiscoveryRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_REQUEST",
            "",
            "",
            "class DiscoveryResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Discovery Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        service_instances (list of `ServiceInstance`): a list of",
            "            service instances that this response contains. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_DISCOVERY_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, service_instances=None):",
            "        super(DiscoveryResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.service_instances = service_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def service_instances(self):",
            "        return self._service_instances",
            "",
            "    @service_instances.setter",
            "    def service_instances(self, value):",
            "        do_check(value, 'service_instances', type=ServiceInstance)",
            "        self._service_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(DiscoveryResponse, self).to_etree()",
            "        for service_instance in self.service_instances:",
            "            xml.append(service_instance.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(DiscoveryResponse, self).to_dict()",
            "        d['service_instances'] = []",
            "        for service_instance in self.service_instances:",
            "            d['service_instances'].append(service_instance.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(DiscoveryResponse, self).to_text()",
            "        for si in self.service_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['service_instances'] = []",
            "        service_instance_set = etree_xml.xpath('./taxii_11:Service_Instance', namespaces=ns_map)",
            "        for service_instance in service_instance_set:",
            "            si = ServiceInstance.from_etree(service_instance)",
            "            kwargs['service_instances'].append(si)",
            "",
            "        return super(DiscoveryResponse, cls).from_etree(etree_xml, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(DiscoveryResponse, cls).from_dict(d)",
            "        msg.service_instances = []",
            "        service_instance_set = d['service_instances']",
            "        for service_instance in service_instance_set:",
            "            si = ServiceInstance.from_dict(service_instance)",
            "            msg.service_instances.append(si)",
            "        return msg",
            "",
            "",
            "class ServiceInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Service Instance component of a TAXII Discovery Response Message.",
            "",
            "    Args:",
            "        service_type (string): identifies the Service Type of this",
            "            Service Instance. **Required**",
            "        services_version (string): identifies the TAXII Services",
            "            Specification to which this Service conforms. **Required**",
            "        protocol_binding (string): identifies the protocol binding",
            "            supported by this Service. **Required**",
            "        service_address (string): identifies the network address of the",
            "            TAXII Daemon that hosts this Service. **Required**",
            "        message_bindings (list of strings): identifies the message",
            "            bindings supported by this Service instance. **Required**",
            "        inbox_service_accepted_content (list of ContentBinding objects): identifies",
            "            content bindings that this Inbox Service is willing to accept.",
            "            **Optional**",
            "        available (boolean): indicates whether the identity of the",
            "            requester (authenticated or otherwise) is allowed to access this",
            "            TAXII Service. **Optional**",
            "        message (string): contains a message regarding this Service",
            "            instance. **Optional**",
            "        supported_query (SupportedQuery): contains a structure indicating a",
            "            supported query. **Optional**",
            "",
            "    The ``message_bindings`` list must contain at least one value. The",
            "    ``supported_query`` parameter is optional when",
            "    ``service_type`` is :py:data:`SVC_POLL`.",
            "    \"\"\"",
            "",
            "    def __init__(self, service_type, services_version, protocol_binding,",
            "                 service_address, message_bindings,",
            "                 inbox_service_accepted_content=None, available=None,",
            "                 message=None, supported_query=None):",
            "        self.service_type = service_type",
            "        self.services_version = services_version",
            "        self.protocol_binding = protocol_binding",
            "        self.service_address = service_address",
            "        self.message_bindings = message_bindings",
            "        self.inbox_service_accepted_content = inbox_service_accepted_content or []",
            "        self.available = available",
            "        self.message = message",
            "        self.supported_query = supported_query or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.service_address",
            "",
            "    @property",
            "    def service_type(self):",
            "        return self._service_type",
            "",
            "    @service_type.setter",
            "    def service_type(self, value):",
            "        do_check(value, 'service_type', value_tuple=SVC_TYPES)",
            "        self._service_type = value",
            "",
            "    @property",
            "    def services_version(self):",
            "        return self._services_version",
            "",
            "    @services_version.setter",
            "    def services_version(self, value):",
            "        do_check(value, 'services_version', regex_tuple=uri_regex)",
            "        self._services_version = value",
            "",
            "    @property",
            "    def protocol_binding(self):",
            "        return self._protocol_binding",
            "",
            "    @protocol_binding.setter",
            "    def protocol_binding(self, value):",
            "        do_check(value, 'protocol_binding', regex_tuple=uri_regex)",
            "        self._protocol_binding = value",
            "",
            "    @property",
            "    def service_address(self):",
            "        return self._service_address",
            "",
            "    @service_address.setter",
            "    def service_address(self, value):",
            "        self._service_address = value",
            "",
            "    @property",
            "    def message_bindings(self):",
            "        return self._message_bindings",
            "",
            "    @message_bindings.setter",
            "    def message_bindings(self, value):",
            "        do_check(value, 'message_bindings', regex_tuple=uri_regex)",
            "        self._message_bindings = value",
            "",
            "    @property",
            "    def supported_query(self):",
            "        return self._supported_query",
            "",
            "    @supported_query.setter",
            "    def supported_query(self, value):",
            "        do_check(value, 'supported_query', type=SupportedQuery)",
            "        self._supported_query = value",
            "",
            "    @property",
            "    def inbox_service_accepted_content(self):",
            "        return self._inbox_service_accepted_content",
            "",
            "    @inbox_service_accepted_content.setter",
            "    def inbox_service_accepted_content(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'inbox_service_accepted_content', type=ContentBinding)",
            "        self._inbox_service_accepted_content = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Service_Instance' % ns_map['taxii_11'], nsmap=ns_map)",
            "        si.attrib['service_type'] = self.service_type",
            "        si.attrib['service_version'] = self.services_version",
            "        if self.available is not None:",
            "            si.attrib['available'] = str(self.available).lower()",
            "",
            "        protocol_binding = etree.SubElement(si, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        protocol_binding.text = self.protocol_binding",
            "",
            "        service_address = etree.SubElement(si, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        service_address.text = self.service_address",
            "",
            "        for mb in self.message_bindings:",
            "            message_binding = etree.SubElement(si, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            message_binding.text = mb",
            "",
            "        for sq in self.supported_query:",
            "            si.append(sq.to_etree())",
            "",
            "        for cb in self.inbox_service_accepted_content:",
            "            content_binding = cb.to_etree()",
            "            si.append(content_binding)",
            "",
            "        if self.message is not None:",
            "            message = etree.SubElement(si, '{%s}Message' % ns_map['taxii_11'], nsmap=ns_map)",
            "            message.text = self.message",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['service_type'] = self.service_type",
            "        d['services_version'] = self.services_version",
            "        d['protocol_binding'] = self.protocol_binding",
            "        d['service_address'] = self.service_address",
            "        d['message_bindings'] = self.message_bindings",
            "        d['supported_query'] = []",
            "        for sq in self.supported_query:",
            "            d['supported_query'].append(sq.to_dict())",
            "        d['inbox_service_accepted_content'] = self.inbox_service_accepted_content",
            "        d['available'] = self.available",
            "        d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Service Instance ===\\n\"",
            "        s += line_prepend + \"  Service Type: %s\\n\" % self.service_type",
            "        s += line_prepend + \"  Service Version: %s\\n\" % self.services_version",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.protocol_binding",
            "        s += line_prepend + \"  Service Address: %s\\n\" % self.service_address",
            "        for mb in self.message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if self.service_type == SVC_INBOX:",
            "            s += line_prepend + \"  Inbox Service AC: %s\\n\" % [ac.to_text() for ac in self.inbox_service_accepted_content]",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for q in self.supported_query:",
            "            s += q.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):  # Expects a taxii_11:Service_Instance element",
            "        service_type = etree_xml.attrib['service_type']",
            "        services_version = etree_xml.attrib['service_version']",
            "        available = None",
            "        if etree_xml.attrib.get('available'):",
            "            tmp_available = etree_xml.attrib['available']",
            "            available = tmp_available == 'true'",
            "",
            "        protocol_binding = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        service_address = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for mb in message_binding_set:",
            "            message_bindings.append(mb.text)",
            "",
            "        inbox_service_accepted_content = []",
            "        inbox_service_accepted_content_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for cb in inbox_service_accepted_content_set:",
            "            inbox_service_accepted_content.append(ContentBinding.from_etree(cb))",
            "",
            "        supported_query = []",
            "        supported_query_set = etree_xml.xpath('./taxii_11:Supported_Query', namespaces=ns_map)",
            "        for sq in supported_query_set:",
            "            format_id = sq.xpath('./@format_id')[0]",
            "            query_obj = get_deserializer(format_id, 'query_info').from_etree(sq)",
            "            supported_query.append(query_obj)",
            "",
            "        message = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        return ServiceInstance(service_type,",
            "                               services_version,",
            "                               protocol_binding,",
            "                               service_address,",
            "                               message_bindings,",
            "                               inbox_service_accepted_content,",
            "                               available,",
            "                               message,",
            "                               supported_query)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        service_type = d['service_type']",
            "        services_version = d['services_version']",
            "        protocol_binding = d['protocol_binding']",
            "        service_address = d['service_address']",
            "        message_bindings = d['message_bindings']",
            "        supported_query = []",
            "        sq_list = d.get('supported_query')",
            "        if sq_list is not None:",
            "            for sq in sq_list:",
            "                format_id = sq['format_id']",
            "                query_obj = get_deserializer(format_id, 'query_info').from_dict(sq)",
            "                supported_query.append(query_obj)",
            "        inbox_service_accepted_content = d.get('inbox_service_accepted_content')",
            "        available = d.get('available')",
            "        message = d.get('message')",
            "",
            "        return ServiceInstance(service_type,",
            "                               services_version,",
            "                               protocol_binding,",
            "                               service_address,",
            "                               message_bindings,",
            "                               inbox_service_accepted_content,",
            "                               available,",
            "                               message,",
            "                               supported_query)",
            "",
            "",
            "class CollectionInformationRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Collection Information Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "    \"\"\"",
            "",
            "    message_type = MSG_COLLECTION_INFORMATION_REQUEST",
            "",
            "",
            "class CollectionInformationResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Collection Information Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_informations (list of CollectionInformation objects): A list",
            "            of CollectionInformation objects to be contained in this response.",
            "            **Optional**",
            "    \"\"\"",
            "    message_type = MSG_COLLECTION_INFORMATION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, collection_informations=None):",
            "        super(CollectionInformationResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.collection_informations = collection_informations or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_informations(self):",
            "        return self._collection_informations",
            "",
            "    @collection_informations.setter",
            "    def collection_informations(self, value):",
            "        do_check(value, 'collection_informations', type=CollectionInformation)",
            "        self._collection_informations = value",
            "",
            "    def to_etree(self):",
            "        xml = super(CollectionInformationResponse, self).to_etree()",
            "        for collection in self.collection_informations:",
            "            xml.append(collection.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(CollectionInformationResponse, self).to_dict()",
            "        d['collection_informations'] = []",
            "        for collection in self.collection_informations:",
            "            d['collection_informations'].append(collection.to_dict())",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(CollectionInformationResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"Contains %s Collection Informations\\n\" % len(self.collection_informations)",
            "        for collection in self.collection_informations:",
            "            s += collection.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        msg = super(CollectionInformationResponse, cls).from_etree(etree_xml)",
            "        msg.collection_informations = []",
            "        collection_informations = etree_xml.xpath('./taxii_11:Collection', namespaces=ns_map)",
            "        for collection in collection_informations:",
            "            msg.collection_informations.append(CollectionInformation.from_etree(collection))",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        msg = super(CollectionInformationResponse, cls).from_dict(d)",
            "        msg.collection_informations = []",
            "        for collection in d['collection_informations']:",
            "            msg.collection_informations.append(CollectionInformation.from_dict(collection))",
            "        return msg",
            "",
            "",
            "class CollectionInformation(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Collection Information component of a TAXII Collection Information",
            "    Response Message.",
            "",
            "    Arguments:",
            "        collection_name (str): the name by which this TAXII Data Collection is",
            "            identified. **Required**",
            "        collection_description (str): a prose description of this TAXII",
            "            Data Collection. **Required**",
            "        supported_contents (list of str): Content Binding IDs",
            "            indicating which types of content are currently expressed in this",
            "            TAXII Data Collection. **Optional**",
            "        available (boolean): whether the identity of the requester",
            "            (authenticated or otherwise) is allowed to access this TAXII",
            "            Service. **Optional** Default: ``None``, indicating \"unknown\"",
            "        push_methods (list of PushMethod objects): the protocols that",
            "            can be used to push content via a subscription. **Optional**",
            "        polling_service_instances (list of PollingServiceInstance objects):",
            "            the bindings and address a Consumer can use to interact with a",
            "            Poll Service instance that supports this TAXII Data Collection.",
            "            **Optional**",
            "        subscription_methods (list of SubscriptionMethod objects): the",
            "            protocol and address of the TAXII Daemon hosting the Collection",
            "            Management Service that can process subscriptions for this TAXII",
            "            Data Collection. **Optional**",
            "        collection_volume (int): the typical number of messages per day.",
            "            **Optional**",
            "        collection_type (str): the type ofo this collection. **Optional**,",
            "            defaults to :py:data:`CT_DATA_FEED`.",
            "        receiving_inbox_services (list of ReceivingInboxService objects):",
            "            TODO: FILL THIS IN. **Optional**",
            "",
            "    If ``supported_contents`` is omitted, then the collection supports all",
            "    content bindings.  The absense of ``push_methods`` indicates no push",
            "    methods.  The absense of ``polling_service_instances`` indicates no",
            "    polling services.  The absense of ``subscription_methods`` indicates no",
            "    subscription services.  The absense of ``receiving_inbox_services``",
            "    indicates no receiving inbox services.",
            "    \"\"\"",
            "",
            "    def __init__(self, collection_name, collection_description,",
            "                 supported_contents=None, available=None, push_methods=None,",
            "                 polling_service_instances=None, subscription_methods=None,",
            "                 collection_volume=None, collection_type=CT_DATA_FEED,",
            "                 receiving_inbox_services=None):",
            "        self.collection_name = collection_name",
            "        self.available = available",
            "        self.collection_description = collection_description",
            "        self.supported_contents = supported_contents or []",
            "        self.push_methods = push_methods or []",
            "        self.polling_service_instances = polling_service_instances or []",
            "        self.subscription_methods = subscription_methods or []",
            "        self.receiving_inbox_services = receiving_inbox_services or []",
            "        self.collection_volume = collection_volume",
            "        self.collection_type = collection_type",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.collection_name",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def available(self):",
            "        return self._available",
            "",
            "    @available.setter",
            "    def available(self, value):",
            "        do_check(value, 'available', value_tuple=(True, False), can_be_none=True)",
            "        self._available = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'supported_contents', type=ContentBinding)",
            "        self._supported_contents = value",
            "",
            "    @property",
            "    def push_methods(self):",
            "        return self._push_methods",
            "",
            "    @push_methods.setter",
            "    def push_methods(self, value):",
            "        do_check(value, 'push_methods', type=PushMethod)",
            "        self._push_methods = value",
            "",
            "    @property",
            "    def polling_service_instances(self):",
            "        return self._polling_service_instances",
            "",
            "    @polling_service_instances.setter",
            "    def polling_service_instances(self, value):",
            "        do_check(value, 'polling_service_instances', type=PollingServiceInstance)",
            "        self._polling_service_instances = value",
            "",
            "    @property",
            "    def subscription_methods(self):",
            "        return self._subscription_methods",
            "",
            "    @subscription_methods.setter",
            "    def subscription_methods(self, value):",
            "        do_check(value, 'subscription_methods', type=SubscriptionMethod)",
            "        self._subscription_methods = value",
            "",
            "    @property",
            "    def receiving_inbox_services(self):",
            "        return self._receiving_inbox_services",
            "",
            "    @receiving_inbox_services.setter",
            "    def receiving_inbox_services(self, value):",
            "        do_check(value, 'receiving_inbox_services', type=ReceivingInboxService)",
            "        self._receiving_inbox_services = value",
            "",
            "    @property",
            "    def collection_volume(self):",
            "        return self._collection_volume",
            "",
            "    @collection_volume.setter",
            "    def collection_volume(self, value):",
            "        do_check(value, 'collection_volume', type=int, can_be_none=True)",
            "        self._collection_volume = value",
            "",
            "    @property",
            "    def collection_type(self):",
            "        return self._collection_type",
            "",
            "    @collection_type.setter",
            "    def collection_type(self, value):",
            "        do_check(value, 'collection_type', value_tuple=CT_TYPES, can_be_none=True)",
            "        self._collection_type = value",
            "",
            "    def to_etree(self):",
            "        c = etree.Element('{%s}Collection' % ns_map['taxii_11'], nsmap=ns_map)",
            "        c.attrib['collection_name'] = self.collection_name",
            "        if self.collection_type is not None:",
            "            c.attrib['collection_type'] = self.collection_type",
            "        if self.available is not None:",
            "            c.attrib['available'] = str(self.available).lower()",
            "        collection_description = etree.SubElement(c, '{%s}Description' % ns_map['taxii_11'], nsmap=ns_map)",
            "        collection_description.text = self.collection_description",
            "",
            "        if self.collection_volume is not None:",
            "            collection_volume = etree.SubElement(c, '{%s}Collection_Volume' % ns_map['taxii_11'], nsmap=ns_map)",
            "            collection_volume.text = str(self.collection_volume)",
            "",
            "        for binding in self.supported_contents:",
            "            c.append(binding.to_etree())",
            "",
            "        for push_method in self.push_methods:",
            "            c.append(push_method.to_etree())",
            "",
            "        for polling_service in self.polling_service_instances:",
            "            c.append(polling_service.to_etree())",
            "",
            "        for subscription_method in self.subscription_methods:",
            "            c.append(subscription_method.to_etree())",
            "",
            "        for receiving_inbox_service in self.receiving_inbox_services:",
            "            c.append(receiving_inbox_service.to_etree())",
            "",
            "        return c",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['collection_name'] = self.collection_name",
            "        if self.collection_type is not None:",
            "            d['collection_type'] = self.collection_type",
            "        if self.available is not None:",
            "            d['available'] = self.available",
            "        d['collection_description'] = self.collection_description",
            "        if self.collection_volume is not None:",
            "            d['collection_volume'] = self.collection_volume",
            "        # TODO: I think this isn't a good serialization, I think a for loop is necessary",
            "        # This is probably a bug",
            "        d['supported_contents'] = self.supported_contents",
            "",
            "        d['push_methods'] = []",
            "        for push_method in self.push_methods:",
            "            d['push_methods'].append(push_method.to_dict())",
            "",
            "        d['polling_service_instances'] = []",
            "        for polling_service in self.polling_service_instances:",
            "            d['polling_service_instances'].append(polling_service.to_dict())",
            "",
            "        d['subscription_methods'] = []",
            "        for subscription_method in self.subscription_methods:",
            "            d['subscription_methods'].append(subscription_method.to_dict())",
            "",
            "        d['receiving_inbox_services'] = []",
            "        for receiving_inbox_service in self.receiving_inbox_services:",
            "            d['receiving_inbox_services'].append(receiving_inbox_service.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Data Collection Information ===\\n\"",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Collection Type: %s\\n\" % (self.collection_type if (None != self.collection_type) else CT_DATA_FEED)",
            "        s += line_prepend + \"  Available: %s\\n\" % self.available",
            "        s += line_prepend + \"  Collection Description: %s\\n\" % self.collection_description",
            "        if self.collection_volume:",
            "            s += line_prepend + \"  Volume: %s\\n\" % self.collection_volume",
            "        if len(self.supported_contents) == 0:  # All contents supported:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % \"All\"",
            "        for contents in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % contents.to_text(line_prepend + STD_INDENT)",
            "        for psi in self.polling_service_instances:",
            "            s += psi.to_text(line_prepend + STD_INDENT)",
            "        for sm in self.subscription_methods:",
            "            s += sm.to_text(line_prepend + STD_INDENT)",
            "        for ris in self.receiving_inbox_services:",
            "            s += ris.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"==================================\\n\\n\"",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "        kwargs['collection_type'] = etree_xml.attrib.get('collection_type', None)",
            "",
            "        kwargs['available'] = None",
            "        if 'available' in etree_xml.attrib:",
            "            tmp = etree_xml.attrib['available']",
            "            kwargs['available'] = tmp.lower() == 'true'",
            "",
            "        kwargs['collection_description'] = get_required(etree_xml, './taxii_11:Description', ns_map).text",
            "",
            "        collection_volume_text = get_optional_text(etree_xml, './taxii_11:Collection_Volume', ns_map)",
            "        if collection_volume_text:",
            "            kwargs['collection_volume'] = int(collection_volume_text)",
            "",
            "        kwargs['supported_contents'] = []",
            "        supported_content_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for binding_elt in supported_content_set:",
            "            kwargs['supported_contents'].append(ContentBinding.from_etree(binding_elt))",
            "",
            "        kwargs['push_methods'] = []",
            "        push_method_set = etree_xml.xpath('./taxii_11:Push_Method', namespaces=ns_map)",
            "        for push_method_elt in push_method_set:",
            "            kwargs['push_methods'].append(PushMethod.from_etree(push_method_elt))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        polling_service_set = etree_xml.xpath('./taxii_11:Polling_Service', namespaces=ns_map)",
            "        for polling_elt in polling_service_set:",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_etree(polling_elt))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        subscription_method_set = etree_xml.xpath('./taxii_11:Subscription_Service', namespaces=ns_map)",
            "        for subscription_elt in subscription_method_set:",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_etree(subscription_elt))",
            "",
            "        kwargs['receiving_inbox_services'] = []",
            "        receiving_inbox_services_set = etree_xml.xpath('./taxii_11:Receiving_Inbox_Service', namespaces=ns_map)",
            "        for receiving_inbox_service in receiving_inbox_services_set:",
            "            kwargs['receiving_inbox_services'].append(ReceivingInboxService.from_etree(receiving_inbox_service))",
            "",
            "        return CollectionInformation(**kwargs)",
            "",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['collection_type'] = d.get('collection_type')",
            "        kwargs['available'] = d.get('available')",
            "        kwargs['collection_description'] = d['collection_description']",
            "        kwargs['collection_volume'] = d.get('collection_volume')",
            "",
            "        kwargs['supported_contents'] = d.get('supported_contents', [])",
            "",
            "        kwargs['push_methods'] = []",
            "        for push_method in d.get('push_methods', []):",
            "            kwargs['push_methods'].append(PushMethod.from_dict(push_method))",
            "",
            "        kwargs['polling_service_instances'] = []",
            "        for polling in d.get('polling_service_instances', []):",
            "            kwargs['polling_service_instances'].append(PollingServiceInstance.from_dict(polling))",
            "",
            "        kwargs['subscription_methods'] = []",
            "        for subscription_method in d.get('subscription_methods', []):",
            "            kwargs['subscription_methods'].append(SubscriptionMethod.from_dict(subscription_method))",
            "",
            "        kwargs['receiving_inbox_services'] = []",
            "        receiving_inbox_services_set = d.get('receiving_inbox_services', [])",
            "        for receiving_inbox_service in receiving_inbox_services_set:",
            "            kwargs['receiving_inbox_services'].append(ReceivingInboxService.from_dict(receiving_inbox_service))",
            "",
            "        return CollectionInformation(**kwargs)",
            "",
            "",
            "class PushMethod(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Push Method component of a TAXII Collection Information",
            "    component.",
            "",
            "    Args:",
            "        push_protocol (str): a protocol binding that can be used",
            "            to push content to an Inbox Service instance. **Required**",
            "        push_message_bindings (list of str): the message bindings that",
            "            can be used to push content to an Inbox Service instance",
            "            using the protocol identified in the Push Protocol field.",
            "            **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, push_protocol, push_message_bindings):",
            "        self.push_protocol = push_protocol",
            "        self.push_message_bindings = push_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.push_protocol",
            "",
            "    @property",
            "    def push_protocol(self):",
            "        return self._push_protocol",
            "",
            "    @push_protocol.setter",
            "    def push_protocol(self, value):",
            "        do_check(value, 'push_protocol', regex_tuple=uri_regex)",
            "        self._push_protocol = value",
            "",
            "    @property",
            "    def push_message_bindings(self):",
            "        return self._push_message_bindings",
            "",
            "    @push_message_bindings.setter",
            "    def push_message_bindings(self, value):",
            "        do_check(value, 'push_message_bindings', regex_tuple=uri_regex)",
            "        self._push_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Push_Method' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.push_protocol",
            "        for binding in self.push_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['push_protocol'] = self.push_protocol",
            "        d['push_message_bindings'] = []",
            "        for binding in self.push_message_bindings:",
            "            d['push_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Push Method ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.push_protocol",
            "        for mb in self.push_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        kwargs = {}",
            "        kwargs['push_protocol'] = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "",
            "        kwargs['push_message_bindings'] = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            kwargs['push_message_bindings'].append(message_binding.text)",
            "        return PushMethod(**kwargs)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PushMethod(**d)",
            "",
            "",
            "class PollingServiceInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Polling Service Instance component of a TAXII Collection",
            "    Information component.",
            "",
            "    Args:",
            "        poll_protocol (str): the protocol binding supported by",
            "            this Poll Service instance. **Required**",
            "        poll_address (str): the address of the TAXII Daemon",
            "            hosting this Poll Service instance. **Required**",
            "        poll_message_bindings (list of str): the message bindings",
            "            supported by this Poll Service instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Polling_Service'",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}Polling_Service' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.poll_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        address.text = self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Polling Service Instance ===\\n\"",
            "        s += line_prepend + \"  Poll Protocol: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Poll Address: %s\\n\" % self.poll_address",
            "        for binding in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % binding",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class SubscriptionMethod(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Method component of a TAXII Collection Information",
            "    component.",
            "",
            "    Args:",
            "        subscription_protocol (str): the protocol binding supported by",
            "            this Collection Management Service instance. **Required**",
            "        subscription_address (str): the address of the TAXII Daemon",
            "            hosting this Collection Management Service instance.",
            "            **Required**.",
            "        subscription_message_bindings (list of str): the message",
            "            bindings supported by this Collection Management Service",
            "            Instance. **Required**",
            "    \"\"\"",
            "    NAME = 'Subscription_Service'",
            "",
            "    def __init__(self, subscription_protocol, subscription_address,",
            "                 subscription_message_bindings):",
            "        self.subscription_protocol = subscription_protocol",
            "        self.subscription_address = subscription_address",
            "        self.subscription_message_bindings = subscription_message_bindings",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_address",
            "",
            "    @property",
            "    def subscription_protocol(self):",
            "        return self._subscription_protocol",
            "",
            "    @subscription_protocol.setter",
            "    def subscription_protocol(self, value):",
            "        do_check(value, 'subscription_protocol', regex_tuple=uri_regex)",
            "        self._subscription_protocol = value",
            "",
            "    @property",
            "    def subscription_message_bindings(self):",
            "        return self._subscription_message_bindings",
            "",
            "    @subscription_message_bindings.setter",
            "    def subscription_message_bindings(self, value):",
            "        do_check(value, 'subscription_message_bindings', regex_tuple=uri_regex)",
            "        self._subscription_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        x = etree.Element('{%s}%s' % (ns_map['taxii_11'], self.NAME))",
            "        proto_bind = etree.SubElement(x, '{%s}Protocol_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "        proto_bind.text = self.subscription_protocol",
            "        address = etree.SubElement(x, '{%s}Address' % ns_map['taxii_11'], nsmap=ns_map)",
            "        address.text = self.subscription_address",
            "        for binding in self.subscription_message_bindings:",
            "            b = etree.SubElement(x, '{%s}Message_Binding' % ns_map['taxii_11'], nsmap=ns_map)",
            "            b.text = binding",
            "        return x",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['subscription_protocol'] = self.subscription_protocol",
            "        d['subscription_address'] = self.subscription_address",
            "        d['subscription_message_bindings'] = []",
            "        for binding in self.subscription_message_bindings:",
            "            d['subscription_message_bindings'].append(binding)",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Service ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.subscription_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.subscription_address",
            "        for mb in self.subscription_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "        bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for message_binding in message_binding_set:",
            "            bindings.append(message_binding.text)",
            "        return cls(protocol, addr, bindings)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        return cls(**d)",
            "",
            "",
            "class ReceivingInboxService(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Receiving Inbox Service component of a TAXII Collection",
            "    Information component.",
            "",
            "    Args:",
            "        inbox_protocol (str): Indicates the protocol this Inbox Service",
            "            uses. **Required**",
            "        inbox address (str): Indicates the address of this Inbox Service.",
            "            **Required**",
            "        inbox_message_bindings (list of str): Each string indicates a",
            "            message binding that this inbox service uses. **Required**",
            "        supported_contents (list of ContentBinding objects): Each object",
            "            indicates a Content Binding this inbox service can receive.",
            "            **Optional**.  Setting to ``None`` means that all Content",
            "            Bindings are supported.",
            "    \"\"\"",
            "",
            "    def __init__(self, inbox_protocol, inbox_address,",
            "                 inbox_message_bindings, supported_contents=None):",
            "        self.inbox_protocol = inbox_protocol",
            "        self.inbox_address = inbox_address",
            "        self.inbox_message_bindings = inbox_message_bindings",
            "        self.supported_contents = supported_contents or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.inbox_address",
            "",
            "    @property",
            "    def inbox_protocol(self):",
            "        return self._inbox_protocol",
            "",
            "    @inbox_protocol.setter",
            "    def inbox_protocol(self, value):",
            "        do_check(value, 'inbox_protocol', type=six.string_types, regex_tuple=uri_regex)",
            "        self._inbox_protocol = value",
            "",
            "    @property",
            "    def inbox_address(self):",
            "        return self._inbox_address",
            "",
            "    @inbox_address.setter",
            "    def inbox_address(self, value):",
            "        self._inbox_address = value",
            "",
            "    @property",
            "    def inbox_message_bindings(self):",
            "        return self._inbox_message_bindings",
            "",
            "    @inbox_message_bindings.setter",
            "    def inbox_message_bindings(self, value):",
            "        do_check(value, 'inbox_message_bindings', regex_tuple=uri_regex)",
            "        self._inbox_message_bindings = value",
            "",
            "    @property",
            "    def supported_contents(self):",
            "        return self._supported_contents",
            "",
            "    @supported_contents.setter",
            "    def supported_contents(self, value):",
            "        value = _sanitize_content_bindings(value)",
            "        do_check(value, 'supported_contents', type=ContentBinding)",
            "        self._supported_contents = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Receiving_Inbox_Service' % ns_map['taxii_11'], nsmap=ns_map)",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.inbox_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.inbox_address",
            "",
            "        for binding in self.inbox_message_bindings:",
            "            mb = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "            mb.text = binding",
            "",
            "        for binding in self.supported_contents:",
            "            xml.append(binding.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['inbox_protocol'] = self.inbox_protocol",
            "        d['inbox_address'] = self.inbox_address",
            "        d['inbox_message_bindings'] = self.inbox_message_bindings",
            "        d['supported_contents'] = []",
            "        for supported_content in self.supported_contents:",
            "            d['supported_contents'].append(supported_content.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Receiving Inbox Service ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.inbox_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.inbox_address",
            "        for mb in self.inbox_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        if len(self.supported_contents) == 0:",
            "            s += line_prepend + \"  Supported Contents: All\\n\"",
            "        for sc in self.supported_contents:",
            "            s += line_prepend + \"  Supported Content: %s\\n\" % str(sc)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        proto = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        addr = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        message_bindings = []",
            "        message_binding_set = etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map)",
            "        for mb in message_binding_set:",
            "            message_bindings.append(mb.text)",
            "",
            "        supported_contents = []",
            "        supported_contents_set = etree_xml.xpath('./taxii_11:Content_Binding', namespaces=ns_map)",
            "        for cb in supported_contents_set:",
            "            supported_contents.append(ContentBinding.from_etree(cb))",
            "",
            "        return ReceivingInboxService(proto, addr, message_bindings, supported_contents)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        kwargs = {}",
            "        kwargs['inbox_protocol'] = d['inbox_protocol']",
            "        kwargs['inbox_address'] = d['inbox_address']",
            "        kwargs['inbox_message_bindings'] = d['inbox_message_bindings']",
            "        kwargs['supported_contents'] = []",
            "        for binding in d['supported_contents']:",
            "            kwargs['supported_contents'].append(ContentBinding.from_dict(binding))",
            "",
            "        return ReceivingInboxService(**kwargs)",
            "",
            "",
            "class PollRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Request message.",
            "",
            "    Arguments:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection that is being",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional for a Data Feed, Prohibited",
            "            for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range of TAXII Data Feed content the",
            "            requester wishes to receive. **Optional for a Data Feed, Probited",
            "            for a Data Set**",
            "        subscription_id (str): the existing subscription the Consumer",
            "            wishes to poll. **Optional**",
            "        poll_parameters (list of PollParameters objects): the poll parameters",
            "            for this request. **Optional**",
            "",
            "    Exactly one of ``subscription_id`` and ``poll_parameters`` is **Required**.",
            "    \"\"\"",
            "    message_type = MSG_POLL_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 poll_parameters=None):",
            "        super(PollRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.poll_parameters = poll_parameters",
            "",
            "        if subscription_id is None and poll_parameters is None:",
            "            raise ValueError('One of subscription_id or poll_parameters must not be None')",
            "        if subscription_id is not None and poll_parameters is not None:",
            "            raise ValueError('Only one of subscription_id and poll_parameters can be present')",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', value_tuple=(None, None), can_be_none=True)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def poll_parameters(self):",
            "        return self._poll_parameters",
            "",
            "    @poll_parameters.setter",
            "    def poll_parameters(self, value):",
            "        do_check(value, 'poll_parameters', type=PollParameters, can_be_none=True)",
            "        self._poll_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "",
            "        if self.exclusive_begin_timestamp_label is not None:",
            "            ebt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'], nsmap=ns_map)",
            "            # TODO: Add TZ Info",
            "            ebt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label is not None:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'], nsmap=ns_map)",
            "            # TODO: Add TZ Info",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'], nsmap=ns_map)",
            "            si.text = self.subscription_id",
            "",
            "        if self.poll_parameters is not None:",
            "            xml.append(self.poll_parameters.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label is not None:  # TODO: Add TZ Info",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label is not None:  # TODO: Add TZ Info",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['poll_parameters'] = None",
            "        if self.poll_parameters is not None:",
            "            d['poll_parameters'] = self.poll_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label",
            "        s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label",
            "        if self.poll_parameters:",
            "            s += self.poll_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "",
            "        begin_ts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        if begin_ts_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(begin_ts_text)",
            "",
            "        end_ts_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        if end_ts_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(end_ts_text)",
            "",
            "        poll_parameter_el = get_optional(etree_xml, './taxii_11:Poll_Parameters', ns_map)",
            "        if poll_parameter_el is not None:",
            "            kwargs['poll_parameters'] = PollParameters.from_etree(poll_parameter_el)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "",
            "        msg = super(PollRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if 'exclusive_begin_timestamp_label' in d:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if 'inclusive_end_timestamp_label' in d:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['poll_parameters'] = None",
            "        if 'poll_parameters' in d and d['poll_parameters'] is not None:",
            "            kwargs['poll_parameters'] = PollParameters.from_dict(d['poll_parameters'])",
            "",
            "        msg = super(PollRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class PollParameters(_GenericParameters):",
            "",
            "    \"\"\"",
            "    The Poll Parameters component of a TAXII Poll Request message.",
            "",
            "    Args:",
            "        response_type (str): The requested response type. Must be either",
            "            :py:data:`RT_FULL` or :py:data:`RT_COUNT_ONLY`. **Optional**,",
            "            defaults to :py:data:`RT_FULL`",
            "        content_bindings (list of ContentBinding objects): A list of Content",
            "            Bindings acceptable in response. **Optional**",
            "        query (Query): The query for this poll parameters. **Optional**",
            "        allow_asynch (bool): Indicates whether the client supports",
            "            asynchronous polling. **Optional**, defaults to ``False``",
            "        delivery_parameters (libtaxii.messages_11.DeliveryParameters): The requested delivery",
            "            parameters for this object. **Optional**",
            "",
            "    If ``content_bindings`` in not provided, this indicates that all",
            "    bindings are accepted as a response.",
            "    \"\"\"",
            "    name = 'Poll_Parameters'",
            "",
            "    def __init__(self, response_type=RT_FULL, content_bindings=None,",
            "                 query=None, allow_asynch=False, delivery_parameters=None):",
            "        super(PollParameters, self).__init__(response_type, content_bindings, query)",
            "        self.allow_asynch = allow_asynch",
            "        self.delivery_parameters = delivery_parameters",
            "",
            "    @property",
            "    def delivery_parameters(self):",
            "        return self._delivery_parameters",
            "",
            "    @delivery_parameters.setter",
            "    def delivery_parameters(self, value):",
            "        do_check(value, 'delivery_parameters', type=DeliveryParameters, can_be_none=True)",
            "        self._delivery_parameters = value",
            "",
            "    @property",
            "    def allow_asynch(self):",
            "        return self._allow_asynch",
            "",
            "    @allow_asynch.setter",
            "    def allow_asynch(self, value):",
            "        do_check(value, 'allow_asynch', value_tuple=(True, False), can_be_none=True)",
            "        self._allow_asynch = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollParameters, self).to_etree()",
            "",
            "        if self.allow_asynch is not None:",
            "            xml.attrib['allow_asynch'] = str(self.allow_asynch).lower()",
            "",
            "        if self.delivery_parameters is not None:",
            "            xml.append(self.delivery_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollParameters, self).to_dict()",
            "        if self.allow_asynch is not None:",
            "            d['allow_asynch'] = str(self.allow_asynch).lower()",
            "        d['delivery_parameters'] = None",
            "        if self.delivery_parameters is not None:",
            "            d['delivery_parameters'] = self.delivery_parameters.to_dict()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollParameters, self).to_text(line_prepend)",
            "        if self.allow_asynch:",
            "            s += line_prepend + \"  Allow Asynch: %s\\n\" % self.allow_asynch",
            "        if self.delivery_parameters:",
            "            s += self.delivery_parameters.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        poll_parameters = super(PollParameters, cls).from_etree(etree_xml)",
            "",
            "        allow_asynch_el = get_optional(etree_xml, './@allow_asynch', ns_map)",
            "        poll_parameters.allow_asynch = allow_asynch_el == 'true'",
            "",
            "        delivery_parameters_el = get_optional(etree_xml, './taxii_11:Delivery_Parameters', ns_map)",
            "        if delivery_parameters_el is not None:",
            "            poll_parameters.delivery_parameters = DeliveryParameters.from_etree(delivery_parameters_el)",
            "",
            "        return poll_parameters",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        poll_parameters = super(PollParameters, cls).from_dict(d)",
            "",
            "        aa = d.get('allow_asynch')",
            "        if aa is not None:",
            "            poll_parameters.allow_asynch = aa == 'true'",
            "",
            "        delivery_parameters = d.get('delivery_parameters')",
            "        if delivery_parameters is not None:",
            "            poll_parameters.delivery_parameters = DeliveryParameters.from_dict(delivery_parameters)",
            "",
            "        return poll_parameters",
            "",
            "",
            "class PollResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Optional**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection that was",
            "            polled. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the range this response covers.",
            "            **Optional for a Data Feed, Prohibited for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the range this response covers. **Optional",
            "            for a Data Feed, Prohibited for a Data Set**",
            "        subscription_id (str): the Subscription ID for which this content",
            "            is being provided. **Optional**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        content_blocks (list of ContentBlock): piece of content",
            "            and additional information related to the content. **Optional**",
            "        more (bool): Whether there are more result parts. **Optional**, defaults",
            "            to ``False``",
            "        result_id (str): The ID of this result. **Optional**",
            "        result_part_number (int): The result part number of this response.",
            "             **Optional**",
            "        record_count (RecordCount): The number of records and whether",
            "             the count is a lower bound. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_POLL_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 collection_name=None, exclusive_begin_timestamp_label=None,",
            "                 inclusive_end_timestamp_label=None, subscription_id=None,",
            "                 message=None, content_blocks=None, more=False, result_id=None,",
            "                 result_part_number=1, record_count=None):",
            "        super(PollResponse, self).__init__(message_id, in_response_to, extended_headers)",
            "        self.collection_name = collection_name",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "        self.subscription_id = subscription_id",
            "        self.message = message",
            "        self.content_blocks = content_blocks or []",
            "        self.more = more",
            "        self.result_part_number = result_part_number",
            "        self.result_id = result_id",
            "        self.record_count = record_count",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_begin_timestamp_label(self):",
            "        return self._inclusive_begin_timestamp_label",
            "",
            "    @inclusive_begin_timestamp_label.setter",
            "    def inclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_begin_timestamp_label', can_be_none=True)",
            "        self._inclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    @property",
            "    def more(self):",
            "        return self._more",
            "",
            "    @more.setter",
            "    def more(self, value):",
            "        do_check(value, 'more', value_tuple=(True, False))",
            "        self._more = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def result_part_number(self):",
            "        return self._result_part_number",
            "",
            "    @result_part_number.setter",
            "    def result_part_number(self, value):",
            "        do_check(value, 'result_part_number', type=int, can_be_none=True)",
            "        self._result_part_number = value",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=RecordCount, can_be_none=True)",
            "        self._record_count = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollResponse, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        if self.result_id is not None:",
            "            xml.attrib['result_id'] = self.result_id",
            "",
            "        if self.more is not None:",
            "            xml.attrib['more'] = str(self.more).lower()",
            "",
            "        if self.result_part_number is not None:",
            "            xml.attrib['result_part_number'] = str(self.result_part_number)",
            "",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "            si.text = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ibt = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'])",
            "            ibt.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            iet = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'])",
            "            iet.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        if self.record_count:",
            "            xml.append(self.record_count.to_etree())",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollResponse, self).to_dict()",
            "",
            "        d['collection_name'] = self.collection_name",
            "        d['more'] = self.more",
            "        d['result_id'] = self.result_id",
            "        d['result_part_number'] = self.result_part_number",
            "        if self.record_count is not None:",
            "            d['record_count'] = self.record_count.to_dict()",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        if self.exclusive_begin_timestamp_label is not None:",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label is not None:",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  More: %s\\n\" % self.more",
            "        s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        if self.result_part_number:",
            "            s += line_prepend + \"  Result Part Num: %s\\n\" % self.result_part_number",
            "        if self.record_count:",
            "            s += self.record_count.to_text(line_prepend + STD_INDENT)",
            "        if self.subscription_id:",
            "            s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.message:",
            "            s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "        kwargs['more'] = etree_xml.attrib.get('more', 'false') == 'true'",
            "        kwargs['subscription_id'] = None",
            "        kwargs['result_id'] = etree_xml.attrib.get('result_id')",
            "        rpn = etree_xml.attrib.get('result_part_number', None)",
            "        if rpn:",
            "            kwargs['result_part_number'] = int(rpn)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        ebts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        if ebts_text:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(ebts_text)",
            "",
            "        iets_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        if iets_text:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(iets_text)",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in etree_xml.xpath('./taxii_11:Content_Block', namespaces=ns_map):",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        record_count_el = get_optional(etree_xml, './taxii_11:Record_Count', ns_map)",
            "        if record_count_el is not None:",
            "            kwargs['record_count'] = RecordCount.from_etree(record_count_el)",
            "",
            "        msg = super(PollResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['result_id'] = d.get('result_id')",
            "        kwargs['result_part_number'] = d.get('result_part_number')",
            "        kwargs['message'] = None",
            "        if 'message' in d:",
            "            kwargs['message'] = d['message']",
            "",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "        kwargs['more'] = d.get('more', False)",
            "",
            "        kwargs['exclusive_begin_timestamp_label'] = None",
            "        if 'exclusive_begin_timestamp_label' in d:",
            "            kwargs['exclusive_begin_timestamp_label'] = parse_datetime_string(d['exclusive_begin_timestamp_label'])",
            "",
            "        kwargs['record_count'] = None",
            "        if 'record_count' in d:",
            "            kwargs['record_count'] = RecordCount.from_dict(d['record_count'])",
            "",
            "        kwargs['inclusive_end_timestamp_label'] = None",
            "        if 'inclusive_end_timestamp_label' in d:",
            "            kwargs['inclusive_end_timestamp_label'] = parse_datetime_string(d['inclusive_end_timestamp_label'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "        msg = super(PollResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "_StatusDetail = collections.namedtuple('_StatusDetail', ['name', 'required', 'type', 'multiple'])",
            "_DCE_AcceptableDestination = _StatusDetail(SD_ACCEPTABLE_DESTINATION, False, str, True)",
            "_IRP_MaxPartNumber = _StatusDetail(SD_MAX_PART_NUMBER, True, int, False)",
            "_NF_Item = _StatusDetail(SD_ITEM, False, str, False)",
            "_P_EstimatedWait = _StatusDetail(SD_ESTIMATED_WAIT, True, int, False)",
            "_P_ResultId = _StatusDetail(SD_RESULT_ID, True, str, False)",
            "_P_WillPush = _StatusDetail(SD_WILL_PUSH, True, bool, False)",
            "_R_EstimatedWait = _StatusDetail(SD_ESTIMATED_WAIT, False, int, False)",
            "_UM_SupportedBinding = _StatusDetail(SD_SUPPORTED_BINDING, False, str, True)",
            "_UC_SupportedContent = _StatusDetail(SD_SUPPORTED_CONTENT, False, ContentBinding, True)",
            "_UP_SupportedProtocol = _StatusDetail(SD_SUPPORTED_PROTOCOL, False, str, True)",
            "_UQ_SupportedQuery = _StatusDetail(SD_SUPPORTED_QUERY, False, str, True)",
            "",
            "",
            "status_details = {",
            "    ST_ASYNCHRONOUS_POLL_ERROR: {},",
            "    ST_BAD_MESSAGE: {},",
            "    ST_DENIED: {},",
            "    ST_DESTINATION_COLLECTION_ERROR: {SD_ACCEPTABLE_DESTINATION: _DCE_AcceptableDestination},",
            "    ST_FAILURE: {},",
            "    ST_INVALID_RESPONSE_PART: {SD_MAX_PART_NUMBER: _IRP_MaxPartNumber},",
            "    ST_NETWORK_ERROR: {},",
            "    ST_NOT_FOUND: {SD_ITEM: _NF_Item},",
            "    ST_PENDING: {SD_ESTIMATED_WAIT: _P_EstimatedWait,",
            "                 SD_RESULT_ID: _P_ResultId,",
            "                 SD_WILL_PUSH: _P_WillPush},",
            "    ST_POLLING_UNSUPPORTED: {},",
            "    ST_RETRY: {SD_ESTIMATED_WAIT: _R_EstimatedWait},",
            "    ST_SUCCESS: {},",
            "    ST_UNAUTHORIZED: {},",
            "    ST_UNSUPPORTED_MESSAGE_BINDING: {SD_SUPPORTED_BINDING: _UM_SupportedBinding},",
            "    ST_UNSUPPORTED_CONTENT_BINDING: {SD_SUPPORTED_CONTENT: _UC_SupportedContent},",
            "    ST_UNSUPPORTED_PROTOCOL: {SD_SUPPORTED_PROTOCOL: _UP_SupportedProtocol},",
            "    ST_UNSUPPORTED_QUERY: {SD_SUPPORTED_QUERY: _UQ_SupportedQuery}",
            "}",
            "",
            "",
            "class StatusMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Status message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        status_type (str): One of the defined Status Types or a third-party-",
            "            defined Status Type. **Required**",
            "        status_detail (dict): A field for additional information about",
            "            this status in a machine-readable format. **Required or Optional**",
            "            depending on ``status_type``. See TAXII Specification for details.",
            "        message (str): Additional information for the status. There is no",
            "            expectation that this field be interpretable by a machine; it is",
            "            instead targeted to a human operator. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_STATUS_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None,",
            "                 status_type=None, status_detail=None, message=None):",
            "        super(StatusMessage, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.status_type = status_type",
            "        self.status_detail = status_detail or {}",
            "        self.message = message",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def status_type(self):",
            "        return self._status_type",
            "",
            "    @status_type.setter",
            "    def status_type(self, value):",
            "        do_check(value, 'status_type')",
            "        self._status_type = value",
            "",
            "    @property",
            "    def status_detail(self):",
            "        return self._status_detail",
            "",
            "    @status_detail.setter",
            "    def status_detail(self, value):",
            "        do_check(list(value.keys()), 'status_detail.keys()', regex_tuple=uri_regex)",
            "        detail_rules = status_details.get(self.status_type, {})",
            "        # Check defined status types for conformance",
            "        for sd_name, rules in six.iteritems(detail_rules):",
            "            do_check(value.get(sd_name, None),",
            "                     'status_detail[\\'%s\\']' % sd_name,",
            "                     type=rules.type,",
            "                     can_be_none=(not rules.required))",
            "",
            "        self._status_detail = value",
            "",
            "    @property",
            "    def message(self):",
            "        return self._message",
            "",
            "    @message.setter",
            "    def message(self, value):",
            "        do_check(value, 'message', type=six.string_types, can_be_none=True)",
            "        self._message = value",
            "",
            "    def to_etree(self):",
            "        xml = super(StatusMessage, self).to_etree()",
            "        xml.attrib['status_type'] = self.status_type",
            "",
            "        if len(self.status_detail) > 0:",
            "            sd = etree.SubElement(xml, '{%s}Status_Detail' % ns_map['taxii_11'])",
            "            for k, v in six.iteritems(self.status_detail):",
            "                if not isinstance(v, list):",
            "                    v = [v]",
            "                for item in v:",
            "                    d = etree.SubElement(sd, '{%s}Detail' % ns_map['taxii_11'])",
            "                    d.attrib['name'] = k",
            "                    if item in (True, False):",
            "                        d.text = str(item).lower()",
            "                    else:",
            "                        d.text = str(item)",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(StatusMessage, self).to_dict()",
            "        d['status_type'] = self.status_type",
            "        if self.status_detail is not None:",
            "            d['status_detail'] = self.status_detail",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(StatusMessage, self).to_text(line_prepend)",
            "        s += line_prepend + \"Status Type: %s\\n\" % self.status_type",
            "        for k, v in six.iteritems(self.status_detail):",
            "            s += line_prepend + \"Status Detail: %s = %s\\n\" % (k, v)",
            "        if self.message:",
            "            s += line_prepend + \"Message: %s\\n\" % self.message",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        status_type = etree_xml.attrib['status_type']",
            "        kwargs['status_type'] = status_type",
            "",
            "        kwargs['status_detail'] = {}",
            "        detail_set = etree_xml.xpath('./taxii_11:Status_Detail/taxii_11:Detail', namespaces=ns_map)",
            "        for detail in detail_set:",
            "            # TODO: This seems kind of hacky and should probably be improved",
            "            name = detail.attrib['name']",
            "",
            "            if status_type in status_details and name in status_details[status_type]:  # We have information for this status detail",
            "                detail_info = status_details[status_type][name]",
            "            else:  # We don't have information, so make something up",
            "                detail_info = _StatusDetail('PlaceholderDetail', False, str, True)",
            "",
            "            if detail_info.type == bool:",
            "                v = detail.text.lower() == 'true'",
            "            else:",
            "                v = detail_info.type(detail.text)",
            "            if detail_info.multiple:  # There can be multiple instances of this item",
            "                if name not in kwargs['status_detail']:",
            "                    kwargs['status_detail'][name] = v",
            "                else:  # It already exists",
            "                    if not isinstance(kwargs['status_detail'][name], list):",
            "                        kwargs['status_detail'][name] = [kwargs['status_detail'][name]]  # Make it a list",
            "                    kwargs['status_detail'][name].append(v)",
            "            else:",
            "                kwargs['status_detail'][name] = v",
            "",
            "        kwargs['message'] = None",
            "        m_set = etree_xml.xpath('./taxii_11:Message', namespaces=ns_map)",
            "        if len(m_set) > 0:",
            "            kwargs['message'] = m_set[0].text",
            "",
            "        msg = super(StatusMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['status_type'] = d['status_type']",
            "        kwargs['status_detail'] = d.get('status_detail')",
            "        kwargs['message'] = d.get('message')",
            "",
            "        msg = super(StatusMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class InboxMessage(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Inbox message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        message (str): prose information for the message recipient. **Optional**",
            "        result_id (str): the result id. **Optional**",
            "        destination_collection_names (list of str): Each string indicates a",
            "             destination collection name. **Optional**",
            "        subscription_information (libtaxii.messages_11.SubscriptionInformation): This",
            "            field is only present if this message is being sent to provide",
            "            content in accordance with an existing TAXII Data Collection",
            "            subscription. **Optional**",
            "        record_count (RecordCount): The number of records and whether",
            "             the count is a lower bound. **Optional**",
            "        content_blocks (list of ContentBlock): Inbox content. **Optional**",
            "    \"\"\"",
            "    message_type = MSG_INBOX_MESSAGE",
            "",
            "    def __init__(self, message_id, in_response_to=None, extended_headers=None,",
            "                 message=None, result_id=None, destination_collection_names=None,",
            "                 subscription_information=None, record_count=None,",
            "                 content_blocks=None):",
            "",
            "        super(InboxMessage, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.subscription_information = subscription_information",
            "        self.message = message",
            "        self.result_id = result_id",
            "        self.destination_collection_names = destination_collection_names or []",
            "        self.subscription_information = subscription_information",
            "        self.record_count = record_count",
            "        self.content_blocks = content_blocks or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def subscription_information(self):",
            "        return self._subscription_information",
            "",
            "    @subscription_information.setter",
            "    def subscription_information(self, value):",
            "        do_check(value, 'subscription_information', type=SubscriptionInformation, can_be_none=True)",
            "        self._subscription_information = value",
            "",
            "    @property",
            "    def content_blocks(self):",
            "        return self._content_blocks",
            "",
            "    @content_blocks.setter",
            "    def content_blocks(self, value):",
            "        do_check(value, 'content_blocks', type=ContentBlock)",
            "        self._content_blocks = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def destination_collection_names(self):",
            "        return self._destination_collection_names",
            "",
            "    @destination_collection_names.setter",
            "    def destination_collection_names(self, value):",
            "        do_check(value, 'destination_collection_names', regex_tuple=uri_regex)",
            "        self._destination_collection_names = value",
            "",
            "    @property",
            "    def record_count(self):",
            "        return self._record_count",
            "",
            "    @record_count.setter",
            "    def record_count(self, value):",
            "        do_check(value, 'record_count', type=RecordCount, can_be_none=True)",
            "        self._record_count = value",
            "",
            "    def to_etree(self):",
            "        xml = super(InboxMessage, self).to_etree()",
            "",
            "        if self.result_id is not None:",
            "            xml.attrib['result_id'] = self.result_id",
            "",
            "        for dcn in self.destination_collection_names:",
            "            d = etree.SubElement(xml, '{%s}Destination_Collection_Name' % ns_map['taxii_11'], nsmap=ns_map)",
            "            d.text = dcn",
            "",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        if self.subscription_information is not None:",
            "            xml.append(self.subscription_information.to_etree())",
            "",
            "        if self.record_count is not None:",
            "            xml.append(self.record_count.to_etree())",
            "",
            "        for block in self.content_blocks:",
            "            xml.append(block.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(InboxMessage, self).to_dict()",
            "",
            "        if self.result_id is not None:",
            "            d['result_id'] = self.result_id",
            "",
            "        d['destination_collection_names'] = []",
            "        for dcn in self.destination_collection_names:",
            "            d['destination_collection_names'].append(dcn)",
            "",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "",
            "        if self.subscription_information is not None:",
            "            d['subscription_information'] = self.subscription_information.to_dict()",
            "",
            "        if self.record_count is not None:",
            "            d['record_count'] = self.record_count.to_dict()",
            "",
            "        d['content_blocks'] = []",
            "        for block in self.content_blocks:",
            "            d['content_blocks'].append(block.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(InboxMessage, self).to_text(line_prepend)",
            "        if self.result_id:",
            "            s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        for dcn in self.destination_collection_names:",
            "            s += line_prepend + \"  Destination Collection Name: %s\\n\" % dcn",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        if self.subscription_information:",
            "            s += self.subscription_information.to_text(line_prepend + STD_INDENT)",
            "        if self.record_count:",
            "            s += self.record_count.to_text(line_prepend + STD_INDENT)",
            "        s += line_prepend + \"  Message has %s Content Blocks\\n\" % len(self.content_blocks)",
            "        for cb in self.content_blocks:",
            "            s += cb.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "",
            "        result_id_set = etree_xml.xpath('./@result_id')",
            "        if len(result_id_set) > 0:",
            "            kwargs['result_id'] = result_id_set[0]",
            "",
            "        kwargs['destination_collection_names'] = []",
            "        dcn_set = etree_xml.xpath('./taxii_11:Destination_Collection_Name', namespaces=ns_map)",
            "        for dcn in dcn_set:",
            "            kwargs['destination_collection_names'].append(dcn.text)",
            "",
            "        msg_set = etree_xml.xpath('./taxii_11:Message', namespaces=ns_map)",
            "        if len(msg_set) > 0:",
            "            kwargs['message'] = msg_set[0].text",
            "",
            "        subs_infos = etree_xml.xpath('./taxii_11:Source_Subscription', namespaces=ns_map)",
            "        if len(subs_infos) > 0:",
            "            kwargs['subscription_information'] = SubscriptionInformation.from_etree(subs_infos[0])",
            "",
            "        record_count_set = etree_xml.xpath('./taxii_11:Record_Count', namespaces=ns_map)",
            "        if len(record_count_set) > 0:",
            "            kwargs['record_count'] = RecordCount.from_etree(record_count_set[0])",
            "",
            "        content_blocks = etree_xml.xpath('./taxii_11:Content_Block', namespaces=ns_map)",
            "        kwargs['content_blocks'] = []",
            "        for block in content_blocks:",
            "            kwargs['content_blocks'].append(ContentBlock.from_etree(block))",
            "",
            "        msg = super(InboxMessage, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "",
            "        kwargs = {}",
            "",
            "        kwargs['result_id'] = d.get('result_id')",
            "",
            "        kwargs['destination_collection_names'] = []",
            "        if 'destination_collection_names' in d:",
            "            for dcn in d['destination_collection_names']:",
            "                kwargs['destination_collection_names'].append(dcn)",
            "",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_information'] = None",
            "        if 'subscription_information' in d:",
            "            kwargs['subscription_information'] = SubscriptionInformation.from_dict(d['subscription_information'])",
            "",
            "        if 'record_count' in d:",
            "            kwargs['record_count'] = RecordCount.from_dict(d['record_count'])",
            "",
            "        kwargs['content_blocks'] = []",
            "        for block in d['content_blocks']:",
            "            kwargs['content_blocks'].append(ContentBlock.from_dict(block))",
            "",
            "        msg = super(InboxMessage, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInformation(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Information component of a TAXII Inbox message.",
            "",
            "    Arguments:",
            "        collection_name (str): the name of the TAXII Data Collection from",
            "            which this content is being provided. **Required**",
            "        subscription_id (str): the Subscription ID for which this",
            "            content is being provided. **Required**",
            "        exclusive_begin_timestamp_label (datetime): a Timestamp Label",
            "            indicating the beginning of the time range this Inbox Message",
            "            covers. **Optional for a Data Feed, Prohibited for a Data Set**",
            "        inclusive_end_timestamp_label (datetime): a Timestamp Label",
            "            indicating the end of the time range this Inbox Message covers.",
            "            **Optional for a Data Feed, Prohibited for a Data Set**",
            "    \"\"\"",
            "",
            "    def __init__(self, collection_name, subscription_id, exclusive_begin_timestamp_label=None, inclusive_end_timestamp_label=None):",
            "        self.collection_name = collection_name",
            "        self.subscription_id = subscription_id",
            "        self.exclusive_begin_timestamp_label = exclusive_begin_timestamp_label",
            "        self.inclusive_end_timestamp_label = inclusive_end_timestamp_label",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def exclusive_begin_timestamp_label(self):",
            "        return self._exclusive_begin_timestamp_label",
            "",
            "    @exclusive_begin_timestamp_label.setter",
            "    def exclusive_begin_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'exclusive_begin_timestamp_label', can_be_none=True)",
            "        self._exclusive_begin_timestamp_label = value",
            "",
            "    @property",
            "    def inclusive_end_timestamp_label(self):",
            "        return self._inclusive_end_timestamp_label",
            "",
            "    @inclusive_end_timestamp_label.setter",
            "    def inclusive_end_timestamp_label(self, value):",
            "        value = check_timestamp_label(value, 'inclusive_end_timestamp_label', can_be_none=True)",
            "        self._inclusive_end_timestamp_label = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Source_Subscription' % ns_map['taxii_11'])",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "        si.text = self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            ebtl = etree.SubElement(xml, '{%s}Exclusive_Begin_Timestamp' % ns_map['taxii_11'])",
            "            ebtl.text = self.exclusive_begin_timestamp_label.isoformat()",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            ietl = etree.SubElement(xml, '{%s}Inclusive_End_Timestamp' % ns_map['taxii_11'])",
            "            ietl.text = self.inclusive_end_timestamp_label.isoformat()",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['collection_name'] = self.collection_name",
            "        d['subscription_id'] = self.subscription_id",
            "        if self.exclusive_begin_timestamp_label:",
            "            d['exclusive_begin_timestamp_label'] = self.exclusive_begin_timestamp_label.isoformat()",
            "        if self.inclusive_end_timestamp_label:",
            "            d['inclusive_end_timestamp_label'] = self.inclusive_end_timestamp_label.isoformat()",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Source Subscription ===\\n\"",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.exclusive_begin_timestamp_label:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % self.exclusive_begin_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Excl. Begin TS Label: %s\\n\" % None",
            "",
            "        if self.inclusive_end_timestamp_label:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % self.inclusive_end_timestamp_label.isoformat()",
            "        else:",
            "            s += line_prepend + \"  Incl. End TS Label: %s\\n\" % None",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        collection_name = etree_xml.attrib['collection_name']",
            "        subscription_id = get_required(etree_xml, './taxii_11:Subscription_ID', ns_map).text",
            "",
            "        begin_ts_text = get_optional_text(etree_xml, './taxii_11:Exclusive_Begin_Timestamp', ns_map)",
            "        ebtl = parse_datetime_string(begin_ts_text) if begin_ts_text else None",
            "",
            "        end_ts_text = get_optional_text(etree_xml, './taxii_11:Inclusive_End_Timestamp', ns_map)",
            "        ietl = parse_datetime_string(end_ts_text) if end_ts_text else None",
            "",
            "        return SubscriptionInformation(collection_name, subscription_id, ebtl, ietl)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        collection_name = d['collection_name']",
            "        subscription_id = d['subscription_id']",
            "",
            "        ebtl = parse_datetime_string(d.get('exclusive_begin_timestamp_label'))",
            "        ietl = parse_datetime_string(d.get('inclusive_end_timestamp_label'))",
            "",
            "        return SubscriptionInformation(collection_name, subscription_id, ebtl, ietl)",
            "",
            "",
            "class ManageCollectionSubscriptionRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Collection Subscription Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which the",
            "            action applies. **Required**",
            "        action (str): the requested action to take. **Required**",
            "        subscription_id (str): the ID of a previously created subscription.",
            "            **Probibited** if ``action==``:py:data:`ACT_SUBSCRIBE`, else",
            "            **Required**",
            "        subscription_parameters (SubscriptionParameters): The parameters for",
            "            this subscription. **Optional**",
            "        push_parameters (list of PushParameter): the push parameters for this",
            "            request. **Optional** Absence means push is not requested.",
            "    \"\"\"",
            "",
            "    message_type = MSG_MANAGE_COLLECTION_SUBSCRIPTION_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, action=None, subscription_id=None,",
            "                 subscription_parameters=None, push_parameters=None):",
            "",
            "        super(ManageCollectionSubscriptionRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.action = action",
            "        self.subscription_id = subscription_id",
            "        self.subscription_parameters = subscription_parameters or SubscriptionParameters()",
            "        self.push_parameters = push_parameters",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        if value is not None:",
            "            raise ValueError('in_response_to must be None')",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def action(self):",
            "        return self._action",
            "",
            "    @action.setter",
            "    def action(self, value):",
            "        do_check(value, 'action', value_tuple=ACT_TYPES)",
            "        self._action = value",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex, can_be_none=True)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def subscription_parameters(self):",
            "        return self._subscription_parameters",
            "",
            "    @subscription_parameters.setter",
            "    def subscription_parameters(self, value):",
            "        do_check(value, 'subscription_parameters', type=SubscriptionParameters, can_be_none=True)",
            "        self._subscription_parameters = value",
            "",
            "    @property",
            "    def push_parameters(self):",
            "        return self._push_parameters",
            "",
            "    @push_parameters.setter",
            "    def push_parameters(self, value):",
            "        do_check(value, 'push_parameters', type=PushParameters, can_be_none=True)",
            "        self._push_parameters = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageCollectionSubscriptionRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        xml.attrib['action'] = self.action",
            "        if self.subscription_id is not None:",
            "            si = etree.SubElement(xml, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "            si.text = self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            xml.append(self.subscription_parameters.to_etree())",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            xml.append(self.push_parameters.to_etree())",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageCollectionSubscriptionRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        d['action'] = self.action",
            "",
            "        if self.subscription_id is not None:",
            "            d['subscription_id'] = self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            d['subscription_parameters'] = self.subscription_parameters.to_dict()",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            d['push_parameters'] = self.push_parameters.to_dict()",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageCollectionSubscriptionRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Action: %s\\n\" % self.action",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "",
            "        if self.action == ACT_SUBSCRIBE:",
            "            s += self.subscription_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        if self.action == ACT_SUBSCRIBE and self.push_parameters:",
            "            s += self.push_parameters.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = get_required(etree_xml, './@collection_name', ns_map)",
            "        kwargs['action'] = get_required(etree_xml, './@action', ns_map)",
            "",
            "        kwargs['subscription_id'] = get_optional_text(etree_xml, './taxii_11:Subscription_ID', ns_map)",
            "",
            "        subscription_parameters_el = get_optional(etree_xml, './taxii_11:Subscription_Parameters', ns_map)",
            "        if subscription_parameters_el is not None:",
            "            kwargs['subscription_parameters'] = SubscriptionParameters.from_etree(subscription_parameters_el)",
            "",
            "        push_parameters_el = get_optional(etree_xml, './taxii_11:Push_Parameters', ns_map)",
            "        if push_parameters_el is not None:",
            "            kwargs['push_parameters'] = PushParameters.from_etree(push_parameters_el)",
            "",
            "        msg = super(ManageCollectionSubscriptionRequest, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['action'] = d['action']",
            "        kwargs['subscription_id'] = d.get('subscription_id')",
            "",
            "        kwargs['subscription_parameters'] = None",
            "        if 'subscription_parameters' in d:",
            "            kwargs['subscription_parameters'] = SubscriptionParameters.from_dict(d['subscription_parameters'])",
            "",
            "        kwargs['push_parameters'] = None",
            "        if 'push_parameters' in d:",
            "            kwargs['push_parameters'] = PushParameters.from_dict(d['push_parameters'])",
            "",
            "        msg = super(ManageCollectionSubscriptionRequest, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class ManageCollectionSubscriptionResponse(TAXIIMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Manage Collection Subscription Response message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        in_response_to (str): Contains the Message ID of the message to",
            "            which this is a response. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which",
            "            the action applies. **Required**",
            "        message (str): additional information for the message recipient.",
            "            **Optional**",
            "        subscription_instances (list of SubscriptionInstance): **Optional**",
            "    \"\"\"",
            "    message_type = MSG_MANAGE_COLLECTION_SUBSCRIPTION_RESPONSE",
            "",
            "    def __init__(self, message_id, in_response_to, extended_headers=None, collection_name=None, message=None, subscription_instances=None):",
            "        super(ManageCollectionSubscriptionResponse, self).__init__(message_id, in_response_to, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.message = message",
            "        self.subscription_instances = subscription_instances or []",
            "",
            "    @TAXIIMessage.in_response_to.setter",
            "    def in_response_to(self, value):",
            "        do_check(value, 'in_response_to', regex_tuple=uri_regex)",
            "        self._in_response_to = value",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def subscription_instances(self):",
            "        return self._subscription_instances",
            "",
            "    @subscription_instances.setter",
            "    def subscription_instances(self, value):",
            "        do_check(value, 'subscription_instances', type=SubscriptionInstance)",
            "        self._subscription_instances = value",
            "",
            "    def to_etree(self):",
            "        xml = super(ManageCollectionSubscriptionResponse, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        if self.message is not None:",
            "            m = etree.SubElement(xml, '{%s}Message' % ns_map['taxii_11'])",
            "            m.text = self.message",
            "",
            "        for subscription_instance in self.subscription_instances:",
            "            xml.append(subscription_instance.to_etree())",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(ManageCollectionSubscriptionResponse, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        if self.message is not None:",
            "            d['message'] = self.message",
            "        d['subscription_instances'] = []",
            "        for subscription_instance in self.subscription_instances:",
            "            d['subscription_instances'].append(subscription_instance.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(ManageCollectionSubscriptionResponse, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Message: %s\\n\" % self.message",
            "        for si in self.subscription_instances:",
            "            s += si.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "",
            "        kwargs['message'] = get_optional_text(etree_xml, './taxii_11:Message', ns_map)",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for si in etree_xml.xpath('./taxii_11:Subscription', namespaces=ns_map):",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_etree(si))",
            "",
            "        msg = super(ManageCollectionSubscriptionResponse, cls).from_etree(etree_xml, **kwargs)",
            "        return msg",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "",
            "        kwargs['message'] = d.get('message')",
            "",
            "        kwargs['subscription_instances'] = []",
            "        for instance in d['subscription_instances']:",
            "            kwargs['subscription_instances'].append(SubscriptionInstance.from_dict(instance))",
            "",
            "        msg = super(ManageCollectionSubscriptionResponse, cls).from_dict(d, **kwargs)",
            "        return msg",
            "",
            "",
            "class SubscriptionInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Subscription Instance component of the Manage Collection Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        subscription_id (str): the id of the subscription. **Required**",
            "        status (str): One of :py:data:`SS_ACTIVE`, :py:data:`SS_PAUSED`, or",
            "                :py:data:`SS_UNSUBSCRIBED`. **Optional**, defaults to \"ACTIVE\"",
            "        subscription_parameters (SubscriptionParameters): the parameters",
            "            for this subscription. **Optional** If provided, should match",
            "            the request.",
            "        push_parameters (PushParameters): the push parameters for this",
            "            subscription. **Optional** If provided, should match the request.",
            "        poll_instances (list of PollInstance): The Poll Services that can be",
            "                polled to fulfill this subscription. **Optional**",
            "    \"\"\"",
            "",
            "    def __init__(self, subscription_id, status=SS_ACTIVE,",
            "                 subscription_parameters=None, push_parameters=None,",
            "                 poll_instances=None):",
            "        self.subscription_id = subscription_id",
            "        self.status = status",
            "        self.subscription_parameters = subscription_parameters",
            "        self.push_parameters = push_parameters",
            "        self.poll_instances = poll_instances or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.subscription_id",
            "",
            "    @property",
            "    def subscription_id(self):",
            "        return self._subscription_id",
            "",
            "    @subscription_id.setter",
            "    def subscription_id(self, value):",
            "        do_check(value, 'subscription_id', regex_tuple=uri_regex)",
            "        self._subscription_id = value",
            "",
            "    @property",
            "    def status(self):",
            "        return self._status",
            "",
            "    @status.setter",
            "    def status(self, value):",
            "        do_check(value, 'status', value_tuple=SS_TYPES, can_be_none=True)",
            "        self._status = value",
            "",
            "    @property",
            "    def subscription_parameters(self):",
            "        return self._subscription_parameters",
            "",
            "    @subscription_parameters.setter",
            "    def subscription_parameters(self, value):",
            "        do_check(value, 'subscription_parameters', type=SubscriptionParameters, can_be_none=True)",
            "        self._subscription_parameters = value",
            "",
            "    @property",
            "    def push_parameters(self):",
            "        return self._push_parameters",
            "",
            "    @push_parameters.setter",
            "    def push_parameters(self, value):",
            "        do_check(value, 'push_parameters', type=PushParameters, can_be_none=True)",
            "        self._push_parameters = value",
            "",
            "    @property",
            "    def poll_instances(self):",
            "        return self._poll_instances",
            "",
            "    @poll_instances.setter",
            "    def poll_instances(self, value):",
            "        do_check(value, 'poll_instances', type=PollInstance)",
            "        self._poll_instances = value",
            "",
            "    def to_etree(self):",
            "        si = etree.Element('{%s}Subscription' % ns_map['taxii_11'], nsmap=ns_map)",
            "        if self.status is not None:",
            "            si.attrib['status'] = self.status",
            "",
            "        subs_id = etree.SubElement(si, '{%s}Subscription_ID' % ns_map['taxii_11'])",
            "        subs_id.text = self.subscription_id",
            "",
            "        if self.subscription_parameters is not None:",
            "            si.append(self.subscription_parameters.to_etree())",
            "",
            "        if self.push_parameters is not None:",
            "            si.append(self.push_parameters.to_etree())",
            "",
            "        for pi in self.poll_instances:",
            "            si.append(pi.to_etree())",
            "",
            "        return si",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "        d['status'] = self.status",
            "        d['subscription_id'] = self.subscription_id",
            "        d['subscription_parameters'] = None",
            "        if self.subscription_parameters is not None:",
            "            d['subscription_parameters'] = self.subscription_parameters.to_dict()",
            "",
            "        d['push_parameters'] = None",
            "        if self.push_parameters is not None:",
            "            d['push_parameters'] = self.push_parameters.to_dict()",
            "",
            "        d['poll_instances'] = []",
            "        for pi in self.poll_instances:",
            "            d['poll_instances'].append(pi.to_dict())",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Subscription Instance ===\\n\"",
            "        s += line_prepend + \"  Status: %s\\n\" % self.status",
            "        s += line_prepend + \"  Subscription ID: %s\\n\" % self.subscription_id",
            "        if self.subscription_parameters:",
            "            s += self.subscription_parameters.to_text(line_prepend + STD_INDENT)",
            "        if self.push_parameters:",
            "            s += self.push_parameters.to_text(line_prepend + STD_INDENT)",
            "        for pi in self.poll_instances:",
            "            s += pi.to_text(line_prepend + STD_INDENT)",
            "",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "",
            "        status = get_optional(etree_xml, './@status', ns_map)",
            "",
            "        subscription_id = get_required(etree_xml, './taxii_11:Subscription_ID', ns_map).text",
            "",
            "        subscription_parameters = None",
            "        subscription_parameters_el = get_optional(etree_xml, './taxii_11:Subscription_Parameters', ns_map)",
            "        if subscription_parameters_el is not None:",
            "            subscription_parameters = SubscriptionParameters.from_etree(subscription_parameters_el)",
            "",
            "        push_parameters = None",
            "        push_parameters_el = get_optional(etree_xml, './taxii_11:Push_Parameters', ns_map)",
            "        if push_parameters_el is not None:",
            "            push_parameters = PushParameters.from_etree(push_parameters_el)",
            "",
            "        poll_instances = []",
            "        for pi in etree_xml.xpath('./taxii_11:Poll_Instance', namespaces=ns_map):",
            "            poll_instances.append(PollInstance.from_etree(pi))",
            "",
            "        return SubscriptionInstance(subscription_id, status, subscription_parameters, push_parameters, poll_instances)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        subscription_id = d['subscription_id']",
            "        status = d.get('status')",
            "",
            "        subscription_parameters = None",
            "        if d.get('subscription_parameters') is not None:",
            "            subscription_parameters = SubscriptionParameters.from_dict(d['subscription_parameters'])",
            "",
            "        push_parameters = None",
            "        if d.get('push_parameters') is not None:",
            "            push_parameters = PushParameters.from_dict(d['push_parameters'])",
            "",
            "        poll_instances = []",
            "        if 'poll_instances' in d:",
            "            for pi in d['poll_instances']:",
            "                poll_instances.append(PollInstance.from_dict(pi))",
            "",
            "        return SubscriptionInstance(subscription_id, status, subscription_parameters, push_parameters, poll_instances)",
            "",
            "",
            "class PollInstance(TAXIIBase11):",
            "",
            "    \"\"\"",
            "    The Poll Instance component of the Manage Collection Subscription",
            "    Response message.",
            "",
            "    Args:",
            "        poll_protocol (str): The protocol binding supported by this",
            "            instance of a Polling Service. **Required**",
            "        poll_address (str): the address of the TAXII Daemon hosting",
            "            this Poll Service. **Required**",
            "        poll_message_bindings (list of str): one or more message bindings",
            "            that can be used when interacting with this Poll Service",
            "            instance. **Required**",
            "    \"\"\"",
            "",
            "    def __init__(self, poll_protocol, poll_address, poll_message_bindings=None):",
            "        self.poll_protocol = poll_protocol",
            "        self.poll_address = poll_address",
            "        self.poll_message_bindings = poll_message_bindings or []",
            "",
            "    @property",
            "    def sort_key(self):",
            "        return self.poll_address",
            "",
            "    @property",
            "    def poll_protocol(self):",
            "        return self._poll_protocol",
            "",
            "    @poll_protocol.setter",
            "    def poll_protocol(self, value):",
            "        do_check(value, 'poll_protocol', regex_tuple=uri_regex)",
            "        self._poll_protocol = value",
            "",
            "    @property",
            "    def poll_message_bindings(self):",
            "        return self._poll_message_bindings",
            "",
            "    @poll_message_bindings.setter",
            "    def poll_message_bindings(self, value):",
            "        do_check(value, 'poll_message_bindings', regex_tuple=uri_regex)",
            "        self._poll_message_bindings = value",
            "",
            "    def to_etree(self):",
            "        xml = etree.Element('{%s}Poll_Instance' % ns_map['taxii_11'])",
            "",
            "        pb = etree.SubElement(xml, '{%s}Protocol_Binding' % ns_map['taxii_11'])",
            "        pb.text = self.poll_protocol",
            "",
            "        a = etree.SubElement(xml, '{%s}Address' % ns_map['taxii_11'])",
            "        a.text = self.poll_address",
            "",
            "        for binding in self.poll_message_bindings:",
            "            b = etree.SubElement(xml, '{%s}Message_Binding' % ns_map['taxii_11'])",
            "            b.text = binding",
            "",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = {}",
            "",
            "        d['poll_protocol'] = self.poll_protocol",
            "        d['poll_address'] = self.poll_address",
            "        d['poll_message_bindings'] = []",
            "        for binding in self.poll_message_bindings:",
            "            d['poll_message_bindings'].append(binding)",
            "",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = line_prepend + \"=== Poll Instance ===\\n\"",
            "        s += line_prepend + \"  Protocol Binding: %s\\n\" % self.poll_protocol",
            "        s += line_prepend + \"  Address: %s\\n\" % self.poll_address",
            "        for mb in self.poll_message_bindings:",
            "            s += line_prepend + \"  Message Binding: %s\\n\" % mb",
            "        return s",
            "",
            "    @staticmethod",
            "    def from_etree(etree_xml):",
            "        poll_protocol = get_required(etree_xml, './taxii_11:Protocol_Binding', ns_map).text",
            "        address = get_required(etree_xml, './taxii_11:Address', ns_map).text",
            "",
            "        poll_message_bindings = []",
            "        for b in etree_xml.xpath('./taxii_11:Message_Binding', namespaces=ns_map):",
            "            poll_message_bindings.append(b.text)",
            "",
            "        return PollInstance(poll_protocol, address, poll_message_bindings)",
            "",
            "    @staticmethod",
            "    def from_dict(d):",
            "        return PollInstance(**d)",
            "",
            "",
            "class PollFulfillmentRequest(TAXIIRequestMessage):",
            "",
            "    \"\"\"",
            "    A TAXII Poll Fulfillment Request message.",
            "",
            "    Args:",
            "        message_id (str): A value identifying this message. **Required**",
            "        extended_headers (dict): A dictionary of name/value pairs for",
            "            use as Extended Headers. **Optional**",
            "        collection_name (str): the name of the TAXII Data Collection to which the",
            "            action applies. **Required**",
            "        result_id (str): The result id of the requested result. **Required**",
            "        result_part_number (int): The part number being requested. **Required**",
            "    \"\"\"",
            "    message_type = MSG_POLL_FULFILLMENT_REQUEST",
            "",
            "    def __init__(self, message_id, extended_headers=None,",
            "                 collection_name=None, result_id=None, result_part_number=None):",
            "        super(PollFulfillmentRequest, self).__init__(message_id, extended_headers=extended_headers)",
            "        self.collection_name = collection_name",
            "        self.result_id = result_id",
            "        self.result_part_number = result_part_number",
            "",
            "    @property",
            "    def collection_name(self):",
            "        return self._collection_name",
            "",
            "    @collection_name.setter",
            "    def collection_name(self, value):",
            "        do_check(value, 'collection_name', regex_tuple=uri_regex)",
            "        self._collection_name = value",
            "",
            "    @property",
            "    def result_id(self):",
            "        return self._result_id",
            "",
            "    @result_id.setter",
            "    def result_id(self, value):",
            "        do_check(value, 'result_id', regex_tuple=uri_regex)",
            "        self._result_id = value",
            "",
            "    @property",
            "    def result_part_number(self):",
            "        return self._result_part_number",
            "",
            "    @result_part_number.setter",
            "    def result_part_number(self, value):",
            "        do_check(value, 'result_part_number', type=int)",
            "        self._result_part_number = value",
            "",
            "    def to_etree(self):",
            "        xml = super(PollFulfillmentRequest, self).to_etree()",
            "        xml.attrib['collection_name'] = self.collection_name",
            "        xml.attrib['result_id'] = self.result_id",
            "        xml.attrib['result_part_number'] = str(self.result_part_number)",
            "        return xml",
            "",
            "    def to_dict(self):",
            "        d = super(PollFulfillmentRequest, self).to_dict()",
            "        d['collection_name'] = self.collection_name",
            "        d['result_id'] = self.result_id",
            "        d['result_part_number'] = self.result_part_number",
            "        return d",
            "",
            "    def to_text(self, line_prepend=''):",
            "        s = super(PollFulfillmentRequest, self).to_text(line_prepend)",
            "        s += line_prepend + \"  Collection Name: %s\\n\" % self.collection_name",
            "        s += line_prepend + \"  Result ID: %s\\n\" % self.result_id",
            "        s += line_prepend + \"  Result Part Number: %s\\n\" % self.result_part_number",
            "        return s",
            "",
            "    @classmethod",
            "    def from_etree(cls, etree_xml):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = etree_xml.attrib['collection_name']",
            "        kwargs['result_id'] = etree_xml.attrib['result_id']",
            "        kwargs['result_part_number'] = int(etree_xml.attrib['result_part_number'])",
            "",
            "        return super(PollFulfillmentRequest, cls).from_etree(etree_xml, **kwargs)",
            "",
            "    @classmethod",
            "    def from_dict(cls, d):",
            "",
            "        kwargs = {}",
            "        kwargs['collection_name'] = d['collection_name']",
            "        kwargs['result_id'] = d['result_id']",
            "        kwargs['result_part_number'] = int(d['result_part_number'])",
            "",
            "        return super(PollFulfillmentRequest, cls).from_dict(d, **kwargs)",
            "",
            "",
            "########################################################",
            "# EVERYTHING BELOW HERE IS FOR BACKWARDS COMPATIBILITY #",
            "########################################################",
            "",
            "# Add top-level classes as nested classes for backwards compatibility",
            "DiscoveryResponse.ServiceInstance = ServiceInstance",
            "CollectionInformationResponse.CollectionInformation = CollectionInformation",
            "CollectionInformation.PushMethod = PushMethod",
            "CollectionInformation.PollingServiceInstance = PollingServiceInstance",
            "CollectionInformation.SubscriptionMethod = SubscriptionMethod",
            "CollectionInformation.ReceivingInboxService = ReceivingInboxService",
            "ManageCollectionSubscriptionResponse.PollInstance = PollInstance",
            "ManageCollectionSubscriptionResponse.SubscriptionInstance = SubscriptionInstance",
            "PollRequest.PollParameters = PollParameters",
            "InboxMessage.SubscriptionInformation = SubscriptionInformation",
            "",
            "# Constants not imported in `from constants import *`",
            "",
            "MSG_TYPES = MSG_TYPES_11",
            "ST_TYPES = ST_TYPES_11",
            "ACT_TYPES = ACT_TYPES_11",
            "SS_TYPES = SS_TYPES_11",
            "RT_TYPES = RT_TYPES_11",
            "CT_TYPES = CT_TYPES_11",
            "SVC_TYPES = SVC_TYPES_11",
            "SD_TYPES = SD_TYPES_11",
            "",
            "from .common import (generate_message_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "49": [
                "validate_xml"
            ],
            "821": [
                "ContentBlock",
                "from_dict"
            ],
            "1112": [
                "TAXIIMessage",
                "from_dict"
            ]
        },
        "addLocation": []
    },
    "libtaxii/test/messages_11_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "         except etree.XMLSyntaxError:"
            },
            "1": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "             raise ValueError(\"An XML Syntax Error was raised, meaning a real attack would have succeeded!\")"
            },
            "2": {
                "beforePatchRowNumber": 1272,
                "afterPatchRowNumber": 1272,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "+    def test_ssrf(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "+        Tests that external URLs are forbidden by default."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "+        https://github.com/TAXIIProject/libtaxii/issues/246"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "+        \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "+        try:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "+            parse(\"http://localhost/\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "+        except ValueError:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "+            pass"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "+        else:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "+            raise AssertionError(\"oh no!\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1285,
                "PatchRowcode": "+        try:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "+            parse(\"ftp://localhost/\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1287,
                "PatchRowcode": "+        except ValueError:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1288,
                "PatchRowcode": "+            pass"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1289,
                "PatchRowcode": "+        else:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1290,
                "PatchRowcode": "+            raise AssertionError(\"oh no!\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1291,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1292,
                "PatchRowcode": "+    def test_local_filesystem_access(self):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1293,
                "PatchRowcode": "+        \"\"\"No access to files allowed with allow_file=False"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1294,
                "PatchRowcode": "+        \"\"\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1295,
                "PatchRowcode": "+        try:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1296,
                "PatchRowcode": "+            parse(\"file:///etc/hosts/\", allow_file=False, allow_url=True)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1297,
                "PatchRowcode": "+        except etree.XMLSyntaxError:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1298,
                "PatchRowcode": "+            pass"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1299,
                "PatchRowcode": "+        else:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1300,
                "PatchRowcode": "+            raise AssertionError(\"oh no!\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1301,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1302,
                "PatchRowcode": "+        try:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1303,
                "PatchRowcode": "+            parse(\"/etc/hosts/\", allow_file=False)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1304,
                "PatchRowcode": "+        except etree.XMLSyntaxError:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1305,
                "PatchRowcode": "+            pass"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1306,
                "PatchRowcode": "+        else:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1307,
                "PatchRowcode": "+            raise AssertionError(\"oh no!\")"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1308,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 1273,
                "afterPatchRowNumber": 1309,
                "PatchRowcode": "     def test_dtd_retrieval(self):"
            },
            "40": {
                "beforePatchRowNumber": 1274,
                "afterPatchRowNumber": 1310,
                "PatchRowcode": "         pass"
            },
            "41": {
                "beforePatchRowNumber": 1275,
                "afterPatchRowNumber": 1311,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "# This file has two purposes:",
            "# 1. To provide a rough unit test of libtaxii.messages",
            "# 2. To provide examples of how to use libtaxii.messages",
            "",
            "import datetime",
            "import io",
            "import sys",
            "import unittest",
            "import warnings",
            "import inspect",
            "",
            "from dateutil.tz import tzutc",
            "from lxml import etree",
            "",
            "import libtaxii as t",
            "import libtaxii.messages_11 as tm11",
            "import libtaxii.taxii_default_query as tdq",
            "from libtaxii.validation import SchemaValidator",
            "from libtaxii.constants import *",
            "from libtaxii.common import *",
            "import six",
            "",
            "import sys",
            "",
            "# TODO: This is bad practice. Refactor this.",
            "# Set up some things used across multiple tests.",
            "",
            "full_stix_doc = \"\"\"<stix:STIX_Package",
            "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "    xmlns:stix=\"http://stix.mitre.org/stix-1\"",
            "    xmlns:indicator=\"http://stix.mitre.org/Indicator-2\"",
            "    xmlns:cybox=\"http://cybox.mitre.org/cybox-2\"",
            "    xmlns:DomainNameObj=\"http://cybox.mitre.org/objects#DomainNameObject-1\"",
            "    xmlns:cyboxVocabs=\"http://cybox.mitre.org/default_vocabularies-2\"",
            "    xmlns:stixVocabs=\"http://stix.mitre.org/default_vocabularies-1\"",
            "    xmlns:example=\"http://example.com/\"",
            "    xsi:schemaLocation=",
            "    \"http://stix.mitre.org/stix-1 ../stix_core.xsd",
            "    http://stix.mitre.org/Indicator-2 ../indicator.xsd",
            "    http://cybox.mitre.org/default_vocabularies-2 ../cybox/cybox_default_vocabularies.xsd",
            "    http://stix.mitre.org/default_vocabularies-1 ../stix_default_vocabularies.xsd",
            "    http://cybox.mitre.org/objects#DomainNameObject-1 ../cybox/objects/Domain_Name_Object.xsd\"",
            "    id=\"example:STIXPackage-f61cd874-494d-4194-a3e6-6b487dbb6d6e\"",
            "    timestamp=\"2014-05-08T09:00:00.000000Z\"",
            "    version=\"1.1.1\"",
            "    >",
            "    <stix:STIX_Header>",
            "        <stix:Title>Example watchlist that contains domain information.</stix:Title>",
            "        <stix:Package_Intent xsi:type=\"stixVocabs:PackageIntentVocab-1.0\">Indicators - Watchlist</stix:Package_Intent>",
            "    </stix:STIX_Header>",
            "    <stix:Indicators>",
            "        <stix:Indicator xsi:type=\"indicator:IndicatorType\" id=\"example:Indicator-2e20c5b2-56fa-46cd-9662-8f199c69d2c9\" timestamp=\"2014-05-08T09:00:00.000000Z\">",
            "            <indicator:Type xsi:type=\"stixVocabs:IndicatorTypeVocab-1.1\">Domain Watchlist</indicator:Type>",
            "            <indicator:Description>Sample domain Indicator for this watchlist</indicator:Description>",
            "            <indicator:Observable id=\"example:Observable-87c9a5bb-d005-4b3e-8081-99f720fad62b\">",
            "                <cybox:Object id=\"example:Object-12c760ba-cd2c-4f5d-a37d-18212eac7928\">",
            "                    <cybox:Properties xsi:type=\"DomainNameObj:DomainNameObjectType\" type=\"FQDN\">",
            "                        <DomainNameObj:Value condition=\"Equals\" apply_condition=\"ANY\">malicious1.example.com##comma##malicious2.example.com##comma##malicious3.example.com</DomainNameObj:Value>",
            "                    </cybox:Properties>",
            "                </cybox:Object>",
            "            </indicator:Observable>",
            "        </stix:Indicator>",
            "    </stix:Indicators>",
            "</stix:STIX_Package>\"\"\"",
            "",
            "xml_taxii_message_11 = '<taxii_11:Discovery_Request xmlns:taxii_11=\"http://taxii.mitre.org/messages/taxii_xml_binding-1.1\" message_id=\"1\"/>'",
            "json_taxii_message_11 = '{\"extended_headers\": {}, \"message_type\": \"Discovery_Request\", \"message_id\": \"1\"}'",
            "",
            "# Note that the \"*_old\" tests are just to make sure that backward-compatible aliases exist",
            "test1 = tdq.Test(capability_id=CM_CORE,  # Required",
            "                 relationship='equals',  # Required",
            "                 parameters={'value': 'Test value',",
            "                             'match_type': 'case_sensitive_string'}  # Each relationship defines which params are and are not required",
            "                 )",
            "",
            "test1_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_CORE,  # Required",
            "                                            relationship='equals',  # Required",
            "                                            parameters={'value': 'Test value',",
            "                                                        'match_type': 'case_sensitive_string'}  # Each relationship defines which params are and are not required",
            "                                            )",
            "",
            "test2 = tdq.Test(capability_id=CM_REGEX,  # Required",
            "                 relationship='matches',  # Required",
            "                 parameters={'value': '[A-Z]*',",
            "                             'case_sensitive': True})  # Each relationship defines which params are and are not required",
            "",
            "test2_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_REGEX,  # Required",
            "                                            relationship='matches',  # Required",
            "                                            parameters={'value': '[A-Z]*',",
            "                                                        'case_sensitive': True})  # Each relationship defines which params are and are not required",
            "",
            "test3 = tdq.Test(capability_id=CM_TIMESTAMP,  # Required",
            "                 relationship='greater_than',  # Required",
            "                 parameters={'value': datetime.datetime.now()})  # Each relationship defines which params are and are not required",
            "",
            "test3_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_TIMESTAMP,  # Required",
            "                                            relationship='greater_than',  # Required",
            "                                            parameters={'value': datetime.datetime.now()})  # Each relationship defines which params are and are not required",
            "",
            "criterion1 = tdq.Criterion(target='**', test=test1)",
            "criterion2 = tdq.Criterion(target='STIX_Package/Indicators/Indicator/@id', test=test2)",
            "criterion3 = tdq.Criterion(target='**/Description', test=test3)",
            "",
            "criterion1_old = tdq.DefaultQuery.Criterion(target='**', test=test1)",
            "criterion2_old = tdq.DefaultQuery.Criterion(target='STIX_Package/Indicators/Indicator/@id', test=test2)",
            "criterion3_old = tdq.DefaultQuery.Criterion(target='**/Description', test=test3)",
            "",
            "criteria1 = tdq.Criteria(operator=OP_AND, criterion=[criterion1])",
            "criteria2 = tdq.Criteria(operator=OP_OR, criterion=[criterion1, criterion2, criterion3])",
            "criteria3 = tdq.Criteria(operator=OP_AND, criterion=[criterion1, criterion3], criteria=[criteria2])",
            "",
            "criteria1_old = tdq.DefaultQuery.Criteria(operator=OP_AND, criterion=[criterion1])",
            "criteria2_old = tdq.DefaultQuery.Criteria(operator=OP_OR, criterion=[criterion1, criterion2, criterion3])",
            "criteria3_old = tdq.DefaultQuery.Criteria(operator=OP_AND, criterion=[criterion1, criterion3], criteria=[criteria2])",
            "",
            "query1 = tdq.DefaultQuery(CB_STIX_XML_11, criteria1)",
            "query2 = tdq.DefaultQuery(CB_STIX_XML_11, criteria3)",
            "",
            "subscription_parameters1 = tm11.SubscriptionParameters(",
            "    response_type=RT_COUNT_ONLY,  # Optional, defaults to FULL",
            "    content_bindings=[tm11.ContentBinding(CB_STIX_XML_11)],  # Optional. Absence means no restrictions on returned data",
            "    query=query1)  # Optional. Absence means no query",
            "",
            "push_parameters1 = tm11.PushParameters(",
            "    inbox_protocol=VID_TAXII_HTTPS_10,  # Required",
            "    inbox_address='https://example.com/inboxAddress/',  # Required",
            "    delivery_message_binding=VID_TAXII_XML_11)  # Required",
            "",
            "cb001 = tm11.ContentBlock(",
            "    content_binding=tm11.ContentBinding(CB_STIX_XML_11, subtype_ids=['test1']),  # Required",
            "    content='<STIX_Package/>',  # Required (This isn't real STIX)",
            "    timestamp_label=datetime.datetime.now(tzutc()),  # Optional",
            "    message='Hullo!',  # Optional",
            "    padding='The quick brown fox jumped over the lazy dogs.')  # Optional",
            "",
            "cb002 = tm11.ContentBlock(",
            "    content_binding=tm11.ContentBinding(CB_STIX_XML_11),  # Required",
            "    content=full_stix_doc)  # Required",
            "",
            "",
            "def round_trip_message(taxii_message, print_xml=False):",
            "    if not isinstance(taxii_message, tm11.TAXIIMessage):",
            "        raise ValueError('taxii_message was not an instance of TAXIIMessage')",
            "",
            "    # print '***** Message type = %s; id = %s' % (taxii_message.message_type, taxii_message.message_id)",
            "",
            "    xml_string = taxii_message.to_xml()",
            "",
            "    # The old way of validating",
            "    with warnings.catch_warnings():",
            "        warnings.simplefilter('ignore', DeprecationWarning)",
            "        valid = tm11.validate_xml(xml_string)",
            "    if valid is not True:",
            "        print('Bad XML was:')",
            "        try:",
            "            print(etree.tostring(taxii_message.to_etree(), pretty_print=True, encoding='utf-8'))",
            "        except Exception as e:",
            "            print(xml_string)",
            "        raise Exception('\\tFailure of test #1 - XML not schema valid: %s' % valid)",
            "",
            "    # The new way of validating",
            "    sv = SchemaValidator(SchemaValidator.TAXII_11_SCHEMA)",
            "    try:",
            "        result = sv.validate_string(xml_string)",
            "    except etree.XMLSyntaxError:",
            "        raise",
            "",
            "    if not result.valid:",
            "        errors = [item for item in result.error_log]",
            "        raise Exception('\\tFailure of test #1 - XML not schema valid: %s' % errors)",
            "",
            "    if print_xml:",
            "        print(etree.tostring(taxii_message.to_etree(), pretty_print=True, encoding='utf-8'))",
            "",
            "    msg_from_xml = tm11.get_message_from_xml(xml_string)",
            "    dictionary = taxii_message.to_dict()",
            "    msg_from_dict = tm11.get_message_from_dict(dictionary)",
            "    taxii_message.to_text()  # to_text() returns a string, this just makes sure the call succeeds but doesn't validate the response",
            "    if taxii_message != msg_from_xml:",
            "        print('\\t Failure of test #2 - running equals w/ debug:')",
            "        taxii_message.__eq__(msg_from_xml, True)",
            "        raise Exception('Test #2 failed - taxii_message != msg_from_xml')",
            "",
            "    if taxii_message != msg_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        taxii_message.__eq__(msg_from_dict, True)",
            "        raise Exception('Test #3 failed - taxii_message != msg_from_dict')",
            "",
            "    if msg_from_xml != msg_from_dict:",
            "        print('\\t Failure of test #4 - running equals w/ debug:')",
            "        msg_from_xml.__eq__(msg_from_dict, True)",
            "        raise Exception('Test #4 failed - msg_from_xml != msg_from_dict')",
            "",
            "    # print '***** All tests completed!'",
            "",
            "",
            "def round_trip_content_block(content_block):",
            "    if not isinstance(content_block, tm11.ContentBlock):",
            "        raise ValueError('content_block was not an instance of ContentBlock')",
            "",
            "    # print '***** Starting Content Block tests'",
            "",
            "    xml_string = content_block.to_xml()",
            "    block_from_xml = tm11.ContentBlock.from_xml(xml_string)",
            "    dictionary = content_block.to_dict()",
            "    block_from_dict = tm11.ContentBlock.from_dict(dictionary)",
            "    json_string = content_block.to_json()",
            "    block_from_json = tm11.ContentBlock.from_json(json_string)",
            "    content_block.to_text()",
            "",
            "    if content_block != block_from_xml:",
            "        print('\\t Failure of test #1 - running equals w/ debug:')",
            "        content_block.__eq__(block_from_xml, True)",
            "        raise Exception('Test #1 failed - content_block != block_from_xml')",
            "",
            "    if content_block != block_from_dict:",
            "        print('\\t Failure of test #2 - running equals w/ debug:')",
            "        content_block.__eq__(block_from_dict, True)",
            "        raise Exception('Test #2 failed - content_block != block_from_dict')",
            "",
            "    if block_from_xml != block_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        block_from_xml.__eq__(block_from_dict, True)",
            "        raise Exception('Test #3 failed - block_from_xml != block_from_dict')",
            "    if block_from_json != block_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        block_from_json.__eq__(block_from_dict, True)",
            "        raise Exception('Test #3 failed - block_from_json != block_from_dict')",
            "",
            "    # print '***** All tests completed!'",
            "",
            "",
            "class GenericParametersTests(unittest.TestCase):",
            "",
            "    # https://github.com/TAXIIProject/libtaxii/issues/165",
            "    def test_typo_165(self):",
            "        # Explicitly set `response_type` to None.",
            "        sub_params = tm11.SubscriptionParameters(response_type=None)",
            "        params_xml = sub_params.to_xml()",
            "",
            "        # When parsing from XML, if no response_type is provided, it should be",
            "        # set to RT_FULL.",
            "        new_params = tm11.SubscriptionParameters.from_xml(params_xml)",
            "        self.assertEqual(RT_FULL, new_params.response_type)",
            "",
            "",
            "class StatusMessageTests(unittest.TestCase):",
            "",
            "    def test_status_message_01(self):",
            "        sm01 = tm11.StatusMessage(",
            "            message_id='SM01',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_SUCCESS,  # Required",
            "            status_detail={'custom_status_detail_name': 'Custom status detail value',",
            "                           'Custom_detail_2': ['this one has', 'multiple values']},  # Required depending on Status Type. See spec for details",
            "            message='This is a test message'  # Optional",
            "        )",
            "        round_trip_message(sm01)",
            "",
            "    def test_status_message_02(self):",
            "        sm02 = tm11.StatusMessage(",
            "            message_id='SM02',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_SUCCESS,  # Required",
            "            status_detail=None,  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm02)",
            "",
            "    def test_status_message_03(self):",
            "        sm03 = tm11.StatusMessage(",
            "            message_id='SM03',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_DESTINATION_COLLECTION_ERROR,  # Required",
            "            status_detail={'ACCEPTABLE_DESTINATION': ['Collection1', 'Collection2']},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm03)",
            "",
            "    def test_status_message_04(self):",
            "        sm04 = tm11.StatusMessage(",
            "            message_id='SM04',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_INVALID_RESPONSE_PART,  # Required",
            "            status_detail={'MAX_PART_NUMBER': 4},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm04)",
            "",
            "    def test_status_message_05(self):",
            "        sm05 = tm11.StatusMessage(",
            "            message_id='SM05',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_NOT_FOUND,  # Required",
            "            status_detail={'ITEM': 'Collection1'},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm05)",
            "",
            "    def test_status_message_06(self):",
            "        sm06 = tm11.StatusMessage(",
            "            message_id='SM06',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_PENDING,  # Required",
            "            status_detail={'ESTIMATED_WAIT': 900, 'RESULT_ID': 'Result1', 'WILL_PUSH': False},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm06)",
            "",
            "    def test_status_message_07(self):",
            "        sm07 = tm11.StatusMessage(",
            "            message_id='SM07',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_RETRY,  # Required",
            "            status_detail={'ESTIMATED_WAIT': 900},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm07)",
            "",
            "    def test_status_message_08(self):",
            "        sm08 = tm11.StatusMessage(",
            "            message_id='SM08',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_MESSAGE_BINDING,  # Required",
            "            status_detail={'SUPPORTED_BINDING': [VID_TAXII_XML_10, VID_TAXII_XML_11]},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm08)",
            "",
            "    def test_status_message_09(self):",
            "        sm09 = tm11.StatusMessage(",
            "            message_id='SM09',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_CONTENT_BINDING,  # Required",
            "            status_detail={'SUPPORTED_CONTENT': tm11.ContentBinding(binding_id=CB_STIX_XML_101, subtype_ids=['subtype1', 'subtype2'])},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm09)",
            "",
            "    def test_status_message_10(self):",
            "        sm09 = tm11.StatusMessage(",
            "            message_id='SM10',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_CONTENT_BINDING,  # Required",
            "            status_detail={'SUPPORTED_CONTENT': [tm11.ContentBinding(binding_id=CB_STIX_XML_101, subtype_ids=['subtype1', 'subtype2']), tm11.ContentBinding(binding_id=CB_STIX_XML_11)]},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm09)",
            "",
            "    def test_status_message_11(self):",
            "        # Per https://github.com/TAXIIProject/libtaxii/issues/111",
            "        kwargs = {'message_id': '1', 'in_response_to': '2', 'status_type': ST_FAILURE, 'message': {}}",
            "        self.assertRaises(ValueError, tm11.StatusMessage, **kwargs)",
            "",
            "    def test_status_message_12(self):",
            "        # https://github.com/TAXIIProject/libtaxii/issues/230",
            "        collections = ['Collection1', 'Collection2', 'Collection3']",
            "        sm12 = tm11.StatusMessage(",
            "            message_id='SM12',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_DESTINATION_COLLECTION_ERROR,  # Required",
            "            status_detail={'ACCEPTABLE_DESTINATION': collections}, # Add 3 collections to trigger the bug",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm12)",
            "",
            "        self.assertEqual(sm12.status_detail['ACCEPTABLE_DESTINATION'], collections)",
            "",
            "        # Parse the XML",
            "        parsed_sm12 = tm11.StatusMessage.from_xml(sm12.to_xml())",
            "",
            "        # If the bug is present the value returned will be:",
            "        # [['Collection1', 'Collection2'], 'Collection3']",
            "        self.assertEqual(parsed_sm12.status_detail['ACCEPTABLE_DESTINATION'], collections)",
            "",
            "    # TODO: TEst the query status types",
            "",
            "    def test_xml_ext_header(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of etree._Element",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': parse('<x:element xmlns:x=\"#foo\">'",
            "                                       '<x:subelement attribute=\"something\"/>'",
            "                                       '</x:element>')}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "",
            "    def test_xml_ext_header2(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of etree._Element",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': parse('<x:element xmlns:x=\"#foo\">'",
            "                                       '<x:subelement attribute=\"something\"/>'",
            "                                       '</x:element>')}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "        # print etree.tostring(etree.XML(sm.to_xml(pretty_print=True)), pretty_print=True)",
            "",
            "    def test_xml_ext_header3(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of string",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': '<x:element xmlns:x=\"#foo\">'",
            "                                 '<x:subelement attribute=\"something\"/>'",
            "                                 '</x:element>'}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "        # print etree.tostring(etree.XML(sm.to_xml(pretty_print=True)), pretty_print=True)",
            "",
            "",
            "class DiscoveryRequestTests(unittest.TestCase):",
            "",
            "    def test_discovery_request(self):",
            "        discovery_request1 = tm11.DiscoveryRequest(",
            "            message_id=tm11.generate_message_id(),  # Required",
            "            # Extended headers are optional for every message type, but demonstrated here",
            "            extended_headers={'ext_header1': 'value1', 'ext_header2': 'value2'})  # Optional.",
            "        round_trip_message(discovery_request1)",
            "",
            "",
            "class DiscoveryResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Create query information to use in the ServiceInstances",
            "        tei_01 = tdq.DefaultQueryInfo.TargetingExpressionInfo(",
            "            targeting_expression_id=CB_STIX_XML_10,  # Required. Indicates a supported targeting vocabulary (in this case STIX 1.1)",
            "            preferred_scope=[],  # At least one of Preferred/Allowed must be present. Indicates Preferred and allowed search scope.",
            "            allowed_scope=['**'])  # This example has no preferred scope, and allows any scope",
            "",
            "        tei_02 = tdq.DefaultQueryInfo.TargetingExpressionInfo(",
            "            targeting_expression_id=CB_STIX_XML_11,  # required. Indicates a supported targeting vocabulary (in this case STIX 1.1)",
            "            preferred_scope=['STIX_Package/Indicators/Indicator/**'],  # At least one of Preferred/Allowed must be present. Indicates Preferred and allowed search scope.",
            "            allowed_scope=[])  # This example prefers the Indicator scope and allows no other scope",
            "",
            "        tdq1 = tdq.DefaultQueryInfo(",
            "            targeting_expression_infos=[tei_01, tei_02],  # Required, 1-n. Indicates what targeting expressions are supported",
            "            capability_modules=[CM_CORE])  # Required, 1-n. Indicates which capability modules can be used.",
            "",
            "        tdq2 = tdq.DefaultQueryInfo(",
            "            targeting_expression_infos=[tei_02],  # Required, 1-n. Indicates what targeting expressions are supported",
            "            capability_modules=[CM_REGEX])  # Required, 1-n. Indicates which capability modules can be used.",
            "",
            "        # Create ServiceInstances to use in tests",
            "        self.si1 = tm11.ServiceInstance(",
            "            service_type=SVC_POLL,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/poll/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            available=True,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message.',",
            "            supported_query=[tdq1])  # Optional for service_type=POLL",
            "",
            "        self.si2 = tm11.ServiceInstance(",
            "            service_type=SVC_POLL,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/poll/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            available=True,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message.',",
            "            supported_query=[tdq1, tdq2])  # Optional for service_type=POLL",
            "",
            "        self.si3 = tm11.ServiceInstance(",
            "            service_type=SVC_INBOX,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/inbox/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            inbox_service_accepted_content=[tm11.ContentBinding(CB_STIX_XML_11),",
            "                                            tm11.ContentBinding(CB_STIX_XML_101),",
            "                                            tm11.ContentBinding(CB_STIX_XML_10)],  # Optional. Defaults to \"accepts all content\"",
            "            available=False,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "        self.si4 = tm11.ServiceInstance(",
            "            service_type=SVC_DISCOVERY,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/discovery/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "        self.si5 = tm11.ServiceInstance(",
            "            service_type=SVC_COLLECTION_MANAGEMENT,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/collection_management/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "    def test_discovery_response_01(self):",
            "        # Create and test various discovery responses",
            "        discovery_response01 = tm11.DiscoveryResponse(",
            "            message_id='DR01',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=None)  # Optional.",
            "        round_trip_message(discovery_response01)",
            "",
            "    def test_discovery_response_02(self):",
            "        discovery_response02 = tm11.DiscoveryResponse(",
            "            message_id='DR02',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si3, self.si5])  # Optional.",
            "        round_trip_message(discovery_response02)",
            "",
            "    def test_discovery_response_03(self):",
            "        discovery_response03 = tm11.DiscoveryResponse(",
            "            message_id='DR03',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si2, self.si4])  # Optional.",
            "        round_trip_message(discovery_response03)",
            "",
            "    def test_discovery_response_04(self):",
            "        discovery_response04 = tm11.DiscoveryResponse(",
            "            message_id='DR04',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si2, self.si4])  # Optional.",
            "        round_trip_message(discovery_response04)",
            "",
            "    def test_discovery_response_05(self):",
            "        discovery_response05 = tm11.DiscoveryResponse(",
            "            message_id='DR05',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si2, self.si3, self.si4, self.si5])  # Optional.",
            "        round_trip_message(discovery_response05)",
            "",
            "    def test_discovery_response_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   DiscoveryResponse.ServiceInstance",
            "        service = tm11.DiscoveryResponse.ServiceInstance(",
            "            service_type=SVC_COLLECTION_MANAGEMENT,",
            "            services_version=VID_TAXII_SERVICES_11,",
            "            protocol_binding=VID_TAXII_HTTP_10,",
            "            service_address='http://example.com/collection_management/',",
            "            message_bindings=[VID_TAXII_XML_11])",
            "",
            "        response = tm11.DiscoveryResponse(",
            "            message_id='DR05',",
            "            in_response_to='TheSecondIdentifier',",
            "            service_instances=[service])",
            "",
            "        round_trip_message(response)",
            "",
            "",
            "class CollectionInformationRequestTests(unittest.TestCase):",
            "",
            "    def test_collection_information_request_01(self):",
            "        cir01 = tm11.CollectionInformationRequest(",
            "            message_id='CIReq01'  # Required",
            "        )",
            "        round_trip_message(cir01)",
            "",
            "",
            "class CollectionInformationResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Instantiate a push methods",
            "        push_method1 = tm11.PushMethod(",
            "            push_protocol=VID_TAXII_HTTP_10,  # Required",
            "            push_message_bindings=[VID_TAXII_XML_11])  # Required",
            "",
            "        # Instantiate Poll Services",
            "        poll_service1 = tm11.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            poll_address='https://example.com/TheGreatestPollService',  # Required",
            "            poll_message_bindings=[VID_TAXII_XML_11])  # Required, at least one item must be present in the list",
            "",
            "        poll_service2 = tm11.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTP_10,  # Required",
            "            poll_address='http://example.com/TheOtherPollService',  # Required",
            "            poll_message_bindings=[VID_TAXII_XML_11])  # Required, at least one item must be present in the list",
            "",
            "        # Instantiate Subscription Methods",
            "        subs_method1 = tm11.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            subscription_address='https://example.com/TheSubscriptionService/',  # Required",
            "            subscription_message_bindings=[VID_TAXII_XML_11])  # Required - at least one item must be present in the list",
            "",
            "        subs_method2 = tm11.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTP_10,  # Required",
            "            subscription_address='http://example.com/TheSubscriptionService/',  # Required",
            "            subscription_message_bindings=[VID_TAXII_XML_11])  # Required - at least one item must be present in the list",
            "",
            "        # Instantiate Inbox Services",
            "        inbox_service1 = tm11.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # required",
            "            inbox_address='https://example.com/inbox/',  # Required",
            "            inbox_message_bindings=[VID_TAXII_XML_11],  # Required",
            "            supported_contents=None)  # Optional - None means \"all are supported\"",
            "",
            "        inbox_service2 = tm11.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # required",
            "            inbox_address='https://example.com/inbox/',  # Required",
            "            inbox_message_bindings=[VID_TAXII_XML_11],  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_11, subtype_ids=['exmaple1', 'example2'])])  # Optional - None means \"all are supported\"",
            "",
            "        # Instantiate collections",
            "        self.collection1 = tm11.CollectionInformation(",
            "            collection_name='collection1',  # Required",
            "            collection_type=CT_DATA_FEED,  # Optional. Defaults to 'Data Feed'",
            "            available=False,  # Optional. Defaults to None, which means \"unknown\"",
            "            collection_description='This is a collection',  # Required",
            "            collection_volume=4,  # Optional - indicates typical number of messages per day",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_101)],  # Optional, absence indicates all content bindings",
            "            push_methods=[push_method1],  # Optional - absence indicates no push methods",
            "            polling_service_instances=[poll_service1, poll_service2],  # Optional - absence indicates no polling services",
            "            subscription_methods=[subs_method1, subs_method2],  # optional - absence means no subscription services",
            "            receiving_inbox_services=[inbox_service1, inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "        self.collection2 = tm11.CollectionInformation(",
            "            collection_name='collection2',  # Required",
            "            collection_type=CT_DATA_SET,  # Optional. Defaults to 'Data Feed'",
            "            collection_description='Warrgghghglble.')  # Required",
            "",
            "        self.collection3 = tm11.CollectionInformation(",
            "            collection_name='collection3',  # Required",
            "            collection_description='You must pay all the dollars to have this information.',  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_10), tm11.ContentBinding(CB_STIX_XML_11)],  # Optional",
            "            polling_service_instances=[poll_service2],  # Optional - absence indicates no polling services",
            "            subscription_methods=[subs_method2],  # optional - absence means no subscription services",
            "            receiving_inbox_services=[inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "        self.collection4 = tm11.CollectionInformation(",
            "            collection_name='collection4',  # Required",
            "            collection_description='So improve information. Much amaze.',  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_101, subtype_ids=['ex1', 'ex2', 'ex3'])],  # Optional",
            "            receiving_inbox_services=[inbox_service1, inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "    def test_collection_information_response_01(self):",
            "        collection_response1 = tm11.CollectionInformationResponse(",
            "            message_id='CIR01',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response1)",
            "",
            "    def test_collection_information_response_02(self):",
            "        collection_response2 = tm11.CollectionInformationResponse(",
            "            message_id='CIR02',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1, self.collection2, self.collection3, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response2)",
            "",
            "    def test_collection_information_response_03(self):",
            "        collection_response3 = tm11.CollectionInformationResponse(",
            "            message_id='CIR03',  # Required",
            "            in_response_to='0')  # Required - should be the ID of the message tha this message is a response to",
            "        round_trip_message(collection_response3)",
            "",
            "    def test_collection_information_response_04(self):",
            "        collection_response4 = tm11.CollectionInformationResponse(",
            "            message_id='CIR04',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response4)",
            "",
            "    def test_collection_information_response_05(self):",
            "        collection_response5 = tm11.CollectionInformationResponse(",
            "            message_id='CIR05',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection2, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response5)",
            "",
            "    def test_collection_information_response_deprecated(self):",
            "        # Test deprecated nested forms:",
            "        #   CollectionInformationResponse.CollectionInformation",
            "        #   CollectionInformationResponse.CollectionInformation.PushMethod",
            "        #   CollectionInformationResponse.CollectionInformation.PollingServiceInstance",
            "        #   CollectionInformationResponse.CollectionInformation.SubscriptionMethod",
            "        #   CollectionInformationResponse.CollectionInformation.ReceivingInboxService",
            "        push_method = tm11.CollectionInformationResponse.CollectionInformation.PushMethod(",
            "            push_protocol=VID_TAXII_HTTP_10,",
            "            push_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        poll_service = tm11.CollectionInformationResponse.CollectionInformation.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/TheGreatestPollService',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        subs_method = tm11.CollectionInformationResponse.CollectionInformation.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTPS_10,",
            "            subscription_address='https://example.com/TheSubscriptionService/',",
            "            subscription_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        inbox_service = tm11.CollectionInformationResponse.CollectionInformation.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,",
            "            inbox_address='https://example.com/inbox/',",
            "            inbox_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        collection = tm11.CollectionInformationResponse.CollectionInformation(",
            "            collection_name='collection1',",
            "            collection_description='This is a collection',",
            "            push_methods=[push_method],",
            "            polling_service_instances=[poll_service],",
            "            subscription_methods=[subs_method],",
            "            receiving_inbox_services=[inbox_service])",
            "",
            "        response = tm11.CollectionInformationResponse(",
            "            message_id='CIR05',",
            "            in_response_to='0',",
            "            collection_informations=[collection])",
            "",
            "        round_trip_message(response)",
            "",
            "",
            "class ManageCollectionSubscriptionRequestTests(unittest.TestCase):",
            "",
            "    def test_subs_req1(self):",
            "        subs_req1 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq01',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection1',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters1,  # optional - absence means there are not any subscription parameters",
            "            push_parameters=push_parameters1)  # Optional - absence means push messaging not requested",
            "        round_trip_message(subs_req1)",
            "",
            "    def test_subs_req2(self):",
            "        subscription_parameters2 = tm11.SubscriptionParameters(",
            "            response_type=RT_FULL,  # Optional, defaults to FULL",
            "            # content_bindings = [tm11.ContentBinding(CB_STIX_XML_11)],#Optional. Absence means no restrictions on returned data",
            "            query=query2)  # Optional. Absence means no query",
            "        subs_req2 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq02',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters2)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req2)",
            "",
            "    def test_subs_req3(self):",
            "        subscription_parameters3 = tm11.SubscriptionParameters()  # Use all the defaults",
            "        subs_req3 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq03',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters3)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req3)",
            "",
            "    def test_subs_req4(self):",
            "        subs_req4 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq04',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2')  # Required",
            "        # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "        # subscription_parameters = subscription_parameters2,#optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req4)",
            "",
            "    def test_subs_req5(self):",
            "        subs_req5 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq05',  # Required",
            "            action=ACT_STATUS,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req5)",
            "",
            "    def test_subs_req6(self):",
            "        subs_req6 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq06',  # Required",
            "            action=ACT_STATUS,  # Required",
            "            collection_name='collection2')  # Required",
            "        # subscription_id = 'id1') #Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req6)",
            "",
            "    def test_subs_req7(self):",
            "        subs_req7 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq07',  # Required",
            "            action=ACT_PAUSE,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req7)",
            "",
            "    def test_subs_req8(self):",
            "        subs_req8 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq08',  # Required",
            "            action=ACT_RESUME,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req8)",
            "",
            "    def test_subs_req9(self):",
            "        # https://github.com/TAXIIProject/libtaxii/pull/237",
            "        subscription = \"\"\"{\"content_bindings\": [{\"binding_id\": \"urn:stix.mitre.org:xml:1.2\"}], \"query\": null, \"response_type\": \"FULL\"}\"\"\"",
            "        subscription_dict = json.loads(subscription)",
            "        subscription_parameters9 = tm11.SubscriptionParameters(**subscription_dict)  # Use all the defaults",
            "        subs_req9 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq09',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters9)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req9)",
            "",
            "",
            "class ManageCollectionSubscriptionResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        poll_instance1 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll1/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        poll_instance2 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll2/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "        poll_instance3 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll3/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        self.subs1 = tm11.SubscriptionInstance(",
            "            status=SS_ACTIVE,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            subscription_parameters=subscription_parameters1,  # Optional - should be an echo of the request",
            "            push_parameters=push_parameters1,  # Optional - should be an echo of the request",
            "            poll_instances=[poll_instance1, poll_instance2, poll_instance3],  # Optional",
            "        )",
            "",
            "    def test_subs_resp1(self):",
            "        subs2 = tm11.SubscriptionInstance(",
            "            status=SS_PAUSED,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            subscription_parameters=subscription_parameters1,  # Optional - should be an echo of the request",
            "            push_parameters=push_parameters1,  # Optional - should be an echo of the request",
            "            # poll_instances = [poll_instance1, poll_instance2, poll_instance3],#Optional",
            "        )",
            "        subs3 = tm11.SubscriptionInstance(",
            "            status=SS_PAUSED,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            # subscription_parameters = subscription_parameters1,#Optional - should be an echo of the request",
            "            # push_parameters = delivery_parameters1,#Optional - should be an echo of the request",
            "            # poll_instances = [poll_instance1, poll_instance2, poll_instance3],#Optional",
            "        )",
            "        subs_resp1 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp01',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            message='Hullo!',  # Optional",
            "            subscription_instances=[self.subs1, subs2, subs3],  # Optional",
            "        )",
            "        round_trip_message(subs_resp1)",
            "",
            "    def test_subs_resp2(self):",
            "        subs_resp2 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp02',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            # message = 'Hullo!', #Optional",
            "            # subscription_instances = [subs1, subs2, subs3],#Optional",
            "        )",
            "        round_trip_message(subs_resp2)",
            "",
            "    def test_subs_resp3(self):",
            "        subs_resp3 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp03',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            # message = 'Hullo!', #Optional",
            "            subscription_instances=[self.subs1],  # Optional",
            "        )",
            "        round_trip_message(subs_resp3)",
            "",
            "    def test_subs_resp4(self):",
            "        subs_resp4 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp04',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            message='Hullo!',  # Optional",
            "            # subscription_instances = [subs1, subs2, subs3],#Optional",
            "        )",
            "        round_trip_message(subs_resp4)",
            "",
            "    def test_subs_resp_deprecated(self):",
            "        # Test deprecated nested forms:",
            "        #   ManageCollectionSubscriptionResponse.PollInstance",
            "        #   ManageCollectionSubscriptionResponse.SubscriptionInstance",
            "        poll = tm11.ManageCollectionSubscriptionResponse.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll1/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        subscription = tm11.ManageCollectionSubscriptionResponse.SubscriptionInstance(",
            "            subscription_id='Subs001',",
            "            subscription_parameters=subscription_parameters1,",
            "            push_parameters=push_parameters1,",
            "            poll_instances=[poll])",
            "",
            "        subs_resp = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp01',",
            "            in_response_to='xyz',",
            "            collection_name='abc123',",
            "            subscription_instances=[subscription])",
            "",
            "        round_trip_message(subs_resp)",
            "",
            "",
            "class PollRequestTests(unittest.TestCase):",
            "",
            "    def test_poll_req1(self):",
            "        poll_req1 = tm11.PollRequest(",
            "            message_id='PollReq01',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            subscription_id='12345',  # Optional - one of this or poll_parameters MUST be present.",
            "            poll_parameters=None)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req1)",
            "",
            "    def test_poll_req2(self):",
            "        poll_req2 = tm11.PollRequest(",
            "            message_id='PollReq02',  # Required",
            "            collection_name='collection100',  # Required",
            "            subscription_id='Kenneth Coal Collection',  # Optional - one of this or poll_parameters MUST be present.",
            "            poll_parameters=None)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req2)",
            "",
            "    def test_poll_req3(self):",
            "        delivery_parameters1 = tm11.DeliveryParameters(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            inbox_address='https://example.com/inboxAddress/',  # Required",
            "            delivery_message_binding=VID_TAXII_XML_11)  # Required",
            "",
            "        poll_params1 = tm11.PollParameters(",
            "            allow_asynch=False,  # Optional, defaults to False",
            "            response_type=RT_COUNT_ONLY,  # Optional, defaults to RT_FULL",
            "            content_bindings=[tm11.ContentBinding(binding_id=CB_STIX_XML_11)],  # Optional, defaults to None, which means \"all bindings are accepted in response\"",
            "            query=query1,  # Optional - defaults to None",
            "            delivery_parameters=delivery_parameters1)  # Optional - defaults to None",
            "",
            "        poll_req3 = tm11.PollRequest(",
            "            message_id='PollReq03',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params1)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req3)",
            "",
            "    def test_poll_req4(self):",
            "        poll_params2 = tm11.PollParameters()",
            "        poll_req4 = tm11.PollRequest(",
            "            message_id='PollReq04',  # Required",
            "            collection_name='collection100',  # Required",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params2)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req4)",
            "",
            "    def test_poll_req5(self):",
            "        poll_params3 = tm11.PollParameters(query=query1)  # Optional - defaults to None)#Optional - defaults to None",
            "        poll_req5 = tm11.PollRequest(",
            "            message_id='PollReq05',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params3)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req5)",
            "",
            "    def test_poll_req_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   PollRequest.PollParameters",
            "        params = tm11.PollRequest.PollParameters()",
            "        poll = tm11.PollRequest(",
            "            message_id='PollReq05',",
            "            collection_name='collection100',",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),",
            "            poll_parameters=params)",
            "        round_trip_message(poll)",
            "",
            "",
            "class PollResponseTests(unittest.TestCase):",
            "",
            "    def test_poll_resp1(self):",
            "        poll_resp1 = tm11.PollResponse(",
            "            message_id='PollResp1',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            more=True,  # Optional - defaults to false",
            "            result_id='123',  # Optional",
            "            result_part_number=1,  # optional",
            "            subscription_id='24',  # optional",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for data feeds, prohibited for data sets",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # required for data feeds, prohibited for data sets",
            "            record_count=tm11.RecordCount(record_count=22, partial_count=False),",
            "            message='Woooooooo',  # optional",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp1)",
            "",
            "    def test_poll_resp2(self):",
            "        poll_resp2 = tm11.PollResponse(",
            "            message_id='PollResp2',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah')  # Required",
            "        round_trip_message(poll_resp2)",
            "",
            "    def test_poll_resp3(self):",
            "        poll_resp3 = tm11.PollResponse(",
            "            message_id='PollResp3',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            result_id='123',  # Optional",
            "            subscription_id='24',  # optional",
            "            record_count=tm11.RecordCount(record_count=22),",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp3)",
            "",
            "    def test_poll_resp4(self):",
            "        poll_resp4 = tm11.PollResponse(",
            "            message_id='PollResp4',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            # content_blocks = [cb001, cb002])#optional",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp4)",
            "",
            "    def test_poll_resp5(self):",
            "        poll_resp5 = tm11.PollResponse(",
            "            message_id='PollResp5',",
            "            in_response_to='blah',",
            "            collection_name='foo',",
            "            result_part_number=10,",
            "            content_blocks=[])",
            "        round_trip_message(poll_resp5)",
            "",
            "",
            "class InboxMessageTests(unittest.TestCase):",
            "",
            "    def test_inbox1(self):",
            "        subs_info1 = tm11.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',  # Required",
            "            subscription_id='SubsId021',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for data feeds, prohibited for data sets",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()))  # Optional for data feeds, prohibited for data sets",
            "        inbox1 = tm11.InboxMessage(",
            "            message_id='Inbox1',  # Required",
            "            result_id='123',  # Optional",
            "            destination_collection_names=['collection1', 'collection2'],  # Optional",
            "            message='Hello!',  # Optional",
            "            subscription_information=subs_info1,  # Optional",
            "            record_count=tm11.RecordCount(22, partial_count=True),  # Optional",
            "            content_blocks=[cb001, cb002])",
            "        round_trip_message(inbox1)",
            "",
            "    def test_inbox2(self):",
            "        inbox2 = tm11.InboxMessage(message_id='Inbox1')  # Required",
            "        round_trip_message(inbox2)",
            "",
            "    def test_inbox3(self):",
            "        subs_info2 = tm11.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',  # Required",
            "            subscription_id='SubsId021')  # Required",
            "",
            "        inbox3 = tm11.InboxMessage(",
            "            message_id='Inbox3',  # Required",
            "            result_id='123',  # Optional",
            "            destination_collection_names=['collection1', 'collection2'],  # Optional",
            "            subscription_information=subs_info2,  # Optional",
            "            content_blocks=[cb002])",
            "        round_trip_message(inbox3)",
            "",
            "    def test_inbox_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   InboxMessage.SubscriptionInformation",
            "        subscription = tm11.InboxMessage.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',",
            "            subscription_id='SubsId021')",
            "",
            "        inbox = tm11.InboxMessage(",
            "            message_id='InboxMsg0001',",
            "            subscription_information=subscription,",
            "            content_blocks=[cb002])",
            "        round_trip_message(inbox)",
            "",
            "",
            "class PollFulfillmentTests(unittest.TestCase):",
            "",
            "    def test_poll_fulfillment1(self):",
            "        pf1 = tm11.PollFulfillmentRequest(",
            "            message_id='pf1',  # required",
            "            collection_name='1-800-collection',  # required",
            "            result_id='123',  # required",
            "            result_part_number=1)  # required",
            "",
            "        round_trip_message(pf1)",
            "",
            "",
            "class SubscriptionInformationTests(unittest.TestCase):",
            "",
            "    # See https://github.com/TAXIIProject/libtaxii/issues/110",
            "    def test_exclusive_begin_timestamp_label_must_be_datetime(self):",
            "        params = {",
            "            'collection_name': 'foo',",
            "            'subscription_id': 'baz',",
            "            'exclusive_begin_timestamp_label': '100'",
            "        }",
            "        self.assertRaises(ValueError, tm11.SubscriptionInformation, **params)",
            "",
            "    # See https://github.com/TAXIIProject/libtaxii/issues/110",
            "    def test_110_2(self):",
            "        \"\"\"",
            "        Test for https://github.com/TAXIIProject/libtaxii/issues/110",
            "        :return:",
            "        \"\"\"",
            "        params = {",
            "            'collection_name': 'foo',",
            "            'subscription_id': 'baz',",
            "            'inclusive_end_timestamp_label': '100'",
            "        }",
            "        self.assertRaises(ValueError, tm11.SubscriptionInformation, **params)",
            "",
            "",
            "class ContentBlockTests(unittest.TestCase):",
            "",
            "    def test_content_block01(self):",
            "        cb1 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>')",
            "        round_trip_content_block(cb1)",
            "",
            "    def test_content_block02(self):",
            "        cb2 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content=six.StringIO('<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>'))",
            "        round_trip_content_block(cb2)",
            "",
            "    def test_content_block03(self):",
            "        cb3 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content=parse('<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>'))",
            "        round_trip_content_block(cb3)",
            "",
            "    def test_content_block04(self):",
            "        cb4 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='<Something thats not XML')",
            "        round_trip_content_block(cb4)",
            "",
            "    def test_content_block05(self):",
            "        cb5 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='Something thats not XML <xml/>')",
            "        round_trip_content_block(cb5)",
            "",
            "    def test_content_block06(self):",
            "        cb6 = tm11.ContentBlock(content_binding='RandomUnicodeString', content=six.text_type('abcdef'))",
            "        round_trip_content_block(cb6)",
            "",
            "    def test_content_block07(self):",
            "        cb7 = tm11.ContentBlock(content_binding='something',",
            "                                content='something',",
            "                                message='a message',",
            "                                padding='the padding!')",
            "        round_trip_content_block(cb7)",
            "",
            "",
            "class TestXmlAttacks(unittest.TestCase):",
            "    \"\"\"",
            "    List of XML attacks can be found here: https://pypi.python.org/pypi/defusedxml#python-xml-libraries",
            "    Thanks to @guidovranken for pointing these out",
            "",
            "    \"\"\"",
            "",
            "    def test_billion_laughs(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the \"billion laughs\" attack on libtaxii",
            "        http://en.wikipedia.org/wiki/Billion_laughs",
            "        :return:",
            "        \"\"\"",
            "",
            "        billion_laughs = \"\"\"<!DOCTYPE lolz [",
            "                             <!ENTITY lol \"lol\">",
            "                             <!ELEMENT lolz (#PCDATA)>",
            "                             <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">",
            "                             <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">",
            "                           ]>",
            "                           <lolz>&lol1;</lolz>\"\"\"",
            "",
            "        e = parse(billion_laughs)",
            "",
            "        if e.text is not None:",
            "            raise ValueError(\"The text of e was not None, meaning a real attack would have succeeded!\")",
            "",
            "    def test_guadratic_blowup(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the quadratic blowup attack",
            "        http://msdn.microsoft.com/en-us/magazine/ee335713.aspx",
            "        :return:",
            "        \"\"\"",
            "        q_blowup = \"\"\"<!DOCTYPE kaboom [",
            "                        <!ENTITY a \"aaaaaaaaaaaaaaaaaaa\">",
            "                      ]>",
            "                      <kaboom>&a;</kaboom>",
            "                   \"\"\"",
            "",
            "        e = parse(q_blowup)",
            "",
            "        if e.text is not None:",
            "            raise ValueError('The text of e was not None, meaning a real attack would have succeeded!')",
            "",
            "    def test_xee_remote(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the remote XEE attack",
            "        https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing",
            "        :return:",
            "        \"\"\"",
            "",
            "        xee_remote = \"\"\"<!DOCTYPE foo [",
            "                          <!ELEMENT foo ANY >",
            "                          <!ENTITY xxe SYSTEM \"http://www.mitre.org\" >]>",
            "                        <foo>&xxe;</foo>",
            "                      \"\"\"",
            "",
            "        # If an XML Syntax Error is received, an attack would have succeeded",
            "",
            "        try:",
            "            e = parse(xee_remote)",
            "        except etree.XMLSyntaxError:",
            "            raise ValueError(\"An XML Syntax Error was raised, meaning a real attack would have succeeded!\")",
            "",
            "    def test_xee_local(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the local XEE attack",
            "        https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing",
            "        :return:",
            "        \"\"\"",
            "",
            "        xee_local = \"\"\"<!DOCTYPE foo [",
            "                          <!ELEMENT foo ANY >",
            "                          <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>",
            "                        <foo>&xxe;</foo>",
            "                      \"\"\"",
            "        # If an XML Syntax Error is received, an attack would have succeeded",
            "",
            "        try:",
            "            e = parse(xee_local)",
            "        except etree.XMLSyntaxError:",
            "            raise ValueError(\"An XML Syntax Error was raised, meaning a real attack would have succeeded!\")",
            "",
            "    def test_dtd_retrieval(self):",
            "        pass",
            "",
            "    def test_gzip_bomb(self):",
            "        pass",
            "",
            "    def test_xpath(self):",
            "        pass",
            "",
            "    def test_xslt(self):",
            "        pass",
            "",
            "    def test_xinclude(self):",
            "        pass",
            "",
            "class VersionsTest(unittest.TestCase):",
            "",
            "    def test_01(self):",
            "        \"\"\"",
            "        Tests that all tm10 objects have a version attribute",
            "",
            "        :return:",
            "        \"\"\"",
            "        for name, obj in inspect.getmembers(tm11, inspect.isclass):",
            "            # Certain classes are excluded from this test:",
            "            if name in ('TAXIIBase', 'UnsupportedQueryException', '_StatusDetail'):",
            "                continue",
            "            obj.version",
            "",
            "",
            "# Encodings pulled from: https://docs.python.org/2/library/codecs.html",
            "PYTHON_ENCODINGS = ['ascii',",
            "                     'big5',",
            "                     'big5hkscs',",
            "                     'cp037',",
            "                     'cp424',",
            "                     'cp437',",
            "                     'cp500',",
            "                     'cp720',",
            "                     'cp737',",
            "                     'cp775',",
            "                     'cp850',",
            "                     'cp852',",
            "                     'cp855',",
            "                     'cp856',",
            "                     'cp857',",
            "                     'cp858',",
            "                     'cp860',",
            "                     'cp861',",
            "                     'cp862',",
            "                     'cp863',",
            "                     'cp864',",
            "                     'cp865',",
            "                     'cp866',",
            "                     'cp869',",
            "                     'cp874',",
            "                     'cp875',",
            "                     'cp932',",
            "                     'cp949',",
            "                     'cp950',",
            "                     'cp1006',",
            "                     'cp1026',",
            "                     'cp1140',",
            "                     'cp1250',",
            "                     'cp1251',",
            "                     'cp1252',",
            "                     'cp1253',",
            "                     'cp1254',",
            "                     'cp1255',",
            "                     'cp1256',",
            "                     'cp1257',",
            "                     'cp1258',",
            "                     'euc_jp',",
            "                     'euc_jis_2004',",
            "                     'euc_jisx0213',",
            "                     'euc_kr',",
            "                     'gb2312',",
            "                     'gbk',",
            "                     'gb18030',",
            "                     'hz',",
            "                     'iso2022_jp',",
            "                     'iso2022_jp_1',",
            "                     'iso2022_jp_2',",
            "                     'iso2022_jp_2004',",
            "                     'iso2022_jp_3',",
            "                     'iso2022_jp_ext',",
            "                     'iso2022_kr',",
            "                     'latin_1',",
            "                     'iso8859_2',",
            "                     'iso8859_3',",
            "                     'iso8859_4',",
            "                     'iso8859_5',",
            "                     'iso8859_6',",
            "                     'iso8859_7',",
            "                     'iso8859_8',",
            "                     'iso8859_9',",
            "                     'iso8859_10',",
            "                     'iso8859_13',",
            "                     'iso8859_14',",
            "                     'iso8859_15',",
            "                     'iso8859_16',",
            "                     'johab',",
            "                     'koi8_r',",
            "                     'koi8_u',",
            "                     'mac_cyrillic',",
            "                     'mac_greek',",
            "                     'mac_iceland',",
            "                     'mac_latin2',",
            "                     'mac_roman',",
            "                     'mac_turkish',",
            "                     'ptcp154',",
            "                     'shift_jis',",
            "                     'shift_jis_2004',",
            "                     'shift_jisx0213',",
            "                     'utf_32',",
            "                     'utf_32_be',",
            "                     'utf_32_le',",
            "                     'utf_16',",
            "                     'utf_16_be',",
            "                     'utf_16_le',",
            "                     'utf_7',",
            "                     'utf_8',",
            "                     'utf_8_sig',",
            "                     ]",
            "",
            "",
            "class EncodingsTest(unittest.TestCase):",
            "",
            "    def test_01(self):",
            "        \"\"\"",
            "        Test all the encodings for TAXII 1.1 XML",
            "        \"\"\"",
            "",
            "        for encoding in PYTHON_ENCODINGS:",
            "            if encoding in ('cp720', 'cp858', 'iso8859_11') and (sys.version_info[0] == 2 and sys.version_info[1] == 6):",
            "                continue  # This encoding is not supported in Python 2.6",
            "",
            "            encoded_doc = xml_taxii_message_11.encode(encoding, 'strict')",
            "            try:",
            "                msg = tm11.get_message_from_xml(encoded_doc, encoding)",
            "            except Exception as e:",
            "                print('Bad codec was: %s' % encoding)",
            "                raise",
            "",
            "    def test_02(self):",
            "        \"\"\"",
            "        Test all the encodings for TAXII 1.1 JSON",
            "        \"\"\"",
            "",
            "        for encoding in PYTHON_ENCODINGS:",
            "            if encoding in ('cp720', 'cp858', 'iso8859_11') and (sys.version_info[0] == 2 and sys.version_info[1] == 6):",
            "                continue  # This encoding is not supported in Python 2.6",
            "            encoded_doc = json_taxii_message_11.encode(encoding, 'strict')",
            "            try:",
            "                msg = tm11.get_message_from_json(encoded_doc, encoding)",
            "            except Exception as e:",
            "                print('Bad codec was: %s' % encoding)",
            "                raise",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    unittest.main()"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "# This file has two purposes:",
            "# 1. To provide a rough unit test of libtaxii.messages",
            "# 2. To provide examples of how to use libtaxii.messages",
            "",
            "import datetime",
            "import io",
            "import sys",
            "import unittest",
            "import warnings",
            "import inspect",
            "",
            "from dateutil.tz import tzutc",
            "from lxml import etree",
            "",
            "import libtaxii as t",
            "import libtaxii.messages_11 as tm11",
            "import libtaxii.taxii_default_query as tdq",
            "from libtaxii.validation import SchemaValidator",
            "from libtaxii.constants import *",
            "from libtaxii.common import *",
            "import six",
            "",
            "import sys",
            "",
            "# TODO: This is bad practice. Refactor this.",
            "# Set up some things used across multiple tests.",
            "",
            "full_stix_doc = \"\"\"<stix:STIX_Package",
            "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "    xmlns:stix=\"http://stix.mitre.org/stix-1\"",
            "    xmlns:indicator=\"http://stix.mitre.org/Indicator-2\"",
            "    xmlns:cybox=\"http://cybox.mitre.org/cybox-2\"",
            "    xmlns:DomainNameObj=\"http://cybox.mitre.org/objects#DomainNameObject-1\"",
            "    xmlns:cyboxVocabs=\"http://cybox.mitre.org/default_vocabularies-2\"",
            "    xmlns:stixVocabs=\"http://stix.mitre.org/default_vocabularies-1\"",
            "    xmlns:example=\"http://example.com/\"",
            "    xsi:schemaLocation=",
            "    \"http://stix.mitre.org/stix-1 ../stix_core.xsd",
            "    http://stix.mitre.org/Indicator-2 ../indicator.xsd",
            "    http://cybox.mitre.org/default_vocabularies-2 ../cybox/cybox_default_vocabularies.xsd",
            "    http://stix.mitre.org/default_vocabularies-1 ../stix_default_vocabularies.xsd",
            "    http://cybox.mitre.org/objects#DomainNameObject-1 ../cybox/objects/Domain_Name_Object.xsd\"",
            "    id=\"example:STIXPackage-f61cd874-494d-4194-a3e6-6b487dbb6d6e\"",
            "    timestamp=\"2014-05-08T09:00:00.000000Z\"",
            "    version=\"1.1.1\"",
            "    >",
            "    <stix:STIX_Header>",
            "        <stix:Title>Example watchlist that contains domain information.</stix:Title>",
            "        <stix:Package_Intent xsi:type=\"stixVocabs:PackageIntentVocab-1.0\">Indicators - Watchlist</stix:Package_Intent>",
            "    </stix:STIX_Header>",
            "    <stix:Indicators>",
            "        <stix:Indicator xsi:type=\"indicator:IndicatorType\" id=\"example:Indicator-2e20c5b2-56fa-46cd-9662-8f199c69d2c9\" timestamp=\"2014-05-08T09:00:00.000000Z\">",
            "            <indicator:Type xsi:type=\"stixVocabs:IndicatorTypeVocab-1.1\">Domain Watchlist</indicator:Type>",
            "            <indicator:Description>Sample domain Indicator for this watchlist</indicator:Description>",
            "            <indicator:Observable id=\"example:Observable-87c9a5bb-d005-4b3e-8081-99f720fad62b\">",
            "                <cybox:Object id=\"example:Object-12c760ba-cd2c-4f5d-a37d-18212eac7928\">",
            "                    <cybox:Properties xsi:type=\"DomainNameObj:DomainNameObjectType\" type=\"FQDN\">",
            "                        <DomainNameObj:Value condition=\"Equals\" apply_condition=\"ANY\">malicious1.example.com##comma##malicious2.example.com##comma##malicious3.example.com</DomainNameObj:Value>",
            "                    </cybox:Properties>",
            "                </cybox:Object>",
            "            </indicator:Observable>",
            "        </stix:Indicator>",
            "    </stix:Indicators>",
            "</stix:STIX_Package>\"\"\"",
            "",
            "xml_taxii_message_11 = '<taxii_11:Discovery_Request xmlns:taxii_11=\"http://taxii.mitre.org/messages/taxii_xml_binding-1.1\" message_id=\"1\"/>'",
            "json_taxii_message_11 = '{\"extended_headers\": {}, \"message_type\": \"Discovery_Request\", \"message_id\": \"1\"}'",
            "",
            "# Note that the \"*_old\" tests are just to make sure that backward-compatible aliases exist",
            "test1 = tdq.Test(capability_id=CM_CORE,  # Required",
            "                 relationship='equals',  # Required",
            "                 parameters={'value': 'Test value',",
            "                             'match_type': 'case_sensitive_string'}  # Each relationship defines which params are and are not required",
            "                 )",
            "",
            "test1_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_CORE,  # Required",
            "                                            relationship='equals',  # Required",
            "                                            parameters={'value': 'Test value',",
            "                                                        'match_type': 'case_sensitive_string'}  # Each relationship defines which params are and are not required",
            "                                            )",
            "",
            "test2 = tdq.Test(capability_id=CM_REGEX,  # Required",
            "                 relationship='matches',  # Required",
            "                 parameters={'value': '[A-Z]*',",
            "                             'case_sensitive': True})  # Each relationship defines which params are and are not required",
            "",
            "test2_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_REGEX,  # Required",
            "                                            relationship='matches',  # Required",
            "                                            parameters={'value': '[A-Z]*',",
            "                                                        'case_sensitive': True})  # Each relationship defines which params are and are not required",
            "",
            "test3 = tdq.Test(capability_id=CM_TIMESTAMP,  # Required",
            "                 relationship='greater_than',  # Required",
            "                 parameters={'value': datetime.datetime.now()})  # Each relationship defines which params are and are not required",
            "",
            "test3_old = tdq.DefaultQuery.Criterion.Test(capability_id=CM_TIMESTAMP,  # Required",
            "                                            relationship='greater_than',  # Required",
            "                                            parameters={'value': datetime.datetime.now()})  # Each relationship defines which params are and are not required",
            "",
            "criterion1 = tdq.Criterion(target='**', test=test1)",
            "criterion2 = tdq.Criterion(target='STIX_Package/Indicators/Indicator/@id', test=test2)",
            "criterion3 = tdq.Criterion(target='**/Description', test=test3)",
            "",
            "criterion1_old = tdq.DefaultQuery.Criterion(target='**', test=test1)",
            "criterion2_old = tdq.DefaultQuery.Criterion(target='STIX_Package/Indicators/Indicator/@id', test=test2)",
            "criterion3_old = tdq.DefaultQuery.Criterion(target='**/Description', test=test3)",
            "",
            "criteria1 = tdq.Criteria(operator=OP_AND, criterion=[criterion1])",
            "criteria2 = tdq.Criteria(operator=OP_OR, criterion=[criterion1, criterion2, criterion3])",
            "criteria3 = tdq.Criteria(operator=OP_AND, criterion=[criterion1, criterion3], criteria=[criteria2])",
            "",
            "criteria1_old = tdq.DefaultQuery.Criteria(operator=OP_AND, criterion=[criterion1])",
            "criteria2_old = tdq.DefaultQuery.Criteria(operator=OP_OR, criterion=[criterion1, criterion2, criterion3])",
            "criteria3_old = tdq.DefaultQuery.Criteria(operator=OP_AND, criterion=[criterion1, criterion3], criteria=[criteria2])",
            "",
            "query1 = tdq.DefaultQuery(CB_STIX_XML_11, criteria1)",
            "query2 = tdq.DefaultQuery(CB_STIX_XML_11, criteria3)",
            "",
            "subscription_parameters1 = tm11.SubscriptionParameters(",
            "    response_type=RT_COUNT_ONLY,  # Optional, defaults to FULL",
            "    content_bindings=[tm11.ContentBinding(CB_STIX_XML_11)],  # Optional. Absence means no restrictions on returned data",
            "    query=query1)  # Optional. Absence means no query",
            "",
            "push_parameters1 = tm11.PushParameters(",
            "    inbox_protocol=VID_TAXII_HTTPS_10,  # Required",
            "    inbox_address='https://example.com/inboxAddress/',  # Required",
            "    delivery_message_binding=VID_TAXII_XML_11)  # Required",
            "",
            "cb001 = tm11.ContentBlock(",
            "    content_binding=tm11.ContentBinding(CB_STIX_XML_11, subtype_ids=['test1']),  # Required",
            "    content='<STIX_Package/>',  # Required (This isn't real STIX)",
            "    timestamp_label=datetime.datetime.now(tzutc()),  # Optional",
            "    message='Hullo!',  # Optional",
            "    padding='The quick brown fox jumped over the lazy dogs.')  # Optional",
            "",
            "cb002 = tm11.ContentBlock(",
            "    content_binding=tm11.ContentBinding(CB_STIX_XML_11),  # Required",
            "    content=full_stix_doc)  # Required",
            "",
            "",
            "def round_trip_message(taxii_message, print_xml=False):",
            "    if not isinstance(taxii_message, tm11.TAXIIMessage):",
            "        raise ValueError('taxii_message was not an instance of TAXIIMessage')",
            "",
            "    # print '***** Message type = %s; id = %s' % (taxii_message.message_type, taxii_message.message_id)",
            "",
            "    xml_string = taxii_message.to_xml()",
            "",
            "    # The old way of validating",
            "    with warnings.catch_warnings():",
            "        warnings.simplefilter('ignore', DeprecationWarning)",
            "        valid = tm11.validate_xml(xml_string)",
            "    if valid is not True:",
            "        print('Bad XML was:')",
            "        try:",
            "            print(etree.tostring(taxii_message.to_etree(), pretty_print=True, encoding='utf-8'))",
            "        except Exception as e:",
            "            print(xml_string)",
            "        raise Exception('\\tFailure of test #1 - XML not schema valid: %s' % valid)",
            "",
            "    # The new way of validating",
            "    sv = SchemaValidator(SchemaValidator.TAXII_11_SCHEMA)",
            "    try:",
            "        result = sv.validate_string(xml_string)",
            "    except etree.XMLSyntaxError:",
            "        raise",
            "",
            "    if not result.valid:",
            "        errors = [item for item in result.error_log]",
            "        raise Exception('\\tFailure of test #1 - XML not schema valid: %s' % errors)",
            "",
            "    if print_xml:",
            "        print(etree.tostring(taxii_message.to_etree(), pretty_print=True, encoding='utf-8'))",
            "",
            "    msg_from_xml = tm11.get_message_from_xml(xml_string)",
            "    dictionary = taxii_message.to_dict()",
            "    msg_from_dict = tm11.get_message_from_dict(dictionary)",
            "    taxii_message.to_text()  # to_text() returns a string, this just makes sure the call succeeds but doesn't validate the response",
            "    if taxii_message != msg_from_xml:",
            "        print('\\t Failure of test #2 - running equals w/ debug:')",
            "        taxii_message.__eq__(msg_from_xml, True)",
            "        raise Exception('Test #2 failed - taxii_message != msg_from_xml')",
            "",
            "    if taxii_message != msg_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        taxii_message.__eq__(msg_from_dict, True)",
            "        raise Exception('Test #3 failed - taxii_message != msg_from_dict')",
            "",
            "    if msg_from_xml != msg_from_dict:",
            "        print('\\t Failure of test #4 - running equals w/ debug:')",
            "        msg_from_xml.__eq__(msg_from_dict, True)",
            "        raise Exception('Test #4 failed - msg_from_xml != msg_from_dict')",
            "",
            "    # print '***** All tests completed!'",
            "",
            "",
            "def round_trip_content_block(content_block):",
            "    if not isinstance(content_block, tm11.ContentBlock):",
            "        raise ValueError('content_block was not an instance of ContentBlock')",
            "",
            "    # print '***** Starting Content Block tests'",
            "",
            "    xml_string = content_block.to_xml()",
            "    block_from_xml = tm11.ContentBlock.from_xml(xml_string)",
            "    dictionary = content_block.to_dict()",
            "    block_from_dict = tm11.ContentBlock.from_dict(dictionary)",
            "    json_string = content_block.to_json()",
            "    block_from_json = tm11.ContentBlock.from_json(json_string)",
            "    content_block.to_text()",
            "",
            "    if content_block != block_from_xml:",
            "        print('\\t Failure of test #1 - running equals w/ debug:')",
            "        content_block.__eq__(block_from_xml, True)",
            "        raise Exception('Test #1 failed - content_block != block_from_xml')",
            "",
            "    if content_block != block_from_dict:",
            "        print('\\t Failure of test #2 - running equals w/ debug:')",
            "        content_block.__eq__(block_from_dict, True)",
            "        raise Exception('Test #2 failed - content_block != block_from_dict')",
            "",
            "    if block_from_xml != block_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        block_from_xml.__eq__(block_from_dict, True)",
            "        raise Exception('Test #3 failed - block_from_xml != block_from_dict')",
            "    if block_from_json != block_from_dict:",
            "        print('\\t Failure of test #3 - running equals w/ debug:')",
            "        block_from_json.__eq__(block_from_dict, True)",
            "        raise Exception('Test #3 failed - block_from_json != block_from_dict')",
            "",
            "    # print '***** All tests completed!'",
            "",
            "",
            "class GenericParametersTests(unittest.TestCase):",
            "",
            "    # https://github.com/TAXIIProject/libtaxii/issues/165",
            "    def test_typo_165(self):",
            "        # Explicitly set `response_type` to None.",
            "        sub_params = tm11.SubscriptionParameters(response_type=None)",
            "        params_xml = sub_params.to_xml()",
            "",
            "        # When parsing from XML, if no response_type is provided, it should be",
            "        # set to RT_FULL.",
            "        new_params = tm11.SubscriptionParameters.from_xml(params_xml)",
            "        self.assertEqual(RT_FULL, new_params.response_type)",
            "",
            "",
            "class StatusMessageTests(unittest.TestCase):",
            "",
            "    def test_status_message_01(self):",
            "        sm01 = tm11.StatusMessage(",
            "            message_id='SM01',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_SUCCESS,  # Required",
            "            status_detail={'custom_status_detail_name': 'Custom status detail value',",
            "                           'Custom_detail_2': ['this one has', 'multiple values']},  # Required depending on Status Type. See spec for details",
            "            message='This is a test message'  # Optional",
            "        )",
            "        round_trip_message(sm01)",
            "",
            "    def test_status_message_02(self):",
            "        sm02 = tm11.StatusMessage(",
            "            message_id='SM02',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_SUCCESS,  # Required",
            "            status_detail=None,  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm02)",
            "",
            "    def test_status_message_03(self):",
            "        sm03 = tm11.StatusMessage(",
            "            message_id='SM03',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_DESTINATION_COLLECTION_ERROR,  # Required",
            "            status_detail={'ACCEPTABLE_DESTINATION': ['Collection1', 'Collection2']},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm03)",
            "",
            "    def test_status_message_04(self):",
            "        sm04 = tm11.StatusMessage(",
            "            message_id='SM04',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_INVALID_RESPONSE_PART,  # Required",
            "            status_detail={'MAX_PART_NUMBER': 4},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm04)",
            "",
            "    def test_status_message_05(self):",
            "        sm05 = tm11.StatusMessage(",
            "            message_id='SM05',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_NOT_FOUND,  # Required",
            "            status_detail={'ITEM': 'Collection1'},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm05)",
            "",
            "    def test_status_message_06(self):",
            "        sm06 = tm11.StatusMessage(",
            "            message_id='SM06',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_PENDING,  # Required",
            "            status_detail={'ESTIMATED_WAIT': 900, 'RESULT_ID': 'Result1', 'WILL_PUSH': False},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm06)",
            "",
            "    def test_status_message_07(self):",
            "        sm07 = tm11.StatusMessage(",
            "            message_id='SM07',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_RETRY,  # Required",
            "            status_detail={'ESTIMATED_WAIT': 900},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm07)",
            "",
            "    def test_status_message_08(self):",
            "        sm08 = tm11.StatusMessage(",
            "            message_id='SM08',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_MESSAGE_BINDING,  # Required",
            "            status_detail={'SUPPORTED_BINDING': [VID_TAXII_XML_10, VID_TAXII_XML_11]},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm08)",
            "",
            "    def test_status_message_09(self):",
            "        sm09 = tm11.StatusMessage(",
            "            message_id='SM09',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_CONTENT_BINDING,  # Required",
            "            status_detail={'SUPPORTED_CONTENT': tm11.ContentBinding(binding_id=CB_STIX_XML_101, subtype_ids=['subtype1', 'subtype2'])},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm09)",
            "",
            "    def test_status_message_10(self):",
            "        sm09 = tm11.StatusMessage(",
            "            message_id='SM10',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_UNSUPPORTED_CONTENT_BINDING,  # Required",
            "            status_detail={'SUPPORTED_CONTENT': [tm11.ContentBinding(binding_id=CB_STIX_XML_101, subtype_ids=['subtype1', 'subtype2']), tm11.ContentBinding(binding_id=CB_STIX_XML_11)]},  # Required/optional depending on Status Type. See spec for details",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm09)",
            "",
            "    def test_status_message_11(self):",
            "        # Per https://github.com/TAXIIProject/libtaxii/issues/111",
            "        kwargs = {'message_id': '1', 'in_response_to': '2', 'status_type': ST_FAILURE, 'message': {}}",
            "        self.assertRaises(ValueError, tm11.StatusMessage, **kwargs)",
            "",
            "    def test_status_message_12(self):",
            "        # https://github.com/TAXIIProject/libtaxii/issues/230",
            "        collections = ['Collection1', 'Collection2', 'Collection3']",
            "        sm12 = tm11.StatusMessage(",
            "            message_id='SM12',  # Required",
            "            in_response_to=tm11.generate_message_id(),  # Required, should be the ID of the message that this is in response to",
            "            status_type=ST_DESTINATION_COLLECTION_ERROR,  # Required",
            "            status_detail={'ACCEPTABLE_DESTINATION': collections}, # Add 3 collections to trigger the bug",
            "            message=None  # Optional",
            "        )",
            "        round_trip_message(sm12)",
            "",
            "        self.assertEqual(sm12.status_detail['ACCEPTABLE_DESTINATION'], collections)",
            "",
            "        # Parse the XML",
            "        parsed_sm12 = tm11.StatusMessage.from_xml(sm12.to_xml())",
            "",
            "        # If the bug is present the value returned will be:",
            "        # [['Collection1', 'Collection2'], 'Collection3']",
            "        self.assertEqual(parsed_sm12.status_detail['ACCEPTABLE_DESTINATION'], collections)",
            "",
            "    # TODO: TEst the query status types",
            "",
            "    def test_xml_ext_header(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of etree._Element",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': parse('<x:element xmlns:x=\"#foo\">'",
            "                                       '<x:subelement attribute=\"something\"/>'",
            "                                       '</x:element>')}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "",
            "    def test_xml_ext_header2(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of etree._Element",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': parse('<x:element xmlns:x=\"#foo\">'",
            "                                       '<x:subelement attribute=\"something\"/>'",
            "                                       '</x:element>')}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "        # print etree.tostring(etree.XML(sm.to_xml(pretty_print=True)), pretty_print=True)",
            "",
            "    def test_xml_ext_header3(self):",
            "        \"\"\"",
            "        Tests an XML extended header value of string",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        eh = {'my_ext_header_1': '<x:element xmlns:x=\"#foo\">'",
            "                                 '<x:subelement attribute=\"something\"/>'",
            "                                 '</x:element>'}",
            "",
            "        sm = tm11.StatusMessage(message_id='1',",
            "                                in_response_to='2',",
            "                                status_type=ST_SUCCESS,",
            "                                extended_headers=eh)",
            "        round_trip_message(sm)",
            "        # print etree.tostring(etree.XML(sm.to_xml(pretty_print=True)), pretty_print=True)",
            "",
            "",
            "class DiscoveryRequestTests(unittest.TestCase):",
            "",
            "    def test_discovery_request(self):",
            "        discovery_request1 = tm11.DiscoveryRequest(",
            "            message_id=tm11.generate_message_id(),  # Required",
            "            # Extended headers are optional for every message type, but demonstrated here",
            "            extended_headers={'ext_header1': 'value1', 'ext_header2': 'value2'})  # Optional.",
            "        round_trip_message(discovery_request1)",
            "",
            "",
            "class DiscoveryResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Create query information to use in the ServiceInstances",
            "        tei_01 = tdq.DefaultQueryInfo.TargetingExpressionInfo(",
            "            targeting_expression_id=CB_STIX_XML_10,  # Required. Indicates a supported targeting vocabulary (in this case STIX 1.1)",
            "            preferred_scope=[],  # At least one of Preferred/Allowed must be present. Indicates Preferred and allowed search scope.",
            "            allowed_scope=['**'])  # This example has no preferred scope, and allows any scope",
            "",
            "        tei_02 = tdq.DefaultQueryInfo.TargetingExpressionInfo(",
            "            targeting_expression_id=CB_STIX_XML_11,  # required. Indicates a supported targeting vocabulary (in this case STIX 1.1)",
            "            preferred_scope=['STIX_Package/Indicators/Indicator/**'],  # At least one of Preferred/Allowed must be present. Indicates Preferred and allowed search scope.",
            "            allowed_scope=[])  # This example prefers the Indicator scope and allows no other scope",
            "",
            "        tdq1 = tdq.DefaultQueryInfo(",
            "            targeting_expression_infos=[tei_01, tei_02],  # Required, 1-n. Indicates what targeting expressions are supported",
            "            capability_modules=[CM_CORE])  # Required, 1-n. Indicates which capability modules can be used.",
            "",
            "        tdq2 = tdq.DefaultQueryInfo(",
            "            targeting_expression_infos=[tei_02],  # Required, 1-n. Indicates what targeting expressions are supported",
            "            capability_modules=[CM_REGEX])  # Required, 1-n. Indicates which capability modules can be used.",
            "",
            "        # Create ServiceInstances to use in tests",
            "        self.si1 = tm11.ServiceInstance(",
            "            service_type=SVC_POLL,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/poll/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            available=True,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message.',",
            "            supported_query=[tdq1])  # Optional for service_type=POLL",
            "",
            "        self.si2 = tm11.ServiceInstance(",
            "            service_type=SVC_POLL,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/poll/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            available=True,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message.',",
            "            supported_query=[tdq1, tdq2])  # Optional for service_type=POLL",
            "",
            "        self.si3 = tm11.ServiceInstance(",
            "            service_type=SVC_INBOX,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/inbox/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            inbox_service_accepted_content=[tm11.ContentBinding(CB_STIX_XML_11),",
            "                                            tm11.ContentBinding(CB_STIX_XML_101),",
            "                                            tm11.ContentBinding(CB_STIX_XML_10)],  # Optional. Defaults to \"accepts all content\"",
            "            available=False,  # Optional - defaults to None, which means 'Unknown'",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "        self.si4 = tm11.ServiceInstance(",
            "            service_type=SVC_DISCOVERY,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/discovery/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "        self.si5 = tm11.ServiceInstance(",
            "            service_type=SVC_COLLECTION_MANAGEMENT,  # Required",
            "            services_version=VID_TAXII_SERVICES_11,  # Required",
            "            protocol_binding=VID_TAXII_HTTP_10,  # Required",
            "            service_address='http://example.com/collection_management/',  # Required",
            "            message_bindings=[VID_TAXII_XML_11],  # Required, must have at least one value in the list",
            "            message='This is a message. Yipee!')  # optional",
            "",
            "    def test_discovery_response_01(self):",
            "        # Create and test various discovery responses",
            "        discovery_response01 = tm11.DiscoveryResponse(",
            "            message_id='DR01',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=None)  # Optional.",
            "        round_trip_message(discovery_response01)",
            "",
            "    def test_discovery_response_02(self):",
            "        discovery_response02 = tm11.DiscoveryResponse(",
            "            message_id='DR02',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si3, self.si5])  # Optional.",
            "        round_trip_message(discovery_response02)",
            "",
            "    def test_discovery_response_03(self):",
            "        discovery_response03 = tm11.DiscoveryResponse(",
            "            message_id='DR03',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si2, self.si4])  # Optional.",
            "        round_trip_message(discovery_response03)",
            "",
            "    def test_discovery_response_04(self):",
            "        discovery_response04 = tm11.DiscoveryResponse(",
            "            message_id='DR04',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si2, self.si4])  # Optional.",
            "        round_trip_message(discovery_response04)",
            "",
            "    def test_discovery_response_05(self):",
            "        discovery_response05 = tm11.DiscoveryResponse(",
            "            message_id='DR05',  # Required",
            "            in_response_to='TheSecondIdentifier',  # Required. This should be the ID of the corresponding request",
            "            service_instances=[self.si1, self.si2, self.si3, self.si4, self.si5])  # Optional.",
            "        round_trip_message(discovery_response05)",
            "",
            "    def test_discovery_response_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   DiscoveryResponse.ServiceInstance",
            "        service = tm11.DiscoveryResponse.ServiceInstance(",
            "            service_type=SVC_COLLECTION_MANAGEMENT,",
            "            services_version=VID_TAXII_SERVICES_11,",
            "            protocol_binding=VID_TAXII_HTTP_10,",
            "            service_address='http://example.com/collection_management/',",
            "            message_bindings=[VID_TAXII_XML_11])",
            "",
            "        response = tm11.DiscoveryResponse(",
            "            message_id='DR05',",
            "            in_response_to='TheSecondIdentifier',",
            "            service_instances=[service])",
            "",
            "        round_trip_message(response)",
            "",
            "",
            "class CollectionInformationRequestTests(unittest.TestCase):",
            "",
            "    def test_collection_information_request_01(self):",
            "        cir01 = tm11.CollectionInformationRequest(",
            "            message_id='CIReq01'  # Required",
            "        )",
            "        round_trip_message(cir01)",
            "",
            "",
            "class CollectionInformationResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        # Instantiate a push methods",
            "        push_method1 = tm11.PushMethod(",
            "            push_protocol=VID_TAXII_HTTP_10,  # Required",
            "            push_message_bindings=[VID_TAXII_XML_11])  # Required",
            "",
            "        # Instantiate Poll Services",
            "        poll_service1 = tm11.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            poll_address='https://example.com/TheGreatestPollService',  # Required",
            "            poll_message_bindings=[VID_TAXII_XML_11])  # Required, at least one item must be present in the list",
            "",
            "        poll_service2 = tm11.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTP_10,  # Required",
            "            poll_address='http://example.com/TheOtherPollService',  # Required",
            "            poll_message_bindings=[VID_TAXII_XML_11])  # Required, at least one item must be present in the list",
            "",
            "        # Instantiate Subscription Methods",
            "        subs_method1 = tm11.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            subscription_address='https://example.com/TheSubscriptionService/',  # Required",
            "            subscription_message_bindings=[VID_TAXII_XML_11])  # Required - at least one item must be present in the list",
            "",
            "        subs_method2 = tm11.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTP_10,  # Required",
            "            subscription_address='http://example.com/TheSubscriptionService/',  # Required",
            "            subscription_message_bindings=[VID_TAXII_XML_11])  # Required - at least one item must be present in the list",
            "",
            "        # Instantiate Inbox Services",
            "        inbox_service1 = tm11.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # required",
            "            inbox_address='https://example.com/inbox/',  # Required",
            "            inbox_message_bindings=[VID_TAXII_XML_11],  # Required",
            "            supported_contents=None)  # Optional - None means \"all are supported\"",
            "",
            "        inbox_service2 = tm11.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # required",
            "            inbox_address='https://example.com/inbox/',  # Required",
            "            inbox_message_bindings=[VID_TAXII_XML_11],  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_11, subtype_ids=['exmaple1', 'example2'])])  # Optional - None means \"all are supported\"",
            "",
            "        # Instantiate collections",
            "        self.collection1 = tm11.CollectionInformation(",
            "            collection_name='collection1',  # Required",
            "            collection_type=CT_DATA_FEED,  # Optional. Defaults to 'Data Feed'",
            "            available=False,  # Optional. Defaults to None, which means \"unknown\"",
            "            collection_description='This is a collection',  # Required",
            "            collection_volume=4,  # Optional - indicates typical number of messages per day",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_101)],  # Optional, absence indicates all content bindings",
            "            push_methods=[push_method1],  # Optional - absence indicates no push methods",
            "            polling_service_instances=[poll_service1, poll_service2],  # Optional - absence indicates no polling services",
            "            subscription_methods=[subs_method1, subs_method2],  # optional - absence means no subscription services",
            "            receiving_inbox_services=[inbox_service1, inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "        self.collection2 = tm11.CollectionInformation(",
            "            collection_name='collection2',  # Required",
            "            collection_type=CT_DATA_SET,  # Optional. Defaults to 'Data Feed'",
            "            collection_description='Warrgghghglble.')  # Required",
            "",
            "        self.collection3 = tm11.CollectionInformation(",
            "            collection_name='collection3',  # Required",
            "            collection_description='You must pay all the dollars to have this information.',  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_10), tm11.ContentBinding(CB_STIX_XML_11)],  # Optional",
            "            polling_service_instances=[poll_service2],  # Optional - absence indicates no polling services",
            "            subscription_methods=[subs_method2],  # optional - absence means no subscription services",
            "            receiving_inbox_services=[inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "        self.collection4 = tm11.CollectionInformation(",
            "            collection_name='collection4',  # Required",
            "            collection_description='So improve information. Much amaze.',  # Required",
            "            supported_contents=[tm11.ContentBinding(CB_STIX_XML_101, subtype_ids=['ex1', 'ex2', 'ex3'])],  # Optional",
            "            receiving_inbox_services=[inbox_service1, inbox_service2])  # Optional - absence indicates no receiving inbox services",
            "",
            "    def test_collection_information_response_01(self):",
            "        collection_response1 = tm11.CollectionInformationResponse(",
            "            message_id='CIR01',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response1)",
            "",
            "    def test_collection_information_response_02(self):",
            "        collection_response2 = tm11.CollectionInformationResponse(",
            "            message_id='CIR02',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1, self.collection2, self.collection3, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response2)",
            "",
            "    def test_collection_information_response_03(self):",
            "        collection_response3 = tm11.CollectionInformationResponse(",
            "            message_id='CIR03',  # Required",
            "            in_response_to='0')  # Required - should be the ID of the message tha this message is a response to",
            "        round_trip_message(collection_response3)",
            "",
            "    def test_collection_information_response_04(self):",
            "        collection_response4 = tm11.CollectionInformationResponse(",
            "            message_id='CIR04',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection1, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response4)",
            "",
            "    def test_collection_information_response_05(self):",
            "        collection_response5 = tm11.CollectionInformationResponse(",
            "            message_id='CIR05',  # Required",
            "            in_response_to='0',  # Required - should be the ID of the message tha this message is a response to",
            "            collection_informations=[self.collection2, self.collection4])  # Optional - absence means \"no collections\"",
            "        round_trip_message(collection_response5)",
            "",
            "    def test_collection_information_response_deprecated(self):",
            "        # Test deprecated nested forms:",
            "        #   CollectionInformationResponse.CollectionInformation",
            "        #   CollectionInformationResponse.CollectionInformation.PushMethod",
            "        #   CollectionInformationResponse.CollectionInformation.PollingServiceInstance",
            "        #   CollectionInformationResponse.CollectionInformation.SubscriptionMethod",
            "        #   CollectionInformationResponse.CollectionInformation.ReceivingInboxService",
            "        push_method = tm11.CollectionInformationResponse.CollectionInformation.PushMethod(",
            "            push_protocol=VID_TAXII_HTTP_10,",
            "            push_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        poll_service = tm11.CollectionInformationResponse.CollectionInformation.PollingServiceInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/TheGreatestPollService',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        subs_method = tm11.CollectionInformationResponse.CollectionInformation.SubscriptionMethod(",
            "            subscription_protocol=VID_TAXII_HTTPS_10,",
            "            subscription_address='https://example.com/TheSubscriptionService/',",
            "            subscription_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        inbox_service = tm11.CollectionInformationResponse.CollectionInformation.ReceivingInboxService(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,",
            "            inbox_address='https://example.com/inbox/',",
            "            inbox_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        collection = tm11.CollectionInformationResponse.CollectionInformation(",
            "            collection_name='collection1',",
            "            collection_description='This is a collection',",
            "            push_methods=[push_method],",
            "            polling_service_instances=[poll_service],",
            "            subscription_methods=[subs_method],",
            "            receiving_inbox_services=[inbox_service])",
            "",
            "        response = tm11.CollectionInformationResponse(",
            "            message_id='CIR05',",
            "            in_response_to='0',",
            "            collection_informations=[collection])",
            "",
            "        round_trip_message(response)",
            "",
            "",
            "class ManageCollectionSubscriptionRequestTests(unittest.TestCase):",
            "",
            "    def test_subs_req1(self):",
            "        subs_req1 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq01',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection1',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters1,  # optional - absence means there are not any subscription parameters",
            "            push_parameters=push_parameters1)  # Optional - absence means push messaging not requested",
            "        round_trip_message(subs_req1)",
            "",
            "    def test_subs_req2(self):",
            "        subscription_parameters2 = tm11.SubscriptionParameters(",
            "            response_type=RT_FULL,  # Optional, defaults to FULL",
            "            # content_bindings = [tm11.ContentBinding(CB_STIX_XML_11)],#Optional. Absence means no restrictions on returned data",
            "            query=query2)  # Optional. Absence means no query",
            "        subs_req2 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq02',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters2)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req2)",
            "",
            "    def test_subs_req3(self):",
            "        subscription_parameters3 = tm11.SubscriptionParameters()  # Use all the defaults",
            "        subs_req3 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq03',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters3)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req3)",
            "",
            "    def test_subs_req4(self):",
            "        subs_req4 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq04',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2')  # Required",
            "        # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "        # subscription_parameters = subscription_parameters2,#optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req4)",
            "",
            "    def test_subs_req5(self):",
            "        subs_req5 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq05',  # Required",
            "            action=ACT_STATUS,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req5)",
            "",
            "    def test_subs_req6(self):",
            "        subs_req6 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq06',  # Required",
            "            action=ACT_STATUS,  # Required",
            "            collection_name='collection2')  # Required",
            "        # subscription_id = 'id1') #Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req6)",
            "",
            "    def test_subs_req7(self):",
            "        subs_req7 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq07',  # Required",
            "            action=ACT_PAUSE,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req7)",
            "",
            "    def test_subs_req8(self):",
            "        subs_req8 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq08',  # Required",
            "            action=ACT_RESUME,  # Required",
            "            collection_name='collection2',  # Required",
            "            subscription_id='id1')  # Optional for ACT_STATUS",
            "        # subscription_parameters, delivery_parameters prohibited if action != SUBSCRIBE",
            "",
            "        round_trip_message(subs_req8)",
            "",
            "    def test_subs_req9(self):",
            "        # https://github.com/TAXIIProject/libtaxii/pull/237",
            "        subscription = \"\"\"{\"content_bindings\": [{\"binding_id\": \"urn:stix.mitre.org:xml:1.2\"}], \"query\": null, \"response_type\": \"FULL\"}\"\"\"",
            "        subscription_dict = json.loads(subscription)",
            "        subscription_parameters9 = tm11.SubscriptionParameters(**subscription_dict)  # Use all the defaults",
            "        subs_req9 = tm11.ManageCollectionSubscriptionRequest(",
            "            message_id='SubsReq09',  # Required",
            "            action=ACT_SUBSCRIBE,  # Required",
            "            collection_name='collection2',  # Required",
            "            # subscription_id = None, #Prohibited for action = SUBSCRIBE",
            "            subscription_parameters=subscription_parameters9)  # optional - absence means there are not any subscription parameters",
            "        # delivery_parameters = None)#Optional - absence means push messaging not requested",
            "",
            "        round_trip_message(subs_req9)",
            "",
            "",
            "class ManageCollectionSubscriptionResponseTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        poll_instance1 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll1/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        poll_instance2 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll2/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "        poll_instance3 = tm11.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll3/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        self.subs1 = tm11.SubscriptionInstance(",
            "            status=SS_ACTIVE,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            subscription_parameters=subscription_parameters1,  # Optional - should be an echo of the request",
            "            push_parameters=push_parameters1,  # Optional - should be an echo of the request",
            "            poll_instances=[poll_instance1, poll_instance2, poll_instance3],  # Optional",
            "        )",
            "",
            "    def test_subs_resp1(self):",
            "        subs2 = tm11.SubscriptionInstance(",
            "            status=SS_PAUSED,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            subscription_parameters=subscription_parameters1,  # Optional - should be an echo of the request",
            "            push_parameters=push_parameters1,  # Optional - should be an echo of the request",
            "            # poll_instances = [poll_instance1, poll_instance2, poll_instance3],#Optional",
            "        )",
            "        subs3 = tm11.SubscriptionInstance(",
            "            status=SS_PAUSED,  # Optional, defaults to ACTIVE",
            "            subscription_id='Subs001',  # Required",
            "            # subscription_parameters = subscription_parameters1,#Optional - should be an echo of the request",
            "            # push_parameters = delivery_parameters1,#Optional - should be an echo of the request",
            "            # poll_instances = [poll_instance1, poll_instance2, poll_instance3],#Optional",
            "        )",
            "        subs_resp1 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp01',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            message='Hullo!',  # Optional",
            "            subscription_instances=[self.subs1, subs2, subs3],  # Optional",
            "        )",
            "        round_trip_message(subs_resp1)",
            "",
            "    def test_subs_resp2(self):",
            "        subs_resp2 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp02',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            # message = 'Hullo!', #Optional",
            "            # subscription_instances = [subs1, subs2, subs3],#Optional",
            "        )",
            "        round_trip_message(subs_resp2)",
            "",
            "    def test_subs_resp3(self):",
            "        subs_resp3 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp03',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            # message = 'Hullo!', #Optional",
            "            subscription_instances=[self.subs1],  # Optional",
            "        )",
            "        round_trip_message(subs_resp3)",
            "",
            "    def test_subs_resp4(self):",
            "        subs_resp4 = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp04',  # Required",
            "            in_response_to='xyz',  # Required - should be the ID of the message that this is a response to",
            "            collection_name='abc123',  # Required",
            "            message='Hullo!',  # Optional",
            "            # subscription_instances = [subs1, subs2, subs3],#Optional",
            "        )",
            "        round_trip_message(subs_resp4)",
            "",
            "    def test_subs_resp_deprecated(self):",
            "        # Test deprecated nested forms:",
            "        #   ManageCollectionSubscriptionResponse.PollInstance",
            "        #   ManageCollectionSubscriptionResponse.SubscriptionInstance",
            "        poll = tm11.ManageCollectionSubscriptionResponse.PollInstance(",
            "            poll_protocol=VID_TAXII_HTTPS_10,",
            "            poll_address='https://example.com/poll1/',",
            "            poll_message_bindings=[VID_TAXII_XML_11])",
            "",
            "        subscription = tm11.ManageCollectionSubscriptionResponse.SubscriptionInstance(",
            "            subscription_id='Subs001',",
            "            subscription_parameters=subscription_parameters1,",
            "            push_parameters=push_parameters1,",
            "            poll_instances=[poll])",
            "",
            "        subs_resp = tm11.ManageCollectionSubscriptionResponse(",
            "            message_id='SubsResp01',",
            "            in_response_to='xyz',",
            "            collection_name='abc123',",
            "            subscription_instances=[subscription])",
            "",
            "        round_trip_message(subs_resp)",
            "",
            "",
            "class PollRequestTests(unittest.TestCase):",
            "",
            "    def test_poll_req1(self):",
            "        poll_req1 = tm11.PollRequest(",
            "            message_id='PollReq01',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            subscription_id='12345',  # Optional - one of this or poll_parameters MUST be present.",
            "            poll_parameters=None)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req1)",
            "",
            "    def test_poll_req2(self):",
            "        poll_req2 = tm11.PollRequest(",
            "            message_id='PollReq02',  # Required",
            "            collection_name='collection100',  # Required",
            "            subscription_id='Kenneth Coal Collection',  # Optional - one of this or poll_parameters MUST be present.",
            "            poll_parameters=None)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req2)",
            "",
            "    def test_poll_req3(self):",
            "        delivery_parameters1 = tm11.DeliveryParameters(",
            "            inbox_protocol=VID_TAXII_HTTPS_10,  # Required",
            "            inbox_address='https://example.com/inboxAddress/',  # Required",
            "            delivery_message_binding=VID_TAXII_XML_11)  # Required",
            "",
            "        poll_params1 = tm11.PollParameters(",
            "            allow_asynch=False,  # Optional, defaults to False",
            "            response_type=RT_COUNT_ONLY,  # Optional, defaults to RT_FULL",
            "            content_bindings=[tm11.ContentBinding(binding_id=CB_STIX_XML_11)],  # Optional, defaults to None, which means \"all bindings are accepted in response\"",
            "            query=query1,  # Optional - defaults to None",
            "            delivery_parameters=delivery_parameters1)  # Optional - defaults to None",
            "",
            "        poll_req3 = tm11.PollRequest(",
            "            message_id='PollReq03',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params1)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req3)",
            "",
            "    def test_poll_req4(self):",
            "        poll_params2 = tm11.PollParameters()",
            "        poll_req4 = tm11.PollRequest(",
            "            message_id='PollReq04',  # Required",
            "            collection_name='collection100',  # Required",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params2)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req4)",
            "",
            "    def test_poll_req5(self):",
            "        poll_params3 = tm11.PollParameters(query=query1)  # Optional - defaults to None)#Optional - defaults to None",
            "        poll_req5 = tm11.PollRequest(",
            "            message_id='PollReq05',  # Required",
            "            collection_name='collection100',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for a Data Feed, prohibited for a Data Set",
            "            poll_parameters=poll_params3)  # Optional - one of this or subscription_id MUST be present",
            "        round_trip_message(poll_req5)",
            "",
            "    def test_poll_req_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   PollRequest.PollParameters",
            "        params = tm11.PollRequest.PollParameters()",
            "        poll = tm11.PollRequest(",
            "            message_id='PollReq05',",
            "            collection_name='collection100',",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),",
            "            poll_parameters=params)",
            "        round_trip_message(poll)",
            "",
            "",
            "class PollResponseTests(unittest.TestCase):",
            "",
            "    def test_poll_resp1(self):",
            "        poll_resp1 = tm11.PollResponse(",
            "            message_id='PollResp1',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            more=True,  # Optional - defaults to false",
            "            result_id='123',  # Optional",
            "            result_part_number=1,  # optional",
            "            subscription_id='24',  # optional",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for data feeds, prohibited for data sets",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()),  # required for data feeds, prohibited for data sets",
            "            record_count=tm11.RecordCount(record_count=22, partial_count=False),",
            "            message='Woooooooo',  # optional",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp1)",
            "",
            "    def test_poll_resp2(self):",
            "        poll_resp2 = tm11.PollResponse(",
            "            message_id='PollResp2',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah')  # Required",
            "        round_trip_message(poll_resp2)",
            "",
            "    def test_poll_resp3(self):",
            "        poll_resp3 = tm11.PollResponse(",
            "            message_id='PollResp3',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            result_id='123',  # Optional",
            "            subscription_id='24',  # optional",
            "            record_count=tm11.RecordCount(record_count=22),",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp3)",
            "",
            "    def test_poll_resp4(self):",
            "        poll_resp4 = tm11.PollResponse(",
            "            message_id='PollResp4',  # Required",
            "            in_response_to='tmp',  # Required. Must be the message that this is a response to",
            "            collection_name='blah',  # Required",
            "            # content_blocks = [cb001, cb002])#optional",
            "            content_blocks=[])  # optional",
            "        round_trip_message(poll_resp4)",
            "",
            "    def test_poll_resp5(self):",
            "        poll_resp5 = tm11.PollResponse(",
            "            message_id='PollResp5',",
            "            in_response_to='blah',",
            "            collection_name='foo',",
            "            result_part_number=10,",
            "            content_blocks=[])",
            "        round_trip_message(poll_resp5)",
            "",
            "",
            "class InboxMessageTests(unittest.TestCase):",
            "",
            "    def test_inbox1(self):",
            "        subs_info1 = tm11.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',  # Required",
            "            subscription_id='SubsId021',  # Required",
            "            exclusive_begin_timestamp_label=datetime.datetime.now(tzutc()),  # Optional for data feeds, prohibited for data sets",
            "            inclusive_end_timestamp_label=datetime.datetime.now(tzutc()))  # Optional for data feeds, prohibited for data sets",
            "        inbox1 = tm11.InboxMessage(",
            "            message_id='Inbox1',  # Required",
            "            result_id='123',  # Optional",
            "            destination_collection_names=['collection1', 'collection2'],  # Optional",
            "            message='Hello!',  # Optional",
            "            subscription_information=subs_info1,  # Optional",
            "            record_count=tm11.RecordCount(22, partial_count=True),  # Optional",
            "            content_blocks=[cb001, cb002])",
            "        round_trip_message(inbox1)",
            "",
            "    def test_inbox2(self):",
            "        inbox2 = tm11.InboxMessage(message_id='Inbox1')  # Required",
            "        round_trip_message(inbox2)",
            "",
            "    def test_inbox3(self):",
            "        subs_info2 = tm11.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',  # Required",
            "            subscription_id='SubsId021')  # Required",
            "",
            "        inbox3 = tm11.InboxMessage(",
            "            message_id='Inbox3',  # Required",
            "            result_id='123',  # Optional",
            "            destination_collection_names=['collection1', 'collection2'],  # Optional",
            "            subscription_information=subs_info2,  # Optional",
            "            content_blocks=[cb002])",
            "        round_trip_message(inbox3)",
            "",
            "    def test_inbox_deprecated(self):",
            "        # Test deprecated nested form:",
            "        #   InboxMessage.SubscriptionInformation",
            "        subscription = tm11.InboxMessage.SubscriptionInformation(",
            "            collection_name='SomeCollectionName',",
            "            subscription_id='SubsId021')",
            "",
            "        inbox = tm11.InboxMessage(",
            "            message_id='InboxMsg0001',",
            "            subscription_information=subscription,",
            "            content_blocks=[cb002])",
            "        round_trip_message(inbox)",
            "",
            "",
            "class PollFulfillmentTests(unittest.TestCase):",
            "",
            "    def test_poll_fulfillment1(self):",
            "        pf1 = tm11.PollFulfillmentRequest(",
            "            message_id='pf1',  # required",
            "            collection_name='1-800-collection',  # required",
            "            result_id='123',  # required",
            "            result_part_number=1)  # required",
            "",
            "        round_trip_message(pf1)",
            "",
            "",
            "class SubscriptionInformationTests(unittest.TestCase):",
            "",
            "    # See https://github.com/TAXIIProject/libtaxii/issues/110",
            "    def test_exclusive_begin_timestamp_label_must_be_datetime(self):",
            "        params = {",
            "            'collection_name': 'foo',",
            "            'subscription_id': 'baz',",
            "            'exclusive_begin_timestamp_label': '100'",
            "        }",
            "        self.assertRaises(ValueError, tm11.SubscriptionInformation, **params)",
            "",
            "    # See https://github.com/TAXIIProject/libtaxii/issues/110",
            "    def test_110_2(self):",
            "        \"\"\"",
            "        Test for https://github.com/TAXIIProject/libtaxii/issues/110",
            "        :return:",
            "        \"\"\"",
            "        params = {",
            "            'collection_name': 'foo',",
            "            'subscription_id': 'baz',",
            "            'inclusive_end_timestamp_label': '100'",
            "        }",
            "        self.assertRaises(ValueError, tm11.SubscriptionInformation, **params)",
            "",
            "",
            "class ContentBlockTests(unittest.TestCase):",
            "",
            "    def test_content_block01(self):",
            "        cb1 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>')",
            "        round_trip_content_block(cb1)",
            "",
            "    def test_content_block02(self):",
            "        cb2 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content=six.StringIO('<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>'))",
            "        round_trip_content_block(cb2)",
            "",
            "    def test_content_block03(self):",
            "        cb3 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content=parse('<stix:STIX_Package xmlns:stix=\"http://stix.mitre.org/stix-1\"/>'))",
            "        round_trip_content_block(cb3)",
            "",
            "    def test_content_block04(self):",
            "        cb4 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='<Something thats not XML')",
            "        round_trip_content_block(cb4)",
            "",
            "    def test_content_block05(self):",
            "        cb5 = tm11.ContentBlock(content_binding=tm11.ContentBinding(CB_STIX_XML_10),",
            "                                content='Something thats not XML <xml/>')",
            "        round_trip_content_block(cb5)",
            "",
            "    def test_content_block06(self):",
            "        cb6 = tm11.ContentBlock(content_binding='RandomUnicodeString', content=six.text_type('abcdef'))",
            "        round_trip_content_block(cb6)",
            "",
            "    def test_content_block07(self):",
            "        cb7 = tm11.ContentBlock(content_binding='something',",
            "                                content='something',",
            "                                message='a message',",
            "                                padding='the padding!')",
            "        round_trip_content_block(cb7)",
            "",
            "",
            "class TestXmlAttacks(unittest.TestCase):",
            "    \"\"\"",
            "    List of XML attacks can be found here: https://pypi.python.org/pypi/defusedxml#python-xml-libraries",
            "    Thanks to @guidovranken for pointing these out",
            "",
            "    \"\"\"",
            "",
            "    def test_billion_laughs(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the \"billion laughs\" attack on libtaxii",
            "        http://en.wikipedia.org/wiki/Billion_laughs",
            "        :return:",
            "        \"\"\"",
            "",
            "        billion_laughs = \"\"\"<!DOCTYPE lolz [",
            "                             <!ENTITY lol \"lol\">",
            "                             <!ELEMENT lolz (#PCDATA)>",
            "                             <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">",
            "                             <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">",
            "                           ]>",
            "                           <lolz>&lol1;</lolz>\"\"\"",
            "",
            "        e = parse(billion_laughs)",
            "",
            "        if e.text is not None:",
            "            raise ValueError(\"The text of e was not None, meaning a real attack would have succeeded!\")",
            "",
            "    def test_guadratic_blowup(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the quadratic blowup attack",
            "        http://msdn.microsoft.com/en-us/magazine/ee335713.aspx",
            "        :return:",
            "        \"\"\"",
            "        q_blowup = \"\"\"<!DOCTYPE kaboom [",
            "                        <!ENTITY a \"aaaaaaaaaaaaaaaaaaa\">",
            "                      ]>",
            "                      <kaboom>&a;</kaboom>",
            "                   \"\"\"",
            "",
            "        e = parse(q_blowup)",
            "",
            "        if e.text is not None:",
            "            raise ValueError('The text of e was not None, meaning a real attack would have succeeded!')",
            "",
            "    def test_xee_remote(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the remote XEE attack",
            "        https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing",
            "        :return:",
            "        \"\"\"",
            "",
            "        xee_remote = \"\"\"<!DOCTYPE foo [",
            "                          <!ELEMENT foo ANY >",
            "                          <!ENTITY xxe SYSTEM \"http://www.mitre.org\" >]>",
            "                        <foo>&xxe;</foo>",
            "                      \"\"\"",
            "",
            "        # If an XML Syntax Error is received, an attack would have succeeded",
            "",
            "        try:",
            "            e = parse(xee_remote)",
            "        except etree.XMLSyntaxError:",
            "            raise ValueError(\"An XML Syntax Error was raised, meaning a real attack would have succeeded!\")",
            "",
            "    def test_xee_local(self):",
            "        \"\"\"",
            "        Tests a \"safe\" variant of the local XEE attack",
            "        https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing",
            "        :return:",
            "        \"\"\"",
            "",
            "        xee_local = \"\"\"<!DOCTYPE foo [",
            "                          <!ELEMENT foo ANY >",
            "                          <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>",
            "                        <foo>&xxe;</foo>",
            "                      \"\"\"",
            "        # If an XML Syntax Error is received, an attack would have succeeded",
            "",
            "        try:",
            "            e = parse(xee_local)",
            "        except etree.XMLSyntaxError:",
            "            raise ValueError(\"An XML Syntax Error was raised, meaning a real attack would have succeeded!\")",
            "",
            "    def test_ssrf(self):",
            "        \"\"\"",
            "        Tests that external URLs are forbidden by default.",
            "        https://github.com/TAXIIProject/libtaxii/issues/246",
            "        \"\"\"",
            "        try:",
            "            parse(\"http://localhost/\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise AssertionError(\"oh no!\")",
            "",
            "        try:",
            "            parse(\"ftp://localhost/\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise AssertionError(\"oh no!\")",
            "",
            "    def test_local_filesystem_access(self):",
            "        \"\"\"No access to files allowed with allow_file=False",
            "        \"\"\"",
            "        try:",
            "            parse(\"file:///etc/hosts/\", allow_file=False, allow_url=True)",
            "        except etree.XMLSyntaxError:",
            "            pass",
            "        else:",
            "            raise AssertionError(\"oh no!\")",
            "",
            "        try:",
            "            parse(\"/etc/hosts/\", allow_file=False)",
            "        except etree.XMLSyntaxError:",
            "            pass",
            "        else:",
            "            raise AssertionError(\"oh no!\")",
            "",
            "    def test_dtd_retrieval(self):",
            "        pass",
            "",
            "    def test_gzip_bomb(self):",
            "        pass",
            "",
            "    def test_xpath(self):",
            "        pass",
            "",
            "    def test_xslt(self):",
            "        pass",
            "",
            "    def test_xinclude(self):",
            "        pass",
            "",
            "class VersionsTest(unittest.TestCase):",
            "",
            "    def test_01(self):",
            "        \"\"\"",
            "        Tests that all tm10 objects have a version attribute",
            "",
            "        :return:",
            "        \"\"\"",
            "        for name, obj in inspect.getmembers(tm11, inspect.isclass):",
            "            # Certain classes are excluded from this test:",
            "            if name in ('TAXIIBase', 'UnsupportedQueryException', '_StatusDetail'):",
            "                continue",
            "            obj.version",
            "",
            "",
            "# Encodings pulled from: https://docs.python.org/2/library/codecs.html",
            "PYTHON_ENCODINGS = ['ascii',",
            "                     'big5',",
            "                     'big5hkscs',",
            "                     'cp037',",
            "                     'cp424',",
            "                     'cp437',",
            "                     'cp500',",
            "                     'cp720',",
            "                     'cp737',",
            "                     'cp775',",
            "                     'cp850',",
            "                     'cp852',",
            "                     'cp855',",
            "                     'cp856',",
            "                     'cp857',",
            "                     'cp858',",
            "                     'cp860',",
            "                     'cp861',",
            "                     'cp862',",
            "                     'cp863',",
            "                     'cp864',",
            "                     'cp865',",
            "                     'cp866',",
            "                     'cp869',",
            "                     'cp874',",
            "                     'cp875',",
            "                     'cp932',",
            "                     'cp949',",
            "                     'cp950',",
            "                     'cp1006',",
            "                     'cp1026',",
            "                     'cp1140',",
            "                     'cp1250',",
            "                     'cp1251',",
            "                     'cp1252',",
            "                     'cp1253',",
            "                     'cp1254',",
            "                     'cp1255',",
            "                     'cp1256',",
            "                     'cp1257',",
            "                     'cp1258',",
            "                     'euc_jp',",
            "                     'euc_jis_2004',",
            "                     'euc_jisx0213',",
            "                     'euc_kr',",
            "                     'gb2312',",
            "                     'gbk',",
            "                     'gb18030',",
            "                     'hz',",
            "                     'iso2022_jp',",
            "                     'iso2022_jp_1',",
            "                     'iso2022_jp_2',",
            "                     'iso2022_jp_2004',",
            "                     'iso2022_jp_3',",
            "                     'iso2022_jp_ext',",
            "                     'iso2022_kr',",
            "                     'latin_1',",
            "                     'iso8859_2',",
            "                     'iso8859_3',",
            "                     'iso8859_4',",
            "                     'iso8859_5',",
            "                     'iso8859_6',",
            "                     'iso8859_7',",
            "                     'iso8859_8',",
            "                     'iso8859_9',",
            "                     'iso8859_10',",
            "                     'iso8859_13',",
            "                     'iso8859_14',",
            "                     'iso8859_15',",
            "                     'iso8859_16',",
            "                     'johab',",
            "                     'koi8_r',",
            "                     'koi8_u',",
            "                     'mac_cyrillic',",
            "                     'mac_greek',",
            "                     'mac_iceland',",
            "                     'mac_latin2',",
            "                     'mac_roman',",
            "                     'mac_turkish',",
            "                     'ptcp154',",
            "                     'shift_jis',",
            "                     'shift_jis_2004',",
            "                     'shift_jisx0213',",
            "                     'utf_32',",
            "                     'utf_32_be',",
            "                     'utf_32_le',",
            "                     'utf_16',",
            "                     'utf_16_be',",
            "                     'utf_16_le',",
            "                     'utf_7',",
            "                     'utf_8',",
            "                     'utf_8_sig',",
            "                     ]",
            "",
            "",
            "class EncodingsTest(unittest.TestCase):",
            "",
            "    def test_01(self):",
            "        \"\"\"",
            "        Test all the encodings for TAXII 1.1 XML",
            "        \"\"\"",
            "",
            "        for encoding in PYTHON_ENCODINGS:",
            "            if encoding in ('cp720', 'cp858', 'iso8859_11') and (sys.version_info[0] == 2 and sys.version_info[1] == 6):",
            "                continue  # This encoding is not supported in Python 2.6",
            "",
            "            encoded_doc = xml_taxii_message_11.encode(encoding, 'strict')",
            "            try:",
            "                msg = tm11.get_message_from_xml(encoded_doc, encoding)",
            "            except Exception as e:",
            "                print('Bad codec was: %s' % encoding)",
            "                raise",
            "",
            "    def test_02(self):",
            "        \"\"\"",
            "        Test all the encodings for TAXII 1.1 JSON",
            "        \"\"\"",
            "",
            "        for encoding in PYTHON_ENCODINGS:",
            "            if encoding in ('cp720', 'cp858', 'iso8859_11') and (sys.version_info[0] == 2 and sys.version_info[1] == 6):",
            "                continue  # This encoding is not supported in Python 2.6",
            "            encoded_doc = json_taxii_message_11.encode(encoding, 'strict')",
            "            try:",
            "                msg = tm11.get_message_from_json(encoded_doc, encoding)",
            "            except Exception as e:",
            "                print('Bad codec was: %s' % encoding)",
            "                raise",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    unittest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "libtaxii.test.messages_11_test.TestXmlAttacks.self",
            "airflow.www.views.LogModelView"
        ]
    },
    "libtaxii/validation.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                                 will be used when validate_file/string/etree"
            },
            "1": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "                                 is used."
            },
            "2": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        schema_doc = parse(schema_file)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        schema_doc = parse(schema_file, allow_file=True)"
            },
            "5": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         self.xml_schema = etree.XMLSchema(schema_doc)"
            },
            "6": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     def validate_file(self, file_location):"
            },
            "8": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         with open(file_location, 'r') as f:"
            },
            "11": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            etree_xml = parse(f)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            etree_xml = parse(f, allow_file=True)"
            },
            "13": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         return self.validate_etree(etree_xml)"
            },
            "15": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         A wrapper for validate_etree. Parses xml_string,"
            },
            "17": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         turns it into an etree, then calls validate_etree( ... )"
            },
            "18": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        etree_xml = parse(xml_string)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        etree_xml = parse(xml_string, allow_file=False)"
            },
            "21": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         return self.validate_etree(etree_xml)"
            },
            "22": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     def validate_etree(self, etree_xml):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Common data validation functions used across libtaxii",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import re",
            "import datetime",
            "from lxml import etree",
            "import os",
            "",
            "from .common import (parse, parse_datetime_string)",
            "import six",
            "",
            "# General purpose helper methods #",
            "",
            "RegexTuple = collections.namedtuple('_RegexTuple', ['regex', 'title'])",
            "# URI regex per http://tools.ietf.org/html/rfc3986",
            "uri_regex = RegexTuple(\"(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\", \"URI Format\")",
            "message_id_regex_10 = RegexTuple(\"^[0-9]+$\", \"Numbers only\")",
            "targeting_expression_regex = RegexTuple(\"^(@?\\w+|\\*{1,2})(/(@?\\w+|\\*{1,2}))*$\", \"Targeting Expression Syntax\")",
            "",
            "_none_error = \"%s is not allowed to be None and the provided value was None\"",
            "_type_error = \"%s must be of type %s. The incorrect value was of type %s\"",
            "_regex_error = \"%s must be a string conforming to %s. The incorrect value was: %s\"",
            "_tuple_error = \"%s must be one of %s. The incorrect value was %s\"",
            "",
            "",
            "def do_check(var, varname, type=None, regex_tuple=None, value_tuple=None, can_be_none=False):",
            "    \"\"\"",
            "    Checks supplied var against all of the supplied checks using the following",
            "    process:",
            "",
            "    1. If var is iterable, call this function for every item in the iterable object",
            "    2. If the var is none and can be none, return",
            "    3. If the var is none and cannot be none, raise ValueError",
            "    4. If a type is specified, and the var is not of the specified type, raise ValueError",
            "    5. If a regex is specified, and the var doesn't match the regex, raise ValueError",
            "    6. If a value_tuple is specified, and the var is not in the value_tuple, raise ValueError",
            "",
            "    varname is used in the error messages",
            "",
            "    \"\"\"",
            "",
            "    if isinstance(var, list) or isinstance(var, set) or isinstance(var, tuple):",
            "",
            "        x = 0",
            "        for item in var:",
            "            do_check(item, \"%s[%s]\" % (varname, x), type, regex_tuple, value_tuple, can_be_none)",
            "            x = x + 1",
            "",
            "        return",
            "",
            "    if var is None and can_be_none:",
            "        return",
            "",
            "    if var is None and not can_be_none:",
            "        raise ValueError(_none_error % varname)",
            "",
            "    if type is not None:",
            "        if not isinstance(var, type):",
            "            bad_type = var.__class__.__name__",
            "            raise ValueError(_type_error % (varname, type, bad_type))",
            "",
            "    if regex_tuple is not None:",
            "        if not isinstance(var, six.string_types):",
            "            raise ValueError('%s was about to undergo a regex check, but is not of type basestring! Regex check was not performed' % (varname))",
            "        if re.match(regex_tuple.regex, var) is None:",
            "            raise ValueError(_regex_error % (varname, regex_tuple.title, var))",
            "",
            "    if value_tuple is not None:",
            "        if var not in value_tuple:",
            "            raise ValueError(_tuple_error % (varname, value_tuple, var))",
            "    return",
            "",
            "",
            "def check_timestamp_label(timestamp_label, varname, can_be_none=False):",
            "    \"\"\"",
            "    Checks the timestamp_label to see if it is a valid timestamp label",
            "    using the following process:",
            "",
            "    1. If the timestamp_label is None and is allowed to be None, Pass",
            "    2. If the timestamp_label is None and is not allowed to be None, Fail",
            "    3. If the timestamp_label arg is a string, convert to datetime",
            "    4. If the timestamp_label does not have a tzinfo attribute, Fail",
            "    5. Pass",
            "    \"\"\"",
            "",
            "    if timestamp_label is None and can_be_none:",
            "        return",
            "",
            "    if timestamp_label is None and not can_be_none:",
            "        raise ValueError(_none_error % varname)",
            "",
            "    if isinstance(timestamp_label, six.string_types):",
            "        timestamp_label = parse_datetime_string(timestamp_label)",
            "",
            "    do_check(timestamp_label, varname, type=datetime.datetime, can_be_none=can_be_none)",
            "",
            "    if timestamp_label.tzinfo is None:",
            "        raise ValueError('%s.tzinfo must not be None!' % varname)",
            "",
            "    return timestamp_label",
            "",
            "",
            "class SchemaValidationResult(object):",
            "    \"\"\"A wrapper for the results of schema validation.\"\"\"",
            "",
            "    def __init__(self, valid, error_log):",
            "        self.valid = valid",
            "        self.error_log = error_log",
            "",
            "_pkg_dir = os.path.dirname(__file__)",
            "",
            "#: Automatically-calculated path to the bundled TAXII 1.0 schema.",
            "TAXII_10_SCHEMA = os.path.join(_pkg_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema.xsd\")",
            "",
            "#: Automatically-calculated path to the bundled TAXII 1.1 schema.",
            "TAXII_11_SCHEMA = os.path.join(_pkg_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema_11.xsd\")",
            "",
            "",
            "class SchemaValidator(object):",
            "    \"\"\"",
            "    A helper class for TAXII Schema Validation.",
            "",
            "    Example:",
            "        See validate_etree(...) for an example how to use this class",
            "    \"\"\"",
            "",
            "    # Create class-level variables equal to module-level variables for",
            "    # backwards-compatibility",
            "    TAXII_10_SCHEMA = TAXII_10_SCHEMA",
            "    TAXII_11_SCHEMA = TAXII_11_SCHEMA",
            "",
            "    def __init__(self, schema_file):",
            "        \"\"\"",
            "        Args:",
            "            schema_file (str) - The file location of the schema to",
            "                                validate against. Use the TAXII_11_SCHEMA",
            "                                and TAXII_10_SCHEMA constants to validate",
            "                                against TAXII 1.1 / 1.0. This schema file",
            "                                will be used when validate_file/string/etree",
            "                                is used.",
            "        \"\"\"",
            "        schema_doc = parse(schema_file)",
            "        self.xml_schema = etree.XMLSchema(schema_doc)",
            "",
            "    def validate_file(self, file_location):",
            "        \"\"\"",
            "        A wrapper for validate_etree. Parses file_location,",
            "        turns it into an etree, then calls validate_etree( ... )",
            "        \"\"\"",
            "",
            "        with open(file_location, 'r') as f:",
            "            etree_xml = parse(f)",
            "",
            "        return self.validate_etree(etree_xml)",
            "",
            "    def validate_string(self, xml_string):",
            "        \"\"\"",
            "        A wrapper for validate_etree. Parses xml_string,",
            "        turns it into an etree, then calls validate_etree( ... )",
            "        \"\"\"",
            "        etree_xml = parse(xml_string)",
            "        return self.validate_etree(etree_xml)",
            "",
            "    def validate_etree(self, etree_xml):",
            "        \"\"\"Validate an LXML etree with the specified schema_file.",
            "",
            "        Args:",
            "            etree_xml (etree): The XML to validate.",
            "            schema_file (str): The schema file to validate against",
            "",
            "        Returns:",
            "            A SchemaValidationResult object",
            "",
            "        Raises:",
            "            lxml.etree.XMLSyntaxError: When the XML to be validated is not well formed",
            "",
            "        Example:",
            "            .. code-block:: python",
            "",
            "                from libtaxii import messages_11",
            "                from libtaxii.validation import SchemaValidator, TAXII_11_SCHEMA",
            "                from lxml.etree import XMLSyntaxError",
            "",
            "                sv = SchemaValidator(TAXII_11_SCHEMA)",
            "",
            "                try:",
            "                   result = sv.validate_etree(some_etree)",
            "                   # Note that validate_string() and validate_file() can also be used",
            "                except XMLSyntaxError:",
            "                    # Handle this exception, which occurs when",
            "                    # some_xml_string is not valid XML (e.g., 'foo')",
            "",
            "                if not result.valid:",
            "                    for error in result.error_log:",
            "                        print error",
            "                    sys.exit(1)",
            "",
            "                # At this point, the XML is schema valid",
            "                do_something(some_xml_string)",
            "        \"\"\"",
            "        valid = self.xml_schema.validate(etree_xml)",
            "        return SchemaValidationResult(valid, self.xml_schema.error_log)",
            "",
            "",
            "class TAXII10Validator(SchemaValidator):",
            "    \"\"\"A :py:class:`SchemaValidator` that uses the TAXII 1.0 Schemas\"\"\"",
            "",
            "    def __init__(self):",
            "        super(TAXII10Validator, self).__init__(TAXII_10_SCHEMA)",
            "",
            "",
            "class TAXII11Validator(SchemaValidator):",
            "    \"\"\"A :py:class:`SchemaValidator` that uses the TAXII 1.1 Schemas\"\"\"",
            "",
            "    def __init__(self):",
            "        super(TAXII11Validator, self).__init__(TAXII_11_SCHEMA)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017, The MITRE Corporation",
            "# For license information, see the LICENSE.txt file",
            "",
            "\"\"\"",
            "Common data validation functions used across libtaxii",
            "\"\"\"",
            "",
            "",
            "import collections",
            "import re",
            "import datetime",
            "from lxml import etree",
            "import os",
            "",
            "from .common import (parse, parse_datetime_string)",
            "import six",
            "",
            "# General purpose helper methods #",
            "",
            "RegexTuple = collections.namedtuple('_RegexTuple', ['regex', 'title'])",
            "# URI regex per http://tools.ietf.org/html/rfc3986",
            "uri_regex = RegexTuple(\"(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\", \"URI Format\")",
            "message_id_regex_10 = RegexTuple(\"^[0-9]+$\", \"Numbers only\")",
            "targeting_expression_regex = RegexTuple(\"^(@?\\w+|\\*{1,2})(/(@?\\w+|\\*{1,2}))*$\", \"Targeting Expression Syntax\")",
            "",
            "_none_error = \"%s is not allowed to be None and the provided value was None\"",
            "_type_error = \"%s must be of type %s. The incorrect value was of type %s\"",
            "_regex_error = \"%s must be a string conforming to %s. The incorrect value was: %s\"",
            "_tuple_error = \"%s must be one of %s. The incorrect value was %s\"",
            "",
            "",
            "def do_check(var, varname, type=None, regex_tuple=None, value_tuple=None, can_be_none=False):",
            "    \"\"\"",
            "    Checks supplied var against all of the supplied checks using the following",
            "    process:",
            "",
            "    1. If var is iterable, call this function for every item in the iterable object",
            "    2. If the var is none and can be none, return",
            "    3. If the var is none and cannot be none, raise ValueError",
            "    4. If a type is specified, and the var is not of the specified type, raise ValueError",
            "    5. If a regex is specified, and the var doesn't match the regex, raise ValueError",
            "    6. If a value_tuple is specified, and the var is not in the value_tuple, raise ValueError",
            "",
            "    varname is used in the error messages",
            "",
            "    \"\"\"",
            "",
            "    if isinstance(var, list) or isinstance(var, set) or isinstance(var, tuple):",
            "",
            "        x = 0",
            "        for item in var:",
            "            do_check(item, \"%s[%s]\" % (varname, x), type, regex_tuple, value_tuple, can_be_none)",
            "            x = x + 1",
            "",
            "        return",
            "",
            "    if var is None and can_be_none:",
            "        return",
            "",
            "    if var is None and not can_be_none:",
            "        raise ValueError(_none_error % varname)",
            "",
            "    if type is not None:",
            "        if not isinstance(var, type):",
            "            bad_type = var.__class__.__name__",
            "            raise ValueError(_type_error % (varname, type, bad_type))",
            "",
            "    if regex_tuple is not None:",
            "        if not isinstance(var, six.string_types):",
            "            raise ValueError('%s was about to undergo a regex check, but is not of type basestring! Regex check was not performed' % (varname))",
            "        if re.match(regex_tuple.regex, var) is None:",
            "            raise ValueError(_regex_error % (varname, regex_tuple.title, var))",
            "",
            "    if value_tuple is not None:",
            "        if var not in value_tuple:",
            "            raise ValueError(_tuple_error % (varname, value_tuple, var))",
            "    return",
            "",
            "",
            "def check_timestamp_label(timestamp_label, varname, can_be_none=False):",
            "    \"\"\"",
            "    Checks the timestamp_label to see if it is a valid timestamp label",
            "    using the following process:",
            "",
            "    1. If the timestamp_label is None and is allowed to be None, Pass",
            "    2. If the timestamp_label is None and is not allowed to be None, Fail",
            "    3. If the timestamp_label arg is a string, convert to datetime",
            "    4. If the timestamp_label does not have a tzinfo attribute, Fail",
            "    5. Pass",
            "    \"\"\"",
            "",
            "    if timestamp_label is None and can_be_none:",
            "        return",
            "",
            "    if timestamp_label is None and not can_be_none:",
            "        raise ValueError(_none_error % varname)",
            "",
            "    if isinstance(timestamp_label, six.string_types):",
            "        timestamp_label = parse_datetime_string(timestamp_label)",
            "",
            "    do_check(timestamp_label, varname, type=datetime.datetime, can_be_none=can_be_none)",
            "",
            "    if timestamp_label.tzinfo is None:",
            "        raise ValueError('%s.tzinfo must not be None!' % varname)",
            "",
            "    return timestamp_label",
            "",
            "",
            "class SchemaValidationResult(object):",
            "    \"\"\"A wrapper for the results of schema validation.\"\"\"",
            "",
            "    def __init__(self, valid, error_log):",
            "        self.valid = valid",
            "        self.error_log = error_log",
            "",
            "_pkg_dir = os.path.dirname(__file__)",
            "",
            "#: Automatically-calculated path to the bundled TAXII 1.0 schema.",
            "TAXII_10_SCHEMA = os.path.join(_pkg_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema.xsd\")",
            "",
            "#: Automatically-calculated path to the bundled TAXII 1.1 schema.",
            "TAXII_11_SCHEMA = os.path.join(_pkg_dir, \"xsd\", \"TAXII_XMLMessageBinding_Schema_11.xsd\")",
            "",
            "",
            "class SchemaValidator(object):",
            "    \"\"\"",
            "    A helper class for TAXII Schema Validation.",
            "",
            "    Example:",
            "        See validate_etree(...) for an example how to use this class",
            "    \"\"\"",
            "",
            "    # Create class-level variables equal to module-level variables for",
            "    # backwards-compatibility",
            "    TAXII_10_SCHEMA = TAXII_10_SCHEMA",
            "    TAXII_11_SCHEMA = TAXII_11_SCHEMA",
            "",
            "    def __init__(self, schema_file):",
            "        \"\"\"",
            "        Args:",
            "            schema_file (str) - The file location of the schema to",
            "                                validate against. Use the TAXII_11_SCHEMA",
            "                                and TAXII_10_SCHEMA constants to validate",
            "                                against TAXII 1.1 / 1.0. This schema file",
            "                                will be used when validate_file/string/etree",
            "                                is used.",
            "        \"\"\"",
            "        schema_doc = parse(schema_file, allow_file=True)",
            "        self.xml_schema = etree.XMLSchema(schema_doc)",
            "",
            "    def validate_file(self, file_location):",
            "        \"\"\"",
            "        A wrapper for validate_etree. Parses file_location,",
            "        turns it into an etree, then calls validate_etree( ... )",
            "        \"\"\"",
            "",
            "        with open(file_location, 'r') as f:",
            "            etree_xml = parse(f, allow_file=True)",
            "",
            "        return self.validate_etree(etree_xml)",
            "",
            "    def validate_string(self, xml_string):",
            "        \"\"\"",
            "        A wrapper for validate_etree. Parses xml_string,",
            "        turns it into an etree, then calls validate_etree( ... )",
            "        \"\"\"",
            "        etree_xml = parse(xml_string, allow_file=False)",
            "        return self.validate_etree(etree_xml)",
            "",
            "    def validate_etree(self, etree_xml):",
            "        \"\"\"Validate an LXML etree with the specified schema_file.",
            "",
            "        Args:",
            "            etree_xml (etree): The XML to validate.",
            "            schema_file (str): The schema file to validate against",
            "",
            "        Returns:",
            "            A SchemaValidationResult object",
            "",
            "        Raises:",
            "            lxml.etree.XMLSyntaxError: When the XML to be validated is not well formed",
            "",
            "        Example:",
            "            .. code-block:: python",
            "",
            "                from libtaxii import messages_11",
            "                from libtaxii.validation import SchemaValidator, TAXII_11_SCHEMA",
            "                from lxml.etree import XMLSyntaxError",
            "",
            "                sv = SchemaValidator(TAXII_11_SCHEMA)",
            "",
            "                try:",
            "                   result = sv.validate_etree(some_etree)",
            "                   # Note that validate_string() and validate_file() can also be used",
            "                except XMLSyntaxError:",
            "                    # Handle this exception, which occurs when",
            "                    # some_xml_string is not valid XML (e.g., 'foo')",
            "",
            "                if not result.valid:",
            "                    for error in result.error_log:",
            "                        print error",
            "                    sys.exit(1)",
            "",
            "                # At this point, the XML is schema valid",
            "                do_something(some_xml_string)",
            "        \"\"\"",
            "        valid = self.xml_schema.validate(etree_xml)",
            "        return SchemaValidationResult(valid, self.xml_schema.error_log)",
            "",
            "",
            "class TAXII10Validator(SchemaValidator):",
            "    \"\"\"A :py:class:`SchemaValidator` that uses the TAXII 1.0 Schemas\"\"\"",
            "",
            "    def __init__(self):",
            "        super(TAXII10Validator, self).__init__(TAXII_10_SCHEMA)",
            "",
            "",
            "class TAXII11Validator(SchemaValidator):",
            "    \"\"\"A :py:class:`SchemaValidator` that uses the TAXII 1.1 Schemas\"\"\"",
            "",
            "    def __init__(self):",
            "        super(TAXII11Validator, self).__init__(TAXII_11_SCHEMA)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "148": [
                "SchemaValidator",
                "__init__"
            ],
            "158": [
                "SchemaValidator",
                "validate_file"
            ],
            "167": [
                "SchemaValidator",
                "validate_string"
            ]
        },
        "addLocation": []
    }
}