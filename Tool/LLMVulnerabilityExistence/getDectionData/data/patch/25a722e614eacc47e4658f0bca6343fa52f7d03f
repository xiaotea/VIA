{
    "glance/common/scripts/image_import/main.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     # NOTE: set image status to saving just before setting data"
            },
            "1": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     original_image.status = 'saving'"
            },
            "2": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     image_repo.save(original_image)"
            },
            "3": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    set_image_data(original_image, uri, None)"
            },
            "4": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # NOTE: Check if the Image is not deleted after setting the data"
            },
            "6": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # before setting it's status to active. We need to set the status"
            },
            "7": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # explicitly here using the Image object returned from image_repo .The"
            },
            "8": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Image object returned from create_image method does not have appropriate"
            },
            "9": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # factories wrapped around it."
            },
            "10": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     image_id = original_image.image_id"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    # NOTE: Retrieving image from the database because the Image object"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    # returned from create_image method does not have appropriate factories"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    # wrapped around it."
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     new_image = image_repo.get(image_id)"
            },
            "16": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if new_image.status in ['saving']:"
            },
            "17": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_image.status = 'active'"
            },
            "18": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_image.size = original_image.size"
            },
            "19": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_image.virtual_size = original_image.virtual_size"
            },
            "20": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        new_image.checksum = original_image.checksum"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    set_image_data(new_image, uri, None)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    # NOTE: Check if the Image is not deleted after setting the data"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    # before saving the active image. Here if image status is"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    # saving, then new_image is saved as it contains updated location,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+    # size, virtual_size and checksum information and the status of"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    # new_image is already set to active in set_image_data() call."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    image = image_repo.get(image_id)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    if image.status == 'saving':"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        image_repo.save(new_image)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        return image_id"
            },
            "32": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     else:"
            },
            "33": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         msg = _LE(\"The Image %(image_id)s object being created by this task \""
            },
            "34": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "                   \"%(task_id)s, is no longer in valid status for further \""
            },
            "35": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "                   \"processing.\" % {\"image_id\": new_image.image_id,"
            },
            "36": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                                    \"task_id\": task_id})"
            },
            "37": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         raise exception.Conflict(msg)"
            },
            "38": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    image_repo.save(new_image)"
            },
            "39": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "40": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return image_id"
            },
            "41": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " def create_image(image_repo, image_factory, image_properties, task_id):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "__all__ = [",
            "    'run',",
            "]",
            "",
            "import six",
            "",
            "from glance.api.v2 import images as v2_api",
            "from glance.common import exception",
            "from glance.common.scripts import utils as script_utils",
            "from glance.common import utils as common_utils",
            "from glance import i18n",
            "from glance.openstack.common import excutils",
            "from glance.openstack.common import lockutils",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def run(t_id, context, task_repo, image_repo, image_factory):",
            "    LOG.info(_LI('Task %(task_id)s beginning import '",
            "                 'execution.') % {'task_id': t_id})",
            "    _execute(t_id, task_repo, image_repo, image_factory)",
            "",
            "",
            "# NOTE(nikhil): This lock prevents more than N number of threads to be spawn",
            "# simultaneously. The number N represents the number of threads in the",
            "# executor pool. The value is set to 10 in the eventlet executor.",
            "@lockutils.synchronized(\"glance_import\")",
            "def _execute(t_id, task_repo, image_repo, image_factory):",
            "    task = script_utils.get_task(task_repo, t_id)",
            "",
            "    if task is None:",
            "        # NOTE: This happens if task is not found in the database. In",
            "        # such cases, there is no way to update the task status so,",
            "        # it's ignored here.",
            "        return",
            "",
            "    try:",
            "        task_input = script_utils.unpack_task_input(task)",
            "",
            "        uri = script_utils.validate_location_uri(task_input.get('import_from'))",
            "        image_id = import_image(image_repo, image_factory, task_input, t_id,",
            "                                uri)",
            "",
            "        task.succeed({'image_id': image_id})",
            "    except Exception as e:",
            "        # Note: The message string contains Error in it to indicate",
            "        # in the task.message that it's a error message for the user.",
            "",
            "        #TODO(nikhil): need to bring back save_and_reraise_exception when",
            "        # necessary",
            "        err_msg = (\"Error: \" + six.text_type(type(e)) + ': ' +",
            "                   common_utils.exception_to_str(e))",
            "        log_msg = _LE(err_msg + (\"Task ID %s\" % task.task_id))",
            "        LOG.exception(log_msg)",
            "",
            "        task.fail(_LE(err_msg))",
            "    finally:",
            "        task_repo.save(task)",
            "",
            "",
            "def import_image(image_repo, image_factory, task_input, task_id, uri):",
            "    original_image = create_image(image_repo, image_factory,",
            "                                  task_input.get('image_properties'), task_id)",
            "    # NOTE: set image status to saving just before setting data",
            "    original_image.status = 'saving'",
            "    image_repo.save(original_image)",
            "    set_image_data(original_image, uri, None)",
            "",
            "    # NOTE: Check if the Image is not deleted after setting the data",
            "    # before setting it's status to active. We need to set the status",
            "    # explicitly here using the Image object returned from image_repo .The",
            "    # Image object returned from create_image method does not have appropriate",
            "    # factories wrapped around it.",
            "    image_id = original_image.image_id",
            "    new_image = image_repo.get(image_id)",
            "    if new_image.status in ['saving']:",
            "        new_image.status = 'active'",
            "        new_image.size = original_image.size",
            "        new_image.virtual_size = original_image.virtual_size",
            "        new_image.checksum = original_image.checksum",
            "    else:",
            "        msg = _LE(\"The Image %(image_id)s object being created by this task \"",
            "                  \"%(task_id)s, is no longer in valid status for further \"",
            "                  \"processing.\" % {\"image_id\": new_image.image_id,",
            "                                   \"task_id\": task_id})",
            "        raise exception.Conflict(msg)",
            "    image_repo.save(new_image)",
            "",
            "    return image_id",
            "",
            "",
            "def create_image(image_repo, image_factory, image_properties, task_id):",
            "    _base_properties = []",
            "    for k, v in v2_api.get_base_properties().items():",
            "        _base_properties.append(k)",
            "",
            "    properties = {}",
            "    # NOTE: get the base properties",
            "    for key in _base_properties:",
            "        try:",
            "            properties[key] = image_properties.pop(key)",
            "        except KeyError:",
            "            msg = _(\"Task ID %(task_id)s: Ignoring property %(k)s for setting \"",
            "                    \"base properties while creating \"",
            "                    \"Image.\") % {'task_id': task_id, 'k': key}",
            "            LOG.debug(msg)",
            "",
            "    # NOTE: get the rest of the properties and pass them as",
            "    # extra_properties for Image to be created with them.",
            "    properties['extra_properties'] = image_properties",
            "    script_utils.set_base_image_properties(properties=properties)",
            "",
            "    image = image_factory.new_image(**properties)",
            "    image_repo.add(image)",
            "    return image",
            "",
            "",
            "def set_image_data(image, uri, task_id):",
            "    data_iter = None",
            "    try:",
            "        LOG.info(_LI(\"Task %(task_id)s: Got image data uri %(data_uri)s to be \"",
            "                 \"imported\") % {\"data_uri\": uri, \"task_id\": task_id})",
            "        data_iter = script_utils.get_image_data_iter(uri)",
            "        image.set_data(data_iter)",
            "    except Exception as e:",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.warn(_LW(\"Task %(task_id)s failed with exception %(error)s\") %",
            "                     {\"error\": common_utils.exception_to_str(e),",
            "                      \"task_id\": task_id})",
            "            LOG.info(_LI(\"Task %(task_id)s: Could not import image file\"",
            "                         \" %(image_data)s\") % {\"image_data\": uri,",
            "                                               \"task_id\": task_id})",
            "    finally:",
            "        if isinstance(data_iter, file):",
            "            data_iter.close()"
        ],
        "afterPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "__all__ = [",
            "    'run',",
            "]",
            "",
            "import six",
            "",
            "from glance.api.v2 import images as v2_api",
            "from glance.common import exception",
            "from glance.common.scripts import utils as script_utils",
            "from glance.common import utils as common_utils",
            "from glance import i18n",
            "from glance.openstack.common import excutils",
            "from glance.openstack.common import lockutils",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def run(t_id, context, task_repo, image_repo, image_factory):",
            "    LOG.info(_LI('Task %(task_id)s beginning import '",
            "                 'execution.') % {'task_id': t_id})",
            "    _execute(t_id, task_repo, image_repo, image_factory)",
            "",
            "",
            "# NOTE(nikhil): This lock prevents more than N number of threads to be spawn",
            "# simultaneously. The number N represents the number of threads in the",
            "# executor pool. The value is set to 10 in the eventlet executor.",
            "@lockutils.synchronized(\"glance_import\")",
            "def _execute(t_id, task_repo, image_repo, image_factory):",
            "    task = script_utils.get_task(task_repo, t_id)",
            "",
            "    if task is None:",
            "        # NOTE: This happens if task is not found in the database. In",
            "        # such cases, there is no way to update the task status so,",
            "        # it's ignored here.",
            "        return",
            "",
            "    try:",
            "        task_input = script_utils.unpack_task_input(task)",
            "",
            "        uri = script_utils.validate_location_uri(task_input.get('import_from'))",
            "        image_id = import_image(image_repo, image_factory, task_input, t_id,",
            "                                uri)",
            "",
            "        task.succeed({'image_id': image_id})",
            "    except Exception as e:",
            "        # Note: The message string contains Error in it to indicate",
            "        # in the task.message that it's a error message for the user.",
            "",
            "        #TODO(nikhil): need to bring back save_and_reraise_exception when",
            "        # necessary",
            "        err_msg = (\"Error: \" + six.text_type(type(e)) + ': ' +",
            "                   common_utils.exception_to_str(e))",
            "        log_msg = _LE(err_msg + (\"Task ID %s\" % task.task_id))",
            "        LOG.exception(log_msg)",
            "",
            "        task.fail(_LE(err_msg))",
            "    finally:",
            "        task_repo.save(task)",
            "",
            "",
            "def import_image(image_repo, image_factory, task_input, task_id, uri):",
            "    original_image = create_image(image_repo, image_factory,",
            "                                  task_input.get('image_properties'), task_id)",
            "    # NOTE: set image status to saving just before setting data",
            "    original_image.status = 'saving'",
            "    image_repo.save(original_image)",
            "    image_id = original_image.image_id",
            "",
            "    # NOTE: Retrieving image from the database because the Image object",
            "    # returned from create_image method does not have appropriate factories",
            "    # wrapped around it.",
            "    new_image = image_repo.get(image_id)",
            "    set_image_data(new_image, uri, None)",
            "",
            "    # NOTE: Check if the Image is not deleted after setting the data",
            "    # before saving the active image. Here if image status is",
            "    # saving, then new_image is saved as it contains updated location,",
            "    # size, virtual_size and checksum information and the status of",
            "    # new_image is already set to active in set_image_data() call.",
            "    image = image_repo.get(image_id)",
            "    if image.status == 'saving':",
            "        image_repo.save(new_image)",
            "        return image_id",
            "    else:",
            "        msg = _LE(\"The Image %(image_id)s object being created by this task \"",
            "                  \"%(task_id)s, is no longer in valid status for further \"",
            "                  \"processing.\" % {\"image_id\": new_image.image_id,",
            "                                   \"task_id\": task_id})",
            "        raise exception.Conflict(msg)",
            "",
            "",
            "def create_image(image_repo, image_factory, image_properties, task_id):",
            "    _base_properties = []",
            "    for k, v in v2_api.get_base_properties().items():",
            "        _base_properties.append(k)",
            "",
            "    properties = {}",
            "    # NOTE: get the base properties",
            "    for key in _base_properties:",
            "        try:",
            "            properties[key] = image_properties.pop(key)",
            "        except KeyError:",
            "            msg = _(\"Task ID %(task_id)s: Ignoring property %(k)s for setting \"",
            "                    \"base properties while creating \"",
            "                    \"Image.\") % {'task_id': task_id, 'k': key}",
            "            LOG.debug(msg)",
            "",
            "    # NOTE: get the rest of the properties and pass them as",
            "    # extra_properties for Image to be created with them.",
            "    properties['extra_properties'] = image_properties",
            "    script_utils.set_base_image_properties(properties=properties)",
            "",
            "    image = image_factory.new_image(**properties)",
            "    image_repo.add(image)",
            "    return image",
            "",
            "",
            "def set_image_data(image, uri, task_id):",
            "    data_iter = None",
            "    try:",
            "        LOG.info(_LI(\"Task %(task_id)s: Got image data uri %(data_uri)s to be \"",
            "                 \"imported\") % {\"data_uri\": uri, \"task_id\": task_id})",
            "        data_iter = script_utils.get_image_data_iter(uri)",
            "        image.set_data(data_iter)",
            "    except Exception as e:",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.warn(_LW(\"Task %(task_id)s failed with exception %(error)s\") %",
            "                     {\"error\": common_utils.exception_to_str(e),",
            "                      \"task_id\": task_id})",
            "            LOG.info(_LI(\"Task %(task_id)s: Could not import image file\"",
            "                         \" %(image_data)s\") % {\"image_data\": uri,",
            "                                               \"task_id\": task_id})",
            "    finally:",
            "        if isinstance(data_iter, file):",
            "            data_iter.close()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "import_image"
            ],
            "88": [
                "import_image"
            ],
            "89": [
                "import_image"
            ],
            "90": [
                "import_image"
            ],
            "91": [
                "import_image"
            ],
            "92": [
                "import_image"
            ],
            "93": [
                "import_image"
            ],
            "96": [
                "import_image"
            ],
            "97": [
                "import_image"
            ],
            "98": [
                "import_image"
            ],
            "99": [
                "import_image"
            ],
            "100": [
                "import_image"
            ],
            "107": [
                "import_image"
            ],
            "108": [
                "import_image"
            ],
            "109": [
                "import_image"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/common/scripts/image_import/test_main.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "                     image_id,"
            },
            "1": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "                     image_import_script.import_image(image_repo, image_factory,"
            },
            "2": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "                                                      task_input, None, uri))"
            },
            "3": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertEqual('active', image.status)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                # Check image is in saving state before image_repo.save called"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                self.assertEqual('saving', image.status)"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "                 self.assertTrue(image_repo.save.called)"
            },
            "7": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "                 mock_set_img_data.assert_called_once_with(image, uri, None)"
            },
            "8": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "                 self.assertTrue(image_repo.get.called)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "import urllib2",
            "",
            "from glance.common.scripts.image_import import main as image_import_script",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "class TestImageImport(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageImport, self).setUp()",
            "",
            "    def test_run(self):",
            "        with mock.patch.object(image_import_script,",
            "                               '_execute') as mock_execute:",
            "            task_id = mock.ANY",
            "            context = mock.ANY",
            "            task_repo = mock.ANY",
            "            image_repo = mock.ANY",
            "            image_factory = mock.ANY",
            "            image_import_script.run(task_id, context, task_repo, image_repo,",
            "                                    image_factory)",
            "",
            "        mock_execute.assert_called_once_with(task_id, task_repo, image_repo,",
            "                                             image_factory)",
            "",
            "    def test_import_image(self):",
            "        image_id = mock.ANY",
            "        image = mock.Mock(image_id=image_id)",
            "        image_repo = mock.Mock()",
            "        image_repo.get.return_value = image",
            "        image_factory = mock.ANY",
            "        task_input = mock.Mock(image_properties=mock.ANY)",
            "        uri = mock.ANY",
            "        with mock.patch.object(image_import_script,",
            "                               'create_image') as mock_create_image:",
            "            with mock.patch.object(image_import_script,",
            "                                   'set_image_data') as mock_set_img_data:",
            "                mock_create_image.return_value = image",
            "                self.assertEqual(",
            "                    image_id,",
            "                    image_import_script.import_image(image_repo, image_factory,",
            "                                                     task_input, None, uri))",
            "                self.assertEqual('active', image.status)",
            "                self.assertTrue(image_repo.save.called)",
            "                mock_set_img_data.assert_called_once_with(image, uri, None)",
            "                self.assertTrue(image_repo.get.called)",
            "                self.assertTrue(image_repo.save.called)",
            "",
            "    def test_create_image(self):",
            "        image = mock.ANY",
            "        image_repo = mock.Mock()",
            "        image_factory = mock.Mock()",
            "        image_factory.new_image.return_value = image",
            "",
            "        # Note: include some base properties to ensure no error while",
            "        # attempting to verify them",
            "        image_properties = {'disk_format': 'foo',",
            "                            'id': 'bar'}",
            "",
            "        self.assertEqual(image,",
            "                         image_import_script.create_image(image_repo,",
            "                                                          image_factory,",
            "                                                          image_properties,",
            "                                                          None))",
            "",
            "    def test_set_image_data_http(self):",
            "        uri = 'http://www.example.com'",
            "        image = mock.Mock()",
            "        self.assertEqual(None,",
            "                         image_import_script.set_image_data(image, uri, None))",
            "",
            "    def test_set_image_data_http_error(self):",
            "        uri = 'blahhttp://www.example.com'",
            "        image = mock.Mock()",
            "        self.assertRaises(urllib2.URLError,",
            "                          image_import_script.set_image_data, image, uri, None)"
        ],
        "afterPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "import urllib2",
            "",
            "from glance.common.scripts.image_import import main as image_import_script",
            "import glance.tests.utils as test_utils",
            "",
            "",
            "class TestImageImport(test_utils.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(TestImageImport, self).setUp()",
            "",
            "    def test_run(self):",
            "        with mock.patch.object(image_import_script,",
            "                               '_execute') as mock_execute:",
            "            task_id = mock.ANY",
            "            context = mock.ANY",
            "            task_repo = mock.ANY",
            "            image_repo = mock.ANY",
            "            image_factory = mock.ANY",
            "            image_import_script.run(task_id, context, task_repo, image_repo,",
            "                                    image_factory)",
            "",
            "        mock_execute.assert_called_once_with(task_id, task_repo, image_repo,",
            "                                             image_factory)",
            "",
            "    def test_import_image(self):",
            "        image_id = mock.ANY",
            "        image = mock.Mock(image_id=image_id)",
            "        image_repo = mock.Mock()",
            "        image_repo.get.return_value = image",
            "        image_factory = mock.ANY",
            "        task_input = mock.Mock(image_properties=mock.ANY)",
            "        uri = mock.ANY",
            "        with mock.patch.object(image_import_script,",
            "                               'create_image') as mock_create_image:",
            "            with mock.patch.object(image_import_script,",
            "                                   'set_image_data') as mock_set_img_data:",
            "                mock_create_image.return_value = image",
            "                self.assertEqual(",
            "                    image_id,",
            "                    image_import_script.import_image(image_repo, image_factory,",
            "                                                     task_input, None, uri))",
            "                # Check image is in saving state before image_repo.save called",
            "                self.assertEqual('saving', image.status)",
            "                self.assertTrue(image_repo.save.called)",
            "                mock_set_img_data.assert_called_once_with(image, uri, None)",
            "                self.assertTrue(image_repo.get.called)",
            "                self.assertTrue(image_repo.save.called)",
            "",
            "    def test_create_image(self):",
            "        image = mock.ANY",
            "        image_repo = mock.Mock()",
            "        image_factory = mock.Mock()",
            "        image_factory.new_image.return_value = image",
            "",
            "        # Note: include some base properties to ensure no error while",
            "        # attempting to verify them",
            "        image_properties = {'disk_format': 'foo',",
            "                            'id': 'bar'}",
            "",
            "        self.assertEqual(image,",
            "                         image_import_script.create_image(image_repo,",
            "                                                          image_factory,",
            "                                                          image_properties,",
            "                                                          None))",
            "",
            "    def test_set_image_data_http(self):",
            "        uri = 'http://www.example.com'",
            "        image = mock.Mock()",
            "        self.assertEqual(None,",
            "                         image_import_script.set_image_data(image, uri, None))",
            "",
            "    def test_set_image_data_http_error(self):",
            "        uri = 'blahhttp://www.example.com'",
            "        image = mock.Mock()",
            "        self.assertRaises(urllib2.URLError,",
            "                          image_import_script.set_image_data, image, uri, None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "59": [
                "TestImageImport",
                "test_import_image"
            ]
        },
        "addLocation": []
    }
}