{
    "arches/app/models/concept.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from django.utils.translation import ugettext as _\r"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from django.utils.translation import get_language\r"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from django.db import IntegrityError\r"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+from psycopg2.extensions import AsIs\r"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+\r"
            },
            "5": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " import logging\r"
            },
            "6": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " \r"
            },
            "7": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " \r"
            },
            "8": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 507,
                "PatchRowcode": "         except:\r"
            },
            "9": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "             return []\r"
            },
            "10": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": 509,
                "PatchRowcode": " \r"
            },
            "11": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        languageid = get_language() if languageid is None else languageid\r"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+        # this interpolation is safe because `relationtypes` is hardcoded in all calls, and not accessible via the API\r"
            },
            "13": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "         relationtypes = \" or \".join([\"r.relationtype = '%s'\" % (relationtype) for relationtype in relationtypes])\r"
            },
            "14": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        depth_limit = \"and depth < %s\" % depth_limit if depth_limit else \"\"\r"
            },
            "15": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        child_valuetypes = (\"','\").join(\r"
            },
            "16": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            child_valuetypes if child_valuetypes else models.DValueType.objects.filter(category=\"label\").values_list(\"valuetype\", flat=True)\r"
            },
            "17": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )\r"
            },
            "18": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        limit_clause = \" limit %s offset %s\" % (limit, offset) if offset is not None else \"\"\r"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+        offset_clause = \" limit %(limit)s offset %(offset)s\" if offset else \"\"\r"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+        depth_clause = \" and depth < %(depth_limit)s\" if depth_limit else \"\"\r"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+\r"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 515,
                "PatchRowcode": "+        cursor = connection.cursor()\r"
            },
            "23": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 516,
                "PatchRowcode": " \r"
            },
            "24": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 517,
                "PatchRowcode": "         if order_hierarchically:\r"
            },
            "25": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 518,
                "PatchRowcode": "             sql = \"\"\"\r"
            },
            "26": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 526,
                "PatchRowcode": "                             WHERE conceptid=r.conceptidto\r"
            },
            "27": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": 527,
                "PatchRowcode": "                             AND valuetype in ('prefLabel')\r"
            },
            "28": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": 528,
                "PatchRowcode": "                             ORDER BY (\r"
            },
            "29": {
                "beforePatchRowNumber": 528,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                CASE WHEN languageid = '{languageid}' THEN 10\r"
            },
            "30": {
                "beforePatchRowNumber": 529,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                WHEN languageid like '{short_languageid}%' THEN 5\r"
            },
            "31": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                WHEN languageid like '{default_languageid}%' THEN 2\r"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 529,
                "PatchRowcode": "+                                CASE WHEN languageid = %(languageid)s THEN 10\r"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 530,
                "PatchRowcode": "+                                WHEN languageid like %(short_languageid)s THEN 5\r"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 531,
                "PatchRowcode": "+                                WHEN languageid like %(default_languageid)s THEN 2\r"
            },
            "35": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 532,
                "PatchRowcode": "                                 ELSE 0\r"
            },
            "36": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 533,
                "PatchRowcode": "                                 END\r"
            },
            "37": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": 534,
                "PatchRowcode": "                             ) desc limit 1\r"
            },
            "38": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "                             limit 1\r"
            },
            "39": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "                         ) as collector\r"
            },
            "40": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "                         FROM relations r\r"
            },
            "41": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE r.conceptidfrom = '{conceptid}'\r"
            },
            "42": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        and ({relationtypes})\r"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 551,
                "PatchRowcode": "+                        WHERE r.conceptidfrom = %(conceptid)s\r"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 552,
                "PatchRowcode": "+                        and (%(relationtypes)s)\r"
            },
            "45": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 553,
                "PatchRowcode": "                         ORDER BY sortorder, valuesto\r"
            },
            "46": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": 554,
                "PatchRowcode": "                     )\r"
            },
            "47": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 555,
                "PatchRowcode": "                     UNION\r"
            },
            "48": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "                             WHERE conceptid=r.conceptidto\r"
            },
            "49": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": 561,
                "PatchRowcode": "                             AND valuetype in ('prefLabel')\r"
            },
            "50": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 562,
                "PatchRowcode": "                             ORDER BY (\r"
            },
            "51": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                CASE WHEN languageid = '{languageid}' THEN 10\r"
            },
            "52": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                WHEN languageid like '{short_languageid}%' THEN 5\r"
            },
            "53": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                WHEN languageid like '{default_languageid}%' THEN 2\r"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 563,
                "PatchRowcode": "+                                CASE WHEN languageid = %(languageid)s THEN 10\r"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 564,
                "PatchRowcode": "+                                WHEN languageid like %(short_languageid)s THEN 5\r"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+                                WHEN languageid like %(default_languageid)s THEN 2\r"
            },
            "57": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "                                 ELSE 0\r"
            },
            "58": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "                                 END\r"
            },
            "59": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 568,
                "PatchRowcode": "                             ) desc limit 1\r"
            },
            "60": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "                         ) as collector\r"
            },
            "61": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "                         FROM relations r\r"
            },
            "62": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "                         JOIN ordered_relationships b ON(b.conceptidto = r.conceptidfrom)\r"
            },
            "63": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE ({relationtypes})\r"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 586,
                "PatchRowcode": "+                        WHERE (%(relationtypes)s)\r"
            },
            "65": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "                         ORDER BY sortorder, valuesto\r"
            },
            "66": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": 588,
                "PatchRowcode": "                     )\r"
            },
            "67": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 589,
                "PatchRowcode": "                 ),\r"
            },
            "68": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "                         r.collector,\r"
            },
            "69": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "                         1 AS depth       ---|NonRecursive Part\r"
            },
            "70": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 596,
                "PatchRowcode": "                         FROM ordered_relationships r\r"
            },
            "71": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE r.conceptidfrom = '{conceptid}'\r"
            },
            "72": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        and ({relationtypes})\r"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+                        WHERE r.conceptidfrom = %(conceptid)s\r"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+                        and (%(relationtypes)s)\r"
            },
            "75": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 599,
                "PatchRowcode": "                     UNION\r"
            },
            "76": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 600,
                "PatchRowcode": "                         SELECT r.conceptidfrom, r.conceptidto,\r"
            },
            "77": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 601,
                "PatchRowcode": "                         row || '-' || to_char(row_number() OVER (), 'fm000000'),\r"
            },
            "78": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": 602,
                "PatchRowcode": "                         r.collector,\r"
            },
            "79": {
                "beforePatchRowNumber": 602,
                "afterPatchRowNumber": 603,
                "PatchRowcode": "                         depth+1      ---|RecursivePart\r"
            },
            "80": {
                "beforePatchRowNumber": 603,
                "afterPatchRowNumber": 604,
                "PatchRowcode": "                         FROM ordered_relationships r\r"
            },
            "81": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": 605,
                "PatchRowcode": "                         JOIN children b ON(b.conceptidto = r.conceptidfrom)\r"
            },
            "82": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE ({relationtypes})\r"
            },
            "83": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        {depth_limit}\r"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+                        WHERE (%(relationtypes)s)\r"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+                        {depth_clause}\r"
            },
            "86": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 608,
                "PatchRowcode": "                 )\r"
            },
            "87": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 609,
                "PatchRowcode": " \r"
            },
            "88": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "                 {subquery}\r"
            },
            "89": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "                     FROM (\r"
            },
            "90": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 616,
                "PatchRowcode": "                         SELECT *\r"
            },
            "91": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "                         FROM values\r"
            },
            "92": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE conceptid={recursive_table}.conceptidto\r"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+                        WHERE conceptid=%(recursive_table)s.conceptidto\r"
            },
            "94": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "                         AND valuetype in ('prefLabel')\r"
            },
            "95": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 620,
                "PatchRowcode": "                         ORDER BY (\r"
            },
            "96": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            CASE WHEN languageid = '{languageid}' THEN 10\r"
            },
            "97": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            WHEN languageid like '{short_languageid}%' THEN 5\r"
            },
            "98": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            WHEN languageid like '{default_languageid}%' THEN 2\r"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+                            CASE WHEN languageid = %(languageid)s THEN 10\r"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+                            WHEN languageid like %(short_languageid)s THEN 5\r"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+                            WHEN languageid like %(default_languageid)s THEN 2\r"
            },
            "102": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "                             ELSE 0\r"
            },
            "103": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "                             END\r"
            },
            "104": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "                         ) desc limit 1\r"
            },
            "105": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "                     ) d\r"
            },
            "106": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": 628,
                "PatchRowcode": "                 ) as valueto,\r"
            },
            "107": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 629,
                "PatchRowcode": "                 depth, collector, count(*) OVER() AS full_count\r"
            },
            "108": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": 630,
                "PatchRowcode": " \r"
            },
            "109": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-               FROM {recursive_table} order by row {limit_clause};\r"
            },
            "110": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\r"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+               FROM %(recursive_table)s order by row {offset_clause};\r"
            },
            "112": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 632,
                "PatchRowcode": "             \"\"\"\r"
            },
            "113": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 633,
                "PatchRowcode": " \r"
            },
            "114": {
                "beforePatchRowNumber": 634,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            subquery = (\r"
            },
            "115": {
                "beforePatchRowNumber": 635,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"\"\", results as (\r"
            },
            "116": {
                "beforePatchRowNumber": 636,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r"
            },
            "117": {
                "beforePatchRowNumber": 637,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                FROM children c\r"
            },
            "118": {
                "beforePatchRowNumber": 638,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN values ON(values.conceptid = c.conceptidto)\r"
            },
            "119": {
                "beforePatchRowNumber": 639,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                WHERE LOWER(values.value) like '%%%s%%'\r"
            },
            "120": {
                "beforePatchRowNumber": 640,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                AND values.valuetype in ('prefLabel')\r"
            },
            "121": {
                "beforePatchRowNumber": 641,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    UNION\r"
            },
            "122": {
                "beforePatchRowNumber": 642,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r"
            },
            "123": {
                "beforePatchRowNumber": 643,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                FROM children c\r"
            },
            "124": {
                "beforePatchRowNumber": 644,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN results r on (r.conceptidfrom=c.conceptidto)\r"
            },
            "125": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )\"\"\"\r"
            },
            "126": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                % query.lower()\r"
            },
            "127": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if query is not None\r"
            },
            "128": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else \"\"\r"
            },
            "129": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )\r"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+            if query:\r"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+                subquery = \"\"\"\r"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+                        , results as (\r"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+                            SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+                            FROM children c\r"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+                            JOIN values ON(values.conceptid = c.conceptidto)\r"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+                            WHERE LOWER(values.value) like %(query)s\r"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+                            AND values.valuetype in ('prefLabel')\r"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+                                UNION\r"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+                            SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 644,
                "PatchRowcode": "+                            FROM children c\r"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 645,
                "PatchRowcode": "+                            JOIN results r on (r.conceptidfrom=c.conceptidto)\r"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 646,
                "PatchRowcode": "+                        )\r"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 647,
                "PatchRowcode": "+                    \"\"\"\r"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+            else:\r"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+                subquery = \"\"\r"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+\r"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+            sql = sql.format(subquery=subquery, offset_clause=offset_clause, depth_clause=depth_clause)\r"
            },
            "148": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 652,
                "PatchRowcode": " \r"
            },
            "149": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 653,
                "PatchRowcode": "             recursive_table = \"results\" if query else \"children\"\r"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+            languageid = get_language() if languageid is None else languageid\r"
            },
            "151": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 655,
                "PatchRowcode": " \r"
            },
            "152": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            sql = sql.format(\r"
            },
            "153": {
                "beforePatchRowNumber": 654,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                conceptid=conceptid,\r"
            },
            "154": {
                "beforePatchRowNumber": 655,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                relationtypes=relationtypes,\r"
            },
            "155": {
                "beforePatchRowNumber": 656,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                child_valuetypes=child_valuetypes,\r"
            },
            "156": {
                "beforePatchRowNumber": 657,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                parent_valuetype=parent_valuetype,\r"
            },
            "157": {
                "beforePatchRowNumber": 658,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                depth_limit=depth_limit,\r"
            },
            "158": {
                "beforePatchRowNumber": 659,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                limit_clause=limit_clause,\r"
            },
            "159": {
                "beforePatchRowNumber": 660,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                subquery=subquery,\r"
            },
            "160": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                recursive_table=recursive_table,\r"
            },
            "161": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                languageid=languageid,\r"
            },
            "162": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                short_languageid=languageid.split(\"-\")[0],\r"
            },
            "163": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                default_languageid=settings.LANGUAGE_CODE,\r"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+            cursor.execute(\r"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+                sql,\r"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+                {\r"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+                    \"conceptid\": conceptid,\r"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+                    \"relationtypes\": AsIs(relationtypes),\r"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+                    \"depth_limit\": depth_limit,\r"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 662,
                "PatchRowcode": "+                    \"limit\": limit,\r"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+                    \"offset\": offset,\r"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 664,
                "PatchRowcode": "+                    \"query\": \"%\" + query.lower() + \"%\",\r"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 665,
                "PatchRowcode": "+                    \"recursive_table\": AsIs(recursive_table),\r"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+                    \"languageid\": languageid,\r"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+                    \"short_languageid\": languageid.split(\"-\")[0] + \"%\",\r"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 668,
                "PatchRowcode": "+                    \"default_languageid\": settings.LANGUAGE_CODE + \"%\",\r"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 669,
                "PatchRowcode": "+                },\r"
            },
            "178": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 670,
                "PatchRowcode": "             )\r"
            },
            "179": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\r"
            },
            "180": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 671,
                "PatchRowcode": "         else:\r"
            },
            "181": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "             sql = \"\"\"\r"
            },
            "182": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 673,
                "PatchRowcode": "                 WITH RECURSIVE\r"
            },
            "183": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": 674,
                "PatchRowcode": "                     children AS (\r"
            },
            "184": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "                         SELECT r.conceptidfrom, r.conceptidto, r.relationtype, 1 AS depth\r"
            },
            "185": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "                             FROM relations r\r"
            },
            "186": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            WHERE r.conceptidfrom = '{conceptid}'\r"
            },
            "187": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            AND ({relationtypes})\r"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+                            WHERE r.conceptidfrom = %(conceptid)s\r"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+                            AND (%(relationtypes)s)\r"
            },
            "190": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 679,
                "PatchRowcode": "                         UNION\r"
            },
            "191": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 680,
                "PatchRowcode": "                             SELECT r.conceptidfrom, r.conceptidto, r.relationtype, depth+1\r"
            },
            "192": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": 681,
                "PatchRowcode": "                             FROM relations r\r"
            },
            "193": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": 682,
                "PatchRowcode": "                             JOIN children c ON(c.conceptidto = r.conceptidfrom)\r"
            },
            "194": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            WHERE ({relationtypes})\r"
            },
            "195": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            {depth_limit}\r"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+                            WHERE (%(relationtypes)s)\r"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+                            {depth_clause}\r"
            },
            "198": {
                "beforePatchRowNumber": 681,
                "afterPatchRowNumber": 685,
                "PatchRowcode": "                     ),\r"
            },
            "199": {
                "beforePatchRowNumber": 682,
                "afterPatchRowNumber": 686,
                "PatchRowcode": "                     results AS (\r"
            },
            "200": {
                "beforePatchRowNumber": 683,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "                         SELECT\r"
            },
            "201": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 696,
                "PatchRowcode": "                             JOIN children c ON(c.conceptidto = valueto.conceptid)\r"
            },
            "202": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 697,
                "PatchRowcode": "                             JOIN values valuefrom ON(c.conceptidfrom = valuefrom.conceptid)\r"
            },
            "203": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "                             JOIN d_value_types dtypesfrom ON(dtypesfrom.valuetype = valuefrom.valuetype)\r"
            },
            "204": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHERE valueto.valuetype in ('{child_valuetypes}')\r"
            },
            "205": {
                "beforePatchRowNumber": 696,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        AND valuefrom.valuetype in ('{child_valuetypes}')\r"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+                        WHERE valueto.valuetype in (%(child_valuetypes)s)\r"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+                        AND valuefrom.valuetype in (%(child_valuetypes)s)\r"
            },
            "208": {
                "beforePatchRowNumber": 697,
                "afterPatchRowNumber": 701,
                "PatchRowcode": "                     )\r"
            },
            "209": {
                "beforePatchRowNumber": 698,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    SELECT distinct {columns}\r"
            },
            "210": {
                "beforePatchRowNumber": 699,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    FROM results {limit_clause}\r"
            },
            "211": {
                "beforePatchRowNumber": 700,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\r"
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 702,
                "PatchRowcode": "+                    SELECT distinct %(columns)s\r"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 703,
                "PatchRowcode": "+                    FROM results {offset_clause}\r"
            },
            "214": {
                "beforePatchRowNumber": 701,
                "afterPatchRowNumber": 704,
                "PatchRowcode": "             \"\"\"\r"
            },
            "215": {
                "beforePatchRowNumber": 702,
                "afterPatchRowNumber": 705,
                "PatchRowcode": " \r"
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+            sql = sql.format(offset_clause=offset_clause, depth_clause=depth_clause)\r"
            },
            "217": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+\r"
            },
            "218": {
                "beforePatchRowNumber": 703,
                "afterPatchRowNumber": 708,
                "PatchRowcode": "             if not columns:\r"
            },
            "219": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": 709,
                "PatchRowcode": "                 columns = \"\"\"\r"
            },
            "220": {
                "beforePatchRowNumber": 705,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "                     conceptidfrom::text, conceptidto::text,\r"
            },
            "221": {
                "beforePatchRowNumber": 710,
                "afterPatchRowNumber": 715,
                "PatchRowcode": "                     categoryfrom, categoryto\r"
            },
            "222": {
                "beforePatchRowNumber": 711,
                "afterPatchRowNumber": 716,
                "PatchRowcode": "                 \"\"\"\r"
            },
            "223": {
                "beforePatchRowNumber": 712,
                "afterPatchRowNumber": 717,
                "PatchRowcode": " \r"
            },
            "224": {
                "beforePatchRowNumber": 713,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            sql = sql.format(\r"
            },
            "225": {
                "beforePatchRowNumber": 714,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                conceptid=conceptid,\r"
            },
            "226": {
                "beforePatchRowNumber": 715,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                relationtypes=relationtypes,\r"
            },
            "227": {
                "beforePatchRowNumber": 716,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                child_valuetypes=child_valuetypes,\r"
            },
            "228": {
                "beforePatchRowNumber": 717,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                columns=columns,\r"
            },
            "229": {
                "beforePatchRowNumber": 718,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                depth_limit=depth_limit,\r"
            },
            "230": {
                "beforePatchRowNumber": 719,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                limit_clause=limit_clause,\r"
            },
            "231": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 718,
                "PatchRowcode": "+            cursor.execute(\r"
            },
            "232": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 719,
                "PatchRowcode": "+                sql,\r"
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 720,
                "PatchRowcode": "+                {\r"
            },
            "234": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 721,
                "PatchRowcode": "+                    \"conceptid\": conceptid,\r"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 722,
                "PatchRowcode": "+                    \"relationtypes\": AsIs(relationtypes),\r"
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 723,
                "PatchRowcode": "+                    \"child_valuetypes\": (\"','\").join(\r"
            },
            "237": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 724,
                "PatchRowcode": "+                        child_valuetypes\r"
            },
            "238": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 725,
                "PatchRowcode": "+                        if child_valuetypes\r"
            },
            "239": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 726,
                "PatchRowcode": "+                        else models.DValueType.objects.filter(category=\"label\").values_list(\"valuetype\", flat=True)\r"
            },
            "240": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 727,
                "PatchRowcode": "+                    ),\r"
            },
            "241": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 728,
                "PatchRowcode": "+                    \"columns\": AsIs(columns),\r"
            },
            "242": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 729,
                "PatchRowcode": "+                    \"depth_limit\": depth_limit,\r"
            },
            "243": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 730,
                "PatchRowcode": "+                    \"limit\": limit,\r"
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 731,
                "PatchRowcode": "+                    \"offset\": offset,\r"
            },
            "245": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 732,
                "PatchRowcode": "+                },\r"
            },
            "246": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": 733,
                "PatchRowcode": "             )\r"
            },
            "247": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": 734,
                "PatchRowcode": " \r"
            },
            "248": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cursor = connection.cursor()\r"
            },
            "249": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cursor.execute(sql)\r"
            },
            "250": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rows = cursor.fetchall()\r"
            },
            "251": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return rows\r"
            },
            "252": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 735,
                "PatchRowcode": "+        return cursor.fetchall()\r"
            },
            "253": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 736,
                "PatchRowcode": " \r"
            },
            "254": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 737,
                "PatchRowcode": "     def traverse(self, func, direction=\"down\", scope=None, **kwargs):\r"
            },
            "255": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "         \"\"\"\r"
            },
            "256": {
                "beforePatchRowNumber": 1176,
                "afterPatchRowNumber": 1186,
                "PatchRowcode": " \r"
            },
            "257": {
                "beforePatchRowNumber": 1177,
                "afterPatchRowNumber": 1187,
                "PatchRowcode": "         \"\"\"\r"
            },
            "258": {
                "beforePatchRowNumber": 1178,
                "afterPatchRowNumber": 1188,
                "PatchRowcode": "         cursor = connection.cursor()\r"
            },
            "259": {
                "beforePatchRowNumber": 1179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\r"
            },
            "260": {
                "beforePatchRowNumber": 1180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql = \"\"\"\r"
            },
            "261": {
                "beforePatchRowNumber": 1181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        WITH RECURSIVE children AS (\r"
            },
            "262": {
                "beforePatchRowNumber": 1182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            SELECT d.conceptidfrom, d.conceptidto, c2.value, c2.valueid as valueid, c.value as valueto, c.valueid as valueidto, c.valuetype as vtype, 1 AS depth, array[d.conceptidto] AS conceptpath, array[c.valueid] AS idpath        ---|NonRecursive Part\r"
            },
            "263": {
                "beforePatchRowNumber": 1183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                FROM relations d\r"
            },
            "264": {
                "beforePatchRowNumber": 1184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN values c ON(c.conceptid = d.conceptidto)\r"
            },
            "265": {
                "beforePatchRowNumber": 1185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN values c2 ON(c2.conceptid = d.conceptidfrom)\r"
            },
            "266": {
                "beforePatchRowNumber": 1186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                WHERE d.conceptidfrom = '{0}'\r"
            },
            "267": {
                "beforePatchRowNumber": 1187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and c2.valuetype = 'prefLabel'\r"
            },
            "268": {
                "beforePatchRowNumber": 1188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and c.valuetype in ('prefLabel', 'sortorder', 'collector')\r"
            },
            "269": {
                "beforePatchRowNumber": 1189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r"
            },
            "270": {
                "beforePatchRowNumber": 1190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                UNION\r"
            },
            "271": {
                "beforePatchRowNumber": 1191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                SELECT d.conceptidfrom, d.conceptidto, v2.value, v2.valueid as valueid, v.value as valueto, v.valueid as valueidto, v.valuetype as vtype, depth+1, (conceptpath || d.conceptidto), (idpath || v.valueid)   ---|RecursivePart\r"
            },
            "272": {
                "beforePatchRowNumber": 1192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                FROM relations  d\r"
            },
            "273": {
                "beforePatchRowNumber": 1193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN children b ON(b.conceptidto = d.conceptidfrom)\r"
            },
            "274": {
                "beforePatchRowNumber": 1194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN values v ON(v.conceptid = d.conceptidto)\r"
            },
            "275": {
                "beforePatchRowNumber": 1195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                JOIN values v2 ON(v2.conceptid = d.conceptidfrom)\r"
            },
            "276": {
                "beforePatchRowNumber": 1196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                WHERE  v2.valuetype = 'prefLabel'\r"
            },
            "277": {
                "beforePatchRowNumber": 1197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and v.valuetype in ('prefLabel','sortorder', 'collector')\r"
            },
            "278": {
                "beforePatchRowNumber": 1198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r"
            },
            "279": {
                "beforePatchRowNumber": 1199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ) SELECT conceptidfrom::text, conceptidto::text, value, valueid::text, valueto, valueidto::text, depth, idpath::text, conceptpath::text, vtype FROM children ORDER BY depth, conceptpath;\r"
            },
            "280": {
                "beforePatchRowNumber": 1200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\".format(\r"
            },
            "281": {
                "beforePatchRowNumber": 1201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            conceptid\r"
            },
            "282": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1189,
                "PatchRowcode": "+        cursor.execute(\r"
            },
            "283": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1190,
                "PatchRowcode": "+            \"\"\"\r"
            },
            "284": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1191,
                "PatchRowcode": "+            WITH RECURSIVE children AS (\r"
            },
            "285": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1192,
                "PatchRowcode": "+                SELECT d.conceptidfrom, d.conceptidto, c2.value, c2.valueid as valueid, c.value as valueto, c.valueid as valueidto, c.valuetype as vtype, 1 AS depth, array[d.conceptidto] AS conceptpath, array[c.valueid] AS idpath        ---|NonRecursive Part\r"
            },
            "286": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1193,
                "PatchRowcode": "+                    FROM relations d\r"
            },
            "287": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1194,
                "PatchRowcode": "+                    JOIN values c ON(c.conceptid = d.conceptidto)\r"
            },
            "288": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "+                    JOIN values c2 ON(c2.conceptid = d.conceptidfrom)\r"
            },
            "289": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1196,
                "PatchRowcode": "+                    WHERE d.conceptidfrom = %s\r"
            },
            "290": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1197,
                "PatchRowcode": "+                    and c2.valuetype = 'prefLabel'\r"
            },
            "291": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "+                    and c.valuetype in ('prefLabel', 'sortorder', 'collector')\r"
            },
            "292": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "+                    and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r"
            },
            "293": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1200,
                "PatchRowcode": "+                    UNION\r"
            },
            "294": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1201,
                "PatchRowcode": "+                    SELECT d.conceptidfrom, d.conceptidto, v2.value, v2.valueid as valueid, v.value as valueto, v.valueid as valueidto, v.valuetype as vtype, depth+1, (conceptpath || d.conceptidto), (idpath || v.valueid)   ---|RecursivePart\r"
            },
            "295": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1202,
                "PatchRowcode": "+                    FROM relations  d\r"
            },
            "296": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1203,
                "PatchRowcode": "+                    JOIN children b ON(b.conceptidto = d.conceptidfrom)\r"
            },
            "297": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1204,
                "PatchRowcode": "+                    JOIN values v ON(v.conceptid = d.conceptidto)\r"
            },
            "298": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "+                    JOIN values v2 ON(v2.conceptid = d.conceptidfrom)\r"
            },
            "299": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "+                    WHERE  v2.valuetype = 'prefLabel'\r"
            },
            "300": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1207,
                "PatchRowcode": "+                    and v.valuetype in ('prefLabel','sortorder', 'collector')\r"
            },
            "301": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1208,
                "PatchRowcode": "+                    and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r"
            },
            "302": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1209,
                "PatchRowcode": "+                ) SELECT conceptidfrom::text, conceptidto::text, value, valueid::text, valueto, valueidto::text, depth, idpath::text, conceptpath::text, vtype FROM children ORDER BY depth, conceptpath;\r"
            },
            "303": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1210,
                "PatchRowcode": "+            \"\"\",\r"
            },
            "304": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1211,
                "PatchRowcode": "+            [conceptid],\r"
            },
            "305": {
                "beforePatchRowNumber": 1202,
                "afterPatchRowNumber": 1212,
                "PatchRowcode": "         )\r"
            },
            "306": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1213,
                "PatchRowcode": "+        rows = cursor.fetchall()\r"
            },
            "307": {
                "beforePatchRowNumber": 1203,
                "afterPatchRowNumber": 1214,
                "PatchRowcode": " \r"
            },
            "308": {
                "beforePatchRowNumber": 1204,
                "afterPatchRowNumber": 1215,
                "PatchRowcode": "         column_names = [\r"
            },
            "309": {
                "beforePatchRowNumber": 1205,
                "afterPatchRowNumber": 1216,
                "PatchRowcode": "             \"conceptidfrom\",\r"
            },
            "310": {
                "beforePatchRowNumber": 1213,
                "afterPatchRowNumber": 1224,
                "PatchRowcode": "             \"conceptpath\",\r"
            },
            "311": {
                "beforePatchRowNumber": 1214,
                "afterPatchRowNumber": 1225,
                "PatchRowcode": "             \"vtype\",\r"
            },
            "312": {
                "beforePatchRowNumber": 1215,
                "afterPatchRowNumber": 1226,
                "PatchRowcode": "         ]\r"
            },
            "313": {
                "beforePatchRowNumber": 1216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cursor.execute(sql)\r"
            },
            "314": {
                "beforePatchRowNumber": 1217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rows = cursor.fetchall()\r"
            },
            "315": {
                "beforePatchRowNumber": 1218,
                "afterPatchRowNumber": 1227,
                "PatchRowcode": " \r"
            },
            "316": {
                "beforePatchRowNumber": 1219,
                "afterPatchRowNumber": 1228,
                "PatchRowcode": "         class Val(object):\r"
            },
            "317": {
                "beforePatchRowNumber": 1220,
                "afterPatchRowNumber": 1229,
                "PatchRowcode": "             def __init__(self, conceptid):\r"
            }
        },
        "frontPatchFile": [
            "\"\"\"\r",
            "ARCHES - a program developed to inventory and manage immovable cultural heritage.\r",
            "Copyright (C) 2013 J. Paul Getty Trust and World Monuments Fund\r",
            "\r",
            "This program is free software: you can redistribute it and/or modify\r",
            "it under the terms of the GNU Affero General Public License as\r",
            "published by the Free Software Foundation, either version 3 of the\r",
            "License, or (at your option) any later version.\r",
            "\r",
            "This program is distributed in the hope that it will be useful,\r",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of\r",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r",
            "GNU Affero General Public License for more details.\r",
            "\r",
            "You should have received a copy of the GNU Affero General Public License\r",
            "along with this program. If not, see <http://www.gnu.org/licenses/>.\r",
            "\"\"\"\r",
            "\r",
            "import re\r",
            "import uuid\r",
            "import copy\r",
            "from operator import itemgetter\r",
            "from operator import methodcaller\r",
            "from django.db import transaction, connection\r",
            "from django.db.models import Q\r",
            "from arches.app.models import models\r",
            "from arches.app.models.system_settings import settings\r",
            "from arches.app.search.search_engine_factory import SearchEngineInstance as se\r",
            "from arches.app.search.elasticsearch_dsl_builder import Term, Query, Bool, Match, Terms\r",
            "from arches.app.search.mappings import CONCEPTS_INDEX\r",
            "from arches.app.utils.betterJSONSerializer import JSONSerializer, JSONDeserializer\r",
            "from django.utils.translation import ugettext as _\r",
            "from django.utils.translation import get_language\r",
            "from django.db import IntegrityError\r",
            "import logging\r",
            "\r",
            "\r",
            "logger = logging.getLogger(__name__)\r",
            "\r",
            "CORE_CONCEPTS = (\r",
            "    \"00000000-0000-0000-0000-000000000001\",\r",
            "    \"00000000-0000-0000-0000-000000000004\",\r",
            "    \"00000000-0000-0000-0000-000000000005\",\r",
            "    \"00000000-0000-0000-0000-000000000006\",\r",
            ")\r",
            "\r",
            "\r",
            "class Concept(object):\r",
            "    def __init__(self, *args, **kwargs):\r",
            "        self.id = \"\"\r",
            "        self.nodetype = \"\"\r",
            "        self.legacyoid = \"\"\r",
            "        self.relationshiptype = \"\"\r",
            "        self.values = []\r",
            "        self.subconcepts = []\r",
            "        self.parentconcepts = []\r",
            "        self.relatedconcepts = []\r",
            "        self.hassubconcepts = False\r",
            "\r",
            "        if len(args) != 0:\r",
            "            if isinstance(args[0], str):\r",
            "                try:\r",
            "                    uuid.UUID(args[0])\r",
            "                    self.get(args[0])\r",
            "                except (ValueError):\r",
            "                    self.load(JSONDeserializer().deserialize(args[0]))\r",
            "            elif isinstance(args[0], dict):\r",
            "                self.load(args[0])\r",
            "            elif isinstance(args[0], object):\r",
            "                self.load(args[0])\r",
            "\r",
            "    def __unicode__(self):\r",
            "        return (\"%s - %s\") % (self.get_preflabel().value, self.id)\r",
            "\r",
            "    def __hash__(self):\r",
            "        return hash(self.id)\r",
            "\r",
            "    def __eq__(self, x):\r",
            "        return hash(self) == hash(x)\r",
            "\r",
            "    def __ne__(self, x):\r",
            "        return hash(self) != hash(x)\r",
            "\r",
            "    def load(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.id = str(value[\"id\"]) if \"id\" in value else \"\"\r",
            "            self.nodetype = value[\"nodetype\"] if \"nodetype\" in value else \"\"\r",
            "            self.legacyoid = value[\"legacyoid\"] if \"legacyoid\" in value else \"\"\r",
            "            self.relationshiptype = value[\"relationshiptype\"] if \"relationshiptype\" in value else \"\"\r",
            "            if \"values\" in value:\r",
            "                for val in value[\"values\"]:\r",
            "                    self.addvalue(val)\r",
            "            if \"subconcepts\" in value:\r",
            "                for subconcept in value[\"subconcepts\"]:\r",
            "                    self.addsubconcept(subconcept)\r",
            "            if \"parentconcepts\" in value:\r",
            "                for parentconcept in value[\"parentconcepts\"]:\r",
            "                    self.addparent(parentconcept)\r",
            "            if \"relatedconcepts\" in value:\r",
            "                for relatedconcept in value[\"relatedconcepts\"]:\r",
            "                    self.addrelatedconcept(relatedconcept)\r",
            "\r",
            "        if isinstance(value, models.Concept):\r",
            "            self.id = str(value.pk)\r",
            "            self.nodetype = value.nodetype_id\r",
            "            self.legacyoid = value.legacyoid\r",
            "\r",
            "    def get(\r",
            "        self,\r",
            "        id=\"\",\r",
            "        legacyoid=\"\",\r",
            "        include_subconcepts=False,\r",
            "        include_parentconcepts=False,\r",
            "        include_relatedconcepts=False,\r",
            "        exclude=[],\r",
            "        include=[],\r",
            "        depth_limit=None,\r",
            "        up_depth_limit=None,\r",
            "        lang=settings.LANGUAGE_CODE,\r",
            "        semantic=True,\r",
            "        pathway_filter=None,\r",
            "        **kwargs,\r",
            "    ):\r",
            "\r",
            "        if id != \"\":\r",
            "            self.load(models.Concept.objects.get(pk=id))\r",
            "        elif legacyoid != \"\":\r",
            "            self.load(models.Concept.objects.get(legacyoid=legacyoid))\r",
            "\r",
            "        _cache = kwargs.pop(\"_cache\", {})\r",
            "        _cache[self.id] = self.__class__(\r",
            "            {\"id\": self.id, \"nodetype\": self.nodetype, \"legacyoid\": self.legacyoid, \"relationshiptype\": self.relationshiptype}\r",
            "        )\r",
            "\r",
            "        if semantic == True:\r",
            "            pathway_filter = (\r",
            "                pathway_filter\r",
            "                if pathway_filter\r",
            "                else Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\")\r",
            "            )\r",
            "        else:\r",
            "            pathway_filter = pathway_filter if pathway_filter else Q(relationtype=\"member\") | Q(relationtype=\"hasCollection\")\r",
            "\r",
            "        if self.id != \"\":\r",
            "            nodetype = kwargs.pop(\"nodetype\", self.nodetype)\r",
            "            uplevel = kwargs.pop(\"uplevel\", 0)\r",
            "            downlevel = kwargs.pop(\"downlevel\", 0)\r",
            "            depth_limit = depth_limit if depth_limit is None else int(depth_limit)\r",
            "            up_depth_limit = up_depth_limit if up_depth_limit is None else int(up_depth_limit)\r",
            "\r",
            "            if include is not None:\r",
            "                if len(include) > 0 and len(exclude) > 0:\r",
            "                    raise Exception(_(\"Only include values for include or exclude, but not both\"))\r",
            "                include = (\r",
            "                    include if len(include) != 0 else models.DValueType.objects.distinct(\"category\").values_list(\"category\", flat=True)\r",
            "                )\r",
            "                include = set(include).difference(exclude)\r",
            "                exclude = []\r",
            "\r",
            "                if len(include) > 0:\r",
            "                    values = models.Value.objects.filter(concept=self.id)\r",
            "                    for value in values:\r",
            "                        if value.valuetype.category in include:\r",
            "                            self.values.append(ConceptValue(value))\r",
            "\r",
            "            hassubconcepts = models.Relation.objects.filter(Q(conceptfrom=self.id), pathway_filter, ~Q(relationtype=\"related\"))[0:1]\r",
            "            if len(hassubconcepts) > 0:\r",
            "                self.hassubconcepts = True\r",
            "\r",
            "            if include_subconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(Q(conceptfrom=self.id), pathway_filter, ~Q(relationtype=\"related\"))\r",
            "                if depth_limit is None or downlevel < depth_limit:\r",
            "                    if depth_limit is not None:\r",
            "                        downlevel = downlevel + 1\r",
            "                    for relation in conceptrealations:\r",
            "                        subconcept = (\r",
            "                            _cache[str(relation.conceptto_id)]\r",
            "                            if str(relation.conceptto_id) in _cache\r",
            "                            else self.__class__().get(\r",
            "                                id=relation.conceptto_id,\r",
            "                                include_subconcepts=include_subconcepts,\r",
            "                                include_parentconcepts=include_parentconcepts,\r",
            "                                include_relatedconcepts=include_relatedconcepts,\r",
            "                                exclude=exclude,\r",
            "                                include=include,\r",
            "                                depth_limit=depth_limit,\r",
            "                                up_depth_limit=up_depth_limit,\r",
            "                                downlevel=downlevel,\r",
            "                                uplevel=uplevel,\r",
            "                                nodetype=nodetype,\r",
            "                                semantic=semantic,\r",
            "                                pathway_filter=pathway_filter,\r",
            "                                _cache=_cache.copy(),\r",
            "                                lang=lang,\r",
            "                            )\r",
            "                        )\r",
            "                        subconcept.relationshiptype = relation.relationtype_id\r",
            "                        self.subconcepts.append(subconcept)\r",
            "\r",
            "                    self.subconcepts = sorted(\r",
            "                        self.subconcepts, key=lambda concept: self.natural_keys(concept.get_sortkey(lang)), reverse=False\r",
            "                    )\r",
            "                    # self.subconcepts = sorted(self.subconcepts, key=methodcaller(\r",
            "                    #     'get_sortkey', lang=lang), reverse=False)\r",
            "\r",
            "            if include_parentconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(Q(conceptto=self.id), pathway_filter, ~Q(relationtype=\"related\"))\r",
            "                if up_depth_limit is None or uplevel < up_depth_limit:\r",
            "                    if up_depth_limit is not None:\r",
            "                        uplevel = uplevel + 1\r",
            "                    for relation in conceptrealations:\r",
            "                        parentconcept = (\r",
            "                            _cache[str(relation.conceptfrom_id)]\r",
            "                            if str(relation.conceptfrom_id) in _cache\r",
            "                            else self.__class__().get(\r",
            "                                id=relation.conceptfrom_id,\r",
            "                                include_subconcepts=False,\r",
            "                                include_parentconcepts=include_parentconcepts,\r",
            "                                include_relatedconcepts=include_relatedconcepts,\r",
            "                                exclude=exclude,\r",
            "                                include=include,\r",
            "                                depth_limit=depth_limit,\r",
            "                                up_depth_limit=up_depth_limit,\r",
            "                                downlevel=downlevel,\r",
            "                                uplevel=uplevel,\r",
            "                                nodetype=nodetype,\r",
            "                                semantic=semantic,\r",
            "                                pathway_filter=pathway_filter,\r",
            "                                _cache=_cache.copy(),\r",
            "                                lang=lang,\r",
            "                            )\r",
            "                        )\r",
            "                        parentconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.parentconcepts.append(parentconcept)\r",
            "\r",
            "            if include_relatedconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(relationtype=\"related\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                    Q(conceptto=self.id) | Q(conceptfrom=self.id),\r",
            "                )\r",
            "                relations = []\r",
            "                for relation in conceptrealations:\r",
            "                    if str(relation.conceptto_id) != self.id and str(relation.relationid) not in relations:\r",
            "                        relations.append(str(relation.relationid))\r",
            "                        relatedconcept = self.__class__().get(relation.conceptto_id, include=[\"label\"], lang=lang)\r",
            "                        relatedconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.relatedconcepts.append(relatedconcept)\r",
            "                    if str(relation.conceptfrom_id) != self.id and str(relation.relationid) not in relations:\r",
            "                        relations.append(str(relation.relationid))\r",
            "                        relatedconcept = self.__class__().get(relation.conceptfrom_id, include=[\"label\"], lang=lang)\r",
            "                        relatedconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.relatedconcepts.append(relatedconcept)\r",
            "\r",
            "        return self\r",
            "\r",
            "    def save(self):\r",
            "        self.id = self.id if (self.id != \"\" and self.id is not None) else str(uuid.uuid4())\r",
            "        concept, created = models.Concept.objects.get_or_create(\r",
            "            pk=self.id, defaults={\"legacyoid\": self.legacyoid if self.legacyoid != \"\" else self.id, \"nodetype_id\": self.nodetype}\r",
            "        )\r",
            "\r",
            "        for value in self.values:\r",
            "            if not isinstance(value, ConceptValue):\r",
            "                value = ConceptValue(value)\r",
            "            value.conceptid = self.id\r",
            "            value.save()\r",
            "\r",
            "        for parentconcept in self.parentconcepts:\r",
            "            parentconcept.save()\r",
            "            parentconcept.add_relation(self, parentconcept.relationshiptype)\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.save()\r",
            "            self.add_relation(subconcept, subconcept.relationshiptype)\r",
            "\r",
            "        # if we're moving a Concept Scheme below another Concept or Concept Scheme\r",
            "        if len(self.parentconcepts) > 0 and concept.nodetype_id == \"ConceptScheme\":\r",
            "            concept.nodetype_id = \"Concept\"\r",
            "            concept.save()\r",
            "            self.load(concept)\r",
            "\r",
            "            for relation in models.Relation.objects.filter(conceptfrom=concept, relationtype_id=\"hasTopConcept\"):\r",
            "                relation.relationtype_id = \"narrower\"\r",
            "                relation.save()\r",
            "\r",
            "        for relatedconcept in self.relatedconcepts:\r",
            "            self.add_relation(relatedconcept, relatedconcept.relationshiptype)\r",
            "\r",
            "            if relatedconcept.relationshiptype == \"member\":\r",
            "                child_concepts = relatedconcept.get(include_subconcepts=True)\r",
            "\r",
            "                def applyRelationship(concept):\r",
            "                    for subconcept in concept.subconcepts:\r",
            "                        concept.add_relation(subconcept, relatedconcept.relationshiptype)\r",
            "\r",
            "                child_concepts.traverse(applyRelationship)\r",
            "\r",
            "        return concept\r",
            "\r",
            "    def delete(self, delete_self=False):\r",
            "        \"\"\"\r",
            "        Deletes any subconcepts associated with this concept and additionally this concept if 'delete_self' is True\r",
            "        If any parentconcepts or relatedconcepts are included then it will only delete the relationship to those concepts but not the concepts themselves\r",
            "        If any values are passed, then those values as well as the relationship to those values will be deleted\r",
            "\r",
            "        Note, django will automatically take care of deleting any db models that have a foreign key relationship to the model being deleted\r",
            "        (eg: deleting a concept model will also delete all values and relationships), but because we need to manage deleting\r",
            "        parent concepts and related concepts and values we have to do that here too\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(subconcept)\r",
            "            for key, concept in concepts_to_delete.items():\r",
            "                models.Concept.objects.get(pk=key).delete()\r",
            "\r",
            "        for parentconcept in self.parentconcepts:\r",
            "            relations_filter = (\r",
            "                (Q(relationtype__category=\"Semantic Relations\") | Q(relationtype=\"hasTopConcept\"))\r",
            "                & Q(conceptfrom=parentconcept.id)\r",
            "                & Q(conceptto=self.id)\r",
            "            )\r",
            "            conceptrelations = models.Relation.objects.filter(relations_filter)\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "\r",
            "            if models.Relation.objects.filter(relations_filter).count() == 0:\r",
            "                # we've removed all parent concepts so now this concept needs to be promoted to a Concept Scheme\r",
            "                concept = models.Concept.objects.get(pk=self.id)\r",
            "                concept.nodetype_id = \"ConceptScheme\"\r",
            "                concept.save()\r",
            "                self.load(concept)\r",
            "\r",
            "                for relation in models.Relation.objects.filter(conceptfrom=concept, relationtype_id=\"narrower\"):\r",
            "                    relation.relationtype_id = \"hasTopConcept\"\r",
            "                    relation.save()\r",
            "\r",
            "        deletedrelatedconcepts = []\r",
            "        for relatedconcept in self.relatedconcepts:\r",
            "            conceptrelations = models.Relation.objects.filter(\r",
            "                Q(relationtype=\"related\") | Q(relationtype=\"member\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                conceptto=relatedconcept.id,\r",
            "                conceptfrom=self.id,\r",
            "            )\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "                deletedrelatedconcepts.append(relatedconcept)\r",
            "\r",
            "            conceptrelations = models.Relation.objects.filter(\r",
            "                Q(relationtype=\"related\") | Q(relationtype=\"member\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                conceptfrom=relatedconcept.id,\r",
            "                conceptto=self.id,\r",
            "            )\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "                deletedrelatedconcepts.append(relatedconcept)\r",
            "\r",
            "        for deletedrelatedconcept in deletedrelatedconcepts:\r",
            "            if deletedrelatedconcept in self.relatedconcepts:\r",
            "                self.relatedconcepts.remove(deletedrelatedconcept)\r",
            "\r",
            "        for value in self.values:\r",
            "            if not isinstance(value, ConceptValue):\r",
            "                value = ConceptValue(value)\r",
            "            value.delete()\r",
            "\r",
            "        if delete_self:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(self)\r",
            "            for key, concept in concepts_to_delete.items():\r",
            "                # delete only member relationships if the nodetype == Collection\r",
            "                if concept.nodetype == \"Collection\":\r",
            "                    concept = Concept().get(\r",
            "                        id=concept.id,\r",
            "                        include_subconcepts=True,\r",
            "                        include_parentconcepts=True,\r",
            "                        include=[\"label\"],\r",
            "                        up_depth_limit=1,\r",
            "                        semantic=False,\r",
            "                    )\r",
            "\r",
            "                    def find_concepts(concept):\r",
            "                        if len(concept.parentconcepts) <= 1:\r",
            "                            for subconcept in concept.subconcepts:\r",
            "                                conceptrelation = models.Relation.objects.get(\r",
            "                                    conceptfrom=concept.id, conceptto=subconcept.id, relationtype=\"member\"\r",
            "                                )\r",
            "                                conceptrelation.delete()\r",
            "                                find_concepts(subconcept)\r",
            "\r",
            "                    find_concepts(concept)\r",
            "                    # if the concept is a collection, loop through the nodes and delete their rdmCollection values\r",
            "                    for node in models.Node.objects.filter(config__rdmCollection=concept.id):\r",
            "                        node.config[\"rdmCollection\"] = None\r",
            "                        node.save()\r",
            "\r",
            "                models.Concept.objects.get(pk=key).delete()\r",
            "        return\r",
            "\r",
            "    def add_relation(self, concepttorelate, relationtype):\r",
            "        \"\"\"\r",
            "        Relates this concept to 'concepttorelate' via the relationtype\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        relation, created = models.Relation.objects.get_or_create(\r",
            "            conceptfrom_id=self.id, conceptto_id=concepttorelate.id, relationtype_id=relationtype\r",
            "        )\r",
            "        return relation\r",
            "\r",
            "    @staticmethod\r",
            "    def gather_concepts_to_delete(concept, lang=settings.LANGUAGE_CODE):\r",
            "        \"\"\"\r",
            "        Gets a dictionary of all the concepts ids to delete\r",
            "        The values of the dictionary keys differ somewhat depending on the node type being deleted\r",
            "        If the nodetype == 'Concept' then return ConceptValue objects keyed to the concept id\r",
            "        If the nodetype == 'ConceptScheme' then return a ConceptValue object with the value set to any ONE prefLabel keyed to the concept id\r",
            "        We do this because it takes so long to gather the ids of the concepts when deleting a Scheme or Group\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        concepts_to_delete = {}\r",
            "\r",
            "        # Here we have to worry about making sure we don't delete nodes that have more than 1 parent\r",
            "        if concept.nodetype == \"Concept\":\r",
            "            concept = Concept().get(\r",
            "                id=concept.id, include_subconcepts=True, include_parentconcepts=True, include=[\"label\"], up_depth_limit=1\r",
            "            )\r",
            "\r",
            "            def find_concepts(concept):\r",
            "                if len(concept.parentconcepts) <= 1:\r",
            "                    concepts_to_delete[concept.id] = concept\r",
            "                    for subconcept in concept.subconcepts:\r",
            "                        find_concepts(subconcept)\r",
            "\r",
            "            find_concepts(concept)\r",
            "            return concepts_to_delete\r",
            "\r",
            "        # here we can just delete everything and so use a recursive CTE to get the concept ids much more quickly\r",
            "        if concept.nodetype == \"ConceptScheme\":\r",
            "            concepts_to_delete[concept.id] = concept\r",
            "            rows = Concept().get_child_concepts(concept.id)\r",
            "            for row in rows:\r",
            "                if row[0] not in concepts_to_delete:\r",
            "                    concepts_to_delete[row[0]] = Concept({\"id\": row[0]})\r",
            "\r",
            "                concepts_to_delete[row[0]].addvalue({\"id\": row[2], \"conceptid\": row[0], \"value\": row[1]})\r",
            "\r",
            "        if concept.nodetype == \"Collection\":\r",
            "            concepts_to_delete[concept.id] = concept\r",
            "            rows = Concept().get_child_collections(concept.id)\r",
            "            for row in rows:\r",
            "                if row[0] not in concepts_to_delete:\r",
            "                    concepts_to_delete[row[0]] = Concept({\"id\": row[0]})\r",
            "\r",
            "                concepts_to_delete[row[0]].addvalue({\"id\": row[2], \"conceptid\": row[0], \"value\": row[1]})\r",
            "\r",
            "        return concepts_to_delete\r",
            "\r",
            "    def get_child_collections_hierarchically(self, conceptid, child_valuetypes=None, offset=0, limit=50, query=None):\r",
            "        child_valuetypes = child_valuetypes if child_valuetypes else [\"prefLabel\"]\r",
            "        columns = \"valueidto::text, conceptidto::text, valueto, valuetypeto, depth, count(*) OVER() AS full_count, collector\"\r",
            "        return self.get_child_edges(\r",
            "            conceptid, [\"member\"], child_valuetypes, offset=offset, limit=limit, order_hierarchically=True, query=query, columns=columns\r",
            "        )\r",
            "\r",
            "    def get_child_collections(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", columns=None, depth_limit=\"\"):\r",
            "        child_valuetypes = child_valuetypes if child_valuetypes else [\"prefLabel\"]\r",
            "        columns = columns if columns else \"conceptidto::text, valueto, valueidto::text\"\r",
            "        return self.get_child_edges(conceptid, [\"member\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "\r",
            "    def get_child_concepts(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", columns=None, depth_limit=\"\"):\r",
            "        columns = columns if columns else \"conceptidto::text, valueto, valueidto::text\"\r",
            "        return self.get_child_edges(conceptid, [\"narrower\", \"hasTopConcept\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "\r",
            "    def get_child_concepts_for_indexing(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", depth_limit=\"\"):\r",
            "        columns = \"valueidto::text, conceptidto::text, valuetypeto, categoryto, valueto, languageto\"\r",
            "        data = self.get_child_edges(conceptid, [\"narrower\", \"hasTopConcept\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "        return [dict(list(zip([\"id\", \"conceptid\", \"type\", \"category\", \"value\", \"language\"], d)), top_concept=\"\") for d in data]\r",
            "\r",
            "    def get_child_edges(\r",
            "        self,\r",
            "        conceptid,\r",
            "        relationtypes,\r",
            "        child_valuetypes=None,\r",
            "        parent_valuetype=\"prefLabel\",\r",
            "        columns=None,\r",
            "        depth_limit=None,\r",
            "        offset=None,\r",
            "        limit=20,\r",
            "        order_hierarchically=False,\r",
            "        query=None,\r",
            "        languageid=None,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Recursively builds a list of concept relations for a given concept and all it's subconcepts based on its relationship type and valuetypes.\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        # if the conceptid isn't a UUID then Postgres will throw an error and transactions will be aborted #7822\r",
            "        try:\r",
            "            uuid.UUID(conceptid)\r",
            "        except:\r",
            "            return []\r",
            "\r",
            "        languageid = get_language() if languageid is None else languageid\r",
            "        relationtypes = \" or \".join([\"r.relationtype = '%s'\" % (relationtype) for relationtype in relationtypes])\r",
            "        depth_limit = \"and depth < %s\" % depth_limit if depth_limit else \"\"\r",
            "        child_valuetypes = (\"','\").join(\r",
            "            child_valuetypes if child_valuetypes else models.DValueType.objects.filter(category=\"label\").values_list(\"valuetype\", flat=True)\r",
            "        )\r",
            "        limit_clause = \" limit %s offset %s\" % (limit, offset) if offset is not None else \"\"\r",
            "\r",
            "        if order_hierarchically:\r",
            "            sql = \"\"\"\r",
            "                WITH RECURSIVE\r",
            "\r",
            "                 ordered_relationships AS (\r",
            "                    (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype, (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('prefLabel')\r",
            "                            ORDER BY (\r",
            "                                CASE WHEN languageid = '{languageid}' THEN 10\r",
            "                                WHEN languageid like '{short_languageid}%' THEN 5\r",
            "                                WHEN languageid like '{default_languageid}%' THEN 2\r",
            "                                ELSE 0\r",
            "                                END\r",
            "                            ) desc limit 1\r",
            "                        ) as valuesto,\r",
            "                        (\r",
            "                            SELECT value::int\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('sortorder')\r",
            "                            limit 1\r",
            "                        ) as sortorder,\r",
            "                        (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('collector')\r",
            "                            limit 1\r",
            "                        ) as collector\r",
            "                        FROM relations r\r",
            "                        WHERE r.conceptidfrom = '{conceptid}'\r",
            "                        and ({relationtypes})\r",
            "                        ORDER BY sortorder, valuesto\r",
            "                    )\r",
            "                    UNION\r",
            "                    (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype,(\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('prefLabel')\r",
            "                            ORDER BY (\r",
            "                                CASE WHEN languageid = '{languageid}' THEN 10\r",
            "                                WHEN languageid like '{short_languageid}%' THEN 5\r",
            "                                WHEN languageid like '{default_languageid}%' THEN 2\r",
            "                                ELSE 0\r",
            "                                END\r",
            "                            ) desc limit 1\r",
            "                        ) as valuesto,\r",
            "                        (\r",
            "                            SELECT value::int\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('sortorder')\r",
            "                            limit 1\r",
            "                        ) as sortorder,\r",
            "                        (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('collector')\r",
            "                            limit 1\r",
            "                        ) as collector\r",
            "                        FROM relations r\r",
            "                        JOIN ordered_relationships b ON(b.conceptidto = r.conceptidfrom)\r",
            "                        WHERE ({relationtypes})\r",
            "                        ORDER BY sortorder, valuesto\r",
            "                    )\r",
            "                ),\r",
            "\r",
            "                children AS (\r",
            "                    SELECT r.conceptidfrom, r.conceptidto,\r",
            "                        to_char(row_number() OVER (), 'fm000000') as row,\r",
            "                        r.collector,\r",
            "                        1 AS depth       ---|NonRecursive Part\r",
            "                        FROM ordered_relationships r\r",
            "                        WHERE r.conceptidfrom = '{conceptid}'\r",
            "                        and ({relationtypes})\r",
            "                    UNION\r",
            "                        SELECT r.conceptidfrom, r.conceptidto,\r",
            "                        row || '-' || to_char(row_number() OVER (), 'fm000000'),\r",
            "                        r.collector,\r",
            "                        depth+1      ---|RecursivePart\r",
            "                        FROM ordered_relationships r\r",
            "                        JOIN children b ON(b.conceptidto = r.conceptidfrom)\r",
            "                        WHERE ({relationtypes})\r",
            "                        {depth_limit}\r",
            "                )\r",
            "\r",
            "                {subquery}\r",
            "\r",
            "                SELECT\r",
            "                (\r",
            "                    select row_to_json(d)\r",
            "                    FROM (\r",
            "                        SELECT *\r",
            "                        FROM values\r",
            "                        WHERE conceptid={recursive_table}.conceptidto\r",
            "                        AND valuetype in ('prefLabel')\r",
            "                        ORDER BY (\r",
            "                            CASE WHEN languageid = '{languageid}' THEN 10\r",
            "                            WHEN languageid like '{short_languageid}%' THEN 5\r",
            "                            WHEN languageid like '{default_languageid}%' THEN 2\r",
            "                            ELSE 0\r",
            "                            END\r",
            "                        ) desc limit 1\r",
            "                    ) d\r",
            "                ) as valueto,\r",
            "                depth, collector, count(*) OVER() AS full_count\r",
            "\r",
            "               FROM {recursive_table} order by row {limit_clause};\r",
            "\r",
            "            \"\"\"\r",
            "\r",
            "            subquery = (\r",
            "                \"\"\", results as (\r",
            "                SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r",
            "                FROM children c\r",
            "                JOIN values ON(values.conceptid = c.conceptidto)\r",
            "                WHERE LOWER(values.value) like '%%%s%%'\r",
            "                AND values.valuetype in ('prefLabel')\r",
            "                    UNION\r",
            "                SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r",
            "                FROM children c\r",
            "                JOIN results r on (r.conceptidfrom=c.conceptidto)\r",
            "            )\"\"\"\r",
            "                % query.lower()\r",
            "                if query is not None\r",
            "                else \"\"\r",
            "            )\r",
            "\r",
            "            recursive_table = \"results\" if query else \"children\"\r",
            "\r",
            "            sql = sql.format(\r",
            "                conceptid=conceptid,\r",
            "                relationtypes=relationtypes,\r",
            "                child_valuetypes=child_valuetypes,\r",
            "                parent_valuetype=parent_valuetype,\r",
            "                depth_limit=depth_limit,\r",
            "                limit_clause=limit_clause,\r",
            "                subquery=subquery,\r",
            "                recursive_table=recursive_table,\r",
            "                languageid=languageid,\r",
            "                short_languageid=languageid.split(\"-\")[0],\r",
            "                default_languageid=settings.LANGUAGE_CODE,\r",
            "            )\r",
            "\r",
            "        else:\r",
            "            sql = \"\"\"\r",
            "                WITH RECURSIVE\r",
            "                    children AS (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype, 1 AS depth\r",
            "                            FROM relations r\r",
            "                            WHERE r.conceptidfrom = '{conceptid}'\r",
            "                            AND ({relationtypes})\r",
            "                        UNION\r",
            "                            SELECT r.conceptidfrom, r.conceptidto, r.relationtype, depth+1\r",
            "                            FROM relations r\r",
            "                            JOIN children c ON(c.conceptidto = r.conceptidfrom)\r",
            "                            WHERE ({relationtypes})\r",
            "                            {depth_limit}\r",
            "                    ),\r",
            "                    results AS (\r",
            "                        SELECT\r",
            "                            valuefrom.value as valuefrom, valueto.value as valueto,\r",
            "                            valuefrom.valueid as valueidfrom, valueto.valueid as valueidto,\r",
            "                            valuefrom.valuetype as valuetypefrom, valueto.valuetype as valuetypeto,\r",
            "                            valuefrom.languageid as languagefrom, valueto.languageid as languageto,\r",
            "                            dtypesfrom.category as categoryfrom, dtypesto.category as categoryto,\r",
            "                            c.conceptidfrom, c.conceptidto\r",
            "                        FROM values valueto\r",
            "                            JOIN d_value_types dtypesto ON(dtypesto.valuetype = valueto.valuetype)\r",
            "                            JOIN children c ON(c.conceptidto = valueto.conceptid)\r",
            "                            JOIN values valuefrom ON(c.conceptidfrom = valuefrom.conceptid)\r",
            "                            JOIN d_value_types dtypesfrom ON(dtypesfrom.valuetype = valuefrom.valuetype)\r",
            "                        WHERE valueto.valuetype in ('{child_valuetypes}')\r",
            "                        AND valuefrom.valuetype in ('{child_valuetypes}')\r",
            "                    )\r",
            "                    SELECT distinct {columns}\r",
            "                    FROM results {limit_clause}\r",
            "\r",
            "            \"\"\"\r",
            "\r",
            "            if not columns:\r",
            "                columns = \"\"\"\r",
            "                    conceptidfrom::text, conceptidto::text,\r",
            "                    valuefrom, valueto,\r",
            "                    valueidfrom::text, valueidto::text,\r",
            "                    valuetypefrom, valuetypeto,\r",
            "                    languagefrom, languageto,\r",
            "                    categoryfrom, categoryto\r",
            "                \"\"\"\r",
            "\r",
            "            sql = sql.format(\r",
            "                conceptid=conceptid,\r",
            "                relationtypes=relationtypes,\r",
            "                child_valuetypes=child_valuetypes,\r",
            "                columns=columns,\r",
            "                depth_limit=depth_limit,\r",
            "                limit_clause=limit_clause,\r",
            "            )\r",
            "\r",
            "        cursor = connection.cursor()\r",
            "        cursor.execute(sql)\r",
            "        rows = cursor.fetchall()\r",
            "        return rows\r",
            "\r",
            "    def traverse(self, func, direction=\"down\", scope=None, **kwargs):\r",
            "        \"\"\"\r",
            "        Traverses a concept graph from self to leaf (direction='down') or root (direction='up') calling\r",
            "        the given function on each node, passes an optional scope to each function\r",
            "\r",
            "        Return a value from the function to prematurely end the traversal\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        _cache = kwargs.pop(\"_cache\", [])\r",
            "        if self.id not in _cache:\r",
            "            _cache.append(self.id)\r",
            "\r",
            "            if scope is None:\r",
            "                ret = func(self, **kwargs)\r",
            "            else:\r",
            "                ret = func(self, scope, **kwargs)\r",
            "\r",
            "            # break out of the traversal if the function returns a value\r",
            "            if ret is not None:\r",
            "                return ret\r",
            "\r",
            "            if direction == \"down\":\r",
            "                for subconcept in self.subconcepts:\r",
            "                    ret = subconcept.traverse(func, direction, scope, _cache=_cache, **kwargs)\r",
            "                    if ret is not None:\r",
            "                        return ret\r",
            "            else:\r",
            "                for parentconcept in self.parentconcepts:\r",
            "                    ret = parentconcept.traverse(func, direction, scope, _cache=_cache, **kwargs)\r",
            "                    if ret is not None:\r",
            "                        return ret\r",
            "\r",
            "    def get_sortkey(self, lang=settings.LANGUAGE_CODE):\r",
            "        for value in self.values:\r",
            "            if value.type == \"sortorder\":\r",
            "                try:\r",
            "                    return float(value.value)\r",
            "                except:\r",
            "                    return None\r",
            "\r",
            "        return self.get_preflabel(lang=lang).value\r",
            "\r",
            "    def natural_keys(self, text):\r",
            "        \"\"\"\r",
            "        alist.sort(key=natural_keys) sorts in human order\r",
            "        http://nedbatchelder.com/blog/200712/human_sorting.html\r",
            "        (See Toothy's implementation in the comments)\r",
            "        float regex comes from https://stackoverflow.com/a/12643073/190597\r",
            "        \"\"\"\r",
            "\r",
            "        def atof(text):\r",
            "            try:\r",
            "                retval = float(text)\r",
            "            except ValueError:\r",
            "                retval = text\r",
            "            return retval\r",
            "\r",
            "        return [atof(c) for c in re.split(r\"[+-]?([0-9]+(?:[.][0-9]*)?|[.][0-9]+)\", str(text))]\r",
            "\r",
            "    def get_preflabel(self, lang=settings.LANGUAGE_CODE):\r",
            "        score = 0\r",
            "        ranked_labels = []\r",
            "        if self.values == []:\r",
            "            concept = Concept().get(id=self.id, include_subconcepts=False, include_parentconcepts=False, include=[\"label\"])\r",
            "        else:\r",
            "            concept = self\r",
            "\r",
            "        for value in concept.values:\r",
            "            ranked_label = {\"weight\": 1, \"value\": value}\r",
            "            if value.type == \"prefLabel\":\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 10\r",
            "            elif value.type == \"altLabel\":\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 4\r",
            "\r",
            "            if value.language == lang:\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 10\r",
            "            elif value.language.split(\"-\")[0] == lang.split(\"-\")[0]:\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 5\r",
            "\r",
            "            ranked_labels.append(ranked_label)\r",
            "\r",
            "        ranked_labels = sorted(ranked_labels, key=lambda label: label[\"weight\"], reverse=True)\r",
            "        if len(ranked_labels) == 0:\r",
            "            ranked_labels.append({\"weight\": 1, \"value\": ConceptValue()})\r",
            "\r",
            "        return ranked_labels[0][\"value\"]\r",
            "\r",
            "    def flatten(self, ret=None):\r",
            "        \"\"\"\r",
            "        Flattens the graph into a unordered list of concepts\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        if ret is None:\r",
            "            ret = []\r",
            "\r",
            "        ret.append(self)\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.flatten(ret)\r",
            "\r",
            "        return ret\r",
            "\r",
            "    def addparent(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.parentconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.parentconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(\"Invalid parent concept definition: %s\" % (value))\r",
            "\r",
            "    def addsubconcept(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.subconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.subconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid subconcept definition: %s\") % (value))\r",
            "\r",
            "    def addrelatedconcept(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.relatedconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.relatedconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid related concept definition: %s\") % (value))\r",
            "\r",
            "    def addvalue(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            value[\"conceptid\"] = self.id\r",
            "            self.values.append(ConceptValue(value))\r",
            "        elif isinstance(value, ConceptValue):\r",
            "            self.values.append(value)\r",
            "        elif isinstance(value, models.Value):\r",
            "            self.values.append(ConceptValue(value))\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid value definition: %s\") % (value))\r",
            "\r",
            "    def index(self, scheme=None):\r",
            "        if scheme is None:\r",
            "            scheme = self.get_context()\r",
            "        for value in self.values:\r",
            "            value.index(scheme=scheme)\r",
            "\r",
            "        if self.nodetype == \"ConceptScheme\":\r",
            "            scheme = None\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.index(scheme=scheme)\r",
            "\r",
            "    def bulk_index(self):\r",
            "        concept_docs = []\r",
            "\r",
            "        if self.nodetype == \"ConceptScheme\":\r",
            "            concept = Concept().get(id=self.id, values=[\"label\"])\r",
            "            concept.index()\r",
            "            for topConcept in self.get_child_concepts_for_indexing(self.id, depth_limit=1):\r",
            "                concept = Concept().get(id=topConcept[\"conceptid\"])\r",
            "                scheme = concept.get_context()\r",
            "                topConcept[\"top_concept\"] = scheme.id\r",
            "                concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=topConcept[\"id\"], data=topConcept))\r",
            "                for childConcept in concept.get_child_concepts_for_indexing(topConcept[\"conceptid\"]):\r",
            "                    childConcept[\"top_concept\"] = scheme.id\r",
            "                    concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=childConcept[\"id\"], data=childConcept))\r",
            "\r",
            "        if self.nodetype == \"Concept\":\r",
            "            concept = Concept().get(id=self.id, values=[\"label\"])\r",
            "            scheme = concept.get_context()\r",
            "            concept.index(scheme)\r",
            "            for childConcept in concept.get_child_concepts_for_indexing(self.id):\r",
            "                childConcept[\"top_concept\"] = scheme.id\r",
            "                concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=childConcept[\"id\"], data=childConcept))\r",
            "\r",
            "        se.bulk_index(concept_docs)\r",
            "\r",
            "    def delete_index(self, delete_self=False):\r",
            "        def delete_concept_values_index(concepts_to_delete):\r",
            "            for concept in concepts_to_delete.values():\r",
            "                query = Query(se, start=0, limit=10000)\r",
            "                term = Term(field=\"conceptid\", term=concept.id)\r",
            "                query.add_query(term)\r",
            "                query.delete(index=CONCEPTS_INDEX)\r",
            "\r",
            "        if delete_self:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(self)\r",
            "            delete_concept_values_index(concepts_to_delete)\r",
            "        else:\r",
            "            for subconcept in self.subconcepts:\r",
            "                concepts_to_delete = Concept.gather_concepts_to_delete(subconcept)\r",
            "                delete_concept_values_index(concepts_to_delete)\r",
            "\r",
            "    def concept_tree(\r",
            "        self, top_concept=\"00000000-0000-0000-0000-000000000001\", lang=settings.LANGUAGE_CODE, mode=\"semantic\",\r",
            "    ):\r",
            "        class concept(object):\r",
            "            def __init__(self, *args, **kwargs):\r",
            "                self.label = \"\"\r",
            "                self.labelid = \"\"\r",
            "                self.id = \"\"\r",
            "                self.sortorder = None\r",
            "                self.load_on_demand = False\r",
            "                self.children = []\r",
            "\r",
            "        def _findNarrowerConcept(conceptid, depth_limit=None, level=0):\r",
            "            labels = models.Value.objects.filter(concept=conceptid)\r",
            "            ret = concept()\r",
            "            temp = Concept()\r",
            "            for label in labels:\r",
            "                temp.addvalue(label)\r",
            "                if label.valuetype_id == \"sortorder\":\r",
            "                    try:\r",
            "                        ret.sortorder = float(label.value)\r",
            "                    except:\r",
            "                        ret.sortorder = None\r",
            "\r",
            "            label = temp.get_preflabel(lang=lang)\r",
            "            ret.label = label.value\r",
            "            ret.id = label.conceptid\r",
            "            ret.labelid = label.id\r",
            "\r",
            "            if mode == \"semantic\":\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(conceptfrom=conceptid), Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\")\r",
            "                )\r",
            "            if mode == \"collections\":\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(conceptfrom=conceptid), Q(relationtype=\"member\") | Q(relationtype=\"hasCollection\")\r",
            "                )\r",
            "            if depth_limit is not None and len(conceptrealations) > 0 and level >= depth_limit:\r",
            "                ret.load_on_demand = True\r",
            "            else:\r",
            "                if depth_limit is not None:\r",
            "                    level = level + 1\r",
            "                for relation in conceptrealations:\r",
            "                    ret.children.append(_findNarrowerConcept(relation.conceptto_id, depth_limit=depth_limit, level=level))\r",
            "\r",
            "                ret.children = sorted(\r",
            "                    ret.children,\r",
            "                    key=lambda concept: self.natural_keys(concept.sortorder if concept.sortorder else concept.label),\r",
            "                    reverse=False,\r",
            "                )\r",
            "            return ret\r",
            "\r",
            "        def _findBroaderConcept(conceptid, child_concept, depth_limit=None, level=0):\r",
            "            conceptrealations = models.Relation.objects.filter(\r",
            "                Q(conceptto=conceptid), ~Q(relationtype=\"related\"), ~Q(relationtype__category=\"Mapping Properties\")\r",
            "            )\r",
            "            if len(conceptrealations) > 0 and conceptid != top_concept:\r",
            "                labels = models.Value.objects.filter(concept=conceptrealations[0].conceptfrom_id)\r",
            "                ret = concept()\r",
            "                temp = Concept()\r",
            "                for label in labels:\r",
            "                    temp.addvalue(label)\r",
            "                label = temp.get_preflabel(lang=lang)\r",
            "                ret.label = label.value\r",
            "                ret.id = label.conceptid\r",
            "                ret.labelid = label.id\r",
            "\r",
            "                ret.children.append(child_concept)\r",
            "                return _findBroaderConcept(conceptrealations[0].conceptfrom_id, ret, depth_limit=depth_limit, level=level)\r",
            "            else:\r",
            "                return child_concept\r",
            "\r",
            "        graph = []\r",
            "        if self.id is None or self.id == \"\" or self.id == \"None\" or self.id == top_concept:\r",
            "            if mode == \"semantic\":\r",
            "                concepts = models.Concept.objects.filter(nodetype=\"ConceptScheme\")\r",
            "                for conceptmodel in concepts:\r",
            "                    graph.append(_findNarrowerConcept(conceptmodel.pk, depth_limit=1))\r",
            "            if mode == \"collections\":\r",
            "                concepts = models.Concept.objects.filter(nodetype=\"Collection\")\r",
            "                for conceptmodel in concepts:\r",
            "                    graph.append(_findNarrowerConcept(conceptmodel.pk, depth_limit=0))\r",
            "\r",
            "                graph = sorted(graph, key=lambda concept: concept.label)\r",
            "                # graph = _findNarrowerConcept(concepts[0].pk, depth_limit=1).children\r",
            "\r",
            "        else:\r",
            "            graph = _findNarrowerConcept(self.id, depth_limit=1).children\r",
            "            # concepts = _findNarrowerConcept(self.id, depth_limit=1)\r",
            "            # graph = [_findBroaderConcept(self.id, concepts, depth_limit=1)]\r",
            "\r",
            "        return graph\r",
            "\r",
            "    def get_paths(self, lang=settings.LANGUAGE_CODE):\r",
            "        def graph_to_paths(current_concept, path=[], path_list=[], _cache=[]):\r",
            "            if len(path) == 0:\r",
            "                current_path = []\r",
            "            else:\r",
            "                current_path = path[:]\r",
            "\r",
            "            current_path.insert(\r",
            "                0,\r",
            "                {\r",
            "                    \"label\": current_concept.get_preflabel(lang=lang).value,\r",
            "                    \"relationshiptype\": current_concept.relationshiptype,\r",
            "                    \"id\": current_concept.id,\r",
            "                },\r",
            "            )\r",
            "\r",
            "            if len(current_concept.parentconcepts) == 0 or current_concept.id in _cache:\r",
            "                path_list.append(current_path[:])\r",
            "            else:\r",
            "                _cache.append(current_concept.id)\r",
            "                for parent in current_concept.parentconcepts:\r",
            "                    ret = graph_to_paths(parent, current_path, path_list, _cache)\r",
            "\r",
            "            return path_list\r",
            "\r",
            "        # def graph_to_paths(current_concept, **kwargs):\r",
            "        #     path = kwargs.get('path', [])\r",
            "        #     path_list = kwargs.get('path_list', [])\r",
            "\r",
            "        #     if len(path) == 0:\r",
            "        #         current_path = []\r",
            "        #     else:\r",
            "        #         current_path = path[:]\r",
            "\r",
            "        #     current_path.insert(0, {'label': current_concept.get_preflabel(lang=lang).value, 'relationshiptype': current_concept.relationshiptype, 'id': current_concept.id})\r",
            "\r",
            "        #     if len(current_concept.parentconcepts) == 0:\r",
            "        #         path_list.append(current_path[:])\r",
            "        #     # else:\r",
            "        #     #     for parent in current_concept.parentconcepts:\r",
            "        #     #         ret = graph_to_paths(parent, current_path, path_list, _cache)\r",
            "\r",
            "        #     #return path_list\r",
            "\r",
            "        # self.traverse(graph_to_paths, direction='up')\r",
            "\r",
            "        return graph_to_paths(self)\r",
            "\r",
            "    def get_node_and_links(self, lang=settings.LANGUAGE_CODE):\r",
            "        nodes = [{\"concept_id\": self.id, \"name\": self.get_preflabel(lang=lang).value, \"type\": \"Current\"}]\r",
            "        links = []\r",
            "\r",
            "        def get_parent_nodes_and_links(current_concept, _cache=[]):\r",
            "            if current_concept.id not in _cache:\r",
            "                _cache.append(current_concept.id)\r",
            "                parents = current_concept.parentconcepts\r",
            "                for parent in parents:\r",
            "                    nodes.append(\r",
            "                        {\r",
            "                            \"concept_id\": parent.id,\r",
            "                            \"name\": parent.get_preflabel(lang=lang).value,\r",
            "                            \"type\": \"Root\" if len(parent.parentconcepts) == 0 else \"Ancestor\",\r",
            "                        }\r",
            "                    )\r",
            "                    links.append(\r",
            "                        {\"target\": current_concept.id, \"source\": parent.id, \"relationship\": \"broader\", }\r",
            "                    )\r",
            "                    get_parent_nodes_and_links(parent, _cache)\r",
            "\r",
            "        get_parent_nodes_and_links(self)\r",
            "\r",
            "        # def get_parent_nodes_and_links(current_concept):\r",
            "        #     parents = current_concept.parentconcepts\r",
            "        #     for parent in parents:\r",
            "        #         nodes.append({'concept_id': parent.id, 'name': parent.get_preflabel(lang=lang).value, 'type': 'Root' if len(parent.parentconcepts) == 0 else 'Ancestor'})\r",
            "        #         links.append({'target': current_concept.id, 'source': parent.id, 'relationship': 'broader' })\r",
            "\r",
            "        # self.traverse(get_parent_nodes_and_links, direction='up')\r",
            "\r",
            "        for child in self.subconcepts:\r",
            "            nodes.append(\r",
            "                {\"concept_id\": child.id, \"name\": child.get_preflabel(lang=lang).value, \"type\": \"Descendant\", }\r",
            "            )\r",
            "            links.append({\"source\": self.id, \"target\": child.id, \"relationship\": \"narrower\"})\r",
            "\r",
            "        for related in self.relatedconcepts:\r",
            "            nodes.append(\r",
            "                {\"concept_id\": related.id, \"name\": related.get_preflabel(lang=lang).value, \"type\": \"Related\", }\r",
            "            )\r",
            "            links.append({\"source\": self.id, \"target\": related.id, \"relationship\": \"related\"})\r",
            "\r",
            "        # get unique node list and assign unique integer ids for each node (required by d3)\r",
            "        nodes = list({node[\"concept_id\"]: node for node in nodes}.values())\r",
            "        for i in range(len(nodes)):\r",
            "            nodes[i][\"id\"] = i\r",
            "            for link in links:\r",
            "                link[\"source\"] = i if link[\"source\"] == nodes[i][\"concept_id\"] else link[\"source\"]\r",
            "                link[\"target\"] = i if link[\"target\"] == nodes[i][\"concept_id\"] else link[\"target\"]\r",
            "\r",
            "        return {\"nodes\": nodes, \"links\": links}\r",
            "\r",
            "    def get_context(self):\r",
            "        \"\"\"\r",
            "        get the Top Concept that the Concept particpates in\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        if self.nodetype == \"Concept\" or self.nodetype == \"Collection\":\r",
            "            concept = Concept().get(id=self.id, include_parentconcepts=True, include=None)\r",
            "\r",
            "            def get_scheme_id(concept):\r",
            "                for parentconcept in concept.parentconcepts:\r",
            "                    if parentconcept.relationshiptype == \"hasTopConcept\":\r",
            "                        return concept\r",
            "\r",
            "            if len(concept.parentconcepts) > 0:\r",
            "                return concept.traverse(get_scheme_id, direction=\"up\")\r",
            "            else:\r",
            "                return self\r",
            "\r",
            "        else:  # like ConceptScheme or EntityType\r",
            "            return self\r",
            "\r",
            "    def get_scheme(self):\r",
            "        \"\"\"\r",
            "        get the ConceptScheme that the Concept particpates in\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        topConcept = self.get_context()\r",
            "        if len(topConcept.parentconcepts) == 1:\r",
            "            if topConcept.parentconcepts[0].nodetype == \"ConceptScheme\":\r",
            "                return topConcept.parentconcepts[0]\r",
            "\r",
            "        return None\r",
            "\r",
            "    def check_if_concept_in_use(self):\r",
            "        \"\"\"Checks  if a concept or any of its subconcepts is in use by a resource instance\"\"\"\r",
            "\r",
            "        in_use = False\r",
            "        cursor = connection.cursor()\r",
            "        for value in self.values:\r",
            "            sql = (\r",
            "                \"\"\"\r",
            "                SELECT count(*) from tiles t, jsonb_each_text(t.tiledata) as json_data\r",
            "                WHERE json_data.value = '%s'\r",
            "            \"\"\"\r",
            "                % value.id\r",
            "            )\r",
            "            cursor.execute(sql)\r",
            "            rows = cursor.fetchall()\r",
            "            if rows[0][0] > 0:\r",
            "                in_use = True\r",
            "                break\r",
            "        if in_use is not True:\r",
            "            for subconcept in self.subconcepts:\r",
            "                in_use = subconcept.check_if_concept_in_use()\r",
            "                if in_use == True:\r",
            "                    return in_use\r",
            "        return in_use\r",
            "\r",
            "    def get_e55_domain(self, conceptid):\r",
            "        \"\"\"\r",
            "        For a given entitytypeid creates a dictionary representing that entitytypeid's concept graph (member pathway) formatted to support\r",
            "        select2 dropdowns\r",
            "\r",
            "        \"\"\"\r",
            "        cursor = connection.cursor()\r",
            "\r",
            "        sql = \"\"\"\r",
            "        WITH RECURSIVE children AS (\r",
            "            SELECT d.conceptidfrom, d.conceptidto, c2.value, c2.valueid as valueid, c.value as valueto, c.valueid as valueidto, c.valuetype as vtype, 1 AS depth, array[d.conceptidto] AS conceptpath, array[c.valueid] AS idpath        ---|NonRecursive Part\r",
            "                FROM relations d\r",
            "                JOIN values c ON(c.conceptid = d.conceptidto)\r",
            "                JOIN values c2 ON(c2.conceptid = d.conceptidfrom)\r",
            "                WHERE d.conceptidfrom = '{0}'\r",
            "                and c2.valuetype = 'prefLabel'\r",
            "                and c.valuetype in ('prefLabel', 'sortorder', 'collector')\r",
            "                and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r",
            "                UNION\r",
            "                SELECT d.conceptidfrom, d.conceptidto, v2.value, v2.valueid as valueid, v.value as valueto, v.valueid as valueidto, v.valuetype as vtype, depth+1, (conceptpath || d.conceptidto), (idpath || v.valueid)   ---|RecursivePart\r",
            "                FROM relations  d\r",
            "                JOIN children b ON(b.conceptidto = d.conceptidfrom)\r",
            "                JOIN values v ON(v.conceptid = d.conceptidto)\r",
            "                JOIN values v2 ON(v2.conceptid = d.conceptidfrom)\r",
            "                WHERE  v2.valuetype = 'prefLabel'\r",
            "                and v.valuetype in ('prefLabel','sortorder', 'collector')\r",
            "                and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r",
            "            ) SELECT conceptidfrom::text, conceptidto::text, value, valueid::text, valueto, valueidto::text, depth, idpath::text, conceptpath::text, vtype FROM children ORDER BY depth, conceptpath;\r",
            "        \"\"\".format(\r",
            "            conceptid\r",
            "        )\r",
            "\r",
            "        column_names = [\r",
            "            \"conceptidfrom\",\r",
            "            \"conceptidto\",\r",
            "            \"value\",\r",
            "            \"valueid\",\r",
            "            \"valueto\",\r",
            "            \"valueidto\",\r",
            "            \"depth\",\r",
            "            \"idpath\",\r",
            "            \"conceptpath\",\r",
            "            \"vtype\",\r",
            "        ]\r",
            "        cursor.execute(sql)\r",
            "        rows = cursor.fetchall()\r",
            "\r",
            "        class Val(object):\r",
            "            def __init__(self, conceptid):\r",
            "                self.text = \"\"\r",
            "                self.conceptid = conceptid\r",
            "                self.id = \"\"\r",
            "                self.sortorder = \"\"\r",
            "                self.collector = \"\"\r",
            "                self.children = []\r",
            "\r",
            "        result = Val(conceptid)\r",
            "\r",
            "        def _findNarrower(val, path, rec):\r",
            "            for conceptid in path:\r",
            "                childids = [child.conceptid for child in val.children]\r",
            "                if conceptid not in childids:\r",
            "                    new_val = Val(rec[\"conceptidto\"])\r",
            "                    if rec[\"vtype\"] == \"sortorder\":\r",
            "                        new_val.sortorder = rec[\"valueto\"]\r",
            "                    elif rec[\"vtype\"] == \"prefLabel\":\r",
            "                        new_val.text = rec[\"valueto\"]\r",
            "                        new_val.id = rec[\"valueidto\"]\r",
            "                    elif rec[\"vtype\"] == \"collector\":\r",
            "                        new_val.collector = \"collector\"\r",
            "                    val.children.append(new_val)\r",
            "                else:\r",
            "                    for child in val.children:\r",
            "                        if conceptid == child.conceptid:\r",
            "                            if conceptid == path[-1]:\r",
            "                                if rec[\"vtype\"] == \"sortorder\":\r",
            "                                    child.sortorder = rec[\"valueto\"]\r",
            "                                elif rec[\"vtype\"] == \"prefLabel\":\r",
            "                                    child.text = rec[\"valueto\"]\r",
            "                                    child.id = rec[\"valueidto\"]\r",
            "                                elif rec[\"vtype\"] == \"collector\":\r",
            "                                    child.collector = \"collector\"\r",
            "                            path.pop(0)\r",
            "                            _findNarrower(child, path, rec)\r",
            "                val.children.sort(key=lambda x: (x.sortorder, x.text))\r",
            "\r",
            "        for row in rows:\r",
            "            rec = dict(list(zip(column_names, row)))\r",
            "            path = rec[\"conceptpath\"][1:-1].split(\",\")\r",
            "            _findNarrower(result, path, rec)\r",
            "\r",
            "        return JSONSerializer().serializeToPython(result)[\"children\"]\r",
            "\r",
            "    def make_collection(self):\r",
            "        if len(self.values) == 0:\r",
            "            raise Exception(_(\"Need to include values when creating a collection\"))\r",
            "        values = JSONSerializer().serializeToPython(self.values)\r",
            "        for value in values:\r",
            "            value[\"id\"] = \"\"\r",
            "        collection_concept = Concept({\"nodetype\": \"Collection\", \"values\": values})\r",
            "\r",
            "        def create_collection(conceptfrom):\r",
            "            for relation in models.Relation.objects.filter(\r",
            "                Q(conceptfrom_id=conceptfrom.id),\r",
            "                Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\"),\r",
            "                ~Q(relationtype=\"related\"),\r",
            "            ):\r",
            "                conceptto = Concept(relation.conceptto)\r",
            "                if conceptfrom == self:\r",
            "                    collection_concept.add_relation(conceptto, \"member\")\r",
            "                else:\r",
            "                    conceptfrom.add_relation(conceptto, \"member\")\r",
            "                create_collection(conceptto)\r",
            "\r",
            "        with transaction.atomic():\r",
            "            collection_concept.save()\r",
            "            create_collection(self)\r",
            "\r",
            "        return collection_concept\r",
            "\r",
            "\r",
            "class ConceptValue(object):\r",
            "    def __init__(self, *args, **kwargs):\r",
            "        self.id = \"\"\r",
            "        self.conceptid = \"\"\r",
            "        self.type = \"\"\r",
            "        self.category = \"\"\r",
            "        self.value = \"\"\r",
            "        self.language = \"\"\r",
            "\r",
            "        if len(args) != 0:\r",
            "            if isinstance(args[0], str):\r",
            "                try:\r",
            "                    uuid.UUID(args[0])\r",
            "                    self.get(args[0])\r",
            "                except (ValueError):\r",
            "                    self.load(JSONDeserializer().deserialize(args[0]))\r",
            "            elif isinstance(args[0], object):\r",
            "                self.load(args[0])\r",
            "\r",
            "    def __repr__(self):\r",
            "        return ('%s: %s = \"%s\" in lang %s') % (self.__class__, self.type, self.value, self.language)\r",
            "\r",
            "    def get(self, id=\"\"):\r",
            "        self.load(models.Value.objects.get(pk=id))\r",
            "        return self\r",
            "\r",
            "    def save(self):\r",
            "        if self.value.strip() != \"\":\r",
            "            self.id = self.id if (self.id != \"\" and self.id is not None) else str(uuid.uuid4())\r",
            "            value = models.Value()\r",
            "            value.pk = self.id\r",
            "            value.value = self.value\r",
            "            value.concept_id = self.conceptid  # models.Concept.objects.get(pk=self.conceptid)\r",
            "            value.valuetype_id = self.type  # models.DValueType.objects.get(pk=self.type)\r",
            "\r",
            "            if self.language != \"\":\r",
            "                # need to normalize language ids to the form xx-XX\r",
            "                lang_parts = self.language.lower().replace(\"_\", \"-\").split(\"-\")\r",
            "                try:\r",
            "                    lang_parts[1] = lang_parts[1].upper()\r",
            "                except:\r",
            "                    pass\r",
            "                self.language = \"-\".join(lang_parts)\r",
            "                value.language_id = self.language  # models.DLanguage.objects.get(pk=self.language)\r",
            "            else:\r",
            "                value.language_id = settings.LANGUAGE_CODE\r",
            "\r",
            "            value.save()\r",
            "            self.category = value.valuetype.category\r",
            "\r",
            "    def delete(self):\r",
            "        if self.id != \"\":\r",
            "            newvalue = models.Value.objects.get(pk=self.id)\r",
            "            if newvalue.valuetype.valuetype == \"image\":\r",
            "                newvalue = models.FileValue.objects.get(pk=self.id)\r",
            "            newvalue.delete()\r",
            "            self = ConceptValue()\r",
            "            return self\r",
            "\r",
            "    def load(self, value):\r",
            "        if isinstance(value, models.Value):\r",
            "            self.id = str(value.pk)\r",
            "            self.conceptid = str(value.concept_id)\r",
            "            self.type = value.valuetype_id\r",
            "            self.category = value.valuetype.category\r",
            "            self.value = value.value\r",
            "            self.language = value.language_id\r",
            "\r",
            "        if isinstance(value, dict):\r",
            "            self.id = str(value[\"id\"]) if \"id\" in value else \"\"\r",
            "            self.conceptid = str(value[\"conceptid\"]) if \"conceptid\" in value else \"\"\r",
            "            self.type = value[\"type\"] if \"type\" in value else \"\"\r",
            "            self.category = value[\"category\"] if \"category\" in value else \"\"\r",
            "            self.value = value[\"value\"] if \"value\" in value else \"\"\r",
            "            self.language = value[\"language\"] if \"language\" in value else \"\"\r",
            "\r",
            "    def index(self, scheme=None):\r",
            "        if self.category == \"label\":\r",
            "            data = JSONSerializer().serializeToPython(self)\r",
            "            if scheme is None:\r",
            "                scheme = self.get_scheme_id()\r",
            "            if scheme is None:\r",
            "                raise Exception(_(\"Index of label failed.  Index type (scheme id) could not be derived from the label.\"))\r",
            "\r",
            "            data[\"top_concept\"] = scheme.id\r",
            "            se.index_data(index=CONCEPTS_INDEX, body=data, idfield=\"id\")\r",
            "\r",
            "    def delete_index(self):\r",
            "        query = Query(se, start=0, limit=10000)\r",
            "        term = Term(field=\"id\", term=self.id)\r",
            "        query.add_query(term)\r",
            "        query.delete(index=CONCEPTS_INDEX)\r",
            "\r",
            "    def get_scheme_id(self):\r",
            "        result = se.search(index=CONCEPTS_INDEX, id=self.id)\r",
            "        if result[\"found\"]:\r",
            "            return Concept(result[\"top_concept\"])\r",
            "        else:\r",
            "            return None\r",
            "\r",
            "\r",
            "def get_preflabel_from_conceptid(conceptid, lang):\r",
            "    ret = None\r",
            "    default = {\r",
            "        \"category\": \"\",\r",
            "        \"conceptid\": \"\",\r",
            "        \"language\": \"\",\r",
            "        \"value\": \"\",\r",
            "        \"type\": \"\",\r",
            "        \"id\": \"\",\r",
            "    }\r",
            "    query = Query(se)\r",
            "    bool_query = Bool()\r",
            "    bool_query.must(Match(field=\"type\", query=\"prefLabel\", type=\"phrase\"))\r",
            "    bool_query.filter(Terms(field=\"conceptid\", terms=[conceptid]))\r",
            "    query.add_query(bool_query)\r",
            "    preflabels = query.search(index=CONCEPTS_INDEX)[\"hits\"][\"hits\"]\r",
            "    for preflabel in preflabels:\r",
            "        default = preflabel[\"_source\"]\r",
            "        if preflabel[\"_source\"][\"language\"] is not None and lang is not None:\r",
            "            # get the label in the preferred language, otherwise get the label in the default language\r",
            "            if preflabel[\"_source\"][\"language\"] == lang:\r",
            "                return preflabel[\"_source\"]\r",
            "            if preflabel[\"_source\"][\"language\"].split(\"-\")[0] == lang.split(\"-\")[0]:\r",
            "                ret = preflabel[\"_source\"]\r",
            "            if preflabel[\"_source\"][\"language\"] == settings.LANGUAGE_CODE and ret is None:\r",
            "                ret = preflabel[\"_source\"]\r",
            "    return default if ret is None else ret\r",
            "\r",
            "\r",
            "def get_valueids_from_concept_label(label, conceptid=None, lang=None):\r",
            "\r",
            "    def exact_val_match(val, conceptid=None):\r",
            "        # exact term match, don't care about relevance ordering.\r",
            "        # due to language formating issues, and with (hopefully) small result sets\r",
            "        # easier to have filter logic in python than to craft it in dsl\r",
            "        if conceptid is None:\r",
            "            return {\"query\": {\"bool\": {\"filter\": {\"match_phrase\": {\"value\": val}}}}}\r",
            "        else:\r",
            "            return {\r",
            "                \"query\": {\r",
            "                    \"bool\": {\"filter\": [{\"match_phrase\": {\"value\": val}}, {\"term\": {\"conceptid\": conceptid}}, ]}\r",
            "                }\r",
            "            }\r",
            "\r",
            "    concept_label_results = se.search(index=CONCEPTS_INDEX, body=exact_val_match(label, conceptid))\r",
            "    if concept_label_results is None:\r",
            "        print(\"Found no matches for label:'{0}' and concept_id: '{1}'\".format(label, conceptid))\r",
            "        return\r",
            "    return [\r",
            "        res[\"_source\"]\r",
            "        for res in concept_label_results[\"hits\"][\"hits\"]\r",
            "        if lang is None or res[\"_source\"][\"language\"].lower() == lang.lower()\r",
            "    ]\r",
            "\r",
            "\r",
            "def get_preflabel_from_valueid(valueid, lang):\r",
            "    concept_label = se.search(index=CONCEPTS_INDEX, id=valueid)\r",
            "    if concept_label[\"found\"]:\r",
            "        return get_preflabel_from_conceptid(concept_label[\"_source\"][\"conceptid\"], lang)\r"
        ],
        "afterPatchFile": [
            "\"\"\"\r",
            "ARCHES - a program developed to inventory and manage immovable cultural heritage.\r",
            "Copyright (C) 2013 J. Paul Getty Trust and World Monuments Fund\r",
            "\r",
            "This program is free software: you can redistribute it and/or modify\r",
            "it under the terms of the GNU Affero General Public License as\r",
            "published by the Free Software Foundation, either version 3 of the\r",
            "License, or (at your option) any later version.\r",
            "\r",
            "This program is distributed in the hope that it will be useful,\r",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of\r",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r",
            "GNU Affero General Public License for more details.\r",
            "\r",
            "You should have received a copy of the GNU Affero General Public License\r",
            "along with this program. If not, see <http://www.gnu.org/licenses/>.\r",
            "\"\"\"\r",
            "\r",
            "import re\r",
            "import uuid\r",
            "import copy\r",
            "from operator import itemgetter\r",
            "from operator import methodcaller\r",
            "from django.db import transaction, connection\r",
            "from django.db.models import Q\r",
            "from arches.app.models import models\r",
            "from arches.app.models.system_settings import settings\r",
            "from arches.app.search.search_engine_factory import SearchEngineInstance as se\r",
            "from arches.app.search.elasticsearch_dsl_builder import Term, Query, Bool, Match, Terms\r",
            "from arches.app.search.mappings import CONCEPTS_INDEX\r",
            "from arches.app.utils.betterJSONSerializer import JSONSerializer, JSONDeserializer\r",
            "from django.utils.translation import ugettext as _\r",
            "from django.utils.translation import get_language\r",
            "from django.db import IntegrityError\r",
            "from psycopg2.extensions import AsIs\r",
            "\r",
            "import logging\r",
            "\r",
            "\r",
            "logger = logging.getLogger(__name__)\r",
            "\r",
            "CORE_CONCEPTS = (\r",
            "    \"00000000-0000-0000-0000-000000000001\",\r",
            "    \"00000000-0000-0000-0000-000000000004\",\r",
            "    \"00000000-0000-0000-0000-000000000005\",\r",
            "    \"00000000-0000-0000-0000-000000000006\",\r",
            ")\r",
            "\r",
            "\r",
            "class Concept(object):\r",
            "    def __init__(self, *args, **kwargs):\r",
            "        self.id = \"\"\r",
            "        self.nodetype = \"\"\r",
            "        self.legacyoid = \"\"\r",
            "        self.relationshiptype = \"\"\r",
            "        self.values = []\r",
            "        self.subconcepts = []\r",
            "        self.parentconcepts = []\r",
            "        self.relatedconcepts = []\r",
            "        self.hassubconcepts = False\r",
            "\r",
            "        if len(args) != 0:\r",
            "            if isinstance(args[0], str):\r",
            "                try:\r",
            "                    uuid.UUID(args[0])\r",
            "                    self.get(args[0])\r",
            "                except (ValueError):\r",
            "                    self.load(JSONDeserializer().deserialize(args[0]))\r",
            "            elif isinstance(args[0], dict):\r",
            "                self.load(args[0])\r",
            "            elif isinstance(args[0], object):\r",
            "                self.load(args[0])\r",
            "\r",
            "    def __unicode__(self):\r",
            "        return (\"%s - %s\") % (self.get_preflabel().value, self.id)\r",
            "\r",
            "    def __hash__(self):\r",
            "        return hash(self.id)\r",
            "\r",
            "    def __eq__(self, x):\r",
            "        return hash(self) == hash(x)\r",
            "\r",
            "    def __ne__(self, x):\r",
            "        return hash(self) != hash(x)\r",
            "\r",
            "    def load(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.id = str(value[\"id\"]) if \"id\" in value else \"\"\r",
            "            self.nodetype = value[\"nodetype\"] if \"nodetype\" in value else \"\"\r",
            "            self.legacyoid = value[\"legacyoid\"] if \"legacyoid\" in value else \"\"\r",
            "            self.relationshiptype = value[\"relationshiptype\"] if \"relationshiptype\" in value else \"\"\r",
            "            if \"values\" in value:\r",
            "                for val in value[\"values\"]:\r",
            "                    self.addvalue(val)\r",
            "            if \"subconcepts\" in value:\r",
            "                for subconcept in value[\"subconcepts\"]:\r",
            "                    self.addsubconcept(subconcept)\r",
            "            if \"parentconcepts\" in value:\r",
            "                for parentconcept in value[\"parentconcepts\"]:\r",
            "                    self.addparent(parentconcept)\r",
            "            if \"relatedconcepts\" in value:\r",
            "                for relatedconcept in value[\"relatedconcepts\"]:\r",
            "                    self.addrelatedconcept(relatedconcept)\r",
            "\r",
            "        if isinstance(value, models.Concept):\r",
            "            self.id = str(value.pk)\r",
            "            self.nodetype = value.nodetype_id\r",
            "            self.legacyoid = value.legacyoid\r",
            "\r",
            "    def get(\r",
            "        self,\r",
            "        id=\"\",\r",
            "        legacyoid=\"\",\r",
            "        include_subconcepts=False,\r",
            "        include_parentconcepts=False,\r",
            "        include_relatedconcepts=False,\r",
            "        exclude=[],\r",
            "        include=[],\r",
            "        depth_limit=None,\r",
            "        up_depth_limit=None,\r",
            "        lang=settings.LANGUAGE_CODE,\r",
            "        semantic=True,\r",
            "        pathway_filter=None,\r",
            "        **kwargs,\r",
            "    ):\r",
            "\r",
            "        if id != \"\":\r",
            "            self.load(models.Concept.objects.get(pk=id))\r",
            "        elif legacyoid != \"\":\r",
            "            self.load(models.Concept.objects.get(legacyoid=legacyoid))\r",
            "\r",
            "        _cache = kwargs.pop(\"_cache\", {})\r",
            "        _cache[self.id] = self.__class__(\r",
            "            {\"id\": self.id, \"nodetype\": self.nodetype, \"legacyoid\": self.legacyoid, \"relationshiptype\": self.relationshiptype}\r",
            "        )\r",
            "\r",
            "        if semantic == True:\r",
            "            pathway_filter = (\r",
            "                pathway_filter\r",
            "                if pathway_filter\r",
            "                else Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\")\r",
            "            )\r",
            "        else:\r",
            "            pathway_filter = pathway_filter if pathway_filter else Q(relationtype=\"member\") | Q(relationtype=\"hasCollection\")\r",
            "\r",
            "        if self.id != \"\":\r",
            "            nodetype = kwargs.pop(\"nodetype\", self.nodetype)\r",
            "            uplevel = kwargs.pop(\"uplevel\", 0)\r",
            "            downlevel = kwargs.pop(\"downlevel\", 0)\r",
            "            depth_limit = depth_limit if depth_limit is None else int(depth_limit)\r",
            "            up_depth_limit = up_depth_limit if up_depth_limit is None else int(up_depth_limit)\r",
            "\r",
            "            if include is not None:\r",
            "                if len(include) > 0 and len(exclude) > 0:\r",
            "                    raise Exception(_(\"Only include values for include or exclude, but not both\"))\r",
            "                include = (\r",
            "                    include if len(include) != 0 else models.DValueType.objects.distinct(\"category\").values_list(\"category\", flat=True)\r",
            "                )\r",
            "                include = set(include).difference(exclude)\r",
            "                exclude = []\r",
            "\r",
            "                if len(include) > 0:\r",
            "                    values = models.Value.objects.filter(concept=self.id)\r",
            "                    for value in values:\r",
            "                        if value.valuetype.category in include:\r",
            "                            self.values.append(ConceptValue(value))\r",
            "\r",
            "            hassubconcepts = models.Relation.objects.filter(Q(conceptfrom=self.id), pathway_filter, ~Q(relationtype=\"related\"))[0:1]\r",
            "            if len(hassubconcepts) > 0:\r",
            "                self.hassubconcepts = True\r",
            "\r",
            "            if include_subconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(Q(conceptfrom=self.id), pathway_filter, ~Q(relationtype=\"related\"))\r",
            "                if depth_limit is None or downlevel < depth_limit:\r",
            "                    if depth_limit is not None:\r",
            "                        downlevel = downlevel + 1\r",
            "                    for relation in conceptrealations:\r",
            "                        subconcept = (\r",
            "                            _cache[str(relation.conceptto_id)]\r",
            "                            if str(relation.conceptto_id) in _cache\r",
            "                            else self.__class__().get(\r",
            "                                id=relation.conceptto_id,\r",
            "                                include_subconcepts=include_subconcepts,\r",
            "                                include_parentconcepts=include_parentconcepts,\r",
            "                                include_relatedconcepts=include_relatedconcepts,\r",
            "                                exclude=exclude,\r",
            "                                include=include,\r",
            "                                depth_limit=depth_limit,\r",
            "                                up_depth_limit=up_depth_limit,\r",
            "                                downlevel=downlevel,\r",
            "                                uplevel=uplevel,\r",
            "                                nodetype=nodetype,\r",
            "                                semantic=semantic,\r",
            "                                pathway_filter=pathway_filter,\r",
            "                                _cache=_cache.copy(),\r",
            "                                lang=lang,\r",
            "                            )\r",
            "                        )\r",
            "                        subconcept.relationshiptype = relation.relationtype_id\r",
            "                        self.subconcepts.append(subconcept)\r",
            "\r",
            "                    self.subconcepts = sorted(\r",
            "                        self.subconcepts, key=lambda concept: self.natural_keys(concept.get_sortkey(lang)), reverse=False\r",
            "                    )\r",
            "                    # self.subconcepts = sorted(self.subconcepts, key=methodcaller(\r",
            "                    #     'get_sortkey', lang=lang), reverse=False)\r",
            "\r",
            "            if include_parentconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(Q(conceptto=self.id), pathway_filter, ~Q(relationtype=\"related\"))\r",
            "                if up_depth_limit is None or uplevel < up_depth_limit:\r",
            "                    if up_depth_limit is not None:\r",
            "                        uplevel = uplevel + 1\r",
            "                    for relation in conceptrealations:\r",
            "                        parentconcept = (\r",
            "                            _cache[str(relation.conceptfrom_id)]\r",
            "                            if str(relation.conceptfrom_id) in _cache\r",
            "                            else self.__class__().get(\r",
            "                                id=relation.conceptfrom_id,\r",
            "                                include_subconcepts=False,\r",
            "                                include_parentconcepts=include_parentconcepts,\r",
            "                                include_relatedconcepts=include_relatedconcepts,\r",
            "                                exclude=exclude,\r",
            "                                include=include,\r",
            "                                depth_limit=depth_limit,\r",
            "                                up_depth_limit=up_depth_limit,\r",
            "                                downlevel=downlevel,\r",
            "                                uplevel=uplevel,\r",
            "                                nodetype=nodetype,\r",
            "                                semantic=semantic,\r",
            "                                pathway_filter=pathway_filter,\r",
            "                                _cache=_cache.copy(),\r",
            "                                lang=lang,\r",
            "                            )\r",
            "                        )\r",
            "                        parentconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.parentconcepts.append(parentconcept)\r",
            "\r",
            "            if include_relatedconcepts:\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(relationtype=\"related\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                    Q(conceptto=self.id) | Q(conceptfrom=self.id),\r",
            "                )\r",
            "                relations = []\r",
            "                for relation in conceptrealations:\r",
            "                    if str(relation.conceptto_id) != self.id and str(relation.relationid) not in relations:\r",
            "                        relations.append(str(relation.relationid))\r",
            "                        relatedconcept = self.__class__().get(relation.conceptto_id, include=[\"label\"], lang=lang)\r",
            "                        relatedconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.relatedconcepts.append(relatedconcept)\r",
            "                    if str(relation.conceptfrom_id) != self.id and str(relation.relationid) not in relations:\r",
            "                        relations.append(str(relation.relationid))\r",
            "                        relatedconcept = self.__class__().get(relation.conceptfrom_id, include=[\"label\"], lang=lang)\r",
            "                        relatedconcept.relationshiptype = relation.relationtype_id\r",
            "\r",
            "                        self.relatedconcepts.append(relatedconcept)\r",
            "\r",
            "        return self\r",
            "\r",
            "    def save(self):\r",
            "        self.id = self.id if (self.id != \"\" and self.id is not None) else str(uuid.uuid4())\r",
            "        concept, created = models.Concept.objects.get_or_create(\r",
            "            pk=self.id, defaults={\"legacyoid\": self.legacyoid if self.legacyoid != \"\" else self.id, \"nodetype_id\": self.nodetype}\r",
            "        )\r",
            "\r",
            "        for value in self.values:\r",
            "            if not isinstance(value, ConceptValue):\r",
            "                value = ConceptValue(value)\r",
            "            value.conceptid = self.id\r",
            "            value.save()\r",
            "\r",
            "        for parentconcept in self.parentconcepts:\r",
            "            parentconcept.save()\r",
            "            parentconcept.add_relation(self, parentconcept.relationshiptype)\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.save()\r",
            "            self.add_relation(subconcept, subconcept.relationshiptype)\r",
            "\r",
            "        # if we're moving a Concept Scheme below another Concept or Concept Scheme\r",
            "        if len(self.parentconcepts) > 0 and concept.nodetype_id == \"ConceptScheme\":\r",
            "            concept.nodetype_id = \"Concept\"\r",
            "            concept.save()\r",
            "            self.load(concept)\r",
            "\r",
            "            for relation in models.Relation.objects.filter(conceptfrom=concept, relationtype_id=\"hasTopConcept\"):\r",
            "                relation.relationtype_id = \"narrower\"\r",
            "                relation.save()\r",
            "\r",
            "        for relatedconcept in self.relatedconcepts:\r",
            "            self.add_relation(relatedconcept, relatedconcept.relationshiptype)\r",
            "\r",
            "            if relatedconcept.relationshiptype == \"member\":\r",
            "                child_concepts = relatedconcept.get(include_subconcepts=True)\r",
            "\r",
            "                def applyRelationship(concept):\r",
            "                    for subconcept in concept.subconcepts:\r",
            "                        concept.add_relation(subconcept, relatedconcept.relationshiptype)\r",
            "\r",
            "                child_concepts.traverse(applyRelationship)\r",
            "\r",
            "        return concept\r",
            "\r",
            "    def delete(self, delete_self=False):\r",
            "        \"\"\"\r",
            "        Deletes any subconcepts associated with this concept and additionally this concept if 'delete_self' is True\r",
            "        If any parentconcepts or relatedconcepts are included then it will only delete the relationship to those concepts but not the concepts themselves\r",
            "        If any values are passed, then those values as well as the relationship to those values will be deleted\r",
            "\r",
            "        Note, django will automatically take care of deleting any db models that have a foreign key relationship to the model being deleted\r",
            "        (eg: deleting a concept model will also delete all values and relationships), but because we need to manage deleting\r",
            "        parent concepts and related concepts and values we have to do that here too\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(subconcept)\r",
            "            for key, concept in concepts_to_delete.items():\r",
            "                models.Concept.objects.get(pk=key).delete()\r",
            "\r",
            "        for parentconcept in self.parentconcepts:\r",
            "            relations_filter = (\r",
            "                (Q(relationtype__category=\"Semantic Relations\") | Q(relationtype=\"hasTopConcept\"))\r",
            "                & Q(conceptfrom=parentconcept.id)\r",
            "                & Q(conceptto=self.id)\r",
            "            )\r",
            "            conceptrelations = models.Relation.objects.filter(relations_filter)\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "\r",
            "            if models.Relation.objects.filter(relations_filter).count() == 0:\r",
            "                # we've removed all parent concepts so now this concept needs to be promoted to a Concept Scheme\r",
            "                concept = models.Concept.objects.get(pk=self.id)\r",
            "                concept.nodetype_id = \"ConceptScheme\"\r",
            "                concept.save()\r",
            "                self.load(concept)\r",
            "\r",
            "                for relation in models.Relation.objects.filter(conceptfrom=concept, relationtype_id=\"narrower\"):\r",
            "                    relation.relationtype_id = \"hasTopConcept\"\r",
            "                    relation.save()\r",
            "\r",
            "        deletedrelatedconcepts = []\r",
            "        for relatedconcept in self.relatedconcepts:\r",
            "            conceptrelations = models.Relation.objects.filter(\r",
            "                Q(relationtype=\"related\") | Q(relationtype=\"member\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                conceptto=relatedconcept.id,\r",
            "                conceptfrom=self.id,\r",
            "            )\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "                deletedrelatedconcepts.append(relatedconcept)\r",
            "\r",
            "            conceptrelations = models.Relation.objects.filter(\r",
            "                Q(relationtype=\"related\") | Q(relationtype=\"member\") | Q(relationtype__category=\"Mapping Properties\"),\r",
            "                conceptfrom=relatedconcept.id,\r",
            "                conceptto=self.id,\r",
            "            )\r",
            "            for relation in conceptrelations:\r",
            "                relation.delete()\r",
            "                deletedrelatedconcepts.append(relatedconcept)\r",
            "\r",
            "        for deletedrelatedconcept in deletedrelatedconcepts:\r",
            "            if deletedrelatedconcept in self.relatedconcepts:\r",
            "                self.relatedconcepts.remove(deletedrelatedconcept)\r",
            "\r",
            "        for value in self.values:\r",
            "            if not isinstance(value, ConceptValue):\r",
            "                value = ConceptValue(value)\r",
            "            value.delete()\r",
            "\r",
            "        if delete_self:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(self)\r",
            "            for key, concept in concepts_to_delete.items():\r",
            "                # delete only member relationships if the nodetype == Collection\r",
            "                if concept.nodetype == \"Collection\":\r",
            "                    concept = Concept().get(\r",
            "                        id=concept.id,\r",
            "                        include_subconcepts=True,\r",
            "                        include_parentconcepts=True,\r",
            "                        include=[\"label\"],\r",
            "                        up_depth_limit=1,\r",
            "                        semantic=False,\r",
            "                    )\r",
            "\r",
            "                    def find_concepts(concept):\r",
            "                        if len(concept.parentconcepts) <= 1:\r",
            "                            for subconcept in concept.subconcepts:\r",
            "                                conceptrelation = models.Relation.objects.get(\r",
            "                                    conceptfrom=concept.id, conceptto=subconcept.id, relationtype=\"member\"\r",
            "                                )\r",
            "                                conceptrelation.delete()\r",
            "                                find_concepts(subconcept)\r",
            "\r",
            "                    find_concepts(concept)\r",
            "                    # if the concept is a collection, loop through the nodes and delete their rdmCollection values\r",
            "                    for node in models.Node.objects.filter(config__rdmCollection=concept.id):\r",
            "                        node.config[\"rdmCollection\"] = None\r",
            "                        node.save()\r",
            "\r",
            "                models.Concept.objects.get(pk=key).delete()\r",
            "        return\r",
            "\r",
            "    def add_relation(self, concepttorelate, relationtype):\r",
            "        \"\"\"\r",
            "        Relates this concept to 'concepttorelate' via the relationtype\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        relation, created = models.Relation.objects.get_or_create(\r",
            "            conceptfrom_id=self.id, conceptto_id=concepttorelate.id, relationtype_id=relationtype\r",
            "        )\r",
            "        return relation\r",
            "\r",
            "    @staticmethod\r",
            "    def gather_concepts_to_delete(concept, lang=settings.LANGUAGE_CODE):\r",
            "        \"\"\"\r",
            "        Gets a dictionary of all the concepts ids to delete\r",
            "        The values of the dictionary keys differ somewhat depending on the node type being deleted\r",
            "        If the nodetype == 'Concept' then return ConceptValue objects keyed to the concept id\r",
            "        If the nodetype == 'ConceptScheme' then return a ConceptValue object with the value set to any ONE prefLabel keyed to the concept id\r",
            "        We do this because it takes so long to gather the ids of the concepts when deleting a Scheme or Group\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        concepts_to_delete = {}\r",
            "\r",
            "        # Here we have to worry about making sure we don't delete nodes that have more than 1 parent\r",
            "        if concept.nodetype == \"Concept\":\r",
            "            concept = Concept().get(\r",
            "                id=concept.id, include_subconcepts=True, include_parentconcepts=True, include=[\"label\"], up_depth_limit=1\r",
            "            )\r",
            "\r",
            "            def find_concepts(concept):\r",
            "                if len(concept.parentconcepts) <= 1:\r",
            "                    concepts_to_delete[concept.id] = concept\r",
            "                    for subconcept in concept.subconcepts:\r",
            "                        find_concepts(subconcept)\r",
            "\r",
            "            find_concepts(concept)\r",
            "            return concepts_to_delete\r",
            "\r",
            "        # here we can just delete everything and so use a recursive CTE to get the concept ids much more quickly\r",
            "        if concept.nodetype == \"ConceptScheme\":\r",
            "            concepts_to_delete[concept.id] = concept\r",
            "            rows = Concept().get_child_concepts(concept.id)\r",
            "            for row in rows:\r",
            "                if row[0] not in concepts_to_delete:\r",
            "                    concepts_to_delete[row[0]] = Concept({\"id\": row[0]})\r",
            "\r",
            "                concepts_to_delete[row[0]].addvalue({\"id\": row[2], \"conceptid\": row[0], \"value\": row[1]})\r",
            "\r",
            "        if concept.nodetype == \"Collection\":\r",
            "            concepts_to_delete[concept.id] = concept\r",
            "            rows = Concept().get_child_collections(concept.id)\r",
            "            for row in rows:\r",
            "                if row[0] not in concepts_to_delete:\r",
            "                    concepts_to_delete[row[0]] = Concept({\"id\": row[0]})\r",
            "\r",
            "                concepts_to_delete[row[0]].addvalue({\"id\": row[2], \"conceptid\": row[0], \"value\": row[1]})\r",
            "\r",
            "        return concepts_to_delete\r",
            "\r",
            "    def get_child_collections_hierarchically(self, conceptid, child_valuetypes=None, offset=0, limit=50, query=None):\r",
            "        child_valuetypes = child_valuetypes if child_valuetypes else [\"prefLabel\"]\r",
            "        columns = \"valueidto::text, conceptidto::text, valueto, valuetypeto, depth, count(*) OVER() AS full_count, collector\"\r",
            "        return self.get_child_edges(\r",
            "            conceptid, [\"member\"], child_valuetypes, offset=offset, limit=limit, order_hierarchically=True, query=query, columns=columns\r",
            "        )\r",
            "\r",
            "    def get_child_collections(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", columns=None, depth_limit=\"\"):\r",
            "        child_valuetypes = child_valuetypes if child_valuetypes else [\"prefLabel\"]\r",
            "        columns = columns if columns else \"conceptidto::text, valueto, valueidto::text\"\r",
            "        return self.get_child_edges(conceptid, [\"member\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "\r",
            "    def get_child_concepts(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", columns=None, depth_limit=\"\"):\r",
            "        columns = columns if columns else \"conceptidto::text, valueto, valueidto::text\"\r",
            "        return self.get_child_edges(conceptid, [\"narrower\", \"hasTopConcept\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "\r",
            "    def get_child_concepts_for_indexing(self, conceptid, child_valuetypes=None, parent_valuetype=\"prefLabel\", depth_limit=\"\"):\r",
            "        columns = \"valueidto::text, conceptidto::text, valuetypeto, categoryto, valueto, languageto\"\r",
            "        data = self.get_child_edges(conceptid, [\"narrower\", \"hasTopConcept\"], child_valuetypes, parent_valuetype, columns, depth_limit)\r",
            "        return [dict(list(zip([\"id\", \"conceptid\", \"type\", \"category\", \"value\", \"language\"], d)), top_concept=\"\") for d in data]\r",
            "\r",
            "    def get_child_edges(\r",
            "        self,\r",
            "        conceptid,\r",
            "        relationtypes,\r",
            "        child_valuetypes=None,\r",
            "        parent_valuetype=\"prefLabel\",\r",
            "        columns=None,\r",
            "        depth_limit=None,\r",
            "        offset=None,\r",
            "        limit=20,\r",
            "        order_hierarchically=False,\r",
            "        query=None,\r",
            "        languageid=None,\r",
            "    ):\r",
            "        \"\"\"\r",
            "        Recursively builds a list of concept relations for a given concept and all it's subconcepts based on its relationship type and valuetypes.\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        # if the conceptid isn't a UUID then Postgres will throw an error and transactions will be aborted #7822\r",
            "        try:\r",
            "            uuid.UUID(conceptid)\r",
            "        except:\r",
            "            return []\r",
            "\r",
            "        # this interpolation is safe because `relationtypes` is hardcoded in all calls, and not accessible via the API\r",
            "        relationtypes = \" or \".join([\"r.relationtype = '%s'\" % (relationtype) for relationtype in relationtypes])\r",
            "        offset_clause = \" limit %(limit)s offset %(offset)s\" if offset else \"\"\r",
            "        depth_clause = \" and depth < %(depth_limit)s\" if depth_limit else \"\"\r",
            "\r",
            "        cursor = connection.cursor()\r",
            "\r",
            "        if order_hierarchically:\r",
            "            sql = \"\"\"\r",
            "                WITH RECURSIVE\r",
            "\r",
            "                 ordered_relationships AS (\r",
            "                    (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype, (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('prefLabel')\r",
            "                            ORDER BY (\r",
            "                                CASE WHEN languageid = %(languageid)s THEN 10\r",
            "                                WHEN languageid like %(short_languageid)s THEN 5\r",
            "                                WHEN languageid like %(default_languageid)s THEN 2\r",
            "                                ELSE 0\r",
            "                                END\r",
            "                            ) desc limit 1\r",
            "                        ) as valuesto,\r",
            "                        (\r",
            "                            SELECT value::int\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('sortorder')\r",
            "                            limit 1\r",
            "                        ) as sortorder,\r",
            "                        (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('collector')\r",
            "                            limit 1\r",
            "                        ) as collector\r",
            "                        FROM relations r\r",
            "                        WHERE r.conceptidfrom = %(conceptid)s\r",
            "                        and (%(relationtypes)s)\r",
            "                        ORDER BY sortorder, valuesto\r",
            "                    )\r",
            "                    UNION\r",
            "                    (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype,(\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('prefLabel')\r",
            "                            ORDER BY (\r",
            "                                CASE WHEN languageid = %(languageid)s THEN 10\r",
            "                                WHEN languageid like %(short_languageid)s THEN 5\r",
            "                                WHEN languageid like %(default_languageid)s THEN 2\r",
            "                                ELSE 0\r",
            "                                END\r",
            "                            ) desc limit 1\r",
            "                        ) as valuesto,\r",
            "                        (\r",
            "                            SELECT value::int\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('sortorder')\r",
            "                            limit 1\r",
            "                        ) as sortorder,\r",
            "                        (\r",
            "                            SELECT value\r",
            "                            FROM values\r",
            "                            WHERE conceptid=r.conceptidto\r",
            "                            AND valuetype in ('collector')\r",
            "                            limit 1\r",
            "                        ) as collector\r",
            "                        FROM relations r\r",
            "                        JOIN ordered_relationships b ON(b.conceptidto = r.conceptidfrom)\r",
            "                        WHERE (%(relationtypes)s)\r",
            "                        ORDER BY sortorder, valuesto\r",
            "                    )\r",
            "                ),\r",
            "\r",
            "                children AS (\r",
            "                    SELECT r.conceptidfrom, r.conceptidto,\r",
            "                        to_char(row_number() OVER (), 'fm000000') as row,\r",
            "                        r.collector,\r",
            "                        1 AS depth       ---|NonRecursive Part\r",
            "                        FROM ordered_relationships r\r",
            "                        WHERE r.conceptidfrom = %(conceptid)s\r",
            "                        and (%(relationtypes)s)\r",
            "                    UNION\r",
            "                        SELECT r.conceptidfrom, r.conceptidto,\r",
            "                        row || '-' || to_char(row_number() OVER (), 'fm000000'),\r",
            "                        r.collector,\r",
            "                        depth+1      ---|RecursivePart\r",
            "                        FROM ordered_relationships r\r",
            "                        JOIN children b ON(b.conceptidto = r.conceptidfrom)\r",
            "                        WHERE (%(relationtypes)s)\r",
            "                        {depth_clause}\r",
            "                )\r",
            "\r",
            "                {subquery}\r",
            "\r",
            "                SELECT\r",
            "                (\r",
            "                    select row_to_json(d)\r",
            "                    FROM (\r",
            "                        SELECT *\r",
            "                        FROM values\r",
            "                        WHERE conceptid=%(recursive_table)s.conceptidto\r",
            "                        AND valuetype in ('prefLabel')\r",
            "                        ORDER BY (\r",
            "                            CASE WHEN languageid = %(languageid)s THEN 10\r",
            "                            WHEN languageid like %(short_languageid)s THEN 5\r",
            "                            WHEN languageid like %(default_languageid)s THEN 2\r",
            "                            ELSE 0\r",
            "                            END\r",
            "                        ) desc limit 1\r",
            "                    ) d\r",
            "                ) as valueto,\r",
            "                depth, collector, count(*) OVER() AS full_count\r",
            "\r",
            "               FROM %(recursive_table)s order by row {offset_clause};\r",
            "            \"\"\"\r",
            "\r",
            "            if query:\r",
            "                subquery = \"\"\"\r",
            "                        , results as (\r",
            "                            SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r",
            "                            FROM children c\r",
            "                            JOIN values ON(values.conceptid = c.conceptidto)\r",
            "                            WHERE LOWER(values.value) like %(query)s\r",
            "                            AND values.valuetype in ('prefLabel')\r",
            "                                UNION\r",
            "                            SELECT c.conceptidfrom, c.conceptidto, c.row, c.depth, c.collector\r",
            "                            FROM children c\r",
            "                            JOIN results r on (r.conceptidfrom=c.conceptidto)\r",
            "                        )\r",
            "                    \"\"\"\r",
            "            else:\r",
            "                subquery = \"\"\r",
            "\r",
            "            sql = sql.format(subquery=subquery, offset_clause=offset_clause, depth_clause=depth_clause)\r",
            "\r",
            "            recursive_table = \"results\" if query else \"children\"\r",
            "            languageid = get_language() if languageid is None else languageid\r",
            "\r",
            "            cursor.execute(\r",
            "                sql,\r",
            "                {\r",
            "                    \"conceptid\": conceptid,\r",
            "                    \"relationtypes\": AsIs(relationtypes),\r",
            "                    \"depth_limit\": depth_limit,\r",
            "                    \"limit\": limit,\r",
            "                    \"offset\": offset,\r",
            "                    \"query\": \"%\" + query.lower() + \"%\",\r",
            "                    \"recursive_table\": AsIs(recursive_table),\r",
            "                    \"languageid\": languageid,\r",
            "                    \"short_languageid\": languageid.split(\"-\")[0] + \"%\",\r",
            "                    \"default_languageid\": settings.LANGUAGE_CODE + \"%\",\r",
            "                },\r",
            "            )\r",
            "        else:\r",
            "            sql = \"\"\"\r",
            "                WITH RECURSIVE\r",
            "                    children AS (\r",
            "                        SELECT r.conceptidfrom, r.conceptidto, r.relationtype, 1 AS depth\r",
            "                            FROM relations r\r",
            "                            WHERE r.conceptidfrom = %(conceptid)s\r",
            "                            AND (%(relationtypes)s)\r",
            "                        UNION\r",
            "                            SELECT r.conceptidfrom, r.conceptidto, r.relationtype, depth+1\r",
            "                            FROM relations r\r",
            "                            JOIN children c ON(c.conceptidto = r.conceptidfrom)\r",
            "                            WHERE (%(relationtypes)s)\r",
            "                            {depth_clause}\r",
            "                    ),\r",
            "                    results AS (\r",
            "                        SELECT\r",
            "                            valuefrom.value as valuefrom, valueto.value as valueto,\r",
            "                            valuefrom.valueid as valueidfrom, valueto.valueid as valueidto,\r",
            "                            valuefrom.valuetype as valuetypefrom, valueto.valuetype as valuetypeto,\r",
            "                            valuefrom.languageid as languagefrom, valueto.languageid as languageto,\r",
            "                            dtypesfrom.category as categoryfrom, dtypesto.category as categoryto,\r",
            "                            c.conceptidfrom, c.conceptidto\r",
            "                        FROM values valueto\r",
            "                            JOIN d_value_types dtypesto ON(dtypesto.valuetype = valueto.valuetype)\r",
            "                            JOIN children c ON(c.conceptidto = valueto.conceptid)\r",
            "                            JOIN values valuefrom ON(c.conceptidfrom = valuefrom.conceptid)\r",
            "                            JOIN d_value_types dtypesfrom ON(dtypesfrom.valuetype = valuefrom.valuetype)\r",
            "                        WHERE valueto.valuetype in (%(child_valuetypes)s)\r",
            "                        AND valuefrom.valuetype in (%(child_valuetypes)s)\r",
            "                    )\r",
            "                    SELECT distinct %(columns)s\r",
            "                    FROM results {offset_clause}\r",
            "            \"\"\"\r",
            "\r",
            "            sql = sql.format(offset_clause=offset_clause, depth_clause=depth_clause)\r",
            "\r",
            "            if not columns:\r",
            "                columns = \"\"\"\r",
            "                    conceptidfrom::text, conceptidto::text,\r",
            "                    valuefrom, valueto,\r",
            "                    valueidfrom::text, valueidto::text,\r",
            "                    valuetypefrom, valuetypeto,\r",
            "                    languagefrom, languageto,\r",
            "                    categoryfrom, categoryto\r",
            "                \"\"\"\r",
            "\r",
            "            cursor.execute(\r",
            "                sql,\r",
            "                {\r",
            "                    \"conceptid\": conceptid,\r",
            "                    \"relationtypes\": AsIs(relationtypes),\r",
            "                    \"child_valuetypes\": (\"','\").join(\r",
            "                        child_valuetypes\r",
            "                        if child_valuetypes\r",
            "                        else models.DValueType.objects.filter(category=\"label\").values_list(\"valuetype\", flat=True)\r",
            "                    ),\r",
            "                    \"columns\": AsIs(columns),\r",
            "                    \"depth_limit\": depth_limit,\r",
            "                    \"limit\": limit,\r",
            "                    \"offset\": offset,\r",
            "                },\r",
            "            )\r",
            "\r",
            "        return cursor.fetchall()\r",
            "\r",
            "    def traverse(self, func, direction=\"down\", scope=None, **kwargs):\r",
            "        \"\"\"\r",
            "        Traverses a concept graph from self to leaf (direction='down') or root (direction='up') calling\r",
            "        the given function on each node, passes an optional scope to each function\r",
            "\r",
            "        Return a value from the function to prematurely end the traversal\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        _cache = kwargs.pop(\"_cache\", [])\r",
            "        if self.id not in _cache:\r",
            "            _cache.append(self.id)\r",
            "\r",
            "            if scope is None:\r",
            "                ret = func(self, **kwargs)\r",
            "            else:\r",
            "                ret = func(self, scope, **kwargs)\r",
            "\r",
            "            # break out of the traversal if the function returns a value\r",
            "            if ret is not None:\r",
            "                return ret\r",
            "\r",
            "            if direction == \"down\":\r",
            "                for subconcept in self.subconcepts:\r",
            "                    ret = subconcept.traverse(func, direction, scope, _cache=_cache, **kwargs)\r",
            "                    if ret is not None:\r",
            "                        return ret\r",
            "            else:\r",
            "                for parentconcept in self.parentconcepts:\r",
            "                    ret = parentconcept.traverse(func, direction, scope, _cache=_cache, **kwargs)\r",
            "                    if ret is not None:\r",
            "                        return ret\r",
            "\r",
            "    def get_sortkey(self, lang=settings.LANGUAGE_CODE):\r",
            "        for value in self.values:\r",
            "            if value.type == \"sortorder\":\r",
            "                try:\r",
            "                    return float(value.value)\r",
            "                except:\r",
            "                    return None\r",
            "\r",
            "        return self.get_preflabel(lang=lang).value\r",
            "\r",
            "    def natural_keys(self, text):\r",
            "        \"\"\"\r",
            "        alist.sort(key=natural_keys) sorts in human order\r",
            "        http://nedbatchelder.com/blog/200712/human_sorting.html\r",
            "        (See Toothy's implementation in the comments)\r",
            "        float regex comes from https://stackoverflow.com/a/12643073/190597\r",
            "        \"\"\"\r",
            "\r",
            "        def atof(text):\r",
            "            try:\r",
            "                retval = float(text)\r",
            "            except ValueError:\r",
            "                retval = text\r",
            "            return retval\r",
            "\r",
            "        return [atof(c) for c in re.split(r\"[+-]?([0-9]+(?:[.][0-9]*)?|[.][0-9]+)\", str(text))]\r",
            "\r",
            "    def get_preflabel(self, lang=settings.LANGUAGE_CODE):\r",
            "        score = 0\r",
            "        ranked_labels = []\r",
            "        if self.values == []:\r",
            "            concept = Concept().get(id=self.id, include_subconcepts=False, include_parentconcepts=False, include=[\"label\"])\r",
            "        else:\r",
            "            concept = self\r",
            "\r",
            "        for value in concept.values:\r",
            "            ranked_label = {\"weight\": 1, \"value\": value}\r",
            "            if value.type == \"prefLabel\":\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 10\r",
            "            elif value.type == \"altLabel\":\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 4\r",
            "\r",
            "            if value.language == lang:\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 10\r",
            "            elif value.language.split(\"-\")[0] == lang.split(\"-\")[0]:\r",
            "                ranked_label[\"weight\"] = ranked_label[\"weight\"] * 5\r",
            "\r",
            "            ranked_labels.append(ranked_label)\r",
            "\r",
            "        ranked_labels = sorted(ranked_labels, key=lambda label: label[\"weight\"], reverse=True)\r",
            "        if len(ranked_labels) == 0:\r",
            "            ranked_labels.append({\"weight\": 1, \"value\": ConceptValue()})\r",
            "\r",
            "        return ranked_labels[0][\"value\"]\r",
            "\r",
            "    def flatten(self, ret=None):\r",
            "        \"\"\"\r",
            "        Flattens the graph into a unordered list of concepts\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        if ret is None:\r",
            "            ret = []\r",
            "\r",
            "        ret.append(self)\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.flatten(ret)\r",
            "\r",
            "        return ret\r",
            "\r",
            "    def addparent(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.parentconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.parentconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(\"Invalid parent concept definition: %s\" % (value))\r",
            "\r",
            "    def addsubconcept(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.subconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.subconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid subconcept definition: %s\") % (value))\r",
            "\r",
            "    def addrelatedconcept(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            self.relatedconcepts.append(Concept(value))\r",
            "        elif isinstance(value, Concept):\r",
            "            self.relatedconcepts.append(value)\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid related concept definition: %s\") % (value))\r",
            "\r",
            "    def addvalue(self, value):\r",
            "        if isinstance(value, dict):\r",
            "            value[\"conceptid\"] = self.id\r",
            "            self.values.append(ConceptValue(value))\r",
            "        elif isinstance(value, ConceptValue):\r",
            "            self.values.append(value)\r",
            "        elif isinstance(value, models.Value):\r",
            "            self.values.append(ConceptValue(value))\r",
            "        else:\r",
            "            raise Exception(_(\"Invalid value definition: %s\") % (value))\r",
            "\r",
            "    def index(self, scheme=None):\r",
            "        if scheme is None:\r",
            "            scheme = self.get_context()\r",
            "        for value in self.values:\r",
            "            value.index(scheme=scheme)\r",
            "\r",
            "        if self.nodetype == \"ConceptScheme\":\r",
            "            scheme = None\r",
            "\r",
            "        for subconcept in self.subconcepts:\r",
            "            subconcept.index(scheme=scheme)\r",
            "\r",
            "    def bulk_index(self):\r",
            "        concept_docs = []\r",
            "\r",
            "        if self.nodetype == \"ConceptScheme\":\r",
            "            concept = Concept().get(id=self.id, values=[\"label\"])\r",
            "            concept.index()\r",
            "            for topConcept in self.get_child_concepts_for_indexing(self.id, depth_limit=1):\r",
            "                concept = Concept().get(id=topConcept[\"conceptid\"])\r",
            "                scheme = concept.get_context()\r",
            "                topConcept[\"top_concept\"] = scheme.id\r",
            "                concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=topConcept[\"id\"], data=topConcept))\r",
            "                for childConcept in concept.get_child_concepts_for_indexing(topConcept[\"conceptid\"]):\r",
            "                    childConcept[\"top_concept\"] = scheme.id\r",
            "                    concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=childConcept[\"id\"], data=childConcept))\r",
            "\r",
            "        if self.nodetype == \"Concept\":\r",
            "            concept = Concept().get(id=self.id, values=[\"label\"])\r",
            "            scheme = concept.get_context()\r",
            "            concept.index(scheme)\r",
            "            for childConcept in concept.get_child_concepts_for_indexing(self.id):\r",
            "                childConcept[\"top_concept\"] = scheme.id\r",
            "                concept_docs.append(se.create_bulk_item(index=CONCEPTS_INDEX, id=childConcept[\"id\"], data=childConcept))\r",
            "\r",
            "        se.bulk_index(concept_docs)\r",
            "\r",
            "    def delete_index(self, delete_self=False):\r",
            "        def delete_concept_values_index(concepts_to_delete):\r",
            "            for concept in concepts_to_delete.values():\r",
            "                query = Query(se, start=0, limit=10000)\r",
            "                term = Term(field=\"conceptid\", term=concept.id)\r",
            "                query.add_query(term)\r",
            "                query.delete(index=CONCEPTS_INDEX)\r",
            "\r",
            "        if delete_self:\r",
            "            concepts_to_delete = Concept.gather_concepts_to_delete(self)\r",
            "            delete_concept_values_index(concepts_to_delete)\r",
            "        else:\r",
            "            for subconcept in self.subconcepts:\r",
            "                concepts_to_delete = Concept.gather_concepts_to_delete(subconcept)\r",
            "                delete_concept_values_index(concepts_to_delete)\r",
            "\r",
            "    def concept_tree(\r",
            "        self, top_concept=\"00000000-0000-0000-0000-000000000001\", lang=settings.LANGUAGE_CODE, mode=\"semantic\",\r",
            "    ):\r",
            "        class concept(object):\r",
            "            def __init__(self, *args, **kwargs):\r",
            "                self.label = \"\"\r",
            "                self.labelid = \"\"\r",
            "                self.id = \"\"\r",
            "                self.sortorder = None\r",
            "                self.load_on_demand = False\r",
            "                self.children = []\r",
            "\r",
            "        def _findNarrowerConcept(conceptid, depth_limit=None, level=0):\r",
            "            labels = models.Value.objects.filter(concept=conceptid)\r",
            "            ret = concept()\r",
            "            temp = Concept()\r",
            "            for label in labels:\r",
            "                temp.addvalue(label)\r",
            "                if label.valuetype_id == \"sortorder\":\r",
            "                    try:\r",
            "                        ret.sortorder = float(label.value)\r",
            "                    except:\r",
            "                        ret.sortorder = None\r",
            "\r",
            "            label = temp.get_preflabel(lang=lang)\r",
            "            ret.label = label.value\r",
            "            ret.id = label.conceptid\r",
            "            ret.labelid = label.id\r",
            "\r",
            "            if mode == \"semantic\":\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(conceptfrom=conceptid), Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\")\r",
            "                )\r",
            "            if mode == \"collections\":\r",
            "                conceptrealations = models.Relation.objects.filter(\r",
            "                    Q(conceptfrom=conceptid), Q(relationtype=\"member\") | Q(relationtype=\"hasCollection\")\r",
            "                )\r",
            "            if depth_limit is not None and len(conceptrealations) > 0 and level >= depth_limit:\r",
            "                ret.load_on_demand = True\r",
            "            else:\r",
            "                if depth_limit is not None:\r",
            "                    level = level + 1\r",
            "                for relation in conceptrealations:\r",
            "                    ret.children.append(_findNarrowerConcept(relation.conceptto_id, depth_limit=depth_limit, level=level))\r",
            "\r",
            "                ret.children = sorted(\r",
            "                    ret.children,\r",
            "                    key=lambda concept: self.natural_keys(concept.sortorder if concept.sortorder else concept.label),\r",
            "                    reverse=False,\r",
            "                )\r",
            "            return ret\r",
            "\r",
            "        def _findBroaderConcept(conceptid, child_concept, depth_limit=None, level=0):\r",
            "            conceptrealations = models.Relation.objects.filter(\r",
            "                Q(conceptto=conceptid), ~Q(relationtype=\"related\"), ~Q(relationtype__category=\"Mapping Properties\")\r",
            "            )\r",
            "            if len(conceptrealations) > 0 and conceptid != top_concept:\r",
            "                labels = models.Value.objects.filter(concept=conceptrealations[0].conceptfrom_id)\r",
            "                ret = concept()\r",
            "                temp = Concept()\r",
            "                for label in labels:\r",
            "                    temp.addvalue(label)\r",
            "                label = temp.get_preflabel(lang=lang)\r",
            "                ret.label = label.value\r",
            "                ret.id = label.conceptid\r",
            "                ret.labelid = label.id\r",
            "\r",
            "                ret.children.append(child_concept)\r",
            "                return _findBroaderConcept(conceptrealations[0].conceptfrom_id, ret, depth_limit=depth_limit, level=level)\r",
            "            else:\r",
            "                return child_concept\r",
            "\r",
            "        graph = []\r",
            "        if self.id is None or self.id == \"\" or self.id == \"None\" or self.id == top_concept:\r",
            "            if mode == \"semantic\":\r",
            "                concepts = models.Concept.objects.filter(nodetype=\"ConceptScheme\")\r",
            "                for conceptmodel in concepts:\r",
            "                    graph.append(_findNarrowerConcept(conceptmodel.pk, depth_limit=1))\r",
            "            if mode == \"collections\":\r",
            "                concepts = models.Concept.objects.filter(nodetype=\"Collection\")\r",
            "                for conceptmodel in concepts:\r",
            "                    graph.append(_findNarrowerConcept(conceptmodel.pk, depth_limit=0))\r",
            "\r",
            "                graph = sorted(graph, key=lambda concept: concept.label)\r",
            "                # graph = _findNarrowerConcept(concepts[0].pk, depth_limit=1).children\r",
            "\r",
            "        else:\r",
            "            graph = _findNarrowerConcept(self.id, depth_limit=1).children\r",
            "            # concepts = _findNarrowerConcept(self.id, depth_limit=1)\r",
            "            # graph = [_findBroaderConcept(self.id, concepts, depth_limit=1)]\r",
            "\r",
            "        return graph\r",
            "\r",
            "    def get_paths(self, lang=settings.LANGUAGE_CODE):\r",
            "        def graph_to_paths(current_concept, path=[], path_list=[], _cache=[]):\r",
            "            if len(path) == 0:\r",
            "                current_path = []\r",
            "            else:\r",
            "                current_path = path[:]\r",
            "\r",
            "            current_path.insert(\r",
            "                0,\r",
            "                {\r",
            "                    \"label\": current_concept.get_preflabel(lang=lang).value,\r",
            "                    \"relationshiptype\": current_concept.relationshiptype,\r",
            "                    \"id\": current_concept.id,\r",
            "                },\r",
            "            )\r",
            "\r",
            "            if len(current_concept.parentconcepts) == 0 or current_concept.id in _cache:\r",
            "                path_list.append(current_path[:])\r",
            "            else:\r",
            "                _cache.append(current_concept.id)\r",
            "                for parent in current_concept.parentconcepts:\r",
            "                    ret = graph_to_paths(parent, current_path, path_list, _cache)\r",
            "\r",
            "            return path_list\r",
            "\r",
            "        # def graph_to_paths(current_concept, **kwargs):\r",
            "        #     path = kwargs.get('path', [])\r",
            "        #     path_list = kwargs.get('path_list', [])\r",
            "\r",
            "        #     if len(path) == 0:\r",
            "        #         current_path = []\r",
            "        #     else:\r",
            "        #         current_path = path[:]\r",
            "\r",
            "        #     current_path.insert(0, {'label': current_concept.get_preflabel(lang=lang).value, 'relationshiptype': current_concept.relationshiptype, 'id': current_concept.id})\r",
            "\r",
            "        #     if len(current_concept.parentconcepts) == 0:\r",
            "        #         path_list.append(current_path[:])\r",
            "        #     # else:\r",
            "        #     #     for parent in current_concept.parentconcepts:\r",
            "        #     #         ret = graph_to_paths(parent, current_path, path_list, _cache)\r",
            "\r",
            "        #     #return path_list\r",
            "\r",
            "        # self.traverse(graph_to_paths, direction='up')\r",
            "\r",
            "        return graph_to_paths(self)\r",
            "\r",
            "    def get_node_and_links(self, lang=settings.LANGUAGE_CODE):\r",
            "        nodes = [{\"concept_id\": self.id, \"name\": self.get_preflabel(lang=lang).value, \"type\": \"Current\"}]\r",
            "        links = []\r",
            "\r",
            "        def get_parent_nodes_and_links(current_concept, _cache=[]):\r",
            "            if current_concept.id not in _cache:\r",
            "                _cache.append(current_concept.id)\r",
            "                parents = current_concept.parentconcepts\r",
            "                for parent in parents:\r",
            "                    nodes.append(\r",
            "                        {\r",
            "                            \"concept_id\": parent.id,\r",
            "                            \"name\": parent.get_preflabel(lang=lang).value,\r",
            "                            \"type\": \"Root\" if len(parent.parentconcepts) == 0 else \"Ancestor\",\r",
            "                        }\r",
            "                    )\r",
            "                    links.append(\r",
            "                        {\"target\": current_concept.id, \"source\": parent.id, \"relationship\": \"broader\", }\r",
            "                    )\r",
            "                    get_parent_nodes_and_links(parent, _cache)\r",
            "\r",
            "        get_parent_nodes_and_links(self)\r",
            "\r",
            "        # def get_parent_nodes_and_links(current_concept):\r",
            "        #     parents = current_concept.parentconcepts\r",
            "        #     for parent in parents:\r",
            "        #         nodes.append({'concept_id': parent.id, 'name': parent.get_preflabel(lang=lang).value, 'type': 'Root' if len(parent.parentconcepts) == 0 else 'Ancestor'})\r",
            "        #         links.append({'target': current_concept.id, 'source': parent.id, 'relationship': 'broader' })\r",
            "\r",
            "        # self.traverse(get_parent_nodes_and_links, direction='up')\r",
            "\r",
            "        for child in self.subconcepts:\r",
            "            nodes.append(\r",
            "                {\"concept_id\": child.id, \"name\": child.get_preflabel(lang=lang).value, \"type\": \"Descendant\", }\r",
            "            )\r",
            "            links.append({\"source\": self.id, \"target\": child.id, \"relationship\": \"narrower\"})\r",
            "\r",
            "        for related in self.relatedconcepts:\r",
            "            nodes.append(\r",
            "                {\"concept_id\": related.id, \"name\": related.get_preflabel(lang=lang).value, \"type\": \"Related\", }\r",
            "            )\r",
            "            links.append({\"source\": self.id, \"target\": related.id, \"relationship\": \"related\"})\r",
            "\r",
            "        # get unique node list and assign unique integer ids for each node (required by d3)\r",
            "        nodes = list({node[\"concept_id\"]: node for node in nodes}.values())\r",
            "        for i in range(len(nodes)):\r",
            "            nodes[i][\"id\"] = i\r",
            "            for link in links:\r",
            "                link[\"source\"] = i if link[\"source\"] == nodes[i][\"concept_id\"] else link[\"source\"]\r",
            "                link[\"target\"] = i if link[\"target\"] == nodes[i][\"concept_id\"] else link[\"target\"]\r",
            "\r",
            "        return {\"nodes\": nodes, \"links\": links}\r",
            "\r",
            "    def get_context(self):\r",
            "        \"\"\"\r",
            "        get the Top Concept that the Concept particpates in\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        if self.nodetype == \"Concept\" or self.nodetype == \"Collection\":\r",
            "            concept = Concept().get(id=self.id, include_parentconcepts=True, include=None)\r",
            "\r",
            "            def get_scheme_id(concept):\r",
            "                for parentconcept in concept.parentconcepts:\r",
            "                    if parentconcept.relationshiptype == \"hasTopConcept\":\r",
            "                        return concept\r",
            "\r",
            "            if len(concept.parentconcepts) > 0:\r",
            "                return concept.traverse(get_scheme_id, direction=\"up\")\r",
            "            else:\r",
            "                return self\r",
            "\r",
            "        else:  # like ConceptScheme or EntityType\r",
            "            return self\r",
            "\r",
            "    def get_scheme(self):\r",
            "        \"\"\"\r",
            "        get the ConceptScheme that the Concept particpates in\r",
            "\r",
            "        \"\"\"\r",
            "\r",
            "        topConcept = self.get_context()\r",
            "        if len(topConcept.parentconcepts) == 1:\r",
            "            if topConcept.parentconcepts[0].nodetype == \"ConceptScheme\":\r",
            "                return topConcept.parentconcepts[0]\r",
            "\r",
            "        return None\r",
            "\r",
            "    def check_if_concept_in_use(self):\r",
            "        \"\"\"Checks  if a concept or any of its subconcepts is in use by a resource instance\"\"\"\r",
            "\r",
            "        in_use = False\r",
            "        cursor = connection.cursor()\r",
            "        for value in self.values:\r",
            "            sql = (\r",
            "                \"\"\"\r",
            "                SELECT count(*) from tiles t, jsonb_each_text(t.tiledata) as json_data\r",
            "                WHERE json_data.value = '%s'\r",
            "            \"\"\"\r",
            "                % value.id\r",
            "            )\r",
            "            cursor.execute(sql)\r",
            "            rows = cursor.fetchall()\r",
            "            if rows[0][0] > 0:\r",
            "                in_use = True\r",
            "                break\r",
            "        if in_use is not True:\r",
            "            for subconcept in self.subconcepts:\r",
            "                in_use = subconcept.check_if_concept_in_use()\r",
            "                if in_use == True:\r",
            "                    return in_use\r",
            "        return in_use\r",
            "\r",
            "    def get_e55_domain(self, conceptid):\r",
            "        \"\"\"\r",
            "        For a given entitytypeid creates a dictionary representing that entitytypeid's concept graph (member pathway) formatted to support\r",
            "        select2 dropdowns\r",
            "\r",
            "        \"\"\"\r",
            "        cursor = connection.cursor()\r",
            "        cursor.execute(\r",
            "            \"\"\"\r",
            "            WITH RECURSIVE children AS (\r",
            "                SELECT d.conceptidfrom, d.conceptidto, c2.value, c2.valueid as valueid, c.value as valueto, c.valueid as valueidto, c.valuetype as vtype, 1 AS depth, array[d.conceptidto] AS conceptpath, array[c.valueid] AS idpath        ---|NonRecursive Part\r",
            "                    FROM relations d\r",
            "                    JOIN values c ON(c.conceptid = d.conceptidto)\r",
            "                    JOIN values c2 ON(c2.conceptid = d.conceptidfrom)\r",
            "                    WHERE d.conceptidfrom = %s\r",
            "                    and c2.valuetype = 'prefLabel'\r",
            "                    and c.valuetype in ('prefLabel', 'sortorder', 'collector')\r",
            "                    and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r",
            "                    UNION\r",
            "                    SELECT d.conceptidfrom, d.conceptidto, v2.value, v2.valueid as valueid, v.value as valueto, v.valueid as valueidto, v.valuetype as vtype, depth+1, (conceptpath || d.conceptidto), (idpath || v.valueid)   ---|RecursivePart\r",
            "                    FROM relations  d\r",
            "                    JOIN children b ON(b.conceptidto = d.conceptidfrom)\r",
            "                    JOIN values v ON(v.conceptid = d.conceptidto)\r",
            "                    JOIN values v2 ON(v2.conceptid = d.conceptidfrom)\r",
            "                    WHERE  v2.valuetype = 'prefLabel'\r",
            "                    and v.valuetype in ('prefLabel','sortorder', 'collector')\r",
            "                    and (d.relationtype = 'member' or d.relationtype = 'hasTopConcept')\r",
            "                ) SELECT conceptidfrom::text, conceptidto::text, value, valueid::text, valueto, valueidto::text, depth, idpath::text, conceptpath::text, vtype FROM children ORDER BY depth, conceptpath;\r",
            "            \"\"\",\r",
            "            [conceptid],\r",
            "        )\r",
            "        rows = cursor.fetchall()\r",
            "\r",
            "        column_names = [\r",
            "            \"conceptidfrom\",\r",
            "            \"conceptidto\",\r",
            "            \"value\",\r",
            "            \"valueid\",\r",
            "            \"valueto\",\r",
            "            \"valueidto\",\r",
            "            \"depth\",\r",
            "            \"idpath\",\r",
            "            \"conceptpath\",\r",
            "            \"vtype\",\r",
            "        ]\r",
            "\r",
            "        class Val(object):\r",
            "            def __init__(self, conceptid):\r",
            "                self.text = \"\"\r",
            "                self.conceptid = conceptid\r",
            "                self.id = \"\"\r",
            "                self.sortorder = \"\"\r",
            "                self.collector = \"\"\r",
            "                self.children = []\r",
            "\r",
            "        result = Val(conceptid)\r",
            "\r",
            "        def _findNarrower(val, path, rec):\r",
            "            for conceptid in path:\r",
            "                childids = [child.conceptid for child in val.children]\r",
            "                if conceptid not in childids:\r",
            "                    new_val = Val(rec[\"conceptidto\"])\r",
            "                    if rec[\"vtype\"] == \"sortorder\":\r",
            "                        new_val.sortorder = rec[\"valueto\"]\r",
            "                    elif rec[\"vtype\"] == \"prefLabel\":\r",
            "                        new_val.text = rec[\"valueto\"]\r",
            "                        new_val.id = rec[\"valueidto\"]\r",
            "                    elif rec[\"vtype\"] == \"collector\":\r",
            "                        new_val.collector = \"collector\"\r",
            "                    val.children.append(new_val)\r",
            "                else:\r",
            "                    for child in val.children:\r",
            "                        if conceptid == child.conceptid:\r",
            "                            if conceptid == path[-1]:\r",
            "                                if rec[\"vtype\"] == \"sortorder\":\r",
            "                                    child.sortorder = rec[\"valueto\"]\r",
            "                                elif rec[\"vtype\"] == \"prefLabel\":\r",
            "                                    child.text = rec[\"valueto\"]\r",
            "                                    child.id = rec[\"valueidto\"]\r",
            "                                elif rec[\"vtype\"] == \"collector\":\r",
            "                                    child.collector = \"collector\"\r",
            "                            path.pop(0)\r",
            "                            _findNarrower(child, path, rec)\r",
            "                val.children.sort(key=lambda x: (x.sortorder, x.text))\r",
            "\r",
            "        for row in rows:\r",
            "            rec = dict(list(zip(column_names, row)))\r",
            "            path = rec[\"conceptpath\"][1:-1].split(\",\")\r",
            "            _findNarrower(result, path, rec)\r",
            "\r",
            "        return JSONSerializer().serializeToPython(result)[\"children\"]\r",
            "\r",
            "    def make_collection(self):\r",
            "        if len(self.values) == 0:\r",
            "            raise Exception(_(\"Need to include values when creating a collection\"))\r",
            "        values = JSONSerializer().serializeToPython(self.values)\r",
            "        for value in values:\r",
            "            value[\"id\"] = \"\"\r",
            "        collection_concept = Concept({\"nodetype\": \"Collection\", \"values\": values})\r",
            "\r",
            "        def create_collection(conceptfrom):\r",
            "            for relation in models.Relation.objects.filter(\r",
            "                Q(conceptfrom_id=conceptfrom.id),\r",
            "                Q(relationtype__category=\"Semantic Relations\") | Q(relationtype__category=\"Properties\"),\r",
            "                ~Q(relationtype=\"related\"),\r",
            "            ):\r",
            "                conceptto = Concept(relation.conceptto)\r",
            "                if conceptfrom == self:\r",
            "                    collection_concept.add_relation(conceptto, \"member\")\r",
            "                else:\r",
            "                    conceptfrom.add_relation(conceptto, \"member\")\r",
            "                create_collection(conceptto)\r",
            "\r",
            "        with transaction.atomic():\r",
            "            collection_concept.save()\r",
            "            create_collection(self)\r",
            "\r",
            "        return collection_concept\r",
            "\r",
            "\r",
            "class ConceptValue(object):\r",
            "    def __init__(self, *args, **kwargs):\r",
            "        self.id = \"\"\r",
            "        self.conceptid = \"\"\r",
            "        self.type = \"\"\r",
            "        self.category = \"\"\r",
            "        self.value = \"\"\r",
            "        self.language = \"\"\r",
            "\r",
            "        if len(args) != 0:\r",
            "            if isinstance(args[0], str):\r",
            "                try:\r",
            "                    uuid.UUID(args[0])\r",
            "                    self.get(args[0])\r",
            "                except (ValueError):\r",
            "                    self.load(JSONDeserializer().deserialize(args[0]))\r",
            "            elif isinstance(args[0], object):\r",
            "                self.load(args[0])\r",
            "\r",
            "    def __repr__(self):\r",
            "        return ('%s: %s = \"%s\" in lang %s') % (self.__class__, self.type, self.value, self.language)\r",
            "\r",
            "    def get(self, id=\"\"):\r",
            "        self.load(models.Value.objects.get(pk=id))\r",
            "        return self\r",
            "\r",
            "    def save(self):\r",
            "        if self.value.strip() != \"\":\r",
            "            self.id = self.id if (self.id != \"\" and self.id is not None) else str(uuid.uuid4())\r",
            "            value = models.Value()\r",
            "            value.pk = self.id\r",
            "            value.value = self.value\r",
            "            value.concept_id = self.conceptid  # models.Concept.objects.get(pk=self.conceptid)\r",
            "            value.valuetype_id = self.type  # models.DValueType.objects.get(pk=self.type)\r",
            "\r",
            "            if self.language != \"\":\r",
            "                # need to normalize language ids to the form xx-XX\r",
            "                lang_parts = self.language.lower().replace(\"_\", \"-\").split(\"-\")\r",
            "                try:\r",
            "                    lang_parts[1] = lang_parts[1].upper()\r",
            "                except:\r",
            "                    pass\r",
            "                self.language = \"-\".join(lang_parts)\r",
            "                value.language_id = self.language  # models.DLanguage.objects.get(pk=self.language)\r",
            "            else:\r",
            "                value.language_id = settings.LANGUAGE_CODE\r",
            "\r",
            "            value.save()\r",
            "            self.category = value.valuetype.category\r",
            "\r",
            "    def delete(self):\r",
            "        if self.id != \"\":\r",
            "            newvalue = models.Value.objects.get(pk=self.id)\r",
            "            if newvalue.valuetype.valuetype == \"image\":\r",
            "                newvalue = models.FileValue.objects.get(pk=self.id)\r",
            "            newvalue.delete()\r",
            "            self = ConceptValue()\r",
            "            return self\r",
            "\r",
            "    def load(self, value):\r",
            "        if isinstance(value, models.Value):\r",
            "            self.id = str(value.pk)\r",
            "            self.conceptid = str(value.concept_id)\r",
            "            self.type = value.valuetype_id\r",
            "            self.category = value.valuetype.category\r",
            "            self.value = value.value\r",
            "            self.language = value.language_id\r",
            "\r",
            "        if isinstance(value, dict):\r",
            "            self.id = str(value[\"id\"]) if \"id\" in value else \"\"\r",
            "            self.conceptid = str(value[\"conceptid\"]) if \"conceptid\" in value else \"\"\r",
            "            self.type = value[\"type\"] if \"type\" in value else \"\"\r",
            "            self.category = value[\"category\"] if \"category\" in value else \"\"\r",
            "            self.value = value[\"value\"] if \"value\" in value else \"\"\r",
            "            self.language = value[\"language\"] if \"language\" in value else \"\"\r",
            "\r",
            "    def index(self, scheme=None):\r",
            "        if self.category == \"label\":\r",
            "            data = JSONSerializer().serializeToPython(self)\r",
            "            if scheme is None:\r",
            "                scheme = self.get_scheme_id()\r",
            "            if scheme is None:\r",
            "                raise Exception(_(\"Index of label failed.  Index type (scheme id) could not be derived from the label.\"))\r",
            "\r",
            "            data[\"top_concept\"] = scheme.id\r",
            "            se.index_data(index=CONCEPTS_INDEX, body=data, idfield=\"id\")\r",
            "\r",
            "    def delete_index(self):\r",
            "        query = Query(se, start=0, limit=10000)\r",
            "        term = Term(field=\"id\", term=self.id)\r",
            "        query.add_query(term)\r",
            "        query.delete(index=CONCEPTS_INDEX)\r",
            "\r",
            "    def get_scheme_id(self):\r",
            "        result = se.search(index=CONCEPTS_INDEX, id=self.id)\r",
            "        if result[\"found\"]:\r",
            "            return Concept(result[\"top_concept\"])\r",
            "        else:\r",
            "            return None\r",
            "\r",
            "\r",
            "def get_preflabel_from_conceptid(conceptid, lang):\r",
            "    ret = None\r",
            "    default = {\r",
            "        \"category\": \"\",\r",
            "        \"conceptid\": \"\",\r",
            "        \"language\": \"\",\r",
            "        \"value\": \"\",\r",
            "        \"type\": \"\",\r",
            "        \"id\": \"\",\r",
            "    }\r",
            "    query = Query(se)\r",
            "    bool_query = Bool()\r",
            "    bool_query.must(Match(field=\"type\", query=\"prefLabel\", type=\"phrase\"))\r",
            "    bool_query.filter(Terms(field=\"conceptid\", terms=[conceptid]))\r",
            "    query.add_query(bool_query)\r",
            "    preflabels = query.search(index=CONCEPTS_INDEX)[\"hits\"][\"hits\"]\r",
            "    for preflabel in preflabels:\r",
            "        default = preflabel[\"_source\"]\r",
            "        if preflabel[\"_source\"][\"language\"] is not None and lang is not None:\r",
            "            # get the label in the preferred language, otherwise get the label in the default language\r",
            "            if preflabel[\"_source\"][\"language\"] == lang:\r",
            "                return preflabel[\"_source\"]\r",
            "            if preflabel[\"_source\"][\"language\"].split(\"-\")[0] == lang.split(\"-\")[0]:\r",
            "                ret = preflabel[\"_source\"]\r",
            "            if preflabel[\"_source\"][\"language\"] == settings.LANGUAGE_CODE and ret is None:\r",
            "                ret = preflabel[\"_source\"]\r",
            "    return default if ret is None else ret\r",
            "\r",
            "\r",
            "def get_valueids_from_concept_label(label, conceptid=None, lang=None):\r",
            "\r",
            "    def exact_val_match(val, conceptid=None):\r",
            "        # exact term match, don't care about relevance ordering.\r",
            "        # due to language formating issues, and with (hopefully) small result sets\r",
            "        # easier to have filter logic in python than to craft it in dsl\r",
            "        if conceptid is None:\r",
            "            return {\"query\": {\"bool\": {\"filter\": {\"match_phrase\": {\"value\": val}}}}}\r",
            "        else:\r",
            "            return {\r",
            "                \"query\": {\r",
            "                    \"bool\": {\"filter\": [{\"match_phrase\": {\"value\": val}}, {\"term\": {\"conceptid\": conceptid}}, ]}\r",
            "                }\r",
            "            }\r",
            "\r",
            "    concept_label_results = se.search(index=CONCEPTS_INDEX, body=exact_val_match(label, conceptid))\r",
            "    if concept_label_results is None:\r",
            "        print(\"Found no matches for label:'{0}' and concept_id: '{1}'\".format(label, conceptid))\r",
            "        return\r",
            "    return [\r",
            "        res[\"_source\"]\r",
            "        for res in concept_label_results[\"hits\"][\"hits\"]\r",
            "        if lang is None or res[\"_source\"][\"language\"].lower() == lang.lower()\r",
            "    ]\r",
            "\r",
            "\r",
            "def get_preflabel_from_valueid(valueid, lang):\r",
            "    concept_label = se.search(index=CONCEPTS_INDEX, id=valueid)\r",
            "    if concept_label[\"found\"]:\r",
            "        return get_preflabel_from_conceptid(concept_label[\"_source\"][\"conceptid\"], lang)\r"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "508": [
                "Concept",
                "get_child_edges"
            ],
            "510": [
                "Concept",
                "get_child_edges"
            ],
            "511": [
                "Concept",
                "get_child_edges"
            ],
            "512": [
                "Concept",
                "get_child_edges"
            ],
            "513": [
                "Concept",
                "get_child_edges"
            ],
            "514": [
                "Concept",
                "get_child_edges"
            ],
            "528": [
                "Concept",
                "get_child_edges"
            ],
            "529": [
                "Concept",
                "get_child_edges"
            ],
            "530": [
                "Concept",
                "get_child_edges"
            ],
            "550": [
                "Concept",
                "get_child_edges"
            ],
            "551": [
                "Concept",
                "get_child_edges"
            ],
            "562": [
                "Concept",
                "get_child_edges"
            ],
            "563": [
                "Concept",
                "get_child_edges"
            ],
            "564": [
                "Concept",
                "get_child_edges"
            ],
            "585": [
                "Concept",
                "get_child_edges"
            ],
            "596": [
                "Concept",
                "get_child_edges"
            ],
            "597": [
                "Concept",
                "get_child_edges"
            ],
            "605": [
                "Concept",
                "get_child_edges"
            ],
            "606": [
                "Concept",
                "get_child_edges"
            ],
            "617": [
                "Concept",
                "get_child_edges"
            ],
            "620": [
                "Concept",
                "get_child_edges"
            ],
            "621": [
                "Concept",
                "get_child_edges"
            ],
            "622": [
                "Concept",
                "get_child_edges"
            ],
            "630": [
                "Concept",
                "get_child_edges"
            ],
            "631": [
                "Concept",
                "get_child_edges"
            ],
            "634": [
                "Concept",
                "get_child_edges"
            ],
            "635": [
                "Concept",
                "get_child_edges"
            ],
            "636": [
                "Concept",
                "get_child_edges"
            ],
            "637": [
                "Concept",
                "get_child_edges"
            ],
            "638": [
                "Concept",
                "get_child_edges"
            ],
            "639": [
                "Concept",
                "get_child_edges"
            ],
            "640": [
                "Concept",
                "get_child_edges"
            ],
            "641": [
                "Concept",
                "get_child_edges"
            ],
            "642": [
                "Concept",
                "get_child_edges"
            ],
            "643": [
                "Concept",
                "get_child_edges"
            ],
            "644": [
                "Concept",
                "get_child_edges"
            ],
            "645": [
                "Concept",
                "get_child_edges"
            ],
            "646": [
                "Concept",
                "get_child_edges"
            ],
            "647": [
                "Concept",
                "get_child_edges"
            ],
            "648": [
                "Concept",
                "get_child_edges"
            ],
            "649": [
                "Concept",
                "get_child_edges"
            ],
            "653": [
                "Concept",
                "get_child_edges"
            ],
            "654": [
                "Concept",
                "get_child_edges"
            ],
            "655": [
                "Concept",
                "get_child_edges"
            ],
            "656": [
                "Concept",
                "get_child_edges"
            ],
            "657": [
                "Concept",
                "get_child_edges"
            ],
            "658": [
                "Concept",
                "get_child_edges"
            ],
            "659": [
                "Concept",
                "get_child_edges"
            ],
            "660": [
                "Concept",
                "get_child_edges"
            ],
            "661": [
                "Concept",
                "get_child_edges"
            ],
            "662": [
                "Concept",
                "get_child_edges"
            ],
            "663": [
                "Concept",
                "get_child_edges"
            ],
            "664": [
                "Concept",
                "get_child_edges"
            ],
            "666": [
                "Concept",
                "get_child_edges"
            ],
            "673": [
                "Concept",
                "get_child_edges"
            ],
            "674": [
                "Concept",
                "get_child_edges"
            ],
            "679": [
                "Concept",
                "get_child_edges"
            ],
            "680": [
                "Concept",
                "get_child_edges"
            ],
            "695": [
                "Concept",
                "get_child_edges"
            ],
            "696": [
                "Concept",
                "get_child_edges"
            ],
            "698": [
                "Concept",
                "get_child_edges"
            ],
            "699": [
                "Concept",
                "get_child_edges"
            ],
            "700": [
                "Concept",
                "get_child_edges"
            ],
            "713": [
                "Concept",
                "get_child_edges"
            ],
            "714": [
                "Concept",
                "get_child_edges"
            ],
            "715": [
                "Concept",
                "get_child_edges"
            ],
            "716": [
                "Concept",
                "get_child_edges"
            ],
            "717": [
                "Concept",
                "get_child_edges"
            ],
            "718": [
                "Concept",
                "get_child_edges"
            ],
            "719": [
                "Concept",
                "get_child_edges"
            ],
            "722": [
                "Concept",
                "get_child_edges"
            ],
            "723": [
                "Concept",
                "get_child_edges"
            ],
            "724": [
                "Concept",
                "get_child_edges"
            ],
            "725": [
                "Concept",
                "get_child_edges"
            ],
            "1179": [
                "Concept",
                "get_e55_domain"
            ],
            "1180": [
                "Concept",
                "get_e55_domain"
            ],
            "1181": [
                "Concept",
                "get_e55_domain"
            ],
            "1182": [
                "Concept",
                "get_e55_domain"
            ],
            "1183": [
                "Concept",
                "get_e55_domain"
            ],
            "1184": [
                "Concept",
                "get_e55_domain"
            ],
            "1185": [
                "Concept",
                "get_e55_domain"
            ],
            "1186": [
                "Concept",
                "get_e55_domain"
            ],
            "1187": [
                "Concept",
                "get_e55_domain"
            ],
            "1188": [
                "Concept",
                "get_e55_domain"
            ],
            "1189": [
                "Concept",
                "get_e55_domain"
            ],
            "1190": [
                "Concept",
                "get_e55_domain"
            ],
            "1191": [
                "Concept",
                "get_e55_domain"
            ],
            "1192": [
                "Concept",
                "get_e55_domain"
            ],
            "1193": [
                "Concept",
                "get_e55_domain"
            ],
            "1194": [
                "Concept",
                "get_e55_domain"
            ],
            "1195": [
                "Concept",
                "get_e55_domain"
            ],
            "1196": [
                "Concept",
                "get_e55_domain"
            ],
            "1197": [
                "Concept",
                "get_e55_domain"
            ],
            "1198": [
                "Concept",
                "get_e55_domain"
            ],
            "1199": [
                "Concept",
                "get_e55_domain"
            ],
            "1200": [
                "Concept",
                "get_e55_domain"
            ],
            "1201": [
                "Concept",
                "get_e55_domain"
            ],
            "1216": [
                "Concept",
                "get_e55_domain"
            ],
            "1217": [
                "Concept",
                "get_e55_domain"
            ]
        },
        "addLocation": []
    },
    "arches/app/views/concept.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 380,
                "PatchRowcode": " \r"
            },
            "1": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": " def paged_dropdown(request):\r"
            },
            "2": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "     conceptid = request.GET.get(\"conceptid\")\r"
            },
            "3": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    query = request.GET.get(\"query\", None)\r"
            },
            "4": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    query = None if query == \"\" else query\r"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+    query = request.GET.get(\"query\", \"\")\r"
            },
            "6": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "     page = int(request.GET.get(\"page\", 1))\r"
            },
            "7": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "     limit = 50\r"
            },
            "8": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "     offset = (page - 1) * limit\r"
            },
            "9": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "                     found = True\r"
            },
            "10": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "                     break\r"
            },
            "11": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "             if not found:\r"
            },
            "12": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                sql = \"\"\"\r"
            },
            "13": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    SELECT value, valueid\r"
            },
            "14": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    FROM \r"
            },
            "15": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    (\r"
            },
            "16": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        SELECT *, CASE WHEN LOWER(languageid) = '{languageid}' THEN 10\r"
            },
            "17": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        WHEN LOWER(languageid) like '{short_languageid}%' THEN 5\r"
            },
            "18": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        ELSE 0\r"
            },
            "19": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        END score\r"
            },
            "20": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        FROM values\r"
            },
            "21": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ) as vals\r"
            },
            "22": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    WHERE LOWER(value)='{query}' AND score > 0\r"
            },
            "23": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    AND valuetype in ('prefLabel')\r"
            },
            "24": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ORDER BY score desc limit 1\r"
            },
            "25": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"\"\"\r"
            },
            "26": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\r"
            },
            "27": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "                 languageid = get_language().lower()\r"
            },
            "28": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                sql = sql.format(query=query.lower(), languageid=languageid, short_languageid=languageid.split(\"-\")[0])\r"
            },
            "29": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "                 cursor = connection.cursor()\r"
            },
            "30": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cursor.execute(sql)\r"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+                cursor.execute(\r"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+                    \"\"\"\r"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+                        SELECT value, valueid\r"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+                        FROM\r"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+                        (\r"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+                            SELECT *, CASE WHEN LOWER(languageid) = %(languageid)s THEN 10\r"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+                            WHEN LOWER(languageid) like %(short_languageid)s THEN 5\r"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+                            ELSE 0\r"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+                            END score\r"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+                            FROM values\r"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+                        ) as vals\r"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+                        WHERE LOWER(value)=%(query)s AND score > 0\r"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+                        AND valuetype in ('prefLabel')\r"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+                        ORDER BY score desc limit 1\r"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+                    \"\"\",\r"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+                    {\"languageid\": languageid, \"short_languageid\": languageid.split(\"-\")[0] + \"%\", \"query\": query.lower()},\r"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+                )\r"
            },
            "48": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 426,
                "PatchRowcode": "                 rows = cursor.fetchall()\r"
            },
            "49": {
                "beforePatchRowNumber": 428,
                "afterPatchRowNumber": 427,
                "PatchRowcode": " \r"
            },
            "50": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "                 if len(rows) == 1:\r"
            }
        },
        "frontPatchFile": [
            "\"\"\"\r",
            "ARCHES - a program developed to inventory and manage immovable cultural heritage.\r",
            "Copyright (C) 2013 J. Paul Getty Trust and World Monuments Fund\r",
            "\r",
            "This program is free software: you can redistribute it and/or modify\r",
            "it under the terms of the GNU Affero General Public License as\r",
            "published by the Free Software Foundation, either version 3 of the\r",
            "License, or (at your option) any later version.\r",
            "\r",
            "This program is distributed in the hope that it will be useful,\r",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of\r",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r",
            "GNU Affero General Public License for more details.\r",
            "\r",
            "You should have received a copy of the GNU Affero General Public License\r",
            "along with this program. If not, see <http://www.gnu.org/licenses/>.\r",
            "\"\"\"\r",
            "\r",
            "import uuid\r",
            "from django.db import transaction, connection\r",
            "from django.db.models import Q\r",
            "from django.http import HttpResponse, HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseServerError\r",
            "from django.shortcuts import render\r",
            "from django.utils.decorators import method_decorator\r",
            "from django.utils.module_loading import import_string\r",
            "from django.utils.translation import ugettext as _\r",
            "from django.utils.translation import get_language\r",
            "from arches.app.models import models\r",
            "from arches.app.models.system_settings import settings\r",
            "from arches.app.models.concept import Concept, ConceptValue, CORE_CONCEPTS, get_preflabel_from_valueid\r",
            "from arches.app.search.search_engine_factory import SearchEngineInstance as se\r",
            "from arches.app.search.elasticsearch_dsl_builder import Bool, Match, Query, Nested, Terms, GeoShape, Range, SimpleQueryString\r",
            "from arches.app.search.mappings import CONCEPTS_INDEX\r",
            "from arches.app.utils.decorators import group_required\r",
            "from arches.app.utils.betterJSONSerializer import JSONSerializer, JSONDeserializer\r",
            "from arches.app.utils.response import JSONResponse, JSONErrorResponse\r",
            "from arches.app.utils.skos import SKOSWriter, SKOSReader\r",
            "from arches.app.views.base import BaseManagerView\r",
            "\r",
            "\r",
            "@method_decorator(group_required(\"RDM Administrator\"), name=\"dispatch\")\r",
            "class RDMView(BaseManagerView):\r",
            "    def get(self, request, conceptid):\r",
            "        lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "\r",
            "        languages = sort_languages(models.Language.objects.all(), lang)\r",
            "\r",
            "        concept_schemes = []\r",
            "        for concept in models.Concept.objects.filter(nodetype=\"ConceptScheme\"):\r",
            "            concept_schemes.append(Concept().get(id=concept.pk, include=[\"label\"]).get_preflabel(lang=lang))\r",
            "\r",
            "        collections = []\r",
            "        for concept in models.Concept.objects.filter(nodetype=\"Collection\"):\r",
            "            collections.append(Concept().get(id=concept.pk, include=[\"label\"]).get_preflabel(lang=lang))\r",
            "\r",
            "        context = self.get_context_data(\r",
            "            main_script=\"rdm\",\r",
            "            active_page=\"RDM\",\r",
            "            languages=languages,\r",
            "            conceptid=conceptid,\r",
            "            concept_schemes=concept_schemes,\r",
            "            collections=collections,\r",
            "            CORE_CONCEPTS=CORE_CONCEPTS,\r",
            "        )\r",
            "\r",
            "        context[\"nav\"][\"icon\"] = \"fa fa-align-left\"\r",
            "        context[\"nav\"][\"title\"] = _(\"Reference Data Manager\")\r",
            "        context[\"nav\"][\"help\"] = {\"title\": _(\"Using the RDM\"), \"template\": \"rdm-help\"}\r",
            "\r",
            "        return render(request, \"rdm.htm\", context)\r",
            "\r",
            "\r",
            "def get_sparql_providers(endpoint=None):\r",
            "    sparql_providers = {}\r",
            "    for provider in settings.SPARQL_ENDPOINT_PROVIDERS:\r",
            "        provider_class = provider[\"SPARQL_ENDPOINT_PROVIDER\"][settings.LANGUAGE_CODE][\"value\"]\r",
            "        Provider = import_string(provider_class)()\r",
            "        sparql_providers[Provider.endpoint] = Provider\r",
            "\r",
            "    if endpoint:\r",
            "        return sparql_providers[endpoint]\r",
            "    else:\r",
            "        return sparql_providers\r",
            "\r",
            "\r",
            "def sort_languages(languages, lang):\r",
            "    \"\"\"\r",
            "    Sorts languages from the d_languages model by name. If there is more than one\r",
            "    default language or no default language, the default language is defined by lang\r",
            "    \"\"\"\r",
            "\r",
            "    if len([l for l in languages if l.isdefault == True]) != 1:\r",
            "        for l in languages:\r",
            "            if l.code == lang:\r",
            "                l.isdefault = True\r",
            "            else:\r",
            "                l.isdefault = False\r",
            "\r",
            "    return sorted(languages, key=lambda x: x.name)\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def concept(request, conceptid):\r",
            "    f = request.GET.get(\"f\", \"json\")\r",
            "    mode = request.GET.get(\"mode\", \"\")\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    pretty = request.GET.get(\"pretty\", False)\r",
            "\r",
            "    if request.method == \"GET\":\r",
            "        include_subconcepts = request.GET.get(\"include_subconcepts\", \"true\") == \"true\"\r",
            "        include_parentconcepts = request.GET.get(\"include_parentconcepts\", \"true\") == \"true\"\r",
            "        include_relatedconcepts = request.GET.get(\"include_relatedconcepts\", \"true\") == \"true\"\r",
            "        emulate_elastic_search = request.GET.get(\"emulate_elastic_search\", \"false\") == \"true\"\r",
            "        depth_limit = request.GET.get(\"depth_limit\", None)\r",
            "\r",
            "        depth_limit = 1\r",
            "        if not conceptid:\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/concept-report.htm\",\r",
            "                {\r",
            "                    \"lang\": lang,\r",
            "                    \"concept_count\": models.Concept.objects.filter(nodetype=\"Concept\").count(),\r",
            "                    \"collection_count\": models.Concept.objects.filter(nodetype=\"Collection\").count(),\r",
            "                    \"scheme_count\": models.Concept.objects.filter(nodetype=\"ConceptScheme\").count(),\r",
            "                    \"entitytype_count\": models.Concept.objects.filter(nodetype=\"EntityType\").count(),\r",
            "                    \"default_report\": True,\r",
            "                },\r",
            "            )\r",
            "\r",
            "        labels = []\r",
            "\r",
            "        concept_graph = Concept().get(\r",
            "            id=conceptid,\r",
            "            include_subconcepts=include_subconcepts,\r",
            "            include_parentconcepts=include_parentconcepts,\r",
            "            include_relatedconcepts=include_relatedconcepts,\r",
            "            depth_limit=depth_limit,\r",
            "            up_depth_limit=None,\r",
            "            lang=lang,\r",
            "            semantic=(mode == \"semantic\" or mode == \"\"),\r",
            "        )\r",
            "\r",
            "        languages = sort_languages(models.Language.objects.all(), lang)\r",
            "\r",
            "        valuetypes = models.DValueType.objects.all()\r",
            "        relationtypes = models.DRelationType.objects.all()\r",
            "        prefLabel = concept_graph.get_preflabel(lang=lang)\r",
            "        for subconcept in concept_graph.subconcepts:\r",
            "            subconcept.prefLabel = subconcept.get_preflabel(lang=lang)\r",
            "        for relatedconcept in concept_graph.relatedconcepts:\r",
            "            relatedconcept.prefLabel = relatedconcept.get_preflabel(lang=lang)\r",
            "        for value in concept_graph.values:\r",
            "            if value.category == \"label\":\r",
            "                labels.append(value)\r",
            "            if value.type == \"image\":\r",
            "                value.full_image_url = (\r",
            "                    (settings.FORCE_SCRIPT_NAME if settings.FORCE_SCRIPT_NAME is not None else \"\") + settings.MEDIA_URL + value.value\r",
            "                ).replace(\"//\", \"/\")\r",
            "\r",
            "        if (mode == \"semantic\" or mode == \"\") and (\r",
            "            concept_graph.nodetype == \"Concept\" or concept_graph.nodetype == \"ConceptScheme\" or concept_graph.nodetype == \"EntityType\"\r",
            "        ):\r",
            "            if concept_graph.nodetype == \"ConceptScheme\":\r",
            "                parent_relations = relationtypes.filter(category=\"Properties\")\r",
            "            else:\r",
            "                parent_relations = (\r",
            "                    relationtypes.filter(category=\"Semantic Relations\")\r",
            "                    .exclude(relationtype=\"related\")\r",
            "                    .exclude(relationtype=\"broader\")\r",
            "                    .exclude(relationtype=\"broaderTransitive\")\r",
            "                )\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/concept-report.htm\",\r",
            "                {\r",
            "                    \"FORCE_SCRIPT_NAME\": settings.FORCE_SCRIPT_NAME,\r",
            "                    \"lang\": lang,\r",
            "                    \"prefLabel\": prefLabel,\r",
            "                    \"labels\": labels,\r",
            "                    \"concept\": concept_graph,\r",
            "                    \"languages\": languages,\r",
            "                    \"sparql_providers\": get_sparql_providers(),\r",
            "                    \"valuetype_labels\": valuetypes.filter(category=\"label\"),\r",
            "                    \"valuetype_notes\": valuetypes.filter(category=\"note\"),\r",
            "                    \"valuetype_related_values\": valuetypes.filter(category__in=[\"undefined\", \"identifiers\"]),\r",
            "                    \"parent_relations\": parent_relations,\r",
            "                    \"related_relations\": relationtypes.filter(Q(category=\"Mapping Properties\") | Q(relationtype=\"related\")),\r",
            "                    \"concept_paths\": concept_graph.get_paths(lang=lang),\r",
            "                    \"graph_json\": JSONSerializer().serialize(concept_graph.get_node_and_links(lang=lang)),\r",
            "                    \"direct_parents\": [parent.get_preflabel(lang=lang) for parent in concept_graph.parentconcepts],\r",
            "                },\r",
            "            )\r",
            "        elif mode == \"collections\":\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/entitytype-report.htm\",\r",
            "                {\r",
            "                    \"lang\": lang,\r",
            "                    \"prefLabel\": prefLabel,\r",
            "                    \"labels\": labels,\r",
            "                    \"concept\": concept_graph,\r",
            "                    \"languages\": languages,\r",
            "                    \"valuetype_labels\": valuetypes.filter(category=\"label\"),\r",
            "                    \"valuetype_notes\": valuetypes.filter(category=\"note\"),\r",
            "                    \"valuetype_related_values\": valuetypes.filter(category__in=[\"undefined\", \"identifiers\"]),\r",
            "                    \"related_relations\": relationtypes.filter(relationtype=\"member\"),\r",
            "                    \"concept_paths\": concept_graph.get_paths(lang=lang),\r",
            "                },\r",
            "            )\r",
            "\r",
            "    if request.method == \"POST\":\r",
            "\r",
            "        if len(request.FILES) > 0:\r",
            "            skosfile = request.FILES.get(\"skosfile\", None)\r",
            "            imagefile = request.FILES.get(\"file\", None)\r",
            "\r",
            "            if imagefile:\r",
            "                value = models.FileValue(\r",
            "                    valueid=str(uuid.uuid4()),\r",
            "                    value=request.FILES.get(\"file\", None),\r",
            "                    concept_id=conceptid,\r",
            "                    valuetype_id=\"image\",\r",
            "                    language_id=lang,\r",
            "                )\r",
            "                value.save()\r",
            "                return JSONResponse(value)\r",
            "\r",
            "            elif skosfile:\r",
            "                overwrite_options = request.POST.get(\"overwrite_options\", None)\r",
            "                staging_options = request.POST.get(\"staging_options\", None)\r",
            "                skos = SKOSReader()\r",
            "                try:\r",
            "                    rdf = skos.read_file(skosfile)\r",
            "                    ret = skos.save_concepts_from_skos(rdf, overwrite_options, staging_options)\r",
            "                    return JSONResponse(ret)\r",
            "                except Exception as e:\r",
            "                    return JSONErrorResponse(_('Unable to Load SKOS File'), _('There was an issue saving the contents of the file to Arches. ') + str(e))\r",
            "\r",
            "        else:\r",
            "            data = JSONDeserializer().deserialize(request.body)\r",
            "            if data:\r",
            "                with transaction.atomic():\r",
            "                    concept = Concept(data)\r",
            "                    concept.save()\r",
            "                    concept.index()\r",
            "\r",
            "                    return JSONResponse(concept)\r",
            "\r",
            "    if request.method == \"DELETE\":\r",
            "        data = JSONDeserializer().deserialize(request.body)\r",
            "        if data:\r",
            "            with transaction.atomic():\r",
            "                concept = Concept(data)\r",
            "                delete_self = data[\"delete_self\"] if \"delete_self\" in data else False\r",
            "                if not (delete_self and concept.id in CORE_CONCEPTS):\r",
            "                    if concept.nodetype == \"Collection\":\r",
            "                        concept.delete(delete_self=delete_self)\r",
            "                    else:\r",
            "                        in_use = False\r",
            "                        if delete_self:\r",
            "                            check_concept = Concept().get(data[\"id\"], include_subconcepts=True)\r",
            "                            in_use = check_concept.check_if_concept_in_use()\r",
            "                        if \"subconcepts\" in data:\r",
            "                            for subconcept in data[\"subconcepts\"]:\r",
            "                                if in_use == False:\r",
            "                                    check_concept = Concept().get(subconcept[\"id\"], include_subconcepts=True)\r",
            "                                    in_use = check_concept.check_if_concept_in_use()\r",
            "\r",
            "                        if in_use == False:\r",
            "                            concept.delete_index(delete_self=delete_self)\r",
            "                            concept.delete(delete_self=delete_self)\r",
            "                        else:\r",
            "                            return JSONErrorResponse(_('Unable to Delete'), _('This concept or one of it\\'s subconcepts is already in use by an existing resource.'), {\"in_use\": in_use})\r",
            "\r",
            "                return JSONResponse(concept)\r",
            "\r",
            "    return HttpResponseNotFound\r",
            "\r",
            "\r",
            "def export(request, conceptid):\r",
            "    concept_graphs = [\r",
            "        Concept().get(\r",
            "            id=conceptid,\r",
            "            include_subconcepts=True,\r",
            "            include_parentconcepts=False,\r",
            "            include_relatedconcepts=True,\r",
            "            depth_limit=None,\r",
            "            up_depth_limit=None,\r",
            "        )\r",
            "    ]\r",
            "\r",
            "    skos = SKOSWriter()\r",
            "    return HttpResponse(skos.write(concept_graphs, format=\"pretty-xml\"), content_type=\"application/xml\")\r",
            "\r",
            "\r",
            "def export_collections(request):\r",
            "    concept_graphs = []\r",
            "    for concept in models.Concept.objects.filter(nodetype_id=\"Collection\"):\r",
            "        concept_graphs.append(\r",
            "            Concept().get(\r",
            "                id=concept.pk,\r",
            "                include_subconcepts=True,\r",
            "                include_parentconcepts=False,\r",
            "                include_relatedconcepts=False,\r",
            "                depth_limit=None,\r",
            "                up_depth_limit=None,\r",
            "                semantic=False,\r",
            "            )\r",
            "        )\r",
            "\r",
            "    skos = SKOSWriter()\r",
            "    return HttpResponse(skos.write(concept_graphs, format=\"pretty-xml\"), content_type=\"application/xml\")\r",
            "\r",
            "\r",
            "def get_concept_collections(request):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    concept_collections = Concept().concept_tree(mode=\"collections\", lang=lang)\r",
            "    return JSONResponse(concept_collections)\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def make_collection(request, conceptid):\r",
            "    concept = Concept().get(id=conceptid, values=[])\r",
            "    try:\r",
            "        collection_concept = concept.make_collection()\r",
            "        return JSONResponse({'collection': collection_concept, 'title': _('Success'), 'message': _('Collection successfully created from the selected concept')})\r",
            "    except:\r",
            "        return JSONErrorResponse(_('Unable to Make Collection'), _('Unable to make a collection from the selected concept.'))\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def manage_parents(request, conceptid):\r",
            "    if request.method == \"POST\":\r",
            "        json = request.body\r",
            "        if json is not None:\r",
            "            data = JSONDeserializer().deserialize(json)\r",
            "\r",
            "            with transaction.atomic():\r",
            "                if len(data[\"deleted\"]) > 0:\r",
            "                    concept = Concept().get(id=conceptid, include=None)\r",
            "                    for deleted in data[\"deleted\"]:\r",
            "                        concept.addparent(deleted)\r",
            "\r",
            "                    concept.delete()\r",
            "                    concept.bulk_index()\r",
            "\r",
            "                if len(data[\"added\"]) > 0:\r",
            "                    concept = Concept().get(id=conceptid)\r",
            "                    for added in data[\"added\"]:\r",
            "                        concept.addparent(added)\r",
            "\r",
            "                    concept.save()\r",
            "                    concept.bulk_index()\r",
            "\r",
            "            return JSONResponse(data)\r",
            "\r",
            "    else:\r",
            "        return HttpResponseNotAllowed([\"POST\"])\r",
            "\r",
            "    return HttpResponseNotFound()\r",
            "\r",
            "\r",
            "def confirm_delete(request, conceptid):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    concept = Concept().get(id=conceptid)\r",
            "    concepts_to_delete = [\r",
            "        concept.get_preflabel(lang=lang).value for key, concept in Concept.gather_concepts_to_delete(concept, lang=lang).items()\r",
            "    ]\r",
            "    # return HttpResponse('<div>Showing only 50 of\r",
            "    # %s concepts</div><ul><li>%s</ul>' % (len(concepts_to_delete), '<li>'.join(concepts_to_delete[:50]) + ''))\r",
            "    return HttpResponse(\"<ul><li>%s</ul>\" % (\"<li>\".join(concepts_to_delete) + \"\"))\r",
            "\r",
            "\r",
            "def dropdown(request):\r",
            "    conceptid = request.GET.get(\"conceptid\")\r",
            "    results = Concept().get_e55_domain(conceptid)\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def paged_dropdown(request):\r",
            "    conceptid = request.GET.get(\"conceptid\")\r",
            "    query = request.GET.get(\"query\", None)\r",
            "    query = None if query == \"\" else query\r",
            "    page = int(request.GET.get(\"page\", 1))\r",
            "    limit = 50\r",
            "    offset = (page - 1) * limit\r",
            "\r",
            "    results = Concept().get_child_collections_hierarchically(conceptid, offset=offset, limit=limit, query=query)\r",
            "    total_count = results[0][3] if len(results) > 0 else 0\r",
            "    data = [dict(list(zip([\"valueto\", \"depth\", \"collector\"], d))) for d in results]\r",
            "    data = [\r",
            "        dict(list(zip([\"id\", \"text\", \"conceptid\", \"language\", \"type\"], d[\"valueto\"].values())), depth=d[\"depth\"], collector=d[\"collector\"])\r",
            "        for d in data\r",
            "    ]\r",
            "\r",
            "    # This try/except block trys to find an exact match to the concept the user is searching and if found\r",
            "    # it will insert it into the results as the first item so that users don't have to scroll to find it.\r",
            "    # See: https://github.com/archesproject/arches/issues/8355\r",
            "    try:\r",
            "        if page == 1:\r",
            "            found = False\r",
            "            for i, d in enumerate(data):\r",
            "                if i <= 7 and d[\"text\"].lower() == query.lower():\r",
            "                    found = True\r",
            "                    break\r",
            "            if not found:\r",
            "                sql = \"\"\"\r",
            "                    SELECT value, valueid\r",
            "                    FROM \r",
            "                    (\r",
            "                        SELECT *, CASE WHEN LOWER(languageid) = '{languageid}' THEN 10\r",
            "                        WHEN LOWER(languageid) like '{short_languageid}%' THEN 5\r",
            "                        ELSE 0\r",
            "                        END score\r",
            "                        FROM values\r",
            "                    ) as vals\r",
            "                    WHERE LOWER(value)='{query}' AND score > 0\r",
            "                    AND valuetype in ('prefLabel')\r",
            "                    ORDER BY score desc limit 1\r",
            "                \"\"\"\r",
            "\r",
            "                languageid = get_language().lower()\r",
            "                sql = sql.format(query=query.lower(), languageid=languageid, short_languageid=languageid.split(\"-\")[0])\r",
            "                cursor = connection.cursor()\r",
            "                cursor.execute(sql)\r",
            "                rows = cursor.fetchall()\r",
            "\r",
            "                if len(rows) == 1:\r",
            "                    data.insert(0, {\"id\": str(rows[0][1]), \"text\": rows[0][0], \"depth\": 1, \"collector\": False})\r",
            "    except:\r",
            "        pass\r",
            "\r",
            "    return JSONResponse({\"results\": data, \"more\": offset + limit < total_count})\r",
            "\r",
            "\r",
            "def get_pref_label(request):\r",
            "    valueid = request.GET.get(\"valueid\")\r",
            "    label = get_preflabel_from_valueid(valueid, request.LANGUAGE_CODE)\r",
            "    return JSONResponse(label)\r",
            "\r",
            "\r",
            "def search(request):\r",
            "    searchString = request.GET[\"q\"]\r",
            "    removechildren = request.GET.get(\"removechildren\", None)\r",
            "    query = Query(se, start=0, limit=100)\r",
            "    phrase = Match(field=\"value\", query=searchString.lower(), type=\"phrase_prefix\")\r",
            "    query.add_query(phrase)\r",
            "    results = query.search(index=CONCEPTS_INDEX)\r",
            "\r",
            "    ids = []\r",
            "    if removechildren is not None:\r",
            "        ids = [concept[0] for concept in Concept().get_child_concepts(removechildren, columns=\"conceptidto::text\")]\r",
            "        ids.append(removechildren)\r",
            "\r",
            "    newresults = []\r",
            "    cached_scheme_names = {}\r",
            "    for result in results[\"hits\"][\"hits\"]:\r",
            "        if result[\"_source\"][\"conceptid\"] not in ids:\r",
            "            # first look to see if we've already retrieved the top concept name\r",
            "            # else look up the top concept name with ES and cache the result\r",
            "            top_concept = result[\"_source\"][\"top_concept\"]\r",
            "            if top_concept in cached_scheme_names:\r",
            "                result[\"in_scheme_name\"] = cached_scheme_names[top_concept]\r",
            "            else:\r",
            "                query = Query(se, start=0, limit=100)\r",
            "                phrase = Match(field=\"conceptid\", query=top_concept, type=\"phrase\")\r",
            "                query.add_query(phrase)\r",
            "                scheme = query.search(index=CONCEPTS_INDEX)\r",
            "                for label in scheme[\"hits\"][\"hits\"]:\r",
            "                    if label[\"_source\"][\"type\"] == \"prefLabel\":\r",
            "                        cached_scheme_names[top_concept] = label[\"_source\"][\"value\"]\r",
            "                        result[\"in_scheme_name\"] = label[\"_source\"][\"value\"]\r",
            "\r",
            "            newresults.append(result)\r",
            "\r",
            "    # Use the db to get the concept context but this is SLOW\r",
            "    # for result in results['hits']['hits']:\r",
            "    #     if result['_source']['conceptid'] not in ids:\r",
            "    #         concept = Concept().get(id=result['_source']['conceptid'], include_parentconcepts=True)\r",
            "    #         pathlist = concept.get_paths()\r",
            "    #         result['in_scheme_name'] = pathlist[0][0]['label']\r",
            "    #         newresults.append(result)\r",
            "\r",
            "    # def crawl(conceptid, path=[]):\r",
            "    #     query = Query(se, start=0, limit=100)\r",
            "    #     bool = Bool()\r",
            "    #     bool.must(Match(field='conceptto', query=conceptid, type='phrase'))\r",
            "    #     bool.must(Match(field='relationtype', query='narrower', type='phrase'))\r",
            "    #     query.add_query(bool)\r",
            "    #     relations = query.search(index='concept_relations')\r",
            "    #     for relation in relations['hits']['hits']:\r",
            "    #         path.insert(0, relation)\r",
            "    #         crawl(relation['_source']['conceptfrom'], path=path)\r",
            "    #     return path\r",
            "\r",
            "    # for result in results['hits']['hits']:\r",
            "    #     if result['_source']['conceptid'] not in ids:\r",
            "    #         concept_relations = crawl(result['_source']['conceptid'], path=[])\r",
            "    #         if len(concept_relations) > 0:\r",
            "    #             conceptid = concept_relations[0]['_source']['conceptfrom']\r",
            "    #             if conceptid in cached_scheme_names:\r",
            "    #                 result['in_scheme_name'] = cached_scheme_names[conceptid]\r",
            "    #             else:\r",
            "    #                 result['in_scheme_name'] = get_preflabel_from_conceptid(conceptid, lang=request.LANGUAGE_CODE)['value']\r",
            "    #                 cached_scheme_names[conceptid] = result['in_scheme_name']\r",
            "\r",
            "    #         newresults.append(result)\r",
            "\r",
            "    results[\"hits\"][\"hits\"] = newresults\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def add_concepts_from_sparql_endpoint(request, conceptid):\r",
            "    if request.method == \"POST\":\r",
            "        json = request.body\r",
            "        if json is not None:\r",
            "            data = JSONDeserializer().deserialize(json)\r",
            "\r",
            "            parentconcept = Concept({\"id\": conceptid, \"nodetype\": data[\"model\"][\"nodetype\"]})\r",
            "\r",
            "            if parentconcept.nodetype == \"Concept\":\r",
            "                relationshiptype = \"narrower\"\r",
            "            elif parentconcept.nodetype == \"ConceptScheme\":\r",
            "                relationshiptype = \"hasTopConcept\"\r",
            "\r",
            "            provider = get_sparql_providers(data[\"endpoint\"])\r",
            "            try:\r",
            "                parentconcept.subconcepts = provider.get_concepts(data[\"ids\"])\r",
            "            except Exception as e:\r",
            "                return HttpResponseServerError(e.message)\r",
            "\r",
            "            for subconcept in parentconcept.subconcepts:\r",
            "                subconcept.relationshiptype = relationshiptype\r",
            "\r",
            "            parentconcept.save()\r",
            "            parentconcept.index()\r",
            "\r",
            "            return JSONResponse(parentconcept, indent=4)\r",
            "\r",
            "    else:\r",
            "        return HttpResponseNotAllowed([\"POST\"])\r",
            "\r",
            "    return HttpResponseNotFound()\r",
            "\r",
            "\r",
            "def search_sparql_endpoint_for_concepts(request):\r",
            "    provider = get_sparql_providers(request.GET.get(\"endpoint\"))\r",
            "    results = provider.search_for_concepts(request.GET.get(\"terms\"))\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def concept_tree(request, mode):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    conceptid = request.GET.get(\"node\", None)\r",
            "    concepts = Concept({\"id\": conceptid}).concept_tree(lang=lang, mode=mode)\r",
            "    return JSONResponse(concepts, indent=4)\r",
            "\r",
            "\r",
            "def concept_value(request):\r",
            "    if request.method == \"DELETE\":\r",
            "        data = JSONDeserializer().deserialize(request.body)\r",
            "\r",
            "        if data:\r",
            "            with transaction.atomic():\r",
            "                value = ConceptValue(data)\r",
            "                value.delete_index()\r",
            "                value.delete()\r",
            "                return JSONResponse(value)\r",
            "    if request.method == \"GET\":\r",
            "        valueid = request.GET.get(\"valueid\")\r",
            "        value = models.Value.objects.get(pk=valueid)\r",
            "        return JSONResponse(value)\r",
            "\r",
            "    return HttpResponseNotFound\r"
        ],
        "afterPatchFile": [
            "\"\"\"\r",
            "ARCHES - a program developed to inventory and manage immovable cultural heritage.\r",
            "Copyright (C) 2013 J. Paul Getty Trust and World Monuments Fund\r",
            "\r",
            "This program is free software: you can redistribute it and/or modify\r",
            "it under the terms of the GNU Affero General Public License as\r",
            "published by the Free Software Foundation, either version 3 of the\r",
            "License, or (at your option) any later version.\r",
            "\r",
            "This program is distributed in the hope that it will be useful,\r",
            "but WITHOUT ANY WARRANTY; without even the implied warranty of\r",
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r",
            "GNU Affero General Public License for more details.\r",
            "\r",
            "You should have received a copy of the GNU Affero General Public License\r",
            "along with this program. If not, see <http://www.gnu.org/licenses/>.\r",
            "\"\"\"\r",
            "\r",
            "import uuid\r",
            "from django.db import transaction, connection\r",
            "from django.db.models import Q\r",
            "from django.http import HttpResponse, HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseServerError\r",
            "from django.shortcuts import render\r",
            "from django.utils.decorators import method_decorator\r",
            "from django.utils.module_loading import import_string\r",
            "from django.utils.translation import ugettext as _\r",
            "from django.utils.translation import get_language\r",
            "from arches.app.models import models\r",
            "from arches.app.models.system_settings import settings\r",
            "from arches.app.models.concept import Concept, ConceptValue, CORE_CONCEPTS, get_preflabel_from_valueid\r",
            "from arches.app.search.search_engine_factory import SearchEngineInstance as se\r",
            "from arches.app.search.elasticsearch_dsl_builder import Bool, Match, Query, Nested, Terms, GeoShape, Range, SimpleQueryString\r",
            "from arches.app.search.mappings import CONCEPTS_INDEX\r",
            "from arches.app.utils.decorators import group_required\r",
            "from arches.app.utils.betterJSONSerializer import JSONSerializer, JSONDeserializer\r",
            "from arches.app.utils.response import JSONResponse, JSONErrorResponse\r",
            "from arches.app.utils.skos import SKOSWriter, SKOSReader\r",
            "from arches.app.views.base import BaseManagerView\r",
            "\r",
            "\r",
            "@method_decorator(group_required(\"RDM Administrator\"), name=\"dispatch\")\r",
            "class RDMView(BaseManagerView):\r",
            "    def get(self, request, conceptid):\r",
            "        lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "\r",
            "        languages = sort_languages(models.Language.objects.all(), lang)\r",
            "\r",
            "        concept_schemes = []\r",
            "        for concept in models.Concept.objects.filter(nodetype=\"ConceptScheme\"):\r",
            "            concept_schemes.append(Concept().get(id=concept.pk, include=[\"label\"]).get_preflabel(lang=lang))\r",
            "\r",
            "        collections = []\r",
            "        for concept in models.Concept.objects.filter(nodetype=\"Collection\"):\r",
            "            collections.append(Concept().get(id=concept.pk, include=[\"label\"]).get_preflabel(lang=lang))\r",
            "\r",
            "        context = self.get_context_data(\r",
            "            main_script=\"rdm\",\r",
            "            active_page=\"RDM\",\r",
            "            languages=languages,\r",
            "            conceptid=conceptid,\r",
            "            concept_schemes=concept_schemes,\r",
            "            collections=collections,\r",
            "            CORE_CONCEPTS=CORE_CONCEPTS,\r",
            "        )\r",
            "\r",
            "        context[\"nav\"][\"icon\"] = \"fa fa-align-left\"\r",
            "        context[\"nav\"][\"title\"] = _(\"Reference Data Manager\")\r",
            "        context[\"nav\"][\"help\"] = {\"title\": _(\"Using the RDM\"), \"template\": \"rdm-help\"}\r",
            "\r",
            "        return render(request, \"rdm.htm\", context)\r",
            "\r",
            "\r",
            "def get_sparql_providers(endpoint=None):\r",
            "    sparql_providers = {}\r",
            "    for provider in settings.SPARQL_ENDPOINT_PROVIDERS:\r",
            "        provider_class = provider[\"SPARQL_ENDPOINT_PROVIDER\"][settings.LANGUAGE_CODE][\"value\"]\r",
            "        Provider = import_string(provider_class)()\r",
            "        sparql_providers[Provider.endpoint] = Provider\r",
            "\r",
            "    if endpoint:\r",
            "        return sparql_providers[endpoint]\r",
            "    else:\r",
            "        return sparql_providers\r",
            "\r",
            "\r",
            "def sort_languages(languages, lang):\r",
            "    \"\"\"\r",
            "    Sorts languages from the d_languages model by name. If there is more than one\r",
            "    default language or no default language, the default language is defined by lang\r",
            "    \"\"\"\r",
            "\r",
            "    if len([l for l in languages if l.isdefault == True]) != 1:\r",
            "        for l in languages:\r",
            "            if l.code == lang:\r",
            "                l.isdefault = True\r",
            "            else:\r",
            "                l.isdefault = False\r",
            "\r",
            "    return sorted(languages, key=lambda x: x.name)\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def concept(request, conceptid):\r",
            "    f = request.GET.get(\"f\", \"json\")\r",
            "    mode = request.GET.get(\"mode\", \"\")\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    pretty = request.GET.get(\"pretty\", False)\r",
            "\r",
            "    if request.method == \"GET\":\r",
            "        include_subconcepts = request.GET.get(\"include_subconcepts\", \"true\") == \"true\"\r",
            "        include_parentconcepts = request.GET.get(\"include_parentconcepts\", \"true\") == \"true\"\r",
            "        include_relatedconcepts = request.GET.get(\"include_relatedconcepts\", \"true\") == \"true\"\r",
            "        emulate_elastic_search = request.GET.get(\"emulate_elastic_search\", \"false\") == \"true\"\r",
            "        depth_limit = request.GET.get(\"depth_limit\", None)\r",
            "\r",
            "        depth_limit = 1\r",
            "        if not conceptid:\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/concept-report.htm\",\r",
            "                {\r",
            "                    \"lang\": lang,\r",
            "                    \"concept_count\": models.Concept.objects.filter(nodetype=\"Concept\").count(),\r",
            "                    \"collection_count\": models.Concept.objects.filter(nodetype=\"Collection\").count(),\r",
            "                    \"scheme_count\": models.Concept.objects.filter(nodetype=\"ConceptScheme\").count(),\r",
            "                    \"entitytype_count\": models.Concept.objects.filter(nodetype=\"EntityType\").count(),\r",
            "                    \"default_report\": True,\r",
            "                },\r",
            "            )\r",
            "\r",
            "        labels = []\r",
            "\r",
            "        concept_graph = Concept().get(\r",
            "            id=conceptid,\r",
            "            include_subconcepts=include_subconcepts,\r",
            "            include_parentconcepts=include_parentconcepts,\r",
            "            include_relatedconcepts=include_relatedconcepts,\r",
            "            depth_limit=depth_limit,\r",
            "            up_depth_limit=None,\r",
            "            lang=lang,\r",
            "            semantic=(mode == \"semantic\" or mode == \"\"),\r",
            "        )\r",
            "\r",
            "        languages = sort_languages(models.Language.objects.all(), lang)\r",
            "\r",
            "        valuetypes = models.DValueType.objects.all()\r",
            "        relationtypes = models.DRelationType.objects.all()\r",
            "        prefLabel = concept_graph.get_preflabel(lang=lang)\r",
            "        for subconcept in concept_graph.subconcepts:\r",
            "            subconcept.prefLabel = subconcept.get_preflabel(lang=lang)\r",
            "        for relatedconcept in concept_graph.relatedconcepts:\r",
            "            relatedconcept.prefLabel = relatedconcept.get_preflabel(lang=lang)\r",
            "        for value in concept_graph.values:\r",
            "            if value.category == \"label\":\r",
            "                labels.append(value)\r",
            "            if value.type == \"image\":\r",
            "                value.full_image_url = (\r",
            "                    (settings.FORCE_SCRIPT_NAME if settings.FORCE_SCRIPT_NAME is not None else \"\") + settings.MEDIA_URL + value.value\r",
            "                ).replace(\"//\", \"/\")\r",
            "\r",
            "        if (mode == \"semantic\" or mode == \"\") and (\r",
            "            concept_graph.nodetype == \"Concept\" or concept_graph.nodetype == \"ConceptScheme\" or concept_graph.nodetype == \"EntityType\"\r",
            "        ):\r",
            "            if concept_graph.nodetype == \"ConceptScheme\":\r",
            "                parent_relations = relationtypes.filter(category=\"Properties\")\r",
            "            else:\r",
            "                parent_relations = (\r",
            "                    relationtypes.filter(category=\"Semantic Relations\")\r",
            "                    .exclude(relationtype=\"related\")\r",
            "                    .exclude(relationtype=\"broader\")\r",
            "                    .exclude(relationtype=\"broaderTransitive\")\r",
            "                )\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/concept-report.htm\",\r",
            "                {\r",
            "                    \"FORCE_SCRIPT_NAME\": settings.FORCE_SCRIPT_NAME,\r",
            "                    \"lang\": lang,\r",
            "                    \"prefLabel\": prefLabel,\r",
            "                    \"labels\": labels,\r",
            "                    \"concept\": concept_graph,\r",
            "                    \"languages\": languages,\r",
            "                    \"sparql_providers\": get_sparql_providers(),\r",
            "                    \"valuetype_labels\": valuetypes.filter(category=\"label\"),\r",
            "                    \"valuetype_notes\": valuetypes.filter(category=\"note\"),\r",
            "                    \"valuetype_related_values\": valuetypes.filter(category__in=[\"undefined\", \"identifiers\"]),\r",
            "                    \"parent_relations\": parent_relations,\r",
            "                    \"related_relations\": relationtypes.filter(Q(category=\"Mapping Properties\") | Q(relationtype=\"related\")),\r",
            "                    \"concept_paths\": concept_graph.get_paths(lang=lang),\r",
            "                    \"graph_json\": JSONSerializer().serialize(concept_graph.get_node_and_links(lang=lang)),\r",
            "                    \"direct_parents\": [parent.get_preflabel(lang=lang) for parent in concept_graph.parentconcepts],\r",
            "                },\r",
            "            )\r",
            "        elif mode == \"collections\":\r",
            "            return render(\r",
            "                request,\r",
            "                \"views/rdm/entitytype-report.htm\",\r",
            "                {\r",
            "                    \"lang\": lang,\r",
            "                    \"prefLabel\": prefLabel,\r",
            "                    \"labels\": labels,\r",
            "                    \"concept\": concept_graph,\r",
            "                    \"languages\": languages,\r",
            "                    \"valuetype_labels\": valuetypes.filter(category=\"label\"),\r",
            "                    \"valuetype_notes\": valuetypes.filter(category=\"note\"),\r",
            "                    \"valuetype_related_values\": valuetypes.filter(category__in=[\"undefined\", \"identifiers\"]),\r",
            "                    \"related_relations\": relationtypes.filter(relationtype=\"member\"),\r",
            "                    \"concept_paths\": concept_graph.get_paths(lang=lang),\r",
            "                },\r",
            "            )\r",
            "\r",
            "    if request.method == \"POST\":\r",
            "\r",
            "        if len(request.FILES) > 0:\r",
            "            skosfile = request.FILES.get(\"skosfile\", None)\r",
            "            imagefile = request.FILES.get(\"file\", None)\r",
            "\r",
            "            if imagefile:\r",
            "                value = models.FileValue(\r",
            "                    valueid=str(uuid.uuid4()),\r",
            "                    value=request.FILES.get(\"file\", None),\r",
            "                    concept_id=conceptid,\r",
            "                    valuetype_id=\"image\",\r",
            "                    language_id=lang,\r",
            "                )\r",
            "                value.save()\r",
            "                return JSONResponse(value)\r",
            "\r",
            "            elif skosfile:\r",
            "                overwrite_options = request.POST.get(\"overwrite_options\", None)\r",
            "                staging_options = request.POST.get(\"staging_options\", None)\r",
            "                skos = SKOSReader()\r",
            "                try:\r",
            "                    rdf = skos.read_file(skosfile)\r",
            "                    ret = skos.save_concepts_from_skos(rdf, overwrite_options, staging_options)\r",
            "                    return JSONResponse(ret)\r",
            "                except Exception as e:\r",
            "                    return JSONErrorResponse(_('Unable to Load SKOS File'), _('There was an issue saving the contents of the file to Arches. ') + str(e))\r",
            "\r",
            "        else:\r",
            "            data = JSONDeserializer().deserialize(request.body)\r",
            "            if data:\r",
            "                with transaction.atomic():\r",
            "                    concept = Concept(data)\r",
            "                    concept.save()\r",
            "                    concept.index()\r",
            "\r",
            "                    return JSONResponse(concept)\r",
            "\r",
            "    if request.method == \"DELETE\":\r",
            "        data = JSONDeserializer().deserialize(request.body)\r",
            "        if data:\r",
            "            with transaction.atomic():\r",
            "                concept = Concept(data)\r",
            "                delete_self = data[\"delete_self\"] if \"delete_self\" in data else False\r",
            "                if not (delete_self and concept.id in CORE_CONCEPTS):\r",
            "                    if concept.nodetype == \"Collection\":\r",
            "                        concept.delete(delete_self=delete_self)\r",
            "                    else:\r",
            "                        in_use = False\r",
            "                        if delete_self:\r",
            "                            check_concept = Concept().get(data[\"id\"], include_subconcepts=True)\r",
            "                            in_use = check_concept.check_if_concept_in_use()\r",
            "                        if \"subconcepts\" in data:\r",
            "                            for subconcept in data[\"subconcepts\"]:\r",
            "                                if in_use == False:\r",
            "                                    check_concept = Concept().get(subconcept[\"id\"], include_subconcepts=True)\r",
            "                                    in_use = check_concept.check_if_concept_in_use()\r",
            "\r",
            "                        if in_use == False:\r",
            "                            concept.delete_index(delete_self=delete_self)\r",
            "                            concept.delete(delete_self=delete_self)\r",
            "                        else:\r",
            "                            return JSONErrorResponse(_('Unable to Delete'), _('This concept or one of it\\'s subconcepts is already in use by an existing resource.'), {\"in_use\": in_use})\r",
            "\r",
            "                return JSONResponse(concept)\r",
            "\r",
            "    return HttpResponseNotFound\r",
            "\r",
            "\r",
            "def export(request, conceptid):\r",
            "    concept_graphs = [\r",
            "        Concept().get(\r",
            "            id=conceptid,\r",
            "            include_subconcepts=True,\r",
            "            include_parentconcepts=False,\r",
            "            include_relatedconcepts=True,\r",
            "            depth_limit=None,\r",
            "            up_depth_limit=None,\r",
            "        )\r",
            "    ]\r",
            "\r",
            "    skos = SKOSWriter()\r",
            "    return HttpResponse(skos.write(concept_graphs, format=\"pretty-xml\"), content_type=\"application/xml\")\r",
            "\r",
            "\r",
            "def export_collections(request):\r",
            "    concept_graphs = []\r",
            "    for concept in models.Concept.objects.filter(nodetype_id=\"Collection\"):\r",
            "        concept_graphs.append(\r",
            "            Concept().get(\r",
            "                id=concept.pk,\r",
            "                include_subconcepts=True,\r",
            "                include_parentconcepts=False,\r",
            "                include_relatedconcepts=False,\r",
            "                depth_limit=None,\r",
            "                up_depth_limit=None,\r",
            "                semantic=False,\r",
            "            )\r",
            "        )\r",
            "\r",
            "    skos = SKOSWriter()\r",
            "    return HttpResponse(skos.write(concept_graphs, format=\"pretty-xml\"), content_type=\"application/xml\")\r",
            "\r",
            "\r",
            "def get_concept_collections(request):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    concept_collections = Concept().concept_tree(mode=\"collections\", lang=lang)\r",
            "    return JSONResponse(concept_collections)\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def make_collection(request, conceptid):\r",
            "    concept = Concept().get(id=conceptid, values=[])\r",
            "    try:\r",
            "        collection_concept = concept.make_collection()\r",
            "        return JSONResponse({'collection': collection_concept, 'title': _('Success'), 'message': _('Collection successfully created from the selected concept')})\r",
            "    except:\r",
            "        return JSONErrorResponse(_('Unable to Make Collection'), _('Unable to make a collection from the selected concept.'))\r",
            "\r",
            "\r",
            "@group_required(\"RDM Administrator\")\r",
            "def manage_parents(request, conceptid):\r",
            "    if request.method == \"POST\":\r",
            "        json = request.body\r",
            "        if json is not None:\r",
            "            data = JSONDeserializer().deserialize(json)\r",
            "\r",
            "            with transaction.atomic():\r",
            "                if len(data[\"deleted\"]) > 0:\r",
            "                    concept = Concept().get(id=conceptid, include=None)\r",
            "                    for deleted in data[\"deleted\"]:\r",
            "                        concept.addparent(deleted)\r",
            "\r",
            "                    concept.delete()\r",
            "                    concept.bulk_index()\r",
            "\r",
            "                if len(data[\"added\"]) > 0:\r",
            "                    concept = Concept().get(id=conceptid)\r",
            "                    for added in data[\"added\"]:\r",
            "                        concept.addparent(added)\r",
            "\r",
            "                    concept.save()\r",
            "                    concept.bulk_index()\r",
            "\r",
            "            return JSONResponse(data)\r",
            "\r",
            "    else:\r",
            "        return HttpResponseNotAllowed([\"POST\"])\r",
            "\r",
            "    return HttpResponseNotFound()\r",
            "\r",
            "\r",
            "def confirm_delete(request, conceptid):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    concept = Concept().get(id=conceptid)\r",
            "    concepts_to_delete = [\r",
            "        concept.get_preflabel(lang=lang).value for key, concept in Concept.gather_concepts_to_delete(concept, lang=lang).items()\r",
            "    ]\r",
            "    # return HttpResponse('<div>Showing only 50 of\r",
            "    # %s concepts</div><ul><li>%s</ul>' % (len(concepts_to_delete), '<li>'.join(concepts_to_delete[:50]) + ''))\r",
            "    return HttpResponse(\"<ul><li>%s</ul>\" % (\"<li>\".join(concepts_to_delete) + \"\"))\r",
            "\r",
            "\r",
            "def dropdown(request):\r",
            "    conceptid = request.GET.get(\"conceptid\")\r",
            "    results = Concept().get_e55_domain(conceptid)\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def paged_dropdown(request):\r",
            "    conceptid = request.GET.get(\"conceptid\")\r",
            "    query = request.GET.get(\"query\", \"\")\r",
            "    page = int(request.GET.get(\"page\", 1))\r",
            "    limit = 50\r",
            "    offset = (page - 1) * limit\r",
            "\r",
            "    results = Concept().get_child_collections_hierarchically(conceptid, offset=offset, limit=limit, query=query)\r",
            "    total_count = results[0][3] if len(results) > 0 else 0\r",
            "    data = [dict(list(zip([\"valueto\", \"depth\", \"collector\"], d))) for d in results]\r",
            "    data = [\r",
            "        dict(list(zip([\"id\", \"text\", \"conceptid\", \"language\", \"type\"], d[\"valueto\"].values())), depth=d[\"depth\"], collector=d[\"collector\"])\r",
            "        for d in data\r",
            "    ]\r",
            "\r",
            "    # This try/except block trys to find an exact match to the concept the user is searching and if found\r",
            "    # it will insert it into the results as the first item so that users don't have to scroll to find it.\r",
            "    # See: https://github.com/archesproject/arches/issues/8355\r",
            "    try:\r",
            "        if page == 1:\r",
            "            found = False\r",
            "            for i, d in enumerate(data):\r",
            "                if i <= 7 and d[\"text\"].lower() == query.lower():\r",
            "                    found = True\r",
            "                    break\r",
            "            if not found:\r",
            "                languageid = get_language().lower()\r",
            "                cursor = connection.cursor()\r",
            "                cursor.execute(\r",
            "                    \"\"\"\r",
            "                        SELECT value, valueid\r",
            "                        FROM\r",
            "                        (\r",
            "                            SELECT *, CASE WHEN LOWER(languageid) = %(languageid)s THEN 10\r",
            "                            WHEN LOWER(languageid) like %(short_languageid)s THEN 5\r",
            "                            ELSE 0\r",
            "                            END score\r",
            "                            FROM values\r",
            "                        ) as vals\r",
            "                        WHERE LOWER(value)=%(query)s AND score > 0\r",
            "                        AND valuetype in ('prefLabel')\r",
            "                        ORDER BY score desc limit 1\r",
            "                    \"\"\",\r",
            "                    {\"languageid\": languageid, \"short_languageid\": languageid.split(\"-\")[0] + \"%\", \"query\": query.lower()},\r",
            "                )\r",
            "                rows = cursor.fetchall()\r",
            "\r",
            "                if len(rows) == 1:\r",
            "                    data.insert(0, {\"id\": str(rows[0][1]), \"text\": rows[0][0], \"depth\": 1, \"collector\": False})\r",
            "    except:\r",
            "        pass\r",
            "\r",
            "    return JSONResponse({\"results\": data, \"more\": offset + limit < total_count})\r",
            "\r",
            "\r",
            "def get_pref_label(request):\r",
            "    valueid = request.GET.get(\"valueid\")\r",
            "    label = get_preflabel_from_valueid(valueid, request.LANGUAGE_CODE)\r",
            "    return JSONResponse(label)\r",
            "\r",
            "\r",
            "def search(request):\r",
            "    searchString = request.GET[\"q\"]\r",
            "    removechildren = request.GET.get(\"removechildren\", None)\r",
            "    query = Query(se, start=0, limit=100)\r",
            "    phrase = Match(field=\"value\", query=searchString.lower(), type=\"phrase_prefix\")\r",
            "    query.add_query(phrase)\r",
            "    results = query.search(index=CONCEPTS_INDEX)\r",
            "\r",
            "    ids = []\r",
            "    if removechildren is not None:\r",
            "        ids = [concept[0] for concept in Concept().get_child_concepts(removechildren, columns=\"conceptidto::text\")]\r",
            "        ids.append(removechildren)\r",
            "\r",
            "    newresults = []\r",
            "    cached_scheme_names = {}\r",
            "    for result in results[\"hits\"][\"hits\"]:\r",
            "        if result[\"_source\"][\"conceptid\"] not in ids:\r",
            "            # first look to see if we've already retrieved the top concept name\r",
            "            # else look up the top concept name with ES and cache the result\r",
            "            top_concept = result[\"_source\"][\"top_concept\"]\r",
            "            if top_concept in cached_scheme_names:\r",
            "                result[\"in_scheme_name\"] = cached_scheme_names[top_concept]\r",
            "            else:\r",
            "                query = Query(se, start=0, limit=100)\r",
            "                phrase = Match(field=\"conceptid\", query=top_concept, type=\"phrase\")\r",
            "                query.add_query(phrase)\r",
            "                scheme = query.search(index=CONCEPTS_INDEX)\r",
            "                for label in scheme[\"hits\"][\"hits\"]:\r",
            "                    if label[\"_source\"][\"type\"] == \"prefLabel\":\r",
            "                        cached_scheme_names[top_concept] = label[\"_source\"][\"value\"]\r",
            "                        result[\"in_scheme_name\"] = label[\"_source\"][\"value\"]\r",
            "\r",
            "            newresults.append(result)\r",
            "\r",
            "    # Use the db to get the concept context but this is SLOW\r",
            "    # for result in results['hits']['hits']:\r",
            "    #     if result['_source']['conceptid'] not in ids:\r",
            "    #         concept = Concept().get(id=result['_source']['conceptid'], include_parentconcepts=True)\r",
            "    #         pathlist = concept.get_paths()\r",
            "    #         result['in_scheme_name'] = pathlist[0][0]['label']\r",
            "    #         newresults.append(result)\r",
            "\r",
            "    # def crawl(conceptid, path=[]):\r",
            "    #     query = Query(se, start=0, limit=100)\r",
            "    #     bool = Bool()\r",
            "    #     bool.must(Match(field='conceptto', query=conceptid, type='phrase'))\r",
            "    #     bool.must(Match(field='relationtype', query='narrower', type='phrase'))\r",
            "    #     query.add_query(bool)\r",
            "    #     relations = query.search(index='concept_relations')\r",
            "    #     for relation in relations['hits']['hits']:\r",
            "    #         path.insert(0, relation)\r",
            "    #         crawl(relation['_source']['conceptfrom'], path=path)\r",
            "    #     return path\r",
            "\r",
            "    # for result in results['hits']['hits']:\r",
            "    #     if result['_source']['conceptid'] not in ids:\r",
            "    #         concept_relations = crawl(result['_source']['conceptid'], path=[])\r",
            "    #         if len(concept_relations) > 0:\r",
            "    #             conceptid = concept_relations[0]['_source']['conceptfrom']\r",
            "    #             if conceptid in cached_scheme_names:\r",
            "    #                 result['in_scheme_name'] = cached_scheme_names[conceptid]\r",
            "    #             else:\r",
            "    #                 result['in_scheme_name'] = get_preflabel_from_conceptid(conceptid, lang=request.LANGUAGE_CODE)['value']\r",
            "    #                 cached_scheme_names[conceptid] = result['in_scheme_name']\r",
            "\r",
            "    #         newresults.append(result)\r",
            "\r",
            "    results[\"hits\"][\"hits\"] = newresults\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def add_concepts_from_sparql_endpoint(request, conceptid):\r",
            "    if request.method == \"POST\":\r",
            "        json = request.body\r",
            "        if json is not None:\r",
            "            data = JSONDeserializer().deserialize(json)\r",
            "\r",
            "            parentconcept = Concept({\"id\": conceptid, \"nodetype\": data[\"model\"][\"nodetype\"]})\r",
            "\r",
            "            if parentconcept.nodetype == \"Concept\":\r",
            "                relationshiptype = \"narrower\"\r",
            "            elif parentconcept.nodetype == \"ConceptScheme\":\r",
            "                relationshiptype = \"hasTopConcept\"\r",
            "\r",
            "            provider = get_sparql_providers(data[\"endpoint\"])\r",
            "            try:\r",
            "                parentconcept.subconcepts = provider.get_concepts(data[\"ids\"])\r",
            "            except Exception as e:\r",
            "                return HttpResponseServerError(e.message)\r",
            "\r",
            "            for subconcept in parentconcept.subconcepts:\r",
            "                subconcept.relationshiptype = relationshiptype\r",
            "\r",
            "            parentconcept.save()\r",
            "            parentconcept.index()\r",
            "\r",
            "            return JSONResponse(parentconcept, indent=4)\r",
            "\r",
            "    else:\r",
            "        return HttpResponseNotAllowed([\"POST\"])\r",
            "\r",
            "    return HttpResponseNotFound()\r",
            "\r",
            "\r",
            "def search_sparql_endpoint_for_concepts(request):\r",
            "    provider = get_sparql_providers(request.GET.get(\"endpoint\"))\r",
            "    results = provider.search_for_concepts(request.GET.get(\"terms\"))\r",
            "    return JSONResponse(results)\r",
            "\r",
            "\r",
            "def concept_tree(request, mode):\r",
            "    lang = request.GET.get(\"lang\", request.LANGUAGE_CODE)\r",
            "    conceptid = request.GET.get(\"node\", None)\r",
            "    concepts = Concept({\"id\": conceptid}).concept_tree(lang=lang, mode=mode)\r",
            "    return JSONResponse(concepts, indent=4)\r",
            "\r",
            "\r",
            "def concept_value(request):\r",
            "    if request.method == \"DELETE\":\r",
            "        data = JSONDeserializer().deserialize(request.body)\r",
            "\r",
            "        if data:\r",
            "            with transaction.atomic():\r",
            "                value = ConceptValue(data)\r",
            "                value.delete_index()\r",
            "                value.delete()\r",
            "                return JSONResponse(value)\r",
            "    if request.method == \"GET\":\r",
            "        valueid = request.GET.get(\"valueid\")\r",
            "        value = models.Value.objects.get(pk=valueid)\r",
            "        return JSONResponse(value)\r",
            "\r",
            "    return HttpResponseNotFound\r"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "383": [
                "paged_dropdown"
            ],
            "384": [
                "paged_dropdown"
            ],
            "408": [
                "paged_dropdown"
            ],
            "409": [
                "paged_dropdown"
            ],
            "410": [
                "paged_dropdown"
            ],
            "411": [
                "paged_dropdown"
            ],
            "412": [
                "paged_dropdown"
            ],
            "413": [
                "paged_dropdown"
            ],
            "414": [
                "paged_dropdown"
            ],
            "415": [
                "paged_dropdown"
            ],
            "416": [
                "paged_dropdown"
            ],
            "417": [
                "paged_dropdown"
            ],
            "418": [
                "paged_dropdown"
            ],
            "419": [
                "paged_dropdown"
            ],
            "420": [
                "paged_dropdown"
            ],
            "421": [
                "paged_dropdown"
            ],
            "422": [
                "paged_dropdown"
            ],
            "424": [
                "paged_dropdown"
            ],
            "426": [
                "paged_dropdown"
            ]
        },
        "addLocation": []
    }
}