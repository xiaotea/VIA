{
    "IPython/html/base/zmqhandlers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " # Imports"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " #-----------------------------------------------------------------------------"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+try:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    from urllib.parse import urlparse"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+except ImportError:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    from urlparse import urlparse"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " try:"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     from http.cookies import SimpleCookie  # Py 3"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " except ImportError:"
            },
            "11": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " #-----------------------------------------------------------------------------"
            },
            "12": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " class ZMQStreamHandler(websocket.WebSocketHandler):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    def check_origin(self):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        \"\"\"Check origin from headers.\"\"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        origin_header = self.request.headers[\"Origin\"]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        host = self.request.headers[\"Host\"]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        parsed_origin = urlparse(origin_header)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        origin = parsed_origin.netloc"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        # Check to see that origin matches host directly, including ports"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        if origin != host:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            self.log.critical(\"Cross Origin WebSocket Attempt.\", exc_info=True)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            raise web.HTTPError(404)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    def _execute(self, transforms, *args, **kwargs):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        \"\"\"Wrap all calls to make sure origin gets checked.\"\"\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        # Check to see that origin matches host directly, including ports"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        self.check_origin()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # Pass on the rest of the handling by the WebSocketHandler"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        super(ZMQStreamHandler, self)._execute(transforms, *args, **kwargs)"
            },
            "37": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     "
            },
            "38": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def clear_cookie(self, *args, **kwargs):"
            },
            "39": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         \"\"\"meaningless for websockets\"\"\""
            }
        },
        "frontPatchFile": [
            "\"\"\"Tornado handlers for WebSocket <-> ZMQ sockets.",
            "",
            "Authors:",
            "",
            "* Brian Granger",
            "\"\"\"",
            "",
            "#-----------------------------------------------------------------------------",
            "#  Copyright (C) 2008-2011  The IPython Development Team",
            "#",
            "#  Distributed under the terms of the BSD License.  The full license is in",
            "#  the file COPYING, distributed as part of this software.",
            "#-----------------------------------------------------------------------------",
            "",
            "#-----------------------------------------------------------------------------",
            "# Imports",
            "#-----------------------------------------------------------------------------",
            "",
            "try:",
            "    from http.cookies import SimpleCookie  # Py 3",
            "except ImportError:",
            "    from Cookie import SimpleCookie  # Py 2",
            "import logging",
            "from tornado import web",
            "from tornado import websocket",
            "",
            "from zmq.utils import jsonapi",
            "",
            "from IPython.kernel.zmq.session import Session",
            "from IPython.utils.jsonutil import date_default",
            "from IPython.utils.py3compat import PY3, cast_unicode",
            "",
            "from .handlers import IPythonHandler",
            "",
            "#-----------------------------------------------------------------------------",
            "# ZMQ handlers",
            "#-----------------------------------------------------------------------------",
            "",
            "class ZMQStreamHandler(websocket.WebSocketHandler):",
            "    ",
            "    def clear_cookie(self, *args, **kwargs):",
            "        \"\"\"meaningless for websockets\"\"\"",
            "        pass",
            "",
            "    def _reserialize_reply(self, msg_list):",
            "        \"\"\"Reserialize a reply message using JSON.",
            "",
            "        This takes the msg list from the ZMQ socket, unserializes it using",
            "        self.session and then serializes the result using JSON. This method",
            "        should be used by self._on_zmq_reply to build messages that can",
            "        be sent back to the browser.",
            "        \"\"\"",
            "        idents, msg_list = self.session.feed_identities(msg_list)",
            "        msg = self.session.unserialize(msg_list)",
            "        try:",
            "            msg['header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        try:",
            "            msg['parent_header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        msg.pop('buffers')",
            "        return jsonapi.dumps(msg, default=date_default)",
            "",
            "    def _on_zmq_reply(self, msg_list):",
            "        # Sometimes this gets triggered when the on_close method is scheduled in the",
            "        # eventloop but hasn't been called.",
            "        if self.stream.closed(): return",
            "        try:",
            "            msg = self._reserialize_reply(msg_list)",
            "        except Exception:",
            "            self.log.critical(\"Malformed message: %r\" % msg_list, exc_info=True)",
            "        else:",
            "            self.write_message(msg)",
            "",
            "    def allow_draft76(self):",
            "        \"\"\"Allow draft 76, until browsers such as Safari update to RFC 6455.",
            "        ",
            "        This has been disabled by default in tornado in release 2.2.0, and",
            "        support will be removed in later versions.",
            "        \"\"\"",
            "        return True",
            "",
            "",
            "class AuthenticatedZMQStreamHandler(ZMQStreamHandler, IPythonHandler):",
            "",
            "    def open(self, kernel_id):",
            "        self.kernel_id = cast_unicode(kernel_id, 'ascii')",
            "        self.session = Session(config=self.config)",
            "        self.save_on_message = self.on_message",
            "        self.on_message = self.on_first_message",
            "",
            "    def _inject_cookie_message(self, msg):",
            "        \"\"\"Inject the first message, which is the document cookie,",
            "        for authentication.\"\"\"",
            "        if not PY3 and isinstance(msg, unicode):",
            "            # Cookie constructor doesn't accept unicode strings",
            "            # under Python 2.x for some reason",
            "            msg = msg.encode('utf8', 'replace')",
            "        try:",
            "            identity, msg = msg.split(':', 1)",
            "            self.session.session = cast_unicode(identity, 'ascii')",
            "        except Exception:",
            "            logging.error(\"First ws message didn't have the form 'identity:[cookie]' - %r\", msg)",
            "        ",
            "        try:",
            "            self.request._cookies = SimpleCookie(msg)",
            "        except:",
            "            self.log.warn(\"couldn't parse cookie string: %s\",msg, exc_info=True)",
            "",
            "    def on_first_message(self, msg):",
            "        self._inject_cookie_message(msg)",
            "        if self.get_current_user() is None:",
            "            self.log.warn(\"Couldn't authenticate WebSocket connection\")",
            "            raise web.HTTPError(403)",
            "        self.on_message = self.save_on_message"
        ],
        "afterPatchFile": [
            "\"\"\"Tornado handlers for WebSocket <-> ZMQ sockets.",
            "",
            "Authors:",
            "",
            "* Brian Granger",
            "\"\"\"",
            "",
            "#-----------------------------------------------------------------------------",
            "#  Copyright (C) 2008-2011  The IPython Development Team",
            "#",
            "#  Distributed under the terms of the BSD License.  The full license is in",
            "#  the file COPYING, distributed as part of this software.",
            "#-----------------------------------------------------------------------------",
            "",
            "#-----------------------------------------------------------------------------",
            "# Imports",
            "#-----------------------------------------------------------------------------",
            "",
            "try:",
            "    from urllib.parse import urlparse",
            "except ImportError:",
            "    from urlparse import urlparse",
            "",
            "try:",
            "    from http.cookies import SimpleCookie  # Py 3",
            "except ImportError:",
            "    from Cookie import SimpleCookie  # Py 2",
            "import logging",
            "from tornado import web",
            "from tornado import websocket",
            "",
            "from zmq.utils import jsonapi",
            "",
            "from IPython.kernel.zmq.session import Session",
            "from IPython.utils.jsonutil import date_default",
            "from IPython.utils.py3compat import PY3, cast_unicode",
            "",
            "from .handlers import IPythonHandler",
            "",
            "#-----------------------------------------------------------------------------",
            "# ZMQ handlers",
            "#-----------------------------------------------------------------------------",
            "",
            "class ZMQStreamHandler(websocket.WebSocketHandler):",
            "",
            "    def check_origin(self):",
            "        \"\"\"Check origin from headers.\"\"\"",
            "        origin_header = self.request.headers[\"Origin\"]",
            "        host = self.request.headers[\"Host\"]",
            "",
            "        parsed_origin = urlparse(origin_header)",
            "        origin = parsed_origin.netloc",
            "",
            "        # Check to see that origin matches host directly, including ports",
            "        if origin != host:",
            "            self.log.critical(\"Cross Origin WebSocket Attempt.\", exc_info=True)",
            "            raise web.HTTPError(404)",
            "",
            "",
            "    def _execute(self, transforms, *args, **kwargs):",
            "        \"\"\"Wrap all calls to make sure origin gets checked.\"\"\"",
            "",
            "        # Check to see that origin matches host directly, including ports",
            "        self.check_origin()",
            "",
            "        # Pass on the rest of the handling by the WebSocketHandler",
            "        super(ZMQStreamHandler, self)._execute(transforms, *args, **kwargs)",
            "    ",
            "    def clear_cookie(self, *args, **kwargs):",
            "        \"\"\"meaningless for websockets\"\"\"",
            "        pass",
            "",
            "    def _reserialize_reply(self, msg_list):",
            "        \"\"\"Reserialize a reply message using JSON.",
            "",
            "        This takes the msg list from the ZMQ socket, unserializes it using",
            "        self.session and then serializes the result using JSON. This method",
            "        should be used by self._on_zmq_reply to build messages that can",
            "        be sent back to the browser.",
            "        \"\"\"",
            "        idents, msg_list = self.session.feed_identities(msg_list)",
            "        msg = self.session.unserialize(msg_list)",
            "        try:",
            "            msg['header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        try:",
            "            msg['parent_header'].pop('date')",
            "        except KeyError:",
            "            pass",
            "        msg.pop('buffers')",
            "        return jsonapi.dumps(msg, default=date_default)",
            "",
            "    def _on_zmq_reply(self, msg_list):",
            "        # Sometimes this gets triggered when the on_close method is scheduled in the",
            "        # eventloop but hasn't been called.",
            "        if self.stream.closed(): return",
            "        try:",
            "            msg = self._reserialize_reply(msg_list)",
            "        except Exception:",
            "            self.log.critical(\"Malformed message: %r\" % msg_list, exc_info=True)",
            "        else:",
            "            self.write_message(msg)",
            "",
            "    def allow_draft76(self):",
            "        \"\"\"Allow draft 76, until browsers such as Safari update to RFC 6455.",
            "        ",
            "        This has been disabled by default in tornado in release 2.2.0, and",
            "        support will be removed in later versions.",
            "        \"\"\"",
            "        return True",
            "",
            "",
            "class AuthenticatedZMQStreamHandler(ZMQStreamHandler, IPythonHandler):",
            "",
            "    def open(self, kernel_id):",
            "        self.kernel_id = cast_unicode(kernel_id, 'ascii')",
            "        self.session = Session(config=self.config)",
            "        self.save_on_message = self.on_message",
            "        self.on_message = self.on_first_message",
            "",
            "    def _inject_cookie_message(self, msg):",
            "        \"\"\"Inject the first message, which is the document cookie,",
            "        for authentication.\"\"\"",
            "        if not PY3 and isinstance(msg, unicode):",
            "            # Cookie constructor doesn't accept unicode strings",
            "            # under Python 2.x for some reason",
            "            msg = msg.encode('utf8', 'replace')",
            "        try:",
            "            identity, msg = msg.split(':', 1)",
            "            self.session.session = cast_unicode(identity, 'ascii')",
            "        except Exception:",
            "            logging.error(\"First ws message didn't have the form 'identity:[cookie]' - %r\", msg)",
            "        ",
            "        try:",
            "            self.request._cookies = SimpleCookie(msg)",
            "        except:",
            "            self.log.warn(\"couldn't parse cookie string: %s\",msg, exc_info=True)",
            "",
            "    def on_first_message(self, msg):",
            "        self._inject_cookie_message(msg)",
            "        if self.get_current_user() is None:",
            "            self.log.warn(\"Couldn't authenticate WebSocket connection\")",
            "            raise web.HTTPError(403)",
            "        self.on_message = self.save_on_message"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "jwt.api_jwt",
            "IPython.html.base.zmqhandlers.ZMQStreamHandler.self"
        ]
    }
}