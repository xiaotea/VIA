{
    "django/contrib/auth/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.contrib.auth import authenticate, get_user_model"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django.contrib.auth.models import User"
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.contrib.auth.hashers import UNUSABLE_PASSWORD, identify_hasher"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from django.contrib.auth.hashers import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    MAXIMUM_PASSWORD_LENGTH, UNUSABLE_PASSWORD, identify_hasher,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+)"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.contrib.auth.tokens import default_token_generator"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.contrib.sites.models import get_current_site"
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             'invalid': _(\"This value may contain only letters, numbers and \""
            },
            "11": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "                          \"@/./+/-/_ characters.\")})"
            },
            "12": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     password1 = forms.CharField(label=_(\"Password\"),"
            },
            "13": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        widget=forms.PasswordInput)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        widget=forms.PasswordInput, max_length=MAXIMUM_PASSWORD_LENGTH)"
            },
            "15": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     password2 = forms.CharField(label=_(\"Password confirmation\"),"
            },
            "16": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         widget=forms.PasswordInput,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "18": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         help_text=_(\"Enter the same password as above, for verification.\"))"
            },
            "19": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     class Meta:"
            },
            "21": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     username/password logins."
            },
            "22": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     username = forms.CharField(max_length=254)"
            },
            "24": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password = forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    password = forms.CharField("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        label=_(\"Password\"),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    )"
            },
            "30": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     error_messages = {"
            },
            "32": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         'invalid_login': _(\"Please enter a correct %(username)s and password. \""
            },
            "33": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     error_messages = {"
            },
            "34": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         'password_mismatch': _(\"The two password fields didn't match.\"),"
            },
            "35": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "     }"
            },
            "36": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    new_password1 = forms.CharField(label=_(\"New password\"),"
            },
            "37": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    widget=forms.PasswordInput)"
            },
            "38": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    new_password2 = forms.CharField(label=_(\"New password confirmation\"),"
            },
            "39": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    widget=forms.PasswordInput)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+    new_password1 = forms.CharField("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        label=_(\"New password\"),"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+    )"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    new_password2 = forms.CharField("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        label=_(\"New password confirmation\"),"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+    )"
            },
            "50": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     def __init__(self, user, *args, **kwargs):"
            },
            "52": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         self.user = user"
            },
            "53": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "         'password_incorrect': _(\"Your old password was entered incorrectly. \""
            },
            "54": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "                                 \"Please enter it again.\"),"
            },
            "55": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "     })"
            },
            "56": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    old_password = forms.CharField(label=_(\"Old password\"),"
            },
            "57": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   widget=forms.PasswordInput)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+    old_password = forms.CharField("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        label=_(\"Old password\"),"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+    )"
            },
            "63": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "     def clean_old_password(self):"
            },
            "65": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "         \"\"\""
            },
            "66": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "     error_messages = {"
            },
            "67": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "         'password_mismatch': _(\"The two password fields didn't match.\"),"
            },
            "68": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "     }"
            },
            "69": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password1 = forms.CharField(label=_(\"Password\"),"
            },
            "70": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                widget=forms.PasswordInput)"
            },
            "71": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    password2 = forms.CharField(label=_(\"Password (again)\"),"
            },
            "72": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                widget=forms.PasswordInput)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+    password1 = forms.CharField("
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        label=_(\"Password\"),"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    )"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    password2 = forms.CharField("
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        label=_(\"Password (again)\"),"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        widget=forms.PasswordInput,"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        max_length=MAXIMUM_PASSWORD_LENGTH,"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    )"
            },
            "83": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 358,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "     def __init__(self, user, *args, **kwargs):"
            },
            "85": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         self.user = user"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "from django import forms",
            "from django.forms.util import flatatt",
            "from django.template import loader",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.html import format_html, format_html_join",
            "from django.utils.http import int_to_base36",
            "from django.utils.safestring import mark_safe",
            "from django.utils.text import capfirst",
            "from django.utils.translation import ugettext, ugettext_lazy as _",
            "",
            "from django.contrib.auth import authenticate, get_user_model",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.hashers import UNUSABLE_PASSWORD, identify_hasher",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "",
            "UNMASKED_DIGITS_TO_SHOW = 6",
            "",
            "mask_password = lambda p: \"%s%s\" % (p[:UNMASKED_DIGITS_TO_SHOW], \"*\" * max(len(p) - UNMASKED_DIGITS_TO_SHOW, 0))",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    def render(self, name, value, attrs):",
            "        encoded = value",
            "        final_attrs = self.build_attrs(attrs)",
            "",
            "        if not encoded or encoded == UNUSABLE_PASSWORD:",
            "            summary = mark_safe(\"<strong>%s</strong>\" % ugettext(\"No password set.\"))",
            "        else:",
            "            try:",
            "                hasher = identify_hasher(encoded)",
            "            except ValueError:",
            "                summary = mark_safe(\"<strong>%s</strong>\" % ugettext(",
            "                    \"Invalid password format or unknown hashing algorithm.\"))",
            "            else:",
            "                summary = format_html_join('',",
            "                                           \"<strong>{0}</strong>: {1} \",",
            "                                           ((ugettext(key), value)",
            "                                            for key, value in hasher.safe_summary(encoded).items())",
            "                                           )",
            "",
            "        return format_html(\"<div{0}>{1}</div>\", flatatt(final_attrs), summary)",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super(ReadOnlyPasswordHashField, self).__init__(*args, **kwargs)",
            "",
            "    def bound_data(self, data, initial):",
            "        # Always return initial because the widget doesn't",
            "        # render an input field.",
            "        return initial",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'duplicate_username': _(\"A user with that username already exists.\"),",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    username = forms.RegexField(label=_(\"Username\"), max_length=30,",
            "        regex=r'^[\\w.@+-]+$',",
            "        help_text=_(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages={",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "        widget=forms.PasswordInput)",
            "    password2 = forms.CharField(label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        help_text=_(\"Enter the same password as above, for verification.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_username(self):",
            "        # Since User.username is unique, this check is redundant,",
            "        # but it sets a nicer error message than the ORM. See #13147.",
            "        username = self.cleaned_data[\"username\"]",
            "        try:",
            "            User._default_manager.get(username=username)",
            "        except User.DoesNotExist:",
            "            return username",
            "        raise forms.ValidationError(self.error_messages['duplicate_username'])",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\")",
            "        password2 = self.cleaned_data.get(\"password2\")",
            "        if password1 and password2 and password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        user = super(UserCreationForm, self).save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    username = forms.RegexField(",
            "        label=_(\"Username\"), max_length=30, regex=r\"^[\\w.@+-]+$\",",
            "        help_text=_(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages={",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password = ReadOnlyPasswordHashField(label=_(\"Password\"),",
            "        help_text=_(\"Raw passwords are not stored, so there is no way to see \"",
            "                    \"this user's password, but you can change the password \"",
            "                    \"using <a href=\\\"password/\\\">this form</a>.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(UserChangeForm, self).__init__(*args, **kwargs)",
            "        f = self.fields.get('user_permissions', None)",
            "        if f is not None:",
            "            f.queryset = f.queryset.select_related('content_type')",
            "",
            "    def clean_password(self):",
            "        # Regardless of what the user provides, return the initial value.",
            "        # This is done here, rather than on the field, because the",
            "        # field does not have access to the initial value",
            "        return self.initial[\"password\"]",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = forms.CharField(max_length=254)",
            "    password = forms.CharField(label=_(\"Password\"), widget=forms.PasswordInput)",
            "",
            "    error_messages = {",
            "        'invalid_login': _(\"Please enter a correct %(username)s and password. \"",
            "                           \"Note that both fields may be case-sensitive.\"),",
            "        'no_cookies': _(\"Your Web browser doesn't appear to have cookies \"",
            "                        \"enabled. Cookies are required for logging in.\"),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        If request is passed in, the form will validate that cookies are",
            "        enabled. Note that the request (a HttpRequest object) must have set a",
            "        cookie with the key TEST_COOKIE_NAME and value TEST_COOKIE_VALUE before",
            "        running this validation.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super(AuthenticationForm, self).__init__(*args, **kwargs)",
            "",
            "        # Set the label for the \"username\" field.",
            "        UserModel = get_user_model()",
            "        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)",
            "        if not self.fields['username'].label:",
            "            self.fields['username'].label = capfirst(self.username_field.verbose_name)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username and password:",
            "            self.user_cache = authenticate(username=username,",
            "                                           password=password)",
            "            if self.user_cache is None:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['invalid_login'] % {",
            "                        'username': self.username_field.verbose_name",
            "                    })",
            "            elif not self.user_cache.is_active:",
            "                raise forms.ValidationError(self.error_messages['inactive'])",
            "        self.check_for_test_cookie()",
            "        return self.cleaned_data",
            "",
            "    def check_for_test_cookie(self):",
            "        if self.request and not self.request.session.test_cookie_worked():",
            "            raise forms.ValidationError(self.error_messages['no_cookies'])",
            "",
            "    def get_user_id(self):",
            "        if self.user_cache:",
            "            return self.user_cache.id",
            "        return None",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    error_messages = {",
            "        'unknown': _(\"That email address doesn't have an associated \"",
            "                     \"user account. Are you sure you've registered?\"),",
            "        'unusable': _(\"The user account associated with this email \"",
            "                      \"address cannot reset the password.\"),",
            "    }",
            "    email = forms.EmailField(label=_(\"Email\"), max_length=254)",
            "",
            "    def clean_email(self):",
            "        \"\"\"",
            "        Validates that an active user exists with the given email address.",
            "        \"\"\"",
            "        UserModel = get_user_model()",
            "        email = self.cleaned_data[\"email\"]",
            "        self.users_cache = UserModel._default_manager.filter(email__iexact=email)",
            "        if not len(self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if not any(user.is_active for user in self.users_cache):",
            "            # none of the filtered users are active",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if any((user.password == UNUSABLE_PASSWORD)",
            "               for user in self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unusable'])",
            "        return email",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None):",
            "        \"\"\"",
            "        Generates a one-use only link for resetting password and sends to the",
            "        user.",
            "        \"\"\"",
            "        from django.core.mail import send_mail",
            "        for user in self.users_cache:",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            c = {",
            "                'email': user.email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': int_to_base36(user.pk),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': use_https and 'https' or 'http',",
            "            }",
            "            subject = loader.render_to_string(subject_template_name, c)",
            "            # Email subject *must not* contain newlines",
            "            subject = ''.join(subject.splitlines())",
            "            email = loader.render_to_string(email_template_name, c)",
            "            send_mail(subject, email, from_email, [user.email])",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set his/her password without entering the",
            "    old password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(label=_(\"New password\"),",
            "                                    widget=forms.PasswordInput)",
            "    new_password2 = forms.CharField(label=_(\"New password confirmation\"),",
            "                                    widget=forms.PasswordInput)",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(SetPasswordForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        self.user.set_password(self.cleaned_data['new_password1'])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change his/her password by entering",
            "    their old password.",
            "    \"\"\"",
            "    error_messages = dict(SetPasswordForm.error_messages, **{",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. \"",
            "                                \"Please enter it again.\"),",
            "    })",
            "    old_password = forms.CharField(label=_(\"Old password\"),",
            "                                   widget=forms.PasswordInput)",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validates that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'])",
            "        return old_password",
            "",
            "PasswordChangeForm.base_fields = SortedDict([",
            "    (k, PasswordChangeForm.base_fields[k])",
            "    for k in ['old_password', 'new_password1', 'new_password2']",
            "])",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "                                widget=forms.PasswordInput)",
            "    password2 = forms.CharField(label=_(\"Password (again)\"),",
            "                                widget=forms.PasswordInput)",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(AdminPasswordChangeForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"",
            "        Saves the new password.",
            "        \"\"\"",
            "        self.user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "from django import forms",
            "from django.forms.util import flatatt",
            "from django.template import loader",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.html import format_html, format_html_join",
            "from django.utils.http import int_to_base36",
            "from django.utils.safestring import mark_safe",
            "from django.utils.text import capfirst",
            "from django.utils.translation import ugettext, ugettext_lazy as _",
            "",
            "from django.contrib.auth import authenticate, get_user_model",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.hashers import (",
            "    MAXIMUM_PASSWORD_LENGTH, UNUSABLE_PASSWORD, identify_hasher,",
            ")",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import get_current_site",
            "",
            "",
            "UNMASKED_DIGITS_TO_SHOW = 6",
            "",
            "mask_password = lambda p: \"%s%s\" % (p[:UNMASKED_DIGITS_TO_SHOW], \"*\" * max(len(p) - UNMASKED_DIGITS_TO_SHOW, 0))",
            "",
            "",
            "class ReadOnlyPasswordHashWidget(forms.Widget):",
            "    def render(self, name, value, attrs):",
            "        encoded = value",
            "        final_attrs = self.build_attrs(attrs)",
            "",
            "        if not encoded or encoded == UNUSABLE_PASSWORD:",
            "            summary = mark_safe(\"<strong>%s</strong>\" % ugettext(\"No password set.\"))",
            "        else:",
            "            try:",
            "                hasher = identify_hasher(encoded)",
            "            except ValueError:",
            "                summary = mark_safe(\"<strong>%s</strong>\" % ugettext(",
            "                    \"Invalid password format or unknown hashing algorithm.\"))",
            "            else:",
            "                summary = format_html_join('',",
            "                                           \"<strong>{0}</strong>: {1} \",",
            "                                           ((ugettext(key), value)",
            "                                            for key, value in hasher.safe_summary(encoded).items())",
            "                                           )",
            "",
            "        return format_html(\"<div{0}>{1}</div>\", flatatt(final_attrs), summary)",
            "",
            "",
            "class ReadOnlyPasswordHashField(forms.Field):",
            "    widget = ReadOnlyPasswordHashWidget",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault(\"required\", False)",
            "        super(ReadOnlyPasswordHashField, self).__init__(*args, **kwargs)",
            "",
            "    def bound_data(self, data, initial):",
            "        # Always return initial because the widget doesn't",
            "        # render an input field.",
            "        return initial",
            "",
            "",
            "class UserCreationForm(forms.ModelForm):",
            "    \"\"\"",
            "    A form that creates a user, with no privileges, from the given username and",
            "    password.",
            "    \"\"\"",
            "    error_messages = {",
            "        'duplicate_username': _(\"A user with that username already exists.\"),",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    username = forms.RegexField(label=_(\"Username\"), max_length=30,",
            "        regex=r'^[\\w.@+-]+$',",
            "        help_text=_(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages={",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password1 = forms.CharField(label=_(\"Password\"),",
            "        widget=forms.PasswordInput, max_length=MAXIMUM_PASSWORD_LENGTH)",
            "    password2 = forms.CharField(label=_(\"Password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "        help_text=_(\"Enter the same password as above, for verification.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_username(self):",
            "        # Since User.username is unique, this check is redundant,",
            "        # but it sets a nicer error message than the ORM. See #13147.",
            "        username = self.cleaned_data[\"username\"]",
            "        try:",
            "            User._default_manager.get(username=username)",
            "        except User.DoesNotExist:",
            "            return username",
            "        raise forms.ValidationError(self.error_messages['duplicate_username'])",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get(\"password1\")",
            "        password2 = self.cleaned_data.get(\"password2\")",
            "        if password1 and password2 and password1 != password2:",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        user = super(UserCreationForm, self).save(commit=False)",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            user.save()",
            "        return user",
            "",
            "",
            "class UserChangeForm(forms.ModelForm):",
            "    username = forms.RegexField(",
            "        label=_(\"Username\"), max_length=30, regex=r\"^[\\w.@+-]+$\",",
            "        help_text=_(\"Required. 30 characters or fewer. Letters, digits and \"",
            "                      \"@/./+/-/_ only.\"),",
            "        error_messages={",
            "            'invalid': _(\"This value may contain only letters, numbers and \"",
            "                         \"@/./+/-/_ characters.\")})",
            "    password = ReadOnlyPasswordHashField(label=_(\"Password\"),",
            "        help_text=_(\"Raw passwords are not stored, so there is no way to see \"",
            "                    \"this user's password, but you can change the password \"",
            "                    \"using <a href=\\\"password/\\\">this form</a>.\"))",
            "",
            "    class Meta:",
            "        model = User",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(UserChangeForm, self).__init__(*args, **kwargs)",
            "        f = self.fields.get('user_permissions', None)",
            "        if f is not None:",
            "            f.queryset = f.queryset.select_related('content_type')",
            "",
            "    def clean_password(self):",
            "        # Regardless of what the user provides, return the initial value.",
            "        # This is done here, rather than on the field, because the",
            "        # field does not have access to the initial value",
            "        return self.initial[\"password\"]",
            "",
            "",
            "class AuthenticationForm(forms.Form):",
            "    \"\"\"",
            "    Base class for authenticating users. Extend this to get a form that accepts",
            "    username/password logins.",
            "    \"\"\"",
            "    username = forms.CharField(max_length=254)",
            "    password = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    error_messages = {",
            "        'invalid_login': _(\"Please enter a correct %(username)s and password. \"",
            "                           \"Note that both fields may be case-sensitive.\"),",
            "        'no_cookies': _(\"Your Web browser doesn't appear to have cookies \"",
            "                        \"enabled. Cookies are required for logging in.\"),",
            "        'inactive': _(\"This account is inactive.\"),",
            "    }",
            "",
            "    def __init__(self, request=None, *args, **kwargs):",
            "        \"\"\"",
            "        If request is passed in, the form will validate that cookies are",
            "        enabled. Note that the request (a HttpRequest object) must have set a",
            "        cookie with the key TEST_COOKIE_NAME and value TEST_COOKIE_VALUE before",
            "        running this validation.",
            "        \"\"\"",
            "        self.request = request",
            "        self.user_cache = None",
            "        super(AuthenticationForm, self).__init__(*args, **kwargs)",
            "",
            "        # Set the label for the \"username\" field.",
            "        UserModel = get_user_model()",
            "        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)",
            "        if not self.fields['username'].label:",
            "            self.fields['username'].label = capfirst(self.username_field.verbose_name)",
            "",
            "    def clean(self):",
            "        username = self.cleaned_data.get('username')",
            "        password = self.cleaned_data.get('password')",
            "",
            "        if username and password:",
            "            self.user_cache = authenticate(username=username,",
            "                                           password=password)",
            "            if self.user_cache is None:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['invalid_login'] % {",
            "                        'username': self.username_field.verbose_name",
            "                    })",
            "            elif not self.user_cache.is_active:",
            "                raise forms.ValidationError(self.error_messages['inactive'])",
            "        self.check_for_test_cookie()",
            "        return self.cleaned_data",
            "",
            "    def check_for_test_cookie(self):",
            "        if self.request and not self.request.session.test_cookie_worked():",
            "            raise forms.ValidationError(self.error_messages['no_cookies'])",
            "",
            "    def get_user_id(self):",
            "        if self.user_cache:",
            "            return self.user_cache.id",
            "        return None",
            "",
            "    def get_user(self):",
            "        return self.user_cache",
            "",
            "",
            "class PasswordResetForm(forms.Form):",
            "    error_messages = {",
            "        'unknown': _(\"That email address doesn't have an associated \"",
            "                     \"user account. Are you sure you've registered?\"),",
            "        'unusable': _(\"The user account associated with this email \"",
            "                      \"address cannot reset the password.\"),",
            "    }",
            "    email = forms.EmailField(label=_(\"Email\"), max_length=254)",
            "",
            "    def clean_email(self):",
            "        \"\"\"",
            "        Validates that an active user exists with the given email address.",
            "        \"\"\"",
            "        UserModel = get_user_model()",
            "        email = self.cleaned_data[\"email\"]",
            "        self.users_cache = UserModel._default_manager.filter(email__iexact=email)",
            "        if not len(self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if not any(user.is_active for user in self.users_cache):",
            "            # none of the filtered users are active",
            "            raise forms.ValidationError(self.error_messages['unknown'])",
            "        if any((user.password == UNUSABLE_PASSWORD)",
            "               for user in self.users_cache):",
            "            raise forms.ValidationError(self.error_messages['unusable'])",
            "        return email",
            "",
            "    def save(self, domain_override=None,",
            "             subject_template_name='registration/password_reset_subject.txt',",
            "             email_template_name='registration/password_reset_email.html',",
            "             use_https=False, token_generator=default_token_generator,",
            "             from_email=None, request=None):",
            "        \"\"\"",
            "        Generates a one-use only link for resetting password and sends to the",
            "        user.",
            "        \"\"\"",
            "        from django.core.mail import send_mail",
            "        for user in self.users_cache:",
            "            if not domain_override:",
            "                current_site = get_current_site(request)",
            "                site_name = current_site.name",
            "                domain = current_site.domain",
            "            else:",
            "                site_name = domain = domain_override",
            "            c = {",
            "                'email': user.email,",
            "                'domain': domain,",
            "                'site_name': site_name,",
            "                'uid': int_to_base36(user.pk),",
            "                'user': user,",
            "                'token': token_generator.make_token(user),",
            "                'protocol': use_https and 'https' or 'http',",
            "            }",
            "            subject = loader.render_to_string(subject_template_name, c)",
            "            # Email subject *must not* contain newlines",
            "            subject = ''.join(subject.splitlines())",
            "            email = loader.render_to_string(email_template_name, c)",
            "            send_mail(subject, email, from_email, [user.email])",
            "",
            "",
            "class SetPasswordForm(forms.Form):",
            "    \"\"\"",
            "    A form that lets a user change set his/her password without entering the",
            "    old password",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    new_password1 = forms.CharField(",
            "        label=_(\"New password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "    new_password2 = forms.CharField(",
            "        label=_(\"New password confirmation\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(SetPasswordForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_new_password2(self):",
            "        password1 = self.cleaned_data.get('new_password1')",
            "        password2 = self.cleaned_data.get('new_password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        self.user.set_password(self.cleaned_data['new_password1'])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user",
            "",
            "",
            "class PasswordChangeForm(SetPasswordForm):",
            "    \"\"\"",
            "    A form that lets a user change his/her password by entering",
            "    their old password.",
            "    \"\"\"",
            "    error_messages = dict(SetPasswordForm.error_messages, **{",
            "        'password_incorrect': _(\"Your old password was entered incorrectly. \"",
            "                                \"Please enter it again.\"),",
            "    })",
            "    old_password = forms.CharField(",
            "        label=_(\"Old password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def clean_old_password(self):",
            "        \"\"\"",
            "        Validates that the old_password field is correct.",
            "        \"\"\"",
            "        old_password = self.cleaned_data[\"old_password\"]",
            "        if not self.user.check_password(old_password):",
            "            raise forms.ValidationError(",
            "                self.error_messages['password_incorrect'])",
            "        return old_password",
            "",
            "PasswordChangeForm.base_fields = SortedDict([",
            "    (k, PasswordChangeForm.base_fields[k])",
            "    for k in ['old_password', 'new_password1', 'new_password2']",
            "])",
            "",
            "",
            "class AdminPasswordChangeForm(forms.Form):",
            "    \"\"\"",
            "    A form used to change the password of a user in the admin interface.",
            "    \"\"\"",
            "    error_messages = {",
            "        'password_mismatch': _(\"The two password fields didn't match.\"),",
            "    }",
            "    password1 = forms.CharField(",
            "        label=_(\"Password\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "    password2 = forms.CharField(",
            "        label=_(\"Password (again)\"),",
            "        widget=forms.PasswordInput,",
            "        max_length=MAXIMUM_PASSWORD_LENGTH,",
            "    )",
            "",
            "    def __init__(self, user, *args, **kwargs):",
            "        self.user = user",
            "        super(AdminPasswordChangeForm, self).__init__(*args, **kwargs)",
            "",
            "    def clean_password2(self):",
            "        password1 = self.cleaned_data.get('password1')",
            "        password2 = self.cleaned_data.get('password2')",
            "        if password1 and password2:",
            "            if password1 != password2:",
            "                raise forms.ValidationError(",
            "                    self.error_messages['password_mismatch'])",
            "        return password2",
            "",
            "    def save(self, commit=True):",
            "        \"\"\"",
            "        Saves the new password.",
            "        \"\"\"",
            "        self.user.set_password(self.cleaned_data[\"password1\"])",
            "        if commit:",
            "            self.user.save()",
            "        return self.user"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "78": [
                "UserCreationForm"
            ],
            "148": [
                "AuthenticationForm"
            ],
            "272": [
                "SetPasswordForm"
            ],
            "273": [
                "SetPasswordForm"
            ],
            "274": [
                "SetPasswordForm"
            ],
            "275": [
                "SetPasswordForm"
            ],
            "306": [
                "PasswordChangeForm"
            ],
            "307": [
                "PasswordChangeForm"
            ],
            "332": [
                "AdminPasswordChangeForm"
            ],
            "333": [
                "AdminPasswordChangeForm"
            ],
            "334": [
                "AdminPasswordChangeForm"
            ],
            "335": [
                "AdminPasswordChangeForm"
            ]
        },
        "addLocation": []
    },
    "django/contrib/auth/hashers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from __future__ import unicode_literals"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import base64"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import functools"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import hashlib"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.dispatch import receiver"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+MAXIMUM_PASSWORD_LENGTH = 4096  # The maximum length a password can be to prevent DoS"
            },
            "11": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " HASHERS = None  # lazily loaded from PASSWORD_HASHERS"
            },
            "12": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS"
            },
            "13": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         PREFERRED_HASHER = None"
            },
            "15": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+def password_max_length(max_length):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    def inner(fn):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        @functools.wraps(fn)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        def wrapper(self, password, *args, **kwargs):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            if len(password) > max_length:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+                raise ValueError(\"Invalid password; Must be less than or equal\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                                 \" to %d bytes\" % max_length)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            return fn(self, password, *args, **kwargs)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        return wrapper"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    return inner"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " def is_password_usable(encoded):"
            },
            "30": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     if encoded is None or encoded == UNUSABLE_PASSWORD:"
            },
            "31": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         return False"
            },
            "32": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "     iterations = 10000"
            },
            "33": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "     digest = hashlib.sha256"
            },
            "34": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 241,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "36": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "     def encode(self, password, salt, iterations=None):"
            },
            "37": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         assert password"
            },
            "38": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "39": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         hash = base64.b64encode(hash).decode('ascii').strip()"
            },
            "40": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)"
            },
            "41": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "43": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "44": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         algorithm, iterations, salt, hash = encoded.split('$', 3)"
            },
            "45": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "46": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         bcrypt = self._load_library()"
            },
            "47": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "         return bcrypt.gensalt(self.rounds)"
            },
            "48": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 297,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "50": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "51": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         bcrypt = self._load_library()"
            },
            "52": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         # Need to reevaluate the force_bytes call once bcrypt is supported on"
            },
            "53": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         # Python 3"
            },
            "54": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         data = bcrypt.hashpw(force_bytes(password), salt)"
            },
            "55": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         return \"%s$%s\" % (self.algorithm, data)"
            },
            "56": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 305,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "58": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "59": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         algorithm, data = encoded.split('$', 1)"
            },
            "60": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "61": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "     \"\"\""
            },
            "62": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     algorithm = \"sha1\""
            },
            "63": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 330,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "65": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "66": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "         assert password"
            },
            "67": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "68": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()"
            },
            "69": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, salt, hash)"
            },
            "70": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 337,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "72": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "73": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "         algorithm, salt, hash = encoded.split('$', 2)"
            },
            "74": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "75": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "     \"\"\""
            },
            "76": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "     algorithm = \"md5\""
            },
            "77": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "79": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "80": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "         assert password"
            },
            "81": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "         assert salt and '$' not in salt"
            },
            "82": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         hash = hashlib.md5(force_bytes(salt + password)).hexdigest()"
            },
            "83": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, salt, hash)"
            },
            "84": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 367,
                "PatchRowcode": " "
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "86": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "87": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "         algorithm, salt, hash = encoded.split('$', 2)"
            },
            "88": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         assert algorithm == self.algorithm"
            },
            "89": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "     def salt(self):"
            },
            "90": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         return ''"
            },
            "91": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 398,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "93": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "94": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         assert salt == ''"
            },
            "95": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         hash = hashlib.sha1(force_bytes(password)).hexdigest()"
            },
            "96": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         return 'sha1$$%s' % hash"
            },
            "97": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 404,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "99": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "100": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         encoded_2 = self.encode(password, '')"
            },
            "101": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         return constant_time_compare(encoded, encoded_2)"
            },
            "102": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "     def salt(self):"
            },
            "103": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "         return ''"
            },
            "104": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 434,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "106": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "107": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "         assert salt == ''"
            },
            "108": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         return hashlib.md5(force_bytes(password)).hexdigest()"
            },
            "109": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 439,
                "PatchRowcode": " "
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "111": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "112": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "         if len(encoded) == 37 and encoded.startswith('md5$$'):"
            },
            "113": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "             encoded = encoded[5:]"
            },
            "114": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "     def salt(self):"
            },
            "115": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "         return get_random_string(2)"
            },
            "116": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 465,
                "PatchRowcode": " "
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "118": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "     def encode(self, password, salt):"
            },
            "119": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "         crypt = self._load_library()"
            },
            "120": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "         assert len(salt) == 2"
            },
            "121": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "         data = crypt.crypt(force_str(password), salt)"
            },
            "122": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "         # we don't need to store the salt, but Django used to do this"
            },
            "123": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "         return \"%s$%s$%s\" % (self.algorithm, '', data)"
            },
            "124": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 473,
                "PatchRowcode": " "
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+    @password_max_length(MAXIMUM_PASSWORD_LENGTH)"
            },
            "126": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "     def verify(self, password, encoded):"
            },
            "127": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "         crypt = self._load_library()"
            },
            "128": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 477,
                "PatchRowcode": "         algorithm, salt, data = encoded.split('$', 2)"
            },
            "129": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 486,
                "PatchRowcode": "             (_('salt'), salt),"
            },
            "130": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "             (_('hash'), mask_hash(data, show=3)),"
            },
            "131": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 488,
                "PatchRowcode": "         ])"
            },
            "132": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import hashlib",
            "",
            "from django.dispatch import receiver",
            "from django.conf import settings",
            "from django.test.signals import setting_changed",
            "from django.utils import importlib",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.encoding import force_bytes, force_str",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import (",
            "    pbkdf2, constant_time_compare, get_random_string)",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "",
            "UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash",
            "HASHERS = None  # lazily loaded from PASSWORD_HASHERS",
            "PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS",
            "",
            "@receiver(setting_changed)",
            "def reset_hashers(**kwargs):",
            "    if kwargs['setting'] == 'PASSWORD_HASHERS':",
            "        global HASHERS, PREFERRED_HASHER",
            "        HASHERS = None",
            "        PREFERRED_HASHER = None",
            "",
            "",
            "def is_password_usable(encoded):",
            "    if encoded is None or encoded == UNUSABLE_PASSWORD:",
            "        return False",
            "    try:",
            "        hasher = identify_hasher(encoded)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if not password or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    hasher = identify_hasher(encoded)",
            "",
            "    must_update = hasher.algorithm != preferred.algorithm",
            "    is_correct = hasher.verify(password, encoded)",
            "    if setter and is_correct and must_update:",
            "        setter(password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.  If",
            "    password is None or blank then UNUSABLE_PASSWORD will be",
            "    returned which disallows logins.",
            "    \"\"\"",
            "    if not password:",
            "        return UNUSABLE_PASSWORD",
            "",
            "    hasher = get_hasher(hasher)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "def load_hashers(password_hashers=None):",
            "    global HASHERS",
            "    global PREFERRED_HASHER",
            "    hashers = []",
            "    if not password_hashers:",
            "        password_hashers = settings.PASSWORD_HASHERS",
            "    for backend in password_hashers:",
            "        try:",
            "            mod_path, cls_name = backend.rsplit('.', 1)",
            "            mod = importlib.import_module(mod_path)",
            "            hasher_cls = getattr(mod, cls_name)",
            "        except (AttributeError, ImportError, ValueError):",
            "            raise ImproperlyConfigured(\"hasher not found: %s\" % backend)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % backend)",
            "        hashers.append(hasher)",
            "    HASHERS = dict([(hasher.algorithm, hasher) for hasher in hashers])",
            "    PREFERRED_HASHER = hashers[0]",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        if PREFERRED_HASHER is None:",
            "            load_hashers()",
            "        return PREFERRED_HASHER",
            "    else:",
            "        if HASHERS is None:",
            "            load_hashers()",
            "        if algorithm not in HASHERS:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "        return HASHERS[algorithm]",
            "",
            "",
            "def identify_hasher(encoded):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    Identifies hasher algorithm by examining encoded hash, and calls",
            "    get_hasher() to return hasher. Raises ValueError if",
            "    algorithm cannot be identified, or if hasher is not loaded.",
            "    \"\"\"",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        algorithm = 'unsalted_md5'",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        algorithm = 'unsalted_sha1'",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "    return get_hasher(algorithm)",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                name = mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError:",
            "                raise ValueError(\"Couldn't load %s password algorithm \"",
            "                                 \"library\" % name)",
            "            return module",
            "        raise ValueError(\"Hasher '%s' doesn't specify a library attribute\" %",
            "                         self.__class__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ascii",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 10000",
            "    digest = hashlib.sha256",
            "",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = base64.b64encode(hash).decode('ascii').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the py-bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    library = (\"py-bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        # Need to reevaluate the force_bytes call once bcrypt is supported on",
            "        # Python 3",
            "        data = bcrypt.hashpw(force_bytes(password), salt)",
            "        return \"%s$%s\" % (self.algorithm, data)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        bcrypt = self._load_library()",
            "        return constant_time_compare(data, bcrypt.hashpw(force_bytes(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(force_bytes(password)).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(force_bytes(password)).hexdigest()",
            "",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(force_str(password), salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(force_str(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import functools",
            "import hashlib",
            "",
            "from django.dispatch import receiver",
            "from django.conf import settings",
            "from django.test.signals import setting_changed",
            "from django.utils import importlib",
            "from django.utils.datastructures import SortedDict",
            "from django.utils.encoding import force_bytes, force_str",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import (",
            "    pbkdf2, constant_time_compare, get_random_string)",
            "from django.utils.translation import ugettext_noop as _",
            "",
            "",
            "UNUSABLE_PASSWORD = '!'  # This will never be a valid encoded hash",
            "MAXIMUM_PASSWORD_LENGTH = 4096  # The maximum length a password can be to prevent DoS",
            "HASHERS = None  # lazily loaded from PASSWORD_HASHERS",
            "PREFERRED_HASHER = None  # defaults to first item in PASSWORD_HASHERS",
            "",
            "@receiver(setting_changed)",
            "def reset_hashers(**kwargs):",
            "    if kwargs['setting'] == 'PASSWORD_HASHERS':",
            "        global HASHERS, PREFERRED_HASHER",
            "        HASHERS = None",
            "        PREFERRED_HASHER = None",
            "",
            "",
            "def password_max_length(max_length):",
            "    def inner(fn):",
            "        @functools.wraps(fn)",
            "        def wrapper(self, password, *args, **kwargs):",
            "            if len(password) > max_length:",
            "                raise ValueError(\"Invalid password; Must be less than or equal\"",
            "                                 \" to %d bytes\" % max_length)",
            "            return fn(self, password, *args, **kwargs)",
            "        return wrapper",
            "    return inner",
            "",
            "",
            "def is_password_usable(encoded):",
            "    if encoded is None or encoded == UNUSABLE_PASSWORD:",
            "        return False",
            "    try:",
            "        hasher = identify_hasher(encoded)",
            "    except ValueError:",
            "        return False",
            "    return True",
            "",
            "",
            "def check_password(password, encoded, setter=None, preferred='default'):",
            "    \"\"\"",
            "    Returns a boolean of whether the raw password matches the three",
            "    part encoded digest.",
            "",
            "    If setter is specified, it'll be called when you need to",
            "    regenerate the password.",
            "    \"\"\"",
            "    if not password or not is_password_usable(encoded):",
            "        return False",
            "",
            "    preferred = get_hasher(preferred)",
            "    hasher = identify_hasher(encoded)",
            "",
            "    must_update = hasher.algorithm != preferred.algorithm",
            "    is_correct = hasher.verify(password, encoded)",
            "    if setter and is_correct and must_update:",
            "        setter(password)",
            "    return is_correct",
            "",
            "",
            "def make_password(password, salt=None, hasher='default'):",
            "    \"\"\"",
            "    Turn a plain-text password into a hash for database storage",
            "",
            "    Same as encode() but generates a new random salt.  If",
            "    password is None or blank then UNUSABLE_PASSWORD will be",
            "    returned which disallows logins.",
            "    \"\"\"",
            "    if not password:",
            "        return UNUSABLE_PASSWORD",
            "",
            "    hasher = get_hasher(hasher)",
            "",
            "    if not salt:",
            "        salt = hasher.salt()",
            "",
            "    return hasher.encode(password, salt)",
            "",
            "",
            "def load_hashers(password_hashers=None):",
            "    global HASHERS",
            "    global PREFERRED_HASHER",
            "    hashers = []",
            "    if not password_hashers:",
            "        password_hashers = settings.PASSWORD_HASHERS",
            "    for backend in password_hashers:",
            "        try:",
            "            mod_path, cls_name = backend.rsplit('.', 1)",
            "            mod = importlib.import_module(mod_path)",
            "            hasher_cls = getattr(mod, cls_name)",
            "        except (AttributeError, ImportError, ValueError):",
            "            raise ImproperlyConfigured(\"hasher not found: %s\" % backend)",
            "        hasher = hasher_cls()",
            "        if not getattr(hasher, 'algorithm'):",
            "            raise ImproperlyConfigured(\"hasher doesn't specify an \"",
            "                                       \"algorithm name: %s\" % backend)",
            "        hashers.append(hasher)",
            "    HASHERS = dict([(hasher.algorithm, hasher) for hasher in hashers])",
            "    PREFERRED_HASHER = hashers[0]",
            "",
            "",
            "def get_hasher(algorithm='default'):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    If algorithm is 'default', the default hasher will be returned.",
            "    This function will also lazy import hashers specified in your",
            "    settings file if needed.",
            "    \"\"\"",
            "    if hasattr(algorithm, 'algorithm'):",
            "        return algorithm",
            "",
            "    elif algorithm == 'default':",
            "        if PREFERRED_HASHER is None:",
            "            load_hashers()",
            "        return PREFERRED_HASHER",
            "    else:",
            "        if HASHERS is None:",
            "            load_hashers()",
            "        if algorithm not in HASHERS:",
            "            raise ValueError(\"Unknown password hashing algorithm '%s'. \"",
            "                             \"Did you specify it in the PASSWORD_HASHERS \"",
            "                             \"setting?\" % algorithm)",
            "        return HASHERS[algorithm]",
            "",
            "",
            "def identify_hasher(encoded):",
            "    \"\"\"",
            "    Returns an instance of a loaded password hasher.",
            "",
            "    Identifies hasher algorithm by examining encoded hash, and calls",
            "    get_hasher() to return hasher. Raises ValueError if",
            "    algorithm cannot be identified, or if hasher is not loaded.",
            "    \"\"\"",
            "    # Ancient versions of Django created plain MD5 passwords and accepted",
            "    # MD5 passwords with an empty salt.",
            "    if ((len(encoded) == 32 and '$' not in encoded) or",
            "            (len(encoded) == 37 and encoded.startswith('md5$$'))):",
            "        algorithm = 'unsalted_md5'",
            "    # Ancient versions of Django accepted SHA1 passwords with an empty salt.",
            "    elif len(encoded) == 46 and encoded.startswith('sha1$$'):",
            "        algorithm = 'unsalted_sha1'",
            "    else:",
            "        algorithm = encoded.split('$', 1)[0]",
            "    return get_hasher(algorithm)",
            "",
            "",
            "def mask_hash(hash, show=6, char=\"*\"):",
            "    \"\"\"",
            "    Returns the given hash, with only the first ``show`` number shown. The",
            "    rest are masked with ``char`` for security reasons.",
            "    \"\"\"",
            "    masked = hash[:show]",
            "    masked += char * len(hash[show:])",
            "    return masked",
            "",
            "",
            "class BasePasswordHasher(object):",
            "    \"\"\"",
            "    Abstract base class for password hashers",
            "",
            "    When creating your own hasher, you need to override algorithm,",
            "    verify(), encode() and safe_summary().",
            "",
            "    PasswordHasher objects are immutable.",
            "    \"\"\"",
            "    algorithm = None",
            "    library = None",
            "",
            "    def _load_library(self):",
            "        if self.library is not None:",
            "            if isinstance(self.library, (tuple, list)):",
            "                name, mod_path = self.library",
            "            else:",
            "                name = mod_path = self.library",
            "            try:",
            "                module = importlib.import_module(mod_path)",
            "            except ImportError:",
            "                raise ValueError(\"Couldn't load %s password algorithm \"",
            "                                 \"library\" % name)",
            "            return module",
            "        raise ValueError(\"Hasher '%s' doesn't specify a library attribute\" %",
            "                         self.__class__)",
            "",
            "    def salt(self):",
            "        \"\"\"",
            "        Generates a cryptographically secure nonce salt in ascii",
            "        \"\"\"",
            "        return get_random_string()",
            "",
            "    def verify(self, password, encoded):",
            "        \"\"\"",
            "        Checks if the given password is correct",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def encode(self, password, salt):",
            "        \"\"\"",
            "        Creates an encoded database value",
            "",
            "        The result is normally formatted as \"algorithm$salt$hash\" and",
            "        must be fewer than 128 characters.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def safe_summary(self, encoded):",
            "        \"\"\"",
            "        Returns a summary of safe values",
            "",
            "        The result is a dictionary and will be used where the password field",
            "        must be displayed to construct a safe representation of the password.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "",
            "class PBKDF2PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the PBKDF2 algorithm (recommended)",
            "",
            "    Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.",
            "    The result is a 64 byte binary string.  Iterations may be changed",
            "    safely but you must rename the algorithm if you change SHA256.",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha256\"",
            "    iterations = 10000",
            "    digest = hashlib.sha256",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt, iterations=None):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        if not iterations:",
            "            iterations = self.iterations",
            "        hash = pbkdf2(password, salt, iterations, digest=self.digest)",
            "        hash = base64.b64encode(hash).decode('ascii').strip()",
            "        return \"%s$%d$%s$%s\" % (self.algorithm, iterations, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt, int(iterations))",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, iterations, salt, hash = encoded.split('$', 3)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('iterations'), iterations),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
            "    \"\"\"",
            "    Alternate PBKDF2 hasher which uses SHA1, the default PRF",
            "    recommended by PKCS #5. This is compatible with other",
            "    implementations of PBKDF2, such as openssl's",
            "    PKCS5_PBKDF2_HMAC_SHA1().",
            "    \"\"\"",
            "    algorithm = \"pbkdf2_sha1\"",
            "    digest = hashlib.sha1",
            "",
            "",
            "class BCryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Secure password hashing using the bcrypt algorithm (recommended)",
            "",
            "    This is considered by many to be the most secure algorithm but you",
            "    must first install the py-bcrypt library.  Please be warned that",
            "    this library depends on native C code and might cause portability",
            "    issues.",
            "    \"\"\"",
            "    algorithm = \"bcrypt\"",
            "    library = (\"py-bcrypt\", \"bcrypt\")",
            "    rounds = 12",
            "",
            "    def salt(self):",
            "        bcrypt = self._load_library()",
            "        return bcrypt.gensalt(self.rounds)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        bcrypt = self._load_library()",
            "        # Need to reevaluate the force_bytes call once bcrypt is supported on",
            "        # Python 3",
            "        data = bcrypt.hashpw(force_bytes(password), salt)",
            "        return \"%s$%s\" % (self.algorithm, data)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, data = encoded.split('$', 1)",
            "        assert algorithm == self.algorithm",
            "        bcrypt = self._load_library()",
            "        return constant_time_compare(data, bcrypt.hashpw(force_bytes(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
            "        assert algorithm == self.algorithm",
            "        salt, checksum = data[:22], data[22:]",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('work factor'), work_factor),",
            "            (_('salt'), mask_hash(salt)),",
            "            (_('checksum'), mask_hash(checksum)),",
            "        ])",
            "",
            "",
            "class SHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The SHA1 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"sha1\"",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.sha1(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class MD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    The Salted MD5 password hashing algorithm (not recommended)",
            "    \"\"\"",
            "    algorithm = \"md5\"",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert password",
            "        assert salt and '$' not in salt",
            "        hash = hashlib.md5(force_bytes(salt + password)).hexdigest()",
            "        return \"%s$%s$%s\" % (self.algorithm, salt, hash)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        encoded_2 = self.encode(password, salt)",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, hash = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), mask_hash(salt, show=2)),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Very insecure algorithm that you should *never* use; stores SHA1 hashes",
            "    with an empty salt.",
            "",
            "    This class is implemented because Django used to accept such password",
            "    hashes. Some older Django installs still have these values lingering",
            "    around so we need to handle and upgrade them properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_sha1\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        hash = hashlib.sha1(force_bytes(password)).hexdigest()",
            "        return 'sha1$$%s' % hash",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        assert encoded.startswith('sha1$$')",
            "        hash = encoded[6:]",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(hash)),",
            "        ])",
            "",
            "",
            "class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Incredibly insecure algorithm that you should *never* use; stores unsalted",
            "    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an",
            "    empty salt.",
            "",
            "    This class is implemented because Django used to store passwords this way",
            "    and to accept such password hashes. Some older Django installs still have",
            "    these values lingering around so we need to handle and upgrade them",
            "    properly.",
            "    \"\"\"",
            "    algorithm = \"unsalted_md5\"",
            "",
            "    def salt(self):",
            "        return ''",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        assert salt == ''",
            "        return hashlib.md5(force_bytes(password)).hexdigest()",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        if len(encoded) == 37 and encoded.startswith('md5$$'):",
            "            encoded = encoded[5:]",
            "        encoded_2 = self.encode(password, '')",
            "        return constant_time_compare(encoded, encoded_2)",
            "",
            "    def safe_summary(self, encoded):",
            "        return SortedDict([",
            "            (_('algorithm'), self.algorithm),",
            "            (_('hash'), mask_hash(encoded, show=3)),",
            "        ])",
            "",
            "",
            "class CryptPasswordHasher(BasePasswordHasher):",
            "    \"\"\"",
            "    Password hashing using UNIX crypt (not recommended)",
            "",
            "    The crypt module is not supported on all platforms.",
            "    \"\"\"",
            "    algorithm = \"crypt\"",
            "    library = \"crypt\"",
            "",
            "    def salt(self):",
            "        return get_random_string(2)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def encode(self, password, salt):",
            "        crypt = self._load_library()",
            "        assert len(salt) == 2",
            "        data = crypt.crypt(force_str(password), salt)",
            "        # we don't need to store the salt, but Django used to do this",
            "        return \"%s$%s$%s\" % (self.algorithm, '', data)",
            "",
            "    @password_max_length(MAXIMUM_PASSWORD_LENGTH)",
            "    def verify(self, password, encoded):",
            "        crypt = self._load_library()",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return constant_time_compare(data, crypt.crypt(force_str(password), data))",
            "",
            "    def safe_summary(self, encoded):",
            "        algorithm, salt, data = encoded.split('$', 2)",
            "        assert algorithm == self.algorithm",
            "        return SortedDict([",
            "            (_('algorithm'), algorithm),",
            "            (_('salt'), salt),",
            "            (_('hash'), mask_hash(data, show=3)),",
            "        ])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2"
        ],
        "dele_reviseLocation": {
            "461": []
        },
        "addLocation": [
            "django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher",
            "django.contrib.auth.hashers.MD5PasswordHasher",
            "django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher.self",
            "django.contrib.auth.hashers.BasePasswordHasher.self",
            "django.contrib.auth.hashers.CryptPasswordHasher",
            "django.contrib.auth.hashers.BCryptPasswordHasher.self",
            "nova.tests.unit.virt.libvirt.test_driver.LibvirtConnTestCase",
            "django.contrib.auth.hashers.BCryptPasswordHasher",
            "django.contrib.auth.hashers.PBKDF2PasswordHasher.self",
            "django.contrib.auth.hashers.SHA1PasswordHasher.self",
            "django.contrib.auth.hashers.MD5PasswordHasher.self",
            "django.contrib.auth.hashers.PBKDF2PasswordHasher",
            "django.contrib.auth.hashers.UnsaltedMD5PasswordHasher.self",
            "django.contrib.auth.hashers.CryptPasswordHasher.self",
            "django.contrib.auth.hashers.SHA1PasswordHasher",
            "django.contrib.auth.hashers.UnsaltedMD5PasswordHasher"
        ]
    },
    "django/contrib/auth/tests/hashers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.conf.global_settings import PASSWORD_HASHERS as default_hashers"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.contrib.auth.hashers import (is_password_usable,"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": "     check_password, make_password, PBKDF2PasswordHasher, load_hashers,"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    PBKDF2SHA1PasswordHasher, get_hasher, identify_hasher, UNUSABLE_PASSWORD)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+    PBKDF2SHA1PasswordHasher, get_hasher, identify_hasher, UNUSABLE_PASSWORD,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+    MAXIMUM_PASSWORD_LENGTH, password_max_length)"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.utils import unittest"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.utils.unittest import skipUnless"
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         self.assertTrue(is_password_usable(encoded))"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', encoded))"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', encoded))"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        # Long password"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        self.assertRaises("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            ValueError,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            make_password,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        )"
            },
            "18": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def test_pkbdf2(self):"
            },
            "20": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         encoded = make_password('l\u00e8tmein', 'seasalt', 'pbkdf2_sha256')"
            },
            "21": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', encoded))"
            },
            "22": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', encoded))"
            },
            "23": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         self.assertEqual(identify_hasher(encoded).algorithm, \"pbkdf2_sha256\")"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        # Long password"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        self.assertRaises("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            ValueError,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            make_password,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            \"seasalt\","
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            \"pbkdf2_sha256\","
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        )"
            },
            "32": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     def test_sha1(self):"
            },
            "34": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         encoded = make_password('l\u00e8tmein', 'seasalt', 'sha1')"
            },
            "35": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', encoded))"
            },
            "36": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', encoded))"
            },
            "37": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         self.assertEqual(identify_hasher(encoded).algorithm, \"sha1\")"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        # Long password"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        self.assertRaises("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            ValueError,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            make_password,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            \"seasalt\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            \"sha1\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        )"
            },
            "46": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def test_md5(self):"
            },
            "48": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         encoded = make_password('l\u00e8tmein', 'seasalt', 'md5')"
            },
            "49": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', encoded))"
            },
            "50": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', encoded))"
            },
            "51": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.assertEqual(identify_hasher(encoded).algorithm, \"md5\")"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        # Long password"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        self.assertRaises("
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            ValueError,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            make_password,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            \"seasalt\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            \"md5\","
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        )"
            },
            "60": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     def test_unsalted_md5(self):"
            },
            "62": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         encoded = make_password('l\u00e8tmein', '', 'unsalted_md5')"
            },
            "63": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         self.assertTrue(is_password_usable(alt_encoded))"
            },
            "64": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', alt_encoded))"
            },
            "65": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', alt_encoded))"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        # Long password"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        self.assertRaises("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            ValueError,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            make_password,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            \"\","
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            \"unsalted_md5\","
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        )"
            },
            "74": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     def test_unsalted_sha1(self):"
            },
            "76": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         encoded = make_password('l\u00e8tmein', '', 'unsalted_sha1')"
            },
            "77": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         # Raw SHA1 isn't acceptable"
            },
            "78": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         alt_encoded = encoded[6:]"
            },
            "79": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmein', alt_encoded))"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        # Long password"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        self.assertRaises("
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+            ValueError,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            make_password,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+            \"\","
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+            \"unslated_sha1\","
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        )"
            },
            "88": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     @skipUnless(crypt, \"no crypt module to generate password.\")"
            },
            "90": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     def test_crypt(self):"
            },
            "91": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmei', encoded))"
            },
            "92": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeiz', encoded))"
            },
            "93": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         self.assertEqual(identify_hasher(encoded).algorithm, \"crypt\")"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        # Long password"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        self.assertRaises("
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            ValueError,"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            make_password,"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            \"seasalt\","
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            \"crypt\","
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        )"
            },
            "102": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     @skipUnless(bcrypt, \"py-bcrypt not installed\")"
            },
            "104": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     def test_bcrypt(self):"
            },
            "105": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         self.assertTrue(check_password('l\u00e8tmein', encoded))"
            },
            "106": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         self.assertFalse(check_password('l\u00e8tmeinz', encoded))"
            },
            "107": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         self.assertEqual(identify_hasher(encoded).algorithm, \"bcrypt\")"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        # Long password"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        self.assertRaises("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            ValueError,"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            make_password,"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            hasher=\"bcrypt\","
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        )"
            },
            "115": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "116": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     def test_unusable(self):"
            },
            "117": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         encoded = make_password(None)"
            },
            "118": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         self.assertFalse(is_password_usable('l\u00e8tmein_badencoded'))"
            },
            "119": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         self.assertFalse(is_password_usable(''))"
            },
            "120": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    def test_max_password_length_decorator(self):"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        @password_max_length(10)"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        def encode(s, password, salt):"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            return True"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        self.assertTrue(encode(None, b\"1234\", b\"1234\"))"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        self.assertRaises(ValueError, encode, None, b\"1234567890A\", b\"1234\")"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+"
            },
            "129": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "     def test_low_level_pkbdf2(self):"
            },
            "130": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         hasher = PBKDF2PasswordHasher()"
            },
            "131": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         encoded = hasher.encode('l\u00e8tmein', 'seasalt')"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import unicode_literals",
            "",
            "from django.conf.global_settings import PASSWORD_HASHERS as default_hashers",
            "from django.contrib.auth.hashers import (is_password_usable,",
            "    check_password, make_password, PBKDF2PasswordHasher, load_hashers,",
            "    PBKDF2SHA1PasswordHasher, get_hasher, identify_hasher, UNUSABLE_PASSWORD)",
            "from django.utils import unittest",
            "from django.utils.unittest import skipUnless",
            "",
            "",
            "try:",
            "    import crypt",
            "except ImportError:",
            "    crypt = None",
            "",
            "try:",
            "    import bcrypt",
            "except ImportError:",
            "    bcrypt = None",
            "",
            "",
            "class TestUtilsHashPass(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        load_hashers(password_hashers=default_hashers)",
            "",
            "    def test_simple(self):",
            "        encoded = make_password('l\u00e8tmein')",
            "        self.assertTrue(encoded.startswith('pbkdf2_sha256$'))",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "",
            "    def test_pkbdf2(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'pbkdf2_sha256')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha256$10000$seasalt$CWWFdHOWwPnki7HvkcqN9iA2T3KLW1cf2uZ5kvArtVY=')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"pbkdf2_sha256\")",
            "",
            "    def test_sha1(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'sha1')",
            "        self.assertEqual(encoded,",
            "            'sha1$seasalt$cff36ea83f5706ce9aa7454e63e431fc726b2dc8')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"sha1\")",
            "",
            "    def test_md5(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'md5')",
            "        self.assertEqual(encoded,",
            "                         'md5$seasalt$3f86d0d3d465b7b458c231bf3555c0e3')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"md5\")",
            "",
            "    def test_unsalted_md5(self):",
            "        encoded = make_password('l\u00e8tmein', '', 'unsalted_md5')",
            "        self.assertEqual(encoded, '88a434c88cca4e900f7874cd98123f43')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"unsalted_md5\")",
            "        # Alternate unsalted syntax",
            "        alt_encoded = \"md5$$%s\" % encoded",
            "        self.assertTrue(is_password_usable(alt_encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', alt_encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', alt_encoded))",
            "",
            "    def test_unsalted_sha1(self):",
            "        encoded = make_password('l\u00e8tmein', '', 'unsalted_sha1')",
            "        self.assertEqual(encoded, 'sha1$$6d138ca3ae545631b3abd71a4f076ce759c5700b')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"unsalted_sha1\")",
            "        # Raw SHA1 isn't acceptable",
            "        alt_encoded = encoded[6:]",
            "        self.assertFalse(check_password('l\u00e8tmein', alt_encoded))",
            "",
            "    @skipUnless(crypt, \"no crypt module to generate password.\")",
            "    def test_crypt(self):",
            "        encoded = make_password('l\u00e8tmei', 'ab', 'crypt')",
            "        self.assertEqual(encoded, 'crypt$$ab1Hv2Lg7ltQo')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmei', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeiz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"crypt\")",
            "",
            "    @skipUnless(bcrypt, \"py-bcrypt not installed\")",
            "    def test_bcrypt(self):",
            "        encoded = make_password('l\u00e8tmein', hasher='bcrypt')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(encoded.startswith('bcrypt$'))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"bcrypt\")",
            "",
            "    def test_unusable(self):",
            "        encoded = make_password(None)",
            "        self.assertFalse(is_password_usable(encoded))",
            "        self.assertFalse(check_password(None, encoded))",
            "        self.assertFalse(check_password(UNUSABLE_PASSWORD, encoded))",
            "        self.assertFalse(check_password('', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertRaises(ValueError, identify_hasher, encoded)",
            "",
            "    def test_bad_algorithm(self):",
            "        def doit():",
            "            make_password('l\u00e8tmein', hasher='lolcat')",
            "        self.assertRaises(ValueError, doit)",
            "        self.assertRaises(ValueError, identify_hasher, \"lolcat$salt$hash\")",
            "",
            "    def test_bad_encoded(self):",
            "        self.assertFalse(is_password_usable('l\u00e8tmein_badencoded'))",
            "        self.assertFalse(is_password_usable(''))",
            "",
            "    def test_low_level_pkbdf2(self):",
            "        hasher = PBKDF2PasswordHasher()",
            "        encoded = hasher.encode('l\u00e8tmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha256$10000$seasalt$CWWFdHOWwPnki7HvkcqN9iA2T3KLW1cf2uZ5kvArtVY=')",
            "        self.assertTrue(hasher.verify('l\u00e8tmein', encoded))",
            "",
            "    def test_low_level_pbkdf2_sha1(self):",
            "        hasher = PBKDF2SHA1PasswordHasher()",
            "        encoded = hasher.encode('l\u00e8tmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha1$10000$seasalt$oAfF6vgs95ncksAhGXOWf4Okq7o=')",
            "        self.assertTrue(hasher.verify('l\u00e8tmein', encoded))",
            "",
            "    def test_upgrade(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('l\u00e8tmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter(password):",
            "                state['upgraded'] = True",
            "            self.assertTrue(check_password('l\u00e8tmein', encoded, setter))",
            "            self.assertTrue(state['upgraded'])",
            "",
            "    def test_no_upgrade(self):",
            "        encoded = make_password('l\u00e8tmein')",
            "        state = {'upgraded': False}",
            "        def setter():",
            "            state['upgraded'] = True",
            "        self.assertFalse(check_password('WRONG', encoded, setter))",
            "        self.assertFalse(state['upgraded'])",
            "",
            "    def test_no_upgrade_on_incorrect_pass(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('l\u00e8tmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter():",
            "                state['upgraded'] = True",
            "            self.assertFalse(check_password('WRONG', encoded, setter))",
            "            self.assertFalse(state['upgraded'])"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import unicode_literals",
            "",
            "from django.conf.global_settings import PASSWORD_HASHERS as default_hashers",
            "from django.contrib.auth.hashers import (is_password_usable,",
            "    check_password, make_password, PBKDF2PasswordHasher, load_hashers,",
            "    PBKDF2SHA1PasswordHasher, get_hasher, identify_hasher, UNUSABLE_PASSWORD,",
            "    MAXIMUM_PASSWORD_LENGTH, password_max_length)",
            "from django.utils import unittest",
            "from django.utils.unittest import skipUnless",
            "",
            "",
            "try:",
            "    import crypt",
            "except ImportError:",
            "    crypt = None",
            "",
            "try:",
            "    import bcrypt",
            "except ImportError:",
            "    bcrypt = None",
            "",
            "",
            "class TestUtilsHashPass(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        load_hashers(password_hashers=default_hashers)",
            "",
            "    def test_simple(self):",
            "        encoded = make_password('l\u00e8tmein')",
            "        self.assertTrue(encoded.startswith('pbkdf2_sha256$'))",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "        )",
            "",
            "    def test_pkbdf2(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'pbkdf2_sha256')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha256$10000$seasalt$CWWFdHOWwPnki7HvkcqN9iA2T3KLW1cf2uZ5kvArtVY=')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"pbkdf2_sha256\")",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"pbkdf2_sha256\",",
            "        )",
            "",
            "    def test_sha1(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'sha1')",
            "        self.assertEqual(encoded,",
            "            'sha1$seasalt$cff36ea83f5706ce9aa7454e63e431fc726b2dc8')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"sha1\")",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"sha1\",",
            "        )",
            "",
            "    def test_md5(self):",
            "        encoded = make_password('l\u00e8tmein', 'seasalt', 'md5')",
            "        self.assertEqual(encoded,",
            "                         'md5$seasalt$3f86d0d3d465b7b458c231bf3555c0e3')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"md5\")",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"md5\",",
            "        )",
            "",
            "    def test_unsalted_md5(self):",
            "        encoded = make_password('l\u00e8tmein', '', 'unsalted_md5')",
            "        self.assertEqual(encoded, '88a434c88cca4e900f7874cd98123f43')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"unsalted_md5\")",
            "        # Alternate unsalted syntax",
            "        alt_encoded = \"md5$$%s\" % encoded",
            "        self.assertTrue(is_password_usable(alt_encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', alt_encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', alt_encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"\",",
            "            \"unsalted_md5\",",
            "        )",
            "",
            "    def test_unsalted_sha1(self):",
            "        encoded = make_password('l\u00e8tmein', '', 'unsalted_sha1')",
            "        self.assertEqual(encoded, 'sha1$$6d138ca3ae545631b3abd71a4f076ce759c5700b')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"unsalted_sha1\")",
            "        # Raw SHA1 isn't acceptable",
            "        alt_encoded = encoded[6:]",
            "        self.assertFalse(check_password('l\u00e8tmein', alt_encoded))",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"\",",
            "            \"unslated_sha1\",",
            "        )",
            "",
            "    @skipUnless(crypt, \"no crypt module to generate password.\")",
            "    def test_crypt(self):",
            "        encoded = make_password('l\u00e8tmei', 'ab', 'crypt')",
            "        self.assertEqual(encoded, 'crypt$$ab1Hv2Lg7ltQo')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(check_password('l\u00e8tmei', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeiz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"crypt\")",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            \"seasalt\",",
            "            \"crypt\",",
            "        )",
            "",
            "    @skipUnless(bcrypt, \"py-bcrypt not installed\")",
            "    def test_bcrypt(self):",
            "        encoded = make_password('l\u00e8tmein', hasher='bcrypt')",
            "        self.assertTrue(is_password_usable(encoded))",
            "        self.assertTrue(encoded.startswith('bcrypt$'))",
            "        self.assertTrue(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertEqual(identify_hasher(encoded).algorithm, \"bcrypt\")",
            "        # Long password",
            "        self.assertRaises(",
            "            ValueError,",
            "            make_password,",
            "            b\"1\" * (MAXIMUM_PASSWORD_LENGTH + 1),",
            "            hasher=\"bcrypt\",",
            "        )",
            "",
            "    def test_unusable(self):",
            "        encoded = make_password(None)",
            "        self.assertFalse(is_password_usable(encoded))",
            "        self.assertFalse(check_password(None, encoded))",
            "        self.assertFalse(check_password(UNUSABLE_PASSWORD, encoded))",
            "        self.assertFalse(check_password('', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmein', encoded))",
            "        self.assertFalse(check_password('l\u00e8tmeinz', encoded))",
            "        self.assertRaises(ValueError, identify_hasher, encoded)",
            "",
            "    def test_bad_algorithm(self):",
            "        def doit():",
            "            make_password('l\u00e8tmein', hasher='lolcat')",
            "        self.assertRaises(ValueError, doit)",
            "        self.assertRaises(ValueError, identify_hasher, \"lolcat$salt$hash\")",
            "",
            "    def test_bad_encoded(self):",
            "        self.assertFalse(is_password_usable('l\u00e8tmein_badencoded'))",
            "        self.assertFalse(is_password_usable(''))",
            "",
            "    def test_max_password_length_decorator(self):",
            "        @password_max_length(10)",
            "        def encode(s, password, salt):",
            "            return True",
            "",
            "        self.assertTrue(encode(None, b\"1234\", b\"1234\"))",
            "        self.assertRaises(ValueError, encode, None, b\"1234567890A\", b\"1234\")",
            "",
            "    def test_low_level_pkbdf2(self):",
            "        hasher = PBKDF2PasswordHasher()",
            "        encoded = hasher.encode('l\u00e8tmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha256$10000$seasalt$CWWFdHOWwPnki7HvkcqN9iA2T3KLW1cf2uZ5kvArtVY=')",
            "        self.assertTrue(hasher.verify('l\u00e8tmein', encoded))",
            "",
            "    def test_low_level_pbkdf2_sha1(self):",
            "        hasher = PBKDF2SHA1PasswordHasher()",
            "        encoded = hasher.encode('l\u00e8tmein', 'seasalt')",
            "        self.assertEqual(encoded,",
            "            'pbkdf2_sha1$10000$seasalt$oAfF6vgs95ncksAhGXOWf4Okq7o=')",
            "        self.assertTrue(hasher.verify('l\u00e8tmein', encoded))",
            "",
            "    def test_upgrade(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('l\u00e8tmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter(password):",
            "                state['upgraded'] = True",
            "            self.assertTrue(check_password('l\u00e8tmein', encoded, setter))",
            "            self.assertTrue(state['upgraded'])",
            "",
            "    def test_no_upgrade(self):",
            "        encoded = make_password('l\u00e8tmein')",
            "        state = {'upgraded': False}",
            "        def setter():",
            "            state['upgraded'] = True",
            "        self.assertFalse(check_password('WRONG', encoded, setter))",
            "        self.assertFalse(state['upgraded'])",
            "",
            "    def test_no_upgrade_on_incorrect_pass(self):",
            "        self.assertEqual('pbkdf2_sha256', get_hasher('default').algorithm)",
            "        for algo in ('sha1', 'md5'):",
            "            encoded = make_password('l\u00e8tmein', hasher=algo)",
            "            state = {'upgraded': False}",
            "            def setter():",
            "                state['upgraded'] = True",
            "            self.assertFalse(check_password('WRONG', encoded, setter))",
            "            self.assertFalse(state['upgraded'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": []
        },
        "addLocation": []
    }
}