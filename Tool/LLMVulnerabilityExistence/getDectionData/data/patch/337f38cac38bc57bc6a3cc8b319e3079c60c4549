{
    "synapse/http/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     TYPE_CHECKING,"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     Any,"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     BinaryIO,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    Callable,"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     Dict,"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     Iterable,"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     List,"
            },
            "7": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 694,
                "PatchRowcode": "         output_stream: BinaryIO,"
            },
            "8": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 695,
                "PatchRowcode": "         max_size: Optional[int] = None,"
            },
            "9": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": 696,
                "PatchRowcode": "         headers: Optional[RawHeaders] = None,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+        is_allowed_content_type: Optional[Callable[[str], bool]] = None,"
            },
            "11": {
                "beforePatchRowNumber": 696,
                "afterPatchRowNumber": 698,
                "PatchRowcode": "     ) -> Tuple[int, Dict[bytes, List[bytes]], str, int]:"
            },
            "12": {
                "beforePatchRowNumber": 697,
                "afterPatchRowNumber": 699,
                "PatchRowcode": "         \"\"\"GETs a file from a given URL"
            },
            "13": {
                "beforePatchRowNumber": 698,
                "afterPatchRowNumber": 700,
                "PatchRowcode": "         Args:"
            },
            "14": {
                "beforePatchRowNumber": 699,
                "afterPatchRowNumber": 701,
                "PatchRowcode": "             url: The URL to GET"
            },
            "15": {
                "beforePatchRowNumber": 700,
                "afterPatchRowNumber": 702,
                "PatchRowcode": "             output_stream: File to write the response body to."
            },
            "16": {
                "beforePatchRowNumber": 701,
                "afterPatchRowNumber": 703,
                "PatchRowcode": "             headers: A map from header name to a list of values for that header"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 704,
                "PatchRowcode": "+            is_allowed_content_type: A predicate to determine whether the"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 705,
                "PatchRowcode": "+                content type of the file we're downloading is allowed. If set and"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+                it evaluates to False when called with the content type, the"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+                request will be terminated before completing the download by"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+                raising SynapseError."
            },
            "22": {
                "beforePatchRowNumber": 702,
                "afterPatchRowNumber": 709,
                "PatchRowcode": "         Returns:"
            },
            "23": {
                "beforePatchRowNumber": 703,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "             A tuple of the file length, dict of the response"
            },
            "24": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": 711,
                "PatchRowcode": "             headers, absolute URI of the response and HTTP response code."
            },
            "25": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 733,
                "PatchRowcode": "                 HTTPStatus.BAD_GATEWAY, \"Got error %d\" % (response.code,), Codes.UNKNOWN"
            },
            "26": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 734,
                "PatchRowcode": "             )"
            },
            "27": {
                "beforePatchRowNumber": 728,
                "afterPatchRowNumber": 735,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 736,
                "PatchRowcode": "+        if is_allowed_content_type and b\"Content-Type\" in resp_headers:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 737,
                "PatchRowcode": "+            content_type = resp_headers[b\"Content-Type\"][0].decode(\"ascii\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 738,
                "PatchRowcode": "+            if not is_allowed_content_type(content_type):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 739,
                "PatchRowcode": "+                raise SynapseError("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 740,
                "PatchRowcode": "+                    HTTPStatus.BAD_GATEWAY,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 741,
                "PatchRowcode": "+                    ("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 742,
                "PatchRowcode": "+                        \"Requested file's content type not allowed for this operation: %s\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 743,
                "PatchRowcode": "+                        % content_type"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 744,
                "PatchRowcode": "+                    ),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 745,
                "PatchRowcode": "+                )"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 746,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 729,
                "afterPatchRowNumber": 747,
                "PatchRowcode": "         # TODO: if our Content-Type is HTML or something, just read the first"
            },
            "40": {
                "beforePatchRowNumber": 730,
                "afterPatchRowNumber": 748,
                "PatchRowcode": "         # N bytes into RAM rather than saving it all to disk only to read it"
            },
            "41": {
                "beforePatchRowNumber": 731,
                "afterPatchRowNumber": 749,
                "PatchRowcode": "         # straight back in again"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import urllib.parse",
            "from http import HTTPStatus",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    BinaryIO,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from netaddr import AddrFormatError, IPAddress, IPSet",
            "from prometheus_client import Counter",
            "from typing_extensions import Protocol",
            "from zope.interface import implementer, provider",
            "",
            "from OpenSSL import SSL",
            "from OpenSSL.SSL import VERIFY_NONE",
            "from twisted.internet import defer, error as twisted_error, protocol, ssl",
            "from twisted.internet.address import IPv4Address, IPv6Address",
            "from twisted.internet.interfaces import (",
            "    IAddress,",
            "    IHostResolution,",
            "    IReactorPluggableNameResolver,",
            "    IResolutionReceiver,",
            "    ITCPTransport,",
            ")",
            "from twisted.internet.protocol import connectionDone",
            "from twisted.internet.task import Cooperator",
            "from twisted.python.failure import Failure",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.client import (",
            "    Agent,",
            "    HTTPConnectionPool,",
            "    ResponseNeverReceived,",
            "    readBody,",
            ")",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "",
            "from synapse.api.errors import Codes, HttpResponseException, SynapseError",
            "from synapse.http import QuieterFileBodyProducer, RequestTimedOutError, redact_uri",
            "from synapse.http.proxyagent import ProxyAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import set_tag, start_active_span, tags",
            "from synapse.types import ISynapseReactor",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(\"synapse_http_client_requests\", \"\", [\"method\"])",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_client_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "# the type of the headers list, to be passed to the t.w.h.Headers.",
            "# Actually we can mix str and bytes keys, but Mapping treats 'key' as invariant so",
            "# we simplify.",
            "RawHeaders = Union[Mapping[str, \"RawHeaderValue\"], Mapping[bytes, \"RawHeaderValue\"]]",
            "",
            "# the value actually has to be a List, but List is invariant so we can't specify that",
            "# the entries can either be Lists or bytes.",
            "RawHeaderValue = Sequence[Union[str, bytes]]",
            "",
            "# the type of the query params, to be passed into `urlencode`",
            "QueryParamValue = Union[str, bytes, Iterable[Union[str, bytes]]]",
            "QueryParams = Union[Mapping[str, QueryParamValue], Mapping[bytes, QueryParamValue]]",
            "",
            "",
            "def check_against_blacklist(",
            "    ip_address: IPAddress, ip_whitelist: Optional[IPSet], ip_blacklist: IPSet",
            ") -> bool:",
            "    \"\"\"",
            "    Compares an IP address to allowed and disallowed IP sets.",
            "",
            "    Args:",
            "        ip_address: The IP address to check",
            "        ip_whitelist: Allowed IP addresses.",
            "        ip_blacklist: Disallowed IP addresses.",
            "",
            "    Returns:",
            "        True if the IP address is in the blacklist and not in the whitelist.",
            "    \"\"\"",
            "    if ip_address in ip_blacklist:",
            "        if ip_whitelist is None or ip_address not in ip_whitelist:",
            "            return True",
            "    return False",
            "",
            "",
            "_EPSILON = 0.00000001",
            "",
            "",
            "def _make_scheduler(reactor):",
            "    \"\"\"Makes a schedular suitable for a Cooperator using the given reactor.",
            "",
            "    (This is effectively just a copy from `twisted.internet.task`)",
            "    \"\"\"",
            "",
            "    def _scheduler(x):",
            "        return reactor.callLater(_EPSILON, x)",
            "",
            "    return _scheduler",
            "",
            "",
            "class _IPBlacklistingResolver:",
            "    \"\"\"",
            "    A proxy for reactor.nameResolver which only produces non-blacklisted IP",
            "    addresses, preventing DNS rebinding attacks on URL preview.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            reactor: The twisted reactor.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def resolveHostName(",
            "        self, recv: IResolutionReceiver, hostname: str, portNumber: int = 0",
            "    ) -> IResolutionReceiver:",
            "        addresses: List[IAddress] = []",
            "",
            "        def _callback() -> None:",
            "            has_bad_ip = False",
            "            for address in addresses:",
            "                # We only expect IPv4 and IPv6 addresses since only A/AAAA lookups",
            "                # should go through this path.",
            "                if not isinstance(address, (IPv4Address, IPv6Address)):",
            "                    continue",
            "",
            "                ip_address = IPAddress(address.host)",
            "",
            "                if check_against_blacklist(",
            "                    ip_address, self._ip_whitelist, self._ip_blacklist",
            "                ):",
            "                    logger.info(",
            "                        \"Dropped %s from DNS resolution to %s due to blacklist\"",
            "                        % (ip_address, hostname)",
            "                    )",
            "                    has_bad_ip = True",
            "",
            "            # if we have a blacklisted IP, we'd like to raise an error to block the",
            "            # request, but all we can really do from here is claim that there were no",
            "            # valid results.",
            "            if not has_bad_ip:",
            "                for address in addresses:",
            "                    recv.addressResolved(address)",
            "            recv.resolutionComplete()",
            "",
            "        @provider(IResolutionReceiver)",
            "        class EndpointReceiver:",
            "            @staticmethod",
            "            def resolutionBegan(resolutionInProgress: IHostResolution) -> None:",
            "                recv.resolutionBegan(resolutionInProgress)",
            "",
            "            @staticmethod",
            "            def addressResolved(address: IAddress) -> None:",
            "                addresses.append(address)",
            "",
            "            @staticmethod",
            "            def resolutionComplete() -> None:",
            "                _callback()",
            "",
            "        self._reactor.nameResolver.resolveHostName(",
            "            EndpointReceiver, hostname, portNumber=portNumber",
            "        )",
            "",
            "        return recv",
            "",
            "",
            "@implementer(ISynapseReactor)",
            "class BlacklistingReactorWrapper:",
            "    \"\"\"",
            "    A Reactor wrapper which will prevent DNS resolution to blacklisted IP",
            "    addresses, to prevent DNS rebinding.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        self._reactor = reactor",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self._nameResolver = _IPBlacklistingResolver(",
            "            self._reactor, ip_whitelist, ip_blacklist",
            "        )",
            "",
            "    def __getattr__(self, attr: str) -> Any:",
            "        # Passthrough to the real reactor except for the DNS resolver.",
            "        if attr == \"nameResolver\":",
            "            return self._nameResolver",
            "        else:",
            "            return getattr(self._reactor, attr)",
            "",
            "",
            "class BlacklistingAgentWrapper(Agent):",
            "    \"\"\"",
            "    An Agent wrapper which will prevent access to IP addresses being accessed",
            "    directly (without an IP address lookup).",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        agent: IAgent,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            agent: The Agent to wrap.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._agent = agent",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def request(",
            "        self,",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> defer.Deferred:",
            "        h = urllib.parse.urlparse(uri.decode(\"ascii\"))",
            "",
            "        try:",
            "            ip_address = IPAddress(h.hostname)",
            "        except AddrFormatError:",
            "            # Not an IP",
            "            pass",
            "        else:",
            "            if check_against_blacklist(",
            "                ip_address, self._ip_whitelist, self._ip_blacklist",
            "            ):",
            "                logger.info(\"Blocking access to %s due to blacklist\" % (ip_address,))",
            "                e = SynapseError(",
            "                    HTTPStatus.FORBIDDEN, \"IP address blocked by IP blacklist entry\"",
            "                )",
            "                return defer.fail(Failure(e))",
            "",
            "        return self._agent.request(",
            "            method, uri, headers=headers, bodyProducer=bodyProducer",
            "        )",
            "",
            "",
            "class SimpleHttpClient:",
            "    \"\"\"",
            "    A simple, no-frills HTTP client with methods that wrap up common ways of",
            "    using HTTP in Matrix",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        treq_args: Optional[Dict[str, Any]] = None,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "        use_proxy: bool = False,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            hs",
            "            treq_args: Extra keyword arguments to be given to treq.request.",
            "            ip_blacklist: The IP addresses that are blacklisted that",
            "                we may not request.",
            "            ip_whitelist: The whitelisted IP addresses, that we can",
            "               request if it were otherwise caught in a blacklist.",
            "            use_proxy: Whether proxy settings should be discovered and used",
            "                from conventional environment variables.",
            "        \"\"\"",
            "        self.hs = hs",
            "",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "        self._extra_treq_args = treq_args or {}",
            "",
            "        self.user_agent = hs.version_string",
            "        self.clock = hs.get_clock()",
            "        if hs.config.server.user_agent_suffix:",
            "            self.user_agent = \"%s %s\" % (",
            "                self.user_agent,",
            "                hs.config.server.user_agent_suffix,",
            "            )",
            "",
            "        # We use this for our body producers to ensure that they use the correct",
            "        # reactor.",
            "        self._cooperator = Cooperator(scheduler=_make_scheduler(hs.get_reactor()))",
            "",
            "        self.user_agent = self.user_agent.encode(\"ascii\")",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we need to use a DNS resolver which",
            "            # filters out blacklisted IP addresses, to prevent DNS rebinding.",
            "            self.reactor: ISynapseReactor = BlacklistingReactorWrapper(",
            "                hs.get_reactor(), self._ip_whitelist, self._ip_blacklist",
            "            )",
            "        else:",
            "            self.reactor = hs.get_reactor()",
            "",
            "        # the pusher makes lots of concurrent SSL connections to sygnal, and",
            "        # tends to do so in batches, so we need to allow the pool to keep",
            "        # lots of idle connections around.",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        # XXX: The justification for using the cache factor here is that larger instances",
            "        # will need both more cache and more connections.",
            "        # Still, this should probably be a separate dial",
            "        pool.maxPersistentPerHost = max((100 * hs.config.caches.global_factor, 5))",
            "        pool.cachedConnectionTimeout = 2 * 60",
            "",
            "        self.agent: IAgent = ProxyAgent(",
            "            self.reactor,",
            "            hs.get_reactor(),",
            "            connectTimeout=15,",
            "            contextFactory=self.hs.get_http_client_context_factory(),",
            "            pool=pool,",
            "            use_proxy=use_proxy,",
            "        )",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we then install the blacklisting Agent",
            "            # which prevents direct access to IP addresses, that are not caught",
            "            # by the DNS resolution.",
            "            self.agent = BlacklistingAgentWrapper(",
            "                self.agent,",
            "                ip_whitelist=self._ip_whitelist,",
            "                ip_blacklist=self._ip_blacklist,",
            "            )",
            "",
            "    async def request(",
            "        self,",
            "        method: str,",
            "        uri: str,",
            "        data: Optional[bytes] = None,",
            "        headers: Optional[Headers] = None,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Args:",
            "            method: HTTP method to use.",
            "            uri: URI to query.",
            "            data: Data to send in the request body, if applicable.",
            "            headers: Request headers.",
            "",
            "        Returns:",
            "            Response object, once the headers have been read.",
            "",
            "        Raises:",
            "            RequestTimedOutError if the request times out before the headers are read",
            "",
            "        \"\"\"",
            "        outgoing_requests_counter.labels(method).inc()",
            "",
            "        # log request but strip `access_token` (AS requests for example include this)",
            "        logger.debug(\"Sending request %s %s\", method, redact_uri(uri))",
            "",
            "        with start_active_span(",
            "            \"outgoing-client-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.HTTP_METHOD: method,",
            "                tags.HTTP_URL: uri,",
            "            },",
            "            finish_on_close=True,",
            "        ):",
            "            try:",
            "                body_producer = None",
            "                if data is not None:",
            "                    body_producer = QuieterFileBodyProducer(",
            "                        BytesIO(data),",
            "                        cooperator=self._cooperator,",
            "                    )",
            "",
            "                request_deferred: defer.Deferred = treq.request(",
            "                    method,",
            "                    uri,",
            "                    agent=self.agent,",
            "                    data=body_producer,",
            "                    headers=headers,",
            "                    # Avoid buffering the body in treq since we do not reuse",
            "                    # response bodies.",
            "                    unbuffered=True,",
            "                    **self._extra_treq_args,",
            "                )",
            "",
            "                # we use our own timeout mechanism rather than treq's as a workaround",
            "                # for https://twistedmatrix.com/trac/ticket/9534.",
            "                request_deferred = timeout_deferred(",
            "                    request_deferred,",
            "                    60,",
            "                    self.hs.get_reactor(),",
            "                )",
            "",
            "                # turn timeouts into RequestTimedOutErrors",
            "                request_deferred.addErrback(_timeout_to_request_timed_out_error)",
            "",
            "                response = await make_deferred_yieldable(request_deferred)",
            "",
            "                incoming_responses_counter.labels(method, response.code).inc()",
            "                logger.info(",
            "                    \"Received response to %s %s: %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    response.code,",
            "                )",
            "                return response",
            "            except Exception as e:",
            "                incoming_responses_counter.labels(method, \"ERR\").inc()",
            "                logger.info(",
            "                    \"Error sending request to  %s %s: %s %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    type(e).__name__,",
            "                    e.args[0],",
            "                )",
            "                set_tag(tags.ERROR, True)",
            "                set_tag(\"error_reason\", e.args[0])",
            "                raise",
            "",
            "    async def post_urlencoded_get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[Mapping[str, Union[str, List[str]]]] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"",
            "        Args:",
            "            uri: uri to query",
            "            args: parameters to be url-encoded in the body",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "",
            "        # TODO: Do we ever want to log message contents?",
            "        logger.debug(\"post_urlencoded_get_json args: %s\", args)",
            "",
            "        query_bytes = encode_query_args(args)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/x-www-form-urlencoded\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=query_bytes",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def post_json_get_json(",
            "        self, uri: str, post_json: Any, headers: Optional[RawHeaders] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "",
            "        Args:",
            "            uri: URI to query.",
            "            post_json: request body, to be encoded as json",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        json_str = encode_canonical_json(post_json)",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_str, uri)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Gets some json from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query string",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        actual_headers = {b\"Accept\": [b\"application/json\"]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        body = await self.get_raw(uri, args, headers=actual_headers)",
            "        return json_decoder.decode(body.decode(\"utf-8\"))",
            "",
            "    async def put_json(",
            "        self,",
            "        uri: str,",
            "        json_body: Any,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Puts some json to the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            json_body: The JSON to put in the HTTP body,",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "             RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        json_str = encode_canonical_json(json_body)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"PUT\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_raw(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> bytes:",
            "        \"\"\"Gets raw text from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the",
            "            HTTP body as bytes.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException on a non-2xx HTTP response.",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", uri, headers=Headers(actual_headers))",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return body",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    # XXX: FIXME: This is horribly copy-pasted from matrixfederationclient.",
            "    # The two should be factored out.",
            "",
            "    async def get_file(",
            "        self,",
            "        url: str,",
            "        output_stream: BinaryIO,",
            "        max_size: Optional[int] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]], str, int]:",
            "        \"\"\"GETs a file from a given URL",
            "        Args:",
            "            url: The URL to GET",
            "            output_stream: File to write the response body to.",
            "            headers: A map from header name to a list of values for that header",
            "        Returns:",
            "            A tuple of the file length, dict of the response",
            "            headers, absolute URI of the response and HTTP response code.",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            SynapseError: if the response is not a 2xx, the remote file is too large, or",
            "               another exception happens during the download.",
            "        \"\"\"",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", url, headers=Headers(actual_headers))",
            "",
            "        resp_headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        if response.code > 299:",
            "            logger.warning(\"Got %d when downloading %s\" % (response.code, url))",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY, \"Got error %d\" % (response.code,), Codes.UNKNOWN",
            "            )",
            "",
            "        # TODO: if our Content-Type is HTML or something, just read the first",
            "        # N bytes into RAM rather than saving it all to disk only to read it",
            "        # straight back in again",
            "",
            "        try:",
            "            d = read_body_with_max_size(response, output_stream, max_size)",
            "",
            "            # Ensure that the body is not read forever.",
            "            d = timeout_deferred(d, 30, self.hs.get_reactor())",
            "",
            "            length = await make_deferred_yieldable(d)",
            "        except BodyExceededMaxSize:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY,",
            "                \"Requested file is too large > %r bytes\" % (max_size,),",
            "                Codes.TOO_LARGE,",
            "            )",
            "        except defer.TimeoutError:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY,",
            "                \"Requested file took too long to download\",",
            "                Codes.TOO_LARGE,",
            "            )",
            "        except Exception as e:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY, (\"Failed to download remote body: %s\" % e)",
            "            ) from e",
            "",
            "        return (",
            "            length,",
            "            resp_headers,",
            "            response.request.absoluteURI.decode(\"ascii\"),",
            "            response.code,",
            "        )",
            "",
            "",
            "def _timeout_to_request_timed_out_error(f: Failure):",
            "    if f.check(twisted_error.TimeoutError, twisted_error.ConnectingCancelledError):",
            "        # The TCP connection has its own timeout (set by the 'connectTimeout' param",
            "        # on the Agent), which raises twisted_error.TimeoutError exception.",
            "        raise RequestTimedOutError(\"Timeout connecting to remote server\")",
            "    elif f.check(defer.TimeoutError, ResponseNeverReceived):",
            "        # this one means that we hit our overall timeout on the request",
            "        raise RequestTimedOutError(\"Timeout waiting for response from remote server\")",
            "",
            "    return f",
            "",
            "",
            "class ByteWriteable(Protocol):",
            "    \"\"\"The type of object which must be passed into read_body_with_max_size.",
            "",
            "    Typically this is a file object.",
            "    \"\"\"",
            "",
            "    def write(self, data: bytes) -> int:",
            "        pass",
            "",
            "",
            "class BodyExceededMaxSize(Exception):",
            "    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"",
            "",
            "",
            "class _DiscardBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which immediately errors upon receiving data.\"\"\"",
            "",
            "    transport: Optional[ITCPTransport] = None",
            "",
            "    def __init__(self, deferred: defer.Deferred):",
            "        self.deferred = deferred",
            "",
            "    def _maybe_fail(self):",
            "        \"\"\"",
            "        Report a max size exceed error and disconnect the first time this is called.",
            "        \"\"\"",
            "        if not self.deferred.called:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            assert self.transport is not None",
            "            self.transport.abortConnection()",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        self._maybe_fail()",
            "",
            "    def connectionLost(self, reason: Failure = connectionDone) -> None:",
            "        self._maybe_fail()",
            "",
            "",
            "class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which reads body to a stream, erroring if the body exceeds a maximum size.\"\"\"",
            "",
            "    transport: Optional[ITCPTransport] = None",
            "",
            "    def __init__(",
            "        self, stream: ByteWriteable, deferred: defer.Deferred, max_size: Optional[int]",
            "    ):",
            "        self.stream = stream",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        # If the deferred was called, bail early.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        try:",
            "            self.stream.write(data)",
            "        except Exception:",
            "            self.deferred.errback()",
            "            return",
            "",
            "        self.length += len(data)",
            "        # The first time the maximum size is exceeded, error and cancel the",
            "        # connection. dataReceived might be called again if data was received",
            "        # in the meantime.",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            assert self.transport is not None",
            "            self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason: Failure = connectionDone) -> None:",
            "        # If the maximum size was already exceeded, there's nothing to do.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.length)",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.length)",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def read_body_with_max_size(",
            "    response: IResponse, stream: ByteWriteable, max_size: Optional[int]",
            ") -> \"defer.Deferred[int]\":",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    If the maximum file size is reached, the returned Deferred will resolve to a",
            "    Failure with a BodyExceededMaxSize exception.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        stream: The file-object to write to.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the length of the read body.",
            "    \"\"\"",
            "    d: \"defer.Deferred[int]\" = defer.Deferred()",
            "",
            "    # If the Content-Length header gives a size larger than the maximum allowed",
            "    # size, do not bother downloading the body.",
            "    if max_size is not None and response.length != UNKNOWN_LENGTH:",
            "        if response.length > max_size:",
            "            response.deliverBody(_DiscardBodyWithMaxSizeProtocol(d))",
            "            return d",
            "",
            "    response.deliverBody(_ReadBodyWithMaxSizeProtocol(stream, d, max_size))",
            "    return d",
            "",
            "",
            "def encode_query_args(args: Optional[Mapping[str, Union[str, List[str]]]]) -> bytes:",
            "    \"\"\"",
            "    Encodes a map of query arguments to bytes which can be appended to a URL.",
            "",
            "    Args:",
            "        args: The query arguments, a mapping of string to string or list of strings.",
            "",
            "    Returns:",
            "        The query arguments encoded as bytes.",
            "    \"\"\"",
            "    if args is None:",
            "        return b\"\"",
            "",
            "    encoded_args = {}",
            "    for k, vs in args.items():",
            "        if isinstance(vs, str):",
            "            vs = [vs]",
            "        encoded_args[k] = [v.encode(\"utf8\") for v in vs]",
            "",
            "    query_str = urllib.parse.urlencode(encoded_args, True)",
            "",
            "    return query_str.encode(\"utf8\")",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class InsecureInterceptableContextFactory(ssl.ContextFactory):",
            "    \"\"\"",
            "    Factory for PyOpenSSL SSL contexts which accepts any certificate for any domain.",
            "",
            "    Do not use this since it allows an attacker to intercept your communications.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._context = SSL.Context(SSL.SSLv23_METHOD)",
            "        self._context.set_verify(VERIFY_NONE, lambda *_: False)",
            "",
            "    def getContext(self, hostname=None, port=None):",
            "        return self._context",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        return self"
        ],
        "afterPatchFile": [
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import urllib.parse",
            "from http import HTTPStatus",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    BinaryIO,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "import treq",
            "from canonicaljson import encode_canonical_json",
            "from netaddr import AddrFormatError, IPAddress, IPSet",
            "from prometheus_client import Counter",
            "from typing_extensions import Protocol",
            "from zope.interface import implementer, provider",
            "",
            "from OpenSSL import SSL",
            "from OpenSSL.SSL import VERIFY_NONE",
            "from twisted.internet import defer, error as twisted_error, protocol, ssl",
            "from twisted.internet.address import IPv4Address, IPv6Address",
            "from twisted.internet.interfaces import (",
            "    IAddress,",
            "    IHostResolution,",
            "    IReactorPluggableNameResolver,",
            "    IResolutionReceiver,",
            "    ITCPTransport,",
            ")",
            "from twisted.internet.protocol import connectionDone",
            "from twisted.internet.task import Cooperator",
            "from twisted.python.failure import Failure",
            "from twisted.web._newclient import ResponseDone",
            "from twisted.web.client import (",
            "    Agent,",
            "    HTTPConnectionPool,",
            "    ResponseNeverReceived,",
            "    readBody,",
            ")",
            "from twisted.web.http import PotentialDataLoss",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import (",
            "    UNKNOWN_LENGTH,",
            "    IAgent,",
            "    IBodyProducer,",
            "    IPolicyForHTTPS,",
            "    IResponse,",
            ")",
            "",
            "from synapse.api.errors import Codes, HttpResponseException, SynapseError",
            "from synapse.http import QuieterFileBodyProducer, RequestTimedOutError, redact_uri",
            "from synapse.http.proxyagent import ProxyAgent",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.logging.opentracing import set_tag, start_active_span, tags",
            "from synapse.types import ISynapseReactor",
            "from synapse.util import json_decoder",
            "from synapse.util.async_helpers import timeout_deferred",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "outgoing_requests_counter = Counter(\"synapse_http_client_requests\", \"\", [\"method\"])",
            "incoming_responses_counter = Counter(",
            "    \"synapse_http_client_responses\", \"\", [\"method\", \"code\"]",
            ")",
            "",
            "# the type of the headers list, to be passed to the t.w.h.Headers.",
            "# Actually we can mix str and bytes keys, but Mapping treats 'key' as invariant so",
            "# we simplify.",
            "RawHeaders = Union[Mapping[str, \"RawHeaderValue\"], Mapping[bytes, \"RawHeaderValue\"]]",
            "",
            "# the value actually has to be a List, but List is invariant so we can't specify that",
            "# the entries can either be Lists or bytes.",
            "RawHeaderValue = Sequence[Union[str, bytes]]",
            "",
            "# the type of the query params, to be passed into `urlencode`",
            "QueryParamValue = Union[str, bytes, Iterable[Union[str, bytes]]]",
            "QueryParams = Union[Mapping[str, QueryParamValue], Mapping[bytes, QueryParamValue]]",
            "",
            "",
            "def check_against_blacklist(",
            "    ip_address: IPAddress, ip_whitelist: Optional[IPSet], ip_blacklist: IPSet",
            ") -> bool:",
            "    \"\"\"",
            "    Compares an IP address to allowed and disallowed IP sets.",
            "",
            "    Args:",
            "        ip_address: The IP address to check",
            "        ip_whitelist: Allowed IP addresses.",
            "        ip_blacklist: Disallowed IP addresses.",
            "",
            "    Returns:",
            "        True if the IP address is in the blacklist and not in the whitelist.",
            "    \"\"\"",
            "    if ip_address in ip_blacklist:",
            "        if ip_whitelist is None or ip_address not in ip_whitelist:",
            "            return True",
            "    return False",
            "",
            "",
            "_EPSILON = 0.00000001",
            "",
            "",
            "def _make_scheduler(reactor):",
            "    \"\"\"Makes a schedular suitable for a Cooperator using the given reactor.",
            "",
            "    (This is effectively just a copy from `twisted.internet.task`)",
            "    \"\"\"",
            "",
            "    def _scheduler(x):",
            "        return reactor.callLater(_EPSILON, x)",
            "",
            "    return _scheduler",
            "",
            "",
            "class _IPBlacklistingResolver:",
            "    \"\"\"",
            "    A proxy for reactor.nameResolver which only produces non-blacklisted IP",
            "    addresses, preventing DNS rebinding attacks on URL preview.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            reactor: The twisted reactor.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._reactor = reactor",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def resolveHostName(",
            "        self, recv: IResolutionReceiver, hostname: str, portNumber: int = 0",
            "    ) -> IResolutionReceiver:",
            "        addresses: List[IAddress] = []",
            "",
            "        def _callback() -> None:",
            "            has_bad_ip = False",
            "            for address in addresses:",
            "                # We only expect IPv4 and IPv6 addresses since only A/AAAA lookups",
            "                # should go through this path.",
            "                if not isinstance(address, (IPv4Address, IPv6Address)):",
            "                    continue",
            "",
            "                ip_address = IPAddress(address.host)",
            "",
            "                if check_against_blacklist(",
            "                    ip_address, self._ip_whitelist, self._ip_blacklist",
            "                ):",
            "                    logger.info(",
            "                        \"Dropped %s from DNS resolution to %s due to blacklist\"",
            "                        % (ip_address, hostname)",
            "                    )",
            "                    has_bad_ip = True",
            "",
            "            # if we have a blacklisted IP, we'd like to raise an error to block the",
            "            # request, but all we can really do from here is claim that there were no",
            "            # valid results.",
            "            if not has_bad_ip:",
            "                for address in addresses:",
            "                    recv.addressResolved(address)",
            "            recv.resolutionComplete()",
            "",
            "        @provider(IResolutionReceiver)",
            "        class EndpointReceiver:",
            "            @staticmethod",
            "            def resolutionBegan(resolutionInProgress: IHostResolution) -> None:",
            "                recv.resolutionBegan(resolutionInProgress)",
            "",
            "            @staticmethod",
            "            def addressResolved(address: IAddress) -> None:",
            "                addresses.append(address)",
            "",
            "            @staticmethod",
            "            def resolutionComplete() -> None:",
            "                _callback()",
            "",
            "        self._reactor.nameResolver.resolveHostName(",
            "            EndpointReceiver, hostname, portNumber=portNumber",
            "        )",
            "",
            "        return recv",
            "",
            "",
            "@implementer(ISynapseReactor)",
            "class BlacklistingReactorWrapper:",
            "    \"\"\"",
            "    A Reactor wrapper which will prevent DNS resolution to blacklisted IP",
            "    addresses, to prevent DNS rebinding.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        reactor: IReactorPluggableNameResolver,",
            "        ip_whitelist: Optional[IPSet],",
            "        ip_blacklist: IPSet,",
            "    ):",
            "        self._reactor = reactor",
            "",
            "        # We need to use a DNS resolver which filters out blacklisted IP",
            "        # addresses, to prevent DNS rebinding.",
            "        self._nameResolver = _IPBlacklistingResolver(",
            "            self._reactor, ip_whitelist, ip_blacklist",
            "        )",
            "",
            "    def __getattr__(self, attr: str) -> Any:",
            "        # Passthrough to the real reactor except for the DNS resolver.",
            "        if attr == \"nameResolver\":",
            "            return self._nameResolver",
            "        else:",
            "            return getattr(self._reactor, attr)",
            "",
            "",
            "class BlacklistingAgentWrapper(Agent):",
            "    \"\"\"",
            "    An Agent wrapper which will prevent access to IP addresses being accessed",
            "    directly (without an IP address lookup).",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        agent: IAgent,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            agent: The Agent to wrap.",
            "            ip_whitelist: IP addresses to allow.",
            "            ip_blacklist: IP addresses to disallow.",
            "        \"\"\"",
            "        self._agent = agent",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "",
            "    def request(",
            "        self,",
            "        method: bytes,",
            "        uri: bytes,",
            "        headers: Optional[Headers] = None,",
            "        bodyProducer: Optional[IBodyProducer] = None,",
            "    ) -> defer.Deferred:",
            "        h = urllib.parse.urlparse(uri.decode(\"ascii\"))",
            "",
            "        try:",
            "            ip_address = IPAddress(h.hostname)",
            "        except AddrFormatError:",
            "            # Not an IP",
            "            pass",
            "        else:",
            "            if check_against_blacklist(",
            "                ip_address, self._ip_whitelist, self._ip_blacklist",
            "            ):",
            "                logger.info(\"Blocking access to %s due to blacklist\" % (ip_address,))",
            "                e = SynapseError(",
            "                    HTTPStatus.FORBIDDEN, \"IP address blocked by IP blacklist entry\"",
            "                )",
            "                return defer.fail(Failure(e))",
            "",
            "        return self._agent.request(",
            "            method, uri, headers=headers, bodyProducer=bodyProducer",
            "        )",
            "",
            "",
            "class SimpleHttpClient:",
            "    \"\"\"",
            "    A simple, no-frills HTTP client with methods that wrap up common ways of",
            "    using HTTP in Matrix",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        treq_args: Optional[Dict[str, Any]] = None,",
            "        ip_whitelist: Optional[IPSet] = None,",
            "        ip_blacklist: Optional[IPSet] = None,",
            "        use_proxy: bool = False,",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            hs",
            "            treq_args: Extra keyword arguments to be given to treq.request.",
            "            ip_blacklist: The IP addresses that are blacklisted that",
            "                we may not request.",
            "            ip_whitelist: The whitelisted IP addresses, that we can",
            "               request if it were otherwise caught in a blacklist.",
            "            use_proxy: Whether proxy settings should be discovered and used",
            "                from conventional environment variables.",
            "        \"\"\"",
            "        self.hs = hs",
            "",
            "        self._ip_whitelist = ip_whitelist",
            "        self._ip_blacklist = ip_blacklist",
            "        self._extra_treq_args = treq_args or {}",
            "",
            "        self.user_agent = hs.version_string",
            "        self.clock = hs.get_clock()",
            "        if hs.config.server.user_agent_suffix:",
            "            self.user_agent = \"%s %s\" % (",
            "                self.user_agent,",
            "                hs.config.server.user_agent_suffix,",
            "            )",
            "",
            "        # We use this for our body producers to ensure that they use the correct",
            "        # reactor.",
            "        self._cooperator = Cooperator(scheduler=_make_scheduler(hs.get_reactor()))",
            "",
            "        self.user_agent = self.user_agent.encode(\"ascii\")",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we need to use a DNS resolver which",
            "            # filters out blacklisted IP addresses, to prevent DNS rebinding.",
            "            self.reactor: ISynapseReactor = BlacklistingReactorWrapper(",
            "                hs.get_reactor(), self._ip_whitelist, self._ip_blacklist",
            "            )",
            "        else:",
            "            self.reactor = hs.get_reactor()",
            "",
            "        # the pusher makes lots of concurrent SSL connections to sygnal, and",
            "        # tends to do so in batches, so we need to allow the pool to keep",
            "        # lots of idle connections around.",
            "        pool = HTTPConnectionPool(self.reactor)",
            "        # XXX: The justification for using the cache factor here is that larger instances",
            "        # will need both more cache and more connections.",
            "        # Still, this should probably be a separate dial",
            "        pool.maxPersistentPerHost = max((100 * hs.config.caches.global_factor, 5))",
            "        pool.cachedConnectionTimeout = 2 * 60",
            "",
            "        self.agent: IAgent = ProxyAgent(",
            "            self.reactor,",
            "            hs.get_reactor(),",
            "            connectTimeout=15,",
            "            contextFactory=self.hs.get_http_client_context_factory(),",
            "            pool=pool,",
            "            use_proxy=use_proxy,",
            "        )",
            "",
            "        if self._ip_blacklist:",
            "            # If we have an IP blacklist, we then install the blacklisting Agent",
            "            # which prevents direct access to IP addresses, that are not caught",
            "            # by the DNS resolution.",
            "            self.agent = BlacklistingAgentWrapper(",
            "                self.agent,",
            "                ip_whitelist=self._ip_whitelist,",
            "                ip_blacklist=self._ip_blacklist,",
            "            )",
            "",
            "    async def request(",
            "        self,",
            "        method: str,",
            "        uri: str,",
            "        data: Optional[bytes] = None,",
            "        headers: Optional[Headers] = None,",
            "    ) -> IResponse:",
            "        \"\"\"",
            "        Args:",
            "            method: HTTP method to use.",
            "            uri: URI to query.",
            "            data: Data to send in the request body, if applicable.",
            "            headers: Request headers.",
            "",
            "        Returns:",
            "            Response object, once the headers have been read.",
            "",
            "        Raises:",
            "            RequestTimedOutError if the request times out before the headers are read",
            "",
            "        \"\"\"",
            "        outgoing_requests_counter.labels(method).inc()",
            "",
            "        # log request but strip `access_token` (AS requests for example include this)",
            "        logger.debug(\"Sending request %s %s\", method, redact_uri(uri))",
            "",
            "        with start_active_span(",
            "            \"outgoing-client-request\",",
            "            tags={",
            "                tags.SPAN_KIND: tags.SPAN_KIND_RPC_CLIENT,",
            "                tags.HTTP_METHOD: method,",
            "                tags.HTTP_URL: uri,",
            "            },",
            "            finish_on_close=True,",
            "        ):",
            "            try:",
            "                body_producer = None",
            "                if data is not None:",
            "                    body_producer = QuieterFileBodyProducer(",
            "                        BytesIO(data),",
            "                        cooperator=self._cooperator,",
            "                    )",
            "",
            "                request_deferred: defer.Deferred = treq.request(",
            "                    method,",
            "                    uri,",
            "                    agent=self.agent,",
            "                    data=body_producer,",
            "                    headers=headers,",
            "                    # Avoid buffering the body in treq since we do not reuse",
            "                    # response bodies.",
            "                    unbuffered=True,",
            "                    **self._extra_treq_args,",
            "                )",
            "",
            "                # we use our own timeout mechanism rather than treq's as a workaround",
            "                # for https://twistedmatrix.com/trac/ticket/9534.",
            "                request_deferred = timeout_deferred(",
            "                    request_deferred,",
            "                    60,",
            "                    self.hs.get_reactor(),",
            "                )",
            "",
            "                # turn timeouts into RequestTimedOutErrors",
            "                request_deferred.addErrback(_timeout_to_request_timed_out_error)",
            "",
            "                response = await make_deferred_yieldable(request_deferred)",
            "",
            "                incoming_responses_counter.labels(method, response.code).inc()",
            "                logger.info(",
            "                    \"Received response to %s %s: %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    response.code,",
            "                )",
            "                return response",
            "            except Exception as e:",
            "                incoming_responses_counter.labels(method, \"ERR\").inc()",
            "                logger.info(",
            "                    \"Error sending request to  %s %s: %s %s\",",
            "                    method,",
            "                    redact_uri(uri),",
            "                    type(e).__name__,",
            "                    e.args[0],",
            "                )",
            "                set_tag(tags.ERROR, True)",
            "                set_tag(\"error_reason\", e.args[0])",
            "                raise",
            "",
            "    async def post_urlencoded_get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[Mapping[str, Union[str, List[str]]]] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"",
            "        Args:",
            "            uri: uri to query",
            "            args: parameters to be url-encoded in the body",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "",
            "        # TODO: Do we ever want to log message contents?",
            "        logger.debug(\"post_urlencoded_get_json args: %s\", args)",
            "",
            "        query_bytes = encode_query_args(args)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/x-www-form-urlencoded\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=query_bytes",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def post_json_get_json(",
            "        self, uri: str, post_json: Any, headers: Optional[RawHeaders] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "",
            "        Args:",
            "            uri: URI to query.",
            "            post_json: request body, to be encoded as json",
            "            headers: a map from header name to a list of values for that header",
            "",
            "        Returns:",
            "            parsed json",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException: On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        json_str = encode_canonical_json(post_json)",
            "",
            "        logger.debug(\"HTTP POST %s -> %s\", json_str, uri)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"POST\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_json(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Gets some json from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query string",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        actual_headers = {b\"Accept\": [b\"application/json\"]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        body = await self.get_raw(uri, args, headers=actual_headers)",
            "        return json_decoder.decode(body.decode(\"utf-8\"))",
            "",
            "    async def put_json(",
            "        self,",
            "        uri: str,",
            "        json_body: Any,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> Any:",
            "        \"\"\"Puts some json to the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            json_body: The JSON to put in the HTTP body,",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the HTTP body as JSON.",
            "        Raises:",
            "             RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException On a non-2xx HTTP response.",
            "",
            "            ValueError: if the response was not JSON",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        json_str = encode_canonical_json(json_body)",
            "",
            "        actual_headers = {",
            "            b\"Content-Type\": [b\"application/json\"],",
            "            b\"User-Agent\": [self.user_agent],",
            "            b\"Accept\": [b\"application/json\"],",
            "        }",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(",
            "            \"PUT\", uri, headers=Headers(actual_headers), data=json_str",
            "        )",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return json_decoder.decode(body.decode(\"utf-8\"))",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    async def get_raw(",
            "        self,",
            "        uri: str,",
            "        args: Optional[QueryParams] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "    ) -> bytes:",
            "        \"\"\"Gets raw text from the given URI.",
            "",
            "        Args:",
            "            uri: The URI to request, not including query parameters",
            "            args: A dictionary used to create query strings",
            "            headers: a map from header name to a list of values for that header",
            "        Returns:",
            "            Succeeds when we get a 2xx HTTP response, with the",
            "            HTTP body as bytes.",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            HttpResponseException on a non-2xx HTTP response.",
            "        \"\"\"",
            "        if args:",
            "            query_str = urllib.parse.urlencode(args, True)",
            "            uri = \"%s?%s\" % (uri, query_str)",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", uri, headers=Headers(actual_headers))",
            "",
            "        body = await make_deferred_yieldable(readBody(response))",
            "",
            "        if 200 <= response.code < 300:",
            "            return body",
            "        else:",
            "            raise HttpResponseException(",
            "                response.code, response.phrase.decode(\"ascii\", errors=\"replace\"), body",
            "            )",
            "",
            "    # XXX: FIXME: This is horribly copy-pasted from matrixfederationclient.",
            "    # The two should be factored out.",
            "",
            "    async def get_file(",
            "        self,",
            "        url: str,",
            "        output_stream: BinaryIO,",
            "        max_size: Optional[int] = None,",
            "        headers: Optional[RawHeaders] = None,",
            "        is_allowed_content_type: Optional[Callable[[str], bool]] = None,",
            "    ) -> Tuple[int, Dict[bytes, List[bytes]], str, int]:",
            "        \"\"\"GETs a file from a given URL",
            "        Args:",
            "            url: The URL to GET",
            "            output_stream: File to write the response body to.",
            "            headers: A map from header name to a list of values for that header",
            "            is_allowed_content_type: A predicate to determine whether the",
            "                content type of the file we're downloading is allowed. If set and",
            "                it evaluates to False when called with the content type, the",
            "                request will be terminated before completing the download by",
            "                raising SynapseError.",
            "        Returns:",
            "            A tuple of the file length, dict of the response",
            "            headers, absolute URI of the response and HTTP response code.",
            "",
            "        Raises:",
            "            RequestTimedOutError: if there is a timeout before the response headers",
            "               are received. Note there is currently no timeout on reading the response",
            "               body.",
            "",
            "            SynapseError: if the response is not a 2xx, the remote file is too large, or",
            "               another exception happens during the download.",
            "        \"\"\"",
            "",
            "        actual_headers = {b\"User-Agent\": [self.user_agent]}",
            "        if headers:",
            "            actual_headers.update(headers)  # type: ignore",
            "",
            "        response = await self.request(\"GET\", url, headers=Headers(actual_headers))",
            "",
            "        resp_headers = dict(response.headers.getAllRawHeaders())",
            "",
            "        if response.code > 299:",
            "            logger.warning(\"Got %d when downloading %s\" % (response.code, url))",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY, \"Got error %d\" % (response.code,), Codes.UNKNOWN",
            "            )",
            "",
            "        if is_allowed_content_type and b\"Content-Type\" in resp_headers:",
            "            content_type = resp_headers[b\"Content-Type\"][0].decode(\"ascii\")",
            "            if not is_allowed_content_type(content_type):",
            "                raise SynapseError(",
            "                    HTTPStatus.BAD_GATEWAY,",
            "                    (",
            "                        \"Requested file's content type not allowed for this operation: %s\"",
            "                        % content_type",
            "                    ),",
            "                )",
            "",
            "        # TODO: if our Content-Type is HTML or something, just read the first",
            "        # N bytes into RAM rather than saving it all to disk only to read it",
            "        # straight back in again",
            "",
            "        try:",
            "            d = read_body_with_max_size(response, output_stream, max_size)",
            "",
            "            # Ensure that the body is not read forever.",
            "            d = timeout_deferred(d, 30, self.hs.get_reactor())",
            "",
            "            length = await make_deferred_yieldable(d)",
            "        except BodyExceededMaxSize:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY,",
            "                \"Requested file is too large > %r bytes\" % (max_size,),",
            "                Codes.TOO_LARGE,",
            "            )",
            "        except defer.TimeoutError:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY,",
            "                \"Requested file took too long to download\",",
            "                Codes.TOO_LARGE,",
            "            )",
            "        except Exception as e:",
            "            raise SynapseError(",
            "                HTTPStatus.BAD_GATEWAY, (\"Failed to download remote body: %s\" % e)",
            "            ) from e",
            "",
            "        return (",
            "            length,",
            "            resp_headers,",
            "            response.request.absoluteURI.decode(\"ascii\"),",
            "            response.code,",
            "        )",
            "",
            "",
            "def _timeout_to_request_timed_out_error(f: Failure):",
            "    if f.check(twisted_error.TimeoutError, twisted_error.ConnectingCancelledError):",
            "        # The TCP connection has its own timeout (set by the 'connectTimeout' param",
            "        # on the Agent), which raises twisted_error.TimeoutError exception.",
            "        raise RequestTimedOutError(\"Timeout connecting to remote server\")",
            "    elif f.check(defer.TimeoutError, ResponseNeverReceived):",
            "        # this one means that we hit our overall timeout on the request",
            "        raise RequestTimedOutError(\"Timeout waiting for response from remote server\")",
            "",
            "    return f",
            "",
            "",
            "class ByteWriteable(Protocol):",
            "    \"\"\"The type of object which must be passed into read_body_with_max_size.",
            "",
            "    Typically this is a file object.",
            "    \"\"\"",
            "",
            "    def write(self, data: bytes) -> int:",
            "        pass",
            "",
            "",
            "class BodyExceededMaxSize(Exception):",
            "    \"\"\"The maximum allowed size of the HTTP body was exceeded.\"\"\"",
            "",
            "",
            "class _DiscardBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which immediately errors upon receiving data.\"\"\"",
            "",
            "    transport: Optional[ITCPTransport] = None",
            "",
            "    def __init__(self, deferred: defer.Deferred):",
            "        self.deferred = deferred",
            "",
            "    def _maybe_fail(self):",
            "        \"\"\"",
            "        Report a max size exceed error and disconnect the first time this is called.",
            "        \"\"\"",
            "        if not self.deferred.called:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            assert self.transport is not None",
            "            self.transport.abortConnection()",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        self._maybe_fail()",
            "",
            "    def connectionLost(self, reason: Failure = connectionDone) -> None:",
            "        self._maybe_fail()",
            "",
            "",
            "class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):",
            "    \"\"\"A protocol which reads body to a stream, erroring if the body exceeds a maximum size.\"\"\"",
            "",
            "    transport: Optional[ITCPTransport] = None",
            "",
            "    def __init__(",
            "        self, stream: ByteWriteable, deferred: defer.Deferred, max_size: Optional[int]",
            "    ):",
            "        self.stream = stream",
            "        self.deferred = deferred",
            "        self.length = 0",
            "        self.max_size = max_size",
            "",
            "    def dataReceived(self, data: bytes) -> None:",
            "        # If the deferred was called, bail early.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        try:",
            "            self.stream.write(data)",
            "        except Exception:",
            "            self.deferred.errback()",
            "            return",
            "",
            "        self.length += len(data)",
            "        # The first time the maximum size is exceeded, error and cancel the",
            "        # connection. dataReceived might be called again if data was received",
            "        # in the meantime.",
            "        if self.max_size is not None and self.length >= self.max_size:",
            "            self.deferred.errback(BodyExceededMaxSize())",
            "            # Close the connection (forcefully) since all the data will get",
            "            # discarded anyway.",
            "            assert self.transport is not None",
            "            self.transport.abortConnection()",
            "",
            "    def connectionLost(self, reason: Failure = connectionDone) -> None:",
            "        # If the maximum size was already exceeded, there's nothing to do.",
            "        if self.deferred.called:",
            "            return",
            "",
            "        if reason.check(ResponseDone):",
            "            self.deferred.callback(self.length)",
            "        elif reason.check(PotentialDataLoss):",
            "            # stolen from https://github.com/twisted/treq/pull/49/files",
            "            # http://twistedmatrix.com/trac/ticket/4840",
            "            self.deferred.callback(self.length)",
            "        else:",
            "            self.deferred.errback(reason)",
            "",
            "",
            "def read_body_with_max_size(",
            "    response: IResponse, stream: ByteWriteable, max_size: Optional[int]",
            ") -> \"defer.Deferred[int]\":",
            "    \"\"\"",
            "    Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.",
            "",
            "    If the maximum file size is reached, the returned Deferred will resolve to a",
            "    Failure with a BodyExceededMaxSize exception.",
            "",
            "    Args:",
            "        response: The HTTP response to read from.",
            "        stream: The file-object to write to.",
            "        max_size: The maximum file size to allow.",
            "",
            "    Returns:",
            "        A Deferred which resolves to the length of the read body.",
            "    \"\"\"",
            "    d: \"defer.Deferred[int]\" = defer.Deferred()",
            "",
            "    # If the Content-Length header gives a size larger than the maximum allowed",
            "    # size, do not bother downloading the body.",
            "    if max_size is not None and response.length != UNKNOWN_LENGTH:",
            "        if response.length > max_size:",
            "            response.deliverBody(_DiscardBodyWithMaxSizeProtocol(d))",
            "            return d",
            "",
            "    response.deliverBody(_ReadBodyWithMaxSizeProtocol(stream, d, max_size))",
            "    return d",
            "",
            "",
            "def encode_query_args(args: Optional[Mapping[str, Union[str, List[str]]]]) -> bytes:",
            "    \"\"\"",
            "    Encodes a map of query arguments to bytes which can be appended to a URL.",
            "",
            "    Args:",
            "        args: The query arguments, a mapping of string to string or list of strings.",
            "",
            "    Returns:",
            "        The query arguments encoded as bytes.",
            "    \"\"\"",
            "    if args is None:",
            "        return b\"\"",
            "",
            "    encoded_args = {}",
            "    for k, vs in args.items():",
            "        if isinstance(vs, str):",
            "            vs = [vs]",
            "        encoded_args[k] = [v.encode(\"utf8\") for v in vs]",
            "",
            "    query_str = urllib.parse.urlencode(encoded_args, True)",
            "",
            "    return query_str.encode(\"utf8\")",
            "",
            "",
            "@implementer(IPolicyForHTTPS)",
            "class InsecureInterceptableContextFactory(ssl.ContextFactory):",
            "    \"\"\"",
            "    Factory for PyOpenSSL SSL contexts which accepts any certificate for any domain.",
            "",
            "    Do not use this since it allows an attacker to intercept your communications.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._context = SSL.Context(SSL.SSLv23_METHOD)",
            "        self._context.set_verify(VERIFY_NONE, lambda *_: False)",
            "",
            "    def getContext(self, hostname=None, port=None):",
            "        return self._context",
            "",
            "    def creatorForNetloc(self, hostname, port):",
            "        return self"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "synapse.http.client.SimpleHttpClient.self"
        ]
    },
    "synapse/rest/media/v1/preview_url_resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "                 output_stream=output_stream,"
            },
            "1": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "                 max_size=self.max_spider_size,"
            },
            "2": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "                 headers={\"Accept-Language\": self.url_preview_accept_language},"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+                is_allowed_content_type=_is_previewable,"
            },
            "4": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "             )"
            },
            "5": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         except SynapseError:"
            },
            "6": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             # Pass SynapseErrors through directly, so that the servlet"
            },
            "7": {
                "beforePatchRowNumber": 761,
                "afterPatchRowNumber": 762,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 762,
                "afterPatchRowNumber": 763,
                "PatchRowcode": " def _is_json(content_type: str) -> bool:"
            },
            "9": {
                "beforePatchRowNumber": 763,
                "afterPatchRowNumber": 764,
                "PatchRowcode": "     return content_type.lower().startswith(\"application/json\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 765,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 766,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 767,
                "PatchRowcode": "+def _is_previewable(content_type: str) -> bool:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 768,
                "PatchRowcode": "+    \"\"\"Returns True for content types for which we will perform URL preview and False"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 769,
                "PatchRowcode": "+    otherwise.\"\"\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 770,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 771,
                "PatchRowcode": "+    return _is_html(content_type) or _is_media(content_type) or _is_json(content_type)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2016 OpenMarket Ltd",
            "# Copyright 2020-2021 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import datetime",
            "import errno",
            "import fnmatch",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import traceback",
            "from typing import TYPE_CHECKING, BinaryIO, Iterable, Optional, Tuple",
            "from urllib import parse as urlparse",
            "from urllib.request import urlopen",
            "",
            "import attr",
            "",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.error import DNSLookupError",
            "",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.http.client import SimpleHttpClient",
            "from synapse.http.server import (",
            "    DirectServeJsonResource,",
            "    respond_with_json,",
            "    respond_with_json_bytes,",
            ")",
            "from synapse.http.servlet import parse_integer, parse_string",
            "from synapse.http.site import SynapseRequest",
            "from synapse.logging.context import make_deferred_yieldable, run_in_background",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.rest.media.v1._base import get_filename_from_headers",
            "from synapse.rest.media.v1.media_storage import MediaStorage",
            "from synapse.rest.media.v1.oembed import OEmbedProvider",
            "from synapse.rest.media.v1.preview_html import (",
            "    decode_body,",
            "    parse_html_to_open_graph,",
            "    rebase_url,",
            ")",
            "from synapse.types import JsonDict, UserID",
            "from synapse.util import json_encoder",
            "from synapse.util.async_helpers import ObservableDeferred",
            "from synapse.util.caches.expiringcache import ExpiringCache",
            "from synapse.util.stringutils import random_string",
            "",
            "from ._base import FileInfo",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.rest.media.v1.media_repository import MediaRepository",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "OG_TAG_NAME_MAXLEN = 50",
            "OG_TAG_VALUE_MAXLEN = 1000",
            "",
            "ONE_HOUR = 60 * 60 * 1000",
            "ONE_DAY = 24 * ONE_HOUR",
            "IMAGE_CACHE_EXPIRY_MS = 2 * ONE_DAY",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class DownloadResult:",
            "    length: int",
            "    uri: str",
            "    response_code: int",
            "    media_type: str",
            "    download_name: Optional[str]",
            "    expires: int",
            "    etag: Optional[str]",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class MediaInfo:",
            "    \"\"\"",
            "    Information parsed from downloading media being previewed.",
            "    \"\"\"",
            "",
            "    # The Content-Type header of the response.",
            "    media_type: str",
            "    # The length (in bytes) of the downloaded media.",
            "    media_length: int",
            "    # The media filename, according to the server. This is parsed from the",
            "    # returned headers, if possible.",
            "    download_name: Optional[str]",
            "    # The time of the preview.",
            "    created_ts_ms: int",
            "    # Information from the media storage provider about where the file is stored",
            "    # on disk.",
            "    filesystem_id: str",
            "    filename: str",
            "    # The URI being previewed.",
            "    uri: str",
            "    # The HTTP response code.",
            "    response_code: int",
            "    # The timestamp (in milliseconds) of when this preview expires.",
            "    expires: int",
            "    # The ETag header of the response.",
            "    etag: Optional[str]",
            "",
            "",
            "class PreviewUrlResource(DirectServeJsonResource):",
            "    \"\"\"",
            "    Generating URL previews is a complicated task which many potential pitfalls.",
            "",
            "    See docs/development/url_previews.md for discussion of the design and",
            "    algorithm followed in this module.",
            "    \"\"\"",
            "",
            "    isLeaf = True",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        media_repo: \"MediaRepository\",",
            "        media_storage: MediaStorage,",
            "    ):",
            "        super().__init__()",
            "",
            "        self.auth = hs.get_auth()",
            "        self.clock = hs.get_clock()",
            "        self.filepaths = media_repo.filepaths",
            "        self.max_spider_size = hs.config.media.max_spider_size",
            "        self.server_name = hs.hostname",
            "        self.store = hs.get_datastore()",
            "        self.client = SimpleHttpClient(",
            "            hs,",
            "            treq_args={\"browser_like_redirects\": True},",
            "            ip_whitelist=hs.config.media.url_preview_ip_range_whitelist,",
            "            ip_blacklist=hs.config.media.url_preview_ip_range_blacklist,",
            "            use_proxy=True,",
            "        )",
            "        self.media_repo = media_repo",
            "        self.primary_base_path = media_repo.primary_base_path",
            "        self.media_storage = media_storage",
            "",
            "        self._oembed = OEmbedProvider(hs)",
            "",
            "        # We run the background jobs if we're the instance specified (or no",
            "        # instance is specified, where we assume there is only one instance",
            "        # serving media).",
            "        instance_running_jobs = hs.config.media.media_instance_running_background_jobs",
            "        self._worker_run_media_background_jobs = (",
            "            instance_running_jobs is None",
            "            or instance_running_jobs == hs.get_instance_name()",
            "        )",
            "",
            "        self.url_preview_url_blacklist = hs.config.media.url_preview_url_blacklist",
            "        self.url_preview_accept_language = hs.config.media.url_preview_accept_language",
            "",
            "        # memory cache mapping urls to an ObservableDeferred returning",
            "        # JSON-encoded OG metadata",
            "        self._cache: ExpiringCache[str, ObservableDeferred] = ExpiringCache(",
            "            cache_name=\"url_previews\",",
            "            clock=self.clock,",
            "            # don't spider URLs more often than once an hour",
            "            expiry_ms=ONE_HOUR,",
            "        )",
            "",
            "        if self._worker_run_media_background_jobs:",
            "            self._cleaner_loop = self.clock.looping_call(",
            "                self._start_expire_url_cache_data, 10 * 1000",
            "            )",
            "",
            "    async def _async_render_OPTIONS(self, request: SynapseRequest) -> None:",
            "        request.setHeader(b\"Allow\", b\"OPTIONS, GET\")",
            "        respond_with_json(request, 200, {}, send_cors=True)",
            "",
            "    async def _async_render_GET(self, request: SynapseRequest) -> None:",
            "        # XXX: if get_user_by_req fails, what should we do in an async render?",
            "        requester = await self.auth.get_user_by_req(request)",
            "        url = parse_string(request, \"url\", required=True)",
            "        ts = parse_integer(request, \"ts\")",
            "        if ts is None:",
            "            ts = self.clock.time_msec()",
            "",
            "        # XXX: we could move this into _do_preview if we wanted.",
            "        url_tuple = urlparse.urlsplit(url)",
            "        for entry in self.url_preview_url_blacklist:",
            "            match = True",
            "            for attrib in entry:",
            "                pattern = entry[attrib]",
            "                value = getattr(url_tuple, attrib)",
            "                logger.debug(",
            "                    \"Matching attrib '%s' with value '%s' against pattern '%s'\",",
            "                    attrib,",
            "                    value,",
            "                    pattern,",
            "                )",
            "",
            "                if value is None:",
            "                    match = False",
            "                    continue",
            "",
            "                if pattern.startswith(\"^\"):",
            "                    if not re.match(pattern, getattr(url_tuple, attrib)):",
            "                        match = False",
            "                        continue",
            "                else:",
            "                    if not fnmatch.fnmatch(getattr(url_tuple, attrib), pattern):",
            "                        match = False",
            "                        continue",
            "            if match:",
            "                logger.warning(\"URL %s blocked by url_blacklist entry %s\", url, entry)",
            "                raise SynapseError(",
            "                    403, \"URL blocked by url pattern blacklist entry\", Codes.UNKNOWN",
            "                )",
            "",
            "        # the in-memory cache:",
            "        # * ensures that only one request is active at a time",
            "        # * takes load off the DB for the thundering herds",
            "        # * also caches any failures (unlike the DB) so we don't keep",
            "        #    requesting the same endpoint",
            "",
            "        observable = self._cache.get(url)",
            "",
            "        if not observable:",
            "            download = run_in_background(self._do_preview, url, requester.user, ts)",
            "            observable = ObservableDeferred(download, consumeErrors=True)",
            "            self._cache[url] = observable",
            "        else:",
            "            logger.info(\"Returning cached response\")",
            "",
            "        og = await make_deferred_yieldable(observable.observe())",
            "        respond_with_json_bytes(request, 200, og, send_cors=True)",
            "",
            "    async def _do_preview(self, url: str, user: UserID, ts: int) -> bytes:",
            "        \"\"\"Check the db, and download the URL and build a preview",
            "",
            "        Args:",
            "            url: The URL to preview.",
            "            user: The user requesting the preview.",
            "            ts: The timestamp requested for the preview.",
            "",
            "        Returns:",
            "            json-encoded og data",
            "        \"\"\"",
            "        # check the URL cache in the DB (which will also provide us with",
            "        # historical previews, if we have any)",
            "        cache_result = await self.store.get_url_cache(url, ts)",
            "        if (",
            "            cache_result",
            "            and cache_result[\"expires_ts\"] > ts",
            "            and cache_result[\"response_code\"] / 100 == 2",
            "        ):",
            "            # It may be stored as text in the database, not as bytes (such as",
            "            # PostgreSQL). If so, encode it back before handing it on.",
            "            og = cache_result[\"og\"]",
            "            if isinstance(og, str):",
            "                og = og.encode(\"utf8\")",
            "            return og",
            "",
            "        # If this URL can be accessed via oEmbed, use that instead.",
            "        url_to_download = url",
            "        oembed_url = self._oembed.get_oembed_url(url)",
            "        if oembed_url:",
            "            url_to_download = oembed_url",
            "",
            "        media_info = await self._handle_url(url_to_download, user)",
            "",
            "        logger.debug(\"got media_info of '%s'\", media_info)",
            "",
            "        # The number of milliseconds that the response should be considered valid.",
            "        expiration_ms = media_info.expires",
            "        author_name: Optional[str] = None",
            "",
            "        if _is_media(media_info.media_type):",
            "            file_id = media_info.filesystem_id",
            "            dims = await self.media_repo._generate_thumbnails(",
            "                None, file_id, file_id, media_info.media_type, url_cache=True",
            "            )",
            "",
            "            og = {",
            "                \"og:description\": media_info.download_name,",
            "                \"og:image\": f\"mxc://{self.server_name}/{media_info.filesystem_id}\",",
            "                \"og:image:type\": media_info.media_type,",
            "                \"matrix:image:size\": media_info.media_length,",
            "            }",
            "",
            "            if dims:",
            "                og[\"og:image:width\"] = dims[\"width\"]",
            "                og[\"og:image:height\"] = dims[\"height\"]",
            "            else:",
            "                logger.warning(\"Couldn't get dims for %s\" % url)",
            "",
            "            # define our OG response for this media",
            "        elif _is_html(media_info.media_type):",
            "            # TODO: somehow stop a big HTML tree from exploding synapse's RAM",
            "",
            "            with open(media_info.filename, \"rb\") as file:",
            "                body = file.read()",
            "",
            "            tree = decode_body(body, media_info.uri, media_info.media_type)",
            "            if tree is not None:",
            "                # Check if this HTML document points to oEmbed information and",
            "                # defer to that.",
            "                oembed_url = self._oembed.autodiscover_from_html(tree)",
            "                og_from_oembed: JsonDict = {}",
            "                if oembed_url:",
            "                    oembed_info = await self._handle_url(",
            "                        oembed_url, user, allow_data_urls=True",
            "                    )",
            "                    (",
            "                        og_from_oembed,",
            "                        author_name,",
            "                        expiration_ms,",
            "                    ) = await self._handle_oembed_response(",
            "                        url, oembed_info, expiration_ms",
            "                    )",
            "",
            "                # Parse Open Graph information from the HTML in case the oEmbed",
            "                # response failed or is incomplete.",
            "                og_from_html = parse_html_to_open_graph(tree, media_info.uri)",
            "",
            "                # Compile the Open Graph response by using the scraped",
            "                # information from the HTML and overlaying any information",
            "                # from the oEmbed response.",
            "                og = {**og_from_html, **og_from_oembed}",
            "",
            "                await self._precache_image_url(user, media_info, og)",
            "            else:",
            "                og = {}",
            "",
            "        elif oembed_url:",
            "            # Handle the oEmbed information.",
            "            og, author_name, expiration_ms = await self._handle_oembed_response(",
            "                url, media_info, expiration_ms",
            "            )",
            "            await self._precache_image_url(user, media_info, og)",
            "",
            "        else:",
            "            logger.warning(\"Failed to find any OG data in %s\", url)",
            "            og = {}",
            "",
            "        # If we don't have a title but we have author_name, copy it as",
            "        # title",
            "        if not og.get(\"og:title\") and author_name:",
            "            og[\"og:title\"] = author_name",
            "",
            "        # filter out any stupidly long values",
            "        keys_to_remove = []",
            "        for k, v in og.items():",
            "            # values can be numeric as well as strings, hence the cast to str",
            "            if len(k) > OG_TAG_NAME_MAXLEN or len(str(v)) > OG_TAG_VALUE_MAXLEN:",
            "                logger.warning(",
            "                    \"Pruning overlong tag %s from OG data\", k[:OG_TAG_NAME_MAXLEN]",
            "                )",
            "                keys_to_remove.append(k)",
            "        for k in keys_to_remove:",
            "            del og[k]",
            "",
            "        logger.debug(\"Calculated OG for %s as %s\", url, og)",
            "",
            "        jsonog = json_encoder.encode(og)",
            "",
            "        # Cap the amount of time to consider a response valid.",
            "        expiration_ms = min(expiration_ms, ONE_DAY)",
            "",
            "        # store OG in history-aware DB cache",
            "        await self.store.store_url_cache(",
            "            url,",
            "            media_info.response_code,",
            "            media_info.etag,",
            "            media_info.created_ts_ms + expiration_ms,",
            "            jsonog,",
            "            media_info.filesystem_id,",
            "            media_info.created_ts_ms,",
            "        )",
            "",
            "        return jsonog.encode(\"utf8\")",
            "",
            "    async def _download_url(self, url: str, output_stream: BinaryIO) -> DownloadResult:",
            "        \"\"\"",
            "        Fetches a remote URL and parses the headers.",
            "",
            "        Args:",
            "             url: The URL to fetch.",
            "             output_stream: The stream to write the content to.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                Media length, URL downloaded, the HTTP response code,",
            "                the media type, the downloaded file name, the number of",
            "                milliseconds the result is valid for, the etag header.",
            "        \"\"\"",
            "",
            "        try:",
            "            logger.debug(\"Trying to get preview for url '%s'\", url)",
            "            length, headers, uri, code = await self.client.get_file(",
            "                url,",
            "                output_stream=output_stream,",
            "                max_size=self.max_spider_size,",
            "                headers={\"Accept-Language\": self.url_preview_accept_language},",
            "            )",
            "        except SynapseError:",
            "            # Pass SynapseErrors through directly, so that the servlet",
            "            # handler will return a SynapseError to the client instead of",
            "            # blank data or a 500.",
            "            raise",
            "        except DNSLookupError:",
            "            # DNS lookup returned no results",
            "            # Note: This will also be the case if one of the resolved IP",
            "            # addresses is blacklisted",
            "            raise SynapseError(",
            "                502,",
            "                \"DNS resolution failure during URL preview generation\",",
            "                Codes.UNKNOWN,",
            "            )",
            "        except Exception as e:",
            "            # FIXME: pass through 404s and other error messages nicely",
            "            logger.warning(\"Error downloading %s: %r\", url, e)",
            "",
            "            raise SynapseError(",
            "                500,",
            "                \"Failed to download content: %s\"",
            "                % (traceback.format_exception_only(sys.exc_info()[0], e),),",
            "                Codes.UNKNOWN,",
            "            )",
            "",
            "        if b\"Content-Type\" in headers:",
            "            media_type = headers[b\"Content-Type\"][0].decode(\"ascii\")",
            "        else:",
            "            media_type = \"application/octet-stream\"",
            "",
            "        download_name = get_filename_from_headers(headers)",
            "",
            "        # FIXME: we should calculate a proper expiration based on the",
            "        # Cache-Control and Expire headers.  But for now, assume 1 hour.",
            "        expires = ONE_HOUR",
            "        etag = headers[b\"ETag\"][0].decode(\"ascii\") if b\"ETag\" in headers else None",
            "",
            "        return DownloadResult(",
            "            length, uri, code, media_type, download_name, expires, etag",
            "        )",
            "",
            "    async def _parse_data_url(",
            "        self, url: str, output_stream: BinaryIO",
            "    ) -> DownloadResult:",
            "        \"\"\"",
            "        Parses a data: URL.",
            "",
            "        Args:",
            "             url: The URL to parse.",
            "             output_stream: The stream to write the content to.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                Media length, URL downloaded, the HTTP response code,",
            "                the media type, the downloaded file name, the number of",
            "                milliseconds the result is valid for, the etag header.",
            "        \"\"\"",
            "",
            "        try:",
            "            logger.debug(\"Trying to parse data url '%s'\", url)",
            "            with urlopen(url) as url_info:",
            "                # TODO Can this be more efficient.",
            "                output_stream.write(url_info.read())",
            "        except Exception as e:",
            "            logger.warning(\"Error parsing data: URL %s: %r\", url, e)",
            "",
            "            raise SynapseError(",
            "                500,",
            "                \"Failed to parse data URL: %s\"",
            "                % (traceback.format_exception_only(sys.exc_info()[0], e),),",
            "                Codes.UNKNOWN,",
            "            )",
            "",
            "        return DownloadResult(",
            "            # Read back the length that has been written.",
            "            length=output_stream.tell(),",
            "            uri=url,",
            "            # If it was parsed, consider this a 200 OK.",
            "            response_code=200,",
            "            # urlopen shoves the media-type from the data URL into the content type",
            "            # header object.",
            "            media_type=url_info.headers.get_content_type(),",
            "            # Some features are not supported by data: URLs.",
            "            download_name=None,",
            "            expires=ONE_HOUR,",
            "            etag=None,",
            "        )",
            "",
            "    async def _handle_url(",
            "        self, url: str, user: UserID, allow_data_urls: bool = False",
            "    ) -> MediaInfo:",
            "        \"\"\"",
            "        Fetches content from a URL and parses the result to generate a MediaInfo.",
            "",
            "        It uses the media storage provider to persist the fetched content and",
            "        stores the mapping into the database.",
            "",
            "        Args:",
            "             url: The URL to fetch.",
            "             user: The user who ahs requested this URL.",
            "             allow_data_urls: True if data URLs should be allowed.",
            "",
            "        Returns:",
            "            A MediaInfo object describing the fetched content.",
            "        \"\"\"",
            "",
            "        # TODO: we should probably honour robots.txt... except in practice",
            "        # we're most likely being explicitly triggered by a human rather than a",
            "        # bot, so are we really a robot?",
            "",
            "        file_id = datetime.date.today().isoformat() + \"_\" + random_string(16)",
            "",
            "        file_info = FileInfo(server_name=None, file_id=file_id, url_cache=True)",
            "",
            "        with self.media_storage.store_into_file(file_info) as (f, fname, finish):",
            "            if url.startswith(\"data:\"):",
            "                if not allow_data_urls:",
            "                    raise SynapseError(",
            "                        500, \"Previewing of data: URLs is forbidden\", Codes.UNKNOWN",
            "                    )",
            "",
            "                download_result = await self._parse_data_url(url, f)",
            "            else:",
            "                download_result = await self._download_url(url, f)",
            "",
            "            await finish()",
            "",
            "        try:",
            "            time_now_ms = self.clock.time_msec()",
            "",
            "            await self.store.store_local_media(",
            "                media_id=file_id,",
            "                media_type=download_result.media_type,",
            "                time_now_ms=time_now_ms,",
            "                upload_name=download_result.download_name,",
            "                media_length=download_result.length,",
            "                user_id=user,",
            "                url_cache=url,",
            "            )",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error handling downloaded %s: %r\", url, e)",
            "            # TODO: we really ought to delete the downloaded file in this",
            "            # case, since we won't have recorded it in the db, and will",
            "            # therefore not expire it.",
            "            raise",
            "",
            "        return MediaInfo(",
            "            media_type=download_result.media_type,",
            "            media_length=download_result.length,",
            "            download_name=download_result.download_name,",
            "            created_ts_ms=time_now_ms,",
            "            filesystem_id=file_id,",
            "            filename=fname,",
            "            uri=download_result.uri,",
            "            response_code=download_result.response_code,",
            "            expires=download_result.expires,",
            "            etag=download_result.etag,",
            "        )",
            "",
            "    async def _precache_image_url(",
            "        self, user: UserID, media_info: MediaInfo, og: JsonDict",
            "    ) -> None:",
            "        \"\"\"",
            "        Pre-cache the image (if one exists) for posterity",
            "",
            "        Args:",
            "            user: The user requesting the preview.",
            "            media_info: The media being previewed.",
            "            og: The Open Graph dictionary. This is modified with image information.",
            "        \"\"\"",
            "        # If there's no image or it is blank, there's nothing to do.",
            "        if \"og:image\" not in og or not og[\"og:image\"]:",
            "            return",
            "",
            "        # FIXME: it might be cleaner to use the same flow as the main /preview_url",
            "        # request itself and benefit from the same caching etc.  But for now we",
            "        # just rely on the caching on the master request to speed things up.",
            "        image_info = await self._handle_url(",
            "            rebase_url(og[\"og:image\"], media_info.uri), user, allow_data_urls=True",
            "        )",
            "",
            "        if _is_media(image_info.media_type):",
            "            # TODO: make sure we don't choke on white-on-transparent images",
            "            file_id = image_info.filesystem_id",
            "            dims = await self.media_repo._generate_thumbnails(",
            "                None, file_id, file_id, image_info.media_type, url_cache=True",
            "            )",
            "            if dims:",
            "                og[\"og:image:width\"] = dims[\"width\"]",
            "                og[\"og:image:height\"] = dims[\"height\"]",
            "            else:",
            "                logger.warning(\"Couldn't get dims for %s\", og[\"og:image\"])",
            "",
            "            og[\"og:image\"] = f\"mxc://{self.server_name}/{image_info.filesystem_id}\"",
            "            og[\"og:image:type\"] = image_info.media_type",
            "            og[\"matrix:image:size\"] = image_info.media_length",
            "        else:",
            "            del og[\"og:image\"]",
            "",
            "    async def _handle_oembed_response(",
            "        self, url: str, media_info: MediaInfo, expiration_ms: int",
            "    ) -> Tuple[JsonDict, Optional[str], int]:",
            "        \"\"\"",
            "        Parse the downloaded oEmbed info.",
            "",
            "        Args:",
            "            url: The URL which is being previewed (not the one which was",
            "                requested).",
            "            media_info: The media being previewed.",
            "            expiration_ms: The length of time, in milliseconds, the media is valid for.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                The Open Graph dictionary, if the oEmbed info can be parsed.",
            "                The author name if it could be retrieved from oEmbed.",
            "                The (possibly updated) length of time, in milliseconds, the media is valid for.",
            "        \"\"\"",
            "        # If JSON was not returned, there's nothing to do.",
            "        if not _is_json(media_info.media_type):",
            "            return {}, None, expiration_ms",
            "",
            "        with open(media_info.filename, \"rb\") as file:",
            "            body = file.read()",
            "",
            "        oembed_response = self._oembed.parse_oembed_response(url, body)",
            "        open_graph_result = oembed_response.open_graph_result",
            "",
            "        # Use the cache age from the oEmbed result, if one was given.",
            "        if open_graph_result and oembed_response.cache_age is not None:",
            "            expiration_ms = oembed_response.cache_age",
            "",
            "        return open_graph_result, oembed_response.author_name, expiration_ms",
            "",
            "    def _start_expire_url_cache_data(self) -> Deferred:",
            "        return run_as_background_process(",
            "            \"expire_url_cache_data\", self._expire_url_cache_data",
            "        )",
            "",
            "    async def _expire_url_cache_data(self) -> None:",
            "        \"\"\"Clean up expired url cache content, media and thumbnails.\"\"\"",
            "",
            "        assert self._worker_run_media_background_jobs",
            "",
            "        now = self.clock.time_msec()",
            "",
            "        logger.debug(\"Running url preview cache expiry\")",
            "",
            "        if not (await self.store.db_pool.updates.has_completed_background_updates()):",
            "            logger.info(\"Still running DB updates; skipping expiry\")",
            "            return",
            "",
            "        def try_remove_parent_dirs(dirs: Iterable[str]) -> None:",
            "            \"\"\"Attempt to remove the given chain of parent directories",
            "",
            "            Args:",
            "                dirs: The list of directory paths to delete, with children appearing",
            "                    before their parents.",
            "            \"\"\"",
            "            for dir in dirs:",
            "                try:",
            "                    os.rmdir(dir)",
            "                except FileNotFoundError:",
            "                    # Already deleted, continue with deleting the rest",
            "                    pass",
            "                except OSError as e:",
            "                    # Failed, skip deleting the rest of the parent dirs",
            "                    if e.errno != errno.ENOTEMPTY:",
            "                        logger.warning(",
            "                            \"Failed to remove media directory: %r: %s\", dir, e",
            "                        )",
            "                    break",
            "",
            "        # First we delete expired url cache entries",
            "        media_ids = await self.store.get_expired_url_cache(now)",
            "",
            "        removed_media = []",
            "        for media_id in media_ids:",
            "            fname = self.filepaths.url_cache_filepath(media_id)",
            "            try:",
            "                os.remove(fname)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            removed_media.append(media_id)",
            "",
            "            dirs = self.filepaths.url_cache_filepath_dirs_to_delete(media_id)",
            "            try_remove_parent_dirs(dirs)",
            "",
            "        await self.store.delete_url_cache(removed_media)",
            "",
            "        if removed_media:",
            "            logger.info(\"Deleted %d entries from url cache\", len(removed_media))",
            "        else:",
            "            logger.debug(\"No entries removed from url cache\")",
            "",
            "        # Now we delete old images associated with the url cache.",
            "        # These may be cached for a bit on the client (i.e., they",
            "        # may have a room open with a preview url thing open).",
            "        # So we wait a couple of days before deleting, just in case.",
            "        expire_before = now - IMAGE_CACHE_EXPIRY_MS",
            "        media_ids = await self.store.get_url_cache_media_before(expire_before)",
            "",
            "        removed_media = []",
            "        for media_id in media_ids:",
            "            fname = self.filepaths.url_cache_filepath(media_id)",
            "            try:",
            "                os.remove(fname)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            dirs = self.filepaths.url_cache_filepath_dirs_to_delete(media_id)",
            "            try_remove_parent_dirs(dirs)",
            "",
            "            thumbnail_dir = self.filepaths.url_cache_thumbnail_directory(media_id)",
            "            try:",
            "                shutil.rmtree(thumbnail_dir)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            removed_media.append(media_id)",
            "",
            "            dirs = self.filepaths.url_cache_thumbnail_dirs_to_delete(media_id)",
            "            # Note that one of the directories to be deleted has already been",
            "            # removed by the `rmtree` above.",
            "            try_remove_parent_dirs(dirs)",
            "",
            "        await self.store.delete_url_cache_media(removed_media)",
            "",
            "        if removed_media:",
            "            logger.info(\"Deleted %d media from url cache\", len(removed_media))",
            "        else:",
            "            logger.debug(\"No media removed from url cache\")",
            "",
            "",
            "def _is_media(content_type: str) -> bool:",
            "    return content_type.lower().startswith(\"image/\")",
            "",
            "",
            "def _is_html(content_type: str) -> bool:",
            "    content_type = content_type.lower()",
            "    return content_type.startswith(\"text/html\") or content_type.startswith(",
            "        \"application/xhtml\"",
            "    )",
            "",
            "",
            "def _is_json(content_type: str) -> bool:",
            "    return content_type.lower().startswith(\"application/json\")"
        ],
        "afterPatchFile": [
            "# Copyright 2016 OpenMarket Ltd",
            "# Copyright 2020-2021 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import datetime",
            "import errno",
            "import fnmatch",
            "import logging",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import traceback",
            "from typing import TYPE_CHECKING, BinaryIO, Iterable, Optional, Tuple",
            "from urllib import parse as urlparse",
            "from urllib.request import urlopen",
            "",
            "import attr",
            "",
            "from twisted.internet.defer import Deferred",
            "from twisted.internet.error import DNSLookupError",
            "",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.http.client import SimpleHttpClient",
            "from synapse.http.server import (",
            "    DirectServeJsonResource,",
            "    respond_with_json,",
            "    respond_with_json_bytes,",
            ")",
            "from synapse.http.servlet import parse_integer, parse_string",
            "from synapse.http.site import SynapseRequest",
            "from synapse.logging.context import make_deferred_yieldable, run_in_background",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.rest.media.v1._base import get_filename_from_headers",
            "from synapse.rest.media.v1.media_storage import MediaStorage",
            "from synapse.rest.media.v1.oembed import OEmbedProvider",
            "from synapse.rest.media.v1.preview_html import (",
            "    decode_body,",
            "    parse_html_to_open_graph,",
            "    rebase_url,",
            ")",
            "from synapse.types import JsonDict, UserID",
            "from synapse.util import json_encoder",
            "from synapse.util.async_helpers import ObservableDeferred",
            "from synapse.util.caches.expiringcache import ExpiringCache",
            "from synapse.util.stringutils import random_string",
            "",
            "from ._base import FileInfo",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.rest.media.v1.media_repository import MediaRepository",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "OG_TAG_NAME_MAXLEN = 50",
            "OG_TAG_VALUE_MAXLEN = 1000",
            "",
            "ONE_HOUR = 60 * 60 * 1000",
            "ONE_DAY = 24 * ONE_HOUR",
            "IMAGE_CACHE_EXPIRY_MS = 2 * ONE_DAY",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class DownloadResult:",
            "    length: int",
            "    uri: str",
            "    response_code: int",
            "    media_type: str",
            "    download_name: Optional[str]",
            "    expires: int",
            "    etag: Optional[str]",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class MediaInfo:",
            "    \"\"\"",
            "    Information parsed from downloading media being previewed.",
            "    \"\"\"",
            "",
            "    # The Content-Type header of the response.",
            "    media_type: str",
            "    # The length (in bytes) of the downloaded media.",
            "    media_length: int",
            "    # The media filename, according to the server. This is parsed from the",
            "    # returned headers, if possible.",
            "    download_name: Optional[str]",
            "    # The time of the preview.",
            "    created_ts_ms: int",
            "    # Information from the media storage provider about where the file is stored",
            "    # on disk.",
            "    filesystem_id: str",
            "    filename: str",
            "    # The URI being previewed.",
            "    uri: str",
            "    # The HTTP response code.",
            "    response_code: int",
            "    # The timestamp (in milliseconds) of when this preview expires.",
            "    expires: int",
            "    # The ETag header of the response.",
            "    etag: Optional[str]",
            "",
            "",
            "class PreviewUrlResource(DirectServeJsonResource):",
            "    \"\"\"",
            "    Generating URL previews is a complicated task which many potential pitfalls.",
            "",
            "    See docs/development/url_previews.md for discussion of the design and",
            "    algorithm followed in this module.",
            "    \"\"\"",
            "",
            "    isLeaf = True",
            "",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        media_repo: \"MediaRepository\",",
            "        media_storage: MediaStorage,",
            "    ):",
            "        super().__init__()",
            "",
            "        self.auth = hs.get_auth()",
            "        self.clock = hs.get_clock()",
            "        self.filepaths = media_repo.filepaths",
            "        self.max_spider_size = hs.config.media.max_spider_size",
            "        self.server_name = hs.hostname",
            "        self.store = hs.get_datastore()",
            "        self.client = SimpleHttpClient(",
            "            hs,",
            "            treq_args={\"browser_like_redirects\": True},",
            "            ip_whitelist=hs.config.media.url_preview_ip_range_whitelist,",
            "            ip_blacklist=hs.config.media.url_preview_ip_range_blacklist,",
            "            use_proxy=True,",
            "        )",
            "        self.media_repo = media_repo",
            "        self.primary_base_path = media_repo.primary_base_path",
            "        self.media_storage = media_storage",
            "",
            "        self._oembed = OEmbedProvider(hs)",
            "",
            "        # We run the background jobs if we're the instance specified (or no",
            "        # instance is specified, where we assume there is only one instance",
            "        # serving media).",
            "        instance_running_jobs = hs.config.media.media_instance_running_background_jobs",
            "        self._worker_run_media_background_jobs = (",
            "            instance_running_jobs is None",
            "            or instance_running_jobs == hs.get_instance_name()",
            "        )",
            "",
            "        self.url_preview_url_blacklist = hs.config.media.url_preview_url_blacklist",
            "        self.url_preview_accept_language = hs.config.media.url_preview_accept_language",
            "",
            "        # memory cache mapping urls to an ObservableDeferred returning",
            "        # JSON-encoded OG metadata",
            "        self._cache: ExpiringCache[str, ObservableDeferred] = ExpiringCache(",
            "            cache_name=\"url_previews\",",
            "            clock=self.clock,",
            "            # don't spider URLs more often than once an hour",
            "            expiry_ms=ONE_HOUR,",
            "        )",
            "",
            "        if self._worker_run_media_background_jobs:",
            "            self._cleaner_loop = self.clock.looping_call(",
            "                self._start_expire_url_cache_data, 10 * 1000",
            "            )",
            "",
            "    async def _async_render_OPTIONS(self, request: SynapseRequest) -> None:",
            "        request.setHeader(b\"Allow\", b\"OPTIONS, GET\")",
            "        respond_with_json(request, 200, {}, send_cors=True)",
            "",
            "    async def _async_render_GET(self, request: SynapseRequest) -> None:",
            "        # XXX: if get_user_by_req fails, what should we do in an async render?",
            "        requester = await self.auth.get_user_by_req(request)",
            "        url = parse_string(request, \"url\", required=True)",
            "        ts = parse_integer(request, \"ts\")",
            "        if ts is None:",
            "            ts = self.clock.time_msec()",
            "",
            "        # XXX: we could move this into _do_preview if we wanted.",
            "        url_tuple = urlparse.urlsplit(url)",
            "        for entry in self.url_preview_url_blacklist:",
            "            match = True",
            "            for attrib in entry:",
            "                pattern = entry[attrib]",
            "                value = getattr(url_tuple, attrib)",
            "                logger.debug(",
            "                    \"Matching attrib '%s' with value '%s' against pattern '%s'\",",
            "                    attrib,",
            "                    value,",
            "                    pattern,",
            "                )",
            "",
            "                if value is None:",
            "                    match = False",
            "                    continue",
            "",
            "                if pattern.startswith(\"^\"):",
            "                    if not re.match(pattern, getattr(url_tuple, attrib)):",
            "                        match = False",
            "                        continue",
            "                else:",
            "                    if not fnmatch.fnmatch(getattr(url_tuple, attrib), pattern):",
            "                        match = False",
            "                        continue",
            "            if match:",
            "                logger.warning(\"URL %s blocked by url_blacklist entry %s\", url, entry)",
            "                raise SynapseError(",
            "                    403, \"URL blocked by url pattern blacklist entry\", Codes.UNKNOWN",
            "                )",
            "",
            "        # the in-memory cache:",
            "        # * ensures that only one request is active at a time",
            "        # * takes load off the DB for the thundering herds",
            "        # * also caches any failures (unlike the DB) so we don't keep",
            "        #    requesting the same endpoint",
            "",
            "        observable = self._cache.get(url)",
            "",
            "        if not observable:",
            "            download = run_in_background(self._do_preview, url, requester.user, ts)",
            "            observable = ObservableDeferred(download, consumeErrors=True)",
            "            self._cache[url] = observable",
            "        else:",
            "            logger.info(\"Returning cached response\")",
            "",
            "        og = await make_deferred_yieldable(observable.observe())",
            "        respond_with_json_bytes(request, 200, og, send_cors=True)",
            "",
            "    async def _do_preview(self, url: str, user: UserID, ts: int) -> bytes:",
            "        \"\"\"Check the db, and download the URL and build a preview",
            "",
            "        Args:",
            "            url: The URL to preview.",
            "            user: The user requesting the preview.",
            "            ts: The timestamp requested for the preview.",
            "",
            "        Returns:",
            "            json-encoded og data",
            "        \"\"\"",
            "        # check the URL cache in the DB (which will also provide us with",
            "        # historical previews, if we have any)",
            "        cache_result = await self.store.get_url_cache(url, ts)",
            "        if (",
            "            cache_result",
            "            and cache_result[\"expires_ts\"] > ts",
            "            and cache_result[\"response_code\"] / 100 == 2",
            "        ):",
            "            # It may be stored as text in the database, not as bytes (such as",
            "            # PostgreSQL). If so, encode it back before handing it on.",
            "            og = cache_result[\"og\"]",
            "            if isinstance(og, str):",
            "                og = og.encode(\"utf8\")",
            "            return og",
            "",
            "        # If this URL can be accessed via oEmbed, use that instead.",
            "        url_to_download = url",
            "        oembed_url = self._oembed.get_oembed_url(url)",
            "        if oembed_url:",
            "            url_to_download = oembed_url",
            "",
            "        media_info = await self._handle_url(url_to_download, user)",
            "",
            "        logger.debug(\"got media_info of '%s'\", media_info)",
            "",
            "        # The number of milliseconds that the response should be considered valid.",
            "        expiration_ms = media_info.expires",
            "        author_name: Optional[str] = None",
            "",
            "        if _is_media(media_info.media_type):",
            "            file_id = media_info.filesystem_id",
            "            dims = await self.media_repo._generate_thumbnails(",
            "                None, file_id, file_id, media_info.media_type, url_cache=True",
            "            )",
            "",
            "            og = {",
            "                \"og:description\": media_info.download_name,",
            "                \"og:image\": f\"mxc://{self.server_name}/{media_info.filesystem_id}\",",
            "                \"og:image:type\": media_info.media_type,",
            "                \"matrix:image:size\": media_info.media_length,",
            "            }",
            "",
            "            if dims:",
            "                og[\"og:image:width\"] = dims[\"width\"]",
            "                og[\"og:image:height\"] = dims[\"height\"]",
            "            else:",
            "                logger.warning(\"Couldn't get dims for %s\" % url)",
            "",
            "            # define our OG response for this media",
            "        elif _is_html(media_info.media_type):",
            "            # TODO: somehow stop a big HTML tree from exploding synapse's RAM",
            "",
            "            with open(media_info.filename, \"rb\") as file:",
            "                body = file.read()",
            "",
            "            tree = decode_body(body, media_info.uri, media_info.media_type)",
            "            if tree is not None:",
            "                # Check if this HTML document points to oEmbed information and",
            "                # defer to that.",
            "                oembed_url = self._oembed.autodiscover_from_html(tree)",
            "                og_from_oembed: JsonDict = {}",
            "                if oembed_url:",
            "                    oembed_info = await self._handle_url(",
            "                        oembed_url, user, allow_data_urls=True",
            "                    )",
            "                    (",
            "                        og_from_oembed,",
            "                        author_name,",
            "                        expiration_ms,",
            "                    ) = await self._handle_oembed_response(",
            "                        url, oembed_info, expiration_ms",
            "                    )",
            "",
            "                # Parse Open Graph information from the HTML in case the oEmbed",
            "                # response failed or is incomplete.",
            "                og_from_html = parse_html_to_open_graph(tree, media_info.uri)",
            "",
            "                # Compile the Open Graph response by using the scraped",
            "                # information from the HTML and overlaying any information",
            "                # from the oEmbed response.",
            "                og = {**og_from_html, **og_from_oembed}",
            "",
            "                await self._precache_image_url(user, media_info, og)",
            "            else:",
            "                og = {}",
            "",
            "        elif oembed_url:",
            "            # Handle the oEmbed information.",
            "            og, author_name, expiration_ms = await self._handle_oembed_response(",
            "                url, media_info, expiration_ms",
            "            )",
            "            await self._precache_image_url(user, media_info, og)",
            "",
            "        else:",
            "            logger.warning(\"Failed to find any OG data in %s\", url)",
            "            og = {}",
            "",
            "        # If we don't have a title but we have author_name, copy it as",
            "        # title",
            "        if not og.get(\"og:title\") and author_name:",
            "            og[\"og:title\"] = author_name",
            "",
            "        # filter out any stupidly long values",
            "        keys_to_remove = []",
            "        for k, v in og.items():",
            "            # values can be numeric as well as strings, hence the cast to str",
            "            if len(k) > OG_TAG_NAME_MAXLEN or len(str(v)) > OG_TAG_VALUE_MAXLEN:",
            "                logger.warning(",
            "                    \"Pruning overlong tag %s from OG data\", k[:OG_TAG_NAME_MAXLEN]",
            "                )",
            "                keys_to_remove.append(k)",
            "        for k in keys_to_remove:",
            "            del og[k]",
            "",
            "        logger.debug(\"Calculated OG for %s as %s\", url, og)",
            "",
            "        jsonog = json_encoder.encode(og)",
            "",
            "        # Cap the amount of time to consider a response valid.",
            "        expiration_ms = min(expiration_ms, ONE_DAY)",
            "",
            "        # store OG in history-aware DB cache",
            "        await self.store.store_url_cache(",
            "            url,",
            "            media_info.response_code,",
            "            media_info.etag,",
            "            media_info.created_ts_ms + expiration_ms,",
            "            jsonog,",
            "            media_info.filesystem_id,",
            "            media_info.created_ts_ms,",
            "        )",
            "",
            "        return jsonog.encode(\"utf8\")",
            "",
            "    async def _download_url(self, url: str, output_stream: BinaryIO) -> DownloadResult:",
            "        \"\"\"",
            "        Fetches a remote URL and parses the headers.",
            "",
            "        Args:",
            "             url: The URL to fetch.",
            "             output_stream: The stream to write the content to.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                Media length, URL downloaded, the HTTP response code,",
            "                the media type, the downloaded file name, the number of",
            "                milliseconds the result is valid for, the etag header.",
            "        \"\"\"",
            "",
            "        try:",
            "            logger.debug(\"Trying to get preview for url '%s'\", url)",
            "            length, headers, uri, code = await self.client.get_file(",
            "                url,",
            "                output_stream=output_stream,",
            "                max_size=self.max_spider_size,",
            "                headers={\"Accept-Language\": self.url_preview_accept_language},",
            "                is_allowed_content_type=_is_previewable,",
            "            )",
            "        except SynapseError:",
            "            # Pass SynapseErrors through directly, so that the servlet",
            "            # handler will return a SynapseError to the client instead of",
            "            # blank data or a 500.",
            "            raise",
            "        except DNSLookupError:",
            "            # DNS lookup returned no results",
            "            # Note: This will also be the case if one of the resolved IP",
            "            # addresses is blacklisted",
            "            raise SynapseError(",
            "                502,",
            "                \"DNS resolution failure during URL preview generation\",",
            "                Codes.UNKNOWN,",
            "            )",
            "        except Exception as e:",
            "            # FIXME: pass through 404s and other error messages nicely",
            "            logger.warning(\"Error downloading %s: %r\", url, e)",
            "",
            "            raise SynapseError(",
            "                500,",
            "                \"Failed to download content: %s\"",
            "                % (traceback.format_exception_only(sys.exc_info()[0], e),),",
            "                Codes.UNKNOWN,",
            "            )",
            "",
            "        if b\"Content-Type\" in headers:",
            "            media_type = headers[b\"Content-Type\"][0].decode(\"ascii\")",
            "        else:",
            "            media_type = \"application/octet-stream\"",
            "",
            "        download_name = get_filename_from_headers(headers)",
            "",
            "        # FIXME: we should calculate a proper expiration based on the",
            "        # Cache-Control and Expire headers.  But for now, assume 1 hour.",
            "        expires = ONE_HOUR",
            "        etag = headers[b\"ETag\"][0].decode(\"ascii\") if b\"ETag\" in headers else None",
            "",
            "        return DownloadResult(",
            "            length, uri, code, media_type, download_name, expires, etag",
            "        )",
            "",
            "    async def _parse_data_url(",
            "        self, url: str, output_stream: BinaryIO",
            "    ) -> DownloadResult:",
            "        \"\"\"",
            "        Parses a data: URL.",
            "",
            "        Args:",
            "             url: The URL to parse.",
            "             output_stream: The stream to write the content to.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                Media length, URL downloaded, the HTTP response code,",
            "                the media type, the downloaded file name, the number of",
            "                milliseconds the result is valid for, the etag header.",
            "        \"\"\"",
            "",
            "        try:",
            "            logger.debug(\"Trying to parse data url '%s'\", url)",
            "            with urlopen(url) as url_info:",
            "                # TODO Can this be more efficient.",
            "                output_stream.write(url_info.read())",
            "        except Exception as e:",
            "            logger.warning(\"Error parsing data: URL %s: %r\", url, e)",
            "",
            "            raise SynapseError(",
            "                500,",
            "                \"Failed to parse data URL: %s\"",
            "                % (traceback.format_exception_only(sys.exc_info()[0], e),),",
            "                Codes.UNKNOWN,",
            "            )",
            "",
            "        return DownloadResult(",
            "            # Read back the length that has been written.",
            "            length=output_stream.tell(),",
            "            uri=url,",
            "            # If it was parsed, consider this a 200 OK.",
            "            response_code=200,",
            "            # urlopen shoves the media-type from the data URL into the content type",
            "            # header object.",
            "            media_type=url_info.headers.get_content_type(),",
            "            # Some features are not supported by data: URLs.",
            "            download_name=None,",
            "            expires=ONE_HOUR,",
            "            etag=None,",
            "        )",
            "",
            "    async def _handle_url(",
            "        self, url: str, user: UserID, allow_data_urls: bool = False",
            "    ) -> MediaInfo:",
            "        \"\"\"",
            "        Fetches content from a URL and parses the result to generate a MediaInfo.",
            "",
            "        It uses the media storage provider to persist the fetched content and",
            "        stores the mapping into the database.",
            "",
            "        Args:",
            "             url: The URL to fetch.",
            "             user: The user who ahs requested this URL.",
            "             allow_data_urls: True if data URLs should be allowed.",
            "",
            "        Returns:",
            "            A MediaInfo object describing the fetched content.",
            "        \"\"\"",
            "",
            "        # TODO: we should probably honour robots.txt... except in practice",
            "        # we're most likely being explicitly triggered by a human rather than a",
            "        # bot, so are we really a robot?",
            "",
            "        file_id = datetime.date.today().isoformat() + \"_\" + random_string(16)",
            "",
            "        file_info = FileInfo(server_name=None, file_id=file_id, url_cache=True)",
            "",
            "        with self.media_storage.store_into_file(file_info) as (f, fname, finish):",
            "            if url.startswith(\"data:\"):",
            "                if not allow_data_urls:",
            "                    raise SynapseError(",
            "                        500, \"Previewing of data: URLs is forbidden\", Codes.UNKNOWN",
            "                    )",
            "",
            "                download_result = await self._parse_data_url(url, f)",
            "            else:",
            "                download_result = await self._download_url(url, f)",
            "",
            "            await finish()",
            "",
            "        try:",
            "            time_now_ms = self.clock.time_msec()",
            "",
            "            await self.store.store_local_media(",
            "                media_id=file_id,",
            "                media_type=download_result.media_type,",
            "                time_now_ms=time_now_ms,",
            "                upload_name=download_result.download_name,",
            "                media_length=download_result.length,",
            "                user_id=user,",
            "                url_cache=url,",
            "            )",
            "",
            "        except Exception as e:",
            "            logger.error(\"Error handling downloaded %s: %r\", url, e)",
            "            # TODO: we really ought to delete the downloaded file in this",
            "            # case, since we won't have recorded it in the db, and will",
            "            # therefore not expire it.",
            "            raise",
            "",
            "        return MediaInfo(",
            "            media_type=download_result.media_type,",
            "            media_length=download_result.length,",
            "            download_name=download_result.download_name,",
            "            created_ts_ms=time_now_ms,",
            "            filesystem_id=file_id,",
            "            filename=fname,",
            "            uri=download_result.uri,",
            "            response_code=download_result.response_code,",
            "            expires=download_result.expires,",
            "            etag=download_result.etag,",
            "        )",
            "",
            "    async def _precache_image_url(",
            "        self, user: UserID, media_info: MediaInfo, og: JsonDict",
            "    ) -> None:",
            "        \"\"\"",
            "        Pre-cache the image (if one exists) for posterity",
            "",
            "        Args:",
            "            user: The user requesting the preview.",
            "            media_info: The media being previewed.",
            "            og: The Open Graph dictionary. This is modified with image information.",
            "        \"\"\"",
            "        # If there's no image or it is blank, there's nothing to do.",
            "        if \"og:image\" not in og or not og[\"og:image\"]:",
            "            return",
            "",
            "        # FIXME: it might be cleaner to use the same flow as the main /preview_url",
            "        # request itself and benefit from the same caching etc.  But for now we",
            "        # just rely on the caching on the master request to speed things up.",
            "        image_info = await self._handle_url(",
            "            rebase_url(og[\"og:image\"], media_info.uri), user, allow_data_urls=True",
            "        )",
            "",
            "        if _is_media(image_info.media_type):",
            "            # TODO: make sure we don't choke on white-on-transparent images",
            "            file_id = image_info.filesystem_id",
            "            dims = await self.media_repo._generate_thumbnails(",
            "                None, file_id, file_id, image_info.media_type, url_cache=True",
            "            )",
            "            if dims:",
            "                og[\"og:image:width\"] = dims[\"width\"]",
            "                og[\"og:image:height\"] = dims[\"height\"]",
            "            else:",
            "                logger.warning(\"Couldn't get dims for %s\", og[\"og:image\"])",
            "",
            "            og[\"og:image\"] = f\"mxc://{self.server_name}/{image_info.filesystem_id}\"",
            "            og[\"og:image:type\"] = image_info.media_type",
            "            og[\"matrix:image:size\"] = image_info.media_length",
            "        else:",
            "            del og[\"og:image\"]",
            "",
            "    async def _handle_oembed_response(",
            "        self, url: str, media_info: MediaInfo, expiration_ms: int",
            "    ) -> Tuple[JsonDict, Optional[str], int]:",
            "        \"\"\"",
            "        Parse the downloaded oEmbed info.",
            "",
            "        Args:",
            "            url: The URL which is being previewed (not the one which was",
            "                requested).",
            "            media_info: The media being previewed.",
            "            expiration_ms: The length of time, in milliseconds, the media is valid for.",
            "",
            "        Returns:",
            "            A tuple of:",
            "                The Open Graph dictionary, if the oEmbed info can be parsed.",
            "                The author name if it could be retrieved from oEmbed.",
            "                The (possibly updated) length of time, in milliseconds, the media is valid for.",
            "        \"\"\"",
            "        # If JSON was not returned, there's nothing to do.",
            "        if not _is_json(media_info.media_type):",
            "            return {}, None, expiration_ms",
            "",
            "        with open(media_info.filename, \"rb\") as file:",
            "            body = file.read()",
            "",
            "        oembed_response = self._oembed.parse_oembed_response(url, body)",
            "        open_graph_result = oembed_response.open_graph_result",
            "",
            "        # Use the cache age from the oEmbed result, if one was given.",
            "        if open_graph_result and oembed_response.cache_age is not None:",
            "            expiration_ms = oembed_response.cache_age",
            "",
            "        return open_graph_result, oembed_response.author_name, expiration_ms",
            "",
            "    def _start_expire_url_cache_data(self) -> Deferred:",
            "        return run_as_background_process(",
            "            \"expire_url_cache_data\", self._expire_url_cache_data",
            "        )",
            "",
            "    async def _expire_url_cache_data(self) -> None:",
            "        \"\"\"Clean up expired url cache content, media and thumbnails.\"\"\"",
            "",
            "        assert self._worker_run_media_background_jobs",
            "",
            "        now = self.clock.time_msec()",
            "",
            "        logger.debug(\"Running url preview cache expiry\")",
            "",
            "        if not (await self.store.db_pool.updates.has_completed_background_updates()):",
            "            logger.info(\"Still running DB updates; skipping expiry\")",
            "            return",
            "",
            "        def try_remove_parent_dirs(dirs: Iterable[str]) -> None:",
            "            \"\"\"Attempt to remove the given chain of parent directories",
            "",
            "            Args:",
            "                dirs: The list of directory paths to delete, with children appearing",
            "                    before their parents.",
            "            \"\"\"",
            "            for dir in dirs:",
            "                try:",
            "                    os.rmdir(dir)",
            "                except FileNotFoundError:",
            "                    # Already deleted, continue with deleting the rest",
            "                    pass",
            "                except OSError as e:",
            "                    # Failed, skip deleting the rest of the parent dirs",
            "                    if e.errno != errno.ENOTEMPTY:",
            "                        logger.warning(",
            "                            \"Failed to remove media directory: %r: %s\", dir, e",
            "                        )",
            "                    break",
            "",
            "        # First we delete expired url cache entries",
            "        media_ids = await self.store.get_expired_url_cache(now)",
            "",
            "        removed_media = []",
            "        for media_id in media_ids:",
            "            fname = self.filepaths.url_cache_filepath(media_id)",
            "            try:",
            "                os.remove(fname)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            removed_media.append(media_id)",
            "",
            "            dirs = self.filepaths.url_cache_filepath_dirs_to_delete(media_id)",
            "            try_remove_parent_dirs(dirs)",
            "",
            "        await self.store.delete_url_cache(removed_media)",
            "",
            "        if removed_media:",
            "            logger.info(\"Deleted %d entries from url cache\", len(removed_media))",
            "        else:",
            "            logger.debug(\"No entries removed from url cache\")",
            "",
            "        # Now we delete old images associated with the url cache.",
            "        # These may be cached for a bit on the client (i.e., they",
            "        # may have a room open with a preview url thing open).",
            "        # So we wait a couple of days before deleting, just in case.",
            "        expire_before = now - IMAGE_CACHE_EXPIRY_MS",
            "        media_ids = await self.store.get_url_cache_media_before(expire_before)",
            "",
            "        removed_media = []",
            "        for media_id in media_ids:",
            "            fname = self.filepaths.url_cache_filepath(media_id)",
            "            try:",
            "                os.remove(fname)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            dirs = self.filepaths.url_cache_filepath_dirs_to_delete(media_id)",
            "            try_remove_parent_dirs(dirs)",
            "",
            "            thumbnail_dir = self.filepaths.url_cache_thumbnail_directory(media_id)",
            "            try:",
            "                shutil.rmtree(thumbnail_dir)",
            "            except FileNotFoundError:",
            "                pass  # If the path doesn't exist, meh",
            "            except OSError as e:",
            "                logger.warning(\"Failed to remove media: %r: %s\", media_id, e)",
            "                continue",
            "",
            "            removed_media.append(media_id)",
            "",
            "            dirs = self.filepaths.url_cache_thumbnail_dirs_to_delete(media_id)",
            "            # Note that one of the directories to be deleted has already been",
            "            # removed by the `rmtree` above.",
            "            try_remove_parent_dirs(dirs)",
            "",
            "        await self.store.delete_url_cache_media(removed_media)",
            "",
            "        if removed_media:",
            "            logger.info(\"Deleted %d media from url cache\", len(removed_media))",
            "        else:",
            "            logger.debug(\"No media removed from url cache\")",
            "",
            "",
            "def _is_media(content_type: str) -> bool:",
            "    return content_type.lower().startswith(\"image/\")",
            "",
            "",
            "def _is_html(content_type: str) -> bool:",
            "    content_type = content_type.lower()",
            "    return content_type.startswith(\"text/html\") or content_type.startswith(",
            "        \"application/xhtml\"",
            "    )",
            "",
            "",
            "def _is_json(content_type: str) -> bool:",
            "    return content_type.lower().startswith(\"application/json\")",
            "",
            "",
            "def _is_previewable(content_type: str) -> bool:",
            "    \"\"\"Returns True for content types for which we will perform URL preview and False",
            "    otherwise.\"\"\"",
            "",
            "    return _is_html(content_type) or _is_media(content_type) or _is_json(content_type)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "synapse.rest.media.v1.preview_url_resource.PreviewUrlResource.self"
        ]
    }
}