{
    "synapse/handlers/receipts.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         self.server_name = hs.config.server.server_name"
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         self.store = hs.get_datastores().main"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         self.event_auth_handler = hs.get_event_auth_handler()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        self.event_handler = hs.get_event_handler()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        self._storage_controllers = hs.get_storage_controllers()"
            },
            "5": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self.hs = hs"
            },
            "7": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "                 )"
            },
            "9": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "                 continue"
            },
            "10": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            # Let's check that the origin server is in the room before accepting the receipt."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            # We don't want to block waiting on a partial state so take an"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            # approximation if needed."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            domains = await self._storage_controllers.state.get_current_hosts_in_room_or_partial_state_approximation("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                room_id"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            )"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            if origin not in domains:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                logger.info("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                    \"Ignoring receipt for room %r from server %s as they're not in the room\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                    room_id,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                    origin,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                )"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                continue"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "             for receipt_type, users in room_values.items():"
            },
            "26": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "                 for user_id, user_values in users.items():"
            },
            "27": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "                     if get_domain_from_id(user_id) != origin:"
            },
            "28": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         self,"
            },
            "29": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         room_id: str,"
            },
            "30": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         receipt_type: str,"
            },
            "31": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_id: str,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        user_id: UserID,"
            },
            "33": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         event_id: str,"
            },
            "34": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         thread_id: Optional[str],"
            },
            "35": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     ) -> None:"
            },
            "36": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         \"\"\"Called when a client tells us a local user has read up to the given"
            },
            "37": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         event_id in the room."
            },
            "38": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         \"\"\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        # Ensure the room/event exists, this will raise an error if the user"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        # cannot view the event."
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        if not await self.event_handler.get_event(user_id, room_id, event_id):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            return"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         receipt = ReadReceipt("
            },
            "46": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "             room_id=room_id,"
            },
            "47": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "             receipt_type=receipt_type,"
            },
            "48": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_id=user_id,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            user_id=user_id.to_string(),"
            },
            "50": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "             event_ids=[event_id],"
            },
            "51": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "             thread_id=thread_id,"
            },
            "52": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "             data={\"ts\": int(self.clock.time_msec())},"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "from typing import TYPE_CHECKING, Iterable, List, Optional, Sequence, Tuple",
            "",
            "from synapse.api.constants import EduTypes, ReceiptTypes",
            "from synapse.appservice import ApplicationService",
            "from synapse.streams import EventSource",
            "from synapse.types import (",
            "    JsonDict,",
            "    ReadReceipt,",
            "    StreamKeyType,",
            "    UserID,",
            "    get_domain_from_id,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReceiptsHandler:",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.notifier = hs.get_notifier()",
            "        self.server_name = hs.config.server.server_name",
            "        self.store = hs.get_datastores().main",
            "        self.event_auth_handler = hs.get_event_auth_handler()",
            "",
            "        self.hs = hs",
            "",
            "        # We only need to poke the federation sender explicitly if its on the",
            "        # same instance. Other federation sender instances will get notified by",
            "        # `synapse.app.generic_worker.FederationSenderHandler` when it sees it",
            "        # in the receipts stream.",
            "        self.federation_sender = None",
            "        if hs.should_send_federation():",
            "            self.federation_sender = hs.get_federation_sender()",
            "",
            "        # If we can handle the receipt EDUs we do so, otherwise we route them",
            "        # to the appropriate worker.",
            "        if hs.get_instance_name() in hs.config.worker.writers.receipts:",
            "            hs.get_federation_registry().register_edu_handler(",
            "                EduTypes.RECEIPT, self._received_remote_receipt",
            "            )",
            "        else:",
            "            hs.get_federation_registry().register_instances_for_edu(",
            "                EduTypes.RECEIPT,",
            "                hs.config.worker.writers.receipts,",
            "            )",
            "",
            "        self.clock = self.hs.get_clock()",
            "        self.state = hs.get_state_handler()",
            "",
            "    async def _received_remote_receipt(self, origin: str, content: JsonDict) -> None:",
            "        \"\"\"Called when we receive an EDU of type m.receipt from a remote HS.\"\"\"",
            "        receipts = []",
            "        for room_id, room_values in content.items():",
            "            # If we're not in the room just ditch the event entirely. This is",
            "            # probably an old server that has come back and thinks we're still in",
            "            # the room (or we've been rejoined to the room by a state reset).",
            "            is_in_room = await self.event_auth_handler.is_host_in_room(",
            "                room_id, self.server_name",
            "            )",
            "            if not is_in_room:",
            "                logger.info(",
            "                    \"Ignoring receipt for room %r from server %s as we're not in the room\",",
            "                    room_id,",
            "                    origin,",
            "                )",
            "                continue",
            "",
            "            for receipt_type, users in room_values.items():",
            "                for user_id, user_values in users.items():",
            "                    if get_domain_from_id(user_id) != origin:",
            "                        logger.info(",
            "                            \"Received receipt for user %r from server %s, ignoring\",",
            "                            user_id,",
            "                            origin,",
            "                        )",
            "                        continue",
            "",
            "                    # Check if these receipts apply to a thread.",
            "                    data = user_values.get(\"data\", {})",
            "                    thread_id = data.get(\"thread_id\")",
            "                    # If the thread ID is invalid, consider it missing.",
            "                    if not isinstance(thread_id, str):",
            "                        thread_id = None",
            "",
            "                    receipts.append(",
            "                        ReadReceipt(",
            "                            room_id=room_id,",
            "                            receipt_type=receipt_type,",
            "                            user_id=user_id,",
            "                            event_ids=user_values[\"event_ids\"],",
            "                            thread_id=thread_id,",
            "                            data=data,",
            "                        )",
            "                    )",
            "",
            "        await self._handle_new_receipts(receipts)",
            "",
            "    async def _handle_new_receipts(self, receipts: List[ReadReceipt]) -> bool:",
            "        \"\"\"Takes a list of receipts, stores them and informs the notifier.\"\"\"",
            "        min_batch_id: Optional[int] = None",
            "        max_batch_id: Optional[int] = None",
            "",
            "        for receipt in receipts:",
            "            res = await self.store.insert_receipt(",
            "                receipt.room_id,",
            "                receipt.receipt_type,",
            "                receipt.user_id,",
            "                receipt.event_ids,",
            "                receipt.thread_id,",
            "                receipt.data,",
            "            )",
            "",
            "            if not res:",
            "                # res will be None if this receipt is 'old'",
            "                continue",
            "",
            "            stream_id, max_persisted_id = res",
            "",
            "            if min_batch_id is None or stream_id < min_batch_id:",
            "                min_batch_id = stream_id",
            "            if max_batch_id is None or max_persisted_id > max_batch_id:",
            "                max_batch_id = max_persisted_id",
            "",
            "        # Either both of these should be None or neither.",
            "        if min_batch_id is None or max_batch_id is None:",
            "            # no new receipts",
            "            return False",
            "",
            "        affected_room_ids = list({r.room_id for r in receipts})",
            "",
            "        self.notifier.on_new_event(",
            "            StreamKeyType.RECEIPT, max_batch_id, rooms=affected_room_ids",
            "        )",
            "        # Note that the min here shouldn't be relied upon to be accurate.",
            "        await self.hs.get_pusherpool().on_new_receipts(",
            "            min_batch_id, max_batch_id, affected_room_ids",
            "        )",
            "",
            "        return True",
            "",
            "    async def received_client_receipt(",
            "        self,",
            "        room_id: str,",
            "        receipt_type: str,",
            "        user_id: str,",
            "        event_id: str,",
            "        thread_id: Optional[str],",
            "    ) -> None:",
            "        \"\"\"Called when a client tells us a local user has read up to the given",
            "        event_id in the room.",
            "        \"\"\"",
            "        receipt = ReadReceipt(",
            "            room_id=room_id,",
            "            receipt_type=receipt_type,",
            "            user_id=user_id,",
            "            event_ids=[event_id],",
            "            thread_id=thread_id,",
            "            data={\"ts\": int(self.clock.time_msec())},",
            "        )",
            "",
            "        is_new = await self._handle_new_receipts([receipt])",
            "        if not is_new:",
            "            return",
            "",
            "        if self.federation_sender and receipt_type != ReceiptTypes.READ_PRIVATE:",
            "            await self.federation_sender.send_read_receipt(receipt)",
            "",
            "",
            "class ReceiptEventSource(EventSource[int, JsonDict]):",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.store = hs.get_datastores().main",
            "        self.config = hs.config",
            "",
            "    @staticmethod",
            "    def filter_out_private_receipts(",
            "        rooms: Sequence[JsonDict], user_id: str",
            "    ) -> List[JsonDict]:",
            "        \"\"\"",
            "        Filters a list of serialized receipts (as returned by /sync and /initialSync)",
            "        and removes private read receipts of other users.",
            "",
            "        This operates on the return value of get_linearized_receipts_for_rooms(),",
            "        which is wrapped in a cache. Care must be taken to ensure that the input",
            "        values are not modified.",
            "",
            "        Args:",
            "            rooms: A list of mappings, each mapping has a `content` field, which",
            "                is a map of event ID -> receipt type -> user ID -> receipt information.",
            "",
            "        Returns:",
            "            The same as rooms, but filtered.",
            "        \"\"\"",
            "",
            "        result = []",
            "",
            "        # Iterate through each room's receipt content.",
            "        for room in rooms:",
            "            # The receipt content with other user's private read receipts removed.",
            "            content = {}",
            "",
            "            # Iterate over each event ID / receipts for that event.",
            "            for event_id, orig_event_content in room.get(\"content\", {}).items():",
            "                event_content = orig_event_content",
            "                # If there are private read receipts, additional logic is necessary.",
            "                if ReceiptTypes.READ_PRIVATE in event_content:",
            "                    # Make a copy without private read receipts to avoid leaking",
            "                    # other user's private read receipts..",
            "                    event_content = {",
            "                        receipt_type: receipt_value",
            "                        for receipt_type, receipt_value in event_content.items()",
            "                        if receipt_type != ReceiptTypes.READ_PRIVATE",
            "                    }",
            "",
            "                    # Copy the current user's private read receipt from the",
            "                    # original content, if it exists.",
            "                    user_private_read_receipt = orig_event_content[",
            "                        ReceiptTypes.READ_PRIVATE",
            "                    ].get(user_id, None)",
            "                    if user_private_read_receipt:",
            "                        event_content[ReceiptTypes.READ_PRIVATE] = {",
            "                            user_id: user_private_read_receipt",
            "                        }",
            "",
            "                # Include the event if there is at least one non-private read",
            "                # receipt or the current user has a private read receipt.",
            "                if event_content:",
            "                    content[event_id] = event_content",
            "",
            "            # Include the event if there is at least one non-private read receipt",
            "            # or the current user has a private read receipt.",
            "            if content:",
            "                # Build a new event to avoid mutating the cache.",
            "                new_room = {k: v for k, v in room.items() if k != \"content\"}",
            "                new_room[\"content\"] = content",
            "                result.append(new_room)",
            "",
            "        return result",
            "",
            "    async def get_new_events(",
            "        self,",
            "        user: UserID,",
            "        from_key: int,",
            "        limit: int,",
            "        room_ids: Iterable[str],",
            "        is_guest: bool,",
            "        explicit_room_id: Optional[str] = None,",
            "    ) -> Tuple[List[JsonDict], int]:",
            "        from_key = int(from_key)",
            "        to_key = self.get_current_key()",
            "",
            "        if from_key == to_key:",
            "            return [], to_key",
            "",
            "        events = await self.store.get_linearized_receipts_for_rooms(",
            "            room_ids, from_key=from_key, to_key=to_key",
            "        )",
            "",
            "        events = ReceiptEventSource.filter_out_private_receipts(",
            "            events, user.to_string()",
            "        )",
            "",
            "        return events, to_key",
            "",
            "    async def get_new_events_as(",
            "        self, from_key: int, to_key: int, service: ApplicationService",
            "    ) -> Tuple[List[JsonDict], int]:",
            "        \"\"\"Returns a set of new read receipt events that an appservice",
            "        may be interested in.",
            "",
            "        Args:",
            "            from_key: the stream position at which events should be fetched from",
            "            to_key: the stream position up to which events should be fetched to",
            "            service: The appservice which may be interested",
            "",
            "        Returns:",
            "            A two-tuple containing the following:",
            "                * A list of json dictionaries derived from read receipts that the",
            "                  appservice may be interested in.",
            "                * The current read receipt stream token.",
            "        \"\"\"",
            "        from_key = int(from_key)",
            "",
            "        if from_key == to_key:",
            "            return [], to_key",
            "",
            "        # Fetch all read receipts for all rooms, up to a limit of 100. This is ordered",
            "        # by most recent.",
            "        rooms_to_events = await self.store.get_linearized_receipts_for_all_rooms(",
            "            from_key=from_key, to_key=to_key",
            "        )",
            "",
            "        # Then filter down to rooms that the AS can read",
            "        events = []",
            "        for room_id, event in rooms_to_events.items():",
            "            if not await service.is_interested_in_room(room_id, self.store):",
            "                continue",
            "",
            "            events.append(event)",
            "",
            "        return events, to_key",
            "",
            "    def get_current_key(self) -> int:",
            "        return self.store.get_max_receipt_stream_id()"
        ],
        "afterPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "from typing import TYPE_CHECKING, Iterable, List, Optional, Sequence, Tuple",
            "",
            "from synapse.api.constants import EduTypes, ReceiptTypes",
            "from synapse.appservice import ApplicationService",
            "from synapse.streams import EventSource",
            "from synapse.types import (",
            "    JsonDict,",
            "    ReadReceipt,",
            "    StreamKeyType,",
            "    UserID,",
            "    get_domain_from_id,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReceiptsHandler:",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.notifier = hs.get_notifier()",
            "        self.server_name = hs.config.server.server_name",
            "        self.store = hs.get_datastores().main",
            "        self.event_auth_handler = hs.get_event_auth_handler()",
            "        self.event_handler = hs.get_event_handler()",
            "        self._storage_controllers = hs.get_storage_controllers()",
            "",
            "        self.hs = hs",
            "",
            "        # We only need to poke the federation sender explicitly if its on the",
            "        # same instance. Other federation sender instances will get notified by",
            "        # `synapse.app.generic_worker.FederationSenderHandler` when it sees it",
            "        # in the receipts stream.",
            "        self.federation_sender = None",
            "        if hs.should_send_federation():",
            "            self.federation_sender = hs.get_federation_sender()",
            "",
            "        # If we can handle the receipt EDUs we do so, otherwise we route them",
            "        # to the appropriate worker.",
            "        if hs.get_instance_name() in hs.config.worker.writers.receipts:",
            "            hs.get_federation_registry().register_edu_handler(",
            "                EduTypes.RECEIPT, self._received_remote_receipt",
            "            )",
            "        else:",
            "            hs.get_federation_registry().register_instances_for_edu(",
            "                EduTypes.RECEIPT,",
            "                hs.config.worker.writers.receipts,",
            "            )",
            "",
            "        self.clock = self.hs.get_clock()",
            "        self.state = hs.get_state_handler()",
            "",
            "    async def _received_remote_receipt(self, origin: str, content: JsonDict) -> None:",
            "        \"\"\"Called when we receive an EDU of type m.receipt from a remote HS.\"\"\"",
            "        receipts = []",
            "        for room_id, room_values in content.items():",
            "            # If we're not in the room just ditch the event entirely. This is",
            "            # probably an old server that has come back and thinks we're still in",
            "            # the room (or we've been rejoined to the room by a state reset).",
            "            is_in_room = await self.event_auth_handler.is_host_in_room(",
            "                room_id, self.server_name",
            "            )",
            "            if not is_in_room:",
            "                logger.info(",
            "                    \"Ignoring receipt for room %r from server %s as we're not in the room\",",
            "                    room_id,",
            "                    origin,",
            "                )",
            "                continue",
            "",
            "            # Let's check that the origin server is in the room before accepting the receipt.",
            "            # We don't want to block waiting on a partial state so take an",
            "            # approximation if needed.",
            "            domains = await self._storage_controllers.state.get_current_hosts_in_room_or_partial_state_approximation(",
            "                room_id",
            "            )",
            "            if origin not in domains:",
            "                logger.info(",
            "                    \"Ignoring receipt for room %r from server %s as they're not in the room\",",
            "                    room_id,",
            "                    origin,",
            "                )",
            "                continue",
            "",
            "            for receipt_type, users in room_values.items():",
            "                for user_id, user_values in users.items():",
            "                    if get_domain_from_id(user_id) != origin:",
            "                        logger.info(",
            "                            \"Received receipt for user %r from server %s, ignoring\",",
            "                            user_id,",
            "                            origin,",
            "                        )",
            "                        continue",
            "",
            "                    # Check if these receipts apply to a thread.",
            "                    data = user_values.get(\"data\", {})",
            "                    thread_id = data.get(\"thread_id\")",
            "                    # If the thread ID is invalid, consider it missing.",
            "                    if not isinstance(thread_id, str):",
            "                        thread_id = None",
            "",
            "                    receipts.append(",
            "                        ReadReceipt(",
            "                            room_id=room_id,",
            "                            receipt_type=receipt_type,",
            "                            user_id=user_id,",
            "                            event_ids=user_values[\"event_ids\"],",
            "                            thread_id=thread_id,",
            "                            data=data,",
            "                        )",
            "                    )",
            "",
            "        await self._handle_new_receipts(receipts)",
            "",
            "    async def _handle_new_receipts(self, receipts: List[ReadReceipt]) -> bool:",
            "        \"\"\"Takes a list of receipts, stores them and informs the notifier.\"\"\"",
            "        min_batch_id: Optional[int] = None",
            "        max_batch_id: Optional[int] = None",
            "",
            "        for receipt in receipts:",
            "            res = await self.store.insert_receipt(",
            "                receipt.room_id,",
            "                receipt.receipt_type,",
            "                receipt.user_id,",
            "                receipt.event_ids,",
            "                receipt.thread_id,",
            "                receipt.data,",
            "            )",
            "",
            "            if not res:",
            "                # res will be None if this receipt is 'old'",
            "                continue",
            "",
            "            stream_id, max_persisted_id = res",
            "",
            "            if min_batch_id is None or stream_id < min_batch_id:",
            "                min_batch_id = stream_id",
            "            if max_batch_id is None or max_persisted_id > max_batch_id:",
            "                max_batch_id = max_persisted_id",
            "",
            "        # Either both of these should be None or neither.",
            "        if min_batch_id is None or max_batch_id is None:",
            "            # no new receipts",
            "            return False",
            "",
            "        affected_room_ids = list({r.room_id for r in receipts})",
            "",
            "        self.notifier.on_new_event(",
            "            StreamKeyType.RECEIPT, max_batch_id, rooms=affected_room_ids",
            "        )",
            "        # Note that the min here shouldn't be relied upon to be accurate.",
            "        await self.hs.get_pusherpool().on_new_receipts(",
            "            min_batch_id, max_batch_id, affected_room_ids",
            "        )",
            "",
            "        return True",
            "",
            "    async def received_client_receipt(",
            "        self,",
            "        room_id: str,",
            "        receipt_type: str,",
            "        user_id: UserID,",
            "        event_id: str,",
            "        thread_id: Optional[str],",
            "    ) -> None:",
            "        \"\"\"Called when a client tells us a local user has read up to the given",
            "        event_id in the room.",
            "        \"\"\"",
            "",
            "        # Ensure the room/event exists, this will raise an error if the user",
            "        # cannot view the event.",
            "        if not await self.event_handler.get_event(user_id, room_id, event_id):",
            "            return",
            "",
            "        receipt = ReadReceipt(",
            "            room_id=room_id,",
            "            receipt_type=receipt_type,",
            "            user_id=user_id.to_string(),",
            "            event_ids=[event_id],",
            "            thread_id=thread_id,",
            "            data={\"ts\": int(self.clock.time_msec())},",
            "        )",
            "",
            "        is_new = await self._handle_new_receipts([receipt])",
            "        if not is_new:",
            "            return",
            "",
            "        if self.federation_sender and receipt_type != ReceiptTypes.READ_PRIVATE:",
            "            await self.federation_sender.send_read_receipt(receipt)",
            "",
            "",
            "class ReceiptEventSource(EventSource[int, JsonDict]):",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.store = hs.get_datastores().main",
            "        self.config = hs.config",
            "",
            "    @staticmethod",
            "    def filter_out_private_receipts(",
            "        rooms: Sequence[JsonDict], user_id: str",
            "    ) -> List[JsonDict]:",
            "        \"\"\"",
            "        Filters a list of serialized receipts (as returned by /sync and /initialSync)",
            "        and removes private read receipts of other users.",
            "",
            "        This operates on the return value of get_linearized_receipts_for_rooms(),",
            "        which is wrapped in a cache. Care must be taken to ensure that the input",
            "        values are not modified.",
            "",
            "        Args:",
            "            rooms: A list of mappings, each mapping has a `content` field, which",
            "                is a map of event ID -> receipt type -> user ID -> receipt information.",
            "",
            "        Returns:",
            "            The same as rooms, but filtered.",
            "        \"\"\"",
            "",
            "        result = []",
            "",
            "        # Iterate through each room's receipt content.",
            "        for room in rooms:",
            "            # The receipt content with other user's private read receipts removed.",
            "            content = {}",
            "",
            "            # Iterate over each event ID / receipts for that event.",
            "            for event_id, orig_event_content in room.get(\"content\", {}).items():",
            "                event_content = orig_event_content",
            "                # If there are private read receipts, additional logic is necessary.",
            "                if ReceiptTypes.READ_PRIVATE in event_content:",
            "                    # Make a copy without private read receipts to avoid leaking",
            "                    # other user's private read receipts..",
            "                    event_content = {",
            "                        receipt_type: receipt_value",
            "                        for receipt_type, receipt_value in event_content.items()",
            "                        if receipt_type != ReceiptTypes.READ_PRIVATE",
            "                    }",
            "",
            "                    # Copy the current user's private read receipt from the",
            "                    # original content, if it exists.",
            "                    user_private_read_receipt = orig_event_content[",
            "                        ReceiptTypes.READ_PRIVATE",
            "                    ].get(user_id, None)",
            "                    if user_private_read_receipt:",
            "                        event_content[ReceiptTypes.READ_PRIVATE] = {",
            "                            user_id: user_private_read_receipt",
            "                        }",
            "",
            "                # Include the event if there is at least one non-private read",
            "                # receipt or the current user has a private read receipt.",
            "                if event_content:",
            "                    content[event_id] = event_content",
            "",
            "            # Include the event if there is at least one non-private read receipt",
            "            # or the current user has a private read receipt.",
            "            if content:",
            "                # Build a new event to avoid mutating the cache.",
            "                new_room = {k: v for k, v in room.items() if k != \"content\"}",
            "                new_room[\"content\"] = content",
            "                result.append(new_room)",
            "",
            "        return result",
            "",
            "    async def get_new_events(",
            "        self,",
            "        user: UserID,",
            "        from_key: int,",
            "        limit: int,",
            "        room_ids: Iterable[str],",
            "        is_guest: bool,",
            "        explicit_room_id: Optional[str] = None,",
            "    ) -> Tuple[List[JsonDict], int]:",
            "        from_key = int(from_key)",
            "        to_key = self.get_current_key()",
            "",
            "        if from_key == to_key:",
            "            return [], to_key",
            "",
            "        events = await self.store.get_linearized_receipts_for_rooms(",
            "            room_ids, from_key=from_key, to_key=to_key",
            "        )",
            "",
            "        events = ReceiptEventSource.filter_out_private_receipts(",
            "            events, user.to_string()",
            "        )",
            "",
            "        return events, to_key",
            "",
            "    async def get_new_events_as(",
            "        self, from_key: int, to_key: int, service: ApplicationService",
            "    ) -> Tuple[List[JsonDict], int]:",
            "        \"\"\"Returns a set of new read receipt events that an appservice",
            "        may be interested in.",
            "",
            "        Args:",
            "            from_key: the stream position at which events should be fetched from",
            "            to_key: the stream position up to which events should be fetched to",
            "            service: The appservice which may be interested",
            "",
            "        Returns:",
            "            A two-tuple containing the following:",
            "                * A list of json dictionaries derived from read receipts that the",
            "                  appservice may be interested in.",
            "                * The current read receipt stream token.",
            "        \"\"\"",
            "        from_key = int(from_key)",
            "",
            "        if from_key == to_key:",
            "            return [], to_key",
            "",
            "        # Fetch all read receipts for all rooms, up to a limit of 100. This is ordered",
            "        # by most recent.",
            "        rooms_to_events = await self.store.get_linearized_receipts_for_all_rooms(",
            "            from_key=from_key, to_key=to_key",
            "        )",
            "",
            "        # Then filter down to rooms that the AS can read",
            "        events = []",
            "        for room_id, event in rooms_to_events.items():",
            "            if not await service.is_interested_in_room(room_id, self.store):",
            "                continue",
            "",
            "            events.append(event)",
            "",
            "        return events, to_key",
            "",
            "    def get_current_key(self) -> int:",
            "        return self.store.get_max_receipt_stream_id()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "161": [
                "ReceiptsHandler"
            ],
            "171": [
                "ReceiptsHandler"
            ]
        },
        "addLocation": [
            "synapse.handlers.receipts.ReceiptsHandler.self",
            "jwt.api_jwt",
            "synapse.handlers.receipts.ReceiptsHandler"
        ]
    },
    "synapse/rest/client/read_marker.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "                 await self.receipts_handler.received_client_receipt("
            },
            "1": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "                     room_id,"
            },
            "2": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                     receipt_type,"
            },
            "3": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    user_id=requester.user.to_string(),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                    user_id=requester.user,"
            },
            "5": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                     event_id=event_id,"
            },
            "6": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                     # Setting the thread ID is not possible with the /read_markers endpoint."
            },
            "7": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                     thread_id=None,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2017 Vector Creations Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from typing import TYPE_CHECKING, Tuple",
            "",
            "from synapse.api.constants import ReceiptTypes",
            "from synapse.http.server import HttpServer",
            "from synapse.http.servlet import RestServlet, parse_json_object_from_request",
            "from synapse.http.site import SynapseRequest",
            "from synapse.types import JsonDict",
            "",
            "from ._base import client_patterns",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReadMarkerRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/rooms/(?P<room_id>[^/]*)/read_markers$\")",
            "    CATEGORY = \"Receipts requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.auth = hs.get_auth()",
            "        self.config = hs.config",
            "        self.receipts_handler = hs.get_receipts_handler()",
            "        self.read_marker_handler = hs.get_read_marker_handler()",
            "        self.presence_handler = hs.get_presence_handler()",
            "",
            "        self._known_receipt_types = {",
            "            ReceiptTypes.READ,",
            "            ReceiptTypes.FULLY_READ,",
            "            ReceiptTypes.READ_PRIVATE,",
            "        }",
            "",
            "    async def on_POST(",
            "        self, request: SynapseRequest, room_id: str",
            "    ) -> Tuple[int, JsonDict]:",
            "        requester = await self.auth.get_user_by_req(request)",
            "",
            "        await self.presence_handler.bump_presence_active_time(",
            "            requester.user, requester.device_id",
            "        )",
            "",
            "        body = parse_json_object_from_request(request)",
            "",
            "        unrecognized_types = set(body.keys()) - self._known_receipt_types",
            "        if unrecognized_types:",
            "            # It's fine if there are unrecognized receipt types, but let's log",
            "            # it to help debug clients that have typoed the receipt type.",
            "            #",
            "            # We specifically *don't* error here, as a) it stops us processing",
            "            # the valid receipts, and b) we need to be extensible on receipt",
            "            # types.",
            "            logger.info(\"Ignoring unrecognized receipt types: %s\", unrecognized_types)",
            "",
            "        for receipt_type in self._known_receipt_types:",
            "            event_id = body.get(receipt_type, None)",
            "            # TODO Add validation to reject non-string event IDs.",
            "            if not event_id:",
            "                continue",
            "",
            "            if receipt_type == ReceiptTypes.FULLY_READ:",
            "                await self.read_marker_handler.received_client_read_marker(",
            "                    room_id,",
            "                    user_id=requester.user.to_string(),",
            "                    event_id=event_id,",
            "                )",
            "            else:",
            "                await self.receipts_handler.received_client_receipt(",
            "                    room_id,",
            "                    receipt_type,",
            "                    user_id=requester.user.to_string(),",
            "                    event_id=event_id,",
            "                    # Setting the thread ID is not possible with the /read_markers endpoint.",
            "                    thread_id=None,",
            "                )",
            "",
            "        return 200, {}",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    ReadMarkerRestServlet(hs).register(http_server)"
        ],
        "afterPatchFile": [
            "# Copyright 2017 Vector Creations Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from typing import TYPE_CHECKING, Tuple",
            "",
            "from synapse.api.constants import ReceiptTypes",
            "from synapse.http.server import HttpServer",
            "from synapse.http.servlet import RestServlet, parse_json_object_from_request",
            "from synapse.http.site import SynapseRequest",
            "from synapse.types import JsonDict",
            "",
            "from ._base import client_patterns",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReadMarkerRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/rooms/(?P<room_id>[^/]*)/read_markers$\")",
            "    CATEGORY = \"Receipts requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.auth = hs.get_auth()",
            "        self.config = hs.config",
            "        self.receipts_handler = hs.get_receipts_handler()",
            "        self.read_marker_handler = hs.get_read_marker_handler()",
            "        self.presence_handler = hs.get_presence_handler()",
            "",
            "        self._known_receipt_types = {",
            "            ReceiptTypes.READ,",
            "            ReceiptTypes.FULLY_READ,",
            "            ReceiptTypes.READ_PRIVATE,",
            "        }",
            "",
            "    async def on_POST(",
            "        self, request: SynapseRequest, room_id: str",
            "    ) -> Tuple[int, JsonDict]:",
            "        requester = await self.auth.get_user_by_req(request)",
            "",
            "        await self.presence_handler.bump_presence_active_time(",
            "            requester.user, requester.device_id",
            "        )",
            "",
            "        body = parse_json_object_from_request(request)",
            "",
            "        unrecognized_types = set(body.keys()) - self._known_receipt_types",
            "        if unrecognized_types:",
            "            # It's fine if there are unrecognized receipt types, but let's log",
            "            # it to help debug clients that have typoed the receipt type.",
            "            #",
            "            # We specifically *don't* error here, as a) it stops us processing",
            "            # the valid receipts, and b) we need to be extensible on receipt",
            "            # types.",
            "            logger.info(\"Ignoring unrecognized receipt types: %s\", unrecognized_types)",
            "",
            "        for receipt_type in self._known_receipt_types:",
            "            event_id = body.get(receipt_type, None)",
            "            # TODO Add validation to reject non-string event IDs.",
            "            if not event_id:",
            "                continue",
            "",
            "            if receipt_type == ReceiptTypes.FULLY_READ:",
            "                await self.read_marker_handler.received_client_read_marker(",
            "                    room_id,",
            "                    user_id=requester.user.to_string(),",
            "                    event_id=event_id,",
            "                )",
            "            else:",
            "                await self.receipts_handler.received_client_receipt(",
            "                    room_id,",
            "                    receipt_type,",
            "                    user_id=requester.user,",
            "                    event_id=event_id,",
            "                    # Setting the thread ID is not possible with the /read_markers endpoint.",
            "                    thread_id=None,",
            "                )",
            "",
            "        return 200, {}",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    ReadMarkerRestServlet(hs).register(http_server)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "ReadMarkerRestServlet"
            ]
        },
        "addLocation": []
    },
    "synapse/rest/client/receipts.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             await self.receipts_handler.received_client_receipt("
            },
            "1": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                 room_id,"
            },
            "2": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "                 receipt_type,"
            },
            "3": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user_id=requester.user.to_string(),"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                user_id=requester.user,"
            },
            "5": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                 event_id=event_id,"
            },
            "6": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                 thread_id=thread_id,"
            },
            "7": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             )"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from typing import TYPE_CHECKING, Tuple",
            "",
            "from synapse.api.constants import MAIN_TIMELINE, ReceiptTypes",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.http.server import HttpServer",
            "from synapse.http.servlet import RestServlet, parse_json_object_from_request",
            "from synapse.http.site import SynapseRequest",
            "from synapse.types import EventID, JsonDict, RoomID",
            "",
            "from ._base import client_patterns",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReceiptRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(",
            "        \"/rooms/(?P<room_id>[^/]*)\"",
            "        \"/receipt/(?P<receipt_type>[^/]*)\"",
            "        \"/(?P<event_id>[^/]*)$\"",
            "    )",
            "    CATEGORY = \"Receipts requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.auth = hs.get_auth()",
            "        self.receipts_handler = hs.get_receipts_handler()",
            "        self.read_marker_handler = hs.get_read_marker_handler()",
            "        self.presence_handler = hs.get_presence_handler()",
            "        self._main_store = hs.get_datastores().main",
            "",
            "        self._known_receipt_types = {",
            "            ReceiptTypes.READ,",
            "            ReceiptTypes.READ_PRIVATE,",
            "            ReceiptTypes.FULLY_READ,",
            "        }",
            "",
            "    async def on_POST(",
            "        self, request: SynapseRequest, room_id: str, receipt_type: str, event_id: str",
            "    ) -> Tuple[int, JsonDict]:",
            "        requester = await self.auth.get_user_by_req(request)",
            "",
            "        if not RoomID.is_valid(room_id) or not event_id.startswith(EventID.SIGIL):",
            "            raise SynapseError(400, \"A valid room ID and event ID must be specified\")",
            "",
            "        if receipt_type not in self._known_receipt_types:",
            "            raise SynapseError(",
            "                400,",
            "                f\"Receipt type must be {', '.join(self._known_receipt_types)}\",",
            "            )",
            "",
            "        body = parse_json_object_from_request(request)",
            "",
            "        # Pull the thread ID, if one exists.",
            "        thread_id = None",
            "        if \"thread_id\" in body:",
            "            thread_id = body.get(\"thread_id\")",
            "            if not thread_id or not isinstance(thread_id, str):",
            "                raise SynapseError(",
            "                    400,",
            "                    \"thread_id field must be a non-empty string\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "            if receipt_type == ReceiptTypes.FULLY_READ:",
            "                raise SynapseError(",
            "                    400,",
            "                    f\"thread_id is not compatible with {ReceiptTypes.FULLY_READ} receipts.\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "            # Ensure the event ID roughly correlates to the thread ID.",
            "            if not await self._is_event_in_thread(event_id, thread_id):",
            "                raise SynapseError(",
            "                    400,",
            "                    f\"event_id {event_id} is not related to thread {thread_id}\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "        await self.presence_handler.bump_presence_active_time(",
            "            requester.user, requester.device_id",
            "        )",
            "",
            "        if receipt_type == ReceiptTypes.FULLY_READ:",
            "            await self.read_marker_handler.received_client_read_marker(",
            "                room_id,",
            "                user_id=requester.user.to_string(),",
            "                event_id=event_id,",
            "            )",
            "        else:",
            "            await self.receipts_handler.received_client_receipt(",
            "                room_id,",
            "                receipt_type,",
            "                user_id=requester.user.to_string(),",
            "                event_id=event_id,",
            "                thread_id=thread_id,",
            "            )",
            "",
            "        return 200, {}",
            "",
            "    async def _is_event_in_thread(self, event_id: str, thread_id: str) -> bool:",
            "        \"\"\"",
            "        The event must be related to the thread ID (in a vague sense) to ensure",
            "        clients aren't sending bogus receipts.",
            "",
            "        A thread ID is considered valid for a given event E if:",
            "",
            "        1. E has a thread relation which matches the thread ID;",
            "        2. E has another event which has a thread relation to E matching the",
            "           thread ID; or",
            "        3. E is recursively related (via any rel_type) to an event which",
            "           satisfies 1 or 2.",
            "",
            "        Given the following DAG:",
            "",
            "            A <---[m.thread]-- B <--[m.annotation]-- C",
            "            ^",
            "            |--[m.reference]-- D <--[m.annotation]-- E",
            "",
            "        It is valid to send a receipt for thread A on A, B, C, D, or E.",
            "",
            "        It is valid to send a receipt for the main timeline on A, D, and E.",
            "",
            "        Args:",
            "            event_id: The event ID to check.",
            "            thread_id: The thread ID the event is potentially part of.",
            "",
            "        Returns:",
            "            True if the event belongs to the given thread, otherwise False.",
            "        \"\"\"",
            "",
            "        # If the receipt is on the main timeline, it is enough to check whether",
            "        # the event is directly related to a thread.",
            "        if thread_id == MAIN_TIMELINE:",
            "            return MAIN_TIMELINE == await self._main_store.get_thread_id(event_id)",
            "",
            "        # Otherwise, check if the event is directly part of a thread, or is the",
            "        # root message (or related to the root message) of a thread.",
            "        return thread_id == await self._main_store.get_thread_id_for_receipts(event_id)",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    ReceiptRestServlet(hs).register(http_server)"
        ],
        "afterPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "from typing import TYPE_CHECKING, Tuple",
            "",
            "from synapse.api.constants import MAIN_TIMELINE, ReceiptTypes",
            "from synapse.api.errors import Codes, SynapseError",
            "from synapse.http.server import HttpServer",
            "from synapse.http.servlet import RestServlet, parse_json_object_from_request",
            "from synapse.http.site import SynapseRequest",
            "from synapse.types import EventID, JsonDict, RoomID",
            "",
            "from ._base import client_patterns",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ReceiptRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(",
            "        \"/rooms/(?P<room_id>[^/]*)\"",
            "        \"/receipt/(?P<receipt_type>[^/]*)\"",
            "        \"/(?P<event_id>[^/]*)$\"",
            "    )",
            "    CATEGORY = \"Receipts requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.auth = hs.get_auth()",
            "        self.receipts_handler = hs.get_receipts_handler()",
            "        self.read_marker_handler = hs.get_read_marker_handler()",
            "        self.presence_handler = hs.get_presence_handler()",
            "        self._main_store = hs.get_datastores().main",
            "",
            "        self._known_receipt_types = {",
            "            ReceiptTypes.READ,",
            "            ReceiptTypes.READ_PRIVATE,",
            "            ReceiptTypes.FULLY_READ,",
            "        }",
            "",
            "    async def on_POST(",
            "        self, request: SynapseRequest, room_id: str, receipt_type: str, event_id: str",
            "    ) -> Tuple[int, JsonDict]:",
            "        requester = await self.auth.get_user_by_req(request)",
            "",
            "        if not RoomID.is_valid(room_id) or not event_id.startswith(EventID.SIGIL):",
            "            raise SynapseError(400, \"A valid room ID and event ID must be specified\")",
            "",
            "        if receipt_type not in self._known_receipt_types:",
            "            raise SynapseError(",
            "                400,",
            "                f\"Receipt type must be {', '.join(self._known_receipt_types)}\",",
            "            )",
            "",
            "        body = parse_json_object_from_request(request)",
            "",
            "        # Pull the thread ID, if one exists.",
            "        thread_id = None",
            "        if \"thread_id\" in body:",
            "            thread_id = body.get(\"thread_id\")",
            "            if not thread_id or not isinstance(thread_id, str):",
            "                raise SynapseError(",
            "                    400,",
            "                    \"thread_id field must be a non-empty string\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "            if receipt_type == ReceiptTypes.FULLY_READ:",
            "                raise SynapseError(",
            "                    400,",
            "                    f\"thread_id is not compatible with {ReceiptTypes.FULLY_READ} receipts.\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "            # Ensure the event ID roughly correlates to the thread ID.",
            "            if not await self._is_event_in_thread(event_id, thread_id):",
            "                raise SynapseError(",
            "                    400,",
            "                    f\"event_id {event_id} is not related to thread {thread_id}\",",
            "                    Codes.INVALID_PARAM,",
            "                )",
            "",
            "        await self.presence_handler.bump_presence_active_time(",
            "            requester.user, requester.device_id",
            "        )",
            "",
            "        if receipt_type == ReceiptTypes.FULLY_READ:",
            "            await self.read_marker_handler.received_client_read_marker(",
            "                room_id,",
            "                user_id=requester.user.to_string(),",
            "                event_id=event_id,",
            "            )",
            "        else:",
            "            await self.receipts_handler.received_client_receipt(",
            "                room_id,",
            "                receipt_type,",
            "                user_id=requester.user,",
            "                event_id=event_id,",
            "                thread_id=thread_id,",
            "            )",
            "",
            "        return 200, {}",
            "",
            "    async def _is_event_in_thread(self, event_id: str, thread_id: str) -> bool:",
            "        \"\"\"",
            "        The event must be related to the thread ID (in a vague sense) to ensure",
            "        clients aren't sending bogus receipts.",
            "",
            "        A thread ID is considered valid for a given event E if:",
            "",
            "        1. E has a thread relation which matches the thread ID;",
            "        2. E has another event which has a thread relation to E matching the",
            "           thread ID; or",
            "        3. E is recursively related (via any rel_type) to an event which",
            "           satisfies 1 or 2.",
            "",
            "        Given the following DAG:",
            "",
            "            A <---[m.thread]-- B <--[m.annotation]-- C",
            "            ^",
            "            |--[m.reference]-- D <--[m.annotation]-- E",
            "",
            "        It is valid to send a receipt for thread A on A, B, C, D, or E.",
            "",
            "        It is valid to send a receipt for the main timeline on A, D, and E.",
            "",
            "        Args:",
            "            event_id: The event ID to check.",
            "            thread_id: The thread ID the event is potentially part of.",
            "",
            "        Returns:",
            "            True if the event belongs to the given thread, otherwise False.",
            "        \"\"\"",
            "",
            "        # If the receipt is on the main timeline, it is enough to check whether",
            "        # the event is directly related to a thread.",
            "        if thread_id == MAIN_TIMELINE:",
            "            return MAIN_TIMELINE == await self._main_store.get_thread_id(event_id)",
            "",
            "        # Otherwise, check if the event is directly part of a thread, or is the",
            "        # root message (or related to the root message) of a thread.",
            "        return thread_id == await self._main_store.get_thread_id_for_receipts(event_id)",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    ReceiptRestServlet(hs).register(http_server)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "111": [
                "ReceiptRestServlet"
            ]
        },
        "addLocation": []
    }
}