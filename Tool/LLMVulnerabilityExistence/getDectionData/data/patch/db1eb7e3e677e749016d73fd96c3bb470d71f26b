{
    "synapse/api/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         Raises:"
            },
            "1": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             AuthError if no user by that token exists or the token is invalid."
            },
            "2": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "4": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_id, guest = self._parse_and_validate_macaroon(token, rights)"
            },
            "5": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except _InvalidMacaroonException:"
            },
            "6": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # doesn't look like a macaroon: treat it as an opaque token which"
            },
            "7": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # must be in the database."
            },
            "8": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # TODO: it would be nice to get rid of this, but apparently some"
            },
            "9": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # people use access tokens which aren't macaroons"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        if rights == \"access\":"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+            # first look in the database"
            },
            "13": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "             r = yield self._look_up_user_by_access_token(token)"
            },
            "14": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            defer.returnValue(r)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+            if r:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+                defer.returnValue(r)"
            },
            "17": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+        # otherwise it needs to be a valid macaroon"
            },
            "19": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         try:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+            user_id, guest = self._parse_and_validate_macaroon(token, rights)"
            },
            "21": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "             user = UserID.from_string(user_id)"
            },
            "22": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 314,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if guest:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            if rights == \"access\":"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+                if not guest:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+                    # non-guest access tokens must be in the database"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+                    logger.warning(\"Unrecognised access token - not in store.\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+                    raise AuthError("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+                        self.TOKEN_NOT_FOUND_HTTP_STATUS,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+                        \"Unrecognised access token.\","
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+                        errcode=Codes.UNKNOWN_TOKEN,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+                    )"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "                 # Guest access tokens are not stored in the database (there can"
            },
            "35": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "                 # only be one access token per guest, anyway)."
            },
            "36": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "                 #"
            },
            "37": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "                     \"device_id\": None,"
            },
            "38": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "                 }"
            },
            "39": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "             else:"
            },
            "40": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # This codepath exists for several reasons:"
            },
            "41": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #   * so that we can actually return a token ID, which is used"
            },
            "42": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #     in some parts of the schema (where we probably ought to"
            },
            "43": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #     use device IDs instead)"
            },
            "44": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #   * the only way we currently have to invalidate an"
            },
            "45": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #     access_token is by removing it from the database, so we"
            },
            "46": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #     have to check here that it is still in the db"
            },
            "47": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #   * some attributes (notably device_id) aren't stored in the"
            },
            "48": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                #     macaroon. They probably should be."
            },
            "49": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # TODO: build the dictionary from the macaroon once the"
            },
            "50": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # above are fixed"
            },
            "51": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ret = yield self._look_up_user_by_access_token(token)"
            },
            "52": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if ret[\"user\"] != user:"
            },
            "53": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    logger.error("
            },
            "54": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"Macaroon user (%s) != DB user (%s)\","
            },
            "55": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        user,"
            },
            "56": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        ret[\"user\"]"
            },
            "57": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "58": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise AuthError("
            },
            "59": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        self.TOKEN_NOT_FOUND_HTTP_STATUS,"
            },
            "60": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"User mismatch in macaroon\","
            },
            "61": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        errcode=Codes.UNKNOWN_TOKEN"
            },
            "62": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+                raise RuntimeError(\"Unknown rights setting %s\", rights)"
            },
            "64": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "             defer.returnValue(ret)"
            },
            "65": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except (pymacaroons.exceptions.MacaroonException, TypeError, ValueError):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+        except ("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+            _InvalidMacaroonException,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+            pymacaroons.exceptions.MacaroonException,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+            TypeError,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+            ValueError,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+        ) as e:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+            logger.warning(\"Invalid macaroon in auth: %s %s\", type(e), e)"
            },
            "73": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "             raise AuthError("
            },
            "74": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "                 self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Invalid macaroon passed.\","
            },
            "75": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "                 errcode=Codes.UNKNOWN_TOKEN"
            },
            "76": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": 500,
                "PatchRowcode": "     def _look_up_user_by_access_token(self, token):"
            },
            "77": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": 501,
                "PatchRowcode": "         ret = yield self.store.get_user_by_access_token(token)"
            },
            "78": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         if not ret:"
            },
            "79": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            logger.warn(\"Unrecognised access token - not in store.\")"
            },
            "80": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise AuthError("
            },
            "81": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Unrecognised access token.\","
            },
            "82": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                errcode=Codes.UNKNOWN_TOKEN"
            },
            "83": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+            defer.returnValue(None)"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "         # we use ret.get() below because *lots* of unit tests stub out"
            },
            "87": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         # get_user_by_access_token in a way where it only returns a couple of"
            },
            "88": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 507,
                "PatchRowcode": "         # the fields."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014 - 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "",
            "from six import itervalues",
            "",
            "import pymacaroons",
            "from netaddr import IPAddress",
            "",
            "from twisted.internet import defer",
            "",
            "import synapse.types",
            "from synapse import event_auth",
            "from synapse.api.constants import EventTypes, JoinRules, Membership",
            "from synapse.api.errors import AuthError, Codes, ResourceLimitError",
            "from synapse.config.server import is_threepid_reserved",
            "from synapse.types import UserID",
            "from synapse.util.caches import CACHE_SIZE_FACTOR, register_cache",
            "from synapse.util.caches.lrucache import LruCache",
            "from synapse.util.metrics import Measure",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "AuthEventTypes = (",
            "    EventTypes.Create, EventTypes.Member, EventTypes.PowerLevels,",
            "    EventTypes.JoinRules, EventTypes.RoomHistoryVisibility,",
            "    EventTypes.ThirdPartyInvite,",
            ")",
            "",
            "# guests always get this device id.",
            "GUEST_DEVICE_ID = \"guest_device\"",
            "",
            "",
            "class _InvalidMacaroonException(Exception):",
            "    pass",
            "",
            "",
            "class Auth(object):",
            "    \"\"\"",
            "    FIXME: This class contains a mix of functions for authenticating users",
            "    of our client-server API and authenticating events added to room graphs.",
            "    \"\"\"",
            "    def __init__(self, hs):",
            "        self.hs = hs",
            "        self.clock = hs.get_clock()",
            "        self.store = hs.get_datastore()",
            "        self.state = hs.get_state_handler()",
            "        self.TOKEN_NOT_FOUND_HTTP_STATUS = 401",
            "",
            "        self.token_cache = LruCache(CACHE_SIZE_FACTOR * 10000)",
            "        register_cache(\"cache\", \"token_cache\", self.token_cache)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_from_context(self, event, context, do_sig_check=True):",
            "        prev_state_ids = yield context.get_prev_state_ids(self.store)",
            "        auth_events_ids = yield self.compute_auth_events(",
            "            event, prev_state_ids, for_verification=True,",
            "        )",
            "        auth_events = yield self.store.get_events(auth_events_ids)",
            "        auth_events = {",
            "            (e.type, e.state_key): e for e in itervalues(auth_events)",
            "        }",
            "        self.check(event, auth_events=auth_events, do_sig_check=do_sig_check)",
            "",
            "    def check(self, event, auth_events, do_sig_check=True):",
            "        \"\"\" Checks if this event is correctly authed.",
            "",
            "        Args:",
            "            event: the event being checked.",
            "            auth_events (dict: event-key -> event): the existing room state.",
            "",
            "",
            "        Returns:",
            "            True if the auth checks pass.",
            "        \"\"\"",
            "        with Measure(self.clock, \"auth.check\"):",
            "            event_auth.check(event, auth_events, do_sig_check=do_sig_check)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_joined_room(self, room_id, user_id, current_state=None):",
            "        \"\"\"Check if the user is currently joined in the room",
            "        Args:",
            "            room_id(str): The room to check.",
            "            user_id(str): The user to check.",
            "            current_state(dict): Optional map of the current state of the room.",
            "                If provided then that map is used to check whether they are a",
            "                member of the room. Otherwise the current membership is",
            "                loaded from the database.",
            "        Raises:",
            "            AuthError if the user is not in the room.",
            "        Returns:",
            "            A deferred membership event for the user if the user is in",
            "            the room.",
            "        \"\"\"",
            "        if current_state:",
            "            member = current_state.get(",
            "                (EventTypes.Member, user_id),",
            "                None",
            "            )",
            "        else:",
            "            member = yield self.state.get_current_state(",
            "                room_id=room_id,",
            "                event_type=EventTypes.Member,",
            "                state_key=user_id",
            "            )",
            "",
            "        self._check_joined_room(member, user_id, room_id)",
            "        defer.returnValue(member)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_user_was_in_room(self, room_id, user_id):",
            "        \"\"\"Check if the user was in the room at some point.",
            "        Args:",
            "            room_id(str): The room to check.",
            "            user_id(str): The user to check.",
            "        Raises:",
            "            AuthError if the user was never in the room.",
            "        Returns:",
            "            A deferred membership event for the user if the user was in the",
            "            room. This will be the join event if they are currently joined to",
            "            the room. This will be the leave event if they have left the room.",
            "        \"\"\"",
            "        member = yield self.state.get_current_state(",
            "            room_id=room_id,",
            "            event_type=EventTypes.Member,",
            "            state_key=user_id",
            "        )",
            "        membership = member.membership if member else None",
            "",
            "        if membership not in (Membership.JOIN, Membership.LEAVE):",
            "            raise AuthError(403, \"User %s not in room %s\" % (",
            "                user_id, room_id",
            "            ))",
            "",
            "        if membership == Membership.LEAVE:",
            "            forgot = yield self.store.did_forget(user_id, room_id)",
            "            if forgot:",
            "                raise AuthError(403, \"User %s not in room %s\" % (",
            "                    user_id, room_id",
            "                ))",
            "",
            "        defer.returnValue(member)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_host_in_room(self, room_id, host):",
            "        with Measure(self.clock, \"check_host_in_room\"):",
            "            latest_event_ids = yield self.store.is_host_joined(room_id, host)",
            "            defer.returnValue(latest_event_ids)",
            "",
            "    def _check_joined_room(self, member, user_id, room_id):",
            "        if not member or member.membership != Membership.JOIN:",
            "            raise AuthError(403, \"User %s not in room %s (%s)\" % (",
            "                user_id, room_id, repr(member)",
            "            ))",
            "",
            "    def can_federate(self, event, auth_events):",
            "        creation_event = auth_events.get((EventTypes.Create, \"\"))",
            "",
            "        return creation_event.content.get(\"m.federate\", True) is True",
            "",
            "    def get_public_keys(self, invite_event):",
            "        return event_auth.get_public_keys(invite_event)",
            "",
            "    @defer.inlineCallbacks",
            "    def get_user_by_req(self, request, allow_guest=False, rights=\"access\"):",
            "        \"\"\" Get a registered user's ID.",
            "",
            "        Args:",
            "            request - An HTTP request with an access_token query parameter.",
            "        Returns:",
            "            defer.Deferred: resolves to a ``synapse.types.Requester`` object",
            "        Raises:",
            "            AuthError if no user by that token exists or the token is invalid.",
            "        \"\"\"",
            "        # Can optionally look elsewhere in the request (e.g. headers)",
            "        try:",
            "            ip_addr = self.hs.get_ip_from_request(request)",
            "            user_agent = request.requestHeaders.getRawHeaders(",
            "                b\"User-Agent\",",
            "                default=[b\"\"]",
            "            )[0].decode('ascii', 'surrogateescape')",
            "",
            "            access_token = self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "",
            "            user_id, app_service = yield self._get_appservice_user_id(request)",
            "            if user_id:",
            "                request.authenticated_entity = user_id",
            "",
            "                if ip_addr and self.hs.config.track_appservice_user_ips:",
            "                    yield self.store.insert_client_ip(",
            "                        user_id=user_id,",
            "                        access_token=access_token,",
            "                        ip=ip_addr,",
            "                        user_agent=user_agent,",
            "                        device_id=\"dummy-device\",  # stubbed",
            "                    )",
            "",
            "                defer.returnValue(",
            "                    synapse.types.create_requester(user_id, app_service=app_service)",
            "                )",
            "",
            "            user_info = yield self.get_user_by_access_token(access_token, rights)",
            "            user = user_info[\"user\"]",
            "            token_id = user_info[\"token_id\"]",
            "            is_guest = user_info[\"is_guest\"]",
            "",
            "            # device_id may not be present if get_user_by_access_token has been",
            "            # stubbed out.",
            "            device_id = user_info.get(\"device_id\")",
            "",
            "            if user and access_token and ip_addr:",
            "                yield self.store.insert_client_ip(",
            "                    user_id=user.to_string(),",
            "                    access_token=access_token,",
            "                    ip=ip_addr,",
            "                    user_agent=user_agent,",
            "                    device_id=device_id,",
            "                )",
            "",
            "            if is_guest and not allow_guest:",
            "                raise AuthError(",
            "                    403, \"Guest access not allowed\", errcode=Codes.GUEST_ACCESS_FORBIDDEN",
            "                )",
            "",
            "            request.authenticated_entity = user.to_string()",
            "",
            "            defer.returnValue(synapse.types.create_requester(",
            "                user, token_id, is_guest, device_id, app_service=app_service)",
            "            )",
            "        except KeyError:",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Missing access token.\",",
            "                errcode=Codes.MISSING_TOKEN",
            "            )",
            "",
            "    @defer.inlineCallbacks",
            "    def _get_appservice_user_id(self, request):",
            "        app_service = self.store.get_app_service_by_token(",
            "            self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "        )",
            "        if app_service is None:",
            "            defer.returnValue((None, None))",
            "",
            "        if app_service.ip_range_whitelist:",
            "            ip_address = IPAddress(self.hs.get_ip_from_request(request))",
            "            if ip_address not in app_service.ip_range_whitelist:",
            "                defer.returnValue((None, None))",
            "",
            "        if b\"user_id\" not in request.args:",
            "            defer.returnValue((app_service.sender, app_service))",
            "",
            "        user_id = request.args[b\"user_id\"][0].decode('utf8')",
            "        if app_service.sender == user_id:",
            "            defer.returnValue((app_service.sender, app_service))",
            "",
            "        if not app_service.is_interested_in_user(user_id):",
            "            raise AuthError(",
            "                403,",
            "                \"Application service cannot masquerade as this user.\"",
            "            )",
            "        if not (yield self.store.get_user_by_id(user_id)):",
            "            raise AuthError(",
            "                403,",
            "                \"Application service has not registered this user\"",
            "            )",
            "        defer.returnValue((user_id, app_service))",
            "",
            "    @defer.inlineCallbacks",
            "    def get_user_by_access_token(self, token, rights=\"access\"):",
            "        \"\"\" Validate access token and get user_id from it",
            "",
            "        Args:",
            "            token (str): The access token to get the user by.",
            "            rights (str): The operation being performed; the access token must",
            "                allow this.",
            "        Returns:",
            "            Deferred[dict]: dict that includes:",
            "               `user` (UserID)",
            "               `is_guest` (bool)",
            "               `token_id` (int|None): access token id. May be None if guest",
            "               `device_id` (str|None): device corresponding to access token",
            "        Raises:",
            "            AuthError if no user by that token exists or the token is invalid.",
            "        \"\"\"",
            "        try:",
            "            user_id, guest = self._parse_and_validate_macaroon(token, rights)",
            "        except _InvalidMacaroonException:",
            "            # doesn't look like a macaroon: treat it as an opaque token which",
            "            # must be in the database.",
            "            # TODO: it would be nice to get rid of this, but apparently some",
            "            # people use access tokens which aren't macaroons",
            "            r = yield self._look_up_user_by_access_token(token)",
            "            defer.returnValue(r)",
            "",
            "        try:",
            "            user = UserID.from_string(user_id)",
            "",
            "            if guest:",
            "                # Guest access tokens are not stored in the database (there can",
            "                # only be one access token per guest, anyway).",
            "                #",
            "                # In order to prevent guest access tokens being used as regular",
            "                # user access tokens (and hence getting around the invalidation",
            "                # process), we look up the user id and check that it is indeed",
            "                # a guest user.",
            "                #",
            "                # It would of course be much easier to store guest access",
            "                # tokens in the database as well, but that would break existing",
            "                # guest tokens.",
            "                stored_user = yield self.store.get_user_by_id(user_id)",
            "                if not stored_user:",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"Unknown user_id %s\" % user_id,",
            "                        errcode=Codes.UNKNOWN_TOKEN",
            "                    )",
            "                if not stored_user[\"is_guest\"]:",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"Guest access token used for regular user\",",
            "                        errcode=Codes.UNKNOWN_TOKEN",
            "                    )",
            "                ret = {",
            "                    \"user\": user,",
            "                    \"is_guest\": True,",
            "                    \"token_id\": None,",
            "                    # all guests get the same device id",
            "                    \"device_id\": GUEST_DEVICE_ID,",
            "                }",
            "            elif rights == \"delete_pusher\":",
            "                # We don't store these tokens in the database",
            "                ret = {",
            "                    \"user\": user,",
            "                    \"is_guest\": False,",
            "                    \"token_id\": None,",
            "                    \"device_id\": None,",
            "                }",
            "            else:",
            "                # This codepath exists for several reasons:",
            "                #   * so that we can actually return a token ID, which is used",
            "                #     in some parts of the schema (where we probably ought to",
            "                #     use device IDs instead)",
            "                #   * the only way we currently have to invalidate an",
            "                #     access_token is by removing it from the database, so we",
            "                #     have to check here that it is still in the db",
            "                #   * some attributes (notably device_id) aren't stored in the",
            "                #     macaroon. They probably should be.",
            "                # TODO: build the dictionary from the macaroon once the",
            "                # above are fixed",
            "                ret = yield self._look_up_user_by_access_token(token)",
            "                if ret[\"user\"] != user:",
            "                    logger.error(",
            "                        \"Macaroon user (%s) != DB user (%s)\",",
            "                        user,",
            "                        ret[\"user\"]",
            "                    )",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"User mismatch in macaroon\",",
            "                        errcode=Codes.UNKNOWN_TOKEN",
            "                    )",
            "            defer.returnValue(ret)",
            "        except (pymacaroons.exceptions.MacaroonException, TypeError, ValueError):",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Invalid macaroon passed.\",",
            "                errcode=Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "    def _parse_and_validate_macaroon(self, token, rights=\"access\"):",
            "        \"\"\"Takes a macaroon and tries to parse and validate it. This is cached",
            "        if and only if rights == access and there isn't an expiry.",
            "",
            "        On invalid macaroon raises _InvalidMacaroonException",
            "",
            "        Returns:",
            "            (user_id, is_guest)",
            "        \"\"\"",
            "        if rights == \"access\":",
            "            cached = self.token_cache.get(token, None)",
            "            if cached:",
            "                return cached",
            "",
            "        try:",
            "            macaroon = pymacaroons.Macaroon.deserialize(token)",
            "        except Exception:  # deserialize can throw more-or-less anything",
            "            # doesn't look like a macaroon: treat it as an opaque token which",
            "            # must be in the database.",
            "            # TODO: it would be nice to get rid of this, but apparently some",
            "            # people use access tokens which aren't macaroons",
            "            raise _InvalidMacaroonException()",
            "",
            "        try:",
            "            user_id = self.get_user_id_from_macaroon(macaroon)",
            "",
            "            has_expiry = False",
            "            guest = False",
            "            for caveat in macaroon.caveats:",
            "                if caveat.caveat_id.startswith(\"time \"):",
            "                    has_expiry = True",
            "                elif caveat.caveat_id == \"guest = true\":",
            "                    guest = True",
            "",
            "            self.validate_macaroon(",
            "                macaroon, rights, self.hs.config.expire_access_token,",
            "                user_id=user_id,",
            "            )",
            "        except (pymacaroons.exceptions.MacaroonException, TypeError, ValueError):",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Invalid macaroon passed.\",",
            "                errcode=Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "        if not has_expiry and rights == \"access\":",
            "            self.token_cache[token] = (user_id, guest)",
            "",
            "        return user_id, guest",
            "",
            "    def get_user_id_from_macaroon(self, macaroon):",
            "        \"\"\"Retrieve the user_id given by the caveats on the macaroon.",
            "",
            "        Does *not* validate the macaroon.",
            "",
            "        Args:",
            "            macaroon (pymacaroons.Macaroon): The macaroon to validate",
            "",
            "        Returns:",
            "            (str) user id",
            "",
            "        Raises:",
            "            AuthError if there is no user_id caveat in the macaroon",
            "        \"\"\"",
            "        user_prefix = \"user_id = \"",
            "        for caveat in macaroon.caveats:",
            "            if caveat.caveat_id.startswith(user_prefix):",
            "                return caveat.caveat_id[len(user_prefix):]",
            "        raise AuthError(",
            "            self.TOKEN_NOT_FOUND_HTTP_STATUS, \"No user caveat in macaroon\",",
            "            errcode=Codes.UNKNOWN_TOKEN",
            "        )",
            "",
            "    def validate_macaroon(self, macaroon, type_string, verify_expiry, user_id):",
            "        \"\"\"",
            "        validate that a Macaroon is understood by and was signed by this server.",
            "",
            "        Args:",
            "            macaroon(pymacaroons.Macaroon): The macaroon to validate",
            "            type_string(str): The kind of token required (e.g. \"access\",",
            "                              \"delete_pusher\")",
            "            verify_expiry(bool): Whether to verify whether the macaroon has expired.",
            "            user_id (str): The user_id required",
            "        \"\"\"",
            "        v = pymacaroons.Verifier()",
            "",
            "        # the verifier runs a test for every caveat on the macaroon, to check",
            "        # that it is met for the current request. Each caveat must match at",
            "        # least one of the predicates specified by satisfy_exact or",
            "        # specify_general.",
            "        v.satisfy_exact(\"gen = 1\")",
            "        v.satisfy_exact(\"type = \" + type_string)",
            "        v.satisfy_exact(\"user_id = %s\" % user_id)",
            "        v.satisfy_exact(\"guest = true\")",
            "",
            "        # verify_expiry should really always be True, but there exist access",
            "        # tokens in the wild which expire when they should not, so we can't",
            "        # enforce expiry yet (so we have to allow any caveat starting with",
            "        # 'time < ' in access tokens).",
            "        #",
            "        # On the other hand, short-term login tokens (as used by CAS login, for",
            "        # example) have an expiry time which we do want to enforce.",
            "",
            "        if verify_expiry:",
            "            v.satisfy_general(self._verify_expiry)",
            "        else:",
            "            v.satisfy_general(lambda c: c.startswith(\"time < \"))",
            "",
            "        # access_tokens include a nonce for uniqueness: any value is acceptable",
            "        v.satisfy_general(lambda c: c.startswith(\"nonce = \"))",
            "",
            "        v.verify(macaroon, self.hs.config.macaroon_secret_key)",
            "",
            "    def _verify_expiry(self, caveat):",
            "        prefix = \"time < \"",
            "        if not caveat.startswith(prefix):",
            "            return False",
            "        expiry = int(caveat[len(prefix):])",
            "        now = self.hs.get_clock().time_msec()",
            "        return now < expiry",
            "",
            "    @defer.inlineCallbacks",
            "    def _look_up_user_by_access_token(self, token):",
            "        ret = yield self.store.get_user_by_access_token(token)",
            "        if not ret:",
            "            logger.warn(\"Unrecognised access token - not in store.\")",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Unrecognised access token.\",",
            "                errcode=Codes.UNKNOWN_TOKEN",
            "            )",
            "        # we use ret.get() below because *lots* of unit tests stub out",
            "        # get_user_by_access_token in a way where it only returns a couple of",
            "        # the fields.",
            "        user_info = {",
            "            \"user\": UserID.from_string(ret.get(\"name\")),",
            "            \"token_id\": ret.get(\"token_id\", None),",
            "            \"is_guest\": False,",
            "            \"device_id\": ret.get(\"device_id\"),",
            "        }",
            "        defer.returnValue(user_info)",
            "",
            "    def get_appservice_by_req(self, request):",
            "        try:",
            "            token = self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "            service = self.store.get_app_service_by_token(token)",
            "            if not service:",
            "                logger.warn(\"Unrecognised appservice access token.\")",
            "                raise AuthError(",
            "                    self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                    \"Unrecognised access token.\",",
            "                    errcode=Codes.UNKNOWN_TOKEN",
            "                )",
            "            request.authenticated_entity = service.sender",
            "            return defer.succeed(service)",
            "        except KeyError:",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Missing access token.\"",
            "            )",
            "",
            "    def is_server_admin(self, user):",
            "        \"\"\" Check if the given user is a local server admin.",
            "",
            "        Args:",
            "            user (str): mxid of user to check",
            "",
            "        Returns:",
            "            bool: True if the user is an admin",
            "        \"\"\"",
            "        return self.store.is_server_admin(user)",
            "",
            "    @defer.inlineCallbacks",
            "    def add_auth_events(self, builder, context):",
            "        prev_state_ids = yield context.get_prev_state_ids(self.store)",
            "        auth_ids = yield self.compute_auth_events(builder, prev_state_ids)",
            "",
            "        auth_events_entries = yield self.store.add_event_hashes(",
            "            auth_ids",
            "        )",
            "",
            "        builder.auth_events = auth_events_entries",
            "",
            "    @defer.inlineCallbacks",
            "    def compute_auth_events(self, event, current_state_ids, for_verification=False):",
            "        if event.type == EventTypes.Create:",
            "            defer.returnValue([])",
            "",
            "        auth_ids = []",
            "",
            "        key = (EventTypes.PowerLevels, \"\", )",
            "        power_level_event_id = current_state_ids.get(key)",
            "",
            "        if power_level_event_id:",
            "            auth_ids.append(power_level_event_id)",
            "",
            "        key = (EventTypes.JoinRules, \"\", )",
            "        join_rule_event_id = current_state_ids.get(key)",
            "",
            "        key = (EventTypes.Member, event.user_id, )",
            "        member_event_id = current_state_ids.get(key)",
            "",
            "        key = (EventTypes.Create, \"\", )",
            "        create_event_id = current_state_ids.get(key)",
            "        if create_event_id:",
            "            auth_ids.append(create_event_id)",
            "",
            "        if join_rule_event_id:",
            "            join_rule_event = yield self.store.get_event(join_rule_event_id)",
            "            join_rule = join_rule_event.content.get(\"join_rule\")",
            "            is_public = join_rule == JoinRules.PUBLIC if join_rule else False",
            "        else:",
            "            is_public = False",
            "",
            "        if event.type == EventTypes.Member:",
            "            e_type = event.content[\"membership\"]",
            "            if e_type in [Membership.JOIN, Membership.INVITE]:",
            "                if join_rule_event_id:",
            "                    auth_ids.append(join_rule_event_id)",
            "",
            "            if e_type == Membership.JOIN:",
            "                if member_event_id and not is_public:",
            "                    auth_ids.append(member_event_id)",
            "            else:",
            "                if member_event_id:",
            "                    auth_ids.append(member_event_id)",
            "",
            "                if for_verification:",
            "                    key = (EventTypes.Member, event.state_key, )",
            "                    existing_event_id = current_state_ids.get(key)",
            "                    if existing_event_id:",
            "                        auth_ids.append(existing_event_id)",
            "",
            "            if e_type == Membership.INVITE:",
            "                if \"third_party_invite\" in event.content:",
            "                    key = (",
            "                        EventTypes.ThirdPartyInvite,",
            "                        event.content[\"third_party_invite\"][\"signed\"][\"token\"]",
            "                    )",
            "                    third_party_invite_id = current_state_ids.get(key)",
            "                    if third_party_invite_id:",
            "                        auth_ids.append(third_party_invite_id)",
            "        elif member_event_id:",
            "            member_event = yield self.store.get_event(member_event_id)",
            "            if member_event.content[\"membership\"] == Membership.JOIN:",
            "                auth_ids.append(member_event.event_id)",
            "",
            "        defer.returnValue(auth_ids)",
            "",
            "    def check_redaction(self, event, auth_events):",
            "        \"\"\"Check whether the event sender is allowed to redact the target event.",
            "",
            "        Returns:",
            "            True if the the sender is allowed to redact the target event if the",
            "            target event was created by them.",
            "            False if the sender is allowed to redact the target event with no",
            "            further checks.",
            "",
            "        Raises:",
            "            AuthError if the event sender is definitely not allowed to redact",
            "            the target event.",
            "        \"\"\"",
            "        return event_auth.check_redaction(event, auth_events)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_can_change_room_list(self, room_id, user):",
            "        \"\"\"Check if the user is allowed to edit the room's entry in the",
            "        published room list.",
            "",
            "        Args:",
            "            room_id (str)",
            "            user (UserID)",
            "        \"\"\"",
            "",
            "        is_admin = yield self.is_server_admin(user)",
            "        if is_admin:",
            "            defer.returnValue(True)",
            "",
            "        user_id = user.to_string()",
            "        yield self.check_joined_room(room_id, user_id)",
            "",
            "        # We currently require the user is a \"moderator\" in the room. We do this",
            "        # by checking if they would (theoretically) be able to change the",
            "        # m.room.aliases events",
            "        power_level_event = yield self.state.get_current_state(",
            "            room_id, EventTypes.PowerLevels, \"\"",
            "        )",
            "",
            "        auth_events = {}",
            "        if power_level_event:",
            "            auth_events[(EventTypes.PowerLevels, \"\")] = power_level_event",
            "",
            "        send_level = event_auth.get_send_level(",
            "            EventTypes.Aliases, \"\", power_level_event,",
            "        )",
            "        user_level = event_auth.get_user_power_level(user_id, auth_events)",
            "",
            "        if user_level < send_level:",
            "            raise AuthError(",
            "                403,",
            "                \"This server requires you to be a moderator in the room to\"",
            "                \" edit its room list entry\"",
            "            )",
            "",
            "    @staticmethod",
            "    def has_access_token(request):",
            "        \"\"\"Checks if the request has an access_token.",
            "",
            "        Returns:",
            "            bool: False if no access_token was given, True otherwise.",
            "        \"\"\"",
            "        query_params = request.args.get(b\"access_token\")",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "        return bool(query_params) or bool(auth_headers)",
            "",
            "    @staticmethod",
            "    def get_access_token_from_request(request, token_not_found_http_status=401):",
            "        \"\"\"Extracts the access_token from the request.",
            "",
            "        Args:",
            "            request: The http request.",
            "            token_not_found_http_status(int): The HTTP status code to set in the",
            "                AuthError if the token isn't found. This is used in some of the",
            "                legacy APIs to change the status code to 403 from the default of",
            "                401 since some of the old clients depended on auth errors returning",
            "                403.",
            "        Returns:",
            "            unicode: The access_token",
            "        Raises:",
            "            AuthError: If there isn't an access_token in the request.",
            "        \"\"\"",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "        query_params = request.args.get(b\"access_token\")",
            "        if auth_headers:",
            "            # Try the get the access_token from a \"Authorization: Bearer\"",
            "            # header",
            "            if query_params is not None:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Mixing Authorization headers and access_token query parameters.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "            if len(auth_headers) > 1:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Too many Authorization headers.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "            parts = auth_headers[0].split(b\" \")",
            "            if parts[0] == b\"Bearer\" and len(parts) == 2:",
            "                return parts[1].decode('ascii')",
            "            else:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Invalid Authorization header.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "        else:",
            "            # Try to get the access_token from the query params.",
            "            if not query_params:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Missing access token.\",",
            "                    errcode=Codes.MISSING_TOKEN",
            "                )",
            "",
            "            return query_params[0].decode('ascii')",
            "",
            "    @defer.inlineCallbacks",
            "    def check_in_room_or_world_readable(self, room_id, user_id):",
            "        \"\"\"Checks that the user is or was in the room or the room is world",
            "        readable. If it isn't then an exception is raised.",
            "",
            "        Returns:",
            "            Deferred[tuple[str, str|None]]: Resolves to the current membership of",
            "            the user in the room and the membership event ID of the user. If",
            "            the user is not in the room and never has been, then",
            "            `(Membership.JOIN, None)` is returned.",
            "        \"\"\"",
            "",
            "        try:",
            "            # check_user_was_in_room will return the most recent membership",
            "            # event for the user if:",
            "            #  * The user is a non-guest user, and was ever in the room",
            "            #  * The user is a guest user, and has joined the room",
            "            # else it will throw.",
            "            member_event = yield self.check_user_was_in_room(room_id, user_id)",
            "            defer.returnValue((member_event.membership, member_event.event_id))",
            "        except AuthError:",
            "            visibility = yield self.state.get_current_state(",
            "                room_id, EventTypes.RoomHistoryVisibility, \"\"",
            "            )",
            "            if (",
            "                visibility and",
            "                visibility.content[\"history_visibility\"] == \"world_readable\"",
            "            ):",
            "                defer.returnValue((Membership.JOIN, None))",
            "                return",
            "            raise AuthError(",
            "                403, \"Guest access not allowed\", errcode=Codes.GUEST_ACCESS_FORBIDDEN",
            "            )",
            "",
            "    @defer.inlineCallbacks",
            "    def check_auth_blocking(self, user_id=None, threepid=None):",
            "        \"\"\"Checks if the user should be rejected for some external reason,",
            "        such as monthly active user limiting or global disable flag",
            "",
            "        Args:",
            "            user_id(str|None): If present, checks for presence against existing",
            "            MAU cohort",
            "",
            "            threepid(dict|None): If present, checks for presence against configured",
            "            reserved threepid. Used in cases where the user is trying register",
            "            with a MAU blocked server, normally they would be rejected but their",
            "            threepid is on the reserved list. user_id and",
            "            threepid should never be set at the same time.",
            "        \"\"\"",
            "",
            "        # Never fail an auth check for the server notices users",
            "        # This can be a problem where event creation is prohibited due to blocking",
            "        if user_id == self.hs.config.server_notices_mxid:",
            "            return",
            "",
            "        if self.hs.config.hs_disabled:",
            "            raise ResourceLimitError(",
            "                403, self.hs.config.hs_disabled_message,",
            "                errcode=Codes.RESOURCE_LIMIT_EXCEEDED,",
            "                admin_contact=self.hs.config.admin_contact,",
            "                limit_type=self.hs.config.hs_disabled_limit_type",
            "            )",
            "        if self.hs.config.limit_usage_by_mau is True:",
            "            assert not (user_id and threepid)",
            "",
            "            # If the user is already part of the MAU cohort or a trial user",
            "            if user_id:",
            "                timestamp = yield self.store.user_last_seen_monthly_active(user_id)",
            "                if timestamp:",
            "                    return",
            "",
            "                is_trial = yield self.store.is_trial_user(user_id)",
            "                if is_trial:",
            "                    return",
            "            elif threepid:",
            "                # If the user does not exist yet, but is signing up with a",
            "                # reserved threepid then pass auth check",
            "                if is_threepid_reserved(self.hs.config, threepid):",
            "                    return",
            "            # Else if there is no room in the MAU bucket, bail",
            "            current_mau = yield self.store.get_monthly_active_count()",
            "            if current_mau >= self.hs.config.max_mau_value:",
            "                raise ResourceLimitError(",
            "                    403, \"Monthly Active User Limit Exceeded\",",
            "                    admin_contact=self.hs.config.admin_contact,",
            "                    errcode=Codes.RESOURCE_LIMIT_EXCEEDED,",
            "                    limit_type=\"monthly_active_user\"",
            "                )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014 - 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "",
            "from six import itervalues",
            "",
            "import pymacaroons",
            "from netaddr import IPAddress",
            "",
            "from twisted.internet import defer",
            "",
            "import synapse.types",
            "from synapse import event_auth",
            "from synapse.api.constants import EventTypes, JoinRules, Membership",
            "from synapse.api.errors import AuthError, Codes, ResourceLimitError",
            "from synapse.config.server import is_threepid_reserved",
            "from synapse.types import UserID",
            "from synapse.util.caches import CACHE_SIZE_FACTOR, register_cache",
            "from synapse.util.caches.lrucache import LruCache",
            "from synapse.util.metrics import Measure",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "AuthEventTypes = (",
            "    EventTypes.Create, EventTypes.Member, EventTypes.PowerLevels,",
            "    EventTypes.JoinRules, EventTypes.RoomHistoryVisibility,",
            "    EventTypes.ThirdPartyInvite,",
            ")",
            "",
            "# guests always get this device id.",
            "GUEST_DEVICE_ID = \"guest_device\"",
            "",
            "",
            "class _InvalidMacaroonException(Exception):",
            "    pass",
            "",
            "",
            "class Auth(object):",
            "    \"\"\"",
            "    FIXME: This class contains a mix of functions for authenticating users",
            "    of our client-server API and authenticating events added to room graphs.",
            "    \"\"\"",
            "    def __init__(self, hs):",
            "        self.hs = hs",
            "        self.clock = hs.get_clock()",
            "        self.store = hs.get_datastore()",
            "        self.state = hs.get_state_handler()",
            "        self.TOKEN_NOT_FOUND_HTTP_STATUS = 401",
            "",
            "        self.token_cache = LruCache(CACHE_SIZE_FACTOR * 10000)",
            "        register_cache(\"cache\", \"token_cache\", self.token_cache)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_from_context(self, event, context, do_sig_check=True):",
            "        prev_state_ids = yield context.get_prev_state_ids(self.store)",
            "        auth_events_ids = yield self.compute_auth_events(",
            "            event, prev_state_ids, for_verification=True,",
            "        )",
            "        auth_events = yield self.store.get_events(auth_events_ids)",
            "        auth_events = {",
            "            (e.type, e.state_key): e for e in itervalues(auth_events)",
            "        }",
            "        self.check(event, auth_events=auth_events, do_sig_check=do_sig_check)",
            "",
            "    def check(self, event, auth_events, do_sig_check=True):",
            "        \"\"\" Checks if this event is correctly authed.",
            "",
            "        Args:",
            "            event: the event being checked.",
            "            auth_events (dict: event-key -> event): the existing room state.",
            "",
            "",
            "        Returns:",
            "            True if the auth checks pass.",
            "        \"\"\"",
            "        with Measure(self.clock, \"auth.check\"):",
            "            event_auth.check(event, auth_events, do_sig_check=do_sig_check)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_joined_room(self, room_id, user_id, current_state=None):",
            "        \"\"\"Check if the user is currently joined in the room",
            "        Args:",
            "            room_id(str): The room to check.",
            "            user_id(str): The user to check.",
            "            current_state(dict): Optional map of the current state of the room.",
            "                If provided then that map is used to check whether they are a",
            "                member of the room. Otherwise the current membership is",
            "                loaded from the database.",
            "        Raises:",
            "            AuthError if the user is not in the room.",
            "        Returns:",
            "            A deferred membership event for the user if the user is in",
            "            the room.",
            "        \"\"\"",
            "        if current_state:",
            "            member = current_state.get(",
            "                (EventTypes.Member, user_id),",
            "                None",
            "            )",
            "        else:",
            "            member = yield self.state.get_current_state(",
            "                room_id=room_id,",
            "                event_type=EventTypes.Member,",
            "                state_key=user_id",
            "            )",
            "",
            "        self._check_joined_room(member, user_id, room_id)",
            "        defer.returnValue(member)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_user_was_in_room(self, room_id, user_id):",
            "        \"\"\"Check if the user was in the room at some point.",
            "        Args:",
            "            room_id(str): The room to check.",
            "            user_id(str): The user to check.",
            "        Raises:",
            "            AuthError if the user was never in the room.",
            "        Returns:",
            "            A deferred membership event for the user if the user was in the",
            "            room. This will be the join event if they are currently joined to",
            "            the room. This will be the leave event if they have left the room.",
            "        \"\"\"",
            "        member = yield self.state.get_current_state(",
            "            room_id=room_id,",
            "            event_type=EventTypes.Member,",
            "            state_key=user_id",
            "        )",
            "        membership = member.membership if member else None",
            "",
            "        if membership not in (Membership.JOIN, Membership.LEAVE):",
            "            raise AuthError(403, \"User %s not in room %s\" % (",
            "                user_id, room_id",
            "            ))",
            "",
            "        if membership == Membership.LEAVE:",
            "            forgot = yield self.store.did_forget(user_id, room_id)",
            "            if forgot:",
            "                raise AuthError(403, \"User %s not in room %s\" % (",
            "                    user_id, room_id",
            "                ))",
            "",
            "        defer.returnValue(member)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_host_in_room(self, room_id, host):",
            "        with Measure(self.clock, \"check_host_in_room\"):",
            "            latest_event_ids = yield self.store.is_host_joined(room_id, host)",
            "            defer.returnValue(latest_event_ids)",
            "",
            "    def _check_joined_room(self, member, user_id, room_id):",
            "        if not member or member.membership != Membership.JOIN:",
            "            raise AuthError(403, \"User %s not in room %s (%s)\" % (",
            "                user_id, room_id, repr(member)",
            "            ))",
            "",
            "    def can_federate(self, event, auth_events):",
            "        creation_event = auth_events.get((EventTypes.Create, \"\"))",
            "",
            "        return creation_event.content.get(\"m.federate\", True) is True",
            "",
            "    def get_public_keys(self, invite_event):",
            "        return event_auth.get_public_keys(invite_event)",
            "",
            "    @defer.inlineCallbacks",
            "    def get_user_by_req(self, request, allow_guest=False, rights=\"access\"):",
            "        \"\"\" Get a registered user's ID.",
            "",
            "        Args:",
            "            request - An HTTP request with an access_token query parameter.",
            "        Returns:",
            "            defer.Deferred: resolves to a ``synapse.types.Requester`` object",
            "        Raises:",
            "            AuthError if no user by that token exists or the token is invalid.",
            "        \"\"\"",
            "        # Can optionally look elsewhere in the request (e.g. headers)",
            "        try:",
            "            ip_addr = self.hs.get_ip_from_request(request)",
            "            user_agent = request.requestHeaders.getRawHeaders(",
            "                b\"User-Agent\",",
            "                default=[b\"\"]",
            "            )[0].decode('ascii', 'surrogateescape')",
            "",
            "            access_token = self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "",
            "            user_id, app_service = yield self._get_appservice_user_id(request)",
            "            if user_id:",
            "                request.authenticated_entity = user_id",
            "",
            "                if ip_addr and self.hs.config.track_appservice_user_ips:",
            "                    yield self.store.insert_client_ip(",
            "                        user_id=user_id,",
            "                        access_token=access_token,",
            "                        ip=ip_addr,",
            "                        user_agent=user_agent,",
            "                        device_id=\"dummy-device\",  # stubbed",
            "                    )",
            "",
            "                defer.returnValue(",
            "                    synapse.types.create_requester(user_id, app_service=app_service)",
            "                )",
            "",
            "            user_info = yield self.get_user_by_access_token(access_token, rights)",
            "            user = user_info[\"user\"]",
            "            token_id = user_info[\"token_id\"]",
            "            is_guest = user_info[\"is_guest\"]",
            "",
            "            # device_id may not be present if get_user_by_access_token has been",
            "            # stubbed out.",
            "            device_id = user_info.get(\"device_id\")",
            "",
            "            if user and access_token and ip_addr:",
            "                yield self.store.insert_client_ip(",
            "                    user_id=user.to_string(),",
            "                    access_token=access_token,",
            "                    ip=ip_addr,",
            "                    user_agent=user_agent,",
            "                    device_id=device_id,",
            "                )",
            "",
            "            if is_guest and not allow_guest:",
            "                raise AuthError(",
            "                    403, \"Guest access not allowed\", errcode=Codes.GUEST_ACCESS_FORBIDDEN",
            "                )",
            "",
            "            request.authenticated_entity = user.to_string()",
            "",
            "            defer.returnValue(synapse.types.create_requester(",
            "                user, token_id, is_guest, device_id, app_service=app_service)",
            "            )",
            "        except KeyError:",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Missing access token.\",",
            "                errcode=Codes.MISSING_TOKEN",
            "            )",
            "",
            "    @defer.inlineCallbacks",
            "    def _get_appservice_user_id(self, request):",
            "        app_service = self.store.get_app_service_by_token(",
            "            self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "        )",
            "        if app_service is None:",
            "            defer.returnValue((None, None))",
            "",
            "        if app_service.ip_range_whitelist:",
            "            ip_address = IPAddress(self.hs.get_ip_from_request(request))",
            "            if ip_address not in app_service.ip_range_whitelist:",
            "                defer.returnValue((None, None))",
            "",
            "        if b\"user_id\" not in request.args:",
            "            defer.returnValue((app_service.sender, app_service))",
            "",
            "        user_id = request.args[b\"user_id\"][0].decode('utf8')",
            "        if app_service.sender == user_id:",
            "            defer.returnValue((app_service.sender, app_service))",
            "",
            "        if not app_service.is_interested_in_user(user_id):",
            "            raise AuthError(",
            "                403,",
            "                \"Application service cannot masquerade as this user.\"",
            "            )",
            "        if not (yield self.store.get_user_by_id(user_id)):",
            "            raise AuthError(",
            "                403,",
            "                \"Application service has not registered this user\"",
            "            )",
            "        defer.returnValue((user_id, app_service))",
            "",
            "    @defer.inlineCallbacks",
            "    def get_user_by_access_token(self, token, rights=\"access\"):",
            "        \"\"\" Validate access token and get user_id from it",
            "",
            "        Args:",
            "            token (str): The access token to get the user by.",
            "            rights (str): The operation being performed; the access token must",
            "                allow this.",
            "        Returns:",
            "            Deferred[dict]: dict that includes:",
            "               `user` (UserID)",
            "               `is_guest` (bool)",
            "               `token_id` (int|None): access token id. May be None if guest",
            "               `device_id` (str|None): device corresponding to access token",
            "        Raises:",
            "            AuthError if no user by that token exists or the token is invalid.",
            "        \"\"\"",
            "",
            "        if rights == \"access\":",
            "            # first look in the database",
            "            r = yield self._look_up_user_by_access_token(token)",
            "            if r:",
            "                defer.returnValue(r)",
            "",
            "        # otherwise it needs to be a valid macaroon",
            "        try:",
            "            user_id, guest = self._parse_and_validate_macaroon(token, rights)",
            "            user = UserID.from_string(user_id)",
            "",
            "            if rights == \"access\":",
            "                if not guest:",
            "                    # non-guest access tokens must be in the database",
            "                    logger.warning(\"Unrecognised access token - not in store.\")",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"Unrecognised access token.\",",
            "                        errcode=Codes.UNKNOWN_TOKEN,",
            "                    )",
            "",
            "                # Guest access tokens are not stored in the database (there can",
            "                # only be one access token per guest, anyway).",
            "                #",
            "                # In order to prevent guest access tokens being used as regular",
            "                # user access tokens (and hence getting around the invalidation",
            "                # process), we look up the user id and check that it is indeed",
            "                # a guest user.",
            "                #",
            "                # It would of course be much easier to store guest access",
            "                # tokens in the database as well, but that would break existing",
            "                # guest tokens.",
            "                stored_user = yield self.store.get_user_by_id(user_id)",
            "                if not stored_user:",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"Unknown user_id %s\" % user_id,",
            "                        errcode=Codes.UNKNOWN_TOKEN",
            "                    )",
            "                if not stored_user[\"is_guest\"]:",
            "                    raise AuthError(",
            "                        self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                        \"Guest access token used for regular user\",",
            "                        errcode=Codes.UNKNOWN_TOKEN",
            "                    )",
            "                ret = {",
            "                    \"user\": user,",
            "                    \"is_guest\": True,",
            "                    \"token_id\": None,",
            "                    # all guests get the same device id",
            "                    \"device_id\": GUEST_DEVICE_ID,",
            "                }",
            "            elif rights == \"delete_pusher\":",
            "                # We don't store these tokens in the database",
            "                ret = {",
            "                    \"user\": user,",
            "                    \"is_guest\": False,",
            "                    \"token_id\": None,",
            "                    \"device_id\": None,",
            "                }",
            "            else:",
            "                raise RuntimeError(\"Unknown rights setting %s\", rights)",
            "            defer.returnValue(ret)",
            "        except (",
            "            _InvalidMacaroonException,",
            "            pymacaroons.exceptions.MacaroonException,",
            "            TypeError,",
            "            ValueError,",
            "        ) as e:",
            "            logger.warning(\"Invalid macaroon in auth: %s %s\", type(e), e)",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Invalid macaroon passed.\",",
            "                errcode=Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "    def _parse_and_validate_macaroon(self, token, rights=\"access\"):",
            "        \"\"\"Takes a macaroon and tries to parse and validate it. This is cached",
            "        if and only if rights == access and there isn't an expiry.",
            "",
            "        On invalid macaroon raises _InvalidMacaroonException",
            "",
            "        Returns:",
            "            (user_id, is_guest)",
            "        \"\"\"",
            "        if rights == \"access\":",
            "            cached = self.token_cache.get(token, None)",
            "            if cached:",
            "                return cached",
            "",
            "        try:",
            "            macaroon = pymacaroons.Macaroon.deserialize(token)",
            "        except Exception:  # deserialize can throw more-or-less anything",
            "            # doesn't look like a macaroon: treat it as an opaque token which",
            "            # must be in the database.",
            "            # TODO: it would be nice to get rid of this, but apparently some",
            "            # people use access tokens which aren't macaroons",
            "            raise _InvalidMacaroonException()",
            "",
            "        try:",
            "            user_id = self.get_user_id_from_macaroon(macaroon)",
            "",
            "            has_expiry = False",
            "            guest = False",
            "            for caveat in macaroon.caveats:",
            "                if caveat.caveat_id.startswith(\"time \"):",
            "                    has_expiry = True",
            "                elif caveat.caveat_id == \"guest = true\":",
            "                    guest = True",
            "",
            "            self.validate_macaroon(",
            "                macaroon, rights, self.hs.config.expire_access_token,",
            "                user_id=user_id,",
            "            )",
            "        except (pymacaroons.exceptions.MacaroonException, TypeError, ValueError):",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Invalid macaroon passed.\",",
            "                errcode=Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "        if not has_expiry and rights == \"access\":",
            "            self.token_cache[token] = (user_id, guest)",
            "",
            "        return user_id, guest",
            "",
            "    def get_user_id_from_macaroon(self, macaroon):",
            "        \"\"\"Retrieve the user_id given by the caveats on the macaroon.",
            "",
            "        Does *not* validate the macaroon.",
            "",
            "        Args:",
            "            macaroon (pymacaroons.Macaroon): The macaroon to validate",
            "",
            "        Returns:",
            "            (str) user id",
            "",
            "        Raises:",
            "            AuthError if there is no user_id caveat in the macaroon",
            "        \"\"\"",
            "        user_prefix = \"user_id = \"",
            "        for caveat in macaroon.caveats:",
            "            if caveat.caveat_id.startswith(user_prefix):",
            "                return caveat.caveat_id[len(user_prefix):]",
            "        raise AuthError(",
            "            self.TOKEN_NOT_FOUND_HTTP_STATUS, \"No user caveat in macaroon\",",
            "            errcode=Codes.UNKNOWN_TOKEN",
            "        )",
            "",
            "    def validate_macaroon(self, macaroon, type_string, verify_expiry, user_id):",
            "        \"\"\"",
            "        validate that a Macaroon is understood by and was signed by this server.",
            "",
            "        Args:",
            "            macaroon(pymacaroons.Macaroon): The macaroon to validate",
            "            type_string(str): The kind of token required (e.g. \"access\",",
            "                              \"delete_pusher\")",
            "            verify_expiry(bool): Whether to verify whether the macaroon has expired.",
            "            user_id (str): The user_id required",
            "        \"\"\"",
            "        v = pymacaroons.Verifier()",
            "",
            "        # the verifier runs a test for every caveat on the macaroon, to check",
            "        # that it is met for the current request. Each caveat must match at",
            "        # least one of the predicates specified by satisfy_exact or",
            "        # specify_general.",
            "        v.satisfy_exact(\"gen = 1\")",
            "        v.satisfy_exact(\"type = \" + type_string)",
            "        v.satisfy_exact(\"user_id = %s\" % user_id)",
            "        v.satisfy_exact(\"guest = true\")",
            "",
            "        # verify_expiry should really always be True, but there exist access",
            "        # tokens in the wild which expire when they should not, so we can't",
            "        # enforce expiry yet (so we have to allow any caveat starting with",
            "        # 'time < ' in access tokens).",
            "        #",
            "        # On the other hand, short-term login tokens (as used by CAS login, for",
            "        # example) have an expiry time which we do want to enforce.",
            "",
            "        if verify_expiry:",
            "            v.satisfy_general(self._verify_expiry)",
            "        else:",
            "            v.satisfy_general(lambda c: c.startswith(\"time < \"))",
            "",
            "        # access_tokens include a nonce for uniqueness: any value is acceptable",
            "        v.satisfy_general(lambda c: c.startswith(\"nonce = \"))",
            "",
            "        v.verify(macaroon, self.hs.config.macaroon_secret_key)",
            "",
            "    def _verify_expiry(self, caveat):",
            "        prefix = \"time < \"",
            "        if not caveat.startswith(prefix):",
            "            return False",
            "        expiry = int(caveat[len(prefix):])",
            "        now = self.hs.get_clock().time_msec()",
            "        return now < expiry",
            "",
            "    @defer.inlineCallbacks",
            "    def _look_up_user_by_access_token(self, token):",
            "        ret = yield self.store.get_user_by_access_token(token)",
            "        if not ret:",
            "            defer.returnValue(None)",
            "",
            "        # we use ret.get() below because *lots* of unit tests stub out",
            "        # get_user_by_access_token in a way where it only returns a couple of",
            "        # the fields.",
            "        user_info = {",
            "            \"user\": UserID.from_string(ret.get(\"name\")),",
            "            \"token_id\": ret.get(\"token_id\", None),",
            "            \"is_guest\": False,",
            "            \"device_id\": ret.get(\"device_id\"),",
            "        }",
            "        defer.returnValue(user_info)",
            "",
            "    def get_appservice_by_req(self, request):",
            "        try:",
            "            token = self.get_access_token_from_request(",
            "                request, self.TOKEN_NOT_FOUND_HTTP_STATUS",
            "            )",
            "            service = self.store.get_app_service_by_token(token)",
            "            if not service:",
            "                logger.warn(\"Unrecognised appservice access token.\")",
            "                raise AuthError(",
            "                    self.TOKEN_NOT_FOUND_HTTP_STATUS,",
            "                    \"Unrecognised access token.\",",
            "                    errcode=Codes.UNKNOWN_TOKEN",
            "                )",
            "            request.authenticated_entity = service.sender",
            "            return defer.succeed(service)",
            "        except KeyError:",
            "            raise AuthError(",
            "                self.TOKEN_NOT_FOUND_HTTP_STATUS, \"Missing access token.\"",
            "            )",
            "",
            "    def is_server_admin(self, user):",
            "        \"\"\" Check if the given user is a local server admin.",
            "",
            "        Args:",
            "            user (str): mxid of user to check",
            "",
            "        Returns:",
            "            bool: True if the user is an admin",
            "        \"\"\"",
            "        return self.store.is_server_admin(user)",
            "",
            "    @defer.inlineCallbacks",
            "    def add_auth_events(self, builder, context):",
            "        prev_state_ids = yield context.get_prev_state_ids(self.store)",
            "        auth_ids = yield self.compute_auth_events(builder, prev_state_ids)",
            "",
            "        auth_events_entries = yield self.store.add_event_hashes(",
            "            auth_ids",
            "        )",
            "",
            "        builder.auth_events = auth_events_entries",
            "",
            "    @defer.inlineCallbacks",
            "    def compute_auth_events(self, event, current_state_ids, for_verification=False):",
            "        if event.type == EventTypes.Create:",
            "            defer.returnValue([])",
            "",
            "        auth_ids = []",
            "",
            "        key = (EventTypes.PowerLevels, \"\", )",
            "        power_level_event_id = current_state_ids.get(key)",
            "",
            "        if power_level_event_id:",
            "            auth_ids.append(power_level_event_id)",
            "",
            "        key = (EventTypes.JoinRules, \"\", )",
            "        join_rule_event_id = current_state_ids.get(key)",
            "",
            "        key = (EventTypes.Member, event.user_id, )",
            "        member_event_id = current_state_ids.get(key)",
            "",
            "        key = (EventTypes.Create, \"\", )",
            "        create_event_id = current_state_ids.get(key)",
            "        if create_event_id:",
            "            auth_ids.append(create_event_id)",
            "",
            "        if join_rule_event_id:",
            "            join_rule_event = yield self.store.get_event(join_rule_event_id)",
            "            join_rule = join_rule_event.content.get(\"join_rule\")",
            "            is_public = join_rule == JoinRules.PUBLIC if join_rule else False",
            "        else:",
            "            is_public = False",
            "",
            "        if event.type == EventTypes.Member:",
            "            e_type = event.content[\"membership\"]",
            "            if e_type in [Membership.JOIN, Membership.INVITE]:",
            "                if join_rule_event_id:",
            "                    auth_ids.append(join_rule_event_id)",
            "",
            "            if e_type == Membership.JOIN:",
            "                if member_event_id and not is_public:",
            "                    auth_ids.append(member_event_id)",
            "            else:",
            "                if member_event_id:",
            "                    auth_ids.append(member_event_id)",
            "",
            "                if for_verification:",
            "                    key = (EventTypes.Member, event.state_key, )",
            "                    existing_event_id = current_state_ids.get(key)",
            "                    if existing_event_id:",
            "                        auth_ids.append(existing_event_id)",
            "",
            "            if e_type == Membership.INVITE:",
            "                if \"third_party_invite\" in event.content:",
            "                    key = (",
            "                        EventTypes.ThirdPartyInvite,",
            "                        event.content[\"third_party_invite\"][\"signed\"][\"token\"]",
            "                    )",
            "                    third_party_invite_id = current_state_ids.get(key)",
            "                    if third_party_invite_id:",
            "                        auth_ids.append(third_party_invite_id)",
            "        elif member_event_id:",
            "            member_event = yield self.store.get_event(member_event_id)",
            "            if member_event.content[\"membership\"] == Membership.JOIN:",
            "                auth_ids.append(member_event.event_id)",
            "",
            "        defer.returnValue(auth_ids)",
            "",
            "    def check_redaction(self, event, auth_events):",
            "        \"\"\"Check whether the event sender is allowed to redact the target event.",
            "",
            "        Returns:",
            "            True if the the sender is allowed to redact the target event if the",
            "            target event was created by them.",
            "            False if the sender is allowed to redact the target event with no",
            "            further checks.",
            "",
            "        Raises:",
            "            AuthError if the event sender is definitely not allowed to redact",
            "            the target event.",
            "        \"\"\"",
            "        return event_auth.check_redaction(event, auth_events)",
            "",
            "    @defer.inlineCallbacks",
            "    def check_can_change_room_list(self, room_id, user):",
            "        \"\"\"Check if the user is allowed to edit the room's entry in the",
            "        published room list.",
            "",
            "        Args:",
            "            room_id (str)",
            "            user (UserID)",
            "        \"\"\"",
            "",
            "        is_admin = yield self.is_server_admin(user)",
            "        if is_admin:",
            "            defer.returnValue(True)",
            "",
            "        user_id = user.to_string()",
            "        yield self.check_joined_room(room_id, user_id)",
            "",
            "        # We currently require the user is a \"moderator\" in the room. We do this",
            "        # by checking if they would (theoretically) be able to change the",
            "        # m.room.aliases events",
            "        power_level_event = yield self.state.get_current_state(",
            "            room_id, EventTypes.PowerLevels, \"\"",
            "        )",
            "",
            "        auth_events = {}",
            "        if power_level_event:",
            "            auth_events[(EventTypes.PowerLevels, \"\")] = power_level_event",
            "",
            "        send_level = event_auth.get_send_level(",
            "            EventTypes.Aliases, \"\", power_level_event,",
            "        )",
            "        user_level = event_auth.get_user_power_level(user_id, auth_events)",
            "",
            "        if user_level < send_level:",
            "            raise AuthError(",
            "                403,",
            "                \"This server requires you to be a moderator in the room to\"",
            "                \" edit its room list entry\"",
            "            )",
            "",
            "    @staticmethod",
            "    def has_access_token(request):",
            "        \"\"\"Checks if the request has an access_token.",
            "",
            "        Returns:",
            "            bool: False if no access_token was given, True otherwise.",
            "        \"\"\"",
            "        query_params = request.args.get(b\"access_token\")",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "        return bool(query_params) or bool(auth_headers)",
            "",
            "    @staticmethod",
            "    def get_access_token_from_request(request, token_not_found_http_status=401):",
            "        \"\"\"Extracts the access_token from the request.",
            "",
            "        Args:",
            "            request: The http request.",
            "            token_not_found_http_status(int): The HTTP status code to set in the",
            "                AuthError if the token isn't found. This is used in some of the",
            "                legacy APIs to change the status code to 403 from the default of",
            "                401 since some of the old clients depended on auth errors returning",
            "                403.",
            "        Returns:",
            "            unicode: The access_token",
            "        Raises:",
            "            AuthError: If there isn't an access_token in the request.",
            "        \"\"\"",
            "",
            "        auth_headers = request.requestHeaders.getRawHeaders(b\"Authorization\")",
            "        query_params = request.args.get(b\"access_token\")",
            "        if auth_headers:",
            "            # Try the get the access_token from a \"Authorization: Bearer\"",
            "            # header",
            "            if query_params is not None:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Mixing Authorization headers and access_token query parameters.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "            if len(auth_headers) > 1:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Too many Authorization headers.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "            parts = auth_headers[0].split(b\" \")",
            "            if parts[0] == b\"Bearer\" and len(parts) == 2:",
            "                return parts[1].decode('ascii')",
            "            else:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Invalid Authorization header.\",",
            "                    errcode=Codes.MISSING_TOKEN,",
            "                )",
            "        else:",
            "            # Try to get the access_token from the query params.",
            "            if not query_params:",
            "                raise AuthError(",
            "                    token_not_found_http_status,",
            "                    \"Missing access token.\",",
            "                    errcode=Codes.MISSING_TOKEN",
            "                )",
            "",
            "            return query_params[0].decode('ascii')",
            "",
            "    @defer.inlineCallbacks",
            "    def check_in_room_or_world_readable(self, room_id, user_id):",
            "        \"\"\"Checks that the user is or was in the room or the room is world",
            "        readable. If it isn't then an exception is raised.",
            "",
            "        Returns:",
            "            Deferred[tuple[str, str|None]]: Resolves to the current membership of",
            "            the user in the room and the membership event ID of the user. If",
            "            the user is not in the room and never has been, then",
            "            `(Membership.JOIN, None)` is returned.",
            "        \"\"\"",
            "",
            "        try:",
            "            # check_user_was_in_room will return the most recent membership",
            "            # event for the user if:",
            "            #  * The user is a non-guest user, and was ever in the room",
            "            #  * The user is a guest user, and has joined the room",
            "            # else it will throw.",
            "            member_event = yield self.check_user_was_in_room(room_id, user_id)",
            "            defer.returnValue((member_event.membership, member_event.event_id))",
            "        except AuthError:",
            "            visibility = yield self.state.get_current_state(",
            "                room_id, EventTypes.RoomHistoryVisibility, \"\"",
            "            )",
            "            if (",
            "                visibility and",
            "                visibility.content[\"history_visibility\"] == \"world_readable\"",
            "            ):",
            "                defer.returnValue((Membership.JOIN, None))",
            "                return",
            "            raise AuthError(",
            "                403, \"Guest access not allowed\", errcode=Codes.GUEST_ACCESS_FORBIDDEN",
            "            )",
            "",
            "    @defer.inlineCallbacks",
            "    def check_auth_blocking(self, user_id=None, threepid=None):",
            "        \"\"\"Checks if the user should be rejected for some external reason,",
            "        such as monthly active user limiting or global disable flag",
            "",
            "        Args:",
            "            user_id(str|None): If present, checks for presence against existing",
            "            MAU cohort",
            "",
            "            threepid(dict|None): If present, checks for presence against configured",
            "            reserved threepid. Used in cases where the user is trying register",
            "            with a MAU blocked server, normally they would be rejected but their",
            "            threepid is on the reserved list. user_id and",
            "            threepid should never be set at the same time.",
            "        \"\"\"",
            "",
            "        # Never fail an auth check for the server notices users",
            "        # This can be a problem where event creation is prohibited due to blocking",
            "        if user_id == self.hs.config.server_notices_mxid:",
            "            return",
            "",
            "        if self.hs.config.hs_disabled:",
            "            raise ResourceLimitError(",
            "                403, self.hs.config.hs_disabled_message,",
            "                errcode=Codes.RESOURCE_LIMIT_EXCEEDED,",
            "                admin_contact=self.hs.config.admin_contact,",
            "                limit_type=self.hs.config.hs_disabled_limit_type",
            "            )",
            "        if self.hs.config.limit_usage_by_mau is True:",
            "            assert not (user_id and threepid)",
            "",
            "            # If the user is already part of the MAU cohort or a trial user",
            "            if user_id:",
            "                timestamp = yield self.store.user_last_seen_monthly_active(user_id)",
            "                if timestamp:",
            "                    return",
            "",
            "                is_trial = yield self.store.is_trial_user(user_id)",
            "                if is_trial:",
            "                    return",
            "            elif threepid:",
            "                # If the user does not exist yet, but is signing up with a",
            "                # reserved threepid then pass auth check",
            "                if is_threepid_reserved(self.hs.config, threepid):",
            "                    return",
            "            # Else if there is no room in the MAU bucket, bail",
            "            current_mau = yield self.store.get_monthly_active_count()",
            "            if current_mau >= self.hs.config.max_mau_value:",
            "                raise ResourceLimitError(",
            "                    403, \"Monthly Active User Limit Exceeded\",",
            "                    admin_contact=self.hs.config.admin_contact,",
            "                    errcode=Codes.RESOURCE_LIMIT_EXCEEDED,",
            "                    limit_type=\"monthly_active_user\"",
            "                )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "303": [
                "Auth",
                "get_user_by_access_token"
            ],
            "304": [
                "Auth",
                "get_user_by_access_token"
            ],
            "305": [
                "Auth",
                "get_user_by_access_token"
            ],
            "306": [
                "Auth",
                "get_user_by_access_token"
            ],
            "307": [
                "Auth",
                "get_user_by_access_token"
            ],
            "308": [
                "Auth",
                "get_user_by_access_token"
            ],
            "309": [
                "Auth",
                "get_user_by_access_token"
            ],
            "311": [
                "Auth",
                "get_user_by_access_token"
            ],
            "316": [
                "Auth",
                "get_user_by_access_token"
            ],
            "357": [
                "Auth",
                "get_user_by_access_token"
            ],
            "358": [
                "Auth",
                "get_user_by_access_token"
            ],
            "359": [
                "Auth",
                "get_user_by_access_token"
            ],
            "360": [
                "Auth",
                "get_user_by_access_token"
            ],
            "361": [
                "Auth",
                "get_user_by_access_token"
            ],
            "362": [
                "Auth",
                "get_user_by_access_token"
            ],
            "363": [
                "Auth",
                "get_user_by_access_token"
            ],
            "364": [
                "Auth",
                "get_user_by_access_token"
            ],
            "365": [
                "Auth",
                "get_user_by_access_token"
            ],
            "366": [
                "Auth",
                "get_user_by_access_token"
            ],
            "367": [
                "Auth",
                "get_user_by_access_token"
            ],
            "368": [
                "Auth",
                "get_user_by_access_token"
            ],
            "369": [
                "Auth",
                "get_user_by_access_token"
            ],
            "370": [
                "Auth",
                "get_user_by_access_token"
            ],
            "371": [
                "Auth",
                "get_user_by_access_token"
            ],
            "372": [
                "Auth",
                "get_user_by_access_token"
            ],
            "373": [
                "Auth",
                "get_user_by_access_token"
            ],
            "374": [
                "Auth",
                "get_user_by_access_token"
            ],
            "375": [
                "Auth",
                "get_user_by_access_token"
            ],
            "376": [
                "Auth",
                "get_user_by_access_token"
            ],
            "377": [
                "Auth",
                "get_user_by_access_token"
            ],
            "378": [
                "Auth",
                "get_user_by_access_token"
            ],
            "379": [
                "Auth",
                "get_user_by_access_token"
            ],
            "381": [
                "Auth",
                "get_user_by_access_token"
            ],
            "511": [
                "Auth",
                "_look_up_user_by_access_token"
            ],
            "512": [
                "Auth",
                "_look_up_user_by_access_token"
            ],
            "513": [
                "Auth",
                "_look_up_user_by_access_token"
            ],
            "514": [
                "Auth",
                "_look_up_user_by_access_token"
            ],
            "515": [
                "Auth",
                "_look_up_user_by_access_token"
            ]
        },
        "addLocation": []
    },
    "synapse/config/key.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             # Unfortunately, there are people out there that don't have this"
            },
            "1": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             # set. Lets just be \"nice\" and derive one from their secret key."
            },
            "2": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             logger.warn(\"Config is missing missing macaroon_secret_key\")"
            },
            "3": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            seed = self.signing_key[0].seed"
            },
            "4": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.macaroon_secret_key = hashlib.sha256(seed)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            seed = bytes(self.signing_key[0])"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            self.macaroon_secret_key = hashlib.sha256(seed).digest()"
            },
            "7": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         self.expire_access_token = config.get(\"expire_access_token\", False)"
            },
            "9": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         base_key_name = os.path.join(config_dir_path, server_name)"
            },
            "11": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         if is_generating_file:"
            },
            "13": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            macaroon_secret_key = random_string_with_symbols(50)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            macaroon_secret_key = '\"%s\"' % random_string_with_symbols(50)"
            },
            "15": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "             form_secret = '\"%s\"' % random_string_with_symbols(50)"
            },
            "16": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         else:"
            },
            "17": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            macaroon_secret_key = None"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            macaroon_secret_key = 'null'"
            },
            "19": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             form_secret = 'null'"
            },
            "20": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         return \"\"\"\\"
            },
            "22": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        macaroon_secret_key: \"%(macaroon_secret_key)s\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        macaroon_secret_key: %(macaroon_secret_key)s"
            },
            "24": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         # Used to enable access token expiration."
            },
            "26": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         expire_access_token: False"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import hashlib",
            "import logging",
            "import os",
            "",
            "from signedjson.key import (",
            "    NACL_ED25519,",
            "    decode_signing_key_base64,",
            "    decode_verify_key_bytes,",
            "    generate_signing_key,",
            "    is_signing_algorithm_supported,",
            "    read_signing_keys,",
            "    write_signing_keys,",
            ")",
            "from unpaddedbase64 import decode_base64",
            "",
            "from synapse.util.stringutils import random_string, random_string_with_symbols",
            "",
            "from ._base import Config, ConfigError",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class KeyConfig(Config):",
            "",
            "    def read_config(self, config):",
            "        self.signing_key = self.read_signing_key(config[\"signing_key_path\"])",
            "        self.old_signing_keys = self.read_old_signing_keys(",
            "            config[\"old_signing_keys\"]",
            "        )",
            "        self.key_refresh_interval = self.parse_duration(",
            "            config[\"key_refresh_interval\"]",
            "        )",
            "        self.perspectives = self.read_perspectives(",
            "            config[\"perspectives\"]",
            "        )",
            "",
            "        self.macaroon_secret_key = config.get(",
            "            \"macaroon_secret_key\", self.registration_shared_secret",
            "        )",
            "",
            "        if not self.macaroon_secret_key:",
            "            # Unfortunately, there are people out there that don't have this",
            "            # set. Lets just be \"nice\" and derive one from their secret key.",
            "            logger.warn(\"Config is missing missing macaroon_secret_key\")",
            "            seed = self.signing_key[0].seed",
            "            self.macaroon_secret_key = hashlib.sha256(seed)",
            "",
            "        self.expire_access_token = config.get(\"expire_access_token\", False)",
            "",
            "        # a secret which is used to calculate HMACs for form values, to stop",
            "        # falsification of values",
            "        self.form_secret = config.get(\"form_secret\", None)",
            "",
            "    def default_config(self, config_dir_path, server_name, is_generating_file=False,",
            "                       **kwargs):",
            "        base_key_name = os.path.join(config_dir_path, server_name)",
            "",
            "        if is_generating_file:",
            "            macaroon_secret_key = random_string_with_symbols(50)",
            "            form_secret = '\"%s\"' % random_string_with_symbols(50)",
            "        else:",
            "            macaroon_secret_key = None",
            "            form_secret = 'null'",
            "",
            "        return \"\"\"\\",
            "        macaroon_secret_key: \"%(macaroon_secret_key)s\"",
            "",
            "        # Used to enable access token expiration.",
            "        expire_access_token: False",
            "",
            "        # a secret which is used to calculate HMACs for form values, to stop",
            "        # falsification of values",
            "        form_secret: %(form_secret)s",
            "",
            "        ## Signing Keys ##",
            "",
            "        # Path to the signing key to sign messages with",
            "        signing_key_path: \"%(base_key_name)s.signing.key\"",
            "",
            "        # The keys that the server used to sign messages with but won't use",
            "        # to sign new messages. E.g. it has lost its private key",
            "        old_signing_keys: {}",
            "        #  \"ed25519:auto\":",
            "        #    # Base64 encoded public key",
            "        #    key: \"The public part of your old signing key.\"",
            "        #    # Millisecond POSIX timestamp when the key expired.",
            "        #    expired_ts: 123456789123",
            "",
            "        # How long key response published by this server is valid for.",
            "        # Used to set the valid_until_ts in /key/v2 APIs.",
            "        # Determines how quickly servers will query to check which keys",
            "        # are still valid.",
            "        key_refresh_interval: \"1d\" # 1 Day.",
            "",
            "        # The trusted servers to download signing keys from.",
            "        perspectives:",
            "          servers:",
            "            \"matrix.org\":",
            "              verify_keys:",
            "                \"ed25519:auto\":",
            "                  key: \"Noi6WqcDj0QmPxCNQqgezwTlBKrfqehY1u2FyWP9uYw\"",
            "        \"\"\" % locals()",
            "",
            "    def read_perspectives(self, perspectives_config):",
            "        servers = {}",
            "        for server_name, server_config in perspectives_config[\"servers\"].items():",
            "            for key_id, key_data in server_config[\"verify_keys\"].items():",
            "                if is_signing_algorithm_supported(key_id):",
            "                    key_base64 = key_data[\"key\"]",
            "                    key_bytes = decode_base64(key_base64)",
            "                    verify_key = decode_verify_key_bytes(key_id, key_bytes)",
            "                    servers.setdefault(server_name, {})[key_id] = verify_key",
            "        return servers",
            "",
            "    def read_signing_key(self, signing_key_path):",
            "        signing_keys = self.read_file(signing_key_path, \"signing_key\")",
            "        try:",
            "            return read_signing_keys(signing_keys.splitlines(True))",
            "        except Exception as e:",
            "            raise ConfigError(",
            "                \"Error reading signing_key: %s\" % (str(e))",
            "            )",
            "",
            "    def read_old_signing_keys(self, old_signing_keys):",
            "        keys = {}",
            "        for key_id, key_data in old_signing_keys.items():",
            "            if is_signing_algorithm_supported(key_id):",
            "                key_base64 = key_data[\"key\"]",
            "                key_bytes = decode_base64(key_base64)",
            "                verify_key = decode_verify_key_bytes(key_id, key_bytes)",
            "                verify_key.expired_ts = key_data[\"expired_ts\"]",
            "                keys[key_id] = verify_key",
            "            else:",
            "                raise ConfigError(",
            "                    \"Unsupported signing algorithm for old key: %r\" % (key_id,)",
            "                )",
            "        return keys",
            "",
            "    def generate_files(self, config):",
            "        signing_key_path = config[\"signing_key_path\"]",
            "",
            "        if not self.path_exists(signing_key_path):",
            "            with open(signing_key_path, \"w\") as signing_key_file:",
            "                key_id = \"a_\" + random_string(4)",
            "                write_signing_keys(",
            "                    signing_key_file, (generate_signing_key(key_id),),",
            "                )",
            "        else:",
            "            signing_keys = self.read_file(signing_key_path, \"signing_key\")",
            "            if len(signing_keys.split(\"\\n\")[0].split()) == 1:",
            "                # handle keys in the old format.",
            "                key_id = \"a_\" + random_string(4)",
            "                key = decode_signing_key_base64(",
            "                    NACL_ED25519, key_id, signing_keys.split(\"\\n\")[0]",
            "                )",
            "                with open(signing_key_path, \"w\") as signing_key_file:",
            "                    write_signing_keys(",
            "                        signing_key_file, (key,),",
            "                    )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import hashlib",
            "import logging",
            "import os",
            "",
            "from signedjson.key import (",
            "    NACL_ED25519,",
            "    decode_signing_key_base64,",
            "    decode_verify_key_bytes,",
            "    generate_signing_key,",
            "    is_signing_algorithm_supported,",
            "    read_signing_keys,",
            "    write_signing_keys,",
            ")",
            "from unpaddedbase64 import decode_base64",
            "",
            "from synapse.util.stringutils import random_string, random_string_with_symbols",
            "",
            "from ._base import Config, ConfigError",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class KeyConfig(Config):",
            "",
            "    def read_config(self, config):",
            "        self.signing_key = self.read_signing_key(config[\"signing_key_path\"])",
            "        self.old_signing_keys = self.read_old_signing_keys(",
            "            config[\"old_signing_keys\"]",
            "        )",
            "        self.key_refresh_interval = self.parse_duration(",
            "            config[\"key_refresh_interval\"]",
            "        )",
            "        self.perspectives = self.read_perspectives(",
            "            config[\"perspectives\"]",
            "        )",
            "",
            "        self.macaroon_secret_key = config.get(",
            "            \"macaroon_secret_key\", self.registration_shared_secret",
            "        )",
            "",
            "        if not self.macaroon_secret_key:",
            "            # Unfortunately, there are people out there that don't have this",
            "            # set. Lets just be \"nice\" and derive one from their secret key.",
            "            logger.warn(\"Config is missing missing macaroon_secret_key\")",
            "            seed = bytes(self.signing_key[0])",
            "            self.macaroon_secret_key = hashlib.sha256(seed).digest()",
            "",
            "        self.expire_access_token = config.get(\"expire_access_token\", False)",
            "",
            "        # a secret which is used to calculate HMACs for form values, to stop",
            "        # falsification of values",
            "        self.form_secret = config.get(\"form_secret\", None)",
            "",
            "    def default_config(self, config_dir_path, server_name, is_generating_file=False,",
            "                       **kwargs):",
            "        base_key_name = os.path.join(config_dir_path, server_name)",
            "",
            "        if is_generating_file:",
            "            macaroon_secret_key = '\"%s\"' % random_string_with_symbols(50)",
            "            form_secret = '\"%s\"' % random_string_with_symbols(50)",
            "        else:",
            "            macaroon_secret_key = 'null'",
            "            form_secret = 'null'",
            "",
            "        return \"\"\"\\",
            "        macaroon_secret_key: %(macaroon_secret_key)s",
            "",
            "        # Used to enable access token expiration.",
            "        expire_access_token: False",
            "",
            "        # a secret which is used to calculate HMACs for form values, to stop",
            "        # falsification of values",
            "        form_secret: %(form_secret)s",
            "",
            "        ## Signing Keys ##",
            "",
            "        # Path to the signing key to sign messages with",
            "        signing_key_path: \"%(base_key_name)s.signing.key\"",
            "",
            "        # The keys that the server used to sign messages with but won't use",
            "        # to sign new messages. E.g. it has lost its private key",
            "        old_signing_keys: {}",
            "        #  \"ed25519:auto\":",
            "        #    # Base64 encoded public key",
            "        #    key: \"The public part of your old signing key.\"",
            "        #    # Millisecond POSIX timestamp when the key expired.",
            "        #    expired_ts: 123456789123",
            "",
            "        # How long key response published by this server is valid for.",
            "        # Used to set the valid_until_ts in /key/v2 APIs.",
            "        # Determines how quickly servers will query to check which keys",
            "        # are still valid.",
            "        key_refresh_interval: \"1d\" # 1 Day.",
            "",
            "        # The trusted servers to download signing keys from.",
            "        perspectives:",
            "          servers:",
            "            \"matrix.org\":",
            "              verify_keys:",
            "                \"ed25519:auto\":",
            "                  key: \"Noi6WqcDj0QmPxCNQqgezwTlBKrfqehY1u2FyWP9uYw\"",
            "        \"\"\" % locals()",
            "",
            "    def read_perspectives(self, perspectives_config):",
            "        servers = {}",
            "        for server_name, server_config in perspectives_config[\"servers\"].items():",
            "            for key_id, key_data in server_config[\"verify_keys\"].items():",
            "                if is_signing_algorithm_supported(key_id):",
            "                    key_base64 = key_data[\"key\"]",
            "                    key_bytes = decode_base64(key_base64)",
            "                    verify_key = decode_verify_key_bytes(key_id, key_bytes)",
            "                    servers.setdefault(server_name, {})[key_id] = verify_key",
            "        return servers",
            "",
            "    def read_signing_key(self, signing_key_path):",
            "        signing_keys = self.read_file(signing_key_path, \"signing_key\")",
            "        try:",
            "            return read_signing_keys(signing_keys.splitlines(True))",
            "        except Exception as e:",
            "            raise ConfigError(",
            "                \"Error reading signing_key: %s\" % (str(e))",
            "            )",
            "",
            "    def read_old_signing_keys(self, old_signing_keys):",
            "        keys = {}",
            "        for key_id, key_data in old_signing_keys.items():",
            "            if is_signing_algorithm_supported(key_id):",
            "                key_base64 = key_data[\"key\"]",
            "                key_bytes = decode_base64(key_base64)",
            "                verify_key = decode_verify_key_bytes(key_id, key_bytes)",
            "                verify_key.expired_ts = key_data[\"expired_ts\"]",
            "                keys[key_id] = verify_key",
            "            else:",
            "                raise ConfigError(",
            "                    \"Unsupported signing algorithm for old key: %r\" % (key_id,)",
            "                )",
            "        return keys",
            "",
            "    def generate_files(self, config):",
            "        signing_key_path = config[\"signing_key_path\"]",
            "",
            "        if not self.path_exists(signing_key_path):",
            "            with open(signing_key_path, \"w\") as signing_key_file:",
            "                key_id = \"a_\" + random_string(4)",
            "                write_signing_keys(",
            "                    signing_key_file, (generate_signing_key(key_id),),",
            "                )",
            "        else:",
            "            signing_keys = self.read_file(signing_key_path, \"signing_key\")",
            "            if len(signing_keys.split(\"\\n\")[0].split()) == 1:",
            "                # handle keys in the old format.",
            "                key_id = \"a_\" + random_string(4)",
            "                key = decode_signing_key_base64(",
            "                    NACL_ED25519, key_id, signing_keys.split(\"\\n\")[0]",
            "                )",
            "                with open(signing_key_path, \"w\") as signing_key_file:",
            "                    write_signing_keys(",
            "                        signing_key_file, (key,),",
            "                    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "60": [
                "KeyConfig",
                "read_config"
            ],
            "61": [
                "KeyConfig",
                "read_config"
            ],
            "74": [
                "KeyConfig",
                "default_config"
            ],
            "77": [
                "KeyConfig",
                "default_config"
            ],
            "81": [
                "KeyConfig",
                "default_config"
            ]
        },
        "addLocation": []
    }
}