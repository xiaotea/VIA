{
    "colander/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 607,
                "PatchRowcode": "     return checksum"
            },
            "1": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": 608,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 609,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+# Gingerly lifted from Django 1.3.x:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+# https://github.com/django/django/blob/stable/1.3.x/django/core/validators.py#L45"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+# <3 y'all!"
            },
            "6": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 613,
                "PatchRowcode": " URL_REGEX = ("
            },
            "7": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r'(?i)\\b((?:[a-z][\\w-]+:(?:/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|'"
            },
            "8": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r'[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|'"
            },
            "9": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r'(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|'"
            },
            "10": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    r'[^\\s`!()\\[\\]{};:\\'\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))'  # \"emacs!"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 614,
                "PatchRowcode": "+    # {http,ftp}s:// (not required)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+    r'^((?:http|ftp)s?://)?'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+    # Domain"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+'"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+    r'(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+    # Localhost"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+    r'localhost|'"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+    # IPv6 address"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+    r'\\[[a-f0-9:]+\\]|'"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+    # IPv4 address"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+    r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+    # Optional port"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+    r'(?::\\d+)?'"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+    # Path"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+    r'(?:/?|[/?]\\S+)$'"
            },
            "26": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 629,
                "PatchRowcode": " )"
            },
            "27": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": 630,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-url = Regex(URL_REGEX, _('Must be a URL'))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+url = Regex(URL_REGEX, msg=_('Must be a URL'), flags=re.IGNORECASE)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 632,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 633,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+URI_REGEX = ("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+    # file:// (required)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+    r'^file://'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+    # Path"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+    r'(?:/|[/?]\\S+)$'"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+file_uri = Regex("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+    URI_REGEX, msg=_('Must be a file:// URI scheme'), flags=re.IGNORECASE"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+)"
            },
            "42": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": 644,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 645,
                "PatchRowcode": " UUID_REGEX = ("
            },
            "44": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 646,
                "PatchRowcode": "     r'^(?:urn:uuid:)?\\{?[a-f0-9]{8}(?:-?[a-f0-9]{4}){3}-?[a-f0-9]{12}\\}?$'"
            }
        },
        "frontPatchFile": [
            "# coding=utf-8",
            "import copy",
            "import datetime",
            "import decimal",
            "import functools",
            "import itertools",
            "import pprint",
            "import re",
            "import translationstring",
            "import warnings",
            "import types",
            "",
            "from iso8601 import iso8601",
            "",
            "from .compat import text_, text_type, string_types, xrange, is_nonstr_iter",
            "",
            "",
            "_ = translationstring.TranslationStringFactory('colander')",
            "",
            "",
            "class _required(object):",
            "    \"\"\" Represents a required value in colander-related operations. \"\"\"",
            "",
            "    def __repr__(self):",
            "        return '<colander.required>'",
            "",
            "    def __reduce__(self):",
            "        # when unpickled, refers to \"required\" below (singleton)",
            "        return 'required'",
            "",
            "",
            "required = _required()",
            "_marker = required  # bw compat",
            "",
            "",
            "class _null(object):",
            "    \"\"\" Represents a null value in colander-related operations. \"\"\"",
            "",
            "    def __nonzero__(self):",
            "        return False",
            "",
            "    # py3 compat",
            "    __bool__ = __nonzero__",
            "",
            "    def __repr__(self):",
            "        return '<colander.null>'",
            "",
            "    def __reduce__(self):",
            "        return 'null'  # when unpickled, refers to \"null\" below (singleton)",
            "",
            "",
            "null = _null()",
            "",
            "",
            "class _drop(object):",
            "    \"\"\" Represents a value that will be dropped from the schema if it",
            "    is missing during *serialization* or *deserialization*.  Passed as",
            "    a value to the `missing` or `default` keyword argument",
            "    of :class:`SchemaNode`.",
            "    \"\"\"",
            "",
            "    def __repr__(self):",
            "        return '<colander.drop>'",
            "",
            "    def __reduce__(self):",
            "        return 'drop'  # when unpickled, refers to \"drop\" below (singleton)",
            "",
            "",
            "drop = _drop()",
            "",
            "",
            "def interpolate(msgs):",
            "    for s in msgs:",
            "        if hasattr(s, 'interpolate'):",
            "            yield s.interpolate()",
            "        else:",
            "            yield s",
            "",
            "",
            "class UnboundDeferredError(Exception):",
            "    \"\"\"",
            "    An exception raised by :meth:`SchemaNode.deserialize` when an attempt",
            "    is made to deserialize a node which has an unbound :class:`deferred`",
            "    validator.",
            "    \"\"\"",
            "",
            "",
            "class Invalid(Exception):",
            "    \"\"\"",
            "    An exception raised by data types and validators indicating that",
            "    the value for a particular node was not valid.",
            "",
            "    The constructor receives a mandatory ``node`` argument.  This must",
            "    be an instance of the :class:`colander.SchemaNode` class, or at",
            "    least something with the same interface.",
            "",
            "    The constructor also receives an optional ``msg`` keyword",
            "    argument, defaulting to ``None``.  The ``msg`` argument is a",
            "    freeform field indicating the error circumstance.",
            "",
            "    The constructor additionally may receive an optional ``value``",
            "    keyword, indicating the value related to the error.",
            "    \"\"\"",
            "",
            "    pos = None",
            "    positional = False",
            "",
            "    def __init__(self, node, msg=None, value=None):",
            "        Exception.__init__(self, node, msg)",
            "        self.node = node",
            "        self.msg = msg",
            "        self.value = value",
            "        self.children = []",
            "",
            "    def messages(self):",
            "        \"\"\" Return an iterable of error messages for this exception using the",
            "        ``msg`` attribute of this error node.  If the ``msg`` attribute is",
            "        iterable, it is returned.  If it is not iterable, and is",
            "        non-``None``, a single-element list containing the ``msg`` value is",
            "        returned.  If the value is ``None``, an empty list is returned.\"\"\"",
            "        if is_nonstr_iter(self.msg):",
            "            return self.msg",
            "        if self.msg is None:",
            "            return []",
            "        return [self.msg]",
            "",
            "    def add(self, exc, pos=None):",
            "        \"\"\" Add a child exception; ``exc`` must be an instance of",
            "        :class:`colander.Invalid` or a subclass.",
            "",
            "        ``pos`` is a value important for accurate error reporting.  If",
            "        it is provided, it must be an integer representing the",
            "        position of ``exc`` relative to all other subexceptions of",
            "        this exception node.  For example, if the exception being",
            "        added is about the third child of the exception which is",
            "        ``self``, ``pos`` might be passed as ``3``.",
            "",
            "        If ``pos`` is provided, it will be assigned to the ``pos``",
            "        attribute of the provided ``exc`` object.",
            "        \"\"\"",
            "        if self.node and isinstance(self.node.typ, Positional):",
            "            exc.positional = True",
            "        if pos is not None:",
            "            exc.pos = pos",
            "        self.children.append(exc)",
            "",
            "    def __setitem__(self, name, msg):",
            "        \"\"\" Add a subexception related to a child node with the",
            "        message ``msg``. ``name`` must be present in the names of the",
            "        set of child nodes of this exception's node; if this is not",
            "        so, a :exc:`KeyError` is raised.",
            "",
            "        For example, if the exception upon which ``__setitem__`` is",
            "        called has a node attribute, and that node attribute has",
            "        children that have the names ``name`` and ``title``, you may",
            "        successfully call ``__setitem__('name', 'Bad name')`` or",
            "        ``__setitem__('title', 'Bad title')``.  But calling",
            "        ``__setitem__('wrong', 'whoops')`` will result in a",
            "        :exc:`KeyError`.",
            "",
            "        This method is typically only useful if the ``node`` attribute",
            "        of the exception upon which it is called is a schema node",
            "        representing a mapping.",
            "        \"\"\"",
            "        for num, child in enumerate(self.node.children):",
            "            if child.name == name:",
            "                exc = Invalid(child, msg)",
            "                self.add(exc, num)",
            "                return",
            "        raise KeyError(name)",
            "",
            "    def paths(self):",
            "        \"\"\" A generator which returns each path through the exception",
            "        graph.  Each path is represented as a tuple of exception",
            "        nodes.  Within each tuple, the leftmost item will represent",
            "        the root schema node, the rightmost item will represent the",
            "        leaf schema node.\"\"\"",
            "",
            "        def traverse(node, stack):",
            "            stack.append(node)",
            "",
            "            if not node.children:",
            "                yield tuple(stack)",
            "",
            "            for child in node.children:",
            "                for path in traverse(child, stack):",
            "                    yield path",
            "",
            "            stack.pop()",
            "",
            "        return traverse(self, [])",
            "",
            "    def _keyname(self):",
            "        if self.positional:",
            "            return str(self.pos)",
            "        return str(self.node.name)",
            "",
            "    def asdict(self, translate=None, separator='; '):",
            "        \"\"\" Return a dictionary containing a basic",
            "        (non-language-translated) error report for this exception.",
            "",
            "        If ``translate`` is supplied, it must be a callable taking a",
            "        translation string as its sole argument and returning a localized,",
            "        interpolated string.",
            "",
            "        If ``separator`` is supplied, error messages are joined with that.",
            "        \"\"\"",
            "        paths = self.paths()",
            "        errors = {}",
            "        for path in paths:",
            "            keyparts = []",
            "            msgs = []",
            "            for exc in path:",
            "                exc.msg and msgs.extend(exc.messages())",
            "                keyname = exc._keyname()",
            "                keyname and keyparts.append(keyname)",
            "            if translate:",
            "                msgs = [translate(msg) for msg in msgs]",
            "            msgs = interpolate(msgs)",
            "            if separator:",
            "                msgs = separator.join(msgs)",
            "            else:",
            "                msgs = list(msgs)",
            "            errors['.'.join(keyparts)] = msgs",
            "        return errors",
            "",
            "    def __str__(self):",
            "        \"\"\" Return a pretty-formatted string representation of the",
            "        result of an execution of this exception's ``asdict`` method\"\"\"",
            "        return pprint.pformat(self.asdict())",
            "",
            "",
            "class UnsupportedFields(Invalid):",
            "    \"\"\"",
            "    Exception used when schema object detect unknown fields in the",
            "    cstruct during deserialize.",
            "    \"\"\"",
            "",
            "    def __init__(self, node, fields, msg=None):",
            "        super(UnsupportedFields, self).__init__(node, msg)",
            "        self.fields = fields",
            "",
            "",
            "class All(object):",
            "    \"\"\" Composite validator which succeeds if none of its",
            "    subvalidators raises an :class:`colander.Invalid` exception\"\"\"",
            "",
            "    def __init__(self, *validators):",
            "        self.validators = validators",
            "",
            "    def __call__(self, node, value):",
            "        excs = []",
            "        for validator in self.validators:",
            "            try:",
            "                validator(node, value)",
            "            except Invalid as e:",
            "                excs.append(e)",
            "",
            "        if excs:",
            "            exc = Invalid(node, [exc.msg for exc in excs])",
            "            for e in excs:",
            "                exc.children.extend(e.children)",
            "            raise exc",
            "",
            "",
            "class Any(All):",
            "    \"\"\" Composite validator which succeeds if at least one of its",
            "    subvalidators does not raise an :class:`colander.Invalid` exception.\"\"\"",
            "",
            "    def __call__(self, node, value):",
            "        try:",
            "            return super(Any, self).__call__(node, value)",
            "        except Invalid as e:",
            "            if len(e.msg) < len(self.validators):",
            "                # At least one validator did not fail:",
            "                return",
            "            raise",
            "",
            "",
            "class Function(object):",
            "    \"\"\" Validator which accepts a function and an optional message;",
            "    the function is called with the ``value`` during validation.",
            "",
            "    If the function returns anything falsy (``None``, ``False``, the",
            "    empty string, ``0``, an object with a ``__nonzero__`` that returns",
            "    ``False``, etc) when called during validation, an",
            "    :exc:`colander.Invalid` exception is raised (validation fails);",
            "    its msg will be the value of the ``msg`` argument passed to this",
            "    class' constructor.",
            "",
            "    If the function returns a stringlike object (a ``str`` or",
            "    ``unicode`` object) that is *not* the empty string , a",
            "    :exc:`colander.Invalid` exception is raised using the stringlike",
            "    value returned from the function as the exeption message",
            "    (validation fails).",
            "",
            "    If the function returns anything *except* a stringlike object",
            "    object which is truthy (e.g. ``True``, the integer ``1``, an",
            "    object with a ``__nonzero__`` that returns ``True``, etc), an",
            "    :exc:`colander.Invalid` exception is *not* raised (validation",
            "    succeeds).",
            "",
            "    The default value for the ``msg`` when not provided via the",
            "    constructor is ``Invalid value``.",
            "",
            "    The ``message`` parameter has been deprecated, use ``msg`` instead.",
            "    \"\"\"",
            "",
            "    def __init__(self, function, msg=None, message=None):",
            "        self.function = function",
            "        if msg is not None and message is not None:",
            "            raise ValueError('Only one of msg and message can be passed')",
            "        # Handle bw compat",
            "        if msg is None and message is None:",
            "            msg = _('Invalid value')",
            "        elif message is not None:",
            "            warnings.warn(",
            "                'The \"message\" argument has been deprecated, use \"msg\" '",
            "                'instead.',",
            "                DeprecationWarning,",
            "            )",
            "            msg = message",
            "        self.msg = msg",
            "",
            "    def __call__(self, node, value):",
            "        result = self.function(value)",
            "        if not result:",
            "            raise Invalid(",
            "                node,",
            "                translationstring.TranslationString(",
            "                    self.msg, mapping={'val': value}",
            "                ),",
            "            )",
            "        if isinstance(result, string_types):",
            "            raise Invalid(",
            "                node,",
            "                translationstring.TranslationString(",
            "                    result, mapping={'val': value}",
            "                ),",
            "            )",
            "",
            "",
            "class Regex(object):",
            "    \"\"\" Regular expression validator.",
            "",
            "        Initialize it with the string regular expression ``regex`` that will",
            "        be compiled and matched against ``value`` when validator is called. It",
            "        uses Python's :py:func:`re.match`, which only matches at the beginning",
            "        of the string and not at the beginning of each line. To match the",
            "        entire string, enclose the regular expression with ``^`` and ``$``.",
            "        If ``msg`` is supplied, it will be the error message to be used;",
            "        otherwise, defaults to 'String does not match expected pattern'.",
            "",
            "        The ``regex`` expression behaviour can be modified by specifying",
            "        any ``flags`` value taken by ``re.compile``.",
            "",
            "        The ``regex`` argument may also be a pattern object (the",
            "        result of ``re.compile``) instead of a string.",
            "",
            "        When calling, if ``value`` matches the regular expression,",
            "        validation succeeds; otherwise, :exc:`colander.Invalid` is",
            "        raised with the ``msg`` error message.",
            "    \"\"\"",
            "",
            "    def __init__(self, regex, msg=None, flags=0):",
            "        if isinstance(regex, string_types):",
            "            self.match_object = re.compile(regex, flags)",
            "        else:",
            "            self.match_object = regex",
            "        if msg is None:",
            "            self.msg = _(\"String does not match expected pattern\")",
            "        else:",
            "            self.msg = msg",
            "",
            "    def __call__(self, node, value):",
            "        if self.match_object.match(value) is None:",
            "            raise Invalid(node, self.msg)",
            "",
            "",
            "# Regex for email addresses.",
            "#",
            "# Stolen from the WhatWG HTML spec:",
            "# https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)",
            "#",
            "# If it is good enough for browsers, it is good enough for us!",
            "EMAIL_RE = (",
            "    r\"^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9]\"",
            "    r\"(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9]\"",
            "    r\"(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\"",
            ")",
            "",
            "",
            "class Email(Regex):",
            "    \"\"\" Email address validator. If ``msg`` is supplied, it will be",
            "        the error message to be used when raising :exc:`colander.Invalid`;",
            "        otherwise, defaults to 'Invalid email address'.",
            "    \"\"\"",
            "",
            "    def __init__(self, msg=None):",
            "        email_regex = text_(EMAIL_RE)",
            "        if msg is None:",
            "            msg = _(\"Invalid email address\")",
            "        super(Email, self).__init__(email_regex, msg=msg)",
            "",
            "",
            "class Range(object):",
            "    \"\"\" Validator which succeeds if the value it is passed is greater",
            "    or equal to ``min`` and less than or equal to ``max``.  If ``min``",
            "    is not specified, or is specified as ``None``, no lower bound",
            "    exists.  If ``max`` is not specified, or is specified as ``None``,",
            "    no upper bound exists.",
            "",
            "    ``min_err`` is used to form the ``msg`` of the",
            "    :exc:`colander.Invalid` error when reporting a validation failure",
            "    caused by a value not meeting the minimum.  If ``min_err`` is",
            "    specified, it must be a string.  The string may contain the",
            "    replacement targets ``${min}`` and ``${val}``, representing the",
            "    minimum value and the provided value respectively.  If it is not",
            "    provided, it defaults to ``'${val} is less than minimum value",
            "    ${min}'``.",
            "",
            "    ``max_err`` is used to form the ``msg`` of the",
            "    :exc:`colander.Invalid` error when reporting a validation failure",
            "    caused by a value exceeding the maximum.  If ``max_err`` is",
            "    specified, it must be a string.  The string may contain the",
            "    replacement targets ``${max}`` and ``${val}``, representing the",
            "    maximum value and the provided value respectively.  If it is not",
            "    provided, it defaults to ``'${val} is greater than maximum value",
            "    ${max}'``.",
            "    \"\"\"",
            "",
            "    _MIN_ERR = _('${val} is less than minimum value ${min}')",
            "    _MAX_ERR = _('${val} is greater than maximum value ${max}')",
            "",
            "    def __init__(self, min=None, max=None, min_err=_MIN_ERR, max_err=_MAX_ERR):",
            "        self.min = min",
            "        self.max = max",
            "        self.min_err = min_err",
            "        self.max_err = max_err",
            "",
            "    def __call__(self, node, value):",
            "        if self.min is not None:",
            "            if value < self.min:",
            "                min_err = _(",
            "                    self.min_err, mapping={'val': value, 'min': self.min}",
            "                )",
            "                raise Invalid(node, min_err)",
            "",
            "        if self.max is not None:",
            "            if value > self.max:",
            "                max_err = _(",
            "                    self.max_err, mapping={'val': value, 'max': self.max}",
            "                )",
            "                raise Invalid(node, max_err)",
            "",
            "",
            "class Length(object):",
            "    \"\"\"Validator which succeeds if the value passed to it has a",
            "        length between a minimum and maximum, expressed in the",
            "        optional ``min`` and ``max`` arguments.",
            "        The value can be any sequence, most often a string.",
            "",
            "        If ``min`` is not specified, or is specified as ``None``,",
            "        no lower bound exists.  If ``max`` is not specified, or",
            "        is specified as ``None``, no upper bound exists.",
            "",
            "        The default error messages are \"Shorter than minimum length ${min}\"",
            "        and \"Longer than maximum length ${max}\". These can be customized:",
            "",
            "        ``min_err`` is used to form the ``msg`` of the",
            "        :exc:`colander.Invalid` error when reporting a validation failure",
            "        caused by a value not meeting the minimum length.  If ``min_err`` is",
            "        specified, it must be a string.  The string may contain the",
            "        replacement target ``${min}``.",
            "",
            "        ``max_err`` is used to form the ``msg`` of the",
            "        :exc:`colander.Invalid` error when reporting a validation failure",
            "        caused by a value exceeding the maximum length.  If ``max_err`` is",
            "        specified, it must be a string.  The string may contain the",
            "        replacement target ``${max}``.",
            "        \"\"\"",
            "",
            "    _MIN_ERR = _('Shorter than minimum length ${min}')",
            "    _MAX_ERR = _('Longer than maximum length ${max}')",
            "",
            "    def __init__(self, min=None, max=None, min_err=_MIN_ERR, max_err=_MAX_ERR):",
            "        self.min = min",
            "        self.max = max",
            "        self.min_err = min_err",
            "        self.max_err = max_err",
            "",
            "    def __call__(self, node, value):",
            "        if self.min is not None:",
            "            if len(value) < self.min:",
            "                min_err = _(self.min_err, mapping={'min': self.min})",
            "                raise Invalid(node, min_err)",
            "        if self.max is not None:",
            "            if len(value) > self.max:",
            "                max_err = _(self.max_err, mapping={'max': self.max})",
            "                raise Invalid(node, max_err)",
            "",
            "",
            "class OneOf(object):",
            "    \"\"\" Validator which succeeds if the value passed to it is one of",
            "    a fixed set of values \"\"\"",
            "",
            "    def __init__(self, choices):",
            "        self.choices = choices",
            "",
            "    def __call__(self, node, value):",
            "        if value not in self.choices:",
            "            choices = ', '.join(['%s' % x for x in self.choices])",
            "            err = _(",
            "                '\"${val}\" is not one of ${choices}',",
            "                mapping={'val': value, 'choices': choices},",
            "            )",
            "            raise Invalid(node, err)",
            "",
            "",
            "class NoneOf(object):",
            "    \"\"\" Validator which succeeds if the value passed to it is none of a",
            "    fixed set of values.",
            "",
            "    ``msg_err`` is used to form the ``msg`` of the :exc:`colander.Invalid`",
            "    error when reporting a validation failure.  If ``msg_err`` is specified,",
            "    it must be a string.  The string may contain the replacement targets",
            "    ``${choices}`` and ``${val}``, representing the set of forbidden values",
            "    and the provided value respectively.",
            "    \"\"\"",
            "",
            "    _MSG_ERR = _('\"${val}\" must not be one of ${choices}')",
            "",
            "    def __init__(self, choices, msg_err=_MSG_ERR):",
            "        self.forbidden = choices",
            "        self.msg_err = msg_err",
            "",
            "    def __call__(self, node, value):",
            "        if value not in self.forbidden:",
            "            return",
            "",
            "        choices = ', '.join(['%s' % x for x in self.forbidden])",
            "        err = _(self.msg_err, mapping={'val': value, 'choices': choices})",
            "",
            "        raise Invalid(node, err)",
            "",
            "",
            "class ContainsOnly(object):",
            "    \"\"\" Validator which succeeds if the value passed to is a sequence and each",
            "    element in the sequence is also in the sequence passed as ``choices``.",
            "    This validator is useful when attached to a schemanode with, e.g. a",
            "    :class:`colander.Set` or another sequencetype.",
            "    \"\"\"",
            "",
            "    err_template = _('One or more of the choices you made was not acceptable')",
            "",
            "    def __init__(self, choices):",
            "        self.choices = choices",
            "",
            "    def __call__(self, node, value):",
            "        if not set(value).issubset(self.choices):",
            "            err = _(",
            "                self.err_template,",
            "                mapping={'val': value, 'choices': self.choices},",
            "            )",
            "            raise Invalid(node, err)",
            "",
            "",
            "def luhnok(node, value):",
            "    \"\"\" Validator which checks to make sure that the value passes a luhn",
            "    mod-10 checksum (credit cards).  ``value`` must be a string, not an",
            "    integer.\"\"\"",
            "    try:",
            "        checksum = _luhnok(value)",
            "    except ValueError:",
            "        raise Invalid(",
            "            node,",
            "            _(",
            "                '\"${val}\" is not a valid credit card number',",
            "                mapping={'val': value},",
            "            ),",
            "        )",
            "",
            "    if (checksum % 10) != 0:",
            "        raise Invalid(",
            "            node,",
            "            _(",
            "                '\"${val}\" is not a valid credit card number',",
            "                mapping={'val': value},",
            "            ),",
            "        )",
            "",
            "",
            "def _luhnok(value):",
            "    checksum = 0",
            "    num_digits = len(value)",
            "    oddeven = num_digits & 1",
            "",
            "    for count in range(0, num_digits):",
            "        digit = int(value[count])",
            "",
            "        if not ((count & 1) ^ oddeven):",
            "            digit *= 2",
            "        if digit > 9:",
            "            digit -= 9",
            "",
            "        checksum += digit",
            "    return checksum",
            "",
            "",
            "URL_REGEX = (",
            "    r'(?i)\\b((?:[a-z][\\w-]+:(?:/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|'",
            "    r'[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|'",
            "    r'(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|'",
            "    r'[^\\s`!()\\[\\]{};:\\'\".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))'  # \"emacs!",
            ")",
            "",
            "url = Regex(URL_REGEX, _('Must be a URL'))",
            "",
            "UUID_REGEX = (",
            "    r'^(?:urn:uuid:)?\\{?[a-f0-9]{8}(?:-?[a-f0-9]{4}){3}-?[a-f0-9]{12}\\}?$'",
            ")",
            "uuid = Regex(UUID_REGEX, _('Invalid UUID string'), re.IGNORECASE)",
            "",
            "",
            "class SchemaType(object):",
            "    \"\"\" Base class for all schema types \"\"\"",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfname = prefix",
            "        else:",
            "            selfname = '%s%s' % (prefix, node.name)",
            "        result[selfname.rstrip('.')] = appstruct",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        name = node.name",
            "        assert paths == [name], \"paths should be [name] for leaf nodes.\"",
            "        return fstruct[name]",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        raise AssertionError(\"Can't call 'set_value' on a leaf node.\")",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        raise AssertionError(\"Can't call 'get_value' on a leaf node.\")",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        return []",
            "",
            "",
            "class Mapping(SchemaType):",
            "    \"\"\" A type which represents a mapping of names to nodes.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type imply the named keys and values in the mapping.",
            "",
            "    The constructor of this type accepts one extra optional keyword",
            "    argument that other types do not: ``unknown``.  An attribute of",
            "    the same name can be set on a type instance to control the",
            "    behavior after construction.",
            "",
            "    unknown",
            "        ``unknown`` controls the behavior of this type when an unknown",
            "        key is encountered in the cstruct passed to the",
            "        ``deserialize`` method of this instance.  All the potential",
            "        values of ``unknown`` are strings.  They are:",
            "",
            "        - ``ignore`` means that keys that are not present in the schema",
            "          associated with this type will be ignored during",
            "          deserialization.",
            "",
            "        - ``raise`` will cause a :exc:`colander.Invalid` exception to",
            "          be raised when unknown keys are present in the cstruct",
            "          during deserialization.",
            "",
            "        - ``preserve`` will preserve the 'raw' unknown keys and values",
            "          in the appstruct returned by deserialization.",
            "",
            "        Default: ``ignore``.",
            "",
            "    Special behavior is exhibited when a subvalue of a mapping is",
            "    present in the schema but is missing from the mapping passed to",
            "    either the ``serialize`` or ``deserialize`` method of this class.",
            "    In this case, the :attr:`colander.null` value will be passed to",
            "    the ``serialize`` or ``deserialize`` method of the schema node",
            "    representing the subvalue of the mapping respectively.  During",
            "    serialization, this will result in the behavior described in",
            "    :ref:`serializing_null` for the subnode.  During deserialization,",
            "    this will result in the behavior described in",
            "    :ref:`deserializing_null` for the subnode.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, a dictionary will be returned, where each of",
            "    the values in the returned dictionary is the serialized",
            "    representation of the null value for its type.",
            "    \"\"\"",
            "",
            "    def __init__(self, unknown='ignore'):",
            "        self.unknown = unknown",
            "",
            "    def _set_unknown(self, value):",
            "        if value not in ('ignore', 'raise', 'preserve'):",
            "            raise ValueError(",
            "                'unknown attribute must be one of \"ignore\", \"raise\", '",
            "                'or \"preserve\"'",
            "            )",
            "        self._unknown = value",
            "",
            "    def _get_unknown(self):",
            "        return self._unknown",
            "",
            "    unknown = property(_get_unknown, _set_unknown)",
            "",
            "    def _validate(self, node, value):",
            "        try:",
            "            if hasattr(value, 'items'):",
            "                return dict(value)",
            "            else:",
            "                raise TypeError('Does not implement dict-like functionality.')",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a mapping type: ${err}',",
            "                    mapping={'val': value, 'err': e},",
            "                ),",
            "            )",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        if cstruct is null:",
            "            value = {}",
            "        else:",
            "            value = self._validate(node, cstruct)",
            "        children = []",
            "        for subnode in node.children:",
            "            name = subnode.name",
            "            subval = value.get(name, _marker)",
            "            if subval is _marker:",
            "                subval = subnode.serialize(null)",
            "            children.append(subval)",
            "        return children",
            "",
            "    def _impl(self, node, value, callback):",
            "        value = self._validate(node, value)",
            "",
            "        error = None",
            "        result = {}",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            name = subnode.name",
            "            subval = value.pop(name, null)",
            "            if subval is drop or (subval is null and subnode.default is drop):",
            "                continue",
            "            try:",
            "                sub_result = callback(subnode, subval)",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "            else:",
            "                if sub_result is drop:",
            "                    continue",
            "                result[name] = sub_result",
            "",
            "        if self.unknown == 'raise':",
            "            if value:",
            "                raise UnsupportedFields(",
            "                    node,",
            "                    value,",
            "                    msg=_(",
            "                        'Unrecognized keys in mapping: \"${val}\"',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "",
            "        elif self.unknown == 'preserve':",
            "            result.update(copy.deepcopy(value))",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return result",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            appstruct = {}",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subcstruct):",
            "            return subnode.deserialize(subcstruct)",
            "",
            "        return self._impl(node, cstruct, callback)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            if node.name:",
            "                selfprefix = '%s%s.' % (prefix, node.name)",
            "            else:",
            "                selfprefix = prefix",
            "",
            "        for subnode in node.children:",
            "            name = subnode.name",
            "            substruct = appstruct.get(name, null)",
            "            result.update(",
            "                subnode.typ.flatten(subnode, substruct, prefix=selfprefix)",
            "            )",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        return _unflatten_mapping(node, paths, fstruct)",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "            next_node = node[next_name]",
            "            next_appstruct = appstruct[next_name]",
            "            appstruct[next_name] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            appstruct[path] = value",
            "        return appstruct",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "            next_node = node[name]",
            "            return next_node.typ.get_value(next_node, appstruct[name], rest)",
            "        return appstruct[path]",
            "",
            "",
            "class Positional(object):",
            "    \"\"\"",
            "    Marker abstract base class meaning 'this type has children which",
            "    should be addressed by position instead of name' (e.g. via seq[0],",
            "    but never seq['name']).  This is consulted by Invalid.asdict when",
            "    creating a dictionary representation of an error tree.",
            "    \"\"\"",
            "",
            "",
            "class Tuple(Positional, SchemaType):",
            "    \"\"\" A type which represents a fixed-length sequence of nodes.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type imply the positional elements of the tuple in the order",
            "    they are added.",
            "",
            "    This type is willing to serialize and deserialized iterables that,",
            "    when converted to a tuple, have the same number of elements as the",
            "    number of the associated node's subnodes.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "    \"\"\"",
            "",
            "    def _validate(self, node, value):",
            "        if not hasattr(value, '__iter__'):",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not iterable', mapping={'val': value})",
            "            )",
            "",
            "        valuelen, nodelen = len(value), len(node.children)",
            "",
            "        if valuelen != nodelen:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" has an incorrect number of elements '",
            "                    '(expected ${exp}, was ${was})',",
            "                    mapping={'val': value, 'exp': nodelen, 'was': valuelen},",
            "                ),",
            "            )",
            "",
            "        return list(value)",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        childlen = len(node.children)",
            "        if cstruct is null:",
            "            cstruct = []",
            "        structlen = len(cstruct)",
            "        if structlen < childlen:",
            "            missing_children = node.children[structlen:]",
            "            cstruct = list(cstruct)",
            "            for child in missing_children:",
            "                cstruct.append(child.serialize(null))",
            "        elif structlen > childlen:",
            "            cstruct = cstruct[:childlen]",
            "        else:",
            "            cstruct = list(cstruct)",
            "        return cstruct",
            "",
            "    def _impl(self, node, value, callback):",
            "        value = self._validate(node, value)",
            "        error = None",
            "        result = []",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            subval = value[num]",
            "            try:",
            "                result.append(callback(subnode, subval))",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return tuple(result)",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subval):",
            "            return subnode.deserialize(subval)",
            "",
            "        return self._impl(node, cstruct, callback)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            selfprefix = '%s%s.' % (prefix, node.name)",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            substruct = appstruct[num]",
            "            result.update(",
            "                subnode.typ.flatten(subnode, substruct, prefix=selfprefix)",
            "            )",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        mapstruct = _unflatten_mapping(node, paths, fstruct)",
            "        appstruct = []",
            "        for subnode in node.children:",
            "            appstruct.append(mapstruct[subnode.name])",
            "        return tuple(appstruct)",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        appstruct = list(appstruct)",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "        else:",
            "            next_name, rest = path, None",
            "        for index, next_node in enumerate(node.children):",
            "            if next_node.name == next_name:",
            "                break",
            "        else:",
            "            raise KeyError(next_name)",
            "        if rest is not None:",
            "            next_appstruct = appstruct[index]",
            "            appstruct[index] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            appstruct[index] = value",
            "        return tuple(appstruct)",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "        else:",
            "            name, rest = path, None",
            "        for index, next_node in enumerate(node.children):",
            "            if next_node.name == name:",
            "                break",
            "        else:",
            "            raise KeyError(name)",
            "        if rest is not None:",
            "            return next_node.typ.get_value(next_node, appstruct[index], rest)",
            "        return appstruct[index]",
            "",
            "",
            "class Set(SchemaType):",
            "    \"\"\" A type representing a non-overlapping set of items.",
            "    Deserializes an iterable to a ``set`` object.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    .. versionadded: 1.0a1",
            "",
            "    \"\"\"",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        if not is_nonstr_iter(cstruct):",
            "            raise Invalid(",
            "                node,",
            "                _('${cstruct} is not iterable', mapping={'cstruct': cstruct}),",
            "            )",
            "",
            "        return set(cstruct)",
            "",
            "",
            "class List(SchemaType):",
            "    \"\"\" Type representing an ordered sequence of items.",
            "",
            "    Desrializes an iterable to a ``list`` object.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    .. versionadded: 1.0a6",
            "    \"\"\"",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        if not is_nonstr_iter(cstruct):",
            "            raise Invalid(",
            "                node,",
            "                _('${cstruct} is not iterable', mapping={'cstruct': cstruct}),",
            "            )",
            "",
            "        return list(cstruct)",
            "",
            "",
            "class SequenceItems(list):",
            "    \"\"\"",
            "    List marker subclass for use by Sequence.cstruct_children, which indicates",
            "    to a caller of that method that the result is from a sequence type.",
            "    Usually these values need to be treated specially, because all of the",
            "    children of a Sequence are not present in a schema.",
            "    \"\"\"",
            "",
            "",
            "class Sequence(Positional, SchemaType):",
            "    \"\"\"",
            "    A type which represents a variable-length sequence of nodes,",
            "    all of which must be of the same type.",
            "",
            "    The type of the first subnode of the",
            "    :class:`colander.SchemaNode` that wraps this type is considered the",
            "    sequence type.",
            "",
            "    The optional ``accept_scalar`` argument to this type's constructor",
            "    indicates what should happen if the value found during serialization or",
            "    deserialization does not have an ``__iter__`` method or is a",
            "    mapping type.",
            "",
            "    If ``accept_scalar`` is ``True`` and the value does not have an",
            "    ``__iter__`` method or is a mapping type, the value will be turned",
            "    into a single element list.",
            "",
            "    If ``accept_scalar`` is ``False`` and the value does not have an",
            "    ``__iter__`` method or is a mapping type, an",
            "    :exc:`colander.Invalid` error will be raised during serialization",
            "    and deserialization.",
            "",
            "    The default value of ``accept_scalar`` is ``False``.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value is returned.",
            "    \"\"\"",
            "",
            "    def __init__(self, accept_scalar=False):",
            "        self.accept_scalar = accept_scalar",
            "",
            "    def _validate(self, node, value, accept_scalar):",
            "        if (",
            "            hasattr(value, '__iter__')",
            "            and not hasattr(value, 'get')",
            "            and not isinstance(value, string_types)",
            "        ):",
            "            return list(value)",
            "        if accept_scalar:",
            "            return [value]",
            "        else:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not iterable', mapping={'val': value})",
            "            )",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        if cstruct is null:",
            "            return SequenceItems([])",
            "        return SequenceItems(cstruct)",
            "",
            "    def _impl(self, node, value, callback, accept_scalar):",
            "        if accept_scalar is None:",
            "            accept_scalar = self.accept_scalar",
            "",
            "        value = self._validate(node, value, accept_scalar)",
            "",
            "        error = None",
            "        result = []",
            "",
            "        subnode = node.children[0]",
            "        for num, subval in enumerate(value):",
            "            if subval is drop or (subval is null and subnode.default is drop):",
            "                continue",
            "            try:",
            "                sub_result = callback(subnode, subval)",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "            else:",
            "                if sub_result is drop:",
            "                    continue",
            "                result.append(sub_result)",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return result",
            "",
            "    def serialize(self, node, appstruct, accept_scalar=None):",
            "        \"\"\"",
            "        Along with the normal ``node`` and ``appstruct`` arguments,",
            "        this method accepts an additional optional keyword argument:",
            "        ``accept_scalar``.  This keyword argument can be used to",
            "        override the constructor value of the same name.",
            "",
            "        If ``accept_scalar`` is ``True`` and the ``appstruct`` does",
            "        not have an ``__iter__`` method or is a mapping type, the",
            "        value will be turned into a single element list.",
            "",
            "        If ``accept_scalar`` is ``False`` and the ``appstruct`` does",
            "        not have an ``__iter__`` method or is a mapping type, an",
            "        :exc:`colander.Invalid` error will be raised during",
            "        serialization and deserialization.",
            "",
            "        The default of ``accept_scalar`` is ``None``, which means",
            "        respect the default ``accept_scalar`` value attached to this",
            "        instance via its constructor.",
            "        \"\"\"",
            "        if appstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback, accept_scalar)",
            "",
            "    def deserialize(self, node, cstruct, accept_scalar=None):",
            "        \"\"\"",
            "        Along with the normal ``node`` and ``cstruct`` arguments, this",
            "        method accepts an additional optional keyword argument:",
            "        ``accept_scalar``.  This keyword argument can be used to",
            "        override the constructor value of the same name.",
            "",
            "        If ``accept_scalar`` is ``True`` and the ``cstruct`` does not",
            "        have an ``__iter__`` method or is a mapping type, the value",
            "        will be turned into a single element list.",
            "",
            "        If ``accept_scalar`` is ``False`` and the ``cstruct`` does not have an",
            "        ``__iter__`` method or is a mapping type, an",
            "        :exc:`colander.Invalid` error will be raised during serialization",
            "        and deserialization.",
            "",
            "        The default of ``accept_scalar`` is ``None``, which means",
            "        respect the default ``accept_scalar`` value attached to this",
            "        instance via its constructor.",
            "        \"\"\"",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subcstruct):",
            "            return subnode.deserialize(subcstruct)",
            "",
            "        return self._impl(node, cstruct, callback, accept_scalar)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            selfprefix = '%s%s.' % (prefix, node.name)",
            "",
            "        childnode = node.children[0]",
            "",
            "        for num, subval in enumerate(appstruct):",
            "            subname = '%s%s' % (selfprefix, num)",
            "            subprefix = subname + '.'",
            "            result.update(",
            "                childnode.typ.flatten(",
            "                    childnode, subval, prefix=subprefix, listitem=True",
            "                )",
            "            )",
            "",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        only_child = node.children[0]",
            "        child_name = only_child.name",
            "",
            "        def get_child(name):",
            "            return only_child",
            "",
            "        def rewrite_subpath(subpath):",
            "            if '.' in subpath:",
            "                suffix = subpath.split('.', 1)[1]",
            "                return '%s.%s' % (child_name, suffix)",
            "            return child_name",
            "",
            "        mapstruct = _unflatten_mapping(",
            "            node, paths, fstruct, get_child, rewrite_subpath",
            "        )",
            "        return [mapstruct[str(index)] for index in xrange(len(mapstruct))]",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "            index = int(next_name)",
            "            next_node = node.children[0]",
            "            next_appstruct = appstruct[index]",
            "            appstruct[index] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            index = int(path)",
            "            appstruct[index] = value",
            "        return appstruct",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "            index = int(name)",
            "            next_node = node.children[0]",
            "            return next_node.typ.get_value(next_node, appstruct[index], rest)",
            "        return appstruct[int(path)]",
            "",
            "",
            "Seq = Sequence",
            "",
            "",
            "class String(SchemaType):",
            "    \"\"\" A type representing a Unicode string.",
            "",
            "    This type constructor accepts two arguments:",
            "",
            "    ``encoding``",
            "       Represents the encoding which should be applied to value",
            "       serialization and deserialization, for example ``utf-8``.  If",
            "       ``encoding`` is passed as ``None``, the ``serialize`` method of",
            "       this type will not do any special encoding of the appstruct it is",
            "       provided, nor will the ``deserialize`` method of this type do",
            "       any special decoding of the cstruct it is provided; inputs and",
            "       outputs will be assumed to be Unicode.  ``encoding`` defaults",
            "       to ``None``.",
            "",
            "       If ``encoding`` is ``None``:",
            "",
            "       - A Unicode input value to ``serialize`` is returned untouched.",
            "",
            "       - A non-Unicode input value to ``serialize`` is run through the",
            "         ``unicode()`` function without an ``encoding`` parameter",
            "         (``unicode(value)``) and the result is returned.",
            "",
            "       - A Unicode input value to ``deserialize`` is returned untouched.",
            "",
            "       - A non-Unicode input value to ``deserialize`` is run through the",
            "         ``unicode()`` function without an ``encoding`` parameter",
            "         (``unicode(value)``) and the result is returned.",
            "",
            "       If ``encoding`` is not ``None``:",
            "",
            "       - A Unicode input value to ``serialize`` is run through the",
            "         ``unicode`` function with the encoding parameter",
            "         (``unicode(value, encoding)``) and the result (a ``str``",
            "         object) is returned.",
            "",
            "       - A non-Unicode input value to ``serialize`` is converted to a",
            "         Unicode using the encoding (``unicode(value, encoding)``);",
            "         subsequently the Unicode object is re-encoded to a ``str``",
            "         object using the encoding and returned.",
            "",
            "       - A Unicode input value to ``deserialize`` is returned",
            "         untouched.",
            "",
            "       - A non-Unicode input value to ``deserialize`` is converted to",
            "         a ``str`` object using ``str(value``).  The resulting str",
            "         value is converted to Unicode using the encoding",
            "         (``unicode(value, encoding)``) and the result is returned.",
            "",
            "       A corollary: If a string (as opposed to a unicode object) is",
            "       provided as a value to either the serialize or deserialize",
            "       method of this type, and the type also has an non-None",
            "       ``encoding``, the string must be encoded with the type's",
            "       encoding.  If this is not true, an :exc:`colander.Invalid`",
            "       error will result.",
            "",
            "    ``allow_empty``",
            "       Boolean, if True allows deserialization of an empty string. If",
            "       False (default), empty strings will deserialize to",
            "       :attr:`colander.null`",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, encoding=None, allow_empty=False):",
            "        self.encoding = encoding",
            "        self.allow_empty = allow_empty",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        try:",
            "            if isinstance(appstruct, (text_type, bytes)):",
            "                encoding = self.encoding",
            "                if encoding:",
            "                    result = text_(appstruct, encoding).encode(encoding)",
            "                else:",
            "                    result = text_type(appstruct)",
            "            else:",
            "                result = text_type(appstruct)",
            "                if self.encoding:",
            "                    result = result.encode(self.encoding)",
            "            return result",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '${val} cannot be serialized: ${err}',",
            "                    mapping={'val': appstruct, 'err': e},",
            "                ),",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct == '' and self.allow_empty:",
            "            return text_type('')",
            "",
            "        if not cstruct:",
            "            return null",
            "",
            "        try:",
            "            result = cstruct",
            "            if isinstance(result, (text_type, bytes)):",
            "                if self.encoding:",
            "                    result = text_(cstruct, self.encoding)",
            "                else:",
            "                    result = text_type(cstruct)",
            "            else:",
            "                raise Invalid(node)",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '${val} is not a string: ${err}',",
            "                    mapping={'val': cstruct, 'err': e},",
            "                ),",
            "            )",
            "",
            "        return result",
            "",
            "",
            "Str = String",
            "",
            "",
            "class Number(SchemaType):",
            "    \"\"\" Abstract base class for float, int, decimal \"\"\"",
            "",
            "    num = None",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct in (null, None):",
            "            return null",
            "",
            "        try:",
            "            return str(self.num(appstruct))",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a number', mapping={'val': appstruct})",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct != 0 and not cstruct:",
            "            return null",
            "",
            "        try:",
            "            return self.num(cstruct)",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a number', mapping={'val': cstruct})",
            "            )",
            "",
            "",
            "class Integer(Number):",
            "    \"\"\" A type representing an integer.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    num = int",
            "",
            "",
            "Int = Integer",
            "",
            "",
            "class Float(Number):",
            "    \"\"\" A type representing a float.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    num = float",
            "",
            "",
            "class Decimal(Number):",
            "    \"\"\"",
            "    A type representing a decimal floating point.  Deserialization returns an",
            "    instance of the Python ``decimal.Decimal`` type.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The Decimal constructor takes three optional arguments, ``quant``,",
            "    ``rounding`` and ``normalize``.  If supplied, ``quant`` should be a string,",
            "    (e.g. ``1.00``).  If supplied, ``rounding`` should be one of the Python",
            "    ``decimal`` module rounding options (e.g. ``decimal.ROUND_UP``,",
            "    ``decimal.ROUND_DOWN``, etc).  The serialized and deserialized result",
            "    will be quantized and rounded via",
            "    ``result.quantize(decimal.Decimal(quant), rounding)``.  ``rounding`` is",
            "    ignored if ``quant`` is not supplied.  If ``normalize`` is ``True``,",
            "    the serialized and deserialized result will be normalized by stripping",
            "    the rightmost trailing zeros.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, quant=None, rounding=None, normalize=False):",
            "        if quant is None:",
            "            self.quant = None",
            "        else:",
            "            self.quant = decimal.Decimal(quant)",
            "        self.rounding = rounding",
            "        self.normalize = normalize",
            "",
            "    def num(self, val):",
            "        result = decimal.Decimal(str(val))",
            "        if self.quant is not None:",
            "            if self.rounding is None:",
            "                result = result.quantize(self.quant)",
            "            else:",
            "                result = result.quantize(self.quant, self.rounding)",
            "        if self.normalize:",
            "            result = result.normalize()",
            "        return result",
            "",
            "",
            "class Money(Decimal):",
            "    \"\"\" A type representing a money value with two digit precision.",
            "    Deserialization returns an instance of the Python ``decimal.Decimal``",
            "    type (quantized to two decimal places, rounded up).",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Money, self).__init__(decimal.Decimal('.01'), decimal.ROUND_UP)",
            "",
            "",
            "class Boolean(SchemaType):",
            "    \"\"\" A type representing a boolean object.",
            "",
            "    The constructor accepts these keyword arguments:",
            "",
            "    - ``false_choices``: The set of strings representing a ``False``",
            "      value on deserialization.",
            "",
            "    - ``true_choices``:  The set of strings representing a ``True``",
            "      value on deserialization.",
            "",
            "    - ``false_val``: The value returned on serialization of a False",
            "      value.",
            "",
            "    - ``true_val``: The value returned on serialization of a True",
            "      value.",
            "",
            "    During deserialization, a value contained in :attr:`false_choices`,",
            "    will be considered ``False``.",
            "",
            "    The behaviour for values not contained in :attr:`false_choices`",
            "    depends on :attr:`true_choices`: if it's empty, any value is considered",
            "    ``True``; otherwise, only values contained in :attr:`true_choices`",
            "    are considered ``True``, and an Invalid exception would be raised",
            "    for values outside of both :attr:`false_choices` and :attr:`true_choices`.",
            "",
            "    Serialization will produce :attr:`true_val` or :attr:`false_val`",
            "    based on the value.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        false_choices=('false', '0'),",
            "        true_choices=(),",
            "        false_val='false',",
            "        true_val='true',",
            "    ):",
            "",
            "        self.false_choices = false_choices",
            "        self.true_choices = true_choices",
            "        self.false_val = false_val",
            "        self.true_val = true_val",
            "",
            "        self.true_reprs = ', '.join([repr(c) for c in self.true_choices])",
            "        self.false_reprs = ', '.join([repr(c) for c in self.false_choices])",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct and self.true_val or self.false_val",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        try:",
            "            result = str(cstruct)",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('${val} is not a string', mapping={'val': cstruct})",
            "            )",
            "        result = result.lower()",
            "",
            "        if result in self.false_choices:",
            "            return False",
            "        elif self.true_choices:",
            "            if result in self.true_choices:",
            "                return True",
            "            else:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        '\"${val}\" is neither in (${false_choices}) '",
            "                        'nor in (${true_choices})',",
            "                        mapping={",
            "                            'val': cstruct,",
            "                            'false_choices': self.false_reprs,",
            "                            'true_choices': self.true_reprs,",
            "                        },",
            "                    ),",
            "                )",
            "",
            "        return True",
            "",
            "",
            "Bool = Boolean",
            "",
            "",
            "class GlobalObject(SchemaType):",
            "    \"\"\" A type representing an importable Python object.  This type",
            "    serializes 'global' Python objects (objects which can be imported)",
            "    to dotted Python names.",
            "",
            "    Two dotted name styles are supported during deserialization:",
            "",
            "    - ``pkg_resources``-style dotted names where non-module attributes",
            "      of a module are separated from the rest of the path using a ':'",
            "      e.g. ``package.module:attr``.",
            "",
            "    - ``zope.dottedname``-style dotted names where non-module",
            "      attributes of a module are separated from the rest of the path",
            "      using a '.' e.g. ``package.module.attr``.",
            "",
            "    These styles can be used interchangeably.  If the serialization",
            "    contains a ``:`` (colon), the ``pkg_resources`` resolution",
            "    mechanism will be chosen, otherwise the ``zope.dottedname``",
            "    resolution mechanism will be chosen.",
            "",
            "    The constructor accepts a single argument named ``package`` which",
            "    should be a Python module or package object; it is used when",
            "    *relative* dotted names are supplied to the ``deserialize``",
            "    method.  A serialization which has a ``.`` (dot) or ``:`` (colon)",
            "    as its first character is treated as relative.  E.g. if",
            "    ``.minidom`` is supplied to ``deserialize``, and the ``package``",
            "    argument to this type was passed the ``xml`` module object, the",
            "    resulting import would be for ``xml.minidom``.  If a relative",
            "    package name is supplied to ``deserialize``, and no ``package``",
            "    was supplied to the constructor, an :exc:`colander.Invalid` error",
            "    will be raised.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, package):",
            "        self.package = package",
            "",
            "    def _pkg_resources_style(self, node, value):",
            "        \"\"\" package.module:attr style \"\"\"",
            "        import pkg_resources",
            "",
            "        if value.startswith('.') or value.startswith(':'):",
            "            if not self.package:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        'relative name \"${val}\" irresolveable without package',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "            if value in ['.', ':']:",
            "                value = self.package.__name__",
            "            else:",
            "                value = self.package.__name__ + value",
            "        return pkg_resources.EntryPoint.parse('x=%s' % value).load(False)",
            "",
            "    def _zope_dottedname_style(self, node, value):",
            "        \"\"\" package.module.attr style \"\"\"",
            "        module = self.package and self.package.__name__ or None",
            "        if value == '.':",
            "            if self.package is None:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        'relative name \"${val}\" irresolveable without package',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "            name = module.split('.')",
            "        else:",
            "            name = value.split('.')",
            "            if not name[0]:",
            "                if module is None:",
            "                    raise Invalid(",
            "                        node,",
            "                        _(",
            "                            'relative name \"${val}\" irresolveable without '",
            "                            'package',",
            "                            mapping={'val': value},",
            "                        ),",
            "                    )",
            "                module = module.split('.')",
            "                name.pop(0)",
            "                while not name[0]:",
            "                    module.pop()",
            "                    name.pop(0)",
            "                name = module + name",
            "",
            "        used = name.pop(0)",
            "        found = __import__(used)",
            "        for n in name:",
            "            used += '.' + n",
            "            try:",
            "                found = getattr(found, n)",
            "            except AttributeError:  # pragma: no cover",
            "                __import__(used)",
            "                found = getattr(found, n)",
            "",
            "        return found",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        try:",
            "            if isinstance(appstruct, types.ModuleType):",
            "                return appstruct.__name__",
            "            else:",
            "                return '{0.__module__}.{0.__name__}'.format(appstruct)",
            "",
            "        except AttributeError:",
            "            raise Invalid(",
            "                node, _('\"${val}\" has no __name__', mapping={'val': appstruct})",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "",
            "        if not isinstance(cstruct, string_types):",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a string', mapping={'val': cstruct})",
            "            )",
            "        try:",
            "            if ':' in cstruct:",
            "                return self._pkg_resources_style(node, cstruct)",
            "            else:",
            "                return self._zope_dottedname_style(node, cstruct)",
            "        except ImportError:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    'The dotted name \"${name}\" cannot be imported',",
            "                    mapping={'name': cstruct},",
            "                ),",
            "            )",
            "",
            "",
            "class DateTime(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.datetime`` object.",
            "",
            "    This type serializes python ``datetime.datetime`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the date, the time, and the timezone of the",
            "    datetime.",
            "",
            "    The constructor accepts an argument named ``default_tzinfo`` which",
            "    should be a Python ``tzinfo`` object. If ``default_tzinfo`` is not",
            "    specified the default tzinfo will be equivalent to UTC (Zulu time).",
            "    The ``default_tzinfo`` tzinfo object is used to convert 'naive'",
            "    datetimes to a timezone-aware representation during serialization.",
            "    If ``default_tzinfo`` is explicitly set to ``None`` then no default",
            "    tzinfo will be applied to naive datetimes.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.date`` objects to a DateTime ISO string representation",
            "    during serialization.  It does so by using midnight of the day as",
            "    the time, and uses the ``default_tzinfo`` to give the",
            "    serialization a timezone.",
            "",
            "    Likewise, for convenience, during deserialization, this type will",
            "    convert ``YYYY-MM-DD`` ISO8601 values to a datetime object.  It",
            "    does so by using midnight of the day as the time, and uses the",
            "    ``default_tzinfo`` to give the serialization a timezone.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid date')",
            "",
            "    def __init__(self, default_tzinfo=iso8601.UTC, format=None):",
            "        self.default_tzinfo = default_tzinfo",
            "        self.format = format",
            "",
            "    def serialize(self, node, appstruct):",
            "        if not appstruct:",
            "            return null",
            "",
            "        # cant use isinstance; dt subs date",
            "        if type(appstruct) is datetime.date:",
            "            appstruct = datetime.datetime.combine(appstruct, datetime.time())",
            "",
            "        if not isinstance(appstruct, datetime.datetime):",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a datetime object',",
            "                    mapping={'val': appstruct},",
            "                ),",
            "            )",
            "",
            "        if appstruct.tzinfo is None:",
            "            appstruct = appstruct.replace(tzinfo=self.default_tzinfo)",
            "        if not self.format:",
            "            return appstruct.isoformat()",
            "        else:",
            "            return appstruct.strftime(self.format)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "",
            "        try:",
            "            if self.format:",
            "                result = datetime.datetime.strptime(cstruct, self.format)",
            "                if not result.tzinfo and self.default_tzinfo:",
            "                    result = result.replace(tzinfo=self.default_tzinfo)",
            "            else:",
            "                result = iso8601.parse_date(",
            "                    cstruct, default_timezone=self.default_tzinfo",
            "                )",
            "        except (ValueError, iso8601.ParseError) as e:",
            "            raise Invalid(",
            "                node, _(self.err_template, mapping={'val': cstruct, 'err': e})",
            "            )",
            "        return result",
            "",
            "",
            "class Date(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.date`` object.",
            "",
            "    This type serializes python ``datetime.date`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the date only.",
            "",
            "    The constructor accepts no arguments.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.datetime`` objects to a date-only ISO string",
            "    representation during serialization.  It does so by stripping off",
            "    any time information, converting the ``datetime.datetime`` into a",
            "    date before serializing.",
            "",
            "    Likewise, for convenience, this type is also willing to coerce ISO",
            "    representations that contain time info into a ``datetime.date``",
            "    object during deserialization.  It does so by throwing away any",
            "    time information related to the serialized value during",
            "    deserialization.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid date')",
            "",
            "    def __init__(self, format=None):",
            "        self.format = format",
            "",
            "    def serialize(self, node, appstruct):",
            "        if not appstruct:",
            "            return null",
            "",
            "        if isinstance(appstruct, datetime.datetime):",
            "            appstruct = appstruct.date()",
            "",
            "        if not isinstance(appstruct, datetime.date):",
            "            raise Invalid(",
            "                node,",
            "                _('\"${val}\" is not a date object', mapping={'val': appstruct}),",
            "            )",
            "",
            "        if self.format:",
            "            return appstruct.strftime(self.format)",
            "        return appstruct.isoformat()",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "        try:",
            "            if self.format:",
            "                result = datetime.datetime.strptime(cstruct, self.format)",
            "            else:",
            "                result = iso8601.parse_date(cstruct)",
            "            result = result.date()",
            "        except iso8601.ParseError as e:",
            "            raise Invalid(",
            "                node, _(self.err_template, mapping={'val': cstruct, 'err': e})",
            "            )",
            "        return result",
            "",
            "",
            "class Time(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.time`` object.",
            "",
            "    .. note:: This type is new as of Colander 0.9.3.",
            "",
            "    This type serializes python ``datetime.time`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the time only.",
            "",
            "    The constructor accepts no arguments.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.datetime`` objects to a time-only ISO string",
            "    representation during serialization.  It does so by stripping off",
            "    any date information, converting the ``datetime.datetime`` into a",
            "    time before serializing.",
            "",
            "    Likewise, for convenience, this type is also willing to coerce ISO",
            "    representations that contain time info into a ``datetime.time``",
            "    object during deserialization.  It does so by throwing away any",
            "    date information related to the serialized value during",
            "    deserialization.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid time')",
            "",
            "    def serialize(self, node, appstruct):",
            "        if isinstance(appstruct, datetime.datetime):",
            "            appstruct = appstruct.time()",
            "",
            "        if not isinstance(appstruct, datetime.time):",
            "            if not appstruct:",
            "                return null",
            "            raise Invalid(",
            "                node,",
            "                _('\"${val}\" is not a time object', mapping={'val': appstruct}),",
            "            )",
            "",
            "        return appstruct.isoformat()",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "        try:",
            "            result = iso8601.parse_date(cstruct)",
            "            return result.time()",
            "        except (iso8601.ParseError, TypeError) as e:",
            "            err = e",
            "        fmts = ['%H:%M:%S.%f', '%H:%M:%S', '%H:%M']",
            "        for fmt in fmts:",
            "            try:",
            "                return datetime.datetime.strptime(cstruct, fmt).time()",
            "            except (ValueError, TypeError):",
            "                continue",
            "        raise Invalid(",
            "            node, _(self.err_template, mapping={'val': cstruct, 'err': err})",
            "        )",
            "",
            "",
            "class Enum(SchemaType):",
            "    \"\"\"A type representing a Python ``enum.Enum`` object.",
            "",
            "    The constructor accepts three arguments named ``enum_cls``, ``attr``,",
            "    and ``typ``.",
            "",
            "    ``enum_cls`` is a mandatory argument and it should be a subclass of",
            "    ``enum.Enum``.  This argument represents the appstruct's type.",
            "",
            "    ``attr`` is an optional argument.  Its default is ``name``.",
            "    It is used to pick a serialized value from an enum instance.",
            "    A serialized value must be unique.",
            "",
            "    ``typ`` is an optional argument, and it should be an instance of",
            "    ``colander.SchemaType``.  This argument represents the cstruct's type.",
            "    If ``typ`` is not specified, a plain ``colander.String`` is used.",
            "    \"\"\"",
            "",
            "    def __init__(self, enum_cls, attr=None, typ=None):",
            "        self.enum_cls = enum_cls",
            "        self.attr = 'name' if attr is None else attr",
            "        self.typ = String() if typ is None else typ",
            "        if self.attr == 'name':",
            "            self.values = enum_cls.__members__.copy()",
            "        else:",
            "            self.values = {}",
            "            for e in self.enum_cls.__members__.values():",
            "                v = getattr(e, self.attr)",
            "                if v in self.values:",
            "                    raise ValueError(",
            "                        '%r is not unique in %r', v, self.enum_cls",
            "                    )",
            "                self.values[v] = e",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        if not isinstance(appstruct, self.enum_cls):",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a valid \"${cls}\"',",
            "                    mapping={'val': appstruct, 'cls': self.enum_cls.__name__},",
            "                ),",
            "            )",
            "",
            "        return self.typ.serialize(node, getattr(appstruct, self.attr))",
            "",
            "    def deserialize(self, node, cstruct):",
            "        result = self.typ.deserialize(node, cstruct)",
            "        if result is null:",
            "            return null",
            "",
            "        if result not in self.values:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a valid \"${cls}\"',",
            "                    mapping={'val': cstruct, 'cls': self.enum_cls.__name__},",
            "                ),",
            "            )",
            "        return self.values[result]",
            "",
            "",
            "def _add_node_children(node, children):",
            "    for n in children:",
            "        insert_before = getattr(n, 'insert_before', None)",
            "        exists = node.get(n.name, _marker) is not _marker",
            "        # use exists for microspeed; we could just call __setitem__",
            "        # exclusively, but it does an enumeration that's unnecessary in the",
            "        # common (nonexisting) case (.add is faster)",
            "        if insert_before is None:",
            "            if exists:",
            "                node[n.name] = n",
            "            else:",
            "                node.add(n)",
            "        else:",
            "            if exists:",
            "                del node[n.name]",
            "            node.add_before(insert_before, n)",
            "",
            "",
            "class _SchemaNode(object):",
            "    \"\"\"",
            "    Fundamental building block of schemas.",
            "",
            "    The constructor accepts these positional arguments:",
            "",
            "    - ``typ``: The 'type' for this node.  It should be an",
            "      instance of a class that implements the",
            "      :class:`colander.interfaces.Type` interface.  If ``typ`` is not passed,",
            "      a call to the ``schema_type()`` method on this class is made to",
            "      get a default type.  (When subclassing, ``schema_type()`` should",
            "      be overridden to provide a reasonable default type).",
            "",
            "    - ``*children``: a sequence of subnodes.  If the subnodes of this",
            "      node are not known at construction time, they can later be added",
            "      via the ``add`` method.",
            "",
            "    The constructor accepts these keyword arguments:",
            "",
            "    - ``name``: The name of this node.",
            "",
            "    - ``typ``: The 'type' for this node can optionally be passed in as a",
            "      keyword argument. See the documentation for the positional arg above.",
            "",
            "    - ``default``: The default serialization value for this node when",
            "      not set.  If ``default`` is :attr:`colander.drop`, the node",
            "      will be dropped from schema serialization.  If not provided,",
            "      the node will be serialized to :attr:`colander.null`.",
            "",
            "    - ``missing``: The default deserialization value for this node.  If it is",
            "      not provided, the missing value of this node will be the special marker",
            "      value :attr:`colander.required`, indicating that it is considered",
            "      'required'.  When ``missing`` is :attr:`colander.required`, the",
            "      ``required`` computed attribute will be ``True``.  When ``missing`` is",
            "      :attr:`colander.drop`, the node is dropped from the schema if it isn't",
            "      set during deserialization.",
            "",
            "    - ``missing_msg``: Optional error message to be used if the value is",
            "      required and missing.",
            "",
            "    - ``preparer``: Optional preparer for this node.  It should be",
            "      an object that implements the",
            "      :class:`colander.interfaces.Preparer` interface.",
            "",
            "    - ``validator``: Optional validator for this node.  It should be",
            "      an object that implements the",
            "      :class:`colander.interfaces.Validator` interface.",
            "",
            "    - ``after_bind``: A callback which is called after a clone of this",
            "      node has 'bound' all of its values successfully. This callback",
            "      is useful for performing arbitrary actions to the cloned node,",
            "      or direct children of the cloned node (such as removing or",
            "      adding children) at bind time.  A 'binding' is the result of an",
            "      execution of the ``bind`` method of the clone's prototype node,",
            "      or one of the parents of the clone's prototype nodes.  The",
            "      deepest nodes in the node tree are bound first, so the",
            "      ``after_bind`` methods of the deepest nodes are called before",
            "      the shallowest.  The ``after_bind`` callback should",
            "      accept two values: ``node`` and ``kw``.  ``node`` will be a",
            "      clone of the bound node object, ``kw`` will be the set of",
            "      keywords passed to the ``bind`` method.",
            "",
            "    - ``title``: The title of this node.  Defaults to a titleization",
            "      of the ``name`` (underscores replaced with empty strings and the",
            "      first letter of every resulting word capitalized).  The title is",
            "      used by higher-level systems (not by Colander itself).",
            "",
            "    - ``description``: The description for this node.  Defaults to",
            "      ``''`` (the empty string).  The description is used by",
            "      higher-level systems (not by Colander itself).",
            "",
            "    - ``widget``: The 'widget' for this node.  Defaults to ``None``.",
            "      The widget attribute is not interpreted by Colander itself, it",
            "      is only meaningful to higher-level systems such as Deform.",
            "",
            "    - ``insert_before``: if supplied, it names a sibling defined by a",
            "      superclass for its parent node; the current node will be inserted",
            "      before the named node. It is not useful unless a mapping schema is",
            "      inherited from another mapping schema, and you need to control",
            "      the ordering of the resulting nodes.",
            "",
            "    Arbitrary keyword arguments remaining will be attached to the node",
            "    object unmolested.",
            "    \"\"\"",
            "",
            "    _counter = itertools.count()",
            "    preparer = None",
            "    validator = None",
            "    default = null",
            "    missing = required",
            "    missing_msg = _('Required')",
            "    name = ''",
            "    raw_title = _marker  # only changes if title is explicitly set",
            "    title = _marker",
            "    description = ''",
            "    widget = None",
            "    after_bind = None",
            "    bindings = None",
            "",
            "    def __new__(cls, *args, **kw):",
            "        node = object.__new__(cls)",
            "        node._order = next(cls._counter)",
            "        node.children = []",
            "        _add_node_children(node, cls.__all_schema_nodes__)",
            "        return node",
            "",
            "    def __init__(self, *arg, **kw):",
            "        # bw compat forces us to treat first arg as type if not a _SchemaNode",
            "        if 'typ' in kw:",
            "            self.typ = kw.pop('typ')",
            "        elif arg and not isinstance(arg[0], _SchemaNode):",
            "            self.typ, arg = arg[0], arg[1:]",
            "        else:",
            "            self.typ = self.schema_type()",
            "        _add_node_children(self, arg)",
            "",
            "        # bw compat forces us to manufacture a title if one is not supplied",
            "        title = kw.get('title', self.title)",
            "        if title is _marker:",
            "            name = kw.get('name', self.name)",
            "            kw['title'] = name.replace('_', ' ').title()",
            "        else:",
            "            kw['raw_title'] = title",
            "",
            "        self.__dict__.update(kw)",
            "",
            "    @staticmethod",
            "    def schema_type():",
            "        raise NotImplementedError(",
            "            'Schema node construction without a `typ` argument or '",
            "            'a schema_type() callable present on the node class '",
            "        )",
            "",
            "    @property",
            "    def required(self):",
            "        \"\"\" A property which returns ``True`` if the ``missing`` value",
            "        related to this node was not specified.",
            "",
            "        A return value of ``True`` implies that a ``missing`` value wasn't",
            "        specified for this node or that the ``missing`` value of this node is",
            "        :attr:`colander.required`.  A return value of ``False`` implies that",
            "        a 'real' ``missing`` value was specified for this node.\"\"\"",
            "        if isinstance(self.missing, deferred):  # unbound schema with deferreds",
            "            return True",
            "        return self.missing is required",
            "",
            "    def serialize(self, appstruct=null):",
            "        \"\"\" Serialize the :term:`appstruct` to a :term:`cstruct` based",
            "        on the schema represented by this node and return the",
            "        cstruct.",
            "",
            "        If ``appstruct`` is :attr:`colander.null`, return the",
            "        serialized value of this node's ``default`` attribute (by",
            "        default, the serialization of :attr:`colander.null`).",
            "",
            "        If an ``appstruct`` argument is not explicitly provided, it",
            "        defaults to :attr:`colander.null`.",
            "        \"\"\"",
            "        if appstruct is null:",
            "            appstruct = self.default",
            "        if isinstance(appstruct, deferred):  # unbound schema with deferreds",
            "            appstruct = null",
            "        cstruct = self.typ.serialize(self, appstruct)",
            "        return cstruct",
            "",
            "    def flatten(self, appstruct):",
            "        \"\"\" Create and return a data structure which is a flattened",
            "        representation of the passed in struct based on the schema represented",
            "        by this node.  The return data structure is a dictionary; its keys are",
            "        dotted names.  Each dotted name represents a path to a location in the",
            "        schema.  The values of of the flattened dictionary are subvalues of",
            "        the passed in struct.\"\"\"",
            "        flat = self.typ.flatten(self, appstruct)",
            "        return flat",
            "",
            "    def unflatten(self, fstruct):",
            "        \"\"\" Create and return a data structure with nested substructures based",
            "        on the schema represented by this node using the flattened",
            "        representation passed in. This is the inverse operation to",
            "        :meth:`colander.SchemaNode.flatten`.\"\"\"",
            "        paths = sorted(fstruct.keys())",
            "        return self.typ.unflatten(self, paths, fstruct)",
            "",
            "    def set_value(self, appstruct, dotted_name, value):",
            "        \"\"\" Uses the schema to set a value in a nested datastructure from a",
            "        dotted name path. \"\"\"",
            "        self.typ.set_value(self, appstruct, dotted_name, value)",
            "",
            "    def get_value(self, appstruct, dotted_name):",
            "        \"\"\" Traverses the nested data structure using the schema and retrieves",
            "        the value specified by the dotted name path.\"\"\"",
            "        return self.typ.get_value(self, appstruct, dotted_name)",
            "",
            "    def deserialize(self, cstruct=null):",
            "        \"\"\" Deserialize the :term:`cstruct` into an :term:`appstruct` based",
            "        on the schema, run this :term:`appstruct` through the",
            "        preparer, if one is present, then validate the",
            "        prepared appstruct.  The ``cstruct`` value is deserialized into an",
            "        ``appstruct`` unconditionally.",
            "",
            "        If ``appstruct`` returned by type deserialization and",
            "        preparation is the value :attr:`colander.null`, do something",
            "        special before attempting validation:",
            "",
            "        - If the ``missing`` attribute of this node has been set explicitly,",
            "          return its value.  No validation of this value is performed; it is",
            "          simply returned.",
            "",
            "        - If the ``missing`` attribute of this node has not been set",
            "          explicitly, raise a :exc:`colander.Invalid` exception error.",
            "",
            "        If the appstruct is not ``colander.null`` and cannot be validated , a",
            "        :exc:`colander.Invalid` exception will be raised.",
            "",
            "        If a ``cstruct`` argument is not explicitly provided, it",
            "        defaults to :attr:`colander.null`.",
            "        \"\"\"",
            "        appstruct = self.typ.deserialize(self, cstruct)",
            "",
            "        if self.preparer is not None:",
            "            # if the preparer is a function, call a single preparer",
            "            if hasattr(self.preparer, '__call__'):",
            "                appstruct = self.preparer(appstruct)",
            "            # if the preparer is a list, call each separate preparer",
            "            elif is_nonstr_iter(self.preparer):",
            "                for preparer in self.preparer:",
            "                    appstruct = preparer(appstruct)",
            "",
            "        if appstruct is null:",
            "            appstruct = self.missing",
            "            if appstruct is required:",
            "                raise Invalid(",
            "                    self,",
            "                    _(",
            "                        self.missing_msg,",
            "                        mapping={'title': self.title, 'name': self.name},",
            "                    ),",
            "                )",
            "",
            "            if isinstance(appstruct, deferred):",
            "                # unbound schema with deferreds",
            "                raise Invalid(self, self.missing_msg)",
            "            # We never deserialize or validate the missing value",
            "            return appstruct",
            "",
            "        if self.validator is not None:",
            "            if isinstance(self.validator, deferred):  # unbound",
            "                raise UnboundDeferredError(",
            "                    \"Schema node {node} has an unbound \"",
            "                    \"deferred validator\".format(node=self)",
            "                )",
            "            self.validator(self, appstruct)",
            "        return appstruct",
            "",
            "    def add(self, node):",
            "        \"\"\" Append a subnode to this node. ``node`` must be a SchemaNode.\"\"\"",
            "        self.children.append(node)",
            "",
            "    def insert(self, index, node):",
            "        \"\"\" Insert a subnode into the position ``index``.  ``node`` must be",
            "        a SchemaNode.\"\"\"",
            "        self.children.insert(index, node)",
            "",
            "    def add_before(self, name, node):",
            "        \"\"\" Insert a subnode into the position before the node named ``name``",
            "        \"\"\"",
            "        for pos, sub in enumerate(self.children[:]):",
            "            if sub.name == name:",
            "                self.insert(pos, node)",
            "                return",
            "        raise KeyError('No such node named %s' % name)",
            "",
            "    def get(self, name, default=None):",
            "        \"\"\" Return the subnode associated with ``name`` or ``default`` if no",
            "        such node exists.\"\"\"",
            "        for node in self.children:",
            "            if node.name == name:",
            "                return node",
            "        return default",
            "",
            "    def clone(self):",
            "        \"\"\" Clone the schema node and return the clone.  All subnodes",
            "        are also cloned recursively.  Attributes present in node",
            "        dictionaries are preserved.\"\"\"",
            "        cloned = self.__class__(self.typ)",
            "        cloned.__dict__.update(self.__dict__)",
            "        cloned.children = [node.clone() for node in self.children]",
            "        return cloned",
            "",
            "    def bind(self, **kw):",
            "        \"\"\" Resolve any deferred values attached to this schema node",
            "        and its children (recursively), using the keywords passed as",
            "        ``kw`` as input to each deferred value.  This function",
            "        *clones* the schema it is called upon and returns the cloned",
            "        value.  The original schema node (the source of the clone)",
            "        is not modified.\"\"\"",
            "        cloned = self.clone()",
            "        cloned._bind(kw)",
            "        return cloned",
            "",
            "    def _bind(self, kw):",
            "        self.bindings = kw",
            "        for child in self.children:",
            "            child._bind(kw)",
            "        names = dir(self)",
            "        for k in names:",
            "            v = getattr(self, k)",
            "            if isinstance(v, deferred):",
            "                v = v(self, kw)",
            "                if isinstance(v, SchemaNode):",
            "                    self[k] = v",
            "                else:",
            "                    setattr(self, k, v)",
            "        if getattr(self, 'after_bind', None):",
            "            self.after_bind(self, kw)",
            "",
            "    def cstruct_children(self, cstruct):",
            "        \"\"\" Will call the node's type's ``cstruct_children`` method with this",
            "        node as a first argument, and ``cstruct`` as a second argument.\"\"\"",
            "        cstruct_children = getattr(self.typ, 'cstruct_children', None)",
            "        if cstruct_children is None:",
            "            warnings.warn(",
            "                'The node type %s has no cstruct_children method. '",
            "                'This method is required to be implemented by schema types '",
            "                'for compatibility with Colander 0.9.9+. In a future Colander '",
            "                'version, the absence of this method will cause an '",
            "                'exception.  Returning [] for compatibility although it '",
            "                'may not be the right value.' % self.typ.__class__,",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            return []",
            "        return cstruct_children(self, cstruct)",
            "",
            "    def __delitem__(self, name):",
            "        \"\"\" Remove a subnode by name \"\"\"",
            "        for idx, node in enumerate(self.children[:]):",
            "            if node.name == name:",
            "                return self.children.pop(idx)",
            "        raise KeyError(name)",
            "",
            "    def __getitem__(self, name):",
            "        \"\"\" Get a subnode by name. \"\"\"",
            "        val = self.get(name, _marker)",
            "        if val is _marker:",
            "            raise KeyError(name)",
            "        return val",
            "",
            "    def __setitem__(self, name, newnode):",
            "        \"\"\" Replace a subnode by name.  ``newnode`` must be a SchemaNode.  If",
            "        a subnode named ``name`` doesn't already exist, calling this method",
            "        is the same as setting the node's name to ``name`` and calling the",
            "        ``add`` method with the node (it will be appended to the children",
            "        list).\"\"\"",
            "        newnode.name = name",
            "        for idx, node in enumerate(self.children[:]):",
            "            if node.name == name:",
            "                self.children[idx] = newnode",
            "                return node",
            "        self.add(newnode)",
            "",
            "    def __iter__(self):",
            "        \"\"\" Iterate over the children nodes of this schema node \"\"\"",
            "        return iter(self.children)",
            "",
            "    def __contains__(self, name):",
            "        \"\"\" Return True if subnode named ``name`` exists in this node \"\"\"",
            "        return self.get(name, _marker) is not _marker",
            "",
            "    def __repr__(self):",
            "        return '<%s.%s object at %d (named %s)>' % (",
            "            self.__module__,",
            "            self.__class__.__name__,",
            "            id(self),",
            "            self.name,",
            "        )",
            "",
            "    def raise_invalid(self, msg, node=None):",
            "        \"\"\" Raise a :exc:`colander.Invalid` exception with the message",
            "        ``msg``.  ``node``, if supplied, should be an instance of a",
            "        :class:`colander.SchemaNode`.  If it is not supplied, ``node`` will",
            "        be this node.  Example usage::",
            "",
            "            class CustomSchemaNode(SchemaNode):",
            "                def validator(self, node, cstruct):",
            "                    if cstruct != 'the_right_thing':",
            "                        self.raise_invalid('Not the right thing')",
            "",
            "        \"\"\"",
            "        if node is None:",
            "            node = self",
            "        raise Invalid(node, msg)",
            "",
            "",
            "class _SchemaMeta(type):",
            "    def __init__(cls, name, bases, clsattrs):",
            "        nodes = []",
            "",
            "        for name, value in clsattrs.items():",
            "            if isinstance(value, _SchemaNode):",
            "                delattr(cls, name)",
            "                if not value.name:",
            "                    value.name = name",
            "                if value.raw_title is _marker:",
            "                    value.title = name.replace('_', ' ').title()",
            "                nodes.append((value._order, value))",
            "",
            "        nodes.sort(key=lambda n: n[0])",
            "        cls.__class_schema_nodes__ = [n[1] for n in nodes]",
            "",
            "        # Combine all attrs from this class and its _SchemaNode superclasses.",
            "        cls.__all_schema_nodes__ = []",
            "        for c in reversed(cls.__mro__):",
            "            csn = getattr(c, '__class_schema_nodes__', [])",
            "            cls.__all_schema_nodes__.extend(csn)",
            "",
            "",
            "# metaclass spelling compatibility across Python 2 and Python 3",
            "SchemaNode = _SchemaMeta(",
            "    'SchemaNode', (_SchemaNode,), {'__doc__': _SchemaNode.__doc__}",
            ")",
            "",
            "",
            "class Schema(SchemaNode):",
            "    schema_type = Mapping",
            "",
            "",
            "MappingSchema = Schema",
            "",
            "",
            "class TupleSchema(SchemaNode):",
            "    schema_type = Tuple",
            "",
            "",
            "class SequenceSchema(SchemaNode):",
            "    schema_type = Sequence",
            "",
            "    def __init__(self, *args, **kw):",
            "        SchemaNode.__init__(self, *args, **kw)",
            "        if len(self.children) != 1:",
            "            raise Invalid(",
            "                self, 'Sequence schemas must have exactly one child node'",
            "            )",
            "",
            "    def clone(self):",
            "        \"\"\" Clone the schema node and return the clone.  All subnodes",
            "        are also cloned recursively.  Attributes present in node",
            "        dictionaries are preserved.\"\"\"",
            "",
            "        # Cloning a ``SequenceSchema`` doesn't work with ``_SchemaNode.clone``.",
            "",
            "        children = [node.clone() for node in self.children]",
            "        cloned = self.__class__(self.typ, *children)",
            "",
            "        attributes = self.__dict__.copy()",
            "        attributes.pop('children', None)",
            "        cloned.__dict__.update(attributes)",
            "        return cloned",
            "",
            "",
            "class deferred(object):",
            "    \"\"\" A decorator which can be used to define deferred schema values",
            "    (missing values, widgets, validators, etc.)\"\"\"",
            "",
            "    def __init__(self, wrapped):",
            "        try:",
            "            functools.update_wrapper(self, wrapped)",
            "        except AttributeError:",
            "            # non-function (raises in Python 2)",
            "            self.__doc__ = getattr(wrapped, '__doc__', None)",
            "        self.wrapped = wrapped",
            "",
            "    def __call__(self, node, kw):",
            "        return self.wrapped(node, kw)",
            "",
            "",
            "def _unflatten_mapping(",
            "    node, paths, fstruct, get_child=None, rewrite_subpath=None",
            "):",
            "    if get_child is None:",
            "        get_child = node.__getitem__",
            "    if rewrite_subpath is None:",
            "",
            "        def rewrite_subpath(subpath):",
            "            return subpath",
            "",
            "    node_name = node.name",
            "    if node_name:",
            "        prefix = node_name + '.'",
            "    else:",
            "        prefix = ''",
            "    prefix_len = len(prefix)",
            "    appstruct = {}",
            "    subfstruct = {}",
            "    subpaths = []",
            "    curname = None",
            "    for path in paths:",
            "        if path == node_name:",
            "            # flattened structs contain non-leaf nodes which are ignored",
            "            # during unflattening.",
            "            continue",
            "        assert path.startswith(prefix), \"Bad node: %s\" % path",
            "        subpath = path[prefix_len:]",
            "        if '.' in subpath:",
            "            name = subpath[: subpath.index('.')]",
            "        else:",
            "            name = subpath",
            "        if curname is None:",
            "            curname = name",
            "        elif name != curname:",
            "            subnode = get_child(curname)",
            "            appstruct[curname] = subnode.typ.unflatten(",
            "                subnode, subpaths, subfstruct",
            "            )",
            "            subfstruct = {}",
            "            subpaths = []",
            "            curname = name",
            "        subpath = rewrite_subpath(subpath)",
            "        subfstruct[subpath] = fstruct[path]",
            "        subpaths.append(subpath)",
            "    if curname is not None:",
            "        subnode = get_child(curname)",
            "        appstruct[curname] = subnode.typ.unflatten(",
            "            subnode, subpaths, subfstruct",
            "        )",
            "    return appstruct",
            "",
            "",
            "class instantiate(object):",
            "    \"\"\"",
            "    A decorator which can be used to instantiate :class:`SchemaNode`",
            "    elements inline within a class definition.",
            "",
            "    All parameters passed to the decorator and passed along to the",
            "    :class:`SchemaNode` during instantiation.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kw):",
            "        self.args, self.kw = args, kw",
            "",
            "    def __call__(self, class_):",
            "        return class_(*self.args, **self.kw)"
        ],
        "afterPatchFile": [
            "# coding=utf-8",
            "import copy",
            "import datetime",
            "import decimal",
            "import functools",
            "import itertools",
            "import pprint",
            "import re",
            "import translationstring",
            "import warnings",
            "import types",
            "",
            "from iso8601 import iso8601",
            "",
            "from .compat import text_, text_type, string_types, xrange, is_nonstr_iter",
            "",
            "",
            "_ = translationstring.TranslationStringFactory('colander')",
            "",
            "",
            "class _required(object):",
            "    \"\"\" Represents a required value in colander-related operations. \"\"\"",
            "",
            "    def __repr__(self):",
            "        return '<colander.required>'",
            "",
            "    def __reduce__(self):",
            "        # when unpickled, refers to \"required\" below (singleton)",
            "        return 'required'",
            "",
            "",
            "required = _required()",
            "_marker = required  # bw compat",
            "",
            "",
            "class _null(object):",
            "    \"\"\" Represents a null value in colander-related operations. \"\"\"",
            "",
            "    def __nonzero__(self):",
            "        return False",
            "",
            "    # py3 compat",
            "    __bool__ = __nonzero__",
            "",
            "    def __repr__(self):",
            "        return '<colander.null>'",
            "",
            "    def __reduce__(self):",
            "        return 'null'  # when unpickled, refers to \"null\" below (singleton)",
            "",
            "",
            "null = _null()",
            "",
            "",
            "class _drop(object):",
            "    \"\"\" Represents a value that will be dropped from the schema if it",
            "    is missing during *serialization* or *deserialization*.  Passed as",
            "    a value to the `missing` or `default` keyword argument",
            "    of :class:`SchemaNode`.",
            "    \"\"\"",
            "",
            "    def __repr__(self):",
            "        return '<colander.drop>'",
            "",
            "    def __reduce__(self):",
            "        return 'drop'  # when unpickled, refers to \"drop\" below (singleton)",
            "",
            "",
            "drop = _drop()",
            "",
            "",
            "def interpolate(msgs):",
            "    for s in msgs:",
            "        if hasattr(s, 'interpolate'):",
            "            yield s.interpolate()",
            "        else:",
            "            yield s",
            "",
            "",
            "class UnboundDeferredError(Exception):",
            "    \"\"\"",
            "    An exception raised by :meth:`SchemaNode.deserialize` when an attempt",
            "    is made to deserialize a node which has an unbound :class:`deferred`",
            "    validator.",
            "    \"\"\"",
            "",
            "",
            "class Invalid(Exception):",
            "    \"\"\"",
            "    An exception raised by data types and validators indicating that",
            "    the value for a particular node was not valid.",
            "",
            "    The constructor receives a mandatory ``node`` argument.  This must",
            "    be an instance of the :class:`colander.SchemaNode` class, or at",
            "    least something with the same interface.",
            "",
            "    The constructor also receives an optional ``msg`` keyword",
            "    argument, defaulting to ``None``.  The ``msg`` argument is a",
            "    freeform field indicating the error circumstance.",
            "",
            "    The constructor additionally may receive an optional ``value``",
            "    keyword, indicating the value related to the error.",
            "    \"\"\"",
            "",
            "    pos = None",
            "    positional = False",
            "",
            "    def __init__(self, node, msg=None, value=None):",
            "        Exception.__init__(self, node, msg)",
            "        self.node = node",
            "        self.msg = msg",
            "        self.value = value",
            "        self.children = []",
            "",
            "    def messages(self):",
            "        \"\"\" Return an iterable of error messages for this exception using the",
            "        ``msg`` attribute of this error node.  If the ``msg`` attribute is",
            "        iterable, it is returned.  If it is not iterable, and is",
            "        non-``None``, a single-element list containing the ``msg`` value is",
            "        returned.  If the value is ``None``, an empty list is returned.\"\"\"",
            "        if is_nonstr_iter(self.msg):",
            "            return self.msg",
            "        if self.msg is None:",
            "            return []",
            "        return [self.msg]",
            "",
            "    def add(self, exc, pos=None):",
            "        \"\"\" Add a child exception; ``exc`` must be an instance of",
            "        :class:`colander.Invalid` or a subclass.",
            "",
            "        ``pos`` is a value important for accurate error reporting.  If",
            "        it is provided, it must be an integer representing the",
            "        position of ``exc`` relative to all other subexceptions of",
            "        this exception node.  For example, if the exception being",
            "        added is about the third child of the exception which is",
            "        ``self``, ``pos`` might be passed as ``3``.",
            "",
            "        If ``pos`` is provided, it will be assigned to the ``pos``",
            "        attribute of the provided ``exc`` object.",
            "        \"\"\"",
            "        if self.node and isinstance(self.node.typ, Positional):",
            "            exc.positional = True",
            "        if pos is not None:",
            "            exc.pos = pos",
            "        self.children.append(exc)",
            "",
            "    def __setitem__(self, name, msg):",
            "        \"\"\" Add a subexception related to a child node with the",
            "        message ``msg``. ``name`` must be present in the names of the",
            "        set of child nodes of this exception's node; if this is not",
            "        so, a :exc:`KeyError` is raised.",
            "",
            "        For example, if the exception upon which ``__setitem__`` is",
            "        called has a node attribute, and that node attribute has",
            "        children that have the names ``name`` and ``title``, you may",
            "        successfully call ``__setitem__('name', 'Bad name')`` or",
            "        ``__setitem__('title', 'Bad title')``.  But calling",
            "        ``__setitem__('wrong', 'whoops')`` will result in a",
            "        :exc:`KeyError`.",
            "",
            "        This method is typically only useful if the ``node`` attribute",
            "        of the exception upon which it is called is a schema node",
            "        representing a mapping.",
            "        \"\"\"",
            "        for num, child in enumerate(self.node.children):",
            "            if child.name == name:",
            "                exc = Invalid(child, msg)",
            "                self.add(exc, num)",
            "                return",
            "        raise KeyError(name)",
            "",
            "    def paths(self):",
            "        \"\"\" A generator which returns each path through the exception",
            "        graph.  Each path is represented as a tuple of exception",
            "        nodes.  Within each tuple, the leftmost item will represent",
            "        the root schema node, the rightmost item will represent the",
            "        leaf schema node.\"\"\"",
            "",
            "        def traverse(node, stack):",
            "            stack.append(node)",
            "",
            "            if not node.children:",
            "                yield tuple(stack)",
            "",
            "            for child in node.children:",
            "                for path in traverse(child, stack):",
            "                    yield path",
            "",
            "            stack.pop()",
            "",
            "        return traverse(self, [])",
            "",
            "    def _keyname(self):",
            "        if self.positional:",
            "            return str(self.pos)",
            "        return str(self.node.name)",
            "",
            "    def asdict(self, translate=None, separator='; '):",
            "        \"\"\" Return a dictionary containing a basic",
            "        (non-language-translated) error report for this exception.",
            "",
            "        If ``translate`` is supplied, it must be a callable taking a",
            "        translation string as its sole argument and returning a localized,",
            "        interpolated string.",
            "",
            "        If ``separator`` is supplied, error messages are joined with that.",
            "        \"\"\"",
            "        paths = self.paths()",
            "        errors = {}",
            "        for path in paths:",
            "            keyparts = []",
            "            msgs = []",
            "            for exc in path:",
            "                exc.msg and msgs.extend(exc.messages())",
            "                keyname = exc._keyname()",
            "                keyname and keyparts.append(keyname)",
            "            if translate:",
            "                msgs = [translate(msg) for msg in msgs]",
            "            msgs = interpolate(msgs)",
            "            if separator:",
            "                msgs = separator.join(msgs)",
            "            else:",
            "                msgs = list(msgs)",
            "            errors['.'.join(keyparts)] = msgs",
            "        return errors",
            "",
            "    def __str__(self):",
            "        \"\"\" Return a pretty-formatted string representation of the",
            "        result of an execution of this exception's ``asdict`` method\"\"\"",
            "        return pprint.pformat(self.asdict())",
            "",
            "",
            "class UnsupportedFields(Invalid):",
            "    \"\"\"",
            "    Exception used when schema object detect unknown fields in the",
            "    cstruct during deserialize.",
            "    \"\"\"",
            "",
            "    def __init__(self, node, fields, msg=None):",
            "        super(UnsupportedFields, self).__init__(node, msg)",
            "        self.fields = fields",
            "",
            "",
            "class All(object):",
            "    \"\"\" Composite validator which succeeds if none of its",
            "    subvalidators raises an :class:`colander.Invalid` exception\"\"\"",
            "",
            "    def __init__(self, *validators):",
            "        self.validators = validators",
            "",
            "    def __call__(self, node, value):",
            "        excs = []",
            "        for validator in self.validators:",
            "            try:",
            "                validator(node, value)",
            "            except Invalid as e:",
            "                excs.append(e)",
            "",
            "        if excs:",
            "            exc = Invalid(node, [exc.msg for exc in excs])",
            "            for e in excs:",
            "                exc.children.extend(e.children)",
            "            raise exc",
            "",
            "",
            "class Any(All):",
            "    \"\"\" Composite validator which succeeds if at least one of its",
            "    subvalidators does not raise an :class:`colander.Invalid` exception.\"\"\"",
            "",
            "    def __call__(self, node, value):",
            "        try:",
            "            return super(Any, self).__call__(node, value)",
            "        except Invalid as e:",
            "            if len(e.msg) < len(self.validators):",
            "                # At least one validator did not fail:",
            "                return",
            "            raise",
            "",
            "",
            "class Function(object):",
            "    \"\"\" Validator which accepts a function and an optional message;",
            "    the function is called with the ``value`` during validation.",
            "",
            "    If the function returns anything falsy (``None``, ``False``, the",
            "    empty string, ``0``, an object with a ``__nonzero__`` that returns",
            "    ``False``, etc) when called during validation, an",
            "    :exc:`colander.Invalid` exception is raised (validation fails);",
            "    its msg will be the value of the ``msg`` argument passed to this",
            "    class' constructor.",
            "",
            "    If the function returns a stringlike object (a ``str`` or",
            "    ``unicode`` object) that is *not* the empty string , a",
            "    :exc:`colander.Invalid` exception is raised using the stringlike",
            "    value returned from the function as the exeption message",
            "    (validation fails).",
            "",
            "    If the function returns anything *except* a stringlike object",
            "    object which is truthy (e.g. ``True``, the integer ``1``, an",
            "    object with a ``__nonzero__`` that returns ``True``, etc), an",
            "    :exc:`colander.Invalid` exception is *not* raised (validation",
            "    succeeds).",
            "",
            "    The default value for the ``msg`` when not provided via the",
            "    constructor is ``Invalid value``.",
            "",
            "    The ``message`` parameter has been deprecated, use ``msg`` instead.",
            "    \"\"\"",
            "",
            "    def __init__(self, function, msg=None, message=None):",
            "        self.function = function",
            "        if msg is not None and message is not None:",
            "            raise ValueError('Only one of msg and message can be passed')",
            "        # Handle bw compat",
            "        if msg is None and message is None:",
            "            msg = _('Invalid value')",
            "        elif message is not None:",
            "            warnings.warn(",
            "                'The \"message\" argument has been deprecated, use \"msg\" '",
            "                'instead.',",
            "                DeprecationWarning,",
            "            )",
            "            msg = message",
            "        self.msg = msg",
            "",
            "    def __call__(self, node, value):",
            "        result = self.function(value)",
            "        if not result:",
            "            raise Invalid(",
            "                node,",
            "                translationstring.TranslationString(",
            "                    self.msg, mapping={'val': value}",
            "                ),",
            "            )",
            "        if isinstance(result, string_types):",
            "            raise Invalid(",
            "                node,",
            "                translationstring.TranslationString(",
            "                    result, mapping={'val': value}",
            "                ),",
            "            )",
            "",
            "",
            "class Regex(object):",
            "    \"\"\" Regular expression validator.",
            "",
            "        Initialize it with the string regular expression ``regex`` that will",
            "        be compiled and matched against ``value`` when validator is called. It",
            "        uses Python's :py:func:`re.match`, which only matches at the beginning",
            "        of the string and not at the beginning of each line. To match the",
            "        entire string, enclose the regular expression with ``^`` and ``$``.",
            "        If ``msg`` is supplied, it will be the error message to be used;",
            "        otherwise, defaults to 'String does not match expected pattern'.",
            "",
            "        The ``regex`` expression behaviour can be modified by specifying",
            "        any ``flags`` value taken by ``re.compile``.",
            "",
            "        The ``regex`` argument may also be a pattern object (the",
            "        result of ``re.compile``) instead of a string.",
            "",
            "        When calling, if ``value`` matches the regular expression,",
            "        validation succeeds; otherwise, :exc:`colander.Invalid` is",
            "        raised with the ``msg`` error message.",
            "    \"\"\"",
            "",
            "    def __init__(self, regex, msg=None, flags=0):",
            "        if isinstance(regex, string_types):",
            "            self.match_object = re.compile(regex, flags)",
            "        else:",
            "            self.match_object = regex",
            "        if msg is None:",
            "            self.msg = _(\"String does not match expected pattern\")",
            "        else:",
            "            self.msg = msg",
            "",
            "    def __call__(self, node, value):",
            "        if self.match_object.match(value) is None:",
            "            raise Invalid(node, self.msg)",
            "",
            "",
            "# Regex for email addresses.",
            "#",
            "# Stolen from the WhatWG HTML spec:",
            "# https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)",
            "#",
            "# If it is good enough for browsers, it is good enough for us!",
            "EMAIL_RE = (",
            "    r\"^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9]\"",
            "    r\"(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9]\"",
            "    r\"(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\"",
            ")",
            "",
            "",
            "class Email(Regex):",
            "    \"\"\" Email address validator. If ``msg`` is supplied, it will be",
            "        the error message to be used when raising :exc:`colander.Invalid`;",
            "        otherwise, defaults to 'Invalid email address'.",
            "    \"\"\"",
            "",
            "    def __init__(self, msg=None):",
            "        email_regex = text_(EMAIL_RE)",
            "        if msg is None:",
            "            msg = _(\"Invalid email address\")",
            "        super(Email, self).__init__(email_regex, msg=msg)",
            "",
            "",
            "class Range(object):",
            "    \"\"\" Validator which succeeds if the value it is passed is greater",
            "    or equal to ``min`` and less than or equal to ``max``.  If ``min``",
            "    is not specified, or is specified as ``None``, no lower bound",
            "    exists.  If ``max`` is not specified, or is specified as ``None``,",
            "    no upper bound exists.",
            "",
            "    ``min_err`` is used to form the ``msg`` of the",
            "    :exc:`colander.Invalid` error when reporting a validation failure",
            "    caused by a value not meeting the minimum.  If ``min_err`` is",
            "    specified, it must be a string.  The string may contain the",
            "    replacement targets ``${min}`` and ``${val}``, representing the",
            "    minimum value and the provided value respectively.  If it is not",
            "    provided, it defaults to ``'${val} is less than minimum value",
            "    ${min}'``.",
            "",
            "    ``max_err`` is used to form the ``msg`` of the",
            "    :exc:`colander.Invalid` error when reporting a validation failure",
            "    caused by a value exceeding the maximum.  If ``max_err`` is",
            "    specified, it must be a string.  The string may contain the",
            "    replacement targets ``${max}`` and ``${val}``, representing the",
            "    maximum value and the provided value respectively.  If it is not",
            "    provided, it defaults to ``'${val} is greater than maximum value",
            "    ${max}'``.",
            "    \"\"\"",
            "",
            "    _MIN_ERR = _('${val} is less than minimum value ${min}')",
            "    _MAX_ERR = _('${val} is greater than maximum value ${max}')",
            "",
            "    def __init__(self, min=None, max=None, min_err=_MIN_ERR, max_err=_MAX_ERR):",
            "        self.min = min",
            "        self.max = max",
            "        self.min_err = min_err",
            "        self.max_err = max_err",
            "",
            "    def __call__(self, node, value):",
            "        if self.min is not None:",
            "            if value < self.min:",
            "                min_err = _(",
            "                    self.min_err, mapping={'val': value, 'min': self.min}",
            "                )",
            "                raise Invalid(node, min_err)",
            "",
            "        if self.max is not None:",
            "            if value > self.max:",
            "                max_err = _(",
            "                    self.max_err, mapping={'val': value, 'max': self.max}",
            "                )",
            "                raise Invalid(node, max_err)",
            "",
            "",
            "class Length(object):",
            "    \"\"\"Validator which succeeds if the value passed to it has a",
            "        length between a minimum and maximum, expressed in the",
            "        optional ``min`` and ``max`` arguments.",
            "        The value can be any sequence, most often a string.",
            "",
            "        If ``min`` is not specified, or is specified as ``None``,",
            "        no lower bound exists.  If ``max`` is not specified, or",
            "        is specified as ``None``, no upper bound exists.",
            "",
            "        The default error messages are \"Shorter than minimum length ${min}\"",
            "        and \"Longer than maximum length ${max}\". These can be customized:",
            "",
            "        ``min_err`` is used to form the ``msg`` of the",
            "        :exc:`colander.Invalid` error when reporting a validation failure",
            "        caused by a value not meeting the minimum length.  If ``min_err`` is",
            "        specified, it must be a string.  The string may contain the",
            "        replacement target ``${min}``.",
            "",
            "        ``max_err`` is used to form the ``msg`` of the",
            "        :exc:`colander.Invalid` error when reporting a validation failure",
            "        caused by a value exceeding the maximum length.  If ``max_err`` is",
            "        specified, it must be a string.  The string may contain the",
            "        replacement target ``${max}``.",
            "        \"\"\"",
            "",
            "    _MIN_ERR = _('Shorter than minimum length ${min}')",
            "    _MAX_ERR = _('Longer than maximum length ${max}')",
            "",
            "    def __init__(self, min=None, max=None, min_err=_MIN_ERR, max_err=_MAX_ERR):",
            "        self.min = min",
            "        self.max = max",
            "        self.min_err = min_err",
            "        self.max_err = max_err",
            "",
            "    def __call__(self, node, value):",
            "        if self.min is not None:",
            "            if len(value) < self.min:",
            "                min_err = _(self.min_err, mapping={'min': self.min})",
            "                raise Invalid(node, min_err)",
            "        if self.max is not None:",
            "            if len(value) > self.max:",
            "                max_err = _(self.max_err, mapping={'max': self.max})",
            "                raise Invalid(node, max_err)",
            "",
            "",
            "class OneOf(object):",
            "    \"\"\" Validator which succeeds if the value passed to it is one of",
            "    a fixed set of values \"\"\"",
            "",
            "    def __init__(self, choices):",
            "        self.choices = choices",
            "",
            "    def __call__(self, node, value):",
            "        if value not in self.choices:",
            "            choices = ', '.join(['%s' % x for x in self.choices])",
            "            err = _(",
            "                '\"${val}\" is not one of ${choices}',",
            "                mapping={'val': value, 'choices': choices},",
            "            )",
            "            raise Invalid(node, err)",
            "",
            "",
            "class NoneOf(object):",
            "    \"\"\" Validator which succeeds if the value passed to it is none of a",
            "    fixed set of values.",
            "",
            "    ``msg_err`` is used to form the ``msg`` of the :exc:`colander.Invalid`",
            "    error when reporting a validation failure.  If ``msg_err`` is specified,",
            "    it must be a string.  The string may contain the replacement targets",
            "    ``${choices}`` and ``${val}``, representing the set of forbidden values",
            "    and the provided value respectively.",
            "    \"\"\"",
            "",
            "    _MSG_ERR = _('\"${val}\" must not be one of ${choices}')",
            "",
            "    def __init__(self, choices, msg_err=_MSG_ERR):",
            "        self.forbidden = choices",
            "        self.msg_err = msg_err",
            "",
            "    def __call__(self, node, value):",
            "        if value not in self.forbidden:",
            "            return",
            "",
            "        choices = ', '.join(['%s' % x for x in self.forbidden])",
            "        err = _(self.msg_err, mapping={'val': value, 'choices': choices})",
            "",
            "        raise Invalid(node, err)",
            "",
            "",
            "class ContainsOnly(object):",
            "    \"\"\" Validator which succeeds if the value passed to is a sequence and each",
            "    element in the sequence is also in the sequence passed as ``choices``.",
            "    This validator is useful when attached to a schemanode with, e.g. a",
            "    :class:`colander.Set` or another sequencetype.",
            "    \"\"\"",
            "",
            "    err_template = _('One or more of the choices you made was not acceptable')",
            "",
            "    def __init__(self, choices):",
            "        self.choices = choices",
            "",
            "    def __call__(self, node, value):",
            "        if not set(value).issubset(self.choices):",
            "            err = _(",
            "                self.err_template,",
            "                mapping={'val': value, 'choices': self.choices},",
            "            )",
            "            raise Invalid(node, err)",
            "",
            "",
            "def luhnok(node, value):",
            "    \"\"\" Validator which checks to make sure that the value passes a luhn",
            "    mod-10 checksum (credit cards).  ``value`` must be a string, not an",
            "    integer.\"\"\"",
            "    try:",
            "        checksum = _luhnok(value)",
            "    except ValueError:",
            "        raise Invalid(",
            "            node,",
            "            _(",
            "                '\"${val}\" is not a valid credit card number',",
            "                mapping={'val': value},",
            "            ),",
            "        )",
            "",
            "    if (checksum % 10) != 0:",
            "        raise Invalid(",
            "            node,",
            "            _(",
            "                '\"${val}\" is not a valid credit card number',",
            "                mapping={'val': value},",
            "            ),",
            "        )",
            "",
            "",
            "def _luhnok(value):",
            "    checksum = 0",
            "    num_digits = len(value)",
            "    oddeven = num_digits & 1",
            "",
            "    for count in range(0, num_digits):",
            "        digit = int(value[count])",
            "",
            "        if not ((count & 1) ^ oddeven):",
            "            digit *= 2",
            "        if digit > 9:",
            "            digit -= 9",
            "",
            "        checksum += digit",
            "    return checksum",
            "",
            "",
            "# Gingerly lifted from Django 1.3.x:",
            "# https://github.com/django/django/blob/stable/1.3.x/django/core/validators.py#L45",
            "# <3 y'all!",
            "URL_REGEX = (",
            "    # {http,ftp}s:// (not required)",
            "    r'^((?:http|ftp)s?://)?'",
            "    # Domain",
            "    r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+'",
            "    r'(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'",
            "    # Localhost",
            "    r'localhost|'",
            "    # IPv6 address",
            "    r'\\[[a-f0-9:]+\\]|'",
            "    # IPv4 address",
            "    r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'",
            "    # Optional port",
            "    r'(?::\\d+)?'",
            "    # Path",
            "    r'(?:/?|[/?]\\S+)$'",
            ")",
            "",
            "url = Regex(URL_REGEX, msg=_('Must be a URL'), flags=re.IGNORECASE)",
            "",
            "",
            "URI_REGEX = (",
            "    # file:// (required)",
            "    r'^file://'",
            "    # Path",
            "    r'(?:/|[/?]\\S+)$'",
            ")",
            "",
            "file_uri = Regex(",
            "    URI_REGEX, msg=_('Must be a file:// URI scheme'), flags=re.IGNORECASE",
            ")",
            "",
            "UUID_REGEX = (",
            "    r'^(?:urn:uuid:)?\\{?[a-f0-9]{8}(?:-?[a-f0-9]{4}){3}-?[a-f0-9]{12}\\}?$'",
            ")",
            "uuid = Regex(UUID_REGEX, _('Invalid UUID string'), re.IGNORECASE)",
            "",
            "",
            "class SchemaType(object):",
            "    \"\"\" Base class for all schema types \"\"\"",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfname = prefix",
            "        else:",
            "            selfname = '%s%s' % (prefix, node.name)",
            "        result[selfname.rstrip('.')] = appstruct",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        name = node.name",
            "        assert paths == [name], \"paths should be [name] for leaf nodes.\"",
            "        return fstruct[name]",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        raise AssertionError(\"Can't call 'set_value' on a leaf node.\")",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        raise AssertionError(\"Can't call 'get_value' on a leaf node.\")",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        return []",
            "",
            "",
            "class Mapping(SchemaType):",
            "    \"\"\" A type which represents a mapping of names to nodes.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type imply the named keys and values in the mapping.",
            "",
            "    The constructor of this type accepts one extra optional keyword",
            "    argument that other types do not: ``unknown``.  An attribute of",
            "    the same name can be set on a type instance to control the",
            "    behavior after construction.",
            "",
            "    unknown",
            "        ``unknown`` controls the behavior of this type when an unknown",
            "        key is encountered in the cstruct passed to the",
            "        ``deserialize`` method of this instance.  All the potential",
            "        values of ``unknown`` are strings.  They are:",
            "",
            "        - ``ignore`` means that keys that are not present in the schema",
            "          associated with this type will be ignored during",
            "          deserialization.",
            "",
            "        - ``raise`` will cause a :exc:`colander.Invalid` exception to",
            "          be raised when unknown keys are present in the cstruct",
            "          during deserialization.",
            "",
            "        - ``preserve`` will preserve the 'raw' unknown keys and values",
            "          in the appstruct returned by deserialization.",
            "",
            "        Default: ``ignore``.",
            "",
            "    Special behavior is exhibited when a subvalue of a mapping is",
            "    present in the schema but is missing from the mapping passed to",
            "    either the ``serialize`` or ``deserialize`` method of this class.",
            "    In this case, the :attr:`colander.null` value will be passed to",
            "    the ``serialize`` or ``deserialize`` method of the schema node",
            "    representing the subvalue of the mapping respectively.  During",
            "    serialization, this will result in the behavior described in",
            "    :ref:`serializing_null` for the subnode.  During deserialization,",
            "    this will result in the behavior described in",
            "    :ref:`deserializing_null` for the subnode.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, a dictionary will be returned, where each of",
            "    the values in the returned dictionary is the serialized",
            "    representation of the null value for its type.",
            "    \"\"\"",
            "",
            "    def __init__(self, unknown='ignore'):",
            "        self.unknown = unknown",
            "",
            "    def _set_unknown(self, value):",
            "        if value not in ('ignore', 'raise', 'preserve'):",
            "            raise ValueError(",
            "                'unknown attribute must be one of \"ignore\", \"raise\", '",
            "                'or \"preserve\"'",
            "            )",
            "        self._unknown = value",
            "",
            "    def _get_unknown(self):",
            "        return self._unknown",
            "",
            "    unknown = property(_get_unknown, _set_unknown)",
            "",
            "    def _validate(self, node, value):",
            "        try:",
            "            if hasattr(value, 'items'):",
            "                return dict(value)",
            "            else:",
            "                raise TypeError('Does not implement dict-like functionality.')",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a mapping type: ${err}',",
            "                    mapping={'val': value, 'err': e},",
            "                ),",
            "            )",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        if cstruct is null:",
            "            value = {}",
            "        else:",
            "            value = self._validate(node, cstruct)",
            "        children = []",
            "        for subnode in node.children:",
            "            name = subnode.name",
            "            subval = value.get(name, _marker)",
            "            if subval is _marker:",
            "                subval = subnode.serialize(null)",
            "            children.append(subval)",
            "        return children",
            "",
            "    def _impl(self, node, value, callback):",
            "        value = self._validate(node, value)",
            "",
            "        error = None",
            "        result = {}",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            name = subnode.name",
            "            subval = value.pop(name, null)",
            "            if subval is drop or (subval is null and subnode.default is drop):",
            "                continue",
            "            try:",
            "                sub_result = callback(subnode, subval)",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "            else:",
            "                if sub_result is drop:",
            "                    continue",
            "                result[name] = sub_result",
            "",
            "        if self.unknown == 'raise':",
            "            if value:",
            "                raise UnsupportedFields(",
            "                    node,",
            "                    value,",
            "                    msg=_(",
            "                        'Unrecognized keys in mapping: \"${val}\"',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "",
            "        elif self.unknown == 'preserve':",
            "            result.update(copy.deepcopy(value))",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return result",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            appstruct = {}",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subcstruct):",
            "            return subnode.deserialize(subcstruct)",
            "",
            "        return self._impl(node, cstruct, callback)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            if node.name:",
            "                selfprefix = '%s%s.' % (prefix, node.name)",
            "            else:",
            "                selfprefix = prefix",
            "",
            "        for subnode in node.children:",
            "            name = subnode.name",
            "            substruct = appstruct.get(name, null)",
            "            result.update(",
            "                subnode.typ.flatten(subnode, substruct, prefix=selfprefix)",
            "            )",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        return _unflatten_mapping(node, paths, fstruct)",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "            next_node = node[next_name]",
            "            next_appstruct = appstruct[next_name]",
            "            appstruct[next_name] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            appstruct[path] = value",
            "        return appstruct",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "            next_node = node[name]",
            "            return next_node.typ.get_value(next_node, appstruct[name], rest)",
            "        return appstruct[path]",
            "",
            "",
            "class Positional(object):",
            "    \"\"\"",
            "    Marker abstract base class meaning 'this type has children which",
            "    should be addressed by position instead of name' (e.g. via seq[0],",
            "    but never seq['name']).  This is consulted by Invalid.asdict when",
            "    creating a dictionary representation of an error tree.",
            "    \"\"\"",
            "",
            "",
            "class Tuple(Positional, SchemaType):",
            "    \"\"\" A type which represents a fixed-length sequence of nodes.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type imply the positional elements of the tuple in the order",
            "    they are added.",
            "",
            "    This type is willing to serialize and deserialized iterables that,",
            "    when converted to a tuple, have the same number of elements as the",
            "    number of the associated node's subnodes.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "    \"\"\"",
            "",
            "    def _validate(self, node, value):",
            "        if not hasattr(value, '__iter__'):",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not iterable', mapping={'val': value})",
            "            )",
            "",
            "        valuelen, nodelen = len(value), len(node.children)",
            "",
            "        if valuelen != nodelen:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" has an incorrect number of elements '",
            "                    '(expected ${exp}, was ${was})',",
            "                    mapping={'val': value, 'exp': nodelen, 'was': valuelen},",
            "                ),",
            "            )",
            "",
            "        return list(value)",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        childlen = len(node.children)",
            "        if cstruct is null:",
            "            cstruct = []",
            "        structlen = len(cstruct)",
            "        if structlen < childlen:",
            "            missing_children = node.children[structlen:]",
            "            cstruct = list(cstruct)",
            "            for child in missing_children:",
            "                cstruct.append(child.serialize(null))",
            "        elif structlen > childlen:",
            "            cstruct = cstruct[:childlen]",
            "        else:",
            "            cstruct = list(cstruct)",
            "        return cstruct",
            "",
            "    def _impl(self, node, value, callback):",
            "        value = self._validate(node, value)",
            "        error = None",
            "        result = []",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            subval = value[num]",
            "            try:",
            "                result.append(callback(subnode, subval))",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return tuple(result)",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subval):",
            "            return subnode.deserialize(subval)",
            "",
            "        return self._impl(node, cstruct, callback)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            selfprefix = '%s%s.' % (prefix, node.name)",
            "",
            "        for num, subnode in enumerate(node.children):",
            "            substruct = appstruct[num]",
            "            result.update(",
            "                subnode.typ.flatten(subnode, substruct, prefix=selfprefix)",
            "            )",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        mapstruct = _unflatten_mapping(node, paths, fstruct)",
            "        appstruct = []",
            "        for subnode in node.children:",
            "            appstruct.append(mapstruct[subnode.name])",
            "        return tuple(appstruct)",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        appstruct = list(appstruct)",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "        else:",
            "            next_name, rest = path, None",
            "        for index, next_node in enumerate(node.children):",
            "            if next_node.name == next_name:",
            "                break",
            "        else:",
            "            raise KeyError(next_name)",
            "        if rest is not None:",
            "            next_appstruct = appstruct[index]",
            "            appstruct[index] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            appstruct[index] = value",
            "        return tuple(appstruct)",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "        else:",
            "            name, rest = path, None",
            "        for index, next_node in enumerate(node.children):",
            "            if next_node.name == name:",
            "                break",
            "        else:",
            "            raise KeyError(name)",
            "        if rest is not None:",
            "            return next_node.typ.get_value(next_node, appstruct[index], rest)",
            "        return appstruct[index]",
            "",
            "",
            "class Set(SchemaType):",
            "    \"\"\" A type representing a non-overlapping set of items.",
            "    Deserializes an iterable to a ``set`` object.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    .. versionadded: 1.0a1",
            "",
            "    \"\"\"",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        if not is_nonstr_iter(cstruct):",
            "            raise Invalid(",
            "                node,",
            "                _('${cstruct} is not iterable', mapping={'cstruct': cstruct}),",
            "            )",
            "",
            "        return set(cstruct)",
            "",
            "",
            "class List(SchemaType):",
            "    \"\"\" Type representing an ordered sequence of items.",
            "",
            "    Desrializes an iterable to a ``list`` object.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    .. versionadded: 1.0a6",
            "    \"\"\"",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        if not is_nonstr_iter(cstruct):",
            "            raise Invalid(",
            "                node,",
            "                _('${cstruct} is not iterable', mapping={'cstruct': cstruct}),",
            "            )",
            "",
            "        return list(cstruct)",
            "",
            "",
            "class SequenceItems(list):",
            "    \"\"\"",
            "    List marker subclass for use by Sequence.cstruct_children, which indicates",
            "    to a caller of that method that the result is from a sequence type.",
            "    Usually these values need to be treated specially, because all of the",
            "    children of a Sequence are not present in a schema.",
            "    \"\"\"",
            "",
            "",
            "class Sequence(Positional, SchemaType):",
            "    \"\"\"",
            "    A type which represents a variable-length sequence of nodes,",
            "    all of which must be of the same type.",
            "",
            "    The type of the first subnode of the",
            "    :class:`colander.SchemaNode` that wraps this type is considered the",
            "    sequence type.",
            "",
            "    The optional ``accept_scalar`` argument to this type's constructor",
            "    indicates what should happen if the value found during serialization or",
            "    deserialization does not have an ``__iter__`` method or is a",
            "    mapping type.",
            "",
            "    If ``accept_scalar`` is ``True`` and the value does not have an",
            "    ``__iter__`` method or is a mapping type, the value will be turned",
            "    into a single element list.",
            "",
            "    If ``accept_scalar`` is ``False`` and the value does not have an",
            "    ``__iter__`` method or is a mapping type, an",
            "    :exc:`colander.Invalid` error will be raised during serialization",
            "    and deserialization.",
            "",
            "    The default value of ``accept_scalar`` is ``False``.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value is returned.",
            "    \"\"\"",
            "",
            "    def __init__(self, accept_scalar=False):",
            "        self.accept_scalar = accept_scalar",
            "",
            "    def _validate(self, node, value, accept_scalar):",
            "        if (",
            "            hasattr(value, '__iter__')",
            "            and not hasattr(value, 'get')",
            "            and not isinstance(value, string_types)",
            "        ):",
            "            return list(value)",
            "        if accept_scalar:",
            "            return [value]",
            "        else:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not iterable', mapping={'val': value})",
            "            )",
            "",
            "    def cstruct_children(self, node, cstruct):",
            "        if cstruct is null:",
            "            return SequenceItems([])",
            "        return SequenceItems(cstruct)",
            "",
            "    def _impl(self, node, value, callback, accept_scalar):",
            "        if accept_scalar is None:",
            "            accept_scalar = self.accept_scalar",
            "",
            "        value = self._validate(node, value, accept_scalar)",
            "",
            "        error = None",
            "        result = []",
            "",
            "        subnode = node.children[0]",
            "        for num, subval in enumerate(value):",
            "            if subval is drop or (subval is null and subnode.default is drop):",
            "                continue",
            "            try:",
            "                sub_result = callback(subnode, subval)",
            "            except Invalid as e:",
            "                if error is None:",
            "                    error = Invalid(node)",
            "                error.add(e, num)",
            "            else:",
            "                if sub_result is drop:",
            "                    continue",
            "                result.append(sub_result)",
            "",
            "        if error is not None:",
            "            raise error",
            "",
            "        return result",
            "",
            "    def serialize(self, node, appstruct, accept_scalar=None):",
            "        \"\"\"",
            "        Along with the normal ``node`` and ``appstruct`` arguments,",
            "        this method accepts an additional optional keyword argument:",
            "        ``accept_scalar``.  This keyword argument can be used to",
            "        override the constructor value of the same name.",
            "",
            "        If ``accept_scalar`` is ``True`` and the ``appstruct`` does",
            "        not have an ``__iter__`` method or is a mapping type, the",
            "        value will be turned into a single element list.",
            "",
            "        If ``accept_scalar`` is ``False`` and the ``appstruct`` does",
            "        not have an ``__iter__`` method or is a mapping type, an",
            "        :exc:`colander.Invalid` error will be raised during",
            "        serialization and deserialization.",
            "",
            "        The default of ``accept_scalar`` is ``None``, which means",
            "        respect the default ``accept_scalar`` value attached to this",
            "        instance via its constructor.",
            "        \"\"\"",
            "        if appstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subappstruct):",
            "            return subnode.serialize(subappstruct)",
            "",
            "        return self._impl(node, appstruct, callback, accept_scalar)",
            "",
            "    def deserialize(self, node, cstruct, accept_scalar=None):",
            "        \"\"\"",
            "        Along with the normal ``node`` and ``cstruct`` arguments, this",
            "        method accepts an additional optional keyword argument:",
            "        ``accept_scalar``.  This keyword argument can be used to",
            "        override the constructor value of the same name.",
            "",
            "        If ``accept_scalar`` is ``True`` and the ``cstruct`` does not",
            "        have an ``__iter__`` method or is a mapping type, the value",
            "        will be turned into a single element list.",
            "",
            "        If ``accept_scalar`` is ``False`` and the ``cstruct`` does not have an",
            "        ``__iter__`` method or is a mapping type, an",
            "        :exc:`colander.Invalid` error will be raised during serialization",
            "        and deserialization.",
            "",
            "        The default of ``accept_scalar`` is ``None``, which means",
            "        respect the default ``accept_scalar`` value attached to this",
            "        instance via its constructor.",
            "        \"\"\"",
            "        if cstruct is null:",
            "            return null",
            "",
            "        def callback(subnode, subcstruct):",
            "            return subnode.deserialize(subcstruct)",
            "",
            "        return self._impl(node, cstruct, callback, accept_scalar)",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        result = {}",
            "        if listitem:",
            "            selfprefix = prefix",
            "        else:",
            "            selfprefix = '%s%s.' % (prefix, node.name)",
            "",
            "        childnode = node.children[0]",
            "",
            "        for num, subval in enumerate(appstruct):",
            "            subname = '%s%s' % (selfprefix, num)",
            "            subprefix = subname + '.'",
            "            result.update(",
            "                childnode.typ.flatten(",
            "                    childnode, subval, prefix=subprefix, listitem=True",
            "                )",
            "            )",
            "",
            "        return result",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        only_child = node.children[0]",
            "        child_name = only_child.name",
            "",
            "        def get_child(name):",
            "            return only_child",
            "",
            "        def rewrite_subpath(subpath):",
            "            if '.' in subpath:",
            "                suffix = subpath.split('.', 1)[1]",
            "                return '%s.%s' % (child_name, suffix)",
            "            return child_name",
            "",
            "        mapstruct = _unflatten_mapping(",
            "            node, paths, fstruct, get_child, rewrite_subpath",
            "        )",
            "        return [mapstruct[str(index)] for index in xrange(len(mapstruct))]",
            "",
            "    def set_value(self, node, appstruct, path, value):",
            "        if '.' in path:",
            "            next_name, rest = path.split('.', 1)",
            "            index = int(next_name)",
            "            next_node = node.children[0]",
            "            next_appstruct = appstruct[index]",
            "            appstruct[index] = next_node.typ.set_value(",
            "                next_node, next_appstruct, rest, value",
            "            )",
            "        else:",
            "            index = int(path)",
            "            appstruct[index] = value",
            "        return appstruct",
            "",
            "    def get_value(self, node, appstruct, path):",
            "        if '.' in path:",
            "            name, rest = path.split('.', 1)",
            "            index = int(name)",
            "            next_node = node.children[0]",
            "            return next_node.typ.get_value(next_node, appstruct[index], rest)",
            "        return appstruct[int(path)]",
            "",
            "",
            "Seq = Sequence",
            "",
            "",
            "class String(SchemaType):",
            "    \"\"\" A type representing a Unicode string.",
            "",
            "    This type constructor accepts two arguments:",
            "",
            "    ``encoding``",
            "       Represents the encoding which should be applied to value",
            "       serialization and deserialization, for example ``utf-8``.  If",
            "       ``encoding`` is passed as ``None``, the ``serialize`` method of",
            "       this type will not do any special encoding of the appstruct it is",
            "       provided, nor will the ``deserialize`` method of this type do",
            "       any special decoding of the cstruct it is provided; inputs and",
            "       outputs will be assumed to be Unicode.  ``encoding`` defaults",
            "       to ``None``.",
            "",
            "       If ``encoding`` is ``None``:",
            "",
            "       - A Unicode input value to ``serialize`` is returned untouched.",
            "",
            "       - A non-Unicode input value to ``serialize`` is run through the",
            "         ``unicode()`` function without an ``encoding`` parameter",
            "         (``unicode(value)``) and the result is returned.",
            "",
            "       - A Unicode input value to ``deserialize`` is returned untouched.",
            "",
            "       - A non-Unicode input value to ``deserialize`` is run through the",
            "         ``unicode()`` function without an ``encoding`` parameter",
            "         (``unicode(value)``) and the result is returned.",
            "",
            "       If ``encoding`` is not ``None``:",
            "",
            "       - A Unicode input value to ``serialize`` is run through the",
            "         ``unicode`` function with the encoding parameter",
            "         (``unicode(value, encoding)``) and the result (a ``str``",
            "         object) is returned.",
            "",
            "       - A non-Unicode input value to ``serialize`` is converted to a",
            "         Unicode using the encoding (``unicode(value, encoding)``);",
            "         subsequently the Unicode object is re-encoded to a ``str``",
            "         object using the encoding and returned.",
            "",
            "       - A Unicode input value to ``deserialize`` is returned",
            "         untouched.",
            "",
            "       - A non-Unicode input value to ``deserialize`` is converted to",
            "         a ``str`` object using ``str(value``).  The resulting str",
            "         value is converted to Unicode using the encoding",
            "         (``unicode(value, encoding)``) and the result is returned.",
            "",
            "       A corollary: If a string (as opposed to a unicode object) is",
            "       provided as a value to either the serialize or deserialize",
            "       method of this type, and the type also has an non-None",
            "       ``encoding``, the string must be encoded with the type's",
            "       encoding.  If this is not true, an :exc:`colander.Invalid`",
            "       error will result.",
            "",
            "    ``allow_empty``",
            "       Boolean, if True allows deserialization of an empty string. If",
            "       False (default), empty strings will deserialize to",
            "       :attr:`colander.null`",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, encoding=None, allow_empty=False):",
            "        self.encoding = encoding",
            "        self.allow_empty = allow_empty",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        try:",
            "            if isinstance(appstruct, (text_type, bytes)):",
            "                encoding = self.encoding",
            "                if encoding:",
            "                    result = text_(appstruct, encoding).encode(encoding)",
            "                else:",
            "                    result = text_type(appstruct)",
            "            else:",
            "                result = text_type(appstruct)",
            "                if self.encoding:",
            "                    result = result.encode(self.encoding)",
            "            return result",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '${val} cannot be serialized: ${err}',",
            "                    mapping={'val': appstruct, 'err': e},",
            "                ),",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct == '' and self.allow_empty:",
            "            return text_type('')",
            "",
            "        if not cstruct:",
            "            return null",
            "",
            "        try:",
            "            result = cstruct",
            "            if isinstance(result, (text_type, bytes)):",
            "                if self.encoding:",
            "                    result = text_(cstruct, self.encoding)",
            "                else:",
            "                    result = text_type(cstruct)",
            "            else:",
            "                raise Invalid(node)",
            "        except Exception as e:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '${val} is not a string: ${err}',",
            "                    mapping={'val': cstruct, 'err': e},",
            "                ),",
            "            )",
            "",
            "        return result",
            "",
            "",
            "Str = String",
            "",
            "",
            "class Number(SchemaType):",
            "    \"\"\" Abstract base class for float, int, decimal \"\"\"",
            "",
            "    num = None",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct in (null, None):",
            "            return null",
            "",
            "        try:",
            "            return str(self.num(appstruct))",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a number', mapping={'val': appstruct})",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct != 0 and not cstruct:",
            "            return null",
            "",
            "        try:",
            "            return self.num(cstruct)",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a number', mapping={'val': cstruct})",
            "            )",
            "",
            "",
            "class Integer(Number):",
            "    \"\"\" A type representing an integer.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    num = int",
            "",
            "",
            "Int = Integer",
            "",
            "",
            "class Float(Number):",
            "    \"\"\" A type representing a float.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    num = float",
            "",
            "",
            "class Decimal(Number):",
            "    \"\"\"",
            "    A type representing a decimal floating point.  Deserialization returns an",
            "    instance of the Python ``decimal.Decimal`` type.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The Decimal constructor takes three optional arguments, ``quant``,",
            "    ``rounding`` and ``normalize``.  If supplied, ``quant`` should be a string,",
            "    (e.g. ``1.00``).  If supplied, ``rounding`` should be one of the Python",
            "    ``decimal`` module rounding options (e.g. ``decimal.ROUND_UP``,",
            "    ``decimal.ROUND_DOWN``, etc).  The serialized and deserialized result",
            "    will be quantized and rounded via",
            "    ``result.quantize(decimal.Decimal(quant), rounding)``.  ``rounding`` is",
            "    ignored if ``quant`` is not supplied.  If ``normalize`` is ``True``,",
            "    the serialized and deserialized result will be normalized by stripping",
            "    the rightmost trailing zeros.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, quant=None, rounding=None, normalize=False):",
            "        if quant is None:",
            "            self.quant = None",
            "        else:",
            "            self.quant = decimal.Decimal(quant)",
            "        self.rounding = rounding",
            "        self.normalize = normalize",
            "",
            "    def num(self, val):",
            "        result = decimal.Decimal(str(val))",
            "        if self.quant is not None:",
            "            if self.rounding is None:",
            "                result = result.quantize(self.quant)",
            "            else:",
            "                result = result.quantize(self.quant, self.rounding)",
            "        if self.normalize:",
            "            result = result.normalize()",
            "        return result",
            "",
            "",
            "class Money(Decimal):",
            "    \"\"\" A type representing a money value with two digit precision.",
            "    Deserialization returns an instance of the Python ``decimal.Decimal``",
            "    type (quantized to two decimal places, rounded up).",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        super(Money, self).__init__(decimal.Decimal('.01'), decimal.ROUND_UP)",
            "",
            "",
            "class Boolean(SchemaType):",
            "    \"\"\" A type representing a boolean object.",
            "",
            "    The constructor accepts these keyword arguments:",
            "",
            "    - ``false_choices``: The set of strings representing a ``False``",
            "      value on deserialization.",
            "",
            "    - ``true_choices``:  The set of strings representing a ``True``",
            "      value on deserialization.",
            "",
            "    - ``false_val``: The value returned on serialization of a False",
            "      value.",
            "",
            "    - ``true_val``: The value returned on serialization of a True",
            "      value.",
            "",
            "    During deserialization, a value contained in :attr:`false_choices`,",
            "    will be considered ``False``.",
            "",
            "    The behaviour for values not contained in :attr:`false_choices`",
            "    depends on :attr:`true_choices`: if it's empty, any value is considered",
            "    ``True``; otherwise, only values contained in :attr:`true_choices`",
            "    are considered ``True``, and an Invalid exception would be raised",
            "    for values outside of both :attr:`false_choices` and :attr:`true_choices`.",
            "",
            "    Serialization will produce :attr:`true_val` or :attr:`false_val`",
            "    based on the value.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        false_choices=('false', '0'),",
            "        true_choices=(),",
            "        false_val='false',",
            "        true_val='true',",
            "    ):",
            "",
            "        self.false_choices = false_choices",
            "        self.true_choices = true_choices",
            "        self.false_val = false_val",
            "        self.true_val = true_val",
            "",
            "        self.true_reprs = ', '.join([repr(c) for c in self.true_choices])",
            "        self.false_reprs = ', '.join([repr(c) for c in self.false_choices])",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        return appstruct and self.true_val or self.false_val",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if cstruct is null:",
            "            return null",
            "",
            "        try:",
            "            result = str(cstruct)",
            "        except Exception:",
            "            raise Invalid(",
            "                node, _('${val} is not a string', mapping={'val': cstruct})",
            "            )",
            "        result = result.lower()",
            "",
            "        if result in self.false_choices:",
            "            return False",
            "        elif self.true_choices:",
            "            if result in self.true_choices:",
            "                return True",
            "            else:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        '\"${val}\" is neither in (${false_choices}) '",
            "                        'nor in (${true_choices})',",
            "                        mapping={",
            "                            'val': cstruct,",
            "                            'false_choices': self.false_reprs,",
            "                            'true_choices': self.true_reprs,",
            "                        },",
            "                    ),",
            "                )",
            "",
            "        return True",
            "",
            "",
            "Bool = Boolean",
            "",
            "",
            "class GlobalObject(SchemaType):",
            "    \"\"\" A type representing an importable Python object.  This type",
            "    serializes 'global' Python objects (objects which can be imported)",
            "    to dotted Python names.",
            "",
            "    Two dotted name styles are supported during deserialization:",
            "",
            "    - ``pkg_resources``-style dotted names where non-module attributes",
            "      of a module are separated from the rest of the path using a ':'",
            "      e.g. ``package.module:attr``.",
            "",
            "    - ``zope.dottedname``-style dotted names where non-module",
            "      attributes of a module are separated from the rest of the path",
            "      using a '.' e.g. ``package.module.attr``.",
            "",
            "    These styles can be used interchangeably.  If the serialization",
            "    contains a ``:`` (colon), the ``pkg_resources`` resolution",
            "    mechanism will be chosen, otherwise the ``zope.dottedname``",
            "    resolution mechanism will be chosen.",
            "",
            "    The constructor accepts a single argument named ``package`` which",
            "    should be a Python module or package object; it is used when",
            "    *relative* dotted names are supplied to the ``deserialize``",
            "    method.  A serialization which has a ``.`` (dot) or ``:`` (colon)",
            "    as its first character is treated as relative.  E.g. if",
            "    ``.minidom`` is supplied to ``deserialize``, and the ``package``",
            "    argument to this type was passed the ``xml`` module object, the",
            "    resulting import would be for ``xml.minidom``.  If a relative",
            "    package name is supplied to ``deserialize``, and no ``package``",
            "    was supplied to the constructor, an :exc:`colander.Invalid` error",
            "    will be raised.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    def __init__(self, package):",
            "        self.package = package",
            "",
            "    def _pkg_resources_style(self, node, value):",
            "        \"\"\" package.module:attr style \"\"\"",
            "        import pkg_resources",
            "",
            "        if value.startswith('.') or value.startswith(':'):",
            "            if not self.package:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        'relative name \"${val}\" irresolveable without package',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "            if value in ['.', ':']:",
            "                value = self.package.__name__",
            "            else:",
            "                value = self.package.__name__ + value",
            "        return pkg_resources.EntryPoint.parse('x=%s' % value).load(False)",
            "",
            "    def _zope_dottedname_style(self, node, value):",
            "        \"\"\" package.module.attr style \"\"\"",
            "        module = self.package and self.package.__name__ or None",
            "        if value == '.':",
            "            if self.package is None:",
            "                raise Invalid(",
            "                    node,",
            "                    _(",
            "                        'relative name \"${val}\" irresolveable without package',",
            "                        mapping={'val': value},",
            "                    ),",
            "                )",
            "            name = module.split('.')",
            "        else:",
            "            name = value.split('.')",
            "            if not name[0]:",
            "                if module is None:",
            "                    raise Invalid(",
            "                        node,",
            "                        _(",
            "                            'relative name \"${val}\" irresolveable without '",
            "                            'package',",
            "                            mapping={'val': value},",
            "                        ),",
            "                    )",
            "                module = module.split('.')",
            "                name.pop(0)",
            "                while not name[0]:",
            "                    module.pop()",
            "                    name.pop(0)",
            "                name = module + name",
            "",
            "        used = name.pop(0)",
            "        found = __import__(used)",
            "        for n in name:",
            "            used += '.' + n",
            "            try:",
            "                found = getattr(found, n)",
            "            except AttributeError:  # pragma: no cover",
            "                __import__(used)",
            "                found = getattr(found, n)",
            "",
            "        return found",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        try:",
            "            if isinstance(appstruct, types.ModuleType):",
            "                return appstruct.__name__",
            "            else:",
            "                return '{0.__module__}.{0.__name__}'.format(appstruct)",
            "",
            "        except AttributeError:",
            "            raise Invalid(",
            "                node, _('\"${val}\" has no __name__', mapping={'val': appstruct})",
            "            )",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "",
            "        if not isinstance(cstruct, string_types):",
            "            raise Invalid(",
            "                node, _('\"${val}\" is not a string', mapping={'val': cstruct})",
            "            )",
            "        try:",
            "            if ':' in cstruct:",
            "                return self._pkg_resources_style(node, cstruct)",
            "            else:",
            "                return self._zope_dottedname_style(node, cstruct)",
            "        except ImportError:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    'The dotted name \"${name}\" cannot be imported',",
            "                    mapping={'name': cstruct},",
            "                ),",
            "            )",
            "",
            "",
            "class DateTime(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.datetime`` object.",
            "",
            "    This type serializes python ``datetime.datetime`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the date, the time, and the timezone of the",
            "    datetime.",
            "",
            "    The constructor accepts an argument named ``default_tzinfo`` which",
            "    should be a Python ``tzinfo`` object. If ``default_tzinfo`` is not",
            "    specified the default tzinfo will be equivalent to UTC (Zulu time).",
            "    The ``default_tzinfo`` tzinfo object is used to convert 'naive'",
            "    datetimes to a timezone-aware representation during serialization.",
            "    If ``default_tzinfo`` is explicitly set to ``None`` then no default",
            "    tzinfo will be applied to naive datetimes.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.date`` objects to a DateTime ISO string representation",
            "    during serialization.  It does so by using midnight of the day as",
            "    the time, and uses the ``default_tzinfo`` to give the",
            "    serialization a timezone.",
            "",
            "    Likewise, for convenience, during deserialization, this type will",
            "    convert ``YYYY-MM-DD`` ISO8601 values to a datetime object.  It",
            "    does so by using midnight of the day as the time, and uses the",
            "    ``default_tzinfo`` to give the serialization a timezone.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid date')",
            "",
            "    def __init__(self, default_tzinfo=iso8601.UTC, format=None):",
            "        self.default_tzinfo = default_tzinfo",
            "        self.format = format",
            "",
            "    def serialize(self, node, appstruct):",
            "        if not appstruct:",
            "            return null",
            "",
            "        # cant use isinstance; dt subs date",
            "        if type(appstruct) is datetime.date:",
            "            appstruct = datetime.datetime.combine(appstruct, datetime.time())",
            "",
            "        if not isinstance(appstruct, datetime.datetime):",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a datetime object',",
            "                    mapping={'val': appstruct},",
            "                ),",
            "            )",
            "",
            "        if appstruct.tzinfo is None:",
            "            appstruct = appstruct.replace(tzinfo=self.default_tzinfo)",
            "        if not self.format:",
            "            return appstruct.isoformat()",
            "        else:",
            "            return appstruct.strftime(self.format)",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "",
            "        try:",
            "            if self.format:",
            "                result = datetime.datetime.strptime(cstruct, self.format)",
            "                if not result.tzinfo and self.default_tzinfo:",
            "                    result = result.replace(tzinfo=self.default_tzinfo)",
            "            else:",
            "                result = iso8601.parse_date(",
            "                    cstruct, default_timezone=self.default_tzinfo",
            "                )",
            "        except (ValueError, iso8601.ParseError) as e:",
            "            raise Invalid(",
            "                node, _(self.err_template, mapping={'val': cstruct, 'err': e})",
            "            )",
            "        return result",
            "",
            "",
            "class Date(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.date`` object.",
            "",
            "    This type serializes python ``datetime.date`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the date only.",
            "",
            "    The constructor accepts no arguments.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.datetime`` objects to a date-only ISO string",
            "    representation during serialization.  It does so by stripping off",
            "    any time information, converting the ``datetime.datetime`` into a",
            "    date before serializing.",
            "",
            "    Likewise, for convenience, this type is also willing to coerce ISO",
            "    representations that contain time info into a ``datetime.date``",
            "    object during deserialization.  It does so by throwing away any",
            "    time information related to the serialized value during",
            "    deserialization.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid date')",
            "",
            "    def __init__(self, format=None):",
            "        self.format = format",
            "",
            "    def serialize(self, node, appstruct):",
            "        if not appstruct:",
            "            return null",
            "",
            "        if isinstance(appstruct, datetime.datetime):",
            "            appstruct = appstruct.date()",
            "",
            "        if not isinstance(appstruct, datetime.date):",
            "            raise Invalid(",
            "                node,",
            "                _('\"${val}\" is not a date object', mapping={'val': appstruct}),",
            "            )",
            "",
            "        if self.format:",
            "            return appstruct.strftime(self.format)",
            "        return appstruct.isoformat()",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "        try:",
            "            if self.format:",
            "                result = datetime.datetime.strptime(cstruct, self.format)",
            "            else:",
            "                result = iso8601.parse_date(cstruct)",
            "            result = result.date()",
            "        except iso8601.ParseError as e:",
            "            raise Invalid(",
            "                node, _(self.err_template, mapping={'val': cstruct, 'err': e})",
            "            )",
            "        return result",
            "",
            "",
            "class Time(SchemaType):",
            "    \"\"\" A type representing a Python ``datetime.time`` object.",
            "",
            "    .. note:: This type is new as of Colander 0.9.3.",
            "",
            "    This type serializes python ``datetime.time`` objects to a",
            "    `ISO8601 <https://en.wikipedia.org/wiki/ISO_8601>`_ string format.",
            "    The format includes the time only.",
            "",
            "    The constructor accepts no arguments.",
            "",
            "    You can adjust the error message reported by this class by",
            "    changing its ``err_template`` attribute in a subclass on an",
            "    instance of this class.  By default, the ``err_template``",
            "    attribute is the string ``Invalid date``.  This string is used as",
            "    the interpolation subject of a dictionary composed of ``val`` and",
            "    ``err``.  ``val`` and ``err`` are the unvalidatable value and the",
            "    exception caused trying to convert the value, respectively. These",
            "    may be used in an overridden err_template as ``${val}`` and",
            "    ``${err}`` respectively as necessary, e.g. ``_('${val} cannot be",
            "    parsed as an iso8601 date: ${err}')``.",
            "",
            "    For convenience, this type is also willing to coerce",
            "    ``datetime.datetime`` objects to a time-only ISO string",
            "    representation during serialization.  It does so by stripping off",
            "    any date information, converting the ``datetime.datetime`` into a",
            "    time before serializing.",
            "",
            "    Likewise, for convenience, this type is also willing to coerce ISO",
            "    representations that contain time info into a ``datetime.time``",
            "    object during deserialization.  It does so by throwing away any",
            "    date information related to the serialized value during",
            "    deserialization.",
            "",
            "    If the :attr:`colander.null` value is passed to the serialize",
            "    method of this class, the :attr:`colander.null` value will be",
            "    returned.",
            "",
            "    The subnodes of the :class:`colander.SchemaNode` that wraps",
            "    this type are ignored.",
            "    \"\"\"",
            "",
            "    err_template = _('Invalid time')",
            "",
            "    def serialize(self, node, appstruct):",
            "        if isinstance(appstruct, datetime.datetime):",
            "            appstruct = appstruct.time()",
            "",
            "        if not isinstance(appstruct, datetime.time):",
            "            if not appstruct:",
            "                return null",
            "            raise Invalid(",
            "                node,",
            "                _('\"${val}\" is not a time object', mapping={'val': appstruct}),",
            "            )",
            "",
            "        return appstruct.isoformat()",
            "",
            "    def deserialize(self, node, cstruct):",
            "        if not cstruct:",
            "            return null",
            "        try:",
            "            result = iso8601.parse_date(cstruct)",
            "            return result.time()",
            "        except (iso8601.ParseError, TypeError) as e:",
            "            err = e",
            "        fmts = ['%H:%M:%S.%f', '%H:%M:%S', '%H:%M']",
            "        for fmt in fmts:",
            "            try:",
            "                return datetime.datetime.strptime(cstruct, fmt).time()",
            "            except (ValueError, TypeError):",
            "                continue",
            "        raise Invalid(",
            "            node, _(self.err_template, mapping={'val': cstruct, 'err': err})",
            "        )",
            "",
            "",
            "class Enum(SchemaType):",
            "    \"\"\"A type representing a Python ``enum.Enum`` object.",
            "",
            "    The constructor accepts three arguments named ``enum_cls``, ``attr``,",
            "    and ``typ``.",
            "",
            "    ``enum_cls`` is a mandatory argument and it should be a subclass of",
            "    ``enum.Enum``.  This argument represents the appstruct's type.",
            "",
            "    ``attr`` is an optional argument.  Its default is ``name``.",
            "    It is used to pick a serialized value from an enum instance.",
            "    A serialized value must be unique.",
            "",
            "    ``typ`` is an optional argument, and it should be an instance of",
            "    ``colander.SchemaType``.  This argument represents the cstruct's type.",
            "    If ``typ`` is not specified, a plain ``colander.String`` is used.",
            "    \"\"\"",
            "",
            "    def __init__(self, enum_cls, attr=None, typ=None):",
            "        self.enum_cls = enum_cls",
            "        self.attr = 'name' if attr is None else attr",
            "        self.typ = String() if typ is None else typ",
            "        if self.attr == 'name':",
            "            self.values = enum_cls.__members__.copy()",
            "        else:",
            "            self.values = {}",
            "            for e in self.enum_cls.__members__.values():",
            "                v = getattr(e, self.attr)",
            "                if v in self.values:",
            "                    raise ValueError(",
            "                        '%r is not unique in %r', v, self.enum_cls",
            "                    )",
            "                self.values[v] = e",
            "",
            "    def serialize(self, node, appstruct):",
            "        if appstruct is null:",
            "            return null",
            "",
            "        if not isinstance(appstruct, self.enum_cls):",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a valid \"${cls}\"',",
            "                    mapping={'val': appstruct, 'cls': self.enum_cls.__name__},",
            "                ),",
            "            )",
            "",
            "        return self.typ.serialize(node, getattr(appstruct, self.attr))",
            "",
            "    def deserialize(self, node, cstruct):",
            "        result = self.typ.deserialize(node, cstruct)",
            "        if result is null:",
            "            return null",
            "",
            "        if result not in self.values:",
            "            raise Invalid(",
            "                node,",
            "                _(",
            "                    '\"${val}\" is not a valid \"${cls}\"',",
            "                    mapping={'val': cstruct, 'cls': self.enum_cls.__name__},",
            "                ),",
            "            )",
            "        return self.values[result]",
            "",
            "",
            "def _add_node_children(node, children):",
            "    for n in children:",
            "        insert_before = getattr(n, 'insert_before', None)",
            "        exists = node.get(n.name, _marker) is not _marker",
            "        # use exists for microspeed; we could just call __setitem__",
            "        # exclusively, but it does an enumeration that's unnecessary in the",
            "        # common (nonexisting) case (.add is faster)",
            "        if insert_before is None:",
            "            if exists:",
            "                node[n.name] = n",
            "            else:",
            "                node.add(n)",
            "        else:",
            "            if exists:",
            "                del node[n.name]",
            "            node.add_before(insert_before, n)",
            "",
            "",
            "class _SchemaNode(object):",
            "    \"\"\"",
            "    Fundamental building block of schemas.",
            "",
            "    The constructor accepts these positional arguments:",
            "",
            "    - ``typ``: The 'type' for this node.  It should be an",
            "      instance of a class that implements the",
            "      :class:`colander.interfaces.Type` interface.  If ``typ`` is not passed,",
            "      a call to the ``schema_type()`` method on this class is made to",
            "      get a default type.  (When subclassing, ``schema_type()`` should",
            "      be overridden to provide a reasonable default type).",
            "",
            "    - ``*children``: a sequence of subnodes.  If the subnodes of this",
            "      node are not known at construction time, they can later be added",
            "      via the ``add`` method.",
            "",
            "    The constructor accepts these keyword arguments:",
            "",
            "    - ``name``: The name of this node.",
            "",
            "    - ``typ``: The 'type' for this node can optionally be passed in as a",
            "      keyword argument. See the documentation for the positional arg above.",
            "",
            "    - ``default``: The default serialization value for this node when",
            "      not set.  If ``default`` is :attr:`colander.drop`, the node",
            "      will be dropped from schema serialization.  If not provided,",
            "      the node will be serialized to :attr:`colander.null`.",
            "",
            "    - ``missing``: The default deserialization value for this node.  If it is",
            "      not provided, the missing value of this node will be the special marker",
            "      value :attr:`colander.required`, indicating that it is considered",
            "      'required'.  When ``missing`` is :attr:`colander.required`, the",
            "      ``required`` computed attribute will be ``True``.  When ``missing`` is",
            "      :attr:`colander.drop`, the node is dropped from the schema if it isn't",
            "      set during deserialization.",
            "",
            "    - ``missing_msg``: Optional error message to be used if the value is",
            "      required and missing.",
            "",
            "    - ``preparer``: Optional preparer for this node.  It should be",
            "      an object that implements the",
            "      :class:`colander.interfaces.Preparer` interface.",
            "",
            "    - ``validator``: Optional validator for this node.  It should be",
            "      an object that implements the",
            "      :class:`colander.interfaces.Validator` interface.",
            "",
            "    - ``after_bind``: A callback which is called after a clone of this",
            "      node has 'bound' all of its values successfully. This callback",
            "      is useful for performing arbitrary actions to the cloned node,",
            "      or direct children of the cloned node (such as removing or",
            "      adding children) at bind time.  A 'binding' is the result of an",
            "      execution of the ``bind`` method of the clone's prototype node,",
            "      or one of the parents of the clone's prototype nodes.  The",
            "      deepest nodes in the node tree are bound first, so the",
            "      ``after_bind`` methods of the deepest nodes are called before",
            "      the shallowest.  The ``after_bind`` callback should",
            "      accept two values: ``node`` and ``kw``.  ``node`` will be a",
            "      clone of the bound node object, ``kw`` will be the set of",
            "      keywords passed to the ``bind`` method.",
            "",
            "    - ``title``: The title of this node.  Defaults to a titleization",
            "      of the ``name`` (underscores replaced with empty strings and the",
            "      first letter of every resulting word capitalized).  The title is",
            "      used by higher-level systems (not by Colander itself).",
            "",
            "    - ``description``: The description for this node.  Defaults to",
            "      ``''`` (the empty string).  The description is used by",
            "      higher-level systems (not by Colander itself).",
            "",
            "    - ``widget``: The 'widget' for this node.  Defaults to ``None``.",
            "      The widget attribute is not interpreted by Colander itself, it",
            "      is only meaningful to higher-level systems such as Deform.",
            "",
            "    - ``insert_before``: if supplied, it names a sibling defined by a",
            "      superclass for its parent node; the current node will be inserted",
            "      before the named node. It is not useful unless a mapping schema is",
            "      inherited from another mapping schema, and you need to control",
            "      the ordering of the resulting nodes.",
            "",
            "    Arbitrary keyword arguments remaining will be attached to the node",
            "    object unmolested.",
            "    \"\"\"",
            "",
            "    _counter = itertools.count()",
            "    preparer = None",
            "    validator = None",
            "    default = null",
            "    missing = required",
            "    missing_msg = _('Required')",
            "    name = ''",
            "    raw_title = _marker  # only changes if title is explicitly set",
            "    title = _marker",
            "    description = ''",
            "    widget = None",
            "    after_bind = None",
            "    bindings = None",
            "",
            "    def __new__(cls, *args, **kw):",
            "        node = object.__new__(cls)",
            "        node._order = next(cls._counter)",
            "        node.children = []",
            "        _add_node_children(node, cls.__all_schema_nodes__)",
            "        return node",
            "",
            "    def __init__(self, *arg, **kw):",
            "        # bw compat forces us to treat first arg as type if not a _SchemaNode",
            "        if 'typ' in kw:",
            "            self.typ = kw.pop('typ')",
            "        elif arg and not isinstance(arg[0], _SchemaNode):",
            "            self.typ, arg = arg[0], arg[1:]",
            "        else:",
            "            self.typ = self.schema_type()",
            "        _add_node_children(self, arg)",
            "",
            "        # bw compat forces us to manufacture a title if one is not supplied",
            "        title = kw.get('title', self.title)",
            "        if title is _marker:",
            "            name = kw.get('name', self.name)",
            "            kw['title'] = name.replace('_', ' ').title()",
            "        else:",
            "            kw['raw_title'] = title",
            "",
            "        self.__dict__.update(kw)",
            "",
            "    @staticmethod",
            "    def schema_type():",
            "        raise NotImplementedError(",
            "            'Schema node construction without a `typ` argument or '",
            "            'a schema_type() callable present on the node class '",
            "        )",
            "",
            "    @property",
            "    def required(self):",
            "        \"\"\" A property which returns ``True`` if the ``missing`` value",
            "        related to this node was not specified.",
            "",
            "        A return value of ``True`` implies that a ``missing`` value wasn't",
            "        specified for this node or that the ``missing`` value of this node is",
            "        :attr:`colander.required`.  A return value of ``False`` implies that",
            "        a 'real' ``missing`` value was specified for this node.\"\"\"",
            "        if isinstance(self.missing, deferred):  # unbound schema with deferreds",
            "            return True",
            "        return self.missing is required",
            "",
            "    def serialize(self, appstruct=null):",
            "        \"\"\" Serialize the :term:`appstruct` to a :term:`cstruct` based",
            "        on the schema represented by this node and return the",
            "        cstruct.",
            "",
            "        If ``appstruct`` is :attr:`colander.null`, return the",
            "        serialized value of this node's ``default`` attribute (by",
            "        default, the serialization of :attr:`colander.null`).",
            "",
            "        If an ``appstruct`` argument is not explicitly provided, it",
            "        defaults to :attr:`colander.null`.",
            "        \"\"\"",
            "        if appstruct is null:",
            "            appstruct = self.default",
            "        if isinstance(appstruct, deferred):  # unbound schema with deferreds",
            "            appstruct = null",
            "        cstruct = self.typ.serialize(self, appstruct)",
            "        return cstruct",
            "",
            "    def flatten(self, appstruct):",
            "        \"\"\" Create and return a data structure which is a flattened",
            "        representation of the passed in struct based on the schema represented",
            "        by this node.  The return data structure is a dictionary; its keys are",
            "        dotted names.  Each dotted name represents a path to a location in the",
            "        schema.  The values of of the flattened dictionary are subvalues of",
            "        the passed in struct.\"\"\"",
            "        flat = self.typ.flatten(self, appstruct)",
            "        return flat",
            "",
            "    def unflatten(self, fstruct):",
            "        \"\"\" Create and return a data structure with nested substructures based",
            "        on the schema represented by this node using the flattened",
            "        representation passed in. This is the inverse operation to",
            "        :meth:`colander.SchemaNode.flatten`.\"\"\"",
            "        paths = sorted(fstruct.keys())",
            "        return self.typ.unflatten(self, paths, fstruct)",
            "",
            "    def set_value(self, appstruct, dotted_name, value):",
            "        \"\"\" Uses the schema to set a value in a nested datastructure from a",
            "        dotted name path. \"\"\"",
            "        self.typ.set_value(self, appstruct, dotted_name, value)",
            "",
            "    def get_value(self, appstruct, dotted_name):",
            "        \"\"\" Traverses the nested data structure using the schema and retrieves",
            "        the value specified by the dotted name path.\"\"\"",
            "        return self.typ.get_value(self, appstruct, dotted_name)",
            "",
            "    def deserialize(self, cstruct=null):",
            "        \"\"\" Deserialize the :term:`cstruct` into an :term:`appstruct` based",
            "        on the schema, run this :term:`appstruct` through the",
            "        preparer, if one is present, then validate the",
            "        prepared appstruct.  The ``cstruct`` value is deserialized into an",
            "        ``appstruct`` unconditionally.",
            "",
            "        If ``appstruct`` returned by type deserialization and",
            "        preparation is the value :attr:`colander.null`, do something",
            "        special before attempting validation:",
            "",
            "        - If the ``missing`` attribute of this node has been set explicitly,",
            "          return its value.  No validation of this value is performed; it is",
            "          simply returned.",
            "",
            "        - If the ``missing`` attribute of this node has not been set",
            "          explicitly, raise a :exc:`colander.Invalid` exception error.",
            "",
            "        If the appstruct is not ``colander.null`` and cannot be validated , a",
            "        :exc:`colander.Invalid` exception will be raised.",
            "",
            "        If a ``cstruct`` argument is not explicitly provided, it",
            "        defaults to :attr:`colander.null`.",
            "        \"\"\"",
            "        appstruct = self.typ.deserialize(self, cstruct)",
            "",
            "        if self.preparer is not None:",
            "            # if the preparer is a function, call a single preparer",
            "            if hasattr(self.preparer, '__call__'):",
            "                appstruct = self.preparer(appstruct)",
            "            # if the preparer is a list, call each separate preparer",
            "            elif is_nonstr_iter(self.preparer):",
            "                for preparer in self.preparer:",
            "                    appstruct = preparer(appstruct)",
            "",
            "        if appstruct is null:",
            "            appstruct = self.missing",
            "            if appstruct is required:",
            "                raise Invalid(",
            "                    self,",
            "                    _(",
            "                        self.missing_msg,",
            "                        mapping={'title': self.title, 'name': self.name},",
            "                    ),",
            "                )",
            "",
            "            if isinstance(appstruct, deferred):",
            "                # unbound schema with deferreds",
            "                raise Invalid(self, self.missing_msg)",
            "            # We never deserialize or validate the missing value",
            "            return appstruct",
            "",
            "        if self.validator is not None:",
            "            if isinstance(self.validator, deferred):  # unbound",
            "                raise UnboundDeferredError(",
            "                    \"Schema node {node} has an unbound \"",
            "                    \"deferred validator\".format(node=self)",
            "                )",
            "            self.validator(self, appstruct)",
            "        return appstruct",
            "",
            "    def add(self, node):",
            "        \"\"\" Append a subnode to this node. ``node`` must be a SchemaNode.\"\"\"",
            "        self.children.append(node)",
            "",
            "    def insert(self, index, node):",
            "        \"\"\" Insert a subnode into the position ``index``.  ``node`` must be",
            "        a SchemaNode.\"\"\"",
            "        self.children.insert(index, node)",
            "",
            "    def add_before(self, name, node):",
            "        \"\"\" Insert a subnode into the position before the node named ``name``",
            "        \"\"\"",
            "        for pos, sub in enumerate(self.children[:]):",
            "            if sub.name == name:",
            "                self.insert(pos, node)",
            "                return",
            "        raise KeyError('No such node named %s' % name)",
            "",
            "    def get(self, name, default=None):",
            "        \"\"\" Return the subnode associated with ``name`` or ``default`` if no",
            "        such node exists.\"\"\"",
            "        for node in self.children:",
            "            if node.name == name:",
            "                return node",
            "        return default",
            "",
            "    def clone(self):",
            "        \"\"\" Clone the schema node and return the clone.  All subnodes",
            "        are also cloned recursively.  Attributes present in node",
            "        dictionaries are preserved.\"\"\"",
            "        cloned = self.__class__(self.typ)",
            "        cloned.__dict__.update(self.__dict__)",
            "        cloned.children = [node.clone() for node in self.children]",
            "        return cloned",
            "",
            "    def bind(self, **kw):",
            "        \"\"\" Resolve any deferred values attached to this schema node",
            "        and its children (recursively), using the keywords passed as",
            "        ``kw`` as input to each deferred value.  This function",
            "        *clones* the schema it is called upon and returns the cloned",
            "        value.  The original schema node (the source of the clone)",
            "        is not modified.\"\"\"",
            "        cloned = self.clone()",
            "        cloned._bind(kw)",
            "        return cloned",
            "",
            "    def _bind(self, kw):",
            "        self.bindings = kw",
            "        for child in self.children:",
            "            child._bind(kw)",
            "        names = dir(self)",
            "        for k in names:",
            "            v = getattr(self, k)",
            "            if isinstance(v, deferred):",
            "                v = v(self, kw)",
            "                if isinstance(v, SchemaNode):",
            "                    self[k] = v",
            "                else:",
            "                    setattr(self, k, v)",
            "        if getattr(self, 'after_bind', None):",
            "            self.after_bind(self, kw)",
            "",
            "    def cstruct_children(self, cstruct):",
            "        \"\"\" Will call the node's type's ``cstruct_children`` method with this",
            "        node as a first argument, and ``cstruct`` as a second argument.\"\"\"",
            "        cstruct_children = getattr(self.typ, 'cstruct_children', None)",
            "        if cstruct_children is None:",
            "            warnings.warn(",
            "                'The node type %s has no cstruct_children method. '",
            "                'This method is required to be implemented by schema types '",
            "                'for compatibility with Colander 0.9.9+. In a future Colander '",
            "                'version, the absence of this method will cause an '",
            "                'exception.  Returning [] for compatibility although it '",
            "                'may not be the right value.' % self.typ.__class__,",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            return []",
            "        return cstruct_children(self, cstruct)",
            "",
            "    def __delitem__(self, name):",
            "        \"\"\" Remove a subnode by name \"\"\"",
            "        for idx, node in enumerate(self.children[:]):",
            "            if node.name == name:",
            "                return self.children.pop(idx)",
            "        raise KeyError(name)",
            "",
            "    def __getitem__(self, name):",
            "        \"\"\" Get a subnode by name. \"\"\"",
            "        val = self.get(name, _marker)",
            "        if val is _marker:",
            "            raise KeyError(name)",
            "        return val",
            "",
            "    def __setitem__(self, name, newnode):",
            "        \"\"\" Replace a subnode by name.  ``newnode`` must be a SchemaNode.  If",
            "        a subnode named ``name`` doesn't already exist, calling this method",
            "        is the same as setting the node's name to ``name`` and calling the",
            "        ``add`` method with the node (it will be appended to the children",
            "        list).\"\"\"",
            "        newnode.name = name",
            "        for idx, node in enumerate(self.children[:]):",
            "            if node.name == name:",
            "                self.children[idx] = newnode",
            "                return node",
            "        self.add(newnode)",
            "",
            "    def __iter__(self):",
            "        \"\"\" Iterate over the children nodes of this schema node \"\"\"",
            "        return iter(self.children)",
            "",
            "    def __contains__(self, name):",
            "        \"\"\" Return True if subnode named ``name`` exists in this node \"\"\"",
            "        return self.get(name, _marker) is not _marker",
            "",
            "    def __repr__(self):",
            "        return '<%s.%s object at %d (named %s)>' % (",
            "            self.__module__,",
            "            self.__class__.__name__,",
            "            id(self),",
            "            self.name,",
            "        )",
            "",
            "    def raise_invalid(self, msg, node=None):",
            "        \"\"\" Raise a :exc:`colander.Invalid` exception with the message",
            "        ``msg``.  ``node``, if supplied, should be an instance of a",
            "        :class:`colander.SchemaNode`.  If it is not supplied, ``node`` will",
            "        be this node.  Example usage::",
            "",
            "            class CustomSchemaNode(SchemaNode):",
            "                def validator(self, node, cstruct):",
            "                    if cstruct != 'the_right_thing':",
            "                        self.raise_invalid('Not the right thing')",
            "",
            "        \"\"\"",
            "        if node is None:",
            "            node = self",
            "        raise Invalid(node, msg)",
            "",
            "",
            "class _SchemaMeta(type):",
            "    def __init__(cls, name, bases, clsattrs):",
            "        nodes = []",
            "",
            "        for name, value in clsattrs.items():",
            "            if isinstance(value, _SchemaNode):",
            "                delattr(cls, name)",
            "                if not value.name:",
            "                    value.name = name",
            "                if value.raw_title is _marker:",
            "                    value.title = name.replace('_', ' ').title()",
            "                nodes.append((value._order, value))",
            "",
            "        nodes.sort(key=lambda n: n[0])",
            "        cls.__class_schema_nodes__ = [n[1] for n in nodes]",
            "",
            "        # Combine all attrs from this class and its _SchemaNode superclasses.",
            "        cls.__all_schema_nodes__ = []",
            "        for c in reversed(cls.__mro__):",
            "            csn = getattr(c, '__class_schema_nodes__', [])",
            "            cls.__all_schema_nodes__.extend(csn)",
            "",
            "",
            "# metaclass spelling compatibility across Python 2 and Python 3",
            "SchemaNode = _SchemaMeta(",
            "    'SchemaNode', (_SchemaNode,), {'__doc__': _SchemaNode.__doc__}",
            ")",
            "",
            "",
            "class Schema(SchemaNode):",
            "    schema_type = Mapping",
            "",
            "",
            "MappingSchema = Schema",
            "",
            "",
            "class TupleSchema(SchemaNode):",
            "    schema_type = Tuple",
            "",
            "",
            "class SequenceSchema(SchemaNode):",
            "    schema_type = Sequence",
            "",
            "    def __init__(self, *args, **kw):",
            "        SchemaNode.__init__(self, *args, **kw)",
            "        if len(self.children) != 1:",
            "            raise Invalid(",
            "                self, 'Sequence schemas must have exactly one child node'",
            "            )",
            "",
            "    def clone(self):",
            "        \"\"\" Clone the schema node and return the clone.  All subnodes",
            "        are also cloned recursively.  Attributes present in node",
            "        dictionaries are preserved.\"\"\"",
            "",
            "        # Cloning a ``SequenceSchema`` doesn't work with ``_SchemaNode.clone``.",
            "",
            "        children = [node.clone() for node in self.children]",
            "        cloned = self.__class__(self.typ, *children)",
            "",
            "        attributes = self.__dict__.copy()",
            "        attributes.pop('children', None)",
            "        cloned.__dict__.update(attributes)",
            "        return cloned",
            "",
            "",
            "class deferred(object):",
            "    \"\"\" A decorator which can be used to define deferred schema values",
            "    (missing values, widgets, validators, etc.)\"\"\"",
            "",
            "    def __init__(self, wrapped):",
            "        try:",
            "            functools.update_wrapper(self, wrapped)",
            "        except AttributeError:",
            "            # non-function (raises in Python 2)",
            "            self.__doc__ = getattr(wrapped, '__doc__', None)",
            "        self.wrapped = wrapped",
            "",
            "    def __call__(self, node, kw):",
            "        return self.wrapped(node, kw)",
            "",
            "",
            "def _unflatten_mapping(",
            "    node, paths, fstruct, get_child=None, rewrite_subpath=None",
            "):",
            "    if get_child is None:",
            "        get_child = node.__getitem__",
            "    if rewrite_subpath is None:",
            "",
            "        def rewrite_subpath(subpath):",
            "            return subpath",
            "",
            "    node_name = node.name",
            "    if node_name:",
            "        prefix = node_name + '.'",
            "    else:",
            "        prefix = ''",
            "    prefix_len = len(prefix)",
            "    appstruct = {}",
            "    subfstruct = {}",
            "    subpaths = []",
            "    curname = None",
            "    for path in paths:",
            "        if path == node_name:",
            "            # flattened structs contain non-leaf nodes which are ignored",
            "            # during unflattening.",
            "            continue",
            "        assert path.startswith(prefix), \"Bad node: %s\" % path",
            "        subpath = path[prefix_len:]",
            "        if '.' in subpath:",
            "            name = subpath[: subpath.index('.')]",
            "        else:",
            "            name = subpath",
            "        if curname is None:",
            "            curname = name",
            "        elif name != curname:",
            "            subnode = get_child(curname)",
            "            appstruct[curname] = subnode.typ.unflatten(",
            "                subnode, subpaths, subfstruct",
            "            )",
            "            subfstruct = {}",
            "            subpaths = []",
            "            curname = name",
            "        subpath = rewrite_subpath(subpath)",
            "        subfstruct[subpath] = fstruct[path]",
            "        subpaths.append(subpath)",
            "    if curname is not None:",
            "        subnode = get_child(curname)",
            "        appstruct[curname] = subnode.typ.unflatten(",
            "            subnode, subpaths, subfstruct",
            "        )",
            "    return appstruct",
            "",
            "",
            "class instantiate(object):",
            "    \"\"\"",
            "    A decorator which can be used to instantiate :class:`SchemaNode`",
            "    elements inline within a class definition.",
            "",
            "    All parameters passed to the decorator and passed along to the",
            "    :class:`SchemaNode` during instantiation.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kw):",
            "        self.args, self.kw = args, kw",
            "",
            "    def __call__(self, class_):",
            "        return class_(*self.args, **self.kw)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "611": [],
            "612": [],
            "613": [],
            "614": [],
            "617": [
                "url"
            ]
        },
        "addLocation": []
    },
    "colander/tests/test_colander.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 646,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "         self.assertRaises(Invalid, self._callFUT, val)"
            },
            "2": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 648,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+    def test_add_sample_dos(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+        # In the old regex (colander <=1.6) this would cause a catastrophic"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+        # backtracking that would cause the regex engine to go into an infinite"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 652,
                "PatchRowcode": "+        # loop."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+        val = \"http://www.mysite.com/(tttttttttttttttttttttt.jpg\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+    def test_website_no_scheme(self):"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+        val = \"www.mysite.com\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 662,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 664,
                "PatchRowcode": "+    def test_ipv6(self):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 665,
                "PatchRowcode": "+        val = \"http://[2001:db8::0]/\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 668,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 669,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 670,
                "PatchRowcode": "+    def test_ipv4(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 671,
                "PatchRowcode": "+        val = \"http://192.0.2.1/\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 672,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 674,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 675,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 676,
                "PatchRowcode": "+    def test_file_raises(self):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+        from colander import Invalid"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 679,
                "PatchRowcode": "+        val = \"file:///this/is/a/file.jpg\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 680,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 681,
                "PatchRowcode": "+        self.assertRaises(Invalid, self._callFUT, val)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 682,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 683,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+class Test_file_uri_validator(unittest.TestCase):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 685,
                "PatchRowcode": "+    def _callFUT(self, val):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+        from colander import file_uri"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 687,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 688,
                "PatchRowcode": "+        return file_uri(None, val)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 689,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 690,
                "PatchRowcode": "+    def test_it_success(self):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 691,
                "PatchRowcode": "+        val = 'file:///'"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 692,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 693,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 694,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 695,
                "PatchRowcode": "+    def test_it_failure(self):"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 696,
                "PatchRowcode": "+        val = 'not-a-uri'"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+        from colander import Invalid"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 698,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+        self.assertRaises(Invalid, self._callFUT, val)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+    def test_no_path_fails(self):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 702,
                "PatchRowcode": "+        val = 'file://'"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 703,
                "PatchRowcode": "+        from colander import Invalid"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 704,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 705,
                "PatchRowcode": "+        self.assertRaises(Invalid, self._callFUT, val)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+    def test_file_with_path(self):"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+        val = \"file:///this/is/a/file.jpg\""
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 710,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 711,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 712,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 713,
                "PatchRowcode": "+    def test_file_with_path_windows(self):"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 714,
                "PatchRowcode": "+        val = \"file:///c:/is/a/file.jpg\""
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 715,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 716,
                "PatchRowcode": "+        result = self._callFUT(val)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 717,
                "PatchRowcode": "+        self.assertEqual(result, None)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 718,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 719,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 720,
                "PatchRowcode": " class TestUUID(unittest.TestCase):"
            },
            "75": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 721,
                "PatchRowcode": "     def _callFUT(self, val):"
            }
        },
        "frontPatchFile": [
            "# -*- coding:utf-8 -*-",
            "import unittest",
            "from colander.compat import text_, text_type",
            "",
            "",
            "def invalid_exc(func, *arg, **kw):",
            "    from colander import Invalid",
            "",
            "    try:",
            "        func(*arg, **kw)",
            "    except Invalid as e:",
            "        return e",
            "    else:",
            "        raise AssertionError('Invalid not raised')  # pragma: no cover",
            "",
            "",
            "class TestInvalid(unittest.TestCase):",
            "    def _makeOne(self, node, msg=None, val=None):",
            "        from colander import Invalid",
            "",
            "        exc = Invalid(node, msg, val)",
            "        return exc",
            "",
            "    def test_ctor(self):",
            "        exc = self._makeOne(None, 'msg', 'val')",
            "        self.assertEqual(exc.node, None)",
            "        self.assertEqual(exc.msg, 'msg')",
            "        self.assertEqual(exc.value, 'val')",
            "        self.assertEqual(exc.children, [])",
            "",
            "    def test_add(self):",
            "        exc = self._makeOne(None, 'msg')",
            "        other = Dummy()",
            "        exc.add(other)",
            "        self.assertFalse(hasattr(other, 'positional'))",
            "        self.assertEqual(exc.children, [other])",
            "",
            "    def test_add_positional(self):",
            "        from colander import Positional",
            "",
            "        p = Positional()",
            "        node = DummySchemaNode(p)",
            "        exc = self._makeOne(node, 'msg')",
            "        other = Dummy()",
            "        exc.add(other)",
            "        self.assertEqual(other.positional, True)",
            "        self.assertEqual(exc.children, [other])",
            "",
            "    def test__keyname_no_parent(self):",
            "        node = DummySchemaNode(None, name='name')",
            "        exc = self._makeOne(None, '')",
            "        exc.node = node",
            "        self.assertEqual(exc._keyname(), 'name')",
            "",
            "    def test__keyname_positional(self):",
            "        exc = self._makeOne(None, '')",
            "        exc.positional = True",
            "        exc.pos = 2",
            "        self.assertEqual(exc._keyname(), '2')",
            "",
            "    def test__keyname_nonpositional_parent(self):",
            "        parent = Dummy()",
            "        parent.node = DummySchemaNode(None)",
            "        exc = self._makeOne(None, 'me')",
            "        exc.parent = parent",
            "        exc.pos = 2",
            "        exc.node = DummySchemaNode(None, name='name')",
            "        self.assertEqual(exc._keyname(), 'name')",
            "",
            "    def test_paths(self):",
            "        exc1 = self._makeOne(None, 'exc1')",
            "        exc2 = self._makeOne(None, 'exc2')",
            "        exc3 = self._makeOne(None, 'exc3')",
            "        exc4 = self._makeOne(None, 'exc4')",
            "        exc1.add(exc2)",
            "        exc2.add(exc3)",
            "        exc1.add(exc4)",
            "        paths = list(exc1.paths())",
            "        self.assertEqual(paths, [(exc1, exc2, exc3), (exc1, exc4)])",
            "",
            "    def test_asdict(self):",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node4 = DummySchemaNode(Positional(), 'node4')",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = self._makeOne(node3, 'exc3')",
            "        exc4 = self._makeOne(node4, 'exc4')",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        exc1.add(exc4, 4)",
            "        d = exc1.asdict()",
            "        self.assertEqual(",
            "            d,",
            "            {'node1.node2.3': 'exc1; exc2; exc3', 'node1.node4': 'exc1; exc4'},",
            "        )",
            "",
            "    def test_asdict_with_all_validator(self):",
            "        # see https://github.com/Pylons/colander/pull/27",
            "        from colander import All",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node1.children = [node3]",
            "        validator1 = DummyValidator('validator1')",
            "        validator2 = DummyValidator('validator2')",
            "        validator = All(validator1, validator2)",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc1['node3'] = 'message1'",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = invalid_exc(validator, None, None)",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        d = exc1.asdict()",
            "        self.assertEqual(",
            "            d,",
            "            {",
            "                'node1.node2.3': 'exc1; exc2; validator1; validator2',",
            "                'node1.node3': 'exc1; message1',",
            "            },",
            "        )",
            "",
            "    def test_asdict_with_all_validator_functional(self):",
            "        # see https://github.com/Pylons/colander/issues/2",
            "        import colander as c",
            "",
            "        class MySchema(c.MappingSchema):",
            "            number1 = c.SchemaNode(c.Int(), validator=c.Range(min=1))",
            "            number2 = c.SchemaNode(c.Int(), validator=c.Range(min=1))",
            "",
            "        def validate_higher(node, val):",
            "            if val['number1'] >= val['number2']:",
            "                raise c.Invalid(node, 'Number 1 must be lower than number 2')",
            "",
            "        def validate_different(node, val):",
            "            if val['number1'] == val['number2']:",
            "                raise c.Invalid(node, \"They can't be the same, either\")",
            "",
            "        schema = MySchema(validator=c.All(validate_higher, validate_different))",
            "        try:",
            "            schema.deserialize(dict(number1=2, number2=2))",
            "        except c.Invalid as e:",
            "            result = e.asdict()",
            "            self.assertEqual(",
            "                result,",
            "                {",
            "                    '': (",
            "                        \"Number 1 must be lower than number 2; \"",
            "                        \"They can't be the same, either\"",
            "                    )",
            "                },",
            "            )",
            "        try:",
            "            schema.deserialize(dict(number1=2, number2=2))",
            "        except c.Invalid as e:",
            "            result = e.asdict(separator=None)",
            "            self.assertEqual(",
            "                result,",
            "                {",
            "                    '': [",
            "                        \"Number 1 must be lower than number 2\",",
            "                        \"They can't be the same, either\",",
            "                    ]",
            "                },",
            "            )",
            "",
            "    def test___str__(self):",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node4 = DummySchemaNode(Positional(), 'node4')",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = self._makeOne(node3, 'exc3')",
            "        exc4 = self._makeOne(node4, 'exc4')",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        exc1.add(exc4, 4)",
            "        result = str(exc1)",
            "        self.assertEqual(",
            "            result,",
            "            \"{'node1.node2.3': 'exc1; exc2; exc3', \"",
            "            \"'node1.node4': 'exc1; exc4'}\",",
            "        )",
            "",
            "    def test___setitem__fails(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, 'msg')",
            "        self.assertRaises(KeyError, exc.__setitem__, 'notfound', 'msg')",
            "",
            "    def test___setitem__succeeds(self):",
            "        node = DummySchemaNode(None)",
            "        child = DummySchemaNode(None)",
            "        child.name = 'found'",
            "        node.children = [child]",
            "        exc = self._makeOne(node, 'msg')",
            "        exc['found'] = 'msg2'",
            "        self.assertEqual(len(exc.children), 1)",
            "        childexc = exc.children[0]",
            "        self.assertEqual(childexc.pos, 0)",
            "        self.assertEqual(childexc.node.name, 'found')",
            "",
            "    def test_messages_msg_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, [123, 456])",
            "        self.assertEqual(exc.messages(), [123, 456])",
            "",
            "    def test_messages_msg_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, 'msg')",
            "        self.assertEqual(exc.messages(), ['msg'])",
            "",
            "    def test_messages_msg_None(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, None)",
            "        self.assertEqual(exc.messages(), [])",
            "",
            "",
            "class TestAll(unittest.TestCase):",
            "    def _makeOne(self, validators):",
            "        from colander import All",
            "",
            "        return All(*validators)",
            "",
            "    def test_success(self):",
            "        validator1 = DummyValidator()",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_failure(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator('msg2')",
            "        validator = self._makeOne([validator1, validator2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, ['msg1', 'msg2'])",
            "",
            "    def test_Invalid_children(self):",
            "        from colander import Invalid",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node = DummySchemaNode(None, 'node')",
            "        node.children = [node1]",
            "        exc1 = Invalid(node1, 'exc1')",
            "        exc2 = Invalid(node1, 'exc2')",
            "        validator1 = DummyValidator('validator1', [exc1])",
            "        validator2 = DummyValidator('validator2', [exc2])",
            "        validator = self._makeOne([validator1, validator2])",
            "        exc = invalid_exc(validator, node, None)",
            "        self.assertEqual(exc.children, [exc1, exc2])",
            "",
            "",
            "class TestAny(unittest.TestCase):",
            "    def _makeOne(self, validators):",
            "        from colander import Any",
            "",
            "        return Any(*validators)",
            "",
            "    def test_success(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_failure(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator('msg2')",
            "        validator = self._makeOne([validator1, validator2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, ['msg1', 'msg2'])",
            "",
            "    def test_Invalid_children(self):",
            "        from colander import Invalid",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node = DummySchemaNode(None, 'node')",
            "        node.children = [node1]",
            "        exc1 = Invalid(node1, 'exc1')",
            "        validator1 = DummyValidator('validator1', [exc1])",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "",
            "class TestFunction(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Function",
            "",
            "        return Function(*arg, **kw)",
            "",
            "    def test_success_function_returns_True(self):",
            "        validator = self._makeOne(lambda x: True)",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_fail_function_returns_empty_string(self):",
            "        validator = self._makeOne(lambda x: '')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'Invalid value')",
            "",
            "    def test_fail_function_returns_False(self):",
            "        validator = self._makeOne(lambda x: False)",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'Invalid value')",
            "",
            "    def test_fail_function_returns_string(self):",
            "        validator = self._makeOne(lambda x: 'fail')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'fail')",
            "",
            "    def test_deprecated_message(self):",
            "        import warnings",
            "",
            "        orig_warn = warnings.warn",
            "        log = []",
            "",
            "        def warn(message, category=None, stacklevel=1):",
            "            log.append((message, category, stacklevel))",
            "",
            "        try:",
            "            # Monkey patching warn so that tests run quietly",
            "            warnings.warn = warn",
            "            validator = self._makeOne(lambda x: False, message='depr')",
            "            e = invalid_exc(validator, None, None)",
            "            self.assertEqual(e.msg.interpolate(), 'depr')",
            "        finally:",
            "            warnings.warn = orig_warn",
            "",
            "    def test_deprecated_message_warning(self):",
            "        import warnings",
            "",
            "        orig_warn = warnings.warn",
            "        log = []",
            "",
            "        def warn(message, category=None, stacklevel=1):",
            "            log.append((message, category, stacklevel))",
            "",
            "        try:",
            "            # Monkey patching warn since catch_warnings context manager",
            "            # is not working when running the full suite",
            "            warnings.warn = warn",
            "            validator = self._makeOne(lambda x: False, message='depr')",
            "            invalid_exc(validator, None, None)",
            "            self.assertEqual(len(log), 1)",
            "        finally:",
            "            warnings.warn = orig_warn",
            "",
            "    def test_msg_and_message_error(self):",
            "        self.assertRaises(",
            "            ValueError,",
            "            self._makeOne,",
            "            lambda x: False,",
            "            msg='one',",
            "            message='two',",
            "        )",
            "",
            "    def test_error_message_adds_mapping_to_configured_message(self):",
            "        validator = self._makeOne(lambda x: False, msg='fail ${val}')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), 'fail None')",
            "",
            "    def test_error_message_adds_mapping_to_return_message(self):",
            "        validator = self._makeOne(lambda x: 'fail ${val}')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), 'fail None')",
            "",
            "    def test_error_message_does_not_overwrite_configured_domain(self):",
            "        import translationstring",
            "",
            "        _ = translationstring.TranslationStringFactory('fnord')",
            "        validator = self._makeOne(lambda x: False, msg=_('fail ${val}'))",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.domain, 'fnord')",
            "",
            "    def test_error_message_does_not_overwrite_returned_domain(self):",
            "        import translationstring",
            "",
            "        _ = translationstring.TranslationStringFactory('fnord')",
            "        validator = self._makeOne(lambda x: _('fail ${val}'))",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.domain, 'fnord')",
            "",
            "    def test_propagation(self):",
            "        validator = self._makeOne(lambda x: 'a' in x, 'msg')",
            "        self.assertRaises(TypeError, validator, None, None)",
            "",
            "",
            "class TestRange(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Range",
            "",
            "        return Range(**kw)",
            "",
            "    def test_success_no_bounds(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_success_upper_bound_only(self):",
            "        validator = self._makeOne(max=1)",
            "        self.assertEqual(validator(None, -1), None)",
            "",
            "    def test_success_minimum_bound_only(self):",
            "        validator = self._makeOne(min=0)",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_success_min_and_max(self):",
            "        validator = self._makeOne(min=1, max=1)",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_min_failure(self):",
            "        validator = self._makeOne(min=1)",
            "        e = invalid_exc(validator, None, 0)",
            "        self.assertEqual(e.msg.interpolate(), '0 is less than minimum value 1')",
            "",
            "    def test_min_failure_msg_override(self):",
            "        validator = self._makeOne(min=1, min_err='wrong')",
            "        e = invalid_exc(validator, None, 0)",
            "        self.assertEqual(e.msg, 'wrong')",
            "",
            "    def test_max_failure(self):",
            "        validator = self._makeOne(max=1)",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(",
            "            e.msg.interpolate(), '2 is greater than maximum value 1'",
            "        )",
            "",
            "    def test_max_failure_msg_override(self):",
            "        validator = self._makeOne(max=1, max_err='wrong')",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(e.msg, 'wrong')",
            "",
            "",
            "class TestRegex(unittest.TestCase):",
            "    def _makeOne(self, pattern):",
            "        from colander import Regex",
            "",
            "        return Regex(pattern)",
            "",
            "    def test_valid_regex(self):",
            "        self.assertEqual(self._makeOne('a')(None, 'a'), None)",
            "        self.assertEqual(self._makeOne('[0-9]+')(None, '1111'), None)",
            "        self.assertEqual(self._makeOne('')(None, ''), None)",
            "        self.assertEqual(self._makeOne('.*')(None, ''), None)",
            "",
            "    def test_invalid_regexs(self):",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._makeOne('[0-9]+'), None, 'a')",
            "        self.assertRaises(Invalid, self._makeOne('a{2,4}'), None, 'ba')",
            "",
            "    def test_regex_not_string(self):",
            "        from colander import Invalid",
            "        import re",
            "",
            "        regex = re.compile('[0-9]+')",
            "        self.assertEqual(self._makeOne(regex)(None, '01'), None)",
            "        self.assertRaises(Invalid, self._makeOne(regex), None, 't')",
            "",
            "",
            "class TestEmail(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Email",
            "",
            "        return Email()",
            "",
            "    def test_valid_emails(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, 'me@here.com'), None)",
            "        self.assertEqual(validator(None, 'me1@here1.com'), None)",
            "        self.assertEqual(validator(None, 'name@here1.us'), None)",
            "        self.assertEqual(validator(None, 'name@here1.info'), None)",
            "        self.assertEqual(validator(None, 'foo@bar.baz.biz'), None)",
            "        self.assertEqual(validator(None, \"tip'oneill@house.gov\"), None)",
            "        self.assertEqual(validator(None, \"lorem@i--ipsum.com\"), None)",
            "",
            "    def test_empty_email(self):",
            "        validator = self._makeOne()",
            "        e = invalid_exc(validator, None, '')",
            "        self.assertEqual(e.msg, 'Invalid email address')",
            "",
            "    def test_invalid_emails(self):",
            "        validator = self._makeOne()",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, validator, None, 'me@here.')",
            "        self.assertRaises(Invalid, validator, None, '@here.us')",
            "        self.assertRaises(Invalid, validator, None, 'me@here..com')",
            "        self.assertRaises(Invalid, validator, None, 'me@we-here-.com')",
            "        self.assertRaises(Invalid, validator, None, 'name1,name2@here.info')",
            "",
            "",
            "class TestLength(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Length",
            "",
            "        return Length(**kw)",
            "",
            "    def test_success_no_bounds(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, ''), None)",
            "",
            "    def test_success_upper_bound_only(self):",
            "        validator = self._makeOne(max=1)",
            "        self.assertEqual(validator(None, 'a'), None)",
            "",
            "    def test_success_minimum_bound_only(self):",
            "        validator = self._makeOne(min=0)",
            "        self.assertEqual(validator(None, ''), None)",
            "",
            "    def test_success_min_and_max(self):",
            "        validator = self._makeOne(min=1, max=1)",
            "        self.assertEqual(validator(None, 'a'), None)",
            "",
            "    def test_min_failure(self):",
            "        validator = self._makeOne(min=1)",
            "        e = invalid_exc(validator, None, '')",
            "        self.assertEqual(e.msg.interpolate(), 'Shorter than minimum length 1')",
            "",
            "    def test_max_failure(self):",
            "        validator = self._makeOne(max=1)",
            "        e = invalid_exc(validator, None, 'ab')",
            "        self.assertEqual(e.msg.interpolate(), 'Longer than maximum length 1')",
            "",
            "    def test_min_failure_msg_override(self):",
            "        validator = self._makeOne(min=1, min_err='Need at least ${min}, mate')",
            "        e = invalid_exc(validator, None, [])",
            "        self.assertEqual(e.msg.interpolate(), 'Need at least 1, mate')",
            "",
            "    def test_max_failure_msg_override(self):",
            "        validator = self._makeOne(max=1, max_err='No more than ${max}, mate')",
            "        e = invalid_exc(validator, None, [1, 2])",
            "        self.assertEqual(e.msg.interpolate(), 'No more than 1, mate')",
            "",
            "",
            "class TestOneOf(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import OneOf",
            "",
            "        return OneOf(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1])",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1, 2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not one of 1, 2')",
            "",
            "",
            "class TestNoneOf(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import NoneOf",
            "",
            "        return NoneOf(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1, 2])",
            "        self.assertEqual(validator(None, 3), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1, 2])",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(e.msg.interpolate(), '\"2\" must not be one of 1, 2')",
            "",
            "",
            "class TestContainsOnly(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import ContainsOnly",
            "",
            "        return ContainsOnly(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1])",
            "        self.assertEqual(validator(None, [1]), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1])",
            "        e = invalid_exc(validator, None, [2])",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'One or more of the choices you made was not acceptable',",
            "        )",
            "",
            "    def test_failure_with_custom_error_template(self):",
            "        validator = self._makeOne([1])",
            "        from colander import _",
            "",
            "        validator.err_template = _('${val}: ${choices}')",
            "        e = invalid_exc(validator, None, [2])",
            "        self.assertTrue('[2]' in e.msg.interpolate())",
            "",
            "",
            "class Test_luhnok(unittest.TestCase):",
            "    def _callFUT(self, node, value):",
            "        from colander import luhnok",
            "",
            "        return luhnok(node, value)",
            "",
            "    def test_fail(self):",
            "        import colander",
            "",
            "        val = '10'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_fail2(self):",
            "        import colander",
            "",
            "        val = '99999999999999999999999'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_fail3(self):",
            "        import colander",
            "",
            "        val = 'abcdefghij'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_success(self):",
            "        val = '4111111111111111'",
            "        self.assertFalse(self._callFUT(None, val))",
            "",
            "",
            "class Test_url_validator(unittest.TestCase):",
            "    def _callFUT(self, val):",
            "        from colander import url",
            "",
            "        return url(None, val)",
            "",
            "    def test_it_success(self):",
            "        val = 'http://example.com'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_it_failure(self):",
            "        val = 'not-a-url'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "",
            "class TestUUID(unittest.TestCase):",
            "    def _callFUT(self, val):",
            "        from colander import uuid",
            "",
            "        return uuid(None, val)",
            "",
            "    def test_success_hexadecimal(self):",
            "        val = '123e4567e89b12d3a456426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_dashes(self):",
            "        val = '123e4567-e89b-12d3-a456-426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_upper_case(self):",
            "        val = '123E4567-E89B-12D3-A456-426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_braces(self):",
            "        val = '{123e4567-e89b-12d3-a456-426655440000}'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_urn_ns(self):",
            "        val = 'urn:uuid:{123e4567-e89b-12d3-a456-426655440000}'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_failure_random_string(self):",
            "        val = 'not-a-uuid'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_not_hexadecimal(self):",
            "        val = '123zzzzz-uuuu-zzzz-uuuu-42665544zzzz'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_invalid_length(self):",
            "        # Correct UUID: 8-4-4-4-12",
            "        val = '88888888-333-4444-333-cccccccccccc'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_with_invalid_urn_ns(self):",
            "        val = 'urn:abcd:{123e4567-e89b-12d3-a456-426655440000}'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "",
            "class TestSchemaType(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import SchemaType",
            "",
            "        return SchemaType(*arg, **kw)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, 'appstruct')",
            "        self.assertEqual(result, {'node': 'appstruct'})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, 'appstruct', listitem=True)",
            "        self.assertEqual(result, {'': 'appstruct'})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(node, ['node'], {'node': 'appstruct'})",
            "        self.assertEqual(result, 'appstruct')",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            AssertionError, typ.set_value, None, None, None, None",
            "        )",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(AssertionError, typ.get_value, None, None, None)",
            "",
            "    def test_cstruct_children(self):",
            "        typ = self._makeOne()",
            "        self.assertEqual(typ.cstruct_children(None, None), [])",
            "",
            "",
            "class TestMapping(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Mapping",
            "",
            "        return Mapping(*arg, **kw)",
            "",
            "    def test_ctor_bad_unknown(self):",
            "        self.assertRaises(ValueError, self._makeOne, 'badarg')",
            "",
            "    def test_ctor_good_unknown(self):",
            "        try:",
            "            self._makeOne('ignore')",
            "            self._makeOne('raise')",
            "            self._makeOne('preserve')",
            "        except ValueError as e:  # pragma: no cover",
            "            raise AssertionError(e)",
            "",
            "    def test_deserialize_not_a_mapping(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "",
            "        # None",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"None\" is not a mapping type')",
            "        )",
            "",
            "        # list",
            "        e = invalid_exc(typ.deserialize, node, [])",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"[]\" is not a mapping type')",
            "        )",
            "",
            "        # str",
            "        e = invalid_exc(typ.deserialize, node, \"\")",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"\" is not a mapping type')",
            "        )",
            "",
            "        # tuple",
            "        e = invalid_exc(typ.deserialize, node, ())",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"()\" is not a mapping type')",
            "        )",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_deserialize_unknown_raise(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne(unknown='raise')",
            "        e = invalid_exc(typ.deserialize, node, {'a': 1, 'b': 2})",
            "        self.assertTrue(isinstance(e, colander.UnsupportedFields))",
            "        self.assertEqual(e.fields, {'b': 2})",
            "        self.assertEqual(",
            "            e.msg.interpolate(), \"Unrecognized keys in mapping: \\\"{'b': 2}\\\"\"",
            "        )",
            "",
            "    def test_deserialize_unknown_preserve(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne(unknown='preserve')",
            "        result = typ.deserialize(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'a': 1, 'b': 2})",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, {'a': 1, 'b': 2})",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_deserialize_subnode_missing_default(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b', default='abc'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1, 'b': colander.null})",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, {})",
            "",
            "    def test_serialize_not_a_mapping(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"None\" is not a mapping type')",
            "        )",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_serialize_with_unknown(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_serialize_value_is_null(self):",
            "        node = DummySchemaNode(None)",
            "        from colander import null",
            "",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, null)",
            "        self.assertEqual(result, {'a': null})",
            "",
            "    def test_serialize_value_has_drop(self):",
            "        from colander import drop",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': drop})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'node.appstruct': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, {'a': 1, 'b': 2}, listitem=True)",
            "        self.assertEqual(result, {'appstruct': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            ['node', 'node.a', 'node.b'],",
            "            {'node': {'a': 1, 'b': 2}, 'node.a': 1, 'node.b': 2},",
            "        )",
            "        self.assertEqual(result, {'a': 1, 'b': 2})",
            "",
            "    def test_unflatten_nested(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        inttype = DummyType()",
            "        one = DummySchemaNode(self._makeOne(), name='one')",
            "        one.children = [",
            "            DummySchemaNode(inttype, name='a'),",
            "            DummySchemaNode(inttype, name='b'),",
            "        ]",
            "        two = DummySchemaNode(self._makeOne(), name='two')",
            "        two.children = [",
            "            DummySchemaNode(inttype, name='c'),",
            "            DummySchemaNode(inttype, name='d'),",
            "        ]",
            "        node.children = [one, two]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            [",
            "                'node',",
            "                'node.one',",
            "                'node.one.a',",
            "                'node.one.b',",
            "                'node.two',",
            "                'node.two.c',",
            "                'node.two.d',",
            "            ],",
            "            {",
            "                'node': {'one': {'a': 1, 'b': 2}, 'two': {'c': 3, 'd': 4}},",
            "                'node.one': {'a': 1, 'b': 2},",
            "                'node.two': {'c': 3, 'd': 4},",
            "                'node.one.a': 1,",
            "                'node.one.b': 2,",
            "                'node.two.c': 3,",
            "                'node.two.d': 4,",
            "            },",
            "        )",
            "        self.assertEqual(",
            "            result, {'one': {'a': 1, 'b': 2}, 'two': {'c': 3, 'd': 4}}",
            "        )",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        appstruct = {'node2': {'foo': 'foo', 'baz': 'baz'}}",
            "        typ.set_value(node1, appstruct, 'node2.foo', 'bar')",
            "        self.assertEqual(appstruct, {'node2': {'foo': 'bar', 'baz': 'baz'}})",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        appstruct = {'node2': {'foo': 'bar', 'baz': 'baz'}}",
            "        self.assertEqual(",
            "            typ.get_value(node1, appstruct, 'node2'),",
            "            {'foo': 'bar', 'baz': 'baz'},",
            "        )",
            "        self.assertEqual(typ.get_value(node1, appstruct, 'node2.foo'), 'bar')",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        result = typ.cstruct_children(node1, null)",
            "        self.assertEqual(result, [null])",
            "",
            "    def test_cstruct_children(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, {'node2': 'abc'})",
            "        self.assertEqual(result, ['abc', null])",
            "",
            "",
            "class TestTuple(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Tuple",
            "",
            "        return Tuple()",
            "",
            "    def test_deserialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, ())",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, ('a',))",
            "",
            "    def test_deserialize_toobig(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ('a', 'b'))",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            \"\\\"('a', 'b')\\\" has an incorrect number of \"",
            "            \"elements (expected 1, was 2)\",",
            "        )",
            "",
            "    def test_deserialize_toosmall(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ())",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            '\"()\" has an incorrect number of elements (expected 1, was 0)',",
            "        )",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ())",
            "        self.assertEqual(result, ())",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ('a',))",
            "        self.assertEqual(result, ('a',))",
            "",
            "    def test_serialize_toobig(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ('a', 'b'))",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            \"\\\"('a', 'b')\\\" has an incorrect number of \"",
            "            \"elements (expected 1, was 2)\",",
            "        )",
            "",
            "    def test_serialize_toosmall(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ())",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            '\"()\" has an incorrect number of elements (expected 1, was 0)',",
            "        )",
            "",
            "    def test_serialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, (1, 2))",
            "        self.assertEqual(result, {'node.appstruct': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, (1, 2), listitem=True)",
            "        self.assertEqual(result, {'appstruct': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            ['node', 'node.a', 'node.b'],",
            "            {'node': (1, 2), 'node.a': 1, 'node.b': 2},",
            "        )",
            "        self.assertEqual(result, (1, 2))",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(typ, name='foo'),",
            "            DummySchemaNode(typ, name='bar'),",
            "        ]",
            "        node['foo'].children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b'),",
            "        ]",
            "        node['bar'].children = [",
            "            DummySchemaNode(None, name='c'),",
            "            DummySchemaNode(None, name='d'),",
            "        ]",
            "        appstruct = ((1, 2), (3, 4))",
            "        result = typ.set_value(node, appstruct, 'bar.c', 34)",
            "        self.assertEqual(result, ((1, 2), (34, 4)))",
            "",
            "    def test_set_value_bad_path(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(None, name='foo'),",
            "            DummySchemaNode(None, name='bar'),",
            "        ]",
            "        self.assertRaises(KeyError, typ.set_value, node, (1, 2), 'foobar', 34)",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(typ, name='foo'),",
            "            DummySchemaNode(typ, name='bar'),",
            "        ]",
            "        node['foo'].children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b'),",
            "        ]",
            "        node['bar'].children = [",
            "            DummySchemaNode(None, name='c'),",
            "            DummySchemaNode(None, name='d'),",
            "        ]",
            "        appstruct = ((1, 2), (3, 4))",
            "        self.assertEqual(typ.get_value(node, appstruct, 'foo'), (1, 2))",
            "        self.assertEqual(typ.get_value(node, appstruct, 'foo.b'), 2)",
            "",
            "    def test_get_value_bad_path(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(None, name='foo'),",
            "            DummySchemaNode(None, name='bar'),",
            "        ]",
            "        self.assertRaises(KeyError, typ.get_value, node, (1, 2), 'foobar')",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        result = typ.cstruct_children(node1, null)",
            "        self.assertEqual(result, [null])",
            "",
            "    def test_cstruct_children_toomany(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one', 'two', 'three'])",
            "        self.assertEqual(result, ['one', 'two'])",
            "",
            "    def test_cstruct_children_toofew(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one'])",
            "        self.assertEqual(result, ['one', null])",
            "",
            "    def test_cstruct_children_justright(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one', 'two'])",
            "        self.assertEqual(result, ['one', 'two'])",
            "",
            "",
            "class TestSet(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Set",
            "",
            "        return Set(**kw)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        provided = []",
            "        result = typ.serialize(node, provided)",
            "        self.assertTrue(result is provided)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.serialize(node, null)",
            "        self.assertTrue(result is null)",
            "",
            "    def test_deserialize_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, 1)",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_str_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, \"foo\")",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_deserialize_valid(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, set(('a',)))",
            "",
            "    def test_deserialize_empty_set(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, set())",
            "        self.assertEqual(result, set())",
            "",
            "",
            "class TestList(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import List",
            "",
            "        return List(**kw)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        provided = []",
            "        result = typ.serialize(node, provided)",
            "        self.assertTrue(result is provided)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.serialize(node, null)",
            "        self.assertTrue(result is null)",
            "",
            "    def test_deserialize_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, 1)",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_str_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, \"foo\")",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_deserialize_valid(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ('a', 'z', 'b'))",
            "        self.assertEqual(result, ['a', 'z', 'b'])",
            "",
            "    def test_deserialize_empty_set(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "",
            "class TestSequence(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Sequence",
            "",
            "        return Sequence(**kw)",
            "",
            "    def test_alias(self):",
            "        from colander import Seq",
            "        from colander import Sequence",
            "",
            "        self.assertEqual(Seq, Sequence)",
            "",
            "    def test_deserialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_deserialize_not_iterable_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, None)",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_deserialize_string_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, 'abc')",
            "        self.assertEqual(result, ['abc'])",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "    def test_deserialize_no_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(None, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, ['a'])",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None, exc='Wrong')",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.deserialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_drop(self):",
            "        from colander import drop",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, (drop,))",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_serialize_not_iterable_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_serialize_string_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.serialize(node, 'abc')",
            "        self.assertEqual(result, ['abc'])",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [node]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ('a',))",
            "        self.assertEqual(result, ['a'])",
            "",
            "    def test_serialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None, exc='Wrong')",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.serialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2])",
            "        self.assertEqual(result, {'node.0': 1, 'node.1': 2})",
            "",
            "    def test_flatten_with_integer(self):",
            "        from colander import Integer",
            "",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(Integer(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2])",
            "        self.assertEqual(result, {'node.0': 1, 'node.1': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2], listitem=True)",
            "        self.assertEqual(result, {'0': 1, '1': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node, ['node.0', 'node.1'], {'node.0': 'a', 'node.1': 'b'}",
            "        )",
            "        self.assertEqual(result, ['a', 'b'])",
            "",
            "    def test_setvalue(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='seq1')",
            "        node2 = DummySchemaNode(typ, name='seq2')",
            "        node1.children = [node2]",
            "        node2.children = DummySchemaNode(None, name='items')",
            "        appstruct = [[1, 2], [3, 4]]",
            "        typ.set_value(node1, appstruct, '1.0', 34)",
            "        self.assertEqual(appstruct, [[1, 2], [34, 4]])",
            "",
            "    def test_getvalue(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='seq1')",
            "        node2 = DummySchemaNode(typ, name='seq2')",
            "        node1.children = [node2]",
            "        node2.children = DummySchemaNode(None, name='items')",
            "        appstruct = [[1, 2], [3, 4]]",
            "        self.assertEqual(typ.get_value(node1, appstruct, '1'), [3, 4])",
            "        self.assertEqual(typ.get_value(node1, appstruct, '1.0'), 3)",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "        from colander import SequenceItems",
            "",
            "        typ = self._makeOne()",
            "        result = typ.cstruct_children(None, null)",
            "        self.assertEqual(result, SequenceItems([]))",
            "",
            "    def test_cstruct_children_cstruct_is_non_null(self):",
            "        from colander import SequenceItems",
            "",
            "        typ = self._makeOne()",
            "        result = typ.cstruct_children(None, ['a'])",
            "        self.assertEqual(result, SequenceItems(['a']))",
            "",
            "",
            "class TestString(unittest.TestCase):",
            "    def _makeOne(self, encoding=None, allow_empty=False):",
            "        from colander import String",
            "",
            "        return String(encoding, allow_empty)",
            "",
            "    def test_alias(self):",
            "        from colander import Str",
            "        from colander import String",
            "",
            "        self.assertEqual(Str, String)",
            "",
            "    def test_deserialize_emptystring(self):",
            "        from colander import null",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(None)",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, null)",
            "        typ = self._makeOne(None, allow_empty=True)",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, '')",
            "",
            "    def test_deserialize_uncooperative(self):",
            "        val = Uncooperative()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_unicode_from_None(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', 'utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, uni)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_nonunicode_from_None(self):",
            "        import colander",
            "",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, value)",
            "",
            "    def test_deserialize_from_utf8(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf8 = uni.encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.deserialize(node, utf8)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_from_utf16(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf16 = uni.encode('utf-16')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-16')",
            "        result = typ.deserialize(node, utf16)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_from_nonstring_obj(self):",
            "        import colander",
            "",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, value)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_serialize_emptystring(self):",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, val)",
            "",
            "    def test_serialize_uncooperative(self):",
            "        val = Uncooperative()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_nonunicode_to_None(self):",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, value)",
            "        self.assertEqual(result, text_type(value))",
            "",
            "    def test_serialize_unicode_to_None(self):",
            "        value = text_('abc')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, value)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_serialize_to_utf8(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf8 = uni.encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.serialize(node, uni)",
            "        self.assertEqual(result, utf8)",
            "",
            "    def test_serialize_to_utf16(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf16 = uni.encode('utf-16')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-16')",
            "        result = typ.serialize(node, uni)",
            "        self.assertEqual(result, utf16)",
            "",
            "    def test_serialize_string_with_high_unresolveable_high_order_chars(self):",
            "        not_utf8 = b'\\xff\\xfe\\xf8\\x00'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        e = invalid_exc(typ.serialize, node, not_utf8)",
            "        self.assertTrue('cannot be serialized' in e.msg)",
            "",
            "    def test_serialize_encoding_with_non_string_type(self):",
            "        utf8 = text_type('123').encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.serialize(node, 123)",
            "        self.assertEqual(result, utf8)",
            "",
            "",
            "class TestInteger(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Integer",
            "",
            "        return Integer()",
            "",
            "    def test_alias(self):",
            "        from colander import Int",
            "        from colander import Integer",
            "",
            "        self.assertEqual(Int, Integer)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        val = '1'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0')",
            "",
            "",
            "class TestFloat(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Float",
            "",
            "        return Float()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.0')",
            "",
            "    def test_serialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        val = '1.0'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, 1.0)",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1.0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.0')",
            "",
            "",
            "class TestDecimal(unittest.TestCase):",
            "    def _makeOne(self, quant=None, rounding=None, normalize=False):",
            "        from colander import Decimal",
            "",
            "        return Decimal(quant, rounding, normalize)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0')",
            "",
            "    def test_serialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.serialize, node, val)",
            "",
            "    def test_serialize_quantize_no_rounding(self):",
            "        val = '.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01')",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.00')",
            "",
            "    def test_serialize_quantize_with_rounding_up(self):",
            "        import decimal",
            "",
            "        val = '.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01', decimal.ROUND_UP)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.01')",
            "",
            "    def test_serialize_normalize(self):",
            "        from decimal import Decimal",
            "",
            "        val = Decimal('1.00')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(normalize=True)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        import decimal",
            "",
            "        val = '1.0'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.0'))",
            "",
            "    def test_deserialize_with_quantize(self):",
            "        import decimal",
            "",
            "        val = '1.00000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01', decimal.ROUND_UP)",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.01'))",
            "",
            "    def test_deserialize_with_normalize(self):",
            "        from decimal import Decimal",
            "",
            "        val = '1.00'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(normalize=True)",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, Decimal('1'))",
            "        self.assertEqual(str(result), '1')",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1.0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.0')",
            "",
            "",
            "class TestMoney(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Money",
            "",
            "        return Money()",
            "",
            "    def test_serialize_rounds_up(self):",
            "        val = '1.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.01')",
            "",
            "    def test_deserialize_rounds_up(self):",
            "        import decimal",
            "",
            "        val = '1.00000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.01'))",
            "",
            "",
            "class TestBoolean(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean()",
            "",
            "    def test_alias(self):",
            "        from colander import Bool",
            "        from colander import Boolean",
            "",
            "        self.assertEqual(Bool, Boolean)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'false'), False)",
            "        self.assertEqual(typ.deserialize(node, 'FALSE'), False)",
            "        self.assertEqual(typ.deserialize(node, '0'), False)",
            "        self.assertEqual(typ.deserialize(node, 'true'), True)",
            "        self.assertEqual(typ.deserialize(node, 'other'), True)",
            "",
            "    def test_deserialize_unstringable(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.deserialize, node, Uncooperative())",
            "        self.assertTrue(e.msg.endswith('not a string'))",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.serialize(node, 1), 'true')",
            "        self.assertEqual(typ.serialize(node, True), 'true')",
            "        self.assertEqual(typ.serialize(node, None), 'false')",
            "        self.assertEqual(typ.serialize(node, False), 'false')",
            "",
            "",
            "class TestBooleanCustomFalseReprs(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_choices=('n', 'f'))",
            "",
            "    def test_deserialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'f'), False)",
            "        self.assertEqual(typ.deserialize(node, 'N'), False)",
            "        self.assertEqual(typ.deserialize(node, 'other'), True)",
            "",
            "",
            "class TestBooleanCustomFalseAndTrueReprs(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_choices=('n', 'f'), true_choices=('y', 't'))",
            "",
            "    def test_deserialize(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'f'), False)",
            "        self.assertEqual(typ.deserialize(node, 'N'), False)",
            "        self.assertEqual(typ.deserialize(node, 'T'), True)",
            "        self.assertEqual(typ.deserialize(node, 'y'), True)",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, 'other')",
            "        try:",
            "            typ.deserialize(node, 'other')",
            "        except colander.Invalid as exc:",
            "            self.assertEqual(exc.msg.mapping['false_choices'], \"'n', 'f'\")",
            "            self.assertEqual(exc.msg.mapping['true_choices'], \"'y', 't'\")",
            "",
            "",
            "class TestBooleanCustomSerializations(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_val='no', true_val='yes')",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.serialize(node, 1), 'yes')",
            "        self.assertEqual(typ.serialize(node, True), 'yes')",
            "        self.assertEqual(typ.serialize(node, None), 'no')",
            "        self.assertEqual(typ.serialize(node, False), 'no')",
            "",
            "",
            "class TestGlobalObject(unittest.TestCase):",
            "    def _makeOne(self, package=None):",
            "        from colander import GlobalObject",
            "",
            "        return GlobalObject(package)",
            "",
            "    def test_zope_dottedname_style_resolve_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._zope_dottedname_style(",
            "            None, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_zope_dottedname_style_irrresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError,",
            "            typ._zope_dottedname_style,",
            "            None,",
            "            'colander.tests.nonexisting',",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolve_relative(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        node = DummySchemaNode(None)",
            "        result = typ._zope_dottedname_style(",
            "            node, '.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__zope_dottedname_style_resolve_relative_leading_dots(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        node = DummySchemaNode(None)",
            "        result = typ._zope_dottedname_style(",
            "            node, '..tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__zope_dottedname_style_resolve_relative_is_dot(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._zope_dottedname_style(None, '.')",
            "        self.assertEqual(result, colander.tests)",
            "",
            "    def test__zope_dottedname_style_irresolveable_relative_is_dot(self):",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ._zope_dottedname_style, None, '.')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'relative name \".\" irresolveable without package',",
            "        )",
            "",
            "    def test_zope_dottedname_style_resolve_relative_nocurrentpackage(self):",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ._zope_dottedname_style, None, '.whatever')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'relative name \".whatever\" irresolveable without package',",
            "        )",
            "",
            "    def test_zope_dottedname_style_irrresolveable_relative(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander)",
            "        self.assertRaises(",
            "            ImportError, typ._zope_dottedname_style, None, '.notexisting'",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolveable_relative(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        result = typ._zope_dottedname_style(None, '.tests')",
            "        from colander import tests",
            "",
            "        self.assertEqual(result, tests)",
            "",
            "    def test__zope_dottedname_style_irresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError, typ._zope_dottedname_style, None, 'colander.fudge.bar'",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._zope_dottedname_style(",
            "            None, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_resolve_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._pkg_resources_style(",
            "            None, 'colander.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_irrresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError,",
            "            typ._pkg_resources_style,",
            "            None,",
            "            'colander.tests.test_colander:nonexisting',",
            "        )",
            "",
            "    def test__pkg_resources_style_resolve_relative_startswith_colon(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._pkg_resources_style(None, ':fixture')",
            "        self.assertEqual(result, 1)",
            "",
            "    def test__pkg_resources_style_resolve_relative_startswith_dot(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        result = typ._pkg_resources_style(",
            "            None, '.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_resolve_relative_is_dot(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._pkg_resources_style(None, '.')",
            "        self.assertEqual(result, colander.tests)",
            "",
            "    def test__pkg_resources_style_resolve_relative_nocurrentpackage(self):",
            "        typ = self._makeOne()",
            "        import colander",
            "",
            "        self.assertRaises(",
            "            colander.Invalid, typ._pkg_resources_style, None, '.whatever'",
            "        )",
            "",
            "    def test__pkg_resources_style_irrresolveable_relative(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander)",
            "        self.assertRaises(",
            "            ImportError, typ._pkg_resources_style, None, ':notexisting'",
            "        )",
            "",
            "    def test_deserialize_None(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_notastring(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, True)",
            "",
            "    def test_deserialize_using_pkgresources_style(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(",
            "            node, 'colander.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_using_zope_dottedname_style(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(",
            "            node, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_style_raises(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.deserialize, node, 'cant.be.found')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'The dotted name \"cant.be.found\" cannot be imported',",
            "        )",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_ok(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, colander.tests)",
            "        self.assertEqual(result, 'colander.tests')",
            "",
            "        from colander import tests",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, tests)",
            "        self.assertEqual(result, 'colander.tests')",
            "",
            "    def test_serialize_class(self):",
            "        cls = self.__class__",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, cls)",
            "        self.assertEqual(",
            "            result, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "",
            "    def test_deserialize_class_ok(self):",
            "        import colander",
            "",
            "        names = (",
            "            'colander.tests.test_colander.TestGlobalObject',",
            "            '.tests.test_colander.TestGlobalObject',",
            "        )",
            "        typ = self._makeOne(colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            result = typ.deserialize(node, name)",
            "            self.assertEqual(result, self.__class__)",
            "",
            "        names = ('.TestGlobalObject',)",
            "        typ = self._makeOne(colander.tests.test_colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            result = typ.deserialize(node, name)",
            "            self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_class_fail(self):",
            "        import colander",
            "",
            "        names = ('.test_colander.TestGlobalObject', '.TestGlobalObject')",
            "        typ = self._makeOne(colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            e = invalid_exc(typ.deserialize, node, name)",
            "            self.assertEqual(",
            "                e.msg.interpolate(),",
            "                'The dotted name \"{0}\" cannot be imported'.format(name),",
            "            )",
            "",
            "    def test_serialize_fail(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" has no __name__')",
            "",
            "",
            "class TestDateTime(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import DateTime",
            "",
            "        return DateTime(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48)",
            "",
            "    def _today(self):",
            "        import datetime",
            "",
            "        return datetime.date.today()",
            "",
            "    def test_ctor_default_tzinfo_not_specified(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        self.assertIs(typ.default_tzinfo, iso8601.UTC)",
            "",
            "    def test_ctor_default_tzinfo_None(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        self.assertEqual(typ.default_tzinfo, None)",
            "",
            "    def test_ctor_default_tzinfo_non_None(self):",
            "        from iso8601 import iso8601",
            "",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        typ = self._makeOne(default_tzinfo=tzinfo)",
            "        self.assertEqual(typ.default_tzinfo, tzinfo)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(",
            "            e.msg.interpolate(), '\"garbage\" is not a datetime object'",
            "        )",
            "",
            "    def test_serialize_with_date(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        expected = datetime.datetime.combine(date, datetime.time())",
            "        expected = expected.replace(tzinfo=typ.default_tzinfo).isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_naive_datetime(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.replace(tzinfo=typ.default_tzinfo).isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_naive_datetime_and_custom_format(self):",
            "        fmt = '%Y%m%d!%H%M%S'",
            "        typ = self._makeOne(format=fmt)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.replace(tzinfo=typ.default_tzinfo).strftime(fmt)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_none_tzinfo_naive_datetime(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        self.assertEqual(result, dt.isoformat())",
            "",
            "    def test_serialize_with_none_tzinfo_naive_datetime_custom_format(self):",
            "        fmt = '%Y%m%d!%H%M%S'",
            "        typ = self._makeOne(default_tzinfo=None, format=fmt)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        self.assertEqual(result, dt.strftime(fmt))",
            "",
            "    def test_serialize_with_tzware_datetime(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_date(self):",
            "        import datetime",
            "        from iso8601 import iso8601",
            "",
            "        date = self._today()",
            "        typ = self._makeOne()",
            "        formatted = date.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, formatted)",
            "        expected = datetime.datetime.combine(result, datetime.time())",
            "        expected = expected.replace(tzinfo=iso8601.UTC)",
            "        self.assertEqual(result.isoformat(), expected.isoformat())",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_slashes_invalid(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, '2013/05/31')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_success(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), iso)",
            "",
            "    def test_deserialize_datetime_with_custom_format(self):",
            "        from iso8601 import iso8601",
            "",
            "        fmt = '%Y%m%d.%H%M%S'",
            "        typ = self._makeOne(format=fmt)",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        expected = dt.strftime(fmt)",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, expected)",
            "        self.assertEqual(result.strftime(fmt), expected)",
            "",
            "    def test_deserialize_naive_with_default_tzinfo(self):",
            "        from iso8601 import iso8601",
            "",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        typ = self._makeOne(default_tzinfo=tzinfo)",
            "        dt = self._dt()",
            "        dt_with_tz = dt.replace(tzinfo=tzinfo)",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt_with_tz.isoformat())",
            "",
            "    def test_deserialize_none_tzinfo(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        dt = self._dt()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.isoformat())",
            "        self.assertEqual(result.tzinfo, None)",
            "",
            "",
            "class TestDate(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Date",
            "",
            "        return Date(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48)",
            "",
            "    def _today(self):",
            "        import datetime",
            "",
            "        return datetime.date.today()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(e.msg.interpolate(), '\"garbage\" is not a date object')",
            "",
            "    def test_serialize_with_date(self):",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        expected = date.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_datetime(self):",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.date().isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_invalid_weird(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, '10-10-10-10')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_success_date(self):",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        iso = date.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), iso)",
            "",
            "    def test_deserialize_success_datetime(self):",
            "        dt = self._dt()",
            "        typ = self._makeOne()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.date().isoformat())",
            "",
            "    def test_serialize_date_with_custom_format(self):",
            "        fmt = '%m,%Y,%d'",
            "        typ = self._makeOne(format=fmt)",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        self.assertEqual(result, date.strftime(fmt))",
            "",
            "    def test_deserialize_date_with_custom_format(self):",
            "        date = self._today()",
            "        fmt = '%d/%m/%Y'",
            "        typ = self._makeOne(format=fmt)",
            "        formatted = date.strftime(fmt)",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, formatted)",
            "        self.assertEqual(result, date)",
            "",
            "",
            "class TestTime(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Time",
            "",
            "        return Time(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48, 0, 424242)",
            "",
            "    def _now(self):",
            "        import datetime",
            "",
            "        return datetime.datetime.now().time()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(e.msg.interpolate(), '\"garbage\" is not a time object')",
            "",
            "    def test_serialize_with_time(self):",
            "        typ = self._makeOne()",
            "        time = self._now()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, time)",
            "        expected = time.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_zero_time(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        time = datetime.time(0)",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, time)",
            "        expected = time.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_datetime(self):",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.time().isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_three_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00:11')",
            "        self.assertEqual(result, datetime.time(11, 0, 11))",
            "",
            "    def test_deserialize_four_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00:11.424242')",
            "        self.assertEqual(result, datetime.time(11, 0, 11, 424242))",
            "",
            "    def test_deserialize_two_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00')",
            "        self.assertEqual(result, datetime.time(11, 0))",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_missing_seconds(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, '10:12')",
            "        self.assertEqual(result, datetime.time(10, 12))",
            "",
            "    def test_deserialize_success_time(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, '10:12:13')",
            "        self.assertEqual(result, datetime.time(10, 12, 13))",
            "",
            "    def test_deserialize_success_datetime(self):",
            "        dt = self._dt()",
            "        typ = self._makeOne()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.time().isoformat())",
            "",
            "",
            "class TestEnum(unittest.TestCase):",
            "    def _makeOne(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 0",
            "            green = 1",
            "            blue = 2",
            "",
            "        typ = colander.Enum(DummyEnum)",
            "        return DummyEnum, typ",
            "",
            "    def _makeOneIntVal(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 0",
            "            green = 1",
            "            blue = 2",
            "",
            "        typ = colander.Enum(DummyEnum, attr='value', typ=colander.Integer())",
            "        return DummyEnum, typ",
            "",
            "    def _makeOneStrVal(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 'RED'",
            "            green = 'GREEN'",
            "            blue = 'BLUE'",
            "",
            "        typ = colander.Enum(DummyEnum, attr='value', typ=colander.String())",
            "        return DummyEnum, typ",
            "",
            "    def test_non_unique_failure(self):",
            "        import colander",
            "        import enum",
            "",
            "        class NonUniqueEnum(enum.Enum):",
            "            one = 1",
            "            other = 1",
            "",
            "        self.assertRaises(",
            "            ValueError,",
            "            colander.Enum,",
            "            NonUniqueEnum,",
            "            attr='value',",
            "            typ=colander.Integer(),",
            "        )",
            "",
            "    def test_non_unique_failure2(self):",
            "        import colander",
            "        import enum",
            "",
            "        class NonUniqueEnum(enum.Enum):",
            "            some = (1, 1)",
            "            other = (1, 2)",
            "",
            "            def __init__(self, val0, val1):",
            "                self.val0 = val0",
            "                self.val1 = val1",
            "",
            "        self.assertRaises(",
            "            ValueError,",
            "            colander.Enum,",
            "            NonUniqueEnum,",
            "            attr='val0',",
            "            typ=colander.Integer(),",
            "        )",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        e, typ = self._makeOne()",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertIs(result, colander.null)",
            "",
            "    def test_serialize_name(self):",
            "        e, typ = self._makeOne()",
            "        val = e.red",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, 'red')",
            "",
            "    def test_serialize_value_int(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = e.green",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_serialize_value_str(self):",
            "        e, typ = self._makeOneStrVal()",
            "        val = e.blue",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, 'BLUE')",
            "",
            "    def test_serialize_failure(self):",
            "        e, typ = self._makeOne()",
            "        val = 'not a enum'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.serialize, node, val)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        e, typ = self._makeOne()",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, colander.null)",
            "",
            "    def test_deserialize_name(self):",
            "        e, typ = self._makeOne()",
            "        val = 'green'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.green)",
            "",
            "    def test_deserialize_value_int(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = '2'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.blue)",
            "",
            "    def test_deserialize_value_str(self):",
            "        e, typ = self._makeOneStrVal()",
            "        val = 'BLUE'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.blue)",
            "",
            "    def test_deserialize_failure(self):",
            "        e, typ = self._makeOne()",
            "        val = 'not a enum'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.deserialize, node, val)",
            "",
            "    def test_deserialize_failure_typ(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = 'not a int'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.deserialize, node, val)",
            "",
            "",
            "class TestSchemaNode(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import SchemaNode",
            "",
            "        return SchemaNode(*arg, **kw)",
            "",
            "    def test_new_sets_order(self):",
            "        node = self._makeOne(None)",
            "        self.assertTrue(hasattr(node, '_order'))",
            "",
            "    def test_ctor_no_title(self):",
            "        child = DummySchemaNode(None, name='fred')",
            "        node = self._makeOne(",
            "            None,",
            "            child,",
            "            validator=1,",
            "            default=2,",
            "            name='name_a',",
            "            missing='missing',",
            "        )",
            "        self.assertEqual(node.typ, None)",
            "        self.assertEqual(node.children, [child])",
            "        self.assertEqual(node.validator, 1)",
            "        self.assertEqual(node.default, 2)",
            "        self.assertEqual(node.missing, 'missing')",
            "        self.assertEqual(node.name, 'name_a')",
            "        self.assertEqual(node.title, 'Name A')",
            "",
            "    def test_ctor_with_title(self):",
            "        child = DummySchemaNode(None, name='fred')",
            "        node = self._makeOne(",
            "            None, child, validator=1, default=2, name='name', title='title'",
            "        )",
            "        self.assertEqual(node.typ, None)",
            "        self.assertEqual(node.children, [child])",
            "        self.assertEqual(node.validator, 1)",
            "        self.assertEqual(node.default, 2)",
            "        self.assertEqual(node.name, 'name')",
            "        self.assertEqual(node.title, 'title')",
            "",
            "    def test_ctor_with_description(self):",
            "        node = self._makeOne(",
            "            None,",
            "            validator=1,",
            "            default=2,",
            "            name='name',",
            "            title='title',",
            "            description='desc',",
            "        )",
            "        self.assertEqual(node.description, 'desc')",
            "",
            "    def test_ctor_with_widget(self):",
            "        node = self._makeOne(None, widget='abc')",
            "        self.assertEqual(node.widget, 'abc')",
            "",
            "    def test_ctor_with_preparer(self):",
            "        node = self._makeOne(None, preparer='abc')",
            "        self.assertEqual(node.preparer, 'abc')",
            "",
            "    def test_ctor_without_preparer(self):",
            "        node = self._makeOne(None)",
            "        self.assertEqual(node.preparer, None)",
            "",
            "    def test_ctor_with_unknown_kwarg(self):",
            "        node = self._makeOne(None, foo=1)",
            "        self.assertEqual(node.foo, 1)",
            "",
            "    def test_ctor_with_kwarg_typ(self):",
            "        node = self._makeOne(typ='foo')",
            "        self.assertEqual(node.typ, 'foo')",
            "",
            "    def test_ctor_children_kwarg_typ(self):",
            "        subnode1 = DummySchemaNode(None, name='sub1')",
            "        subnode2 = DummySchemaNode(None, name='sub2')",
            "        node = self._makeOne(subnode1, subnode2, typ='foo')",
            "        self.assertEqual(node.children, [subnode1, subnode2])",
            "",
            "    def test_ctor_without_type(self):",
            "        self.assertRaises(NotImplementedError, self._makeOne)",
            "",
            "    def test_required_true(self):",
            "        node = self._makeOne(None)",
            "        self.assertEqual(node.required, True)",
            "",
            "    def test_required_false(self):",
            "        node = self._makeOne(None, missing=1)",
            "        self.assertEqual(node.required, False)",
            "",
            "    def test_required_deferred(self):",
            "        from colander import deferred",
            "",
            "        node = self._makeOne(None, missing=deferred(lambda: '123'))",
            "        self.assertEqual(node.required, True)",
            "",
            "    def test_deserialize_no_validator(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.deserialize(1)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_deserialize_with_preparer(self):",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer(value):",
            "            return 'prepared_' + value",
            "",
            "        def validator(node, value):",
            "            if not value.startswith('prepared'):",
            "                raise Invalid(node, 'not prepared')  # pragma: no cover",
            "",
            "        node = self._makeOne(typ, preparer=preparer, validator=validator)",
            "        self.assertEqual(node.deserialize('value'), 'prepared_value')",
            "",
            "    def test_deserialize_with_multiple_preparers(self):",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer1(value):",
            "            return 'prepared1_' + value",
            "",
            "        def preparer2(value):",
            "            return 'prepared2_' + value",
            "",
            "        def validator(node, value):",
            "            if not value.startswith('prepared2_prepared1'):",
            "                raise Invalid(node, 'not prepared')  # pragma: no cover",
            "",
            "        node = self._makeOne(",
            "            typ, preparer=[preparer1, preparer2], validator=validator",
            "        )",
            "        self.assertEqual(",
            "            node.deserialize('value'), 'prepared2_prepared1_value'",
            "        )",
            "",
            "    def test_deserialize_preparer_before_missing_check(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer(value):",
            "            return null",
            "",
            "        node = self._makeOne(typ, preparer=preparer)",
            "        e = invalid_exc(node.deserialize, 1)",
            "        self.assertEqual(e.msg, 'Required')",
            "",
            "    def test_deserialize_with_validator(self):",
            "        typ = DummyType()",
            "        validator = DummyValidator(msg='Wrong')",
            "        node = self._makeOne(typ, validator=validator)",
            "        e = invalid_exc(node.deserialize, 1)",
            "        self.assertEqual(e.msg, 'Wrong')",
            "",
            "    def test_deserialize_with_unbound_validator(self):",
            "        from colander import Invalid",
            "        from colander import deferred",
            "        from colander import UnboundDeferredError",
            "",
            "        typ = DummyType()",
            "",
            "        def validator(node, kw):",
            "            def _validate(node, value):",
            "                node.raise_invalid('Invalid')",
            "",
            "            return _validate",
            "",
            "        node = self._makeOne(typ, validator=deferred(validator))",
            "        self.assertRaises(UnboundDeferredError, node.deserialize, None)",
            "        self.assertRaises(Invalid, node.bind(foo='foo').deserialize, None)",
            "",
            "    def test_deserialize_value_is_null_no_missing(self):",
            "        from colander import null",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        self.assertRaises(Invalid, node.deserialize, null)",
            "",
            "    def test_deserialize_value_is_null_with_missing(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = 'abc'",
            "        self.assertEqual(node.deserialize(null), 'abc')",
            "",
            "    def test_deserialize_value_is_null_with_missing_msg(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ, missing_msg='Missing')",
            "        e = invalid_exc(node.deserialize, null)",
            "        self.assertEqual(e.msg, 'Missing')",
            "",
            "    def test_deserialize_value_with_interpolated_missing_msg(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(",
            "            typ, missing_msg='Missing attribute ${title}', name='name_a'",
            "        )",
            "        e = invalid_exc(node.deserialize, null)",
            "        self.assertEqual(e.msg.interpolate(), 'Missing attribute Name A')",
            "",
            "    def test_deserialize_noargs_uses_default(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = 'abc'",
            "        self.assertEqual(node.deserialize(), 'abc')",
            "",
            "    def test_deserialize_null_can_be_used_as_missing(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = null",
            "        self.assertEqual(node.deserialize(null), null)",
            "",
            "    def test_deserialize_appstruct_deferred(self):",
            "        from colander import null",
            "        from colander import deferred",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = deferred(lambda: '123')",
            "        self.assertRaises(Invalid, node.deserialize, null)",
            "",
            "    def test_serialize(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.serialize(1)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_value_is_null_no_default(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.serialize(null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_serialize_value_is_null_with_default(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = 1",
            "        result = node.serialize(null)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_noargs_uses_default(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = 'abc'",
            "        self.assertEqual(node.serialize(), 'abc')",
            "",
            "    def test_serialize_default_deferred(self):",
            "        from colander import deferred",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = deferred(lambda: 'abc')",
            "        self.assertEqual(node.serialize(), null)",
            "",
            "    def test_add(self):",
            "        node = self._makeOne(None)",
            "        node.add(1)",
            "        self.assertEqual(node.children, [1])",
            "",
            "    def test_insert(self):",
            "        node = self._makeOne(None)",
            "        node.children = [99, 99]",
            "        node.insert(1, 'foo')",
            "        self.assertEqual(node.children, [99, 'foo', 99])",
            "",
            "    def test_repr(self):",
            "        node = self._makeOne(None, name='flub')",
            "        result = repr(node)",
            "        self.assertTrue(result.startswith('<colander.SchemaNode object at '))",
            "        self.assertTrue(result.endswith(\"(named flub)>\"))",
            "",
            "    def test___getitem__success(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        self.assertEqual(node['another'], another)",
            "",
            "    def test___getitem__failure(self):",
            "        node = self._makeOne(None)",
            "        self.assertRaises(KeyError, node.__getitem__, 'another')",
            "",
            "    def test___delitem__success(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        del node['another']",
            "        self.assertEqual(node.children, [])",
            "",
            "    def test___delitem__failure(self):",
            "        node = self._makeOne(None)",
            "        self.assertRaises(KeyError, node.__delitem__, 'another')",
            "",
            "    def test___setitem__override(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        andanother = self._makeOne(None, name='andanother')",
            "        node['another'] = andanother",
            "        self.assertEqual(node['another'], andanother)",
            "        self.assertEqual(andanother.name, 'another')",
            "",
            "    def test___setitem__no_override(self):",
            "        another = self._makeOne(None, name='another')",
            "        node = self._makeOne(None)",
            "        node['another'] = another",
            "        self.assertEqual(node['another'], another)",
            "        self.assertEqual(node.children[0], another)",
            "",
            "    def test___iter__(self):",
            "        node = self._makeOne(None)",
            "        node.children = ['a', 'b', 'c']",
            "        it = node.__iter__()",
            "        self.assertEqual(list(it), ['a', 'b', 'c'])",
            "",
            "    def test___contains__(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        self.assertEqual('another' in node, True)",
            "        self.assertEqual('b' in node, False)",
            "",
            "    def test_clone(self):",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "        outer_node = self._makeOne(outer_typ, name='outer')",
            "        inner_node = self._makeOne(inner_typ, name='inner')",
            "        outer_node.foo = 1",
            "        inner_node.foo = 2",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.clone()",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.typ, outer_typ)",
            "        self.assertEqual(outer_clone.name, 'outer')",
            "        self.assertEqual(outer_node.foo, 1)",
            "        self.assertEqual(len(outer_clone.children), 1)",
            "        inner_clone = outer_clone.children[0]",
            "        self.assertFalse(inner_clone is inner_node)",
            "        self.assertEqual(inner_clone.typ, inner_typ)",
            "        self.assertEqual(inner_clone.name, 'inner')",
            "        self.assertEqual(inner_clone.foo, 2)",
            "",
            "    def test_clone_with_modified_schema_instance(self):",
            "        import colander",
            "",
            "        class Schema(colander.MappingSchema):",
            "            n1 = colander.SchemaNode(colander.String())",
            "            n2 = colander.SchemaNode(colander.String())",
            "",
            "        def compare_children(schema, cloned):",
            "            # children of the clone must match the cloned node's children and",
            "            # have to be clones themselves.",
            "            self.assertEqual(len(schema.children), len(cloned.children))",
            "            for child, child_clone in zip(schema.children, cloned.children):",
            "                self.assertIsNot(child, child_clone)",
            "                for name in child.__dict__.keys():",
            "                    self.assertEqual(",
            "                        getattr(child, name), getattr(child_clone, name)",
            "                    )",
            "",
            "        # add a child node before cloning",
            "        schema = Schema()",
            "        schema.add(colander.SchemaNode(colander.String(), name='n3'))",
            "        compare_children(schema, schema.clone())",
            "        # remove a child node before cloning",
            "        schema = Schema()",
            "        del schema['n1']",
            "        compare_children(schema, schema.clone())",
            "        # reorder children before cloning",
            "        schema = Schema()",
            "        schema.children = list(reversed(schema.children))",
            "        compare_children(schema, schema.clone())",
            "",
            "    def test_clone_mapping_references(self):",
            "        import colander",
            "",
            "        class Schema(colander.MappingSchema):",
            "            n1 = colander.SchemaNode(colander.Mapping(unknown='preserve'))",
            "",
            "        foo = {\"n1\": {\"bar\": {\"baz\": \"qux\"}}}",
            "        bar = Schema().serialize(foo)",
            "        bar[\"n1\"][\"bar\"][\"baz\"] = \"foobar\"",
            "        self.assertEqual(foo[\"n1\"][\"bar\"][\"baz\"], \"qux\")",
            "",
            "    def test_bind(self):",
            "        from colander import deferred",
            "",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "",
            "        def dv(node, kw):",
            "            self.assertTrue(node.name in ['outer', 'inner'])",
            "            self.assertTrue('a' in kw)",
            "            return '123'",
            "",
            "        dv = deferred(dv)",
            "        outer_node = self._makeOne(outer_typ, name='outer', missing=dv)",
            "        inner_node = self._makeOne(",
            "            inner_typ, name='inner', validator=dv, missing=dv",
            "        )",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.bind(a=1)",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.missing, '123')",
            "        inner_clone = outer_clone.children[0]",
            "        self.assertFalse(inner_clone is inner_node)",
            "        self.assertEqual(inner_clone.missing, '123')",
            "        self.assertEqual(inner_clone.validator, '123')",
            "",
            "    def test_bind_with_after_bind(self):",
            "        from colander import deferred",
            "",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "",
            "        def dv(node, kw):",
            "            self.assertTrue(node.name in ['outer', 'inner'])",
            "            self.assertTrue('a' in kw)",
            "            return '123'",
            "",
            "        dv = deferred(dv)",
            "",
            "        def remove_inner(node, kw):",
            "            self.assertEqual(kw, {'a': 1})",
            "            del node['inner']",
            "",
            "        outer_node = self._makeOne(",
            "            outer_typ, name='outer', missing=dv, after_bind=remove_inner",
            "        )",
            "        inner_node = self._makeOne(",
            "            inner_typ, name='inner', validator=dv, missing=dv",
            "        )",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.bind(a=1)",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.missing, '123')",
            "        self.assertEqual(len(outer_clone.children), 0)",
            "        self.assertEqual(len(outer_node.children), 1)",
            "",
            "    def test_declarative_name_reassignment(self):",
            "        # see https://github.com/Pylons/colander/issues/39",
            "        import colander",
            "",
            "        class FnordSchema(colander.Schema):",
            "            fnord = colander.SchemaNode(",
            "                colander.Sequence(),",
            "                colander.SchemaNode(colander.Integer(), name=''),",
            "                name=\"fnord[]\",",
            "            )",
            "",
            "        schema = FnordSchema()",
            "        self.assertEqual(schema['fnord[]'].name, 'fnord[]')",
            "",
            "    def test_cstruct_children(self):",
            "        typ = DummyType()",
            "        typ.cstruct_children = lambda *arg: ['foo']",
            "        node = self._makeOne(typ)",
            "        self.assertEqual(node.cstruct_children(None), ['foo'])",
            "",
            "    def test_cstruct_children_warning(self):",
            "        import warnings",
            "",
            "        with warnings.catch_warnings(record=True) as w:",
            "            warnings.simplefilter('always')",
            "            typ = None",
            "            node = self._makeOne(typ)",
            "            self.assertEqual(node.cstruct_children(None), [])",
            "            self.assertEqual(len(w), 1)",
            "",
            "    def test_raise_invalid(self):",
            "        import colander",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        self.assertRaises(colander.Invalid, node.raise_invalid, 'Wrong')",
            "",
            "",
            "class TestSchemaNodeSubclassing(unittest.TestCase):",
            "    def test_subclass_uses_validator_method(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "",
            "            def validator(self, node, cstruct):",
            "                if cstruct > 10:",
            "                    self.raise_invalid('Wrong')",
            "",
            "        node = MyNode()",
            "        self.assertRaises(colander.Invalid, node.deserialize, 20)",
            "",
            "    def test_subclass_uses_missing(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "            missing = 10",
            "",
            "        node = MyNode()",
            "        result = node.deserialize(colander.null)",
            "        self.assertEqual(result, 10)",
            "",
            "    def test_subclass_uses_title(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            title = 'some title'",
            "",
            "        node = MyNode(name='my')",
            "        self.assertEqual(node.title, 'some title')",
            "",
            "    def test_subclass_title_overwritten_by_constructor(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            title = 'some title'",
            "",
            "        node = MyNode(name='my', title='other title')",
            "        self.assertEqual(node.title, 'other title')",
            "",
            "    def test_subelement_title_not_overwritten(self):",
            "        import colander",
            "",
            "        class SampleNode(colander.SchemaNode):",
            "            schema_type = colander.String",
            "            title = 'Some Title'",
            "",
            "        class SampleSchema(colander.Schema):",
            "            node = SampleNode()",
            "",
            "        schema = SampleSchema()",
            "        self.assertEqual('Some Title', schema.children[0].title)",
            "",
            "    def test_subclass_value_overridden_by_constructor(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "            missing = 10",
            "",
            "        node = MyNode(missing=5)",
            "        result = node.deserialize(colander.null)",
            "        self.assertEqual(result, 5)",
            "",
            "    def test_method_values_can_rely_on_binding(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            def amethod(self):",
            "                return self.bindings['request']",
            "",
            "        node = MyNode()",
            "        newnode = node.bind(request=True)",
            "        self.assertEqual(newnode.amethod(), True)",
            "",
            "    def test_nonmethod_values_can_rely_on_after_bind(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            def after_bind(self, node, kw):",
            "                self.missing = kw['missing']",
            "",
            "        node = MyNode()",
            "        newnode = node.bind(missing=10)",
            "        self.assertEqual(newnode.deserialize(colander.null), 10)",
            "",
            "    def test_deferred_methods_dont_quite_work_yet(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            @colander.deferred",
            "            def avalidator(self, node, kw):  # pragma: no cover",
            "                def _avalidator(node, cstruct):",
            "                    self.raise_invalid('Foo')",
            "",
            "                return _avalidator",
            "",
            "        node = MyNode()",
            "        self.assertRaises(TypeError, node.bind)",
            "",
            "    def test_nonmethod_values_can_be_deferred_though(self):",
            "        import colander",
            "",
            "        def _missing(node, kw):",
            "            return 10",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            missing = colander.deferred(_missing)",
            "",
            "        node = MyNode()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize(colander.null), 10)",
            "",
            "    def test_functions_can_be_deferred(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            @colander.deferred",
            "            def missing(node, kw):",
            "                return 10",
            "",
            "        node = MyNode()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize(colander.null), 10)",
            "",
            "    def test_nodes_can_be_deffered(self):",
            "        import colander",
            "",
            "        class MySchema(colander.MappingSchema):",
            "            @colander.deferred",
            "            def child(node, kw):",
            "                return colander.SchemaNode(colander.String(), missing='foo')",
            "",
            "        node = MySchema()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize({}), {'child': 'foo'})",
            "",
            "    def test_schema_child_names_conflict_with_value_names_notused(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            title = colander.SchemaNode(colander.String())",
            "",
            "        node = MyNode()",
            "        self.assertEqual(node.title, '')",
            "",
            "    def test_schema_child_names_conflict_with_value_names_used(self):",
            "        import colander",
            "",
            "        doesntmatter = colander.SchemaNode(colander.String(), name='name')",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            wontmatter = doesntmatter",
            "",
            "        node = MyNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'], doesntmatter)",
            "",
            "    def test_schema_child_names_conflict_with_value_names_in_superclass(self):",
            "        import colander",
            "",
            "        doesntmatter = colander.SchemaNode(colander.String(), name='name')",
            "        _name = colander.SchemaNode(colander.String())",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            wontmatter = doesntmatter",
            "",
            "        class AnotherNode(MyNode):",
            "            name = _name",
            "",
            "        node = AnotherNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'], _name)",
            "",
            "    def test_schema_child_names_conflict_with_value_names_in_subclass(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "",
            "        class AnotherNode(MyNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            doesntmatter = colander.SchemaNode(",
            "                colander.String(), name='name', id='doesntmatter'",
            "            )",
            "",
            "        node = AnotherNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'].id, 'doesntmatter')",
            "",
            "",
            "class TestMappingSchemaInheritance(unittest.TestCase):",
            "    def test_single_inheritance(self):",
            "        import colander",
            "",
            "        class Friend(colander.Schema):",
            "            rank = colander.SchemaNode(colander.Int(), id='rank')",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "            serial = colander.SchemaNode(colander.Bool(), id='serial2')",
            "",
            "        class SpecialFriend(Friend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.Int(), id='iwannacomefirst2'",
            "            )",
            "",
            "        class SuperSpecialFriend(SpecialFriend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.String(), id='iwannacomefirst1'",
            "            )",
            "            another = colander.SchemaNode(colander.String(), id='another')",
            "            serial = colander.SchemaNode(colander.Int(), id='serial1')",
            "",
            "        inst = SuperSpecialFriend()",
            "        self.assertEqual(",
            "            [x.id for x in inst.children],",
            "            ['rank', 'name', 'serial1', 'iwannacomefirst1', 'another'],",
            "        )",
            "",
            "    def test_single_inheritance_with_insert_before(self):",
            "        import colander",
            "",
            "        class Friend(colander.Schema):",
            "            rank = colander.SchemaNode(colander.Int(), id='rank')",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "            serial = colander.SchemaNode(",
            "                colander.Bool(), insert_before='name', id='serial2'",
            "            )",
            "",
            "        class SpecialFriend(Friend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.Int(), id='iwannacomefirst2'",
            "            )",
            "",
            "        class SuperSpecialFriend(SpecialFriend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.String(), insert_before='rank', id='iwannacomefirst1'",
            "            )",
            "            another = colander.SchemaNode(colander.String(), id='another')",
            "            serial = colander.SchemaNode(colander.Int(), id='serial1')",
            "",
            "        inst = SuperSpecialFriend()",
            "        self.assertEqual(",
            "            [x.id for x in inst.children],",
            "            ['iwannacomefirst1', 'rank', 'serial1', 'name', 'another'],",
            "        )",
            "",
            "    def test_single_inheritance2(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int(), id='a1')",
            "            b = colander.SchemaNode(colander.Int(), id='b1')",
            "            d = colander.SchemaNode(colander.Int(), id='d1')",
            "",
            "        class Two(One):",
            "            a = colander.SchemaNode(colander.String(), id='a2')",
            "            c = colander.SchemaNode(colander.String(), id='c2')",
            "            e = colander.SchemaNode(colander.String(), id='e2')",
            "",
            "        class Three(Two):",
            "            b = colander.SchemaNode(colander.Bool(), id='b3')",
            "            d = colander.SchemaNode(colander.Bool(), id='d3')",
            "            f = colander.SchemaNode(colander.Bool(), id='f3')",
            "",
            "        inst = Three()",
            "        c = inst.children",
            "        self.assertEqual(len(c), 6)",
            "        result = [x.id for x in c]",
            "        self.assertEqual(result, ['a2', 'b3', 'd3', 'c2', 'e2', 'f3'])",
            "",
            "    def test_multiple_inheritance(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int(), id='a1')",
            "            b = colander.SchemaNode(colander.Int(), id='b1')",
            "            d = colander.SchemaNode(colander.Int(), id='d1')",
            "",
            "        class Two(colander.Schema):",
            "            a = colander.SchemaNode(colander.String(), id='a2')",
            "            c = colander.SchemaNode(colander.String(), id='c2')",
            "            e = colander.SchemaNode(colander.String(), id='e2')",
            "",
            "        class Three(Two, One):",
            "            b = colander.SchemaNode(colander.Bool(), id='b3')",
            "            d = colander.SchemaNode(colander.Bool(), id='d3')",
            "            f = colander.SchemaNode(colander.Bool(), id='f3')",
            "",
            "        inst = Three()",
            "        c = inst.children",
            "        self.assertEqual(len(c), 6)",
            "        result = [x.id for x in c]",
            "        self.assertEqual(result, ['a2', 'b3', 'd3', 'c2', 'e2', 'f3'])",
            "",
            "    def test_insert_before_failure(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int())",
            "            b = colander.SchemaNode(colander.Int(), insert_before='c')",
            "",
            "        self.assertRaises(KeyError, One)",
            "",
            "",
            "class TestDeferred(unittest.TestCase):",
            "    def _makeOne(self, wrapped):",
            "        from colander import deferred",
            "",
            "        return deferred(wrapped)",
            "",
            "    def test_ctor(self):",
            "        wrapped = lambda: 'foo'",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.wrapped, wrapped)",
            "",
            "    def test___call__(self):",
            "        n = object()",
            "        k = object()",
            "",
            "        def wrapped(node, kw):",
            "            self.assertEqual(node, n)",
            "            self.assertEqual(kw, k)",
            "            return 'abc'",
            "",
            "        inst = self._makeOne(wrapped)",
            "        result = inst(n, k)",
            "        self.assertEqual(result, 'abc')",
            "",
            "    def test_retain_func_details(self):",
            "        def wrapped_func(node, kw):",
            "            \"\"\"Can you hear me now?\"\"\"",
            "            pass  # pragma: no cover",
            "",
            "        inst = self._makeOne(wrapped_func)",
            "        self.assertEqual(inst.__doc__, 'Can you hear me now?')",
            "        self.assertEqual(inst.__name__, 'wrapped_func')",
            "",
            "    def test_w_callable_instance_no_name(self):",
            "        class Wrapped(object):",
            "            \"\"\"CLASS\"\"\"",
            "",
            "            def __call__(self, node, kw):",
            "                \"\"\"METHOD\"\"\"",
            "                pass  # pragma: no cover",
            "",
            "        wrapped = Wrapped()",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.__doc__, wrapped.__doc__)",
            "        self.assertFalse('__name__' in inst.__dict__)",
            "",
            "    def test_w_callable_instance_no_name_or_doc(self):",
            "        class Wrapped(object):",
            "            def __call__(self, node, kw):",
            "                pass  # pragma: no cover",
            "",
            "        wrapped = Wrapped()",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.__doc__, None)",
            "        self.assertFalse('__name__' in inst.__dict__)",
            "",
            "",
            "class TestSchema(unittest.TestCase):",
            "    def test_alias(self):",
            "        from colander import Schema",
            "        from colander import MappingSchema",
            "",
            "        self.assertEqual(Schema, MappingSchema)",
            "",
            "    def test_it(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            thing_a = colander.SchemaNode(colander.String())",
            "            thing2 = colander.SchemaNode(colander.String(), title='bar')",
            "",
            "        node = MySchema(default='abc')",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertEqual(node.default, 'abc')",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Mapping)",
            "        self.assertEqual(node.children[0].typ.__class__, colander.String)",
            "        self.assertEqual(node.children[0].title, 'Thing A')",
            "        self.assertEqual(node.children[1].title, 'bar')",
            "",
            "    def test_title_munging(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            thing1 = colander.SchemaNode(colander.String())",
            "            thing2 = colander.SchemaNode(colander.String(), title=None)",
            "            thing3 = colander.SchemaNode(colander.String(), title='')",
            "            thing4 = colander.SchemaNode(colander.String(), title='thing2')",
            "",
            "        node = MySchema()",
            "        self.assertEqual(node.children[0].title, 'Thing1')",
            "        self.assertEqual(node.children[1].title, None)",
            "        self.assertEqual(node.children[2].title, '')",
            "        self.assertEqual(node.children[3].title, 'thing2')",
            "",
            "    def test_deserialize_drop(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            a = colander.SchemaNode(colander.String())",
            "            b = colander.SchemaNode(colander.String(), missing=colander.drop)",
            "",
            "        node = MySchema()",
            "        expected = {'a': 'test'}",
            "        result = node.deserialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_drop_default(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            a = colander.SchemaNode(colander.String())",
            "            b = colander.SchemaNode(colander.String(), default=colander.drop)",
            "",
            "        node = MySchema()",
            "        expected = {'a': 'foo'}",
            "        result = node.serialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.Schema(node)",
            "        self.assertEqual(schema.schema_type, colander.Mapping)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "    def test_schema_with_cloned_nodes(self):",
            "        import colander",
            "",
            "        test_node = colander.SchemaNode(colander.String())",
            "",
            "        class TestSchema(colander.Schema):",
            "            a = test_node.clone()",
            "            b = test_node.clone()",
            "",
            "        node = TestSchema()",
            "        expected = {'a': 'foo', 'b': 'bar'}",
            "        result = node.serialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "",
            "class TestSequenceSchema(unittest.TestCase):",
            "    def test_succeed(self):",
            "        import colander",
            "",
            "        _inner = colander.SchemaNode(colander.String())",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            inner = _inner",
            "",
            "        node = MySchema()",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Sequence)",
            "        self.assertEqual(node.children[0], _inner)",
            "",
            "    def test_fail_toomany(self):",
            "        import colander",
            "",
            "        thingnode = colander.SchemaNode(colander.String())",
            "        thingnode2 = colander.SchemaNode(colander.String())",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            thing = thingnode",
            "            thing2 = thingnode2",
            "",
            "        e = invalid_exc(MySchema)",
            "        self.assertEqual(",
            "            e.msg, 'Sequence schemas must have exactly one child node'",
            "        )",
            "",
            "    def test_fail_toofew(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            pass",
            "",
            "        e = invalid_exc(MySchema)",
            "        self.assertEqual(",
            "            e.msg, 'Sequence schemas must have exactly one child node'",
            "        )",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.SequenceSchema(node)",
            "        self.assertEqual(schema.schema_type, colander.Sequence)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "    def test_deserialize_drop(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            a = colander.SchemaNode(colander.String(), missing=colander.drop)",
            "",
            "        node = MySchema()",
            "        result = node.deserialize([None])",
            "        self.assertEqual(result, [])",
            "        result = node.deserialize([colander.null])",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_drop_default(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            a = colander.SchemaNode(colander.String(), default=colander.drop)",
            "",
            "        node = MySchema()",
            "        result = node.serialize([colander.null])",
            "        self.assertEqual(result, [])",
            "",
            "    def test_clone_with_sequence_schema(self):",
            "        import colander",
            "",
            "        thingnode = colander.SchemaNode(colander.String(), name='foo')",
            "        schema = colander.SequenceSchema(colander.Sequence(), thingnode)",
            "        clone = schema.clone()",
            "        self.assertIsNot(schema, clone)",
            "        self.assertEqual(schema.name, clone.name)",
            "        self.assertEqual(len(schema.children), len(clone.children))",
            "        self.assertIsNot(schema.children[0], clone.children[0])",
            "        self.assertEqual(schema.children[0].name, clone.children[0].name)",
            "",
            "",
            "class TestTupleSchema(unittest.TestCase):",
            "    def test_it(self):",
            "        import colander",
            "",
            "        class MySchema(colander.TupleSchema):",
            "            thing = colander.SchemaNode(colander.String())",
            "",
            "        node = MySchema()",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Tuple)",
            "        self.assertEqual(node.children[0].typ.__class__, colander.String)",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.TupleSchema(node)",
            "        self.assertEqual(schema.schema_type, colander.Tuple)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "",
            "class TestFunctional(object):",
            "    def test_deserialize_ok(self):",
            "        import colander.tests",
            "",
            "        data = {",
            "            'int': '10',",
            "            'ob': 'colander.tests',",
            "            'seq': [('1', 's'), ('2', 's'), ('3', 's'), ('4', 's')],",
            "            'seq2': [{'key': '1', 'key2': '2'}, {'key': '3', 'key2': '4'}],",
            "            'tup': ('1', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.deserialize(data)",
            "        self.assertEqual(result['int'], 10)",
            "        self.assertEqual(result['ob'], colander.tests)",
            "        self.assertEqual(",
            "            result['seq'], [(1, 's'), (2, 's'), (3, 's'), (4, 's')]",
            "        )",
            "        self.assertEqual(",
            "            result['seq2'], [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}]",
            "        )",
            "        self.assertEqual(result['tup'], (1, 's'))",
            "",
            "    def test_flatten_ok(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.flatten(appstruct)",
            "",
            "        expected = {",
            "            'schema.seq.2.tupstring': 's',",
            "            'schema.seq2.0.key2': 2,",
            "            'schema.ob': colander.tests,",
            "            'schema.seq2.1.key2': 4,",
            "            'schema.seq.1.tupstring': 's',",
            "            'schema.seq2.0.key': 1,",
            "            'schema.seq.1.tupint': 2,",
            "            'schema.seq.0.tupstring': 's',",
            "            'schema.seq.3.tupstring': 's',",
            "            'schema.seq.3.tupint': 4,",
            "            'schema.seq2.1.key': 3,",
            "            'schema.int': 10,",
            "            'schema.seq.0.tupint': 1,",
            "            'schema.tup.tupint': 1,",
            "            'schema.tup.tupstring': 's',",
            "            'schema.seq.2.tupint': 3,",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_flatten_mapping_has_no_name(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        result = schema.flatten(appstruct)",
            "",
            "        expected = {",
            "            'seq.2.tupstring': 's',",
            "            'seq2.0.key2': 2,",
            "            'ob': colander.tests,",
            "            'seq2.1.key2': 4,",
            "            'seq.1.tupstring': 's',",
            "            'seq2.0.key': 1,",
            "            'seq.1.tupint': 2,",
            "            'seq.0.tupstring': 's',",
            "            'seq.3.tupstring': 's',",
            "            'seq.3.tupint': 4,",
            "            'seq2.1.key': 3,",
            "            'int': 10,",
            "            'seq.0.tupint': 1,",
            "            'tup.tupint': 1,",
            "            'tup.tupstring': 's',",
            "            'seq.2.tupint': 3,",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_unflatten_ok(self):",
            "        import colander",
            "",
            "        fstruct = {",
            "            'schema.seq.2.tupstring': 's',",
            "            'schema.seq2.0.key2': 2,",
            "            'schema.ob': colander.tests,",
            "            'schema.seq2.1.key2': 4,",
            "            'schema.seq.1.tupstring': 's',",
            "            'schema.seq2.0.key': 1,",
            "            'schema.seq.1.tupint': 2,",
            "            'schema.seq.0.tupstring': 's',",
            "            'schema.seq.3.tupstring': 's',",
            "            'schema.seq.3.tupint': 4,",
            "            'schema.seq2.1.key': 3,",
            "            'schema.int': 10,",
            "            'schema.seq.0.tupint': 1,",
            "            'schema.tup.tupint': 1,",
            "            'schema.tup.tupstring': 's',",
            "            'schema.seq.2.tupint': 3,",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.unflatten(fstruct)",
            "",
            "        expected = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_unflatten_mapping_no_name(self):",
            "        import colander",
            "",
            "        fstruct = {",
            "            'seq.2.tupstring': 's',",
            "            'seq2.0.key2': 2,",
            "            'ob': colander.tests,",
            "            'seq2.1.key2': 4,",
            "            'seq.1.tupstring': 's',",
            "            'seq2.0.key': 1,",
            "            'seq.1.tupint': 2,",
            "            'seq.0.tupstring': 's',",
            "            'seq.3.tupstring': 's',",
            "            'seq.3.tupint': 4,",
            "            'seq2.1.key': 3,",
            "            'int': 10,",
            "            'seq.0.tupint': 1,",
            "            'tup.tupint': 1,",
            "            'tup.tupstring': 's',",
            "            'seq.2.tupint': 3,",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        result = schema.unflatten(fstruct)",
            "",
            "        expected = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_flatten_unflatten_roundtrip(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        self.assertEqual(",
            "            schema.unflatten(schema.flatten(appstruct)), appstruct",
            "        )",
            "",
            "    def test_set_value(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        schema.set_value(appstruct, 'seq2.1.key', 6)",
            "        self.assertEqual(appstruct['seq2'][1], {'key': 6, 'key2': 4})",
            "",
            "    def test_get_value(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        self.assertEqual(",
            "            schema.get_value(appstruct, 'seq'),",
            "            [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "        )",
            "        self.assertEqual(schema.get_value(appstruct, 'seq2.1.key'), 3)",
            "",
            "    def test_invalid_asdict(self):",
            "        expected = {",
            "            'schema.int': '20 is greater than maximum value 10',",
            "            'schema.ob': 'The dotted name \"no.way.this.exists\" '",
            "            'cannot be imported',",
            "            'schema.seq.0.0': '\"q\" is not a number',",
            "            'schema.seq.1.0': '\"w\" is not a number',",
            "            'schema.seq.2.0': '\"e\" is not a number',",
            "            'schema.seq.3.0': '\"r\" is not a number',",
            "            'schema.seq2.0.key': '\"t\" is not a number',",
            "            'schema.seq2.0.key2': '\"y\" is not a number',",
            "            'schema.seq2.1.key': '\"u\" is not a number',",
            "            'schema.seq2.1.key2': '\"i\" is not a number',",
            "            'schema.tup.0': '\"s\" is not a number',",
            "        }",
            "        data = {",
            "            'int': '20',",
            "            'ob': 'no.way.this.exists',",
            "            'seq': [('q', 's'), ('w', 's'), ('e', 's'), ('r', 's')],",
            "            'seq2': [{'key': 't', 'key2': 'y'}, {'key': 'u', 'key2': 'i'}],",
            "            'tup': ('s', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        e = invalid_exc(schema.deserialize, data)",
            "        errors = e.asdict()",
            "        self.assertEqual(errors, expected)",
            "",
            "    def test_invalid_asdict_translation_callback(self):",
            "        from translationstring import TranslationString",
            "",
            "        expected = {",
            "            'schema.int': 'translated',",
            "            'schema.ob': 'translated',",
            "            'schema.seq.0.0': 'translated',",
            "            'schema.seq.1.0': 'translated',",
            "            'schema.seq.2.0': 'translated',",
            "            'schema.seq.3.0': 'translated',",
            "            'schema.seq2.0.key': 'translated',",
            "            'schema.seq2.0.key2': 'translated',",
            "            'schema.seq2.1.key': 'translated',",
            "            'schema.seq2.1.key2': 'translated',",
            "            'schema.tup.0': 'translated',",
            "        }",
            "        data = {",
            "            'int': '20',",
            "            'ob': 'no.way.this.exists',",
            "            'seq': [('q', 's'), ('w', 's'), ('e', 's'), ('r', 's')],",
            "            'seq2': [{'key': 't', 'key2': 'y'}, {'key': 'u', 'key2': 'i'}],",
            "            'tup': ('s', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        e = invalid_exc(schema.deserialize, data)",
            "",
            "        def translation_function(string):",
            "            return TranslationString('translated')",
            "",
            "        errors = e.asdict(translate=translation_function)",
            "        self.assertEqual(errors, expected)",
            "",
            "",
            "class TestImperative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        integer = colander.SchemaNode(",
            "            colander.Integer(), name='int', validator=colander.Range(0, 10)",
            "        )",
            "",
            "        ob = colander.SchemaNode(",
            "            colander.GlobalObject(package=colander), name='ob'",
            "        )",
            "",
            "        tup = colander.SchemaNode(",
            "            colander.Tuple(),",
            "            colander.SchemaNode(colander.Integer(), name='tupint'),",
            "            colander.SchemaNode(colander.String(), name='tupstring'),",
            "            name='tup',",
            "        )",
            "",
            "        seq = colander.SchemaNode(colander.Sequence(), tup, name='seq')",
            "",
            "        seq2 = colander.SchemaNode(",
            "            colander.Sequence(),",
            "            colander.SchemaNode(",
            "                colander.Mapping(),",
            "                colander.SchemaNode(colander.Integer(), name='key'),",
            "                colander.SchemaNode(colander.Integer(), name='key2'),",
            "                name='mapping',",
            "            ),",
            "            name='seq2',",
            "        )",
            "",
            "        schema = colander.SchemaNode(",
            "            colander.Mapping(), integer, ob, tup, seq, seq2, name=name",
            "        )",
            "",
            "        return schema",
            "",
            "",
            "class TestDeclarative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        class TupleSchema(colander.TupleSchema):",
            "            tupint = colander.SchemaNode(colander.Int())",
            "            tupstring = colander.SchemaNode(colander.String())",
            "",
            "        class MappingSchema(colander.MappingSchema):",
            "            key = colander.SchemaNode(colander.Int())",
            "            key2 = colander.SchemaNode(colander.Int())",
            "",
            "        class SequenceOne(colander.SequenceSchema):",
            "            tup = TupleSchema()",
            "",
            "        class SequenceTwo(colander.SequenceSchema):",
            "            mapping = MappingSchema()",
            "",
            "        class MainSchema(colander.MappingSchema):",
            "            int = colander.SchemaNode(",
            "                colander.Int(), validator=colander.Range(0, 10)",
            "            )",
            "            ob = colander.SchemaNode(colander.GlobalObject(package=colander))",
            "            seq = SequenceOne()",
            "            tup = TupleSchema()",
            "            seq2 = SequenceTwo()",
            "",
            "        schema = MainSchema(name=name)",
            "        return schema",
            "",
            "",
            "class TestUltraDeclarative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        class IntSchema(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "        class StringSchema(colander.SchemaNode):",
            "            schema_type = colander.String",
            "",
            "        class TupleSchema(colander.TupleSchema):",
            "            tupint = IntSchema()",
            "            tupstring = StringSchema()",
            "",
            "        class MappingSchema(colander.MappingSchema):",
            "            key = IntSchema()",
            "            key2 = IntSchema()",
            "",
            "        class SequenceOne(colander.SequenceSchema):",
            "            tup = TupleSchema()",
            "",
            "        class SequenceTwo(colander.SequenceSchema):",
            "            mapping = MappingSchema()",
            "",
            "        class IntSchemaRanged(IntSchema):",
            "            validator = colander.Range(0, 10)",
            "",
            "        class GlobalObjectSchema(colander.SchemaNode):",
            "            def schema_type(self):",
            "                return colander.GlobalObject(package=colander)",
            "",
            "        class MainSchema(colander.MappingSchema):",
            "            int = IntSchemaRanged()",
            "            ob = GlobalObjectSchema()",
            "            seq = SequenceOne()",
            "            tup = TupleSchema()",
            "            seq2 = SequenceTwo()",
            "",
            "        MainSchema.name = name",
            "",
            "        schema = MainSchema()",
            "        return schema",
            "",
            "",
            "class TestDeclarativeWithInstantiate(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        # an unlikely usage, but goos to test passing",
            "        # parameters to instantiation works",
            "        @colander.instantiate(name=name)",
            "        class schema(colander.MappingSchema):",
            "            int = colander.SchemaNode(",
            "                colander.Int(), validator=colander.Range(0, 10)",
            "            )",
            "            ob = colander.SchemaNode(colander.GlobalObject(package=colander))",
            "",
            "            @colander.instantiate()",
            "            class seq(colander.SequenceSchema):",
            "                @colander.instantiate()",
            "                class tup(colander.TupleSchema):",
            "                    tupint = colander.SchemaNode(colander.Int())",
            "                    tupstring = colander.SchemaNode(colander.String())",
            "",
            "            @colander.instantiate()",
            "            class tup(colander.TupleSchema):",
            "                tupint = colander.SchemaNode(colander.Int())",
            "                tupstring = colander.SchemaNode(colander.String())",
            "",
            "            @colander.instantiate()",
            "            class seq2(colander.SequenceSchema):",
            "                @colander.instantiate()",
            "                class mapping(colander.MappingSchema):",
            "                    key = colander.SchemaNode(colander.Int())",
            "                    key2 = colander.SchemaNode(colander.Int())",
            "",
            "        return schema",
            "",
            "",
            "class Test_null(unittest.TestCase):",
            "    def test___nonzero__(self):",
            "        from colander import null",
            "",
            "        self.assertFalse(null)",
            "",
            "    def test___repr__(self):",
            "        from colander import null",
            "",
            "        self.assertEqual(repr(null), '<colander.null>')",
            "",
            "    def test_pickling(self):",
            "        from colander import null",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(null)) is null)",
            "",
            "",
            "class Test_required(unittest.TestCase):",
            "    def test___repr__(self):",
            "        from colander import required",
            "",
            "        self.assertEqual(repr(required), '<colander.required>')",
            "",
            "    def test_pickling(self):",
            "        from colander import required",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(required)) is required)",
            "",
            "",
            "class Test_drop(unittest.TestCase):",
            "    def test___repr__(self):",
            "        from colander import drop",
            "",
            "        self.assertEqual(repr(drop), '<colander.drop>')",
            "",
            "    def test_pickling(self):",
            "        from colander import drop",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(drop)) is drop)",
            "",
            "",
            "class Dummy(object):",
            "    pass",
            "",
            "",
            "class DummySchemaNode(object):",
            "    def __init__(self, typ, name='', exc=None, default=None):",
            "        self.typ = typ",
            "        self.name = name",
            "        self.exc = exc",
            "        self.required = default is None",
            "        self.default = default",
            "        self.children = []",
            "",
            "    def deserialize(self, val):",
            "        from colander import Invalid",
            "",
            "        if self.exc:",
            "            raise Invalid(self, self.exc)",
            "        return val",
            "",
            "    def serialize(self, val):",
            "        from colander import Invalid",
            "",
            "        if self.exc:",
            "            raise Invalid(self, self.exc)",
            "        return val",
            "",
            "    def __getitem__(self, name):",
            "        for child in self.children:",
            "            if child.name == name:",
            "                return child",
            "",
            "",
            "class DummyValidator(object):",
            "    def __init__(self, msg=None, children=None):",
            "        self.msg = msg",
            "        self.children = children",
            "",
            "    def __call__(self, node, value):",
            "        from colander import Invalid",
            "",
            "        if self.msg:",
            "            e = Invalid(node, self.msg)",
            "            self.children and e.children.extend(self.children)",
            "            raise e",
            "",
            "",
            "class Uncooperative(object):",
            "    def __str__(self):",
            "        raise ValueError('I wont cooperate')",
            "",
            "    __unicode__ = __str__",
            "",
            "",
            "class DummyType(object):",
            "    def serialize(self, node, value):",
            "        return value",
            "",
            "    def deserialize(self, node, value):",
            "        return value",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        if listitem:",
            "            key = prefix.rstrip('.')",
            "        else:",
            "            key = prefix + 'appstruct'",
            "        return {key: appstruct}",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        assert paths == [node.name]",
            "        return fstruct[node.name]"
        ],
        "afterPatchFile": [
            "# -*- coding:utf-8 -*-",
            "import unittest",
            "from colander.compat import text_, text_type",
            "",
            "",
            "def invalid_exc(func, *arg, **kw):",
            "    from colander import Invalid",
            "",
            "    try:",
            "        func(*arg, **kw)",
            "    except Invalid as e:",
            "        return e",
            "    else:",
            "        raise AssertionError('Invalid not raised')  # pragma: no cover",
            "",
            "",
            "class TestInvalid(unittest.TestCase):",
            "    def _makeOne(self, node, msg=None, val=None):",
            "        from colander import Invalid",
            "",
            "        exc = Invalid(node, msg, val)",
            "        return exc",
            "",
            "    def test_ctor(self):",
            "        exc = self._makeOne(None, 'msg', 'val')",
            "        self.assertEqual(exc.node, None)",
            "        self.assertEqual(exc.msg, 'msg')",
            "        self.assertEqual(exc.value, 'val')",
            "        self.assertEqual(exc.children, [])",
            "",
            "    def test_add(self):",
            "        exc = self._makeOne(None, 'msg')",
            "        other = Dummy()",
            "        exc.add(other)",
            "        self.assertFalse(hasattr(other, 'positional'))",
            "        self.assertEqual(exc.children, [other])",
            "",
            "    def test_add_positional(self):",
            "        from colander import Positional",
            "",
            "        p = Positional()",
            "        node = DummySchemaNode(p)",
            "        exc = self._makeOne(node, 'msg')",
            "        other = Dummy()",
            "        exc.add(other)",
            "        self.assertEqual(other.positional, True)",
            "        self.assertEqual(exc.children, [other])",
            "",
            "    def test__keyname_no_parent(self):",
            "        node = DummySchemaNode(None, name='name')",
            "        exc = self._makeOne(None, '')",
            "        exc.node = node",
            "        self.assertEqual(exc._keyname(), 'name')",
            "",
            "    def test__keyname_positional(self):",
            "        exc = self._makeOne(None, '')",
            "        exc.positional = True",
            "        exc.pos = 2",
            "        self.assertEqual(exc._keyname(), '2')",
            "",
            "    def test__keyname_nonpositional_parent(self):",
            "        parent = Dummy()",
            "        parent.node = DummySchemaNode(None)",
            "        exc = self._makeOne(None, 'me')",
            "        exc.parent = parent",
            "        exc.pos = 2",
            "        exc.node = DummySchemaNode(None, name='name')",
            "        self.assertEqual(exc._keyname(), 'name')",
            "",
            "    def test_paths(self):",
            "        exc1 = self._makeOne(None, 'exc1')",
            "        exc2 = self._makeOne(None, 'exc2')",
            "        exc3 = self._makeOne(None, 'exc3')",
            "        exc4 = self._makeOne(None, 'exc4')",
            "        exc1.add(exc2)",
            "        exc2.add(exc3)",
            "        exc1.add(exc4)",
            "        paths = list(exc1.paths())",
            "        self.assertEqual(paths, [(exc1, exc2, exc3), (exc1, exc4)])",
            "",
            "    def test_asdict(self):",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node4 = DummySchemaNode(Positional(), 'node4')",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = self._makeOne(node3, 'exc3')",
            "        exc4 = self._makeOne(node4, 'exc4')",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        exc1.add(exc4, 4)",
            "        d = exc1.asdict()",
            "        self.assertEqual(",
            "            d,",
            "            {'node1.node2.3': 'exc1; exc2; exc3', 'node1.node4': 'exc1; exc4'},",
            "        )",
            "",
            "    def test_asdict_with_all_validator(self):",
            "        # see https://github.com/Pylons/colander/pull/27",
            "        from colander import All",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node1.children = [node3]",
            "        validator1 = DummyValidator('validator1')",
            "        validator2 = DummyValidator('validator2')",
            "        validator = All(validator1, validator2)",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc1['node3'] = 'message1'",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = invalid_exc(validator, None, None)",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        d = exc1.asdict()",
            "        self.assertEqual(",
            "            d,",
            "            {",
            "                'node1.node2.3': 'exc1; exc2; validator1; validator2',",
            "                'node1.node3': 'exc1; message1',",
            "            },",
            "        )",
            "",
            "    def test_asdict_with_all_validator_functional(self):",
            "        # see https://github.com/Pylons/colander/issues/2",
            "        import colander as c",
            "",
            "        class MySchema(c.MappingSchema):",
            "            number1 = c.SchemaNode(c.Int(), validator=c.Range(min=1))",
            "            number2 = c.SchemaNode(c.Int(), validator=c.Range(min=1))",
            "",
            "        def validate_higher(node, val):",
            "            if val['number1'] >= val['number2']:",
            "                raise c.Invalid(node, 'Number 1 must be lower than number 2')",
            "",
            "        def validate_different(node, val):",
            "            if val['number1'] == val['number2']:",
            "                raise c.Invalid(node, \"They can't be the same, either\")",
            "",
            "        schema = MySchema(validator=c.All(validate_higher, validate_different))",
            "        try:",
            "            schema.deserialize(dict(number1=2, number2=2))",
            "        except c.Invalid as e:",
            "            result = e.asdict()",
            "            self.assertEqual(",
            "                result,",
            "                {",
            "                    '': (",
            "                        \"Number 1 must be lower than number 2; \"",
            "                        \"They can't be the same, either\"",
            "                    )",
            "                },",
            "            )",
            "        try:",
            "            schema.deserialize(dict(number1=2, number2=2))",
            "        except c.Invalid as e:",
            "            result = e.asdict(separator=None)",
            "            self.assertEqual(",
            "                result,",
            "                {",
            "                    '': [",
            "                        \"Number 1 must be lower than number 2\",",
            "                        \"They can't be the same, either\",",
            "                    ]",
            "                },",
            "            )",
            "",
            "    def test___str__(self):",
            "        from colander import Positional",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node2 = DummySchemaNode(Positional(), 'node2')",
            "        node3 = DummySchemaNode(Positional(), 'node3')",
            "        node4 = DummySchemaNode(Positional(), 'node4')",
            "        exc1 = self._makeOne(node1, 'exc1')",
            "        exc1.pos = 1",
            "        exc2 = self._makeOne(node2, 'exc2')",
            "        exc3 = self._makeOne(node3, 'exc3')",
            "        exc4 = self._makeOne(node4, 'exc4')",
            "        exc1.add(exc2, 2)",
            "        exc2.add(exc3, 3)",
            "        exc1.add(exc4, 4)",
            "        result = str(exc1)",
            "        self.assertEqual(",
            "            result,",
            "            \"{'node1.node2.3': 'exc1; exc2; exc3', \"",
            "            \"'node1.node4': 'exc1; exc4'}\",",
            "        )",
            "",
            "    def test___setitem__fails(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, 'msg')",
            "        self.assertRaises(KeyError, exc.__setitem__, 'notfound', 'msg')",
            "",
            "    def test___setitem__succeeds(self):",
            "        node = DummySchemaNode(None)",
            "        child = DummySchemaNode(None)",
            "        child.name = 'found'",
            "        node.children = [child]",
            "        exc = self._makeOne(node, 'msg')",
            "        exc['found'] = 'msg2'",
            "        self.assertEqual(len(exc.children), 1)",
            "        childexc = exc.children[0]",
            "        self.assertEqual(childexc.pos, 0)",
            "        self.assertEqual(childexc.node.name, 'found')",
            "",
            "    def test_messages_msg_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, [123, 456])",
            "        self.assertEqual(exc.messages(), [123, 456])",
            "",
            "    def test_messages_msg_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, 'msg')",
            "        self.assertEqual(exc.messages(), ['msg'])",
            "",
            "    def test_messages_msg_None(self):",
            "        node = DummySchemaNode(None)",
            "        exc = self._makeOne(node, None)",
            "        self.assertEqual(exc.messages(), [])",
            "",
            "",
            "class TestAll(unittest.TestCase):",
            "    def _makeOne(self, validators):",
            "        from colander import All",
            "",
            "        return All(*validators)",
            "",
            "    def test_success(self):",
            "        validator1 = DummyValidator()",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_failure(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator('msg2')",
            "        validator = self._makeOne([validator1, validator2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, ['msg1', 'msg2'])",
            "",
            "    def test_Invalid_children(self):",
            "        from colander import Invalid",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node = DummySchemaNode(None, 'node')",
            "        node.children = [node1]",
            "        exc1 = Invalid(node1, 'exc1')",
            "        exc2 = Invalid(node1, 'exc2')",
            "        validator1 = DummyValidator('validator1', [exc1])",
            "        validator2 = DummyValidator('validator2', [exc2])",
            "        validator = self._makeOne([validator1, validator2])",
            "        exc = invalid_exc(validator, node, None)",
            "        self.assertEqual(exc.children, [exc1, exc2])",
            "",
            "",
            "class TestAny(unittest.TestCase):",
            "    def _makeOne(self, validators):",
            "        from colander import Any",
            "",
            "        return Any(*validators)",
            "",
            "    def test_success(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_failure(self):",
            "        validator1 = DummyValidator('msg1')",
            "        validator2 = DummyValidator('msg2')",
            "        validator = self._makeOne([validator1, validator2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, ['msg1', 'msg2'])",
            "",
            "    def test_Invalid_children(self):",
            "        from colander import Invalid",
            "",
            "        node1 = DummySchemaNode(None, 'node1')",
            "        node = DummySchemaNode(None, 'node')",
            "        node.children = [node1]",
            "        exc1 = Invalid(node1, 'exc1')",
            "        validator1 = DummyValidator('validator1', [exc1])",
            "        validator2 = DummyValidator()",
            "        validator = self._makeOne([validator1, validator2])",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "",
            "class TestFunction(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Function",
            "",
            "        return Function(*arg, **kw)",
            "",
            "    def test_success_function_returns_True(self):",
            "        validator = self._makeOne(lambda x: True)",
            "        self.assertEqual(validator(None, None), None)",
            "",
            "    def test_fail_function_returns_empty_string(self):",
            "        validator = self._makeOne(lambda x: '')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'Invalid value')",
            "",
            "    def test_fail_function_returns_False(self):",
            "        validator = self._makeOne(lambda x: False)",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'Invalid value')",
            "",
            "    def test_fail_function_returns_string(self):",
            "        validator = self._makeOne(lambda x: 'fail')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg, 'fail')",
            "",
            "    def test_deprecated_message(self):",
            "        import warnings",
            "",
            "        orig_warn = warnings.warn",
            "        log = []",
            "",
            "        def warn(message, category=None, stacklevel=1):",
            "            log.append((message, category, stacklevel))",
            "",
            "        try:",
            "            # Monkey patching warn so that tests run quietly",
            "            warnings.warn = warn",
            "            validator = self._makeOne(lambda x: False, message='depr')",
            "            e = invalid_exc(validator, None, None)",
            "            self.assertEqual(e.msg.interpolate(), 'depr')",
            "        finally:",
            "            warnings.warn = orig_warn",
            "",
            "    def test_deprecated_message_warning(self):",
            "        import warnings",
            "",
            "        orig_warn = warnings.warn",
            "        log = []",
            "",
            "        def warn(message, category=None, stacklevel=1):",
            "            log.append((message, category, stacklevel))",
            "",
            "        try:",
            "            # Monkey patching warn since catch_warnings context manager",
            "            # is not working when running the full suite",
            "            warnings.warn = warn",
            "            validator = self._makeOne(lambda x: False, message='depr')",
            "            invalid_exc(validator, None, None)",
            "            self.assertEqual(len(log), 1)",
            "        finally:",
            "            warnings.warn = orig_warn",
            "",
            "    def test_msg_and_message_error(self):",
            "        self.assertRaises(",
            "            ValueError,",
            "            self._makeOne,",
            "            lambda x: False,",
            "            msg='one',",
            "            message='two',",
            "        )",
            "",
            "    def test_error_message_adds_mapping_to_configured_message(self):",
            "        validator = self._makeOne(lambda x: False, msg='fail ${val}')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), 'fail None')",
            "",
            "    def test_error_message_adds_mapping_to_return_message(self):",
            "        validator = self._makeOne(lambda x: 'fail ${val}')",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), 'fail None')",
            "",
            "    def test_error_message_does_not_overwrite_configured_domain(self):",
            "        import translationstring",
            "",
            "        _ = translationstring.TranslationStringFactory('fnord')",
            "        validator = self._makeOne(lambda x: False, msg=_('fail ${val}'))",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.domain, 'fnord')",
            "",
            "    def test_error_message_does_not_overwrite_returned_domain(self):",
            "        import translationstring",
            "",
            "        _ = translationstring.TranslationStringFactory('fnord')",
            "        validator = self._makeOne(lambda x: _('fail ${val}'))",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.domain, 'fnord')",
            "",
            "    def test_propagation(self):",
            "        validator = self._makeOne(lambda x: 'a' in x, 'msg')",
            "        self.assertRaises(TypeError, validator, None, None)",
            "",
            "",
            "class TestRange(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Range",
            "",
            "        return Range(**kw)",
            "",
            "    def test_success_no_bounds(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_success_upper_bound_only(self):",
            "        validator = self._makeOne(max=1)",
            "        self.assertEqual(validator(None, -1), None)",
            "",
            "    def test_success_minimum_bound_only(self):",
            "        validator = self._makeOne(min=0)",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_success_min_and_max(self):",
            "        validator = self._makeOne(min=1, max=1)",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_min_failure(self):",
            "        validator = self._makeOne(min=1)",
            "        e = invalid_exc(validator, None, 0)",
            "        self.assertEqual(e.msg.interpolate(), '0 is less than minimum value 1')",
            "",
            "    def test_min_failure_msg_override(self):",
            "        validator = self._makeOne(min=1, min_err='wrong')",
            "        e = invalid_exc(validator, None, 0)",
            "        self.assertEqual(e.msg, 'wrong')",
            "",
            "    def test_max_failure(self):",
            "        validator = self._makeOne(max=1)",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(",
            "            e.msg.interpolate(), '2 is greater than maximum value 1'",
            "        )",
            "",
            "    def test_max_failure_msg_override(self):",
            "        validator = self._makeOne(max=1, max_err='wrong')",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(e.msg, 'wrong')",
            "",
            "",
            "class TestRegex(unittest.TestCase):",
            "    def _makeOne(self, pattern):",
            "        from colander import Regex",
            "",
            "        return Regex(pattern)",
            "",
            "    def test_valid_regex(self):",
            "        self.assertEqual(self._makeOne('a')(None, 'a'), None)",
            "        self.assertEqual(self._makeOne('[0-9]+')(None, '1111'), None)",
            "        self.assertEqual(self._makeOne('')(None, ''), None)",
            "        self.assertEqual(self._makeOne('.*')(None, ''), None)",
            "",
            "    def test_invalid_regexs(self):",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._makeOne('[0-9]+'), None, 'a')",
            "        self.assertRaises(Invalid, self._makeOne('a{2,4}'), None, 'ba')",
            "",
            "    def test_regex_not_string(self):",
            "        from colander import Invalid",
            "        import re",
            "",
            "        regex = re.compile('[0-9]+')",
            "        self.assertEqual(self._makeOne(regex)(None, '01'), None)",
            "        self.assertRaises(Invalid, self._makeOne(regex), None, 't')",
            "",
            "",
            "class TestEmail(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Email",
            "",
            "        return Email()",
            "",
            "    def test_valid_emails(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, 'me@here.com'), None)",
            "        self.assertEqual(validator(None, 'me1@here1.com'), None)",
            "        self.assertEqual(validator(None, 'name@here1.us'), None)",
            "        self.assertEqual(validator(None, 'name@here1.info'), None)",
            "        self.assertEqual(validator(None, 'foo@bar.baz.biz'), None)",
            "        self.assertEqual(validator(None, \"tip'oneill@house.gov\"), None)",
            "        self.assertEqual(validator(None, \"lorem@i--ipsum.com\"), None)",
            "",
            "    def test_empty_email(self):",
            "        validator = self._makeOne()",
            "        e = invalid_exc(validator, None, '')",
            "        self.assertEqual(e.msg, 'Invalid email address')",
            "",
            "    def test_invalid_emails(self):",
            "        validator = self._makeOne()",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, validator, None, 'me@here.')",
            "        self.assertRaises(Invalid, validator, None, '@here.us')",
            "        self.assertRaises(Invalid, validator, None, 'me@here..com')",
            "        self.assertRaises(Invalid, validator, None, 'me@we-here-.com')",
            "        self.assertRaises(Invalid, validator, None, 'name1,name2@here.info')",
            "",
            "",
            "class TestLength(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Length",
            "",
            "        return Length(**kw)",
            "",
            "    def test_success_no_bounds(self):",
            "        validator = self._makeOne()",
            "        self.assertEqual(validator(None, ''), None)",
            "",
            "    def test_success_upper_bound_only(self):",
            "        validator = self._makeOne(max=1)",
            "        self.assertEqual(validator(None, 'a'), None)",
            "",
            "    def test_success_minimum_bound_only(self):",
            "        validator = self._makeOne(min=0)",
            "        self.assertEqual(validator(None, ''), None)",
            "",
            "    def test_success_min_and_max(self):",
            "        validator = self._makeOne(min=1, max=1)",
            "        self.assertEqual(validator(None, 'a'), None)",
            "",
            "    def test_min_failure(self):",
            "        validator = self._makeOne(min=1)",
            "        e = invalid_exc(validator, None, '')",
            "        self.assertEqual(e.msg.interpolate(), 'Shorter than minimum length 1')",
            "",
            "    def test_max_failure(self):",
            "        validator = self._makeOne(max=1)",
            "        e = invalid_exc(validator, None, 'ab')",
            "        self.assertEqual(e.msg.interpolate(), 'Longer than maximum length 1')",
            "",
            "    def test_min_failure_msg_override(self):",
            "        validator = self._makeOne(min=1, min_err='Need at least ${min}, mate')",
            "        e = invalid_exc(validator, None, [])",
            "        self.assertEqual(e.msg.interpolate(), 'Need at least 1, mate')",
            "",
            "    def test_max_failure_msg_override(self):",
            "        validator = self._makeOne(max=1, max_err='No more than ${max}, mate')",
            "        e = invalid_exc(validator, None, [1, 2])",
            "        self.assertEqual(e.msg.interpolate(), 'No more than 1, mate')",
            "",
            "",
            "class TestOneOf(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import OneOf",
            "",
            "        return OneOf(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1])",
            "        self.assertEqual(validator(None, 1), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1, 2])",
            "        e = invalid_exc(validator, None, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not one of 1, 2')",
            "",
            "",
            "class TestNoneOf(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import NoneOf",
            "",
            "        return NoneOf(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1, 2])",
            "        self.assertEqual(validator(None, 3), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1, 2])",
            "        e = invalid_exc(validator, None, 2)",
            "        self.assertEqual(e.msg.interpolate(), '\"2\" must not be one of 1, 2')",
            "",
            "",
            "class TestContainsOnly(unittest.TestCase):",
            "    def _makeOne(self, values):",
            "        from colander import ContainsOnly",
            "",
            "        return ContainsOnly(values)",
            "",
            "    def test_success(self):",
            "        validator = self._makeOne([1])",
            "        self.assertEqual(validator(None, [1]), None)",
            "",
            "    def test_failure(self):",
            "        validator = self._makeOne([1])",
            "        e = invalid_exc(validator, None, [2])",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'One or more of the choices you made was not acceptable',",
            "        )",
            "",
            "    def test_failure_with_custom_error_template(self):",
            "        validator = self._makeOne([1])",
            "        from colander import _",
            "",
            "        validator.err_template = _('${val}: ${choices}')",
            "        e = invalid_exc(validator, None, [2])",
            "        self.assertTrue('[2]' in e.msg.interpolate())",
            "",
            "",
            "class Test_luhnok(unittest.TestCase):",
            "    def _callFUT(self, node, value):",
            "        from colander import luhnok",
            "",
            "        return luhnok(node, value)",
            "",
            "    def test_fail(self):",
            "        import colander",
            "",
            "        val = '10'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_fail2(self):",
            "        import colander",
            "",
            "        val = '99999999999999999999999'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_fail3(self):",
            "        import colander",
            "",
            "        val = 'abcdefghij'",
            "        self.assertRaises(colander.Invalid, self._callFUT, None, val)",
            "",
            "    def test_success(self):",
            "        val = '4111111111111111'",
            "        self.assertFalse(self._callFUT(None, val))",
            "",
            "",
            "class Test_url_validator(unittest.TestCase):",
            "    def _callFUT(self, val):",
            "        from colander import url",
            "",
            "        return url(None, val)",
            "",
            "    def test_it_success(self):",
            "        val = 'http://example.com'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_it_failure(self):",
            "        val = 'not-a-url'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_add_sample_dos(self):",
            "        # In the old regex (colander <=1.6) this would cause a catastrophic",
            "        # backtracking that would cause the regex engine to go into an infinite",
            "        # loop.",
            "        val = \"http://www.mysite.com/(tttttttttttttttttttttt.jpg\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_website_no_scheme(self):",
            "        val = \"www.mysite.com\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_ipv6(self):",
            "        val = \"http://[2001:db8::0]/\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_ipv4(self):",
            "        val = \"http://192.0.2.1/\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_file_raises(self):",
            "        from colander import Invalid",
            "",
            "        val = \"file:///this/is/a/file.jpg\"",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "",
            "class Test_file_uri_validator(unittest.TestCase):",
            "    def _callFUT(self, val):",
            "        from colander import file_uri",
            "",
            "        return file_uri(None, val)",
            "",
            "    def test_it_success(self):",
            "        val = 'file:///'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_it_failure(self):",
            "        val = 'not-a-uri'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_no_path_fails(self):",
            "        val = 'file://'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_file_with_path(self):",
            "        val = \"file:///this/is/a/file.jpg\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_file_with_path_windows(self):",
            "        val = \"file:///c:/is/a/file.jpg\"",
            "",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "",
            "class TestUUID(unittest.TestCase):",
            "    def _callFUT(self, val):",
            "        from colander import uuid",
            "",
            "        return uuid(None, val)",
            "",
            "    def test_success_hexadecimal(self):",
            "        val = '123e4567e89b12d3a456426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_dashes(self):",
            "        val = '123e4567-e89b-12d3-a456-426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_upper_case(self):",
            "        val = '123E4567-E89B-12D3-A456-426655440000'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_braces(self):",
            "        val = '{123e4567-e89b-12d3-a456-426655440000}'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_success_with_urn_ns(self):",
            "        val = 'urn:uuid:{123e4567-e89b-12d3-a456-426655440000}'",
            "        result = self._callFUT(val)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_failure_random_string(self):",
            "        val = 'not-a-uuid'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_not_hexadecimal(self):",
            "        val = '123zzzzz-uuuu-zzzz-uuuu-42665544zzzz'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_invalid_length(self):",
            "        # Correct UUID: 8-4-4-4-12",
            "        val = '88888888-333-4444-333-cccccccccccc'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "    def test_failure_with_invalid_urn_ns(self):",
            "        val = 'urn:abcd:{123e4567-e89b-12d3-a456-426655440000}'",
            "        from colander import Invalid",
            "",
            "        self.assertRaises(Invalid, self._callFUT, val)",
            "",
            "",
            "class TestSchemaType(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import SchemaType",
            "",
            "        return SchemaType(*arg, **kw)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, 'appstruct')",
            "        self.assertEqual(result, {'node': 'appstruct'})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, 'appstruct', listitem=True)",
            "        self.assertEqual(result, {'': 'appstruct'})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(node, ['node'], {'node': 'appstruct'})",
            "        self.assertEqual(result, 'appstruct')",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            AssertionError, typ.set_value, None, None, None, None",
            "        )",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(AssertionError, typ.get_value, None, None, None)",
            "",
            "    def test_cstruct_children(self):",
            "        typ = self._makeOne()",
            "        self.assertEqual(typ.cstruct_children(None, None), [])",
            "",
            "",
            "class TestMapping(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Mapping",
            "",
            "        return Mapping(*arg, **kw)",
            "",
            "    def test_ctor_bad_unknown(self):",
            "        self.assertRaises(ValueError, self._makeOne, 'badarg')",
            "",
            "    def test_ctor_good_unknown(self):",
            "        try:",
            "            self._makeOne('ignore')",
            "            self._makeOne('raise')",
            "            self._makeOne('preserve')",
            "        except ValueError as e:  # pragma: no cover",
            "            raise AssertionError(e)",
            "",
            "    def test_deserialize_not_a_mapping(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "",
            "        # None",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"None\" is not a mapping type')",
            "        )",
            "",
            "        # list",
            "        e = invalid_exc(typ.deserialize, node, [])",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"[]\" is not a mapping type')",
            "        )",
            "",
            "        # str",
            "        e = invalid_exc(typ.deserialize, node, \"\")",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"\" is not a mapping type')",
            "        )",
            "",
            "        # tuple",
            "        e = invalid_exc(typ.deserialize, node, ())",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"()\" is not a mapping type')",
            "        )",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_deserialize_unknown_raise(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne(unknown='raise')",
            "        e = invalid_exc(typ.deserialize, node, {'a': 1, 'b': 2})",
            "        self.assertTrue(isinstance(e, colander.UnsupportedFields))",
            "        self.assertEqual(e.fields, {'b': 2})",
            "        self.assertEqual(",
            "            e.msg.interpolate(), \"Unrecognized keys in mapping: \\\"{'b': 2}\\\"\"",
            "        )",
            "",
            "    def test_deserialize_unknown_preserve(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne(unknown='preserve')",
            "        result = typ.deserialize(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'a': 1, 'b': 2})",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, {'a': 1, 'b': 2})",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_deserialize_subnode_missing_default(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b', default='abc'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1, 'b': colander.null})",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, {})",
            "",
            "    def test_serialize_not_a_mapping(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertTrue(",
            "            e.msg.interpolate().startswith('\"None\" is not a mapping type')",
            "        )",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': 1})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_serialize_with_unknown(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'a': 1})",
            "",
            "    def test_serialize_value_is_null(self):",
            "        node = DummySchemaNode(None)",
            "        from colander import null",
            "",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, null)",
            "        self.assertEqual(result, {'a': null})",
            "",
            "    def test_serialize_value_has_drop(self):",
            "        from colander import drop",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, {'a': drop})",
            "        self.assertEqual(result, {})",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, {'a': 1, 'b': 2})",
            "        self.assertEqual(result, {'node.appstruct': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, {'a': 1, 'b': 2}, listitem=True)",
            "        self.assertEqual(result, {'appstruct': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            ['node', 'node.a', 'node.b'],",
            "            {'node': {'a': 1, 'b': 2}, 'node.a': 1, 'node.b': 2},",
            "        )",
            "        self.assertEqual(result, {'a': 1, 'b': 2})",
            "",
            "    def test_unflatten_nested(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        inttype = DummyType()",
            "        one = DummySchemaNode(self._makeOne(), name='one')",
            "        one.children = [",
            "            DummySchemaNode(inttype, name='a'),",
            "            DummySchemaNode(inttype, name='b'),",
            "        ]",
            "        two = DummySchemaNode(self._makeOne(), name='two')",
            "        two.children = [",
            "            DummySchemaNode(inttype, name='c'),",
            "            DummySchemaNode(inttype, name='d'),",
            "        ]",
            "        node.children = [one, two]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            [",
            "                'node',",
            "                'node.one',",
            "                'node.one.a',",
            "                'node.one.b',",
            "                'node.two',",
            "                'node.two.c',",
            "                'node.two.d',",
            "            ],",
            "            {",
            "                'node': {'one': {'a': 1, 'b': 2}, 'two': {'c': 3, 'd': 4}},",
            "                'node.one': {'a': 1, 'b': 2},",
            "                'node.two': {'c': 3, 'd': 4},",
            "                'node.one.a': 1,",
            "                'node.one.b': 2,",
            "                'node.two.c': 3,",
            "                'node.two.d': 4,",
            "            },",
            "        )",
            "        self.assertEqual(",
            "            result, {'one': {'a': 1, 'b': 2}, 'two': {'c': 3, 'd': 4}}",
            "        )",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        appstruct = {'node2': {'foo': 'foo', 'baz': 'baz'}}",
            "        typ.set_value(node1, appstruct, 'node2.foo', 'bar')",
            "        self.assertEqual(appstruct, {'node2': {'foo': 'bar', 'baz': 'baz'}})",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        appstruct = {'node2': {'foo': 'bar', 'baz': 'baz'}}",
            "        self.assertEqual(",
            "            typ.get_value(node1, appstruct, 'node2'),",
            "            {'foo': 'bar', 'baz': 'baz'},",
            "        )",
            "        self.assertEqual(typ.get_value(node1, appstruct, 'node2.foo'), 'bar')",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        result = typ.cstruct_children(node1, null)",
            "        self.assertEqual(result, [null])",
            "",
            "    def test_cstruct_children(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, {'node2': 'abc'})",
            "        self.assertEqual(result, ['abc', null])",
            "",
            "",
            "class TestTuple(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Tuple",
            "",
            "        return Tuple()",
            "",
            "    def test_deserialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, ())",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, ('a',))",
            "",
            "    def test_deserialize_toobig(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ('a', 'b'))",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            \"\\\"('a', 'b')\\\" has an incorrect number of \"",
            "            \"elements (expected 1, was 2)\",",
            "        )",
            "",
            "    def test_deserialize_toosmall(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ())",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            '\"()\" has an incorrect number of elements (expected 1, was 0)',",
            "        )",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ())",
            "        self.assertEqual(result, ())",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ('a',))",
            "        self.assertEqual(result, ('a',))",
            "",
            "    def test_serialize_toobig(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ('a', 'b'))",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            \"\\\"('a', 'b')\\\" has an incorrect number of \"",
            "            \"elements (expected 1, was 2)\",",
            "        )",
            "",
            "    def test_serialize_toosmall(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ())",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            '\"()\" has an incorrect number of elements (expected 1, was 0)',",
            "        )",
            "",
            "    def test_serialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [",
            "            DummySchemaNode(None, name='a', exc='Wrong 2'),",
            "            DummySchemaNode(None, name='b', exc='Wrong 2'),",
            "        ]",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, (1, 2))",
            "        self.assertEqual(result, {'node.appstruct': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, (1, 2), listitem=True)",
            "        self.assertEqual(result, {'appstruct': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        int1 = DummyType()",
            "        int2 = DummyType()",
            "        node.children = [",
            "            DummySchemaNode(int1, name='a'),",
            "            DummySchemaNode(int2, name='b'),",
            "        ]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node,",
            "            ['node', 'node.a', 'node.b'],",
            "            {'node': (1, 2), 'node.a': 1, 'node.b': 2},",
            "        )",
            "        self.assertEqual(result, (1, 2))",
            "",
            "    def test_set_value(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(typ, name='foo'),",
            "            DummySchemaNode(typ, name='bar'),",
            "        ]",
            "        node['foo'].children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b'),",
            "        ]",
            "        node['bar'].children = [",
            "            DummySchemaNode(None, name='c'),",
            "            DummySchemaNode(None, name='d'),",
            "        ]",
            "        appstruct = ((1, 2), (3, 4))",
            "        result = typ.set_value(node, appstruct, 'bar.c', 34)",
            "        self.assertEqual(result, ((1, 2), (34, 4)))",
            "",
            "    def test_set_value_bad_path(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(None, name='foo'),",
            "            DummySchemaNode(None, name='bar'),",
            "        ]",
            "        self.assertRaises(KeyError, typ.set_value, node, (1, 2), 'foobar', 34)",
            "",
            "    def test_get_value(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(typ, name='foo'),",
            "            DummySchemaNode(typ, name='bar'),",
            "        ]",
            "        node['foo'].children = [",
            "            DummySchemaNode(None, name='a'),",
            "            DummySchemaNode(None, name='b'),",
            "        ]",
            "        node['bar'].children = [",
            "            DummySchemaNode(None, name='c'),",
            "            DummySchemaNode(None, name='d'),",
            "        ]",
            "        appstruct = ((1, 2), (3, 4))",
            "        self.assertEqual(typ.get_value(node, appstruct, 'foo'), (1, 2))",
            "        self.assertEqual(typ.get_value(node, appstruct, 'foo.b'), 2)",
            "",
            "    def test_get_value_bad_path(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ, name='node')",
            "        node.children = [",
            "            DummySchemaNode(None, name='foo'),",
            "            DummySchemaNode(None, name='bar'),",
            "        ]",
            "        self.assertRaises(KeyError, typ.get_value, node, (1, 2), 'foobar')",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node1.children = [node2]",
            "        result = typ.cstruct_children(node1, null)",
            "        self.assertEqual(result, [null])",
            "",
            "    def test_cstruct_children_toomany(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one', 'two', 'three'])",
            "        self.assertEqual(result, ['one', 'two'])",
            "",
            "    def test_cstruct_children_toofew(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one'])",
            "        self.assertEqual(result, ['one', null])",
            "",
            "    def test_cstruct_children_justright(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='node1')",
            "        node2 = DummySchemaNode(typ, name='node2')",
            "        node3 = DummySchemaNode(typ, name='node3')",
            "        node1.children = [node2, node3]",
            "        result = typ.cstruct_children(node1, ['one', 'two'])",
            "        self.assertEqual(result, ['one', 'two'])",
            "",
            "",
            "class TestSet(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Set",
            "",
            "        return Set(**kw)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        provided = []",
            "        result = typ.serialize(node, provided)",
            "        self.assertTrue(result is provided)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.serialize(node, null)",
            "        self.assertTrue(result is null)",
            "",
            "    def test_deserialize_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, 1)",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_str_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, \"foo\")",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_deserialize_valid(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, set(('a',)))",
            "",
            "    def test_deserialize_empty_set(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, set())",
            "        self.assertEqual(result, set())",
            "",
            "",
            "class TestList(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import List",
            "",
            "        return List(**kw)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        provided = []",
            "        result = typ.serialize(node, provided)",
            "        self.assertTrue(result is provided)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.serialize(node, null)",
            "        self.assertTrue(result is null)",
            "",
            "    def test_deserialize_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, 1)",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_str_no_iter(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        e = invalid_exc(typ.deserialize, node, \"foo\")",
            "        self.assertEqual(e.msg, '${cstruct} is not iterable')",
            "",
            "    def test_deserialize_null(self):",
            "        from colander import null",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_deserialize_valid(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ('a', 'z', 'b'))",
            "        self.assertEqual(result, ['a', 'z', 'b'])",
            "",
            "    def test_deserialize_empty_set(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(typ)",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "",
            "class TestSequence(unittest.TestCase):",
            "    def _makeOne(self, **kw):",
            "        from colander import Sequence",
            "",
            "        return Sequence(**kw)",
            "",
            "    def test_alias(self):",
            "        from colander import Seq",
            "        from colander import Sequence",
            "",
            "        self.assertEqual(Seq, Sequence)",
            "",
            "    def test_deserialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.deserialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_deserialize_not_iterable_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, None)",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_deserialize_string_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, 'abc')",
            "        self.assertEqual(result, ['abc'])",
            "",
            "    def test_deserialize_no_subnodes(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        node.children = [node]",
            "        result = typ.deserialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "    def test_deserialize_no_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(None, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        result = typ.deserialize(node, ('a',))",
            "        self.assertEqual(result, ['a'])",
            "",
            "    def test_deserialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None, exc='Wrong')",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.deserialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_drop(self):",
            "        from colander import drop",
            "",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, (drop,))",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_not_iterable(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" is not iterable')",
            "        self.assertEqual(e.node, node)",
            "",
            "    def test_serialize_not_iterable_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, [None])",
            "",
            "    def test_serialize_string_accept_scalar(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(accept_scalar=True)",
            "        node.children = [node]",
            "        result = typ.serialize(node, 'abc')",
            "        self.assertEqual(result, ['abc'])",
            "",
            "    def test_serialize_no_subnodes(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [node]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ())",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_ok(self):",
            "        node = DummySchemaNode(None)",
            "        node.children = [DummySchemaNode(None, name='a')]",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, ('a',))",
            "        self.assertEqual(result, ['a'])",
            "",
            "    def test_serialize_subnodes_raise(self):",
            "        node = DummySchemaNode(None, exc='Wrong')",
            "        typ = self._makeOne()",
            "        node.children = [node]",
            "        e = invalid_exc(typ.serialize, node, ('1', '2'))",
            "        self.assertEqual(e.msg, None)",
            "        self.assertEqual(len(e.children), 2)",
            "",
            "    def test_flatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2])",
            "        self.assertEqual(result, {'node.0': 1, 'node.1': 2})",
            "",
            "    def test_flatten_with_integer(self):",
            "        from colander import Integer",
            "",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(Integer(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2])",
            "        self.assertEqual(result, {'node.0': 1, 'node.1': 2})",
            "",
            "    def test_flatten_listitem(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.flatten(node, [1, 2], listitem=True)",
            "        self.assertEqual(result, {'0': 1, '1': 2})",
            "",
            "    def test_unflatten(self):",
            "        node = DummySchemaNode(None, name='node')",
            "        node.children = [DummySchemaNode(DummyType(), name='foo')]",
            "        typ = self._makeOne()",
            "        result = typ.unflatten(",
            "            node, ['node.0', 'node.1'], {'node.0': 'a', 'node.1': 'b'}",
            "        )",
            "        self.assertEqual(result, ['a', 'b'])",
            "",
            "    def test_setvalue(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='seq1')",
            "        node2 = DummySchemaNode(typ, name='seq2')",
            "        node1.children = [node2]",
            "        node2.children = DummySchemaNode(None, name='items')",
            "        appstruct = [[1, 2], [3, 4]]",
            "        typ.set_value(node1, appstruct, '1.0', 34)",
            "        self.assertEqual(appstruct, [[1, 2], [34, 4]])",
            "",
            "    def test_getvalue(self):",
            "        typ = self._makeOne()",
            "        node1 = DummySchemaNode(typ, name='seq1')",
            "        node2 = DummySchemaNode(typ, name='seq2')",
            "        node1.children = [node2]",
            "        node2.children = DummySchemaNode(None, name='items')",
            "        appstruct = [[1, 2], [3, 4]]",
            "        self.assertEqual(typ.get_value(node1, appstruct, '1'), [3, 4])",
            "        self.assertEqual(typ.get_value(node1, appstruct, '1.0'), 3)",
            "",
            "    def test_cstruct_children_cstruct_is_null(self):",
            "        from colander import null",
            "        from colander import SequenceItems",
            "",
            "        typ = self._makeOne()",
            "        result = typ.cstruct_children(None, null)",
            "        self.assertEqual(result, SequenceItems([]))",
            "",
            "    def test_cstruct_children_cstruct_is_non_null(self):",
            "        from colander import SequenceItems",
            "",
            "        typ = self._makeOne()",
            "        result = typ.cstruct_children(None, ['a'])",
            "        self.assertEqual(result, SequenceItems(['a']))",
            "",
            "",
            "class TestString(unittest.TestCase):",
            "    def _makeOne(self, encoding=None, allow_empty=False):",
            "        from colander import String",
            "",
            "        return String(encoding, allow_empty)",
            "",
            "    def test_alias(self):",
            "        from colander import Str",
            "        from colander import String",
            "",
            "        self.assertEqual(Str, String)",
            "",
            "    def test_deserialize_emptystring(self):",
            "        from colander import null",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(None)",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, null)",
            "        typ = self._makeOne(None, allow_empty=True)",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, '')",
            "",
            "    def test_deserialize_uncooperative(self):",
            "        val = Uncooperative()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_unicode_from_None(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', 'utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, uni)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_nonunicode_from_None(self):",
            "        import colander",
            "",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, value)",
            "",
            "    def test_deserialize_from_utf8(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf8 = uni.encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.deserialize(node, utf8)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_from_utf16(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf16 = uni.encode('utf-16')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-16')",
            "        result = typ.deserialize(node, utf16)",
            "        self.assertEqual(result, uni)",
            "",
            "    def test_deserialize_from_nonstring_obj(self):",
            "        import colander",
            "",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, value)",
            "",
            "    def test_serialize_null(self):",
            "        from colander import null",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_serialize_emptystring(self):",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, val)",
            "",
            "    def test_serialize_uncooperative(self):",
            "        val = Uncooperative()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_nonunicode_to_None(self):",
            "        value = object()",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, value)",
            "        self.assertEqual(result, text_type(value))",
            "",
            "    def test_serialize_unicode_to_None(self):",
            "        value = text_('abc')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, value)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_serialize_to_utf8(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf8 = uni.encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.serialize(node, uni)",
            "        self.assertEqual(result, utf8)",
            "",
            "    def test_serialize_to_utf16(self):",
            "        uni = text_(b'\\xe3\\x81\\x82', encoding='utf-8')",
            "        utf16 = uni.encode('utf-16')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-16')",
            "        result = typ.serialize(node, uni)",
            "        self.assertEqual(result, utf16)",
            "",
            "    def test_serialize_string_with_high_unresolveable_high_order_chars(self):",
            "        not_utf8 = b'\\xff\\xfe\\xf8\\x00'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        e = invalid_exc(typ.serialize, node, not_utf8)",
            "        self.assertTrue('cannot be serialized' in e.msg)",
            "",
            "    def test_serialize_encoding_with_non_string_type(self):",
            "        utf8 = text_type('123').encode('utf-8')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('utf-8')",
            "        result = typ.serialize(node, 123)",
            "        self.assertEqual(result, utf8)",
            "",
            "",
            "class TestInteger(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Integer",
            "",
            "        return Integer()",
            "",
            "    def test_alias(self):",
            "        from colander import Int",
            "        from colander import Integer",
            "",
            "        self.assertEqual(Int, Integer)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        val = '1'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0')",
            "",
            "",
            "class TestFloat(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Float",
            "",
            "        return Float()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.0')",
            "",
            "    def test_serialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        val = '1.0'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, 1.0)",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1.0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.0')",
            "",
            "",
            "class TestDecimal(unittest.TestCase):",
            "    def _makeOne(self, quant=None, rounding=None, normalize=False):",
            "        from colander import Decimal",
            "",
            "        return Decimal(quant, rounding, normalize)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_zero(self):",
            "        val = 0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0')",
            "",
            "    def test_serialize_emptystring(self):",
            "        import colander",
            "",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        self.assertRaises(colander.Invalid, typ.serialize, node, val)",
            "",
            "    def test_serialize_quantize_no_rounding(self):",
            "        val = '.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01')",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.00')",
            "",
            "    def test_serialize_quantize_with_rounding_up(self):",
            "        import decimal",
            "",
            "        val = '.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01', decimal.ROUND_UP)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '0.01')",
            "",
            "    def test_serialize_normalize(self):",
            "        from decimal import Decimal",
            "",
            "        val = Decimal('1.00')",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(normalize=True)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_deserialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_deserialize_ok(self):",
            "        import decimal",
            "",
            "        val = '1.0'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.0'))",
            "",
            "    def test_deserialize_with_quantize(self):",
            "        import decimal",
            "",
            "        val = '1.00000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne('.01', decimal.ROUND_UP)",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.01'))",
            "",
            "    def test_deserialize_with_normalize(self):",
            "        from decimal import Decimal",
            "",
            "        val = '1.00'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne(normalize=True)",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, Decimal('1'))",
            "        self.assertEqual(str(result), '1')",
            "",
            "    def test_serialize_fails(self):",
            "        val = 'P'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.serialize, node, val)",
            "        self.assertTrue(e.msg)",
            "",
            "    def test_serialize_ok(self):",
            "        val = 1.0",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.0')",
            "",
            "",
            "class TestMoney(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Money",
            "",
            "        return Money()",
            "",
            "    def test_serialize_rounds_up(self):",
            "        val = '1.000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1.01')",
            "",
            "    def test_deserialize_rounds_up(self):",
            "        import decimal",
            "",
            "        val = '1.00000001'",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, val)",
            "        self.assertEqual(result, decimal.Decimal('1.01'))",
            "",
            "",
            "class TestBoolean(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean()",
            "",
            "    def test_alias(self):",
            "        from colander import Bool",
            "        from colander import Boolean",
            "",
            "        self.assertEqual(Bool, Boolean)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'false'), False)",
            "        self.assertEqual(typ.deserialize(node, 'FALSE'), False)",
            "        self.assertEqual(typ.deserialize(node, '0'), False)",
            "        self.assertEqual(typ.deserialize(node, 'true'), True)",
            "        self.assertEqual(typ.deserialize(node, 'other'), True)",
            "",
            "    def test_deserialize_unstringable(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.deserialize, node, Uncooperative())",
            "        self.assertTrue(e.msg.endswith('not a string'))",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.serialize(node, 1), 'true')",
            "        self.assertEqual(typ.serialize(node, True), 'true')",
            "        self.assertEqual(typ.serialize(node, None), 'false')",
            "        self.assertEqual(typ.serialize(node, False), 'false')",
            "",
            "",
            "class TestBooleanCustomFalseReprs(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_choices=('n', 'f'))",
            "",
            "    def test_deserialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'f'), False)",
            "        self.assertEqual(typ.deserialize(node, 'N'), False)",
            "        self.assertEqual(typ.deserialize(node, 'other'), True)",
            "",
            "",
            "class TestBooleanCustomFalseAndTrueReprs(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_choices=('n', 'f'), true_choices=('y', 't'))",
            "",
            "    def test_deserialize(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.deserialize(node, 'f'), False)",
            "        self.assertEqual(typ.deserialize(node, 'N'), False)",
            "        self.assertEqual(typ.deserialize(node, 'T'), True)",
            "        self.assertEqual(typ.deserialize(node, 'y'), True)",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, 'other')",
            "        try:",
            "            typ.deserialize(node, 'other')",
            "        except colander.Invalid as exc:",
            "            self.assertEqual(exc.msg.mapping['false_choices'], \"'n', 'f'\")",
            "            self.assertEqual(exc.msg.mapping['true_choices'], \"'y', 't'\")",
            "",
            "",
            "class TestBooleanCustomSerializations(unittest.TestCase):",
            "    def _makeOne(self):",
            "        from colander import Boolean",
            "",
            "        return Boolean(false_val='no', true_val='yes')",
            "",
            "    def test_serialize(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertEqual(typ.serialize(node, 1), 'yes')",
            "        self.assertEqual(typ.serialize(node, True), 'yes')",
            "        self.assertEqual(typ.serialize(node, None), 'no')",
            "        self.assertEqual(typ.serialize(node, False), 'no')",
            "",
            "",
            "class TestGlobalObject(unittest.TestCase):",
            "    def _makeOne(self, package=None):",
            "        from colander import GlobalObject",
            "",
            "        return GlobalObject(package)",
            "",
            "    def test_zope_dottedname_style_resolve_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._zope_dottedname_style(",
            "            None, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_zope_dottedname_style_irrresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError,",
            "            typ._zope_dottedname_style,",
            "            None,",
            "            'colander.tests.nonexisting',",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolve_relative(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        node = DummySchemaNode(None)",
            "        result = typ._zope_dottedname_style(",
            "            node, '.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__zope_dottedname_style_resolve_relative_leading_dots(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        node = DummySchemaNode(None)",
            "        result = typ._zope_dottedname_style(",
            "            node, '..tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__zope_dottedname_style_resolve_relative_is_dot(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._zope_dottedname_style(None, '.')",
            "        self.assertEqual(result, colander.tests)",
            "",
            "    def test__zope_dottedname_style_irresolveable_relative_is_dot(self):",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ._zope_dottedname_style, None, '.')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'relative name \".\" irresolveable without package',",
            "        )",
            "",
            "    def test_zope_dottedname_style_resolve_relative_nocurrentpackage(self):",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ._zope_dottedname_style, None, '.whatever')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'relative name \".whatever\" irresolveable without package',",
            "        )",
            "",
            "    def test_zope_dottedname_style_irrresolveable_relative(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander)",
            "        self.assertRaises(",
            "            ImportError, typ._zope_dottedname_style, None, '.notexisting'",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolveable_relative(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        result = typ._zope_dottedname_style(None, '.tests')",
            "        from colander import tests",
            "",
            "        self.assertEqual(result, tests)",
            "",
            "    def test__zope_dottedname_style_irresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError, typ._zope_dottedname_style, None, 'colander.fudge.bar'",
            "        )",
            "",
            "    def test__zope_dottedname_style_resolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._zope_dottedname_style(",
            "            None, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_resolve_absolute(self):",
            "        typ = self._makeOne()",
            "        result = typ._pkg_resources_style(",
            "            None, 'colander.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_irrresolveable_absolute(self):",
            "        typ = self._makeOne()",
            "        self.assertRaises(",
            "            ImportError,",
            "            typ._pkg_resources_style,",
            "            None,",
            "            'colander.tests.test_colander:nonexisting',",
            "        )",
            "",
            "    def test__pkg_resources_style_resolve_relative_startswith_colon(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._pkg_resources_style(None, ':fixture')",
            "        self.assertEqual(result, 1)",
            "",
            "    def test__pkg_resources_style_resolve_relative_startswith_dot(self):",
            "        import colander",
            "",
            "        typ = self._makeOne(package=colander)",
            "        result = typ._pkg_resources_style(",
            "            None, '.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test__pkg_resources_style_resolve_relative_is_dot(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander.tests)",
            "        result = typ._pkg_resources_style(None, '.')",
            "        self.assertEqual(result, colander.tests)",
            "",
            "    def test__pkg_resources_style_resolve_relative_nocurrentpackage(self):",
            "        typ = self._makeOne()",
            "        import colander",
            "",
            "        self.assertRaises(",
            "            colander.Invalid, typ._pkg_resources_style, None, '.whatever'",
            "        )",
            "",
            "    def test__pkg_resources_style_irrresolveable_relative(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne(package=colander)",
            "        self.assertRaises(",
            "            ImportError, typ._pkg_resources_style, None, ':notexisting'",
            "        )",
            "",
            "    def test_deserialize_None(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, None)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_notastring(self):",
            "        import colander",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        self.assertRaises(colander.Invalid, typ.deserialize, node, True)",
            "",
            "    def test_deserialize_using_pkgresources_style(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(",
            "            node, 'colander.tests.test_colander:TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_using_zope_dottedname_style(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(",
            "            node, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "        self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_style_raises(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.deserialize, node, 'cant.be.found')",
            "        self.assertEqual(",
            "            e.msg.interpolate(),",
            "            'The dotted name \"cant.be.found\" cannot be imported',",
            "        )",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_ok(self):",
            "        import colander.tests",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, colander.tests)",
            "        self.assertEqual(result, 'colander.tests')",
            "",
            "        from colander import tests",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, tests)",
            "        self.assertEqual(result, 'colander.tests')",
            "",
            "    def test_serialize_class(self):",
            "        cls = self.__class__",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, cls)",
            "        self.assertEqual(",
            "            result, 'colander.tests.test_colander.TestGlobalObject'",
            "        )",
            "",
            "    def test_deserialize_class_ok(self):",
            "        import colander",
            "",
            "        names = (",
            "            'colander.tests.test_colander.TestGlobalObject',",
            "            '.tests.test_colander.TestGlobalObject',",
            "        )",
            "        typ = self._makeOne(colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            result = typ.deserialize(node, name)",
            "            self.assertEqual(result, self.__class__)",
            "",
            "        names = ('.TestGlobalObject',)",
            "        typ = self._makeOne(colander.tests.test_colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            result = typ.deserialize(node, name)",
            "            self.assertEqual(result, self.__class__)",
            "",
            "    def test_deserialize_class_fail(self):",
            "        import colander",
            "",
            "        names = ('.test_colander.TestGlobalObject', '.TestGlobalObject')",
            "        typ = self._makeOne(colander)",
            "        node = DummySchemaNode(None)",
            "        for name in names:",
            "            e = invalid_exc(typ.deserialize, node, name)",
            "            self.assertEqual(",
            "                e.msg.interpolate(),",
            "                'The dotted name \"{0}\" cannot be imported'.format(name),",
            "            )",
            "",
            "    def test_serialize_fail(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, None)",
            "        self.assertEqual(e.msg.interpolate(), '\"None\" has no __name__')",
            "",
            "",
            "class TestDateTime(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import DateTime",
            "",
            "        return DateTime(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48)",
            "",
            "    def _today(self):",
            "        import datetime",
            "",
            "        return datetime.date.today()",
            "",
            "    def test_ctor_default_tzinfo_not_specified(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        self.assertIs(typ.default_tzinfo, iso8601.UTC)",
            "",
            "    def test_ctor_default_tzinfo_None(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        self.assertEqual(typ.default_tzinfo, None)",
            "",
            "    def test_ctor_default_tzinfo_non_None(self):",
            "        from iso8601 import iso8601",
            "",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        typ = self._makeOne(default_tzinfo=tzinfo)",
            "        self.assertEqual(typ.default_tzinfo, tzinfo)",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(",
            "            e.msg.interpolate(), '\"garbage\" is not a datetime object'",
            "        )",
            "",
            "    def test_serialize_with_date(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        expected = datetime.datetime.combine(date, datetime.time())",
            "        expected = expected.replace(tzinfo=typ.default_tzinfo).isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_naive_datetime(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.replace(tzinfo=typ.default_tzinfo).isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_naive_datetime_and_custom_format(self):",
            "        fmt = '%Y%m%d!%H%M%S'",
            "        typ = self._makeOne(format=fmt)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.replace(tzinfo=typ.default_tzinfo).strftime(fmt)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_none_tzinfo_naive_datetime(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        self.assertEqual(result, dt.isoformat())",
            "",
            "    def test_serialize_with_none_tzinfo_naive_datetime_custom_format(self):",
            "        fmt = '%Y%m%d!%H%M%S'",
            "        typ = self._makeOne(default_tzinfo=None, format=fmt)",
            "        node = DummySchemaNode(None)",
            "        dt = self._dt()",
            "        result = typ.serialize(node, dt)",
            "        self.assertEqual(result, dt.strftime(fmt))",
            "",
            "    def test_serialize_with_tzware_datetime(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_date(self):",
            "        import datetime",
            "        from iso8601 import iso8601",
            "",
            "        date = self._today()",
            "        typ = self._makeOne()",
            "        formatted = date.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, formatted)",
            "        expected = datetime.datetime.combine(result, datetime.time())",
            "        expected = expected.replace(tzinfo=iso8601.UTC)",
            "        self.assertEqual(result.isoformat(), expected.isoformat())",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_slashes_invalid(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, '2013/05/31')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_success(self):",
            "        from iso8601 import iso8601",
            "",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), iso)",
            "",
            "    def test_deserialize_datetime_with_custom_format(self):",
            "        from iso8601 import iso8601",
            "",
            "        fmt = '%Y%m%d.%H%M%S'",
            "        typ = self._makeOne(format=fmt)",
            "        dt = self._dt()",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        dt = dt.replace(tzinfo=tzinfo)",
            "        expected = dt.strftime(fmt)",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, expected)",
            "        self.assertEqual(result.strftime(fmt), expected)",
            "",
            "    def test_deserialize_naive_with_default_tzinfo(self):",
            "        from iso8601 import iso8601",
            "",
            "        tzinfo = iso8601.FixedOffset(1, 0, 'myname')",
            "        typ = self._makeOne(default_tzinfo=tzinfo)",
            "        dt = self._dt()",
            "        dt_with_tz = dt.replace(tzinfo=tzinfo)",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt_with_tz.isoformat())",
            "",
            "    def test_deserialize_none_tzinfo(self):",
            "        typ = self._makeOne(default_tzinfo=None)",
            "        dt = self._dt()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.isoformat())",
            "        self.assertEqual(result.tzinfo, None)",
            "",
            "",
            "class TestDate(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Date",
            "",
            "        return Date(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48)",
            "",
            "    def _today(self):",
            "        import datetime",
            "",
            "        return datetime.date.today()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(e.msg.interpolate(), '\"garbage\" is not a date object')",
            "",
            "    def test_serialize_with_date(self):",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        expected = date.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_datetime(self):",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.date().isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_invalid_weird(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, '10-10-10-10')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_success_date(self):",
            "        typ = self._makeOne()",
            "        date = self._today()",
            "        iso = date.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), iso)",
            "",
            "    def test_deserialize_success_datetime(self):",
            "        dt = self._dt()",
            "        typ = self._makeOne()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.date().isoformat())",
            "",
            "    def test_serialize_date_with_custom_format(self):",
            "        fmt = '%m,%Y,%d'",
            "        typ = self._makeOne(format=fmt)",
            "        date = self._today()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, date)",
            "        self.assertEqual(result, date.strftime(fmt))",
            "",
            "    def test_deserialize_date_with_custom_format(self):",
            "        date = self._today()",
            "        fmt = '%d/%m/%Y'",
            "        typ = self._makeOne(format=fmt)",
            "        formatted = date.strftime(fmt)",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, formatted)",
            "        self.assertEqual(result, date)",
            "",
            "",
            "class TestTime(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import Time",
            "",
            "        return Time(*arg, **kw)",
            "",
            "    def _dt(self):",
            "        import datetime",
            "",
            "        return datetime.datetime(2010, 4, 26, 10, 48, 0, 424242)",
            "",
            "    def _now(self):",
            "        import datetime",
            "",
            "        return datetime.datetime.now().time()",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_none(self):",
            "        import colander",
            "",
            "        val = None",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_serialize_with_garbage(self):",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        e = invalid_exc(typ.serialize, node, 'garbage')",
            "        self.assertEqual(e.msg.interpolate(), '\"garbage\" is not a time object')",
            "",
            "    def test_serialize_with_time(self):",
            "        typ = self._makeOne()",
            "        time = self._now()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, time)",
            "        expected = time.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_zero_time(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        time = datetime.time(0)",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, time)",
            "        expected = time.isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_with_datetime(self):",
            "        typ = self._makeOne()",
            "        dt = self._dt()",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, dt)",
            "        expected = dt.time().isoformat()",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_deserialize_invalid_ParseError(self):",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        e = invalid_exc(typ.deserialize, node, 'garbage')",
            "        self.assertTrue('Invalid' in e.msg)",
            "",
            "    def test_deserialize_three_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00:11')",
            "        self.assertEqual(result, datetime.time(11, 0, 11))",
            "",
            "    def test_deserialize_four_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00:11.424242')",
            "        self.assertEqual(result, datetime.time(11, 0, 11, 424242))",
            "",
            "    def test_deserialize_two_digit_string(self):",
            "        import datetime",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '11:00')",
            "        self.assertEqual(result, datetime.time(11, 0))",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, colander.null)",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_empty(self):",
            "        import colander",
            "",
            "        node = DummySchemaNode(None)",
            "        typ = self._makeOne()",
            "        result = typ.deserialize(node, '')",
            "        self.assertEqual(result, colander.null)",
            "",
            "    def test_deserialize_missing_seconds(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, '10:12')",
            "        self.assertEqual(result, datetime.time(10, 12))",
            "",
            "    def test_deserialize_success_time(self):",
            "        import datetime",
            "",
            "        typ = self._makeOne()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, '10:12:13')",
            "        self.assertEqual(result, datetime.time(10, 12, 13))",
            "",
            "    def test_deserialize_success_datetime(self):",
            "        dt = self._dt()",
            "        typ = self._makeOne()",
            "        iso = dt.isoformat()",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, iso)",
            "        self.assertEqual(result.isoformat(), dt.time().isoformat())",
            "",
            "",
            "class TestEnum(unittest.TestCase):",
            "    def _makeOne(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 0",
            "            green = 1",
            "            blue = 2",
            "",
            "        typ = colander.Enum(DummyEnum)",
            "        return DummyEnum, typ",
            "",
            "    def _makeOneIntVal(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 0",
            "            green = 1",
            "            blue = 2",
            "",
            "        typ = colander.Enum(DummyEnum, attr='value', typ=colander.Integer())",
            "        return DummyEnum, typ",
            "",
            "    def _makeOneStrVal(self):",
            "        import colander",
            "        import enum",
            "",
            "        class DummyEnum(enum.Enum):",
            "            red = 'RED'",
            "            green = 'GREEN'",
            "            blue = 'BLUE'",
            "",
            "        typ = colander.Enum(DummyEnum, attr='value', typ=colander.String())",
            "        return DummyEnum, typ",
            "",
            "    def test_non_unique_failure(self):",
            "        import colander",
            "        import enum",
            "",
            "        class NonUniqueEnum(enum.Enum):",
            "            one = 1",
            "            other = 1",
            "",
            "        self.assertRaises(",
            "            ValueError,",
            "            colander.Enum,",
            "            NonUniqueEnum,",
            "            attr='value',",
            "            typ=colander.Integer(),",
            "        )",
            "",
            "    def test_non_unique_failure2(self):",
            "        import colander",
            "        import enum",
            "",
            "        class NonUniqueEnum(enum.Enum):",
            "            some = (1, 1)",
            "            other = (1, 2)",
            "",
            "            def __init__(self, val0, val1):",
            "                self.val0 = val0",
            "                self.val1 = val1",
            "",
            "        self.assertRaises(",
            "            ValueError,",
            "            colander.Enum,",
            "            NonUniqueEnum,",
            "            attr='val0',",
            "            typ=colander.Integer(),",
            "        )",
            "",
            "    def test_serialize_null(self):",
            "        import colander",
            "",
            "        e, typ = self._makeOne()",
            "        val = colander.null",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertIs(result, colander.null)",
            "",
            "    def test_serialize_name(self):",
            "        e, typ = self._makeOne()",
            "        val = e.red",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, 'red')",
            "",
            "    def test_serialize_value_int(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = e.green",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, '1')",
            "",
            "    def test_serialize_value_str(self):",
            "        e, typ = self._makeOneStrVal()",
            "        val = e.blue",
            "        node = DummySchemaNode(None)",
            "        result = typ.serialize(node, val)",
            "        self.assertEqual(result, 'BLUE')",
            "",
            "    def test_serialize_failure(self):",
            "        e, typ = self._makeOne()",
            "        val = 'not a enum'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.serialize, node, val)",
            "",
            "    def test_deserialize_null(self):",
            "        import colander",
            "",
            "        e, typ = self._makeOne()",
            "        val = ''",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, colander.null)",
            "",
            "    def test_deserialize_name(self):",
            "        e, typ = self._makeOne()",
            "        val = 'green'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.green)",
            "",
            "    def test_deserialize_value_int(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = '2'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.blue)",
            "",
            "    def test_deserialize_value_str(self):",
            "        e, typ = self._makeOneStrVal()",
            "        val = 'BLUE'",
            "        node = DummySchemaNode(None)",
            "        result = typ.deserialize(node, val)",
            "        self.assertIs(result, e.blue)",
            "",
            "    def test_deserialize_failure(self):",
            "        e, typ = self._makeOne()",
            "        val = 'not a enum'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.deserialize, node, val)",
            "",
            "    def test_deserialize_failure_typ(self):",
            "        e, typ = self._makeOneIntVal()",
            "        val = 'not a int'",
            "        node = DummySchemaNode(None)",
            "        invalid_exc(typ.deserialize, node, val)",
            "",
            "",
            "class TestSchemaNode(unittest.TestCase):",
            "    def _makeOne(self, *arg, **kw):",
            "        from colander import SchemaNode",
            "",
            "        return SchemaNode(*arg, **kw)",
            "",
            "    def test_new_sets_order(self):",
            "        node = self._makeOne(None)",
            "        self.assertTrue(hasattr(node, '_order'))",
            "",
            "    def test_ctor_no_title(self):",
            "        child = DummySchemaNode(None, name='fred')",
            "        node = self._makeOne(",
            "            None,",
            "            child,",
            "            validator=1,",
            "            default=2,",
            "            name='name_a',",
            "            missing='missing',",
            "        )",
            "        self.assertEqual(node.typ, None)",
            "        self.assertEqual(node.children, [child])",
            "        self.assertEqual(node.validator, 1)",
            "        self.assertEqual(node.default, 2)",
            "        self.assertEqual(node.missing, 'missing')",
            "        self.assertEqual(node.name, 'name_a')",
            "        self.assertEqual(node.title, 'Name A')",
            "",
            "    def test_ctor_with_title(self):",
            "        child = DummySchemaNode(None, name='fred')",
            "        node = self._makeOne(",
            "            None, child, validator=1, default=2, name='name', title='title'",
            "        )",
            "        self.assertEqual(node.typ, None)",
            "        self.assertEqual(node.children, [child])",
            "        self.assertEqual(node.validator, 1)",
            "        self.assertEqual(node.default, 2)",
            "        self.assertEqual(node.name, 'name')",
            "        self.assertEqual(node.title, 'title')",
            "",
            "    def test_ctor_with_description(self):",
            "        node = self._makeOne(",
            "            None,",
            "            validator=1,",
            "            default=2,",
            "            name='name',",
            "            title='title',",
            "            description='desc',",
            "        )",
            "        self.assertEqual(node.description, 'desc')",
            "",
            "    def test_ctor_with_widget(self):",
            "        node = self._makeOne(None, widget='abc')",
            "        self.assertEqual(node.widget, 'abc')",
            "",
            "    def test_ctor_with_preparer(self):",
            "        node = self._makeOne(None, preparer='abc')",
            "        self.assertEqual(node.preparer, 'abc')",
            "",
            "    def test_ctor_without_preparer(self):",
            "        node = self._makeOne(None)",
            "        self.assertEqual(node.preparer, None)",
            "",
            "    def test_ctor_with_unknown_kwarg(self):",
            "        node = self._makeOne(None, foo=1)",
            "        self.assertEqual(node.foo, 1)",
            "",
            "    def test_ctor_with_kwarg_typ(self):",
            "        node = self._makeOne(typ='foo')",
            "        self.assertEqual(node.typ, 'foo')",
            "",
            "    def test_ctor_children_kwarg_typ(self):",
            "        subnode1 = DummySchemaNode(None, name='sub1')",
            "        subnode2 = DummySchemaNode(None, name='sub2')",
            "        node = self._makeOne(subnode1, subnode2, typ='foo')",
            "        self.assertEqual(node.children, [subnode1, subnode2])",
            "",
            "    def test_ctor_without_type(self):",
            "        self.assertRaises(NotImplementedError, self._makeOne)",
            "",
            "    def test_required_true(self):",
            "        node = self._makeOne(None)",
            "        self.assertEqual(node.required, True)",
            "",
            "    def test_required_false(self):",
            "        node = self._makeOne(None, missing=1)",
            "        self.assertEqual(node.required, False)",
            "",
            "    def test_required_deferred(self):",
            "        from colander import deferred",
            "",
            "        node = self._makeOne(None, missing=deferred(lambda: '123'))",
            "        self.assertEqual(node.required, True)",
            "",
            "    def test_deserialize_no_validator(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.deserialize(1)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_deserialize_with_preparer(self):",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer(value):",
            "            return 'prepared_' + value",
            "",
            "        def validator(node, value):",
            "            if not value.startswith('prepared'):",
            "                raise Invalid(node, 'not prepared')  # pragma: no cover",
            "",
            "        node = self._makeOne(typ, preparer=preparer, validator=validator)",
            "        self.assertEqual(node.deserialize('value'), 'prepared_value')",
            "",
            "    def test_deserialize_with_multiple_preparers(self):",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer1(value):",
            "            return 'prepared1_' + value",
            "",
            "        def preparer2(value):",
            "            return 'prepared2_' + value",
            "",
            "        def validator(node, value):",
            "            if not value.startswith('prepared2_prepared1'):",
            "                raise Invalid(node, 'not prepared')  # pragma: no cover",
            "",
            "        node = self._makeOne(",
            "            typ, preparer=[preparer1, preparer2], validator=validator",
            "        )",
            "        self.assertEqual(",
            "            node.deserialize('value'), 'prepared2_prepared1_value'",
            "        )",
            "",
            "    def test_deserialize_preparer_before_missing_check(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "",
            "        def preparer(value):",
            "            return null",
            "",
            "        node = self._makeOne(typ, preparer=preparer)",
            "        e = invalid_exc(node.deserialize, 1)",
            "        self.assertEqual(e.msg, 'Required')",
            "",
            "    def test_deserialize_with_validator(self):",
            "        typ = DummyType()",
            "        validator = DummyValidator(msg='Wrong')",
            "        node = self._makeOne(typ, validator=validator)",
            "        e = invalid_exc(node.deserialize, 1)",
            "        self.assertEqual(e.msg, 'Wrong')",
            "",
            "    def test_deserialize_with_unbound_validator(self):",
            "        from colander import Invalid",
            "        from colander import deferred",
            "        from colander import UnboundDeferredError",
            "",
            "        typ = DummyType()",
            "",
            "        def validator(node, kw):",
            "            def _validate(node, value):",
            "                node.raise_invalid('Invalid')",
            "",
            "            return _validate",
            "",
            "        node = self._makeOne(typ, validator=deferred(validator))",
            "        self.assertRaises(UnboundDeferredError, node.deserialize, None)",
            "        self.assertRaises(Invalid, node.bind(foo='foo').deserialize, None)",
            "",
            "    def test_deserialize_value_is_null_no_missing(self):",
            "        from colander import null",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        self.assertRaises(Invalid, node.deserialize, null)",
            "",
            "    def test_deserialize_value_is_null_with_missing(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = 'abc'",
            "        self.assertEqual(node.deserialize(null), 'abc')",
            "",
            "    def test_deserialize_value_is_null_with_missing_msg(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ, missing_msg='Missing')",
            "        e = invalid_exc(node.deserialize, null)",
            "        self.assertEqual(e.msg, 'Missing')",
            "",
            "    def test_deserialize_value_with_interpolated_missing_msg(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(",
            "            typ, missing_msg='Missing attribute ${title}', name='name_a'",
            "        )",
            "        e = invalid_exc(node.deserialize, null)",
            "        self.assertEqual(e.msg.interpolate(), 'Missing attribute Name A')",
            "",
            "    def test_deserialize_noargs_uses_default(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = 'abc'",
            "        self.assertEqual(node.deserialize(), 'abc')",
            "",
            "    def test_deserialize_null_can_be_used_as_missing(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = null",
            "        self.assertEqual(node.deserialize(null), null)",
            "",
            "    def test_deserialize_appstruct_deferred(self):",
            "        from colander import null",
            "        from colander import deferred",
            "        from colander import Invalid",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.missing = deferred(lambda: '123')",
            "        self.assertRaises(Invalid, node.deserialize, null)",
            "",
            "    def test_serialize(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.serialize(1)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_value_is_null_no_default(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        result = node.serialize(null)",
            "        self.assertEqual(result, null)",
            "",
            "    def test_serialize_value_is_null_with_default(self):",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = 1",
            "        result = node.serialize(null)",
            "        self.assertEqual(result, 1)",
            "",
            "    def test_serialize_noargs_uses_default(self):",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = 'abc'",
            "        self.assertEqual(node.serialize(), 'abc')",
            "",
            "    def test_serialize_default_deferred(self):",
            "        from colander import deferred",
            "        from colander import null",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        node.default = deferred(lambda: 'abc')",
            "        self.assertEqual(node.serialize(), null)",
            "",
            "    def test_add(self):",
            "        node = self._makeOne(None)",
            "        node.add(1)",
            "        self.assertEqual(node.children, [1])",
            "",
            "    def test_insert(self):",
            "        node = self._makeOne(None)",
            "        node.children = [99, 99]",
            "        node.insert(1, 'foo')",
            "        self.assertEqual(node.children, [99, 'foo', 99])",
            "",
            "    def test_repr(self):",
            "        node = self._makeOne(None, name='flub')",
            "        result = repr(node)",
            "        self.assertTrue(result.startswith('<colander.SchemaNode object at '))",
            "        self.assertTrue(result.endswith(\"(named flub)>\"))",
            "",
            "    def test___getitem__success(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        self.assertEqual(node['another'], another)",
            "",
            "    def test___getitem__failure(self):",
            "        node = self._makeOne(None)",
            "        self.assertRaises(KeyError, node.__getitem__, 'another')",
            "",
            "    def test___delitem__success(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        del node['another']",
            "        self.assertEqual(node.children, [])",
            "",
            "    def test___delitem__failure(self):",
            "        node = self._makeOne(None)",
            "        self.assertRaises(KeyError, node.__delitem__, 'another')",
            "",
            "    def test___setitem__override(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        andanother = self._makeOne(None, name='andanother')",
            "        node['another'] = andanother",
            "        self.assertEqual(node['another'], andanother)",
            "        self.assertEqual(andanother.name, 'another')",
            "",
            "    def test___setitem__no_override(self):",
            "        another = self._makeOne(None, name='another')",
            "        node = self._makeOne(None)",
            "        node['another'] = another",
            "        self.assertEqual(node['another'], another)",
            "        self.assertEqual(node.children[0], another)",
            "",
            "    def test___iter__(self):",
            "        node = self._makeOne(None)",
            "        node.children = ['a', 'b', 'c']",
            "        it = node.__iter__()",
            "        self.assertEqual(list(it), ['a', 'b', 'c'])",
            "",
            "    def test___contains__(self):",
            "        node = self._makeOne(None)",
            "        another = self._makeOne(None, name='another')",
            "        node.add(another)",
            "        self.assertEqual('another' in node, True)",
            "        self.assertEqual('b' in node, False)",
            "",
            "    def test_clone(self):",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "        outer_node = self._makeOne(outer_typ, name='outer')",
            "        inner_node = self._makeOne(inner_typ, name='inner')",
            "        outer_node.foo = 1",
            "        inner_node.foo = 2",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.clone()",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.typ, outer_typ)",
            "        self.assertEqual(outer_clone.name, 'outer')",
            "        self.assertEqual(outer_node.foo, 1)",
            "        self.assertEqual(len(outer_clone.children), 1)",
            "        inner_clone = outer_clone.children[0]",
            "        self.assertFalse(inner_clone is inner_node)",
            "        self.assertEqual(inner_clone.typ, inner_typ)",
            "        self.assertEqual(inner_clone.name, 'inner')",
            "        self.assertEqual(inner_clone.foo, 2)",
            "",
            "    def test_clone_with_modified_schema_instance(self):",
            "        import colander",
            "",
            "        class Schema(colander.MappingSchema):",
            "            n1 = colander.SchemaNode(colander.String())",
            "            n2 = colander.SchemaNode(colander.String())",
            "",
            "        def compare_children(schema, cloned):",
            "            # children of the clone must match the cloned node's children and",
            "            # have to be clones themselves.",
            "            self.assertEqual(len(schema.children), len(cloned.children))",
            "            for child, child_clone in zip(schema.children, cloned.children):",
            "                self.assertIsNot(child, child_clone)",
            "                for name in child.__dict__.keys():",
            "                    self.assertEqual(",
            "                        getattr(child, name), getattr(child_clone, name)",
            "                    )",
            "",
            "        # add a child node before cloning",
            "        schema = Schema()",
            "        schema.add(colander.SchemaNode(colander.String(), name='n3'))",
            "        compare_children(schema, schema.clone())",
            "        # remove a child node before cloning",
            "        schema = Schema()",
            "        del schema['n1']",
            "        compare_children(schema, schema.clone())",
            "        # reorder children before cloning",
            "        schema = Schema()",
            "        schema.children = list(reversed(schema.children))",
            "        compare_children(schema, schema.clone())",
            "",
            "    def test_clone_mapping_references(self):",
            "        import colander",
            "",
            "        class Schema(colander.MappingSchema):",
            "            n1 = colander.SchemaNode(colander.Mapping(unknown='preserve'))",
            "",
            "        foo = {\"n1\": {\"bar\": {\"baz\": \"qux\"}}}",
            "        bar = Schema().serialize(foo)",
            "        bar[\"n1\"][\"bar\"][\"baz\"] = \"foobar\"",
            "        self.assertEqual(foo[\"n1\"][\"bar\"][\"baz\"], \"qux\")",
            "",
            "    def test_bind(self):",
            "        from colander import deferred",
            "",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "",
            "        def dv(node, kw):",
            "            self.assertTrue(node.name in ['outer', 'inner'])",
            "            self.assertTrue('a' in kw)",
            "            return '123'",
            "",
            "        dv = deferred(dv)",
            "        outer_node = self._makeOne(outer_typ, name='outer', missing=dv)",
            "        inner_node = self._makeOne(",
            "            inner_typ, name='inner', validator=dv, missing=dv",
            "        )",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.bind(a=1)",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.missing, '123')",
            "        inner_clone = outer_clone.children[0]",
            "        self.assertFalse(inner_clone is inner_node)",
            "        self.assertEqual(inner_clone.missing, '123')",
            "        self.assertEqual(inner_clone.validator, '123')",
            "",
            "    def test_bind_with_after_bind(self):",
            "        from colander import deferred",
            "",
            "        inner_typ = DummyType()",
            "        outer_typ = DummyType()",
            "",
            "        def dv(node, kw):",
            "            self.assertTrue(node.name in ['outer', 'inner'])",
            "            self.assertTrue('a' in kw)",
            "            return '123'",
            "",
            "        dv = deferred(dv)",
            "",
            "        def remove_inner(node, kw):",
            "            self.assertEqual(kw, {'a': 1})",
            "            del node['inner']",
            "",
            "        outer_node = self._makeOne(",
            "            outer_typ, name='outer', missing=dv, after_bind=remove_inner",
            "        )",
            "        inner_node = self._makeOne(",
            "            inner_typ, name='inner', validator=dv, missing=dv",
            "        )",
            "        outer_node.children = [inner_node]",
            "        outer_clone = outer_node.bind(a=1)",
            "        self.assertFalse(outer_clone is outer_node)",
            "        self.assertEqual(outer_clone.missing, '123')",
            "        self.assertEqual(len(outer_clone.children), 0)",
            "        self.assertEqual(len(outer_node.children), 1)",
            "",
            "    def test_declarative_name_reassignment(self):",
            "        # see https://github.com/Pylons/colander/issues/39",
            "        import colander",
            "",
            "        class FnordSchema(colander.Schema):",
            "            fnord = colander.SchemaNode(",
            "                colander.Sequence(),",
            "                colander.SchemaNode(colander.Integer(), name=''),",
            "                name=\"fnord[]\",",
            "            )",
            "",
            "        schema = FnordSchema()",
            "        self.assertEqual(schema['fnord[]'].name, 'fnord[]')",
            "",
            "    def test_cstruct_children(self):",
            "        typ = DummyType()",
            "        typ.cstruct_children = lambda *arg: ['foo']",
            "        node = self._makeOne(typ)",
            "        self.assertEqual(node.cstruct_children(None), ['foo'])",
            "",
            "    def test_cstruct_children_warning(self):",
            "        import warnings",
            "",
            "        with warnings.catch_warnings(record=True) as w:",
            "            warnings.simplefilter('always')",
            "            typ = None",
            "            node = self._makeOne(typ)",
            "            self.assertEqual(node.cstruct_children(None), [])",
            "            self.assertEqual(len(w), 1)",
            "",
            "    def test_raise_invalid(self):",
            "        import colander",
            "",
            "        typ = DummyType()",
            "        node = self._makeOne(typ)",
            "        self.assertRaises(colander.Invalid, node.raise_invalid, 'Wrong')",
            "",
            "",
            "class TestSchemaNodeSubclassing(unittest.TestCase):",
            "    def test_subclass_uses_validator_method(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "",
            "            def validator(self, node, cstruct):",
            "                if cstruct > 10:",
            "                    self.raise_invalid('Wrong')",
            "",
            "        node = MyNode()",
            "        self.assertRaises(colander.Invalid, node.deserialize, 20)",
            "",
            "    def test_subclass_uses_missing(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "            missing = 10",
            "",
            "        node = MyNode()",
            "        result = node.deserialize(colander.null)",
            "        self.assertEqual(result, 10)",
            "",
            "    def test_subclass_uses_title(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            title = 'some title'",
            "",
            "        node = MyNode(name='my')",
            "        self.assertEqual(node.title, 'some title')",
            "",
            "    def test_subclass_title_overwritten_by_constructor(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            title = 'some title'",
            "",
            "        node = MyNode(name='my', title='other title')",
            "        self.assertEqual(node.title, 'other title')",
            "",
            "    def test_subelement_title_not_overwritten(self):",
            "        import colander",
            "",
            "        class SampleNode(colander.SchemaNode):",
            "            schema_type = colander.String",
            "            title = 'Some Title'",
            "",
            "        class SampleSchema(colander.Schema):",
            "            node = SampleNode()",
            "",
            "        schema = SampleSchema()",
            "        self.assertEqual('Some Title', schema.children[0].title)",
            "",
            "    def test_subclass_value_overridden_by_constructor(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            name = 'my'",
            "            missing = 10",
            "",
            "        node = MyNode(missing=5)",
            "        result = node.deserialize(colander.null)",
            "        self.assertEqual(result, 5)",
            "",
            "    def test_method_values_can_rely_on_binding(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            def amethod(self):",
            "                return self.bindings['request']",
            "",
            "        node = MyNode()",
            "        newnode = node.bind(request=True)",
            "        self.assertEqual(newnode.amethod(), True)",
            "",
            "    def test_nonmethod_values_can_rely_on_after_bind(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            def after_bind(self, node, kw):",
            "                self.missing = kw['missing']",
            "",
            "        node = MyNode()",
            "        newnode = node.bind(missing=10)",
            "        self.assertEqual(newnode.deserialize(colander.null), 10)",
            "",
            "    def test_deferred_methods_dont_quite_work_yet(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            @colander.deferred",
            "            def avalidator(self, node, kw):  # pragma: no cover",
            "                def _avalidator(node, cstruct):",
            "                    self.raise_invalid('Foo')",
            "",
            "                return _avalidator",
            "",
            "        node = MyNode()",
            "        self.assertRaises(TypeError, node.bind)",
            "",
            "    def test_nonmethod_values_can_be_deferred_though(self):",
            "        import colander",
            "",
            "        def _missing(node, kw):",
            "            return 10",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "            missing = colander.deferred(_missing)",
            "",
            "        node = MyNode()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize(colander.null), 10)",
            "",
            "    def test_functions_can_be_deferred(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "            @colander.deferred",
            "            def missing(node, kw):",
            "                return 10",
            "",
            "        node = MyNode()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize(colander.null), 10)",
            "",
            "    def test_nodes_can_be_deffered(self):",
            "        import colander",
            "",
            "        class MySchema(colander.MappingSchema):",
            "            @colander.deferred",
            "            def child(node, kw):",
            "                return colander.SchemaNode(colander.String(), missing='foo')",
            "",
            "        node = MySchema()",
            "        bound_node = node.bind()",
            "        self.assertEqual(bound_node.deserialize({}), {'child': 'foo'})",
            "",
            "    def test_schema_child_names_conflict_with_value_names_notused(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            title = colander.SchemaNode(colander.String())",
            "",
            "        node = MyNode()",
            "        self.assertEqual(node.title, '')",
            "",
            "    def test_schema_child_names_conflict_with_value_names_used(self):",
            "        import colander",
            "",
            "        doesntmatter = colander.SchemaNode(colander.String(), name='name')",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            wontmatter = doesntmatter",
            "",
            "        node = MyNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'], doesntmatter)",
            "",
            "    def test_schema_child_names_conflict_with_value_names_in_superclass(self):",
            "        import colander",
            "",
            "        doesntmatter = colander.SchemaNode(colander.String(), name='name')",
            "        _name = colander.SchemaNode(colander.String())",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            wontmatter = doesntmatter",
            "",
            "        class AnotherNode(MyNode):",
            "            name = _name",
            "",
            "        node = AnotherNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'], _name)",
            "",
            "    def test_schema_child_names_conflict_with_value_names_in_subclass(self):",
            "        import colander",
            "",
            "        class MyNode(colander.SchemaNode):",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "",
            "        class AnotherNode(MyNode):",
            "            schema_type = colander.Mapping",
            "            name = 'fred'",
            "            doesntmatter = colander.SchemaNode(",
            "                colander.String(), name='name', id='doesntmatter'",
            "            )",
            "",
            "        node = AnotherNode()",
            "        self.assertEqual(node.name, 'fred')",
            "        self.assertEqual(node['name'].id, 'doesntmatter')",
            "",
            "",
            "class TestMappingSchemaInheritance(unittest.TestCase):",
            "    def test_single_inheritance(self):",
            "        import colander",
            "",
            "        class Friend(colander.Schema):",
            "            rank = colander.SchemaNode(colander.Int(), id='rank')",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "            serial = colander.SchemaNode(colander.Bool(), id='serial2')",
            "",
            "        class SpecialFriend(Friend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.Int(), id='iwannacomefirst2'",
            "            )",
            "",
            "        class SuperSpecialFriend(SpecialFriend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.String(), id='iwannacomefirst1'",
            "            )",
            "            another = colander.SchemaNode(colander.String(), id='another')",
            "            serial = colander.SchemaNode(colander.Int(), id='serial1')",
            "",
            "        inst = SuperSpecialFriend()",
            "        self.assertEqual(",
            "            [x.id for x in inst.children],",
            "            ['rank', 'name', 'serial1', 'iwannacomefirst1', 'another'],",
            "        )",
            "",
            "    def test_single_inheritance_with_insert_before(self):",
            "        import colander",
            "",
            "        class Friend(colander.Schema):",
            "            rank = colander.SchemaNode(colander.Int(), id='rank')",
            "            name = colander.SchemaNode(colander.String(), id='name')",
            "            serial = colander.SchemaNode(",
            "                colander.Bool(), insert_before='name', id='serial2'",
            "            )",
            "",
            "        class SpecialFriend(Friend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.Int(), id='iwannacomefirst2'",
            "            )",
            "",
            "        class SuperSpecialFriend(SpecialFriend):",
            "            iwannacomefirst = colander.SchemaNode(",
            "                colander.String(), insert_before='rank', id='iwannacomefirst1'",
            "            )",
            "            another = colander.SchemaNode(colander.String(), id='another')",
            "            serial = colander.SchemaNode(colander.Int(), id='serial1')",
            "",
            "        inst = SuperSpecialFriend()",
            "        self.assertEqual(",
            "            [x.id for x in inst.children],",
            "            ['iwannacomefirst1', 'rank', 'serial1', 'name', 'another'],",
            "        )",
            "",
            "    def test_single_inheritance2(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int(), id='a1')",
            "            b = colander.SchemaNode(colander.Int(), id='b1')",
            "            d = colander.SchemaNode(colander.Int(), id='d1')",
            "",
            "        class Two(One):",
            "            a = colander.SchemaNode(colander.String(), id='a2')",
            "            c = colander.SchemaNode(colander.String(), id='c2')",
            "            e = colander.SchemaNode(colander.String(), id='e2')",
            "",
            "        class Three(Two):",
            "            b = colander.SchemaNode(colander.Bool(), id='b3')",
            "            d = colander.SchemaNode(colander.Bool(), id='d3')",
            "            f = colander.SchemaNode(colander.Bool(), id='f3')",
            "",
            "        inst = Three()",
            "        c = inst.children",
            "        self.assertEqual(len(c), 6)",
            "        result = [x.id for x in c]",
            "        self.assertEqual(result, ['a2', 'b3', 'd3', 'c2', 'e2', 'f3'])",
            "",
            "    def test_multiple_inheritance(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int(), id='a1')",
            "            b = colander.SchemaNode(colander.Int(), id='b1')",
            "            d = colander.SchemaNode(colander.Int(), id='d1')",
            "",
            "        class Two(colander.Schema):",
            "            a = colander.SchemaNode(colander.String(), id='a2')",
            "            c = colander.SchemaNode(colander.String(), id='c2')",
            "            e = colander.SchemaNode(colander.String(), id='e2')",
            "",
            "        class Three(Two, One):",
            "            b = colander.SchemaNode(colander.Bool(), id='b3')",
            "            d = colander.SchemaNode(colander.Bool(), id='d3')",
            "            f = colander.SchemaNode(colander.Bool(), id='f3')",
            "",
            "        inst = Three()",
            "        c = inst.children",
            "        self.assertEqual(len(c), 6)",
            "        result = [x.id for x in c]",
            "        self.assertEqual(result, ['a2', 'b3', 'd3', 'c2', 'e2', 'f3'])",
            "",
            "    def test_insert_before_failure(self):",
            "        import colander",
            "",
            "        class One(colander.Schema):",
            "            a = colander.SchemaNode(colander.Int())",
            "            b = colander.SchemaNode(colander.Int(), insert_before='c')",
            "",
            "        self.assertRaises(KeyError, One)",
            "",
            "",
            "class TestDeferred(unittest.TestCase):",
            "    def _makeOne(self, wrapped):",
            "        from colander import deferred",
            "",
            "        return deferred(wrapped)",
            "",
            "    def test_ctor(self):",
            "        wrapped = lambda: 'foo'",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.wrapped, wrapped)",
            "",
            "    def test___call__(self):",
            "        n = object()",
            "        k = object()",
            "",
            "        def wrapped(node, kw):",
            "            self.assertEqual(node, n)",
            "            self.assertEqual(kw, k)",
            "            return 'abc'",
            "",
            "        inst = self._makeOne(wrapped)",
            "        result = inst(n, k)",
            "        self.assertEqual(result, 'abc')",
            "",
            "    def test_retain_func_details(self):",
            "        def wrapped_func(node, kw):",
            "            \"\"\"Can you hear me now?\"\"\"",
            "            pass  # pragma: no cover",
            "",
            "        inst = self._makeOne(wrapped_func)",
            "        self.assertEqual(inst.__doc__, 'Can you hear me now?')",
            "        self.assertEqual(inst.__name__, 'wrapped_func')",
            "",
            "    def test_w_callable_instance_no_name(self):",
            "        class Wrapped(object):",
            "            \"\"\"CLASS\"\"\"",
            "",
            "            def __call__(self, node, kw):",
            "                \"\"\"METHOD\"\"\"",
            "                pass  # pragma: no cover",
            "",
            "        wrapped = Wrapped()",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.__doc__, wrapped.__doc__)",
            "        self.assertFalse('__name__' in inst.__dict__)",
            "",
            "    def test_w_callable_instance_no_name_or_doc(self):",
            "        class Wrapped(object):",
            "            def __call__(self, node, kw):",
            "                pass  # pragma: no cover",
            "",
            "        wrapped = Wrapped()",
            "        inst = self._makeOne(wrapped)",
            "        self.assertEqual(inst.__doc__, None)",
            "        self.assertFalse('__name__' in inst.__dict__)",
            "",
            "",
            "class TestSchema(unittest.TestCase):",
            "    def test_alias(self):",
            "        from colander import Schema",
            "        from colander import MappingSchema",
            "",
            "        self.assertEqual(Schema, MappingSchema)",
            "",
            "    def test_it(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            thing_a = colander.SchemaNode(colander.String())",
            "            thing2 = colander.SchemaNode(colander.String(), title='bar')",
            "",
            "        node = MySchema(default='abc')",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertEqual(node.default, 'abc')",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Mapping)",
            "        self.assertEqual(node.children[0].typ.__class__, colander.String)",
            "        self.assertEqual(node.children[0].title, 'Thing A')",
            "        self.assertEqual(node.children[1].title, 'bar')",
            "",
            "    def test_title_munging(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            thing1 = colander.SchemaNode(colander.String())",
            "            thing2 = colander.SchemaNode(colander.String(), title=None)",
            "            thing3 = colander.SchemaNode(colander.String(), title='')",
            "            thing4 = colander.SchemaNode(colander.String(), title='thing2')",
            "",
            "        node = MySchema()",
            "        self.assertEqual(node.children[0].title, 'Thing1')",
            "        self.assertEqual(node.children[1].title, None)",
            "        self.assertEqual(node.children[2].title, '')",
            "        self.assertEqual(node.children[3].title, 'thing2')",
            "",
            "    def test_deserialize_drop(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            a = colander.SchemaNode(colander.String())",
            "            b = colander.SchemaNode(colander.String(), missing=colander.drop)",
            "",
            "        node = MySchema()",
            "        expected = {'a': 'test'}",
            "        result = node.deserialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_serialize_drop_default(self):",
            "        import colander",
            "",
            "        class MySchema(colander.Schema):",
            "            a = colander.SchemaNode(colander.String())",
            "            b = colander.SchemaNode(colander.String(), default=colander.drop)",
            "",
            "        node = MySchema()",
            "        expected = {'a': 'foo'}",
            "        result = node.serialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.Schema(node)",
            "        self.assertEqual(schema.schema_type, colander.Mapping)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "    def test_schema_with_cloned_nodes(self):",
            "        import colander",
            "",
            "        test_node = colander.SchemaNode(colander.String())",
            "",
            "        class TestSchema(colander.Schema):",
            "            a = test_node.clone()",
            "            b = test_node.clone()",
            "",
            "        node = TestSchema()",
            "        expected = {'a': 'foo', 'b': 'bar'}",
            "        result = node.serialize(expected)",
            "        self.assertEqual(result, expected)",
            "",
            "",
            "class TestSequenceSchema(unittest.TestCase):",
            "    def test_succeed(self):",
            "        import colander",
            "",
            "        _inner = colander.SchemaNode(colander.String())",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            inner = _inner",
            "",
            "        node = MySchema()",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Sequence)",
            "        self.assertEqual(node.children[0], _inner)",
            "",
            "    def test_fail_toomany(self):",
            "        import colander",
            "",
            "        thingnode = colander.SchemaNode(colander.String())",
            "        thingnode2 = colander.SchemaNode(colander.String())",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            thing = thingnode",
            "            thing2 = thingnode2",
            "",
            "        e = invalid_exc(MySchema)",
            "        self.assertEqual(",
            "            e.msg, 'Sequence schemas must have exactly one child node'",
            "        )",
            "",
            "    def test_fail_toofew(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            pass",
            "",
            "        e = invalid_exc(MySchema)",
            "        self.assertEqual(",
            "            e.msg, 'Sequence schemas must have exactly one child node'",
            "        )",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.SequenceSchema(node)",
            "        self.assertEqual(schema.schema_type, colander.Sequence)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "    def test_deserialize_drop(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            a = colander.SchemaNode(colander.String(), missing=colander.drop)",
            "",
            "        node = MySchema()",
            "        result = node.deserialize([None])",
            "        self.assertEqual(result, [])",
            "        result = node.deserialize([colander.null])",
            "        self.assertEqual(result, [])",
            "",
            "    def test_serialize_drop_default(self):",
            "        import colander",
            "",
            "        class MySchema(colander.SequenceSchema):",
            "            a = colander.SchemaNode(colander.String(), default=colander.drop)",
            "",
            "        node = MySchema()",
            "        result = node.serialize([colander.null])",
            "        self.assertEqual(result, [])",
            "",
            "    def test_clone_with_sequence_schema(self):",
            "        import colander",
            "",
            "        thingnode = colander.SchemaNode(colander.String(), name='foo')",
            "        schema = colander.SequenceSchema(colander.Sequence(), thingnode)",
            "        clone = schema.clone()",
            "        self.assertIsNot(schema, clone)",
            "        self.assertEqual(schema.name, clone.name)",
            "        self.assertEqual(len(schema.children), len(clone.children))",
            "        self.assertIsNot(schema.children[0], clone.children[0])",
            "        self.assertEqual(schema.children[0].name, clone.children[0].name)",
            "",
            "",
            "class TestTupleSchema(unittest.TestCase):",
            "    def test_it(self):",
            "        import colander",
            "",
            "        class MySchema(colander.TupleSchema):",
            "            thing = colander.SchemaNode(colander.String())",
            "",
            "        node = MySchema()",
            "        self.assertTrue(hasattr(node, '_order'))",
            "        self.assertTrue(isinstance(node, colander.SchemaNode))",
            "        self.assertEqual(node.typ.__class__, colander.Tuple)",
            "        self.assertEqual(node.children[0].typ.__class__, colander.String)",
            "",
            "    def test_imperative_with_implicit_schema_type(self):",
            "        import colander",
            "",
            "        node = colander.SchemaNode(colander.String())",
            "        schema = colander.TupleSchema(node)",
            "        self.assertEqual(schema.schema_type, colander.Tuple)",
            "        self.assertEqual(schema.children[0], node)",
            "",
            "",
            "class TestFunctional(object):",
            "    def test_deserialize_ok(self):",
            "        import colander.tests",
            "",
            "        data = {",
            "            'int': '10',",
            "            'ob': 'colander.tests',",
            "            'seq': [('1', 's'), ('2', 's'), ('3', 's'), ('4', 's')],",
            "            'seq2': [{'key': '1', 'key2': '2'}, {'key': '3', 'key2': '4'}],",
            "            'tup': ('1', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.deserialize(data)",
            "        self.assertEqual(result['int'], 10)",
            "        self.assertEqual(result['ob'], colander.tests)",
            "        self.assertEqual(",
            "            result['seq'], [(1, 's'), (2, 's'), (3, 's'), (4, 's')]",
            "        )",
            "        self.assertEqual(",
            "            result['seq2'], [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}]",
            "        )",
            "        self.assertEqual(result['tup'], (1, 's'))",
            "",
            "    def test_flatten_ok(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.flatten(appstruct)",
            "",
            "        expected = {",
            "            'schema.seq.2.tupstring': 's',",
            "            'schema.seq2.0.key2': 2,",
            "            'schema.ob': colander.tests,",
            "            'schema.seq2.1.key2': 4,",
            "            'schema.seq.1.tupstring': 's',",
            "            'schema.seq2.0.key': 1,",
            "            'schema.seq.1.tupint': 2,",
            "            'schema.seq.0.tupstring': 's',",
            "            'schema.seq.3.tupstring': 's',",
            "            'schema.seq.3.tupint': 4,",
            "            'schema.seq2.1.key': 3,",
            "            'schema.int': 10,",
            "            'schema.seq.0.tupint': 1,",
            "            'schema.tup.tupint': 1,",
            "            'schema.tup.tupstring': 's',",
            "            'schema.seq.2.tupint': 3,",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_flatten_mapping_has_no_name(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        result = schema.flatten(appstruct)",
            "",
            "        expected = {",
            "            'seq.2.tupstring': 's',",
            "            'seq2.0.key2': 2,",
            "            'ob': colander.tests,",
            "            'seq2.1.key2': 4,",
            "            'seq.1.tupstring': 's',",
            "            'seq2.0.key': 1,",
            "            'seq.1.tupint': 2,",
            "            'seq.0.tupstring': 's',",
            "            'seq.3.tupstring': 's',",
            "            'seq.3.tupint': 4,",
            "            'seq2.1.key': 3,",
            "            'int': 10,",
            "            'seq.0.tupint': 1,",
            "            'tup.tupint': 1,",
            "            'tup.tupstring': 's',",
            "            'seq.2.tupint': 3,",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_unflatten_ok(self):",
            "        import colander",
            "",
            "        fstruct = {",
            "            'schema.seq.2.tupstring': 's',",
            "            'schema.seq2.0.key2': 2,",
            "            'schema.ob': colander.tests,",
            "            'schema.seq2.1.key2': 4,",
            "            'schema.seq.1.tupstring': 's',",
            "            'schema.seq2.0.key': 1,",
            "            'schema.seq.1.tupint': 2,",
            "            'schema.seq.0.tupstring': 's',",
            "            'schema.seq.3.tupstring': 's',",
            "            'schema.seq.3.tupint': 4,",
            "            'schema.seq2.1.key': 3,",
            "            'schema.int': 10,",
            "            'schema.seq.0.tupint': 1,",
            "            'schema.tup.tupint': 1,",
            "            'schema.tup.tupstring': 's',",
            "            'schema.seq.2.tupint': 3,",
            "        }",
            "        schema = self._makeSchema()",
            "        result = schema.unflatten(fstruct)",
            "",
            "        expected = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_unflatten_mapping_no_name(self):",
            "        import colander",
            "",
            "        fstruct = {",
            "            'seq.2.tupstring': 's',",
            "            'seq2.0.key2': 2,",
            "            'ob': colander.tests,",
            "            'seq2.1.key2': 4,",
            "            'seq.1.tupstring': 's',",
            "            'seq2.0.key': 1,",
            "            'seq.1.tupint': 2,",
            "            'seq.0.tupstring': 's',",
            "            'seq.3.tupstring': 's',",
            "            'seq.3.tupint': 4,",
            "            'seq2.1.key': 3,",
            "            'int': 10,",
            "            'seq.0.tupint': 1,",
            "            'tup.tupint': 1,",
            "            'tup.tupstring': 's',",
            "            'seq.2.tupint': 3,",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        result = schema.unflatten(fstruct)",
            "",
            "        expected = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "",
            "        for k, v in expected.items():",
            "            self.assertEqual(result[k], v)",
            "        for k, v in result.items():",
            "            self.assertEqual(expected[k], v)",
            "",
            "    def test_flatten_unflatten_roundtrip(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema(name='')",
            "        self.assertEqual(",
            "            schema.unflatten(schema.flatten(appstruct)), appstruct",
            "        )",
            "",
            "    def test_set_value(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        schema.set_value(appstruct, 'seq2.1.key', 6)",
            "        self.assertEqual(appstruct['seq2'][1], {'key': 6, 'key2': 4})",
            "",
            "    def test_get_value(self):",
            "        import colander",
            "",
            "        appstruct = {",
            "            'int': 10,",
            "            'ob': colander.tests,",
            "            'seq': [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "            'seq2': [{'key': 1, 'key2': 2}, {'key': 3, 'key2': 4}],",
            "            'tup': (1, 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        self.assertEqual(",
            "            schema.get_value(appstruct, 'seq'),",
            "            [(1, 's'), (2, 's'), (3, 's'), (4, 's')],",
            "        )",
            "        self.assertEqual(schema.get_value(appstruct, 'seq2.1.key'), 3)",
            "",
            "    def test_invalid_asdict(self):",
            "        expected = {",
            "            'schema.int': '20 is greater than maximum value 10',",
            "            'schema.ob': 'The dotted name \"no.way.this.exists\" '",
            "            'cannot be imported',",
            "            'schema.seq.0.0': '\"q\" is not a number',",
            "            'schema.seq.1.0': '\"w\" is not a number',",
            "            'schema.seq.2.0': '\"e\" is not a number',",
            "            'schema.seq.3.0': '\"r\" is not a number',",
            "            'schema.seq2.0.key': '\"t\" is not a number',",
            "            'schema.seq2.0.key2': '\"y\" is not a number',",
            "            'schema.seq2.1.key': '\"u\" is not a number',",
            "            'schema.seq2.1.key2': '\"i\" is not a number',",
            "            'schema.tup.0': '\"s\" is not a number',",
            "        }",
            "        data = {",
            "            'int': '20',",
            "            'ob': 'no.way.this.exists',",
            "            'seq': [('q', 's'), ('w', 's'), ('e', 's'), ('r', 's')],",
            "            'seq2': [{'key': 't', 'key2': 'y'}, {'key': 'u', 'key2': 'i'}],",
            "            'tup': ('s', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        e = invalid_exc(schema.deserialize, data)",
            "        errors = e.asdict()",
            "        self.assertEqual(errors, expected)",
            "",
            "    def test_invalid_asdict_translation_callback(self):",
            "        from translationstring import TranslationString",
            "",
            "        expected = {",
            "            'schema.int': 'translated',",
            "            'schema.ob': 'translated',",
            "            'schema.seq.0.0': 'translated',",
            "            'schema.seq.1.0': 'translated',",
            "            'schema.seq.2.0': 'translated',",
            "            'schema.seq.3.0': 'translated',",
            "            'schema.seq2.0.key': 'translated',",
            "            'schema.seq2.0.key2': 'translated',",
            "            'schema.seq2.1.key': 'translated',",
            "            'schema.seq2.1.key2': 'translated',",
            "            'schema.tup.0': 'translated',",
            "        }",
            "        data = {",
            "            'int': '20',",
            "            'ob': 'no.way.this.exists',",
            "            'seq': [('q', 's'), ('w', 's'), ('e', 's'), ('r', 's')],",
            "            'seq2': [{'key': 't', 'key2': 'y'}, {'key': 'u', 'key2': 'i'}],",
            "            'tup': ('s', 's'),",
            "        }",
            "        schema = self._makeSchema()",
            "        e = invalid_exc(schema.deserialize, data)",
            "",
            "        def translation_function(string):",
            "            return TranslationString('translated')",
            "",
            "        errors = e.asdict(translate=translation_function)",
            "        self.assertEqual(errors, expected)",
            "",
            "",
            "class TestImperative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        integer = colander.SchemaNode(",
            "            colander.Integer(), name='int', validator=colander.Range(0, 10)",
            "        )",
            "",
            "        ob = colander.SchemaNode(",
            "            colander.GlobalObject(package=colander), name='ob'",
            "        )",
            "",
            "        tup = colander.SchemaNode(",
            "            colander.Tuple(),",
            "            colander.SchemaNode(colander.Integer(), name='tupint'),",
            "            colander.SchemaNode(colander.String(), name='tupstring'),",
            "            name='tup',",
            "        )",
            "",
            "        seq = colander.SchemaNode(colander.Sequence(), tup, name='seq')",
            "",
            "        seq2 = colander.SchemaNode(",
            "            colander.Sequence(),",
            "            colander.SchemaNode(",
            "                colander.Mapping(),",
            "                colander.SchemaNode(colander.Integer(), name='key'),",
            "                colander.SchemaNode(colander.Integer(), name='key2'),",
            "                name='mapping',",
            "            ),",
            "            name='seq2',",
            "        )",
            "",
            "        schema = colander.SchemaNode(",
            "            colander.Mapping(), integer, ob, tup, seq, seq2, name=name",
            "        )",
            "",
            "        return schema",
            "",
            "",
            "class TestDeclarative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        class TupleSchema(colander.TupleSchema):",
            "            tupint = colander.SchemaNode(colander.Int())",
            "            tupstring = colander.SchemaNode(colander.String())",
            "",
            "        class MappingSchema(colander.MappingSchema):",
            "            key = colander.SchemaNode(colander.Int())",
            "            key2 = colander.SchemaNode(colander.Int())",
            "",
            "        class SequenceOne(colander.SequenceSchema):",
            "            tup = TupleSchema()",
            "",
            "        class SequenceTwo(colander.SequenceSchema):",
            "            mapping = MappingSchema()",
            "",
            "        class MainSchema(colander.MappingSchema):",
            "            int = colander.SchemaNode(",
            "                colander.Int(), validator=colander.Range(0, 10)",
            "            )",
            "            ob = colander.SchemaNode(colander.GlobalObject(package=colander))",
            "            seq = SequenceOne()",
            "            tup = TupleSchema()",
            "            seq2 = SequenceTwo()",
            "",
            "        schema = MainSchema(name=name)",
            "        return schema",
            "",
            "",
            "class TestUltraDeclarative(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        class IntSchema(colander.SchemaNode):",
            "            schema_type = colander.Int",
            "",
            "        class StringSchema(colander.SchemaNode):",
            "            schema_type = colander.String",
            "",
            "        class TupleSchema(colander.TupleSchema):",
            "            tupint = IntSchema()",
            "            tupstring = StringSchema()",
            "",
            "        class MappingSchema(colander.MappingSchema):",
            "            key = IntSchema()",
            "            key2 = IntSchema()",
            "",
            "        class SequenceOne(colander.SequenceSchema):",
            "            tup = TupleSchema()",
            "",
            "        class SequenceTwo(colander.SequenceSchema):",
            "            mapping = MappingSchema()",
            "",
            "        class IntSchemaRanged(IntSchema):",
            "            validator = colander.Range(0, 10)",
            "",
            "        class GlobalObjectSchema(colander.SchemaNode):",
            "            def schema_type(self):",
            "                return colander.GlobalObject(package=colander)",
            "",
            "        class MainSchema(colander.MappingSchema):",
            "            int = IntSchemaRanged()",
            "            ob = GlobalObjectSchema()",
            "            seq = SequenceOne()",
            "            tup = TupleSchema()",
            "            seq2 = SequenceTwo()",
            "",
            "        MainSchema.name = name",
            "",
            "        schema = MainSchema()",
            "        return schema",
            "",
            "",
            "class TestDeclarativeWithInstantiate(unittest.TestCase, TestFunctional):",
            "    def _makeSchema(self, name='schema'):",
            "        import colander",
            "",
            "        # an unlikely usage, but goos to test passing",
            "        # parameters to instantiation works",
            "        @colander.instantiate(name=name)",
            "        class schema(colander.MappingSchema):",
            "            int = colander.SchemaNode(",
            "                colander.Int(), validator=colander.Range(0, 10)",
            "            )",
            "            ob = colander.SchemaNode(colander.GlobalObject(package=colander))",
            "",
            "            @colander.instantiate()",
            "            class seq(colander.SequenceSchema):",
            "                @colander.instantiate()",
            "                class tup(colander.TupleSchema):",
            "                    tupint = colander.SchemaNode(colander.Int())",
            "                    tupstring = colander.SchemaNode(colander.String())",
            "",
            "            @colander.instantiate()",
            "            class tup(colander.TupleSchema):",
            "                tupint = colander.SchemaNode(colander.Int())",
            "                tupstring = colander.SchemaNode(colander.String())",
            "",
            "            @colander.instantiate()",
            "            class seq2(colander.SequenceSchema):",
            "                @colander.instantiate()",
            "                class mapping(colander.MappingSchema):",
            "                    key = colander.SchemaNode(colander.Int())",
            "                    key2 = colander.SchemaNode(colander.Int())",
            "",
            "        return schema",
            "",
            "",
            "class Test_null(unittest.TestCase):",
            "    def test___nonzero__(self):",
            "        from colander import null",
            "",
            "        self.assertFalse(null)",
            "",
            "    def test___repr__(self):",
            "        from colander import null",
            "",
            "        self.assertEqual(repr(null), '<colander.null>')",
            "",
            "    def test_pickling(self):",
            "        from colander import null",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(null)) is null)",
            "",
            "",
            "class Test_required(unittest.TestCase):",
            "    def test___repr__(self):",
            "        from colander import required",
            "",
            "        self.assertEqual(repr(required), '<colander.required>')",
            "",
            "    def test_pickling(self):",
            "        from colander import required",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(required)) is required)",
            "",
            "",
            "class Test_drop(unittest.TestCase):",
            "    def test___repr__(self):",
            "        from colander import drop",
            "",
            "        self.assertEqual(repr(drop), '<colander.drop>')",
            "",
            "    def test_pickling(self):",
            "        from colander import drop",
            "        import pickle",
            "",
            "        self.assertTrue(pickle.loads(pickle.dumps(drop)) is drop)",
            "",
            "",
            "class Dummy(object):",
            "    pass",
            "",
            "",
            "class DummySchemaNode(object):",
            "    def __init__(self, typ, name='', exc=None, default=None):",
            "        self.typ = typ",
            "        self.name = name",
            "        self.exc = exc",
            "        self.required = default is None",
            "        self.default = default",
            "        self.children = []",
            "",
            "    def deserialize(self, val):",
            "        from colander import Invalid",
            "",
            "        if self.exc:",
            "            raise Invalid(self, self.exc)",
            "        return val",
            "",
            "    def serialize(self, val):",
            "        from colander import Invalid",
            "",
            "        if self.exc:",
            "            raise Invalid(self, self.exc)",
            "        return val",
            "",
            "    def __getitem__(self, name):",
            "        for child in self.children:",
            "            if child.name == name:",
            "                return child",
            "",
            "",
            "class DummyValidator(object):",
            "    def __init__(self, msg=None, children=None):",
            "        self.msg = msg",
            "        self.children = children",
            "",
            "    def __call__(self, node, value):",
            "        from colander import Invalid",
            "",
            "        if self.msg:",
            "            e = Invalid(node, self.msg)",
            "            self.children and e.children.extend(self.children)",
            "            raise e",
            "",
            "",
            "class Uncooperative(object):",
            "    def __str__(self):",
            "        raise ValueError('I wont cooperate')",
            "",
            "    __unicode__ = __str__",
            "",
            "",
            "class DummyType(object):",
            "    def serialize(self, node, value):",
            "        return value",
            "",
            "    def deserialize(self, node, value):",
            "        return value",
            "",
            "    def flatten(self, node, appstruct, prefix='', listitem=False):",
            "        if listitem:",
            "            key = prefix.rstrip('.')",
            "        else:",
            "            key = prefix + 'appstruct'",
            "        return {key: appstruct}",
            "",
            "    def unflatten(self, node, paths, fstruct):",
            "        assert paths == [node.name]",
            "        return fstruct[node.name]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm",
            "colander.tests.test_colander.Test_url_validator.self"
        ]
    }
}