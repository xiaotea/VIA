{
    "ipaserver/plugins/batch.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         Output('results', (list, tuple), doc='')"
            },
            "1": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     )"
            },
            "2": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    def _validate_request(self, request):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        Check that an individual request in a batch is parseable and the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        commands exists."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        if 'method' not in request:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            raise errors.RequirementError(name='method')"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        if 'params' not in request:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            raise errors.RequirementError(name='params')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        name = request['method']"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        if (name not in self.api.Command or"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                isinstance(self.api.Command[name], Local)):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            raise errors.CommandError(name=name)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        # If params are not formated as a tuple(list, dict)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        # the following lines will raise an exception"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        # that triggers an internal server error"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        # Raise a ConversionError instead to report the issue"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        # to the client"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        try:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            a, kw = request['params']"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            newkw = dict((str(k), v) for k, v in kw.items())"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            api.Command[name].args_options_2_params(*a, **newkw)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        except (AttributeError, ValueError, TypeError):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            raise errors.ConversionError("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                name='params',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                error=_(u'must contain a tuple (list, dict)'))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        except Exception as e:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+            raise errors.ConversionError("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+                name='params',"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                error=str(e))"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    def _repr_iter(self, **params):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        \"\"\""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        Iterate through the request and use the Command _repr_intr so"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        that sensitive information (passwords) is not exposed."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        In case of a malformatted request redact the entire thing."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        \"\"\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        exceptions = False"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        for arg in (params.get('methods', [])):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            try:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+                self._validate_request(arg)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            except Exception:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                # redact the whole request since we don't know what's in it"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+                exceptions = True"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+                yield u'********'"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+                continue"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            name = arg['method']"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            a, kw = arg['params']"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            newkw = dict((str(k), v) for k, v in kw.items())"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            param = api.Command[name].args_options_2_params("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                *a, **newkw)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            yield '{}({})'.format("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                api.Command[name].name,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                ', '.join(api.Command[name]._repr_iter(**param))"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            )"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        if exceptions:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            logger.debug('batch: %s',"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                         ', '.join(super(batch, self)._repr_iter(**params)))"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     def execute(self, methods=None, **options):"
            },
            "68": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         results = []"
            },
            "69": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         for arg in (methods or []):"
            },
            "70": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "             params = dict()"
            },
            "71": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             name = None"
            },
            "72": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "             try:"
            },
            "73": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if 'method' not in arg:"
            },
            "74": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise errors.RequirementError(name='method')"
            },
            "75": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if 'params' not in arg:"
            },
            "76": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise errors.RequirementError(name='params')"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                self._validate_request(arg)"
            },
            "78": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "                 name = arg['method']"
            },
            "79": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if (name not in self.api.Command or"
            },
            "80": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        isinstance(self.api.Command[name], Local)):"
            },
            "81": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise errors.CommandError(name=name)"
            },
            "82": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "83": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # If params are not formated as a tuple(list, dict)"
            },
            "84": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # the following lines will raise an exception"
            },
            "85": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # that triggers an internal server error"
            },
            "86": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Raise a ConversionError instead to report the issue"
            },
            "87": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # to the client"
            },
            "88": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "89": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    a, kw = arg['params']"
            },
            "90": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    newkw = dict((str(k), v) for k, v in kw.items())"
            },
            "91": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    params = api.Command[name].args_options_2_params("
            },
            "92": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        *a, **newkw)"
            },
            "93": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except (AttributeError, ValueError, TypeError):"
            },
            "94": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise errors.ConversionError("
            },
            "95": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        name='params',"
            },
            "96": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        error=_(u'must contain a tuple (list, dict)'))"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                a, kw = arg['params']"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                newkw = dict((str(k), v) for k, v in kw.items())"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                params = api.Command[name].args_options_2_params("
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                    *a, **newkw)"
            },
            "101": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                 newkw.setdefault('version', options['version'])"
            },
            "102": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "                 result = api.Command[name](*a, **newkw)"
            },
            "104": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "                 )"
            },
            "105": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "                 result['error']=None"
            },
            "106": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "             except Exception as e:"
            },
            "107": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if isinstance(e, errors.RequirementError) or \\"
            },
            "108": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    isinstance(e, errors.CommandError):"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                if (isinstance(e, errors.RequirementError) or"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                        isinstance(e, errors.CommandError) or"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+                        isinstance(e, errors.ConversionError)):"
            },
            "112": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "                     logger.info("
            },
            "113": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "                         '%s: batch: %s',"
            },
            "114": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "                         context.principal,  # pylint: disable=no-member"
            }
        },
        "frontPatchFile": [
            "# Authors:",
            "#   Adam Young <ayoung@redhat.com>",
            "#   Rob Crittenden <rcritten@redhat.com>",
            "#",
            "# Copyright (c) 2010  Red Hat",
            "# See file 'copying' for use and warranty information",
            "#",
            "# This program is free software; you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "",
            "import six",
            "",
            "from ipalib import api, errors",
            "from ipalib import Command",
            "from ipalib.frontend import Local",
            "from ipalib.parameters import Str, Dict",
            "from ipalib.output import Output",
            "from ipalib.text import _",
            "from ipalib.request import context",
            "from ipalib.plugable import Registry",
            "from ipapython.version import API_VERSION",
            "",
            "__doc__ = _(\"\"\"",
            "Plugin to make multiple ipa calls via one remote procedure call",
            "",
            "To run this code in the lite-server",
            "",
            "curl   -H \"Content-Type:application/json\"          -H \"Accept:application/json\" -H \"Accept-Language:en\"        --negotiate -u :          --cacert /etc/ipa/ca.crt           -d  @batch_request.json -X POST       http://localhost:8888/ipa/json",
            "",
            "where the contents of the file batch_request.json follow the below example",
            "",
            "{\"method\":\"batch\",\"params\":[[",
            "        {\"method\":\"group_find\",\"params\":[[],{}]},",
            "        {\"method\":\"user_find\",\"params\":[[],{\"whoami\":\"true\",\"all\":\"true\"}]},",
            "        {\"method\":\"user_show\",\"params\":[[\"admin\"],{\"all\":true}]}",
            "        ],{}],\"id\":1}",
            "",
            "The format of the response is nested the same way.  At the top you will see",
            "  \"error\": null,",
            "    \"id\": 1,",
            "    \"result\": {",
            "        \"count\": 3,",
            "            \"results\": [",
            "",
            "",
            "And then a nested response for each IPA command method sent in the request",
            "",
            "\"\"\")",
            "",
            "if six.PY3:",
            "    unicode = str",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "register = Registry()",
            "",
            "@register()",
            "class batch(Command):",
            "    __doc__ = _('Make multiple ipa calls via one remote procedure call')",
            "    NO_CLI = True",
            "",
            "    takes_args = (",
            "        Dict('methods*',",
            "            doc=_('Nested Methods to execute'),",
            "        ),",
            "    )",
            "",
            "    take_options = (",
            "        Str('version',",
            "            cli_name='version',",
            "            doc=_('Client version. Used to determine if server will accept request.'),",
            "            exclude='webui',",
            "            flags=['no_option', 'no_output'],",
            "            default=API_VERSION,",
            "            autofill=True,",
            "        ),",
            "    )",
            "",
            "    has_output = (",
            "        Output('count', int, doc=''),",
            "        Output('results', (list, tuple), doc='')",
            "    )",
            "",
            "    def execute(self, methods=None, **options):",
            "        results = []",
            "        for arg in (methods or []):",
            "            params = dict()",
            "            name = None",
            "            try:",
            "                if 'method' not in arg:",
            "                    raise errors.RequirementError(name='method')",
            "                if 'params' not in arg:",
            "                    raise errors.RequirementError(name='params')",
            "                name = arg['method']",
            "                if (name not in self.api.Command or",
            "                        isinstance(self.api.Command[name], Local)):",
            "                    raise errors.CommandError(name=name)",
            "",
            "                # If params are not formated as a tuple(list, dict)",
            "                # the following lines will raise an exception",
            "                # that triggers an internal server error",
            "                # Raise a ConversionError instead to report the issue",
            "                # to the client",
            "                try:",
            "                    a, kw = arg['params']",
            "                    newkw = dict((str(k), v) for k, v in kw.items())",
            "                    params = api.Command[name].args_options_2_params(",
            "                        *a, **newkw)",
            "                except (AttributeError, ValueError, TypeError):",
            "                    raise errors.ConversionError(",
            "                        name='params',",
            "                        error=_(u'must contain a tuple (list, dict)'))",
            "                newkw.setdefault('version', options['version'])",
            "",
            "                result = api.Command[name](*a, **newkw)",
            "                logger.info(",
            "                    '%s: batch: %s(%s): SUCCESS',",
            "                    getattr(context, 'principal', 'UNKNOWN'),",
            "                    name,",
            "                    ', '.join(api.Command[name]._repr_iter(**params))",
            "                )",
            "                result['error']=None",
            "            except Exception as e:",
            "                if isinstance(e, errors.RequirementError) or \\",
            "                    isinstance(e, errors.CommandError):",
            "                    logger.info(",
            "                        '%s: batch: %s',",
            "                        context.principal,  # pylint: disable=no-member",
            "                        e.__class__.__name__",
            "                    )",
            "                else:",
            "                    logger.info(",
            "                        '%s: batch: %s(%s): %s',",
            "                        context.principal, name,  # pylint: disable=no-member",
            "                        ', '.join(api.Command[name]._repr_iter(**params)),",
            "                        e.__class__.__name__",
            "                    )",
            "                if isinstance(e, errors.PublicError):",
            "                    reported_error = e",
            "                else:",
            "                    reported_error = errors.InternalError()",
            "                result = dict(",
            "                    error=reported_error.strerror,",
            "                    error_code=reported_error.errno,",
            "                    error_name=unicode(type(reported_error).__name__),",
            "                    error_kw=reported_error.kw,",
            "                )",
            "            results.append(result)",
            "        return dict(count=len(results) , results=results)"
        ],
        "afterPatchFile": [
            "# Authors:",
            "#   Adam Young <ayoung@redhat.com>",
            "#   Rob Crittenden <rcritten@redhat.com>",
            "#",
            "# Copyright (c) 2010  Red Hat",
            "# See file 'copying' for use and warranty information",
            "#",
            "# This program is free software; you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "",
            "import six",
            "",
            "from ipalib import api, errors",
            "from ipalib import Command",
            "from ipalib.frontend import Local",
            "from ipalib.parameters import Str, Dict",
            "from ipalib.output import Output",
            "from ipalib.text import _",
            "from ipalib.request import context",
            "from ipalib.plugable import Registry",
            "from ipapython.version import API_VERSION",
            "",
            "__doc__ = _(\"\"\"",
            "Plugin to make multiple ipa calls via one remote procedure call",
            "",
            "To run this code in the lite-server",
            "",
            "curl   -H \"Content-Type:application/json\"          -H \"Accept:application/json\" -H \"Accept-Language:en\"        --negotiate -u :          --cacert /etc/ipa/ca.crt           -d  @batch_request.json -X POST       http://localhost:8888/ipa/json",
            "",
            "where the contents of the file batch_request.json follow the below example",
            "",
            "{\"method\":\"batch\",\"params\":[[",
            "        {\"method\":\"group_find\",\"params\":[[],{}]},",
            "        {\"method\":\"user_find\",\"params\":[[],{\"whoami\":\"true\",\"all\":\"true\"}]},",
            "        {\"method\":\"user_show\",\"params\":[[\"admin\"],{\"all\":true}]}",
            "        ],{}],\"id\":1}",
            "",
            "The format of the response is nested the same way.  At the top you will see",
            "  \"error\": null,",
            "    \"id\": 1,",
            "    \"result\": {",
            "        \"count\": 3,",
            "            \"results\": [",
            "",
            "",
            "And then a nested response for each IPA command method sent in the request",
            "",
            "\"\"\")",
            "",
            "if six.PY3:",
            "    unicode = str",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "register = Registry()",
            "",
            "@register()",
            "class batch(Command):",
            "    __doc__ = _('Make multiple ipa calls via one remote procedure call')",
            "    NO_CLI = True",
            "",
            "    takes_args = (",
            "        Dict('methods*',",
            "            doc=_('Nested Methods to execute'),",
            "        ),",
            "    )",
            "",
            "    take_options = (",
            "        Str('version',",
            "            cli_name='version',",
            "            doc=_('Client version. Used to determine if server will accept request.'),",
            "            exclude='webui',",
            "            flags=['no_option', 'no_output'],",
            "            default=API_VERSION,",
            "            autofill=True,",
            "        ),",
            "    )",
            "",
            "    has_output = (",
            "        Output('count', int, doc=''),",
            "        Output('results', (list, tuple), doc='')",
            "    )",
            "",
            "    def _validate_request(self, request):",
            "        \"\"\"",
            "        Check that an individual request in a batch is parseable and the",
            "        commands exists.",
            "        \"\"\"",
            "        if 'method' not in request:",
            "            raise errors.RequirementError(name='method')",
            "        if 'params' not in request:",
            "            raise errors.RequirementError(name='params')",
            "        name = request['method']",
            "        if (name not in self.api.Command or",
            "                isinstance(self.api.Command[name], Local)):",
            "            raise errors.CommandError(name=name)",
            "",
            "        # If params are not formated as a tuple(list, dict)",
            "        # the following lines will raise an exception",
            "        # that triggers an internal server error",
            "        # Raise a ConversionError instead to report the issue",
            "        # to the client",
            "        try:",
            "            a, kw = request['params']",
            "            newkw = dict((str(k), v) for k, v in kw.items())",
            "            api.Command[name].args_options_2_params(*a, **newkw)",
            "        except (AttributeError, ValueError, TypeError):",
            "            raise errors.ConversionError(",
            "                name='params',",
            "                error=_(u'must contain a tuple (list, dict)'))",
            "        except Exception as e:",
            "            raise errors.ConversionError(",
            "                name='params',",
            "                error=str(e))",
            "",
            "    def _repr_iter(self, **params):",
            "        \"\"\"",
            "        Iterate through the request and use the Command _repr_intr so",
            "        that sensitive information (passwords) is not exposed.",
            "",
            "        In case of a malformatted request redact the entire thing.",
            "        \"\"\"",
            "        exceptions = False",
            "        for arg in (params.get('methods', [])):",
            "            try:",
            "                self._validate_request(arg)",
            "            except Exception:",
            "                # redact the whole request since we don't know what's in it",
            "                exceptions = True",
            "                yield u'********'",
            "                continue",
            "",
            "            name = arg['method']",
            "            a, kw = arg['params']",
            "            newkw = dict((str(k), v) for k, v in kw.items())",
            "            param = api.Command[name].args_options_2_params(",
            "                *a, **newkw)",
            "",
            "            yield '{}({})'.format(",
            "                api.Command[name].name,",
            "                ', '.join(api.Command[name]._repr_iter(**param))",
            "            )",
            "",
            "        if exceptions:",
            "            logger.debug('batch: %s',",
            "                         ', '.join(super(batch, self)._repr_iter(**params)))",
            "",
            "    def execute(self, methods=None, **options):",
            "        results = []",
            "        for arg in (methods or []):",
            "            params = dict()",
            "            name = None",
            "            try:",
            "                self._validate_request(arg)",
            "                name = arg['method']",
            "                a, kw = arg['params']",
            "                newkw = dict((str(k), v) for k, v in kw.items())",
            "                params = api.Command[name].args_options_2_params(",
            "                    *a, **newkw)",
            "                newkw.setdefault('version', options['version'])",
            "",
            "                result = api.Command[name](*a, **newkw)",
            "                logger.info(",
            "                    '%s: batch: %s(%s): SUCCESS',",
            "                    getattr(context, 'principal', 'UNKNOWN'),",
            "                    name,",
            "                    ', '.join(api.Command[name]._repr_iter(**params))",
            "                )",
            "                result['error']=None",
            "            except Exception as e:",
            "                if (isinstance(e, errors.RequirementError) or",
            "                        isinstance(e, errors.CommandError) or",
            "                        isinstance(e, errors.ConversionError)):",
            "                    logger.info(",
            "                        '%s: batch: %s',",
            "                        context.principal,  # pylint: disable=no-member",
            "                        e.__class__.__name__",
            "                    )",
            "                else:",
            "                    logger.info(",
            "                        '%s: batch: %s(%s): %s',",
            "                        context.principal, name,  # pylint: disable=no-member",
            "                        ', '.join(api.Command[name]._repr_iter(**params)),",
            "                        e.__class__.__name__",
            "                    )",
            "                if isinstance(e, errors.PublicError):",
            "                    reported_error = e",
            "                else:",
            "                    reported_error = errors.InternalError()",
            "                result = dict(",
            "                    error=reported_error.strerror,",
            "                    error_code=reported_error.errno,",
            "                    error_name=unicode(type(reported_error).__name__),",
            "                    error_kw=reported_error.kw,",
            "                )",
            "            results.append(result)",
            "        return dict(count=len(results) , results=results)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "102": [
                "batch",
                "execute"
            ],
            "103": [
                "batch",
                "execute"
            ],
            "104": [
                "batch",
                "execute"
            ],
            "105": [
                "batch",
                "execute"
            ],
            "107": [
                "batch",
                "execute"
            ],
            "108": [
                "batch",
                "execute"
            ],
            "109": [
                "batch",
                "execute"
            ],
            "110": [
                "batch",
                "execute"
            ],
            "111": [
                "batch",
                "execute"
            ],
            "112": [
                "batch",
                "execute"
            ],
            "113": [
                "batch",
                "execute"
            ],
            "114": [
                "batch",
                "execute"
            ],
            "115": [
                "batch",
                "execute"
            ],
            "116": [
                "batch",
                "execute"
            ],
            "117": [
                "batch",
                "execute"
            ],
            "118": [
                "batch",
                "execute"
            ],
            "119": [
                "batch",
                "execute"
            ],
            "120": [
                "batch",
                "execute"
            ],
            "121": [
                "batch",
                "execute"
            ],
            "122": [
                "batch",
                "execute"
            ],
            "123": [
                "batch",
                "execute"
            ],
            "124": [
                "batch",
                "execute"
            ],
            "136": [
                "batch",
                "execute"
            ],
            "137": [
                "batch",
                "execute"
            ]
        },
        "addLocation": [
            "nio.crypto.olm_machine",
            "ipaserver.plugins.batch.batch.self",
            "ipaserver.plugins.batch.batch.execute"
        ]
    }
}