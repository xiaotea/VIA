{
    "pywb/manager/locmanager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "                 csv = os.path.join(base, 'messages.csv')"
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "                 po2csv([po, csv])"
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        self.compile_catalog()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     def update_loc(self, locale, no_csv):"
            },
            "6": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         for loc in locale:"
            },
            "7": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             if not no_csv:"
            }
        },
        "frontPatchFile": [
            "import os",
            "import os.path",
            "import shutil",
            "",
            "from babel.messages.frontend import CommandLineInterface",
            "",
            "from translate.convert.po2csv import main as po2csv",
            "from translate.convert.csv2po import main as csv2po",
            "",
            "",
            "ROOT_DIR = 'i18n'",
            "",
            "TRANSLATIONS = os.path.join(ROOT_DIR, 'translations')",
            "",
            "MESSAGES = os.path.join(ROOT_DIR, 'messages.pot')",
            "",
            "# ============================================================================",
            "class LocManager:",
            "    def process(self, r):",
            "        if r.name == 'list':",
            "            r.loc_func(self)",
            "        elif r.name == 'remove':",
            "            r.loc_func(self, r.locale)",
            "        else:",
            "            r.loc_func(self, r.locale, r.no_csv)",
            "",
            "    def extract_loc(self, locale, no_csv):",
            "        self.extract_text()",
            "",
            "        for loc in locale:",
            "            loc_dir = os.path.join(TRANSLATIONS, loc)",
            "            if os.path.isdir(loc_dir):",
            "                self.update_catalog(loc)",
            "            else:",
            "                os.makedirs(loc_dir)",
            "                self.init_catalog(loc)",
            "",
            "            if not no_csv:",
            "                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')",
            "                po = os.path.join(base, 'messages.po')",
            "                csv = os.path.join(base, 'messages.csv')",
            "                po2csv([po, csv])",
            "",
            "    def update_loc(self, locale, no_csv):",
            "        for loc in locale:",
            "            if not no_csv:",
            "                loc_dir = os.path.join(TRANSLATIONS, loc)",
            "                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')",
            "                po = os.path.join(base, 'messages.po')",
            "                csv = os.path.join(base, 'messages.csv')",
            "",
            "                if os.path.isfile(csv):",
            "                    csv2po([csv, po])",
            "",
            "        self.compile_catalog()",
            "",
            "    def remove_loc(self, locale):",
            "        for loc in locale:",
            "            loc_dir = os.path.join(TRANSLATIONS, loc)",
            "            if not os.path.isdir(loc_dir):",
            "                print('Locale \"{0}\" does not exist'.format(loc))",
            "                return",
            "",
            "            shutil.rmtree(loc_dir)",
            "            print('Removed locale \"{0}\"'.format(loc))",
            "",
            "    def list_loc(self):",
            "        print('Current locales:')",
            "        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))",
            "        print('')",
            "",
            "    def extract_text(self):",
            "        os.makedirs(ROOT_DIR, exist_ok=True)",
            "",
            "        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])",
            "",
            "    def init_catalog(self, loc):",
            "        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])",
            "",
            "    def update_catalog(self, loc):",
            "        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])",
            "",
            "    def compile_catalog(self):",
            "        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])",
            "",
            "",
            "    @classmethod",
            "    def init_parser(cls, parser):",
            "        \"\"\"Initializes an argument parser for acl commands",
            "",
            "        :param argparse.ArgumentParser parser: The parser to be initialized",
            "        :rtype: None",
            "        \"\"\"",
            "        subparsers = parser.add_subparsers(dest='op')",
            "        subparsers.required = True",
            "",
            "        def command(name, func):",
            "            op = subparsers.add_parser(name)",
            "            if name != 'list':",
            "                op.add_argument('locale', nargs='+')",
            "                if name != 'remove':",
            "                    op.add_argument('--no-csv', action='store_true')",
            "",
            "            op.set_defaults(loc_func=func, name=name)",
            "",
            "        command('extract', cls.extract_loc)",
            "        command('update', cls.update_loc)",
            "        command('remove', cls.remove_loc)",
            "        command('list', cls.list_loc)"
        ],
        "afterPatchFile": [
            "import os",
            "import os.path",
            "import shutil",
            "",
            "from babel.messages.frontend import CommandLineInterface",
            "",
            "from translate.convert.po2csv import main as po2csv",
            "from translate.convert.csv2po import main as csv2po",
            "",
            "",
            "ROOT_DIR = 'i18n'",
            "",
            "TRANSLATIONS = os.path.join(ROOT_DIR, 'translations')",
            "",
            "MESSAGES = os.path.join(ROOT_DIR, 'messages.pot')",
            "",
            "# ============================================================================",
            "class LocManager:",
            "    def process(self, r):",
            "        if r.name == 'list':",
            "            r.loc_func(self)",
            "        elif r.name == 'remove':",
            "            r.loc_func(self, r.locale)",
            "        else:",
            "            r.loc_func(self, r.locale, r.no_csv)",
            "",
            "    def extract_loc(self, locale, no_csv):",
            "        self.extract_text()",
            "",
            "        for loc in locale:",
            "            loc_dir = os.path.join(TRANSLATIONS, loc)",
            "            if os.path.isdir(loc_dir):",
            "                self.update_catalog(loc)",
            "            else:",
            "                os.makedirs(loc_dir)",
            "                self.init_catalog(loc)",
            "",
            "            if not no_csv:",
            "                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')",
            "                po = os.path.join(base, 'messages.po')",
            "                csv = os.path.join(base, 'messages.csv')",
            "                po2csv([po, csv])",
            "",
            "        self.compile_catalog()",
            "",
            "    def update_loc(self, locale, no_csv):",
            "        for loc in locale:",
            "            if not no_csv:",
            "                loc_dir = os.path.join(TRANSLATIONS, loc)",
            "                base = os.path.join(TRANSLATIONS, loc, 'LC_MESSAGES')",
            "                po = os.path.join(base, 'messages.po')",
            "                csv = os.path.join(base, 'messages.csv')",
            "",
            "                if os.path.isfile(csv):",
            "                    csv2po([csv, po])",
            "",
            "        self.compile_catalog()",
            "",
            "    def remove_loc(self, locale):",
            "        for loc in locale:",
            "            loc_dir = os.path.join(TRANSLATIONS, loc)",
            "            if not os.path.isdir(loc_dir):",
            "                print('Locale \"{0}\" does not exist'.format(loc))",
            "                return",
            "",
            "            shutil.rmtree(loc_dir)",
            "            print('Removed locale \"{0}\"'.format(loc))",
            "",
            "    def list_loc(self):",
            "        print('Current locales:')",
            "        print('\\n'.join(' - ' + x for x in os.listdir(TRANSLATIONS)))",
            "        print('')",
            "",
            "    def extract_text(self):",
            "        os.makedirs(ROOT_DIR, exist_ok=True)",
            "",
            "        CommandLineInterface().run(['pybabel', 'extract', '-F', 'babel.ini', '-k', '_ _Q gettext ngettext', '-o', MESSAGES, './', '--omit-header'])",
            "",
            "    def init_catalog(self, loc):",
            "        CommandLineInterface().run(['pybabel', 'init', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS])",
            "",
            "    def update_catalog(self, loc):",
            "        CommandLineInterface().run(['pybabel', 'update', '-l', loc, '-i', MESSAGES, '-d', TRANSLATIONS, '--previous'])",
            "",
            "    def compile_catalog(self):",
            "        CommandLineInterface().run(['pybabel', 'compile', '-d', TRANSLATIONS])",
            "",
            "",
            "    @classmethod",
            "    def init_parser(cls, parser):",
            "        \"\"\"Initializes an argument parser for acl commands",
            "",
            "        :param argparse.ArgumentParser parser: The parser to be initialized",
            "        :rtype: None",
            "        \"\"\"",
            "        subparsers = parser.add_subparsers(dest='op')",
            "        subparsers.required = True",
            "",
            "        def command(name, func):",
            "            op = subparsers.add_parser(name)",
            "            if name != 'list':",
            "                op.add_argument('locale', nargs='+')",
            "                if name != 'remove':",
            "                    op.add_argument('--no-csv', action='store_true')",
            "",
            "            op.set_defaults(loc_func=func, name=name)",
            "",
            "        command('extract', cls.extract_loc)",
            "        command('update', cls.update_loc)",
            "        command('remove', cls.remove_loc)",
            "        command('list', cls.list_loc)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.twisted.web.client.URI.fromBytes",
            "pywb.manager.locmanager.LocManager.init_parser.command.func",
            "pywb.manager.locmanager.LocManager.self"
        ]
    },
    "pywb/rewrite/templateview.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from six.moves.urllib.parse import urlsplit, quote"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from jinja2 import Environment, TemplateNotFound, contextfunction"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from jinja2 import Environment, TemplateNotFound, contextfunction, select_autoescape"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from babel.support import Translations"
            },
            "8": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         if overlay:"
            },
            "10": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "             jinja_env = overlay.jinja_env.overlay(loader=loader,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                                                  autoescape=select_autoescape(),"
            },
            "12": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "                                                   trim_blocks=True,"
            },
            "13": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "                                                   extensions=extensions)"
            },
            "14": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         else:"
            },
            "15": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "             jinja_env = RelEnvironment(loader=loader,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                                       autoescape=select_autoescape(),"
            },
            "17": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                                        trim_blocks=True,"
            },
            "18": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                                        extensions=extensions)"
            },
            "19": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from warcio.timeutils import timestamp_to_datetime, timestamp_to_sec",
            "from warcio.timeutils import timestamp_now",
            "",
            "from pywb.utils.loaders import load",
            "",
            "from six.moves.urllib.parse import urlsplit, quote",
            "",
            "from jinja2 import Environment, TemplateNotFound, contextfunction",
            "from jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader",
            "",
            "from babel.support import Translations",
            "",
            "from webassets.ext.jinja2 import AssetsExtension",
            "from webassets.loaders import YAMLLoader",
            "from webassets.env import Resolver",
            "",
            "from pkg_resources import resource_filename",
            "",
            "import os",
            "",
            "try:",
            "    import ujson as json",
            "except ImportError:  # pragma: no cover",
            "    import json",
            "",
            "",
            "# ============================================================================",
            "class RelEnvironment(Environment):",
            "    \"\"\"Override join_path() to enable relative template paths.\"\"\"",
            "    def join_path(self, template, parent):",
            "        return os.path.join(os.path.dirname(parent), template)",
            "",
            "",
            "# ============================================================================",
            "class JinjaEnv(object):",
            "    \"\"\"Pywb JinjaEnv class that provides utility functions used by the templates,",
            "    configured template loaders and template paths, and contains the actual Jinja",
            "    env used by each template.\"\"\"",
            "",
            "    def __init__(self, paths=None,",
            "                 packages=None,",
            "                 assets_path=None,",
            "                 globals=None,",
            "                 overlay=None,",
            "                 extensions=None,",
            "                 env_template_params_key='pywb.template_params',",
            "                 env_template_dir_key='pywb.templates_dir'):",
            "        \"\"\"Construct a new JinjaEnv.",
            "",
            "        :param list[str] paths: List of paths to search for templates",
            "        :param list[str] packages: List of assets package names",
            "        :param str assets_path: Path to a yaml file containing assets",
            "        :param dict[str, str] globals: Dictionary of additional globals available during template rendering",
            "        :param overlay:",
            "        :param list extensions: List of webassets extension classes",
            "        :param str env_template_params_key: The full pywb package key for the template params",
            "        :param str env_template_dir_key: The full pywb package key for the template directory",
            "        \"\"\"",
            "",
            "        if paths is None:",
            "            paths = ['templates', '.', '/']",
            "",
            "        if packages is None:",
            "            packages = ['pywb']",
            "",
            "        self._init_filters()",
            "",
            "        loader = ChoiceLoader(self._make_loaders(paths, packages))",
            "",
            "        self.env_template_params_key = env_template_params_key",
            "        self.env_template_dir_key = env_template_dir_key",
            "",
            "        extensions = extensions or []",
            "",
            "        if assets_path:",
            "            extensions.append(AssetsExtension)",
            "",
            "        if overlay:",
            "            jinja_env = overlay.jinja_env.overlay(loader=loader,",
            "                                                  trim_blocks=True,",
            "                                                  extensions=extensions)",
            "        else:",
            "            jinja_env = RelEnvironment(loader=loader,",
            "                                       trim_blocks=True,",
            "                                       extensions=extensions)",
            "",
            "        jinja_env.filters.update(self.filters)",
            "",
            "        if globals:",
            "            jinja_env.globals.update(globals)",
            "",
            "        self.jinja_env = jinja_env",
            "",
            "        # init assets",
            "        if assets_path:",
            "            assets_loader = YAMLLoader(load(assets_path))",
            "            assets_env = assets_loader.load_environment()",
            "            assets_env.resolver = PkgResResolver()",
            "            jinja_env.assets_environment = assets_env",
            "",
            "        self.default_locale = ''",
            "",
            "    def _make_loaders(self, paths, packages):",
            "        \"\"\"Initialize the template loaders based on the supplied paths and packages.",
            "",
            "        :param list[str] paths: List of paths to search for templates",
            "        :param list[str] packages: List of assets package names",
            "        :return: A list of loaders to be used for loading the template assets",
            "        :rtype: list[FileSystemLoader|PackageLoader]",
            "        \"\"\"",
            "        loaders = []",
            "        # add loaders for paths",
            "        for path in paths:",
            "            loaders.append(FileSystemLoader(path))",
            "",
            "        # add loaders for all specified packages",
            "        for package in packages:",
            "            loaders.append(PackageLoader(package))",
            "",
            "        return loaders",
            "",
            "    def init_loc(self, locales_root_dir, locales, loc_map, default_locale):",
            "        locales = locales or []",
            "        locales_root_dir = locales_root_dir or os.path.join('i18n', 'translations')",
            "        default_locale = default_locale or 'en'",
            "        self.default_locale = default_locale",
            "",
            "        if locales_root_dir:",
            "            for loc in locales:",
            "                loc_map[loc] = Translations.load(locales_root_dir, [loc, default_locale])",
            "                #jinja_env.jinja_env.install_gettext_translations(translations)",
            "",
            "        def get_translate(context):",
            "            loc = context.get('env', {}).get('pywb_lang', default_locale)",
            "            return loc_map.get(loc)",
            "",
            "        def override_func(jinja_env, name):",
            "            @contextfunction",
            "            def get_override(context, text):",
            "                translate = get_translate(context)",
            "                if not translate:",
            "                    return text",
            "",
            "                func = getattr(translate, name)",
            "                return func(text)",
            "",
            "            jinja_env.globals[name] = get_override",
            "",
            "        # standard gettext() translation function",
            "        override_func(self.jinja_env, 'gettext')",
            "",
            "        # single/plural form translation function",
            "        override_func(self.jinja_env, 'ngettext')",
            "",
            "        # Special _Q() function to return %-encoded text, necessary for use",
            "        # with text in banner",
            "        @contextfunction",
            "        def quote_gettext(context, text):",
            "            translate = get_translate(context)",
            "            if not translate:",
            "                return text",
            "",
            "            text = translate.gettext(text)",
            "            return quote(text, safe='/: ')",
            "",
            "        self.jinja_env.globals['locales'] = list(loc_map.keys())",
            "        self.jinja_env.globals['_Q'] = quote_gettext",
            "        self.jinja_env.globals['default_locale'] = default_locale",
            "",
            "        @contextfunction",
            "        def switch_locale(context, locale):",
            "            environ = context.get('env')",
            "            curr_loc = environ.get('pywb_lang', '')",
            "",
            "            request_uri = environ.get('REQUEST_URI', environ.get('PATH_INFO'))",
            "",
            "            if curr_loc:",
            "                return request_uri.replace(curr_loc, locale, 1)",
            "",
            "            app_prefix = environ.get('pywb.app_prefix', '')",
            "",
            "            if app_prefix and request_uri.startswith(app_prefix):",
            "                request_uri = request_uri.replace(app_prefix, '')",
            "",
            "            return app_prefix + '/' + locale + request_uri",
            "",
            "        @contextfunction",
            "        def get_locale_prefixes(context):",
            "            environ = context.get('env')",
            "            locale_prefixes = {}",
            "",
            "            orig_prefix = environ.get('pywb.app_prefix', '')",
            "            coll = environ.get('SCRIPT_NAME', '')",
            "",
            "            if orig_prefix:",
            "                coll = coll[len(orig_prefix):]",
            "",
            "            curr_loc = environ.get('pywb_lang', '')",
            "            if curr_loc:",
            "                coll = coll[len(curr_loc) + 1:]",
            "",
            "            for locale in loc_map.keys():",
            "                locale_prefixes[locale] = orig_prefix + '/' + locale + coll + '/'",
            "",
            "            return locale_prefixes",
            "",
            "        self.jinja_env.globals['switch_locale'] = switch_locale",
            "        self.jinja_env.globals['get_locale_prefixes'] = get_locale_prefixes",
            "",
            "    def template_filter(self, param=None):",
            "        \"\"\"Returns a decorator that adds the wrapped function to dictionary of template filters.",
            "",
            "        The wrapped function is keyed by either the supplied param (if supplied)",
            "        or by the wrapped functions name.",
            "",
            "        :param param: Optional name to use instead of the name of the function to be wrapped",
            "        :return: A decorator to wrap a template filter function",
            "        :rtype: callable",
            "        \"\"\"",
            "        def deco(func):",
            "            name = param or func.__name__",
            "            self.filters[name] = func",
            "            return func",
            "",
            "        return deco",
            "",
            "    def _init_filters(self):",
            "        \"\"\"Initialize the default pywb provided Jninja filters available during template rendering\"\"\"",
            "        self.filters = {}",
            "",
            "        @self.template_filter()",
            "        def format_ts(value, format_='%a, %b %d %Y %H:%M:%S'):",
            "            \"\"\"Formats the supplied timestamp using format_",
            "",
            "            :param str value: The timestamp to be formatted",
            "            :param str format_:  The format string",
            "            :return: The correctly formatted timestamp as determined by format_",
            "            :rtype: str",
            "            \"\"\"",
            "            if format_ == '%s':",
            "                return timestamp_to_sec(value)",
            "            else:",
            "                value = timestamp_to_datetime(value)",
            "                return value.strftime(format_)",
            "",
            "        @self.template_filter('urlsplit')",
            "        def get_urlsplit(url):",
            "            \"\"\"Splits the supplied URL",
            "",
            "            :param str url: The url to be split",
            "            :return: The split url",
            "            :rtype: urllib.parse.SplitResult",
            "            \"\"\"",
            "            split = urlsplit(url)",
            "            return split",
            "",
            "        @self.template_filter()",
            "        def tojson(obj):",
            "            \"\"\"Converts the supplied object/array/any to a JSON string if it can be JSONified",
            "",
            "            :param any obj: The value to be converted to a JSON string",
            "            :return: The JSON string representation of the supplied value",
            "            :rtype: str",
            "            \"\"\"",
            "            return json.dumps(obj)",
            "",
            "        @self.template_filter()",
            "        def tobool(bool_val):",
            "            \"\"\"Converts a python boolean to a JS \"true\" or \"false\" string",
            "            :param any obj: A value to be evaluated as a boolean",
            "            :return: The string \"true\" or \"false\" to be inserted into JS",
            "            \"\"\"",
            "",
            "            return 'true' if bool_val else 'false'",
            "",
            "",
            "# ============================================================================",
            "class BaseInsertView(object):",
            "    \"\"\"Base class of all template views used by Pywb\"\"\"",
            "",
            "    def __init__(self, jenv, insert_file, banner_view=None):",
            "        \"\"\"Create a new BaseInsertView.",
            "",
            "        :param JinjaEnv jenv: The instance of pywb.rewrite.templateview.JinjaEnv to be used",
            "        :param str insert_file: The name of the template file",
            "        :param BaseInsertView banner_view: The banner_view property of pywb.apps.RewriterApp",
            "        \"\"\"",
            "        self.jenv = jenv",
            "        self.insert_file = insert_file",
            "        self.banner_view = banner_view",
            "",
            "    def render_to_string(self, env, **kwargs):",
            "        \"\"\"Render this template.",
            "",
            "        :param dict env: The WSGI environment associated with the request causing this template to be rendered",
            "        :param any kwargs: The keyword arguments to be supplied to the Jninja template render method",
            "        :return: The rendered template",
            "        :rtype: str",
            "        \"\"\"",
            "        template = None",
            "        template_path = env.get(self.jenv.env_template_dir_key)",
            "",
            "        if template_path:",
            "            # jinja paths are not os paths, always use '/' as separator",
            "            # https://github.com/pallets/jinja/issues/411",
            "            template_path = template_path + '/' + self.insert_file",
            "",
            "            try:",
            "                template = self.jenv.jinja_env.get_template(template_path)",
            "            except TemplateNotFound as te:",
            "                pass",
            "",
            "        if not template:",
            "            template = self.jenv.jinja_env.get_template(self.insert_file)",
            "",
            "        params = env.get(self.jenv.env_template_params_key)",
            "        if params:",
            "            kwargs.update(params)",
            "",
            "        kwargs['env'] = env",
            "        kwargs['static_prefix'] = env.get('pywb.host_prefix', '') + env.get('pywb.app_prefix', '') + '/static'",
            "",
            "",
            "        return template.render(**kwargs)",
            "",
            "",
            "# ============================================================================",
            "class HeadInsertView(BaseInsertView):",
            "    \"\"\"The template view class associated with rendering the HTML inserted",
            "    into the head of the pages replayed (WB Insert).\"\"\"",
            "",
            "    def create_insert_func(self, wb_url,",
            "                           wb_prefix,",
            "                           host_prefix,",
            "                           top_url,",
            "                           env,",
            "                           is_framed,",
            "                           coll='',",
            "                           include_ts=True,",
            "                           **kwargs):",
            "        \"\"\"Create the function used to render the header insert template for the current request.",
            "",
            "        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for",
            "        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)",
            "        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)",
            "        :param str top_url: The full URL for this request (e.g. http://localhost:8080/live/http://example.com)",
            "        :param dict env: The WSGI environment dictionary for this request",
            "        :param bool is_framed: Is pywb or a specific collection running in framed mode",
            "        :param str coll: The name of the collection this request is associated with",
            "        :param bool include_ts: Should a timestamp be included in the rendered template",
            "        :param kwargs: Additional keyword arguments to be supplied to the Jninja template render method",
            "        :return: A function to be used to render the header insert for the request this template is being rendered for",
            "        :rtype: callable",
            "        \"\"\"",
            "        params = kwargs",
            "        params['host_prefix'] = host_prefix",
            "        params['wb_prefix'] = wb_prefix",
            "        params['wb_url'] = wb_url",
            "        params['top_url'] = top_url",
            "        params['coll'] = coll",
            "        params['is_framed'] = is_framed",
            "",
            "        def make_head_insert(rule, cdx):",
            "            params['wombat_ts'] = cdx['timestamp'] if include_ts else ''",
            "            params['wombat_sec'] = timestamp_to_sec(cdx['timestamp'])",
            "            params['is_live'] = cdx.get('is_live')",
            "",
            "            if self.banner_view:",
            "                banner_html = self.banner_view.render_to_string(env, cdx=cdx, **params)",
            "                params['banner_html'] = banner_html",
            "",
            "            return self.render_to_string(env, cdx=cdx, **params)",
            "",
            "        return make_head_insert",
            "",
            "",
            "# ============================================================================",
            "class TopFrameView(BaseInsertView):",
            "    \"\"\"The template view class associated with rendering the replay iframe\"\"\"",
            "",
            "    def get_top_frame(self, wb_url,",
            "                      wb_prefix,",
            "                      host_prefix,",
            "                      env,",
            "                      frame_mod,",
            "                      replay_mod,",
            "                      coll='',",
            "                      extra_params=None):",
            "        \"\"\"",
            "        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for",
            "        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)",
            "        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)",
            "        :param dict env: The WSGI environment dictionary for the request this template is being rendered for",
            "        :param str frame_mod:  The modifier to be used for framing (e.g. if_)",
            "        :param str replay_mod: The modifier to be used in the URL of the page being replayed (e.g. mp_)",
            "        :param str coll: The name of the collection this template is being rendered for",
            "        :param dict extra_params: Additional parameters to be supplied to the Jninja template render method",
            "        :return: The frame insert string",
            "        :rtype: str",
            "        \"\"\"",
            "",
            "        embed_url = wb_url.to_str(mod=replay_mod)",
            "",
            "        if wb_url.timestamp:",
            "            timestamp = wb_url.timestamp",
            "        else:",
            "            timestamp = timestamp_now()",
            "",
            "        is_proxy = 'wsgiprox.proxy_host' in env",
            "",
            "        params = {'host_prefix': host_prefix,",
            "                  'wb_prefix': wb_prefix,",
            "                  'wb_url': wb_url,",
            "                  'coll': coll,",
            "",
            "                  'options': {'frame_mod': frame_mod,",
            "                              'replay_mod': replay_mod},",
            "",
            "                  'embed_url': embed_url,",
            "                  'is_proxy': is_proxy,",
            "                  'timestamp': timestamp,",
            "                  'url': wb_url.get_url()",
            "                 }",
            "",
            "        if extra_params:",
            "            params.update(extra_params)",
            "",
            "        if self.banner_view:",
            "            banner_html = self.banner_view.render_to_string(env, **params)",
            "            params['banner_html'] = banner_html",
            "",
            "        return self.render_to_string(env, **params)",
            "",
            "",
            "# ============================================================================",
            "class PkgResResolver(Resolver):",
            "    \"\"\"Class for resolving pywb package resources when install via pypi or setup.py\"\"\"",
            "",
            "    def get_pkg_path(self, item):",
            "        \"\"\"Get the package path for the",
            "",
            "        :param str item: A resources full package path",
            "        :return: The netloc and path from the items package path",
            "        :rtype: tuple[str, str]",
            "        \"\"\"",
            "        if not isinstance(item, str):",
            "            return None",
            "",
            "        parts = urlsplit(item)",
            "        if parts.scheme == 'pkg' and parts.netloc:",
            "            return (parts.netloc, parts.path)",
            "",
            "        return None",
            "",
            "    def resolve_source(self, ctx, item):",
            "        pkg = self.get_pkg_path(item)",
            "        if pkg:",
            "            filename = resource_filename(pkg[0], pkg[1])",
            "            if filename:",
            "                return filename",
            "",
            "        return super(PkgResResolver, self).resolve_source(ctx, item)"
        ],
        "afterPatchFile": [
            "from warcio.timeutils import timestamp_to_datetime, timestamp_to_sec",
            "from warcio.timeutils import timestamp_now",
            "",
            "from pywb.utils.loaders import load",
            "",
            "from six.moves.urllib.parse import urlsplit, quote",
            "",
            "from jinja2 import Environment, TemplateNotFound, contextfunction, select_autoescape",
            "from jinja2 import FileSystemLoader, PackageLoader, ChoiceLoader",
            "",
            "from babel.support import Translations",
            "",
            "from webassets.ext.jinja2 import AssetsExtension",
            "from webassets.loaders import YAMLLoader",
            "from webassets.env import Resolver",
            "",
            "from pkg_resources import resource_filename",
            "",
            "import os",
            "",
            "try:",
            "    import ujson as json",
            "except ImportError:  # pragma: no cover",
            "    import json",
            "",
            "",
            "# ============================================================================",
            "class RelEnvironment(Environment):",
            "    \"\"\"Override join_path() to enable relative template paths.\"\"\"",
            "    def join_path(self, template, parent):",
            "        return os.path.join(os.path.dirname(parent), template)",
            "",
            "",
            "# ============================================================================",
            "class JinjaEnv(object):",
            "    \"\"\"Pywb JinjaEnv class that provides utility functions used by the templates,",
            "    configured template loaders and template paths, and contains the actual Jinja",
            "    env used by each template.\"\"\"",
            "",
            "    def __init__(self, paths=None,",
            "                 packages=None,",
            "                 assets_path=None,",
            "                 globals=None,",
            "                 overlay=None,",
            "                 extensions=None,",
            "                 env_template_params_key='pywb.template_params',",
            "                 env_template_dir_key='pywb.templates_dir'):",
            "        \"\"\"Construct a new JinjaEnv.",
            "",
            "        :param list[str] paths: List of paths to search for templates",
            "        :param list[str] packages: List of assets package names",
            "        :param str assets_path: Path to a yaml file containing assets",
            "        :param dict[str, str] globals: Dictionary of additional globals available during template rendering",
            "        :param overlay:",
            "        :param list extensions: List of webassets extension classes",
            "        :param str env_template_params_key: The full pywb package key for the template params",
            "        :param str env_template_dir_key: The full pywb package key for the template directory",
            "        \"\"\"",
            "",
            "        if paths is None:",
            "            paths = ['templates', '.', '/']",
            "",
            "        if packages is None:",
            "            packages = ['pywb']",
            "",
            "        self._init_filters()",
            "",
            "        loader = ChoiceLoader(self._make_loaders(paths, packages))",
            "",
            "        self.env_template_params_key = env_template_params_key",
            "        self.env_template_dir_key = env_template_dir_key",
            "",
            "        extensions = extensions or []",
            "",
            "        if assets_path:",
            "            extensions.append(AssetsExtension)",
            "",
            "        if overlay:",
            "            jinja_env = overlay.jinja_env.overlay(loader=loader,",
            "                                                  autoescape=select_autoescape(),",
            "                                                  trim_blocks=True,",
            "                                                  extensions=extensions)",
            "        else:",
            "            jinja_env = RelEnvironment(loader=loader,",
            "                                       autoescape=select_autoescape(),",
            "                                       trim_blocks=True,",
            "                                       extensions=extensions)",
            "",
            "        jinja_env.filters.update(self.filters)",
            "",
            "        if globals:",
            "            jinja_env.globals.update(globals)",
            "",
            "        self.jinja_env = jinja_env",
            "",
            "        # init assets",
            "        if assets_path:",
            "            assets_loader = YAMLLoader(load(assets_path))",
            "            assets_env = assets_loader.load_environment()",
            "            assets_env.resolver = PkgResResolver()",
            "            jinja_env.assets_environment = assets_env",
            "",
            "        self.default_locale = ''",
            "",
            "    def _make_loaders(self, paths, packages):",
            "        \"\"\"Initialize the template loaders based on the supplied paths and packages.",
            "",
            "        :param list[str] paths: List of paths to search for templates",
            "        :param list[str] packages: List of assets package names",
            "        :return: A list of loaders to be used for loading the template assets",
            "        :rtype: list[FileSystemLoader|PackageLoader]",
            "        \"\"\"",
            "        loaders = []",
            "        # add loaders for paths",
            "        for path in paths:",
            "            loaders.append(FileSystemLoader(path))",
            "",
            "        # add loaders for all specified packages",
            "        for package in packages:",
            "            loaders.append(PackageLoader(package))",
            "",
            "        return loaders",
            "",
            "    def init_loc(self, locales_root_dir, locales, loc_map, default_locale):",
            "        locales = locales or []",
            "        locales_root_dir = locales_root_dir or os.path.join('i18n', 'translations')",
            "        default_locale = default_locale or 'en'",
            "        self.default_locale = default_locale",
            "",
            "        if locales_root_dir:",
            "            for loc in locales:",
            "                loc_map[loc] = Translations.load(locales_root_dir, [loc, default_locale])",
            "                #jinja_env.jinja_env.install_gettext_translations(translations)",
            "",
            "        def get_translate(context):",
            "            loc = context.get('env', {}).get('pywb_lang', default_locale)",
            "            return loc_map.get(loc)",
            "",
            "        def override_func(jinja_env, name):",
            "            @contextfunction",
            "            def get_override(context, text):",
            "                translate = get_translate(context)",
            "                if not translate:",
            "                    return text",
            "",
            "                func = getattr(translate, name)",
            "                return func(text)",
            "",
            "            jinja_env.globals[name] = get_override",
            "",
            "        # standard gettext() translation function",
            "        override_func(self.jinja_env, 'gettext')",
            "",
            "        # single/plural form translation function",
            "        override_func(self.jinja_env, 'ngettext')",
            "",
            "        # Special _Q() function to return %-encoded text, necessary for use",
            "        # with text in banner",
            "        @contextfunction",
            "        def quote_gettext(context, text):",
            "            translate = get_translate(context)",
            "            if not translate:",
            "                return text",
            "",
            "            text = translate.gettext(text)",
            "            return quote(text, safe='/: ')",
            "",
            "        self.jinja_env.globals['locales'] = list(loc_map.keys())",
            "        self.jinja_env.globals['_Q'] = quote_gettext",
            "        self.jinja_env.globals['default_locale'] = default_locale",
            "",
            "        @contextfunction",
            "        def switch_locale(context, locale):",
            "            environ = context.get('env')",
            "            curr_loc = environ.get('pywb_lang', '')",
            "",
            "            request_uri = environ.get('REQUEST_URI', environ.get('PATH_INFO'))",
            "",
            "            if curr_loc:",
            "                return request_uri.replace(curr_loc, locale, 1)",
            "",
            "            app_prefix = environ.get('pywb.app_prefix', '')",
            "",
            "            if app_prefix and request_uri.startswith(app_prefix):",
            "                request_uri = request_uri.replace(app_prefix, '')",
            "",
            "            return app_prefix + '/' + locale + request_uri",
            "",
            "        @contextfunction",
            "        def get_locale_prefixes(context):",
            "            environ = context.get('env')",
            "            locale_prefixes = {}",
            "",
            "            orig_prefix = environ.get('pywb.app_prefix', '')",
            "            coll = environ.get('SCRIPT_NAME', '')",
            "",
            "            if orig_prefix:",
            "                coll = coll[len(orig_prefix):]",
            "",
            "            curr_loc = environ.get('pywb_lang', '')",
            "            if curr_loc:",
            "                coll = coll[len(curr_loc) + 1:]",
            "",
            "            for locale in loc_map.keys():",
            "                locale_prefixes[locale] = orig_prefix + '/' + locale + coll + '/'",
            "",
            "            return locale_prefixes",
            "",
            "        self.jinja_env.globals['switch_locale'] = switch_locale",
            "        self.jinja_env.globals['get_locale_prefixes'] = get_locale_prefixes",
            "",
            "    def template_filter(self, param=None):",
            "        \"\"\"Returns a decorator that adds the wrapped function to dictionary of template filters.",
            "",
            "        The wrapped function is keyed by either the supplied param (if supplied)",
            "        or by the wrapped functions name.",
            "",
            "        :param param: Optional name to use instead of the name of the function to be wrapped",
            "        :return: A decorator to wrap a template filter function",
            "        :rtype: callable",
            "        \"\"\"",
            "        def deco(func):",
            "            name = param or func.__name__",
            "            self.filters[name] = func",
            "            return func",
            "",
            "        return deco",
            "",
            "    def _init_filters(self):",
            "        \"\"\"Initialize the default pywb provided Jninja filters available during template rendering\"\"\"",
            "        self.filters = {}",
            "",
            "        @self.template_filter()",
            "        def format_ts(value, format_='%a, %b %d %Y %H:%M:%S'):",
            "            \"\"\"Formats the supplied timestamp using format_",
            "",
            "            :param str value: The timestamp to be formatted",
            "            :param str format_:  The format string",
            "            :return: The correctly formatted timestamp as determined by format_",
            "            :rtype: str",
            "            \"\"\"",
            "            if format_ == '%s':",
            "                return timestamp_to_sec(value)",
            "            else:",
            "                value = timestamp_to_datetime(value)",
            "                return value.strftime(format_)",
            "",
            "        @self.template_filter('urlsplit')",
            "        def get_urlsplit(url):",
            "            \"\"\"Splits the supplied URL",
            "",
            "            :param str url: The url to be split",
            "            :return: The split url",
            "            :rtype: urllib.parse.SplitResult",
            "            \"\"\"",
            "            split = urlsplit(url)",
            "            return split",
            "",
            "        @self.template_filter()",
            "        def tojson(obj):",
            "            \"\"\"Converts the supplied object/array/any to a JSON string if it can be JSONified",
            "",
            "            :param any obj: The value to be converted to a JSON string",
            "            :return: The JSON string representation of the supplied value",
            "            :rtype: str",
            "            \"\"\"",
            "            return json.dumps(obj)",
            "",
            "        @self.template_filter()",
            "        def tobool(bool_val):",
            "            \"\"\"Converts a python boolean to a JS \"true\" or \"false\" string",
            "            :param any obj: A value to be evaluated as a boolean",
            "            :return: The string \"true\" or \"false\" to be inserted into JS",
            "            \"\"\"",
            "",
            "            return 'true' if bool_val else 'false'",
            "",
            "",
            "# ============================================================================",
            "class BaseInsertView(object):",
            "    \"\"\"Base class of all template views used by Pywb\"\"\"",
            "",
            "    def __init__(self, jenv, insert_file, banner_view=None):",
            "        \"\"\"Create a new BaseInsertView.",
            "",
            "        :param JinjaEnv jenv: The instance of pywb.rewrite.templateview.JinjaEnv to be used",
            "        :param str insert_file: The name of the template file",
            "        :param BaseInsertView banner_view: The banner_view property of pywb.apps.RewriterApp",
            "        \"\"\"",
            "        self.jenv = jenv",
            "        self.insert_file = insert_file",
            "        self.banner_view = banner_view",
            "",
            "    def render_to_string(self, env, **kwargs):",
            "        \"\"\"Render this template.",
            "",
            "        :param dict env: The WSGI environment associated with the request causing this template to be rendered",
            "        :param any kwargs: The keyword arguments to be supplied to the Jninja template render method",
            "        :return: The rendered template",
            "        :rtype: str",
            "        \"\"\"",
            "        template = None",
            "        template_path = env.get(self.jenv.env_template_dir_key)",
            "",
            "        if template_path:",
            "            # jinja paths are not os paths, always use '/' as separator",
            "            # https://github.com/pallets/jinja/issues/411",
            "            template_path = template_path + '/' + self.insert_file",
            "",
            "            try:",
            "                template = self.jenv.jinja_env.get_template(template_path)",
            "            except TemplateNotFound as te:",
            "                pass",
            "",
            "        if not template:",
            "            template = self.jenv.jinja_env.get_template(self.insert_file)",
            "",
            "        params = env.get(self.jenv.env_template_params_key)",
            "        if params:",
            "            kwargs.update(params)",
            "",
            "        kwargs['env'] = env",
            "        kwargs['static_prefix'] = env.get('pywb.host_prefix', '') + env.get('pywb.app_prefix', '') + '/static'",
            "",
            "",
            "        return template.render(**kwargs)",
            "",
            "",
            "# ============================================================================",
            "class HeadInsertView(BaseInsertView):",
            "    \"\"\"The template view class associated with rendering the HTML inserted",
            "    into the head of the pages replayed (WB Insert).\"\"\"",
            "",
            "    def create_insert_func(self, wb_url,",
            "                           wb_prefix,",
            "                           host_prefix,",
            "                           top_url,",
            "                           env,",
            "                           is_framed,",
            "                           coll='',",
            "                           include_ts=True,",
            "                           **kwargs):",
            "        \"\"\"Create the function used to render the header insert template for the current request.",
            "",
            "        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for",
            "        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)",
            "        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)",
            "        :param str top_url: The full URL for this request (e.g. http://localhost:8080/live/http://example.com)",
            "        :param dict env: The WSGI environment dictionary for this request",
            "        :param bool is_framed: Is pywb or a specific collection running in framed mode",
            "        :param str coll: The name of the collection this request is associated with",
            "        :param bool include_ts: Should a timestamp be included in the rendered template",
            "        :param kwargs: Additional keyword arguments to be supplied to the Jninja template render method",
            "        :return: A function to be used to render the header insert for the request this template is being rendered for",
            "        :rtype: callable",
            "        \"\"\"",
            "        params = kwargs",
            "        params['host_prefix'] = host_prefix",
            "        params['wb_prefix'] = wb_prefix",
            "        params['wb_url'] = wb_url",
            "        params['top_url'] = top_url",
            "        params['coll'] = coll",
            "        params['is_framed'] = is_framed",
            "",
            "        def make_head_insert(rule, cdx):",
            "            params['wombat_ts'] = cdx['timestamp'] if include_ts else ''",
            "            params['wombat_sec'] = timestamp_to_sec(cdx['timestamp'])",
            "            params['is_live'] = cdx.get('is_live')",
            "",
            "            if self.banner_view:",
            "                banner_html = self.banner_view.render_to_string(env, cdx=cdx, **params)",
            "                params['banner_html'] = banner_html",
            "",
            "            return self.render_to_string(env, cdx=cdx, **params)",
            "",
            "        return make_head_insert",
            "",
            "",
            "# ============================================================================",
            "class TopFrameView(BaseInsertView):",
            "    \"\"\"The template view class associated with rendering the replay iframe\"\"\"",
            "",
            "    def get_top_frame(self, wb_url,",
            "                      wb_prefix,",
            "                      host_prefix,",
            "                      env,",
            "                      frame_mod,",
            "                      replay_mod,",
            "                      coll='',",
            "                      extra_params=None):",
            "        \"\"\"",
            "        :param rewrite.wburl.WbUrl wb_url: The WbUrl for the request this template is being rendered for",
            "        :param str wb_prefix: The URL prefix pywb is serving the content using (e.g. http://localhost:8080/live/)",
            "        :param str host_prefix: The host URL prefix pywb is running on (e.g. http://localhost:8080)",
            "        :param dict env: The WSGI environment dictionary for the request this template is being rendered for",
            "        :param str frame_mod:  The modifier to be used for framing (e.g. if_)",
            "        :param str replay_mod: The modifier to be used in the URL of the page being replayed (e.g. mp_)",
            "        :param str coll: The name of the collection this template is being rendered for",
            "        :param dict extra_params: Additional parameters to be supplied to the Jninja template render method",
            "        :return: The frame insert string",
            "        :rtype: str",
            "        \"\"\"",
            "",
            "        embed_url = wb_url.to_str(mod=replay_mod)",
            "",
            "        if wb_url.timestamp:",
            "            timestamp = wb_url.timestamp",
            "        else:",
            "            timestamp = timestamp_now()",
            "",
            "        is_proxy = 'wsgiprox.proxy_host' in env",
            "",
            "        params = {'host_prefix': host_prefix,",
            "                  'wb_prefix': wb_prefix,",
            "                  'wb_url': wb_url,",
            "                  'coll': coll,",
            "",
            "                  'options': {'frame_mod': frame_mod,",
            "                              'replay_mod': replay_mod},",
            "",
            "                  'embed_url': embed_url,",
            "                  'is_proxy': is_proxy,",
            "                  'timestamp': timestamp,",
            "                  'url': wb_url.get_url()",
            "                 }",
            "",
            "        if extra_params:",
            "            params.update(extra_params)",
            "",
            "        if self.banner_view:",
            "            banner_html = self.banner_view.render_to_string(env, **params)",
            "            params['banner_html'] = banner_html",
            "",
            "        return self.render_to_string(env, **params)",
            "",
            "",
            "# ============================================================================",
            "class PkgResResolver(Resolver):",
            "    \"\"\"Class for resolving pywb package resources when install via pypi or setup.py\"\"\"",
            "",
            "    def get_pkg_path(self, item):",
            "        \"\"\"Get the package path for the",
            "",
            "        :param str item: A resources full package path",
            "        :return: The netloc and path from the items package path",
            "        :rtype: tuple[str, str]",
            "        \"\"\"",
            "        if not isinstance(item, str):",
            "            return None",
            "",
            "        parts = urlsplit(item)",
            "        if parts.scheme == 'pkg' and parts.netloc:",
            "            return (parts.netloc, parts.path)",
            "",
            "        return None",
            "",
            "    def resolve_source(self, ctx, item):",
            "        pkg = self.get_pkg_path(item)",
            "        if pkg:",
            "            filename = resource_filename(pkg[0], pkg[1])",
            "            if filename:",
            "                return filename",
            "",
            "        return super(PkgResResolver, self).resolve_source(ctx, item)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": []
        },
        "addLocation": []
    },
    "pywb/version.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = '2.6.0b0'"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+__version__ = '2.6.0b1'"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " if __name__ == '__main__':"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": "     print(__version__)"
            }
        },
        "frontPatchFile": [
            "__version__ = '2.6.0b0'",
            "",
            "if __name__ == '__main__':",
            "    print(__version__)"
        ],
        "afterPatchFile": [
            "__version__ = '2.6.0b1'",
            "",
            "if __name__ == '__main__':",
            "    print(__version__)"
        ],
        "action": [
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "          glob.glob('sample_archive/text_content/*')),"
            },
            "1": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     ],"
            },
            "2": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "     install_requires=load_requirements('requirements.txt'),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    extras_require={"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        \"i18n\":  [\"translate_toolkit\"],"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    },"
            },
            "6": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     tests_require=["
            },
            "7": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         'pytest',"
            },
            "8": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         'WebTest',"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# vim: set sw=4 et:",
            "",
            "from setuptools import setup, find_packages",
            "from setuptools.command.test import test as TestCommand",
            "import glob",
            "import os",
            "import sys",
            "",
            "from pywb import __version__",
            "",
            "",
            "def get_long_description():",
            "    with open('README.rst', 'r') as fh:",
            "        long_description = fh.read()",
            "    return long_description",
            "",
            "",
            "class PyTest(TestCommand):",
            "    user_options = []",
            "",
            "    def finalize_options(self):",
            "        TestCommand.finalize_options(self)",
            "        self.test_suite = ' '",
            "",
            "    def run_tests(self):",
            "        from gevent.monkey import patch_all",
            "        patch_all()",
            "",
            "        import pytest",
            "        import os",
            "        os.environ.pop('PYWB_CONFIG_FILE', None)",
            "        cmdline = '--cov-config .coveragerc --cov pywb'",
            "        cmdline += ' -v --doctest-modules ./pywb/ tests/'",
            "",
            "        errcode = pytest.main(cmdline.split(' '))",
            "",
            "        sys.exit(errcode)",
            "",
            "",
            "def get_git_short_hash():",
            "    import subprocess",
            "    try:",
            "        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()",
            "        if sys.version_info >= (3, 0):",
            "            hash_id = hash_id.decode('utf-8')",
            "",
            "        return hash_id",
            "    except Exception:",
            "        return ''",
            "",
            "",
            "def generate_git_hash_py(pkg, filename='git_hash.py'):",
            "    try:",
            "        git_hash = get_git_short_hash()",
            "        with open(os.path.join(pkg, filename), 'wt') as fh:",
            "            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def load_requirements(filename):",
            "    with open(filename, 'rt') as fh:",
            "        requirements = fh.read().rstrip().split('\\n')",
            "    if sys.version_info > (3, 0):",
            "        requirements.append(\"py3AMF\")",
            "    else:",
            "        requirements.append(\"pyAMF\")",
            "    return requirements",
            "",
            "",
            "def get_package_data():",
            "    pkgs = ['static/*.*',",
            "            'templates/*',",
            "            '*.yaml']",
            "",
            "    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):",
            "        for dir_ in dirs:",
            "            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))",
            "",
            "    return pkgs",
            "",
            "",
            "generate_git_hash_py('pywb')",
            "",
            "setup(",
            "    name='pywb',",
            "    version=__version__,",
            "    url='https://github.com/webrecorder/pywb',",
            "    author='Ilya Kreymer',",
            "    author_email='ikreymer@gmail.com',",
            "    description='Pywb Webrecorder web archive replay and capture tools',",
            "    long_description=get_long_description(),",
            "    license='GPL',",
            "    packages=find_packages(exclude=['tests_disabled']),",
            "    zip_safe=False,",
            "    package_data={",
            "        'pywb': get_package_data(),",
            "    },",
            "    data_files=[",
            "        ('sample_archive/cdx', glob.glob('sample_archive/cdx/*')),",
            "        ('sample_archive/cdxj', glob.glob('sample_archive/cdxj/*')),",
            "        ('sample_archive/non-surt-cdx', glob.glob('sample_archive/non-surt-cdx/*')),",
            "        ('sample_archive/zipcdx', glob.glob('sample_archive/zipcdx/*')),",
            "        ('sample_archive/warcs', glob.glob('sample_archive/warcs/*')),",
            "        ('sample_archive/text_content',",
            "         glob.glob('sample_archive/text_content/*')),",
            "    ],",
            "    install_requires=load_requirements('requirements.txt'),",
            "    tests_require=[",
            "        'pytest',",
            "        'WebTest',",
            "        'pytest-cov',",
            "        'mock',",
            "        'urllib3',",
            "        'werkzeug',",
            "        'httpbin==0.5.0',",
            "        'ujson',",
            "        'lxml'",
            "    ],",
            "    cmdclass={'test': PyTest},",
            "    test_suite='',",
            "    entry_points=\"\"\"",
            "        [console_scripts]",
            "        pywb = pywb.apps.cli:wayback",
            "        wayback = pywb.apps.cli:wayback",
            "        cdx-server = pywb.apps.cli:cdx_server",
            "        live-rewrite-server = pywb.apps.cli:live_rewrite_server",
            "        cdx-indexer = pywb.indexer.cdxindexer:main",
            "        wb-manager = pywb.manager.manager:main_wrap_exc",
            "        warcserver = pywb.apps.cli:warcserver",
            "        \"\"\",",
            "    classifiers=[",
            "        'Development Status :: 4 - Beta',",
            "        'Environment :: Web Environment',",
            "        'License :: OSI Approved :: GNU General Public License (GPL)',",
            "        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',",
            "        'Programming Language :: Python :: 2',",
            "        'Programming Language :: Python :: 2.7',",
            "        'Programming Language :: Python :: 3',",
            "        'Programming Language :: Python :: 3.3',",
            "        'Programming Language :: Python :: 3.4',",
            "        'Programming Language :: Python :: 3.5',",
            "        'Programming Language :: Python :: 3.6',",
            "        'Programming Language :: Python :: 3.7',",
            "        'Programming Language :: Python :: 3.8',",
            "        'Programming Language :: Python :: 3.9',",
            "        'Topic :: Internet :: Proxy Servers',",
            "        'Topic :: Internet :: WWW/HTTP',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Server',",
            "        'Topic :: Software Development :: Libraries :: Python Modules',",
            "        'Topic :: System :: Archiving',",
            "        'Topic :: System :: Archiving :: Backup',",
            "        'Topic :: Utilities',",
            "    ])"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# vim: set sw=4 et:",
            "",
            "from setuptools import setup, find_packages",
            "from setuptools.command.test import test as TestCommand",
            "import glob",
            "import os",
            "import sys",
            "",
            "from pywb import __version__",
            "",
            "",
            "def get_long_description():",
            "    with open('README.rst', 'r') as fh:",
            "        long_description = fh.read()",
            "    return long_description",
            "",
            "",
            "class PyTest(TestCommand):",
            "    user_options = []",
            "",
            "    def finalize_options(self):",
            "        TestCommand.finalize_options(self)",
            "        self.test_suite = ' '",
            "",
            "    def run_tests(self):",
            "        from gevent.monkey import patch_all",
            "        patch_all()",
            "",
            "        import pytest",
            "        import os",
            "        os.environ.pop('PYWB_CONFIG_FILE', None)",
            "        cmdline = '--cov-config .coveragerc --cov pywb'",
            "        cmdline += ' -v --doctest-modules ./pywb/ tests/'",
            "",
            "        errcode = pytest.main(cmdline.split(' '))",
            "",
            "        sys.exit(errcode)",
            "",
            "",
            "def get_git_short_hash():",
            "    import subprocess",
            "    try:",
            "        hash_id = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()",
            "        if sys.version_info >= (3, 0):",
            "            hash_id = hash_id.decode('utf-8')",
            "",
            "        return hash_id",
            "    except Exception:",
            "        return ''",
            "",
            "",
            "def generate_git_hash_py(pkg, filename='git_hash.py'):",
            "    try:",
            "        git_hash = get_git_short_hash()",
            "        with open(os.path.join(pkg, filename), 'wt') as fh:",
            "            fh.write('git_hash = \"{0}\"\\n'.format(git_hash))",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def load_requirements(filename):",
            "    with open(filename, 'rt') as fh:",
            "        requirements = fh.read().rstrip().split('\\n')",
            "    if sys.version_info > (3, 0):",
            "        requirements.append(\"py3AMF\")",
            "    else:",
            "        requirements.append(\"pyAMF\")",
            "    return requirements",
            "",
            "",
            "def get_package_data():",
            "    pkgs = ['static/*.*',",
            "            'templates/*',",
            "            '*.yaml']",
            "",
            "    for root, dirs, files in os.walk(os.path.join('pywb', 'static')):",
            "        for dir_ in dirs:",
            "            pkgs.append(os.path.relpath(os.path.join(root, dir_, '*'), 'pywb'))",
            "",
            "    return pkgs",
            "",
            "",
            "generate_git_hash_py('pywb')",
            "",
            "setup(",
            "    name='pywb',",
            "    version=__version__,",
            "    url='https://github.com/webrecorder/pywb',",
            "    author='Ilya Kreymer',",
            "    author_email='ikreymer@gmail.com',",
            "    description='Pywb Webrecorder web archive replay and capture tools',",
            "    long_description=get_long_description(),",
            "    license='GPL',",
            "    packages=find_packages(exclude=['tests_disabled']),",
            "    zip_safe=False,",
            "    package_data={",
            "        'pywb': get_package_data(),",
            "    },",
            "    data_files=[",
            "        ('sample_archive/cdx', glob.glob('sample_archive/cdx/*')),",
            "        ('sample_archive/cdxj', glob.glob('sample_archive/cdxj/*')),",
            "        ('sample_archive/non-surt-cdx', glob.glob('sample_archive/non-surt-cdx/*')),",
            "        ('sample_archive/zipcdx', glob.glob('sample_archive/zipcdx/*')),",
            "        ('sample_archive/warcs', glob.glob('sample_archive/warcs/*')),",
            "        ('sample_archive/text_content',",
            "         glob.glob('sample_archive/text_content/*')),",
            "    ],",
            "    install_requires=load_requirements('requirements.txt'),",
            "    extras_require={",
            "        \"i18n\":  [\"translate_toolkit\"],",
            "    },",
            "    tests_require=[",
            "        'pytest',",
            "        'WebTest',",
            "        'pytest-cov',",
            "        'mock',",
            "        'urllib3',",
            "        'werkzeug',",
            "        'httpbin==0.5.0',",
            "        'ujson',",
            "        'lxml'",
            "    ],",
            "    cmdclass={'test': PyTest},",
            "    test_suite='',",
            "    entry_points=\"\"\"",
            "        [console_scripts]",
            "        pywb = pywb.apps.cli:wayback",
            "        wayback = pywb.apps.cli:wayback",
            "        cdx-server = pywb.apps.cli:cdx_server",
            "        live-rewrite-server = pywb.apps.cli:live_rewrite_server",
            "        cdx-indexer = pywb.indexer.cdxindexer:main",
            "        wb-manager = pywb.manager.manager:main_wrap_exc",
            "        warcserver = pywb.apps.cli:warcserver",
            "        \"\"\",",
            "    classifiers=[",
            "        'Development Status :: 4 - Beta',",
            "        'Environment :: Web Environment',",
            "        'License :: OSI Approved :: GNU General Public License (GPL)',",
            "        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',",
            "        'Programming Language :: Python :: 2',",
            "        'Programming Language :: Python :: 2.7',",
            "        'Programming Language :: Python :: 3',",
            "        'Programming Language :: Python :: 3.3',",
            "        'Programming Language :: Python :: 3.4',",
            "        'Programming Language :: Python :: 3.5',",
            "        'Programming Language :: Python :: 3.6',",
            "        'Programming Language :: Python :: 3.7',",
            "        'Programming Language :: Python :: 3.8',",
            "        'Programming Language :: Python :: 3.9',",
            "        'Topic :: Internet :: Proxy Servers',",
            "        'Topic :: Internet :: WWW/HTTP',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware',",
            "        'Topic :: Internet :: WWW/HTTP :: WSGI :: Server',",
            "        'Topic :: Software Development :: Libraries :: Python Modules',",
            "        'Topic :: System :: Archiving',",
            "        'Topic :: System :: Archiving :: Backup',",
            "        'Topic :: Utilities',",
            "    ])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}