{
    "vyper/semantics/analysis/data_positions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from vyper.exceptions import StorageLayoutException"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from vyper.semantics.analysis.base import CodeOffset, StorageSlot"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from vyper.typing import StorageLayout"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from vyper.utils import ceil32"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " def set_data_positions("
            },
            "7": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         # Expect to find this variable within the storage layout overrides"
            },
            "8": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         if node.target.id in storage_layout_overrides:"
            },
            "9": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             var_slot = storage_layout_overrides[node.target.id][\"slot\"]"
            },
            "10": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Calculate how many storage slots are required"
            },
            "11": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            storage_length = math.ceil(varinfo.typ.size_in_bytes / 32)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            storage_length = varinfo.typ.storage_size_in_words"
            },
            "13": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             # Ensure that all required storage slots are reserved, and prevents other variables"
            },
            "14": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             # from using these slots"
            },
            "15": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "             reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)"
            },
            "16": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     return ret"
            },
            "17": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+class SimpleStorageAllocator:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    def __init__(self, starting_slot: int = 0):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        self._slot = starting_slot"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    def allocate_slot(self, n, var_name):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        ret = self._slot"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        if self._slot + n >= 2**256:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            raise StorageLayoutException("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                f\"Invalid storage slot for var {var_name}, tried to allocate\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                f\" slots {self._slot} through {self._slot + n}\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            )"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        self._slot += n"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        return ret"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:"
            },
            "35": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     \"\"\""
            },
            "36": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     Parse module-level Vyper AST to calculate the layout of storage variables."
            },
            "37": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     Returns the layout as a dict of variable name -> variable info"
            },
            "38": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     \"\"\""
            },
            "39": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     # Allocate storage slots from 0"
            },
            "40": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     # note storage is word-addressable, not byte-addressable"
            },
            "41": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    storage_slot = 0"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    allocator = SimpleStorageAllocator()"
            },
            "43": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     ret: Dict[str, Dict] = {}"
            },
            "45": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             type_.set_reentrancy_key_position(StorageSlot(_slot))"
            },
            "47": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             continue"
            },
            "48": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        type_.set_reentrancy_key_position(StorageSlot(storage_slot))"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        # TODO use one byte - or bit - per reentrancy key"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        # requires either an extra SLOAD or caching the value of the"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        # location in memory at entrance"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        slot = allocator.allocate_slot(1, variable_name)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        type_.set_reentrancy_key_position(StorageSlot(slot))"
            },
            "56": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         # TODO this could have better typing but leave it untyped until"
            },
            "58": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         # we nail down the format better"
            },
            "59": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": storage_slot}"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": slot}"
            },
            "61": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # TODO use one byte - or bit - per reentrancy key"
            },
            "63": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # requires either an extra SLOAD or caching the value of the"
            },
            "64": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # location in memory at entrance"
            },
            "65": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        storage_slot += 1"
            },
            "66": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "     for node in vyper_module.get_children(vy_ast.VariableDecl):"
            },
            "68": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         # skip non-storage variables"
            },
            "69": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         if node.is_constant or node.is_immutable:"
            },
            "70": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "             continue"
            },
            "71": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         varinfo = node.target._metadata[\"varinfo\"]"
            },
            "73": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        varinfo.set_position(StorageSlot(storage_slot))"
            },
            "74": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "75": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         type_ = varinfo.typ"
            },
            "76": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 202,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # this could have better typing but leave it untyped until"
            },
            "78": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # we understand the use case better"
            },
            "79": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ret[node.target.id] = {\"type\": str(type_), \"slot\": storage_slot}"
            },
            "80": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "81": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         # CMC 2021-07-23 note that HashMaps get assigned a slot here."
            },
            "82": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         # I'm not sure if it's safe to avoid allocating that slot"
            },
            "83": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         # for HashMaps because downstream code might use the slot"
            },
            "84": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         # ID as a salt."
            },
            "85": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        storage_slot += math.ceil(type_.size_in_bytes / 32)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        n_slots = type_.storage_size_in_words"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        slot = allocator.allocate_slot(n_slots, node.target.id)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        varinfo.set_position(StorageSlot(slot))"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        # this could have better typing but leave it untyped until"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        # we understand the use case better"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        ret[node.target.id] = {\"type\": str(type_), \"slot\": slot}"
            },
            "94": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 215,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     return ret"
            },
            "96": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 217,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         type_ = varinfo.typ"
            },
            "98": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         varinfo.set_position(CodeOffset(offset))"
            },
            "99": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " "
            },
            "100": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        len_ = math.ceil(type_.size_in_bytes / 32) * 32"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        len_ = ceil32(type_.size_in_bytes)"
            },
            "102": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         # this could have better typing but leave it untyped until"
            },
            "104": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         # we understand the use case better"
            }
        },
        "frontPatchFile": [
            "# TODO this doesn't really belong in \"validation\"",
            "import math",
            "from typing import Dict, List",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.exceptions import StorageLayoutException",
            "from vyper.semantics.analysis.base import CodeOffset, StorageSlot",
            "from vyper.typing import StorageLayout",
            "",
            "",
            "def set_data_positions(",
            "    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout = None",
            ") -> StorageLayout:",
            "    \"\"\"",
            "    Parse the annotated Vyper AST, determine data positions for all variables,",
            "    and annotate the AST nodes with the position data.",
            "",
            "    Arguments",
            "    ---------",
            "    vyper_module : vy_ast.Module",
            "        Top-level Vyper AST node that has already been annotated with type data.",
            "    \"\"\"",
            "    code_offsets = set_code_offsets(vyper_module)",
            "    storage_slots = (",
            "        set_storage_slots_with_overrides(vyper_module, storage_layout_overrides)",
            "        if storage_layout_overrides is not None",
            "        else set_storage_slots(vyper_module)",
            "    )",
            "",
            "    return {\"storage_layout\": storage_slots, \"code_layout\": code_offsets}",
            "",
            "",
            "class StorageAllocator:",
            "    \"\"\"",
            "    Keep track of which storage slots have been used. If there is a collision of",
            "    storage slots, this will raise an error and fail to compile",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.occupied_slots: Dict[int, str] = {}",
            "",
            "    def reserve_slot_range(self, first_slot: int, n_slots: int, var_name: str) -> None:",
            "        \"\"\"",
            "        Reserves `n_slots` storage slots, starting at slot `first_slot`",
            "        This will raise an error if a storage slot has already been allocated.",
            "        It is responsibility of calling function to ensure first_slot is an int",
            "        \"\"\"",
            "        list_to_check = [x + first_slot for x in range(n_slots)]",
            "        self._reserve_slots(list_to_check, var_name)",
            "",
            "    def _reserve_slots(self, slots: List[int], var_name: str) -> None:",
            "        for slot in slots:",
            "            self._reserve_slot(slot, var_name)",
            "",
            "    def _reserve_slot(self, slot: int, var_name: str) -> None:",
            "        if slot < 0 or slot >= 2**256:",
            "            raise StorageLayoutException(",
            "                f\"Invalid storage slot for var {var_name}, out of bounds: {slot}\"",
            "            )",
            "        if slot in self.occupied_slots:",
            "            collided_var = self.occupied_slots[slot]",
            "            raise StorageLayoutException(",
            "                f\"Storage collision! Tried to assign '{var_name}' to slot {slot} but it has \"",
            "                f\"already been reserved by '{collided_var}'\"",
            "            )",
            "        self.occupied_slots[slot] = var_name",
            "",
            "",
            "def set_storage_slots_with_overrides(",
            "    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout",
            ") -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "",
            "    ret: Dict[str, Dict] = {}",
            "    reserved_slots = StorageAllocator()",
            "",
            "    # Search through function definitions to find non-reentrant functions",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "",
            "        # Ignore functions without non-reentrant",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # re-entrant key was already identified",
            "        if variable_name in ret:",
            "            _slot = ret[variable_name][\"slot\"]",
            "            type_.set_reentrancy_key_position(StorageSlot(_slot))",
            "            continue",
            "",
            "        # Expect to find this variable within the storage layout override",
            "        if variable_name in storage_layout_overrides:",
            "            reentrant_slot = storage_layout_overrides[variable_name][\"slot\"]",
            "            # Ensure that this slot has not been used, and prevents other storage variables",
            "            # from using the same slot",
            "            reserved_slots.reserve_slot_range(reentrant_slot, 1, variable_name)",
            "",
            "            type_.set_reentrancy_key_position(StorageSlot(reentrant_slot))",
            "",
            "            ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": reentrant_slot}",
            "        else:",
            "            raise StorageLayoutException(",
            "                f\"Could not find storage_slot for {variable_name}. \"",
            "                \"Have you used the correct storage layout file?\",",
            "                node,",
            "            )",
            "",
            "    # Iterate through variables",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl):",
            "        # Ignore immutable parameters",
            "        if node.get(\"annotation.func.id\") == \"immutable\":",
            "            continue",
            "",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "",
            "        # Expect to find this variable within the storage layout overrides",
            "        if node.target.id in storage_layout_overrides:",
            "            var_slot = storage_layout_overrides[node.target.id][\"slot\"]",
            "            # Calculate how many storage slots are required",
            "            storage_length = math.ceil(varinfo.typ.size_in_bytes / 32)",
            "            # Ensure that all required storage slots are reserved, and prevents other variables",
            "            # from using these slots",
            "            reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)",
            "            varinfo.set_position(StorageSlot(var_slot))",
            "",
            "            ret[node.target.id] = {\"type\": str(varinfo.typ), \"slot\": var_slot}",
            "        else:",
            "            raise StorageLayoutException(",
            "                f\"Could not find storage_slot for {node.target.id}. \"",
            "                \"Have you used the correct storage layout file?\",",
            "                node,",
            "            )",
            "",
            "    return ret",
            "",
            "",
            "def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "    # Allocate storage slots from 0",
            "    # note storage is word-addressable, not byte-addressable",
            "    storage_slot = 0",
            "",
            "    ret: Dict[str, Dict] = {}",
            "",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # a nonreentrant key can appear many times in a module but it",
            "        # only takes one slot. after the first time we see it, do not",
            "        # increment the storage slot.",
            "        if variable_name in ret:",
            "            _slot = ret[variable_name][\"slot\"]",
            "            type_.set_reentrancy_key_position(StorageSlot(_slot))",
            "            continue",
            "",
            "        type_.set_reentrancy_key_position(StorageSlot(storage_slot))",
            "",
            "        # TODO this could have better typing but leave it untyped until",
            "        # we nail down the format better",
            "        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": storage_slot}",
            "",
            "        # TODO use one byte - or bit - per reentrancy key",
            "        # requires either an extra SLOAD or caching the value of the",
            "        # location in memory at entrance",
            "        storage_slot += 1",
            "",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl):",
            "        # skip non-storage variables",
            "        if node.is_constant or node.is_immutable:",
            "            continue",
            "",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "        varinfo.set_position(StorageSlot(storage_slot))",
            "",
            "        type_ = varinfo.typ",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"slot\": storage_slot}",
            "",
            "        # CMC 2021-07-23 note that HashMaps get assigned a slot here.",
            "        # I'm not sure if it's safe to avoid allocating that slot",
            "        # for HashMaps because downstream code might use the slot",
            "        # ID as a salt.",
            "        storage_slot += math.ceil(type_.size_in_bytes / 32)",
            "",
            "    return ret",
            "",
            "",
            "def set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_code_offsets(vyper_module: vy_ast.Module) -> Dict:",
            "    ret = {}",
            "    offset = 0",
            "",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl, filters={\"is_immutable\": True}):",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "        type_ = varinfo.typ",
            "        varinfo.set_position(CodeOffset(offset))",
            "",
            "        len_ = math.ceil(type_.size_in_bytes / 32) * 32",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"offset\": offset, \"length\": len_}",
            "",
            "        offset += len_",
            "",
            "    return ret"
        ],
        "afterPatchFile": [
            "# TODO this doesn't really belong in \"validation\"",
            "import math",
            "from typing import Dict, List",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.exceptions import StorageLayoutException",
            "from vyper.semantics.analysis.base import CodeOffset, StorageSlot",
            "from vyper.typing import StorageLayout",
            "from vyper.utils import ceil32",
            "",
            "",
            "def set_data_positions(",
            "    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout = None",
            ") -> StorageLayout:",
            "    \"\"\"",
            "    Parse the annotated Vyper AST, determine data positions for all variables,",
            "    and annotate the AST nodes with the position data.",
            "",
            "    Arguments",
            "    ---------",
            "    vyper_module : vy_ast.Module",
            "        Top-level Vyper AST node that has already been annotated with type data.",
            "    \"\"\"",
            "    code_offsets = set_code_offsets(vyper_module)",
            "    storage_slots = (",
            "        set_storage_slots_with_overrides(vyper_module, storage_layout_overrides)",
            "        if storage_layout_overrides is not None",
            "        else set_storage_slots(vyper_module)",
            "    )",
            "",
            "    return {\"storage_layout\": storage_slots, \"code_layout\": code_offsets}",
            "",
            "",
            "class StorageAllocator:",
            "    \"\"\"",
            "    Keep track of which storage slots have been used. If there is a collision of",
            "    storage slots, this will raise an error and fail to compile",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self.occupied_slots: Dict[int, str] = {}",
            "",
            "    def reserve_slot_range(self, first_slot: int, n_slots: int, var_name: str) -> None:",
            "        \"\"\"",
            "        Reserves `n_slots` storage slots, starting at slot `first_slot`",
            "        This will raise an error if a storage slot has already been allocated.",
            "        It is responsibility of calling function to ensure first_slot is an int",
            "        \"\"\"",
            "        list_to_check = [x + first_slot for x in range(n_slots)]",
            "        self._reserve_slots(list_to_check, var_name)",
            "",
            "    def _reserve_slots(self, slots: List[int], var_name: str) -> None:",
            "        for slot in slots:",
            "            self._reserve_slot(slot, var_name)",
            "",
            "    def _reserve_slot(self, slot: int, var_name: str) -> None:",
            "        if slot < 0 or slot >= 2**256:",
            "            raise StorageLayoutException(",
            "                f\"Invalid storage slot for var {var_name}, out of bounds: {slot}\"",
            "            )",
            "        if slot in self.occupied_slots:",
            "            collided_var = self.occupied_slots[slot]",
            "            raise StorageLayoutException(",
            "                f\"Storage collision! Tried to assign '{var_name}' to slot {slot} but it has \"",
            "                f\"already been reserved by '{collided_var}'\"",
            "            )",
            "        self.occupied_slots[slot] = var_name",
            "",
            "",
            "def set_storage_slots_with_overrides(",
            "    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout",
            ") -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "",
            "    ret: Dict[str, Dict] = {}",
            "    reserved_slots = StorageAllocator()",
            "",
            "    # Search through function definitions to find non-reentrant functions",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "",
            "        # Ignore functions without non-reentrant",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # re-entrant key was already identified",
            "        if variable_name in ret:",
            "            _slot = ret[variable_name][\"slot\"]",
            "            type_.set_reentrancy_key_position(StorageSlot(_slot))",
            "            continue",
            "",
            "        # Expect to find this variable within the storage layout override",
            "        if variable_name in storage_layout_overrides:",
            "            reentrant_slot = storage_layout_overrides[variable_name][\"slot\"]",
            "            # Ensure that this slot has not been used, and prevents other storage variables",
            "            # from using the same slot",
            "            reserved_slots.reserve_slot_range(reentrant_slot, 1, variable_name)",
            "",
            "            type_.set_reentrancy_key_position(StorageSlot(reentrant_slot))",
            "",
            "            ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": reentrant_slot}",
            "        else:",
            "            raise StorageLayoutException(",
            "                f\"Could not find storage_slot for {variable_name}. \"",
            "                \"Have you used the correct storage layout file?\",",
            "                node,",
            "            )",
            "",
            "    # Iterate through variables",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl):",
            "        # Ignore immutable parameters",
            "        if node.get(\"annotation.func.id\") == \"immutable\":",
            "            continue",
            "",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "",
            "        # Expect to find this variable within the storage layout overrides",
            "        if node.target.id in storage_layout_overrides:",
            "            var_slot = storage_layout_overrides[node.target.id][\"slot\"]",
            "            storage_length = varinfo.typ.storage_size_in_words",
            "            # Ensure that all required storage slots are reserved, and prevents other variables",
            "            # from using these slots",
            "            reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)",
            "            varinfo.set_position(StorageSlot(var_slot))",
            "",
            "            ret[node.target.id] = {\"type\": str(varinfo.typ), \"slot\": var_slot}",
            "        else:",
            "            raise StorageLayoutException(",
            "                f\"Could not find storage_slot for {node.target.id}. \"",
            "                \"Have you used the correct storage layout file?\",",
            "                node,",
            "            )",
            "",
            "    return ret",
            "",
            "",
            "class SimpleStorageAllocator:",
            "    def __init__(self, starting_slot: int = 0):",
            "        self._slot = starting_slot",
            "",
            "    def allocate_slot(self, n, var_name):",
            "        ret = self._slot",
            "        if self._slot + n >= 2**256:",
            "            raise StorageLayoutException(",
            "                f\"Invalid storage slot for var {var_name}, tried to allocate\"",
            "                f\" slots {self._slot} through {self._slot + n}\"",
            "            )",
            "        self._slot += n",
            "        return ret",
            "",
            "",
            "def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:",
            "    \"\"\"",
            "    Parse module-level Vyper AST to calculate the layout of storage variables.",
            "    Returns the layout as a dict of variable name -> variable info",
            "    \"\"\"",
            "    # Allocate storage slots from 0",
            "    # note storage is word-addressable, not byte-addressable",
            "    allocator = SimpleStorageAllocator()",
            "",
            "    ret: Dict[str, Dict] = {}",
            "",
            "    for node in vyper_module.get_children(vy_ast.FunctionDef):",
            "        type_ = node._metadata[\"type\"]",
            "        if type_.nonreentrant is None:",
            "            continue",
            "",
            "        variable_name = f\"nonreentrant.{type_.nonreentrant}\"",
            "",
            "        # a nonreentrant key can appear many times in a module but it",
            "        # only takes one slot. after the first time we see it, do not",
            "        # increment the storage slot.",
            "        if variable_name in ret:",
            "            _slot = ret[variable_name][\"slot\"]",
            "            type_.set_reentrancy_key_position(StorageSlot(_slot))",
            "            continue",
            "",
            "        # TODO use one byte - or bit - per reentrancy key",
            "        # requires either an extra SLOAD or caching the value of the",
            "        # location in memory at entrance",
            "        slot = allocator.allocate_slot(1, variable_name)",
            "",
            "        type_.set_reentrancy_key_position(StorageSlot(slot))",
            "",
            "        # TODO this could have better typing but leave it untyped until",
            "        # we nail down the format better",
            "        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": slot}",
            "",
            "",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl):",
            "        # skip non-storage variables",
            "        if node.is_constant or node.is_immutable:",
            "            continue",
            "",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "        type_ = varinfo.typ",
            "",
            "        # CMC 2021-07-23 note that HashMaps get assigned a slot here.",
            "        # I'm not sure if it's safe to avoid allocating that slot",
            "        # for HashMaps because downstream code might use the slot",
            "        # ID as a salt.",
            "        n_slots = type_.storage_size_in_words",
            "        slot = allocator.allocate_slot(n_slots, node.target.id)",
            "",
            "        varinfo.set_position(StorageSlot(slot))",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"slot\": slot}",
            "",
            "    return ret",
            "",
            "",
            "def set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:",
            "    pass",
            "",
            "",
            "def set_code_offsets(vyper_module: vy_ast.Module) -> Dict:",
            "    ret = {}",
            "    offset = 0",
            "",
            "    for node in vyper_module.get_children(vy_ast.VariableDecl, filters={\"is_immutable\": True}):",
            "        varinfo = node.target._metadata[\"varinfo\"]",
            "        type_ = varinfo.typ",
            "        varinfo.set_position(CodeOffset(offset))",
            "",
            "        len_ = ceil32(type_.size_in_bytes)",
            "",
            "        # this could have better typing but leave it untyped until",
            "        # we understand the use case better",
            "        ret[node.target.id] = {\"type\": str(type_), \"offset\": offset, \"length\": len_}",
            "",
            "        offset += len_",
            "",
            "    return ret"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "124": [
                "set_storage_slots_with_overrides"
            ],
            "125": [
                "set_storage_slots_with_overrides"
            ],
            "149": [
                "set_storage_slots"
            ],
            "168": [
                "set_storage_slots"
            ],
            "172": [
                "set_storage_slots"
            ],
            "174": [
                "set_storage_slots"
            ],
            "175": [
                "set_storage_slots"
            ],
            "176": [
                "set_storage_slots"
            ],
            "177": [
                "set_storage_slots"
            ],
            "185": [
                "set_storage_slots"
            ],
            "186": [
                "set_storage_slots"
            ],
            "189": [
                "set_storage_slots"
            ],
            "190": [
                "set_storage_slots"
            ],
            "191": [
                "set_storage_slots"
            ],
            "192": [
                "set_storage_slots"
            ],
            "197": [
                "set_storage_slots"
            ],
            "219": [
                "set_code_offsets"
            ]
        },
        "addLocation": []
    },
    "vyper/semantics/types/subscriptable.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         if not 0 < length < 2**256:"
            },
            "1": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             raise InvalidType(\"Array length is invalid\")"
            },
            "2": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        if length >= 2**64:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            warnings.warn(\"Use of large arrays can be unsafe!\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         super().__init__(UINT256_T, value_type)"
            },
            "7": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         self.length = length"
            },
            "8": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from typing import Any, Dict, Optional, Tuple, Union",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.abi_types import ABI_DynamicArray, ABI_StaticArray, ABI_Tuple, ABIType",
            "from vyper.exceptions import ArrayIndexException, InvalidType, StructureException",
            "from vyper.semantics.types.base import VyperType",
            "from vyper.semantics.types.primitives import IntegerT",
            "from vyper.semantics.types.shortcuts import UINT256_T",
            "from vyper.semantics.types.utils import get_index_value, type_from_annotation",
            "",
            "",
            "class _SubscriptableT(VyperType):",
            "    \"\"\"",
            "    Base class for subscriptable types such as arrays and mappings.",
            "",
            "    Attributes",
            "    ----------",
            "    key_type: VyperType",
            "        Type representing the index for this object.",
            "    value_type : VyperType",
            "        Type representing the value(s) contained in this object.",
            "    \"\"\"",
            "",
            "    def __init__(self, key_type: VyperType, value_type: VyperType) -> None:",
            "        super().__init__()",
            "        self.key_type = key_type",
            "        self.value_type = value_type",
            "",
            "    @property",
            "    def getter_signature(self) -> Tuple[Tuple, Optional[VyperType]]:",
            "        child_keys, return_type = self.value_type.getter_signature",
            "        return (self.key_type,) + child_keys, return_type",
            "",
            "    def validate_index_type(self, node):",
            "        # TODO: break this cycle",
            "        from vyper.semantics.analysis.utils import validate_expected_type",
            "",
            "        validate_expected_type(node, self.key_type)",
            "",
            "",
            "class HashMapT(_SubscriptableT):",
            "    _id = \"HashMap\"",
            "",
            "    _equality_attrs = (\"key_type\", \"value_type\")",
            "",
            "    def __repr__(self):",
            "        return f\"HashMap[{self.key_type}, {self.value_type}]\"",
            "",
            "    # TODO not sure this is used?",
            "    def compare_type(self, other):",
            "        return (",
            "            super().compare_type(other)",
            "            and self.key_type == other.key_type",
            "            and self.value_type == other.value_type",
            "        )",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript]) -> \"HashMapT\":",
            "        if (",
            "            not isinstance(node, vy_ast.Subscript)",
            "            or not isinstance(node.slice, vy_ast.Index)",
            "            or not isinstance(node.slice.value, vy_ast.Tuple)",
            "            or len(node.slice.value.elements) != 2",
            "        ):",
            "            raise StructureException(",
            "                (",
            "                    \"HashMap must be defined with a key type and a value type, \"",
            "                    \"e.g. my_hashmap: HashMap[k, v]\"",
            "                ),",
            "                node,",
            "            )",
            "        # if location != DataLocation.STORAGE or is_immutable:",
            "        #    raise StructureException(\"HashMap can only be declared as a storage variable\", node)",
            "",
            "        k_ast, v_ast = node.slice.value.elements",
            "        key_type = type_from_annotation(k_ast)",
            "        if not key_type._as_hashmap_key:",
            "            raise InvalidType(\"can only use primitive types as HashMap key!\", k_ast)",
            "",
            "        value_type = type_from_annotation(v_ast)",
            "",
            "        return cls(key_type, value_type)",
            "",
            "",
            "class _SequenceT(_SubscriptableT):",
            "    \"\"\"",
            "    Private base class for sequence types (i.e., index is an int)",
            "",
            "    Arguments",
            "    ---------",
            "    length : int",
            "        Number of items in the type.",
            "    \"\"\"",
            "",
            "    _equality_attrs: tuple = (\"value_type\", \"length\")",
            "",
            "    _is_array_type: bool = True",
            "",
            "    def __init__(self, value_type: VyperType, length: int):",
            "        if not 0 < length < 2**256:",
            "            raise InvalidType(\"Array length is invalid\")",
            "",
            "        super().__init__(UINT256_T, value_type)",
            "        self.length = length",
            "",
            "    @property",
            "    def count(self):",
            "        \"\"\"",
            "        Alias for API compatibility",
            "        \"\"\"",
            "        return self.length",
            "",
            "    def validate_index_type(self, node):",
            "        # TODO break this cycle",
            "        from vyper.semantics.analysis.utils import validate_expected_type",
            "",
            "        if isinstance(node, vy_ast.Int):",
            "            if node.value < 0:",
            "                raise ArrayIndexException(\"Vyper does not support negative indexing\", node)",
            "            if node.value >= self.length:",
            "                raise ArrayIndexException(\"Index out of range\", node)",
            "",
            "        validate_expected_type(node, IntegerT.any())",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "",
            "# override value at `k` with `val`, but inserting it before other keys",
            "# for formatting reasons. besides insertion order, equivalent to",
            "# `{k: val, **xs}`",
            "def _set_first_key(xs: Dict[str, Any], k: str, val: Any) -> dict:",
            "    xs.pop(k, None)",
            "    return {k: val, **xs}",
            "",
            "",
            "class SArrayT(_SequenceT):",
            "    \"\"\"",
            "    Static array type",
            "    \"\"\"",
            "",
            "    def __init__(self, value_type: VyperType, length: int) -> None:",
            "        super().__init__(value_type, length)",
            "",
            "    def __repr__(self):",
            "        return f\"{self.value_type}[{self.length}]\"",
            "",
            "    @property",
            "    def _as_array(self):",
            "        # a static array is arrayable if its value_type is arrayble.",
            "        return self.value_type._as_array",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_StaticArray(self.value_type.abi_type, self.length)",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:",
            "        ret = self.value_type.to_abi_arg()",
            "        # modify the child name in place",
            "        ret[\"type\"] += f\"[{self.length}]\"",
            "        return _set_first_key(ret, \"name\", name)",
            "",
            "    # TODO rename to `memory_bytes_required`",
            "    @property",
            "    def size_in_bytes(self):",
            "        return self.value_type.size_in_bytes * self.length",
            "",
            "    @property",
            "    def subtype(self):",
            "        \"\"\"",
            "        Alias for API compatibility with codegen",
            "        \"\"\"",
            "        return self.value_type",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "    def compare_type(self, other):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length != other.length:",
            "            return False",
            "        return self.value_type.compare_type(other.value_type)",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Subscript) -> \"SArrayT\":",
            "        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):",
            "            raise StructureException(",
            "                \"Arrays must be defined with base type and length, e.g. bool[5]\", node",
            "            )",
            "",
            "        value_type = type_from_annotation(node.value)",
            "",
            "        if not value_type._as_array:",
            "            raise StructureException(f\"arrays of {value_type} are not allowed!\")",
            "",
            "        # note: validates index is a vy_ast.Int.",
            "        length = get_index_value(node.slice)",
            "        return cls(value_type, length)",
            "",
            "",
            "class DArrayT(_SequenceT):",
            "    \"\"\"",
            "    Dynamic array type",
            "    \"\"\"",
            "",
            "    _valid_literal = (vy_ast.List,)",
            "    _as_array = True",
            "    _id = \"DynArray\"",
            "",
            "    def __init__(self, value_type: VyperType, length: int) -> None:",
            "        super().__init__(value_type, length)",
            "",
            "        from vyper.semantics.types.function import MemberFunctionT",
            "",
            "        self.add_member(\"append\", MemberFunctionT(self, \"append\", [self.value_type], None, True))",
            "        self.add_member(\"pop\", MemberFunctionT(self, \"pop\", [], self.value_type, True))",
            "",
            "    def __repr__(self):",
            "        return f\"DynArray[{self.value_type}, {self.length}]\"",
            "",
            "    @property",
            "    def subtype(self):",
            "        \"\"\"",
            "        Alias for backwards compatibility.",
            "        \"\"\"",
            "        return self.value_type",
            "",
            "    @property",
            "    def count(self):",
            "        \"\"\"",
            "        Alias for backwards compatibility.",
            "        \"\"\"",
            "        return self.length",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_DynamicArray(self.value_type.abi_type, self.length)",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:",
            "        ret = self.value_type.to_abi_arg()",
            "        # modify the child name in place.",
            "        ret[\"type\"] += \"[]\"",
            "        return _set_first_key(ret, \"name\", name)",
            "",
            "    # TODO rename me to memory_bytes_required",
            "    @property",
            "    def size_in_bytes(self):",
            "        # one length word + size of the array items",
            "        return 32 + self.value_type.size_in_bytes * self.length",
            "",
            "    def compare_type(self, other):",
            "        # TODO allow static array to be assigned to dyn array?",
            "        # if not isinstance(other, (DArrayT, SArrayT)):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length < other.length:",
            "            return False",
            "        return self.value_type.compare_type(other.value_type)",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Subscript) -> \"DArrayT\":",
            "        if (",
            "            not isinstance(node, vy_ast.Subscript)",
            "            or not isinstance(node.slice, vy_ast.Index)",
            "            or not isinstance(node.slice.value, vy_ast.Tuple)",
            "            or not isinstance(node.slice.value.elements[1], vy_ast.Int)",
            "            or len(node.slice.value.elements) != 2",
            "        ):",
            "            raise StructureException(",
            "                \"DynArray must be defined with base type and max length, e.g. DynArray[bool, 5]\",",
            "                node,",
            "            )",
            "",
            "        value_type = type_from_annotation(node.slice.value.elements[0])",
            "        if not value_type._as_darray:",
            "            raise StructureException(f\"Arrays of {value_type} are not allowed\", node)",
            "",
            "        max_length = node.slice.value.elements[1].value",
            "        return cls(value_type, max_length)",
            "",
            "",
            "class TupleT(VyperType):",
            "    \"\"\"",
            "    Tuple type definition.",
            "",
            "    This class is used to represent multiple return values from",
            "    functions.",
            "    \"\"\"",
            "",
            "    _equality_attrs = (\"members\",)",
            "",
            "    def __init__(self, member_types: Tuple[VyperType, ...]) -> None:",
            "        super().__init__()",
            "        self.member_types = member_types",
            "        self.key_type = UINT256_T  # API Compatibility",
            "",
            "    def __repr__(self):",
            "        return \"(\" + \", \".join(repr(t) for t in self.member_types) + \")\"",
            "",
            "    @property",
            "    def length(self):",
            "        return len(self.member_types)",
            "",
            "    def tuple_members(self):",
            "        return [v for (_k, v) in self.tuple_items()]",
            "",
            "    def tuple_keys(self):",
            "        return [k for (k, _v) in self.tuple_items()]",
            "",
            "    def tuple_items(self):",
            "        return list(enumerate(self.member_types))",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Tuple) -> VyperType:",
            "        values = node.elements",
            "        types = tuple(type_from_annotation(v) for v in values)",
            "        return cls(types)",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_Tuple([t.abi_type for t in self.member_types])",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> dict:",
            "        components = [t.to_abi_arg() for t in self.member_types]",
            "        return {\"name\": name, \"type\": \"tuple\", \"components\": components}",
            "",
            "    @property",
            "    def size_in_bytes(self):",
            "        return sum(i.size_in_bytes for i in self.member_types)",
            "",
            "    def validate_index_type(self, node):",
            "        if not isinstance(node, vy_ast.Int):",
            "            raise InvalidType(\"Tuple indexes must be literals\", node)",
            "        if node.value < 0:",
            "            raise ArrayIndexException(\"Vyper does not support negative indexing\", node)",
            "        if node.value >= self.length:",
            "            raise ArrayIndexException(\"Index out of range\", node)",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.member_types[node.value]",
            "",
            "    def compare_type(self, other):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length != other.length:",
            "            return False",
            "        return all(a.compare_type(b) for (a, b) in zip(self.member_types, other.member_types))"
        ],
        "afterPatchFile": [
            "from typing import Any, Dict, Optional, Tuple, Union",
            "",
            "from vyper import ast as vy_ast",
            "from vyper.abi_types import ABI_DynamicArray, ABI_StaticArray, ABI_Tuple, ABIType",
            "from vyper.exceptions import ArrayIndexException, InvalidType, StructureException",
            "from vyper.semantics.types.base import VyperType",
            "from vyper.semantics.types.primitives import IntegerT",
            "from vyper.semantics.types.shortcuts import UINT256_T",
            "from vyper.semantics.types.utils import get_index_value, type_from_annotation",
            "",
            "",
            "class _SubscriptableT(VyperType):",
            "    \"\"\"",
            "    Base class for subscriptable types such as arrays and mappings.",
            "",
            "    Attributes",
            "    ----------",
            "    key_type: VyperType",
            "        Type representing the index for this object.",
            "    value_type : VyperType",
            "        Type representing the value(s) contained in this object.",
            "    \"\"\"",
            "",
            "    def __init__(self, key_type: VyperType, value_type: VyperType) -> None:",
            "        super().__init__()",
            "        self.key_type = key_type",
            "        self.value_type = value_type",
            "",
            "    @property",
            "    def getter_signature(self) -> Tuple[Tuple, Optional[VyperType]]:",
            "        child_keys, return_type = self.value_type.getter_signature",
            "        return (self.key_type,) + child_keys, return_type",
            "",
            "    def validate_index_type(self, node):",
            "        # TODO: break this cycle",
            "        from vyper.semantics.analysis.utils import validate_expected_type",
            "",
            "        validate_expected_type(node, self.key_type)",
            "",
            "",
            "class HashMapT(_SubscriptableT):",
            "    _id = \"HashMap\"",
            "",
            "    _equality_attrs = (\"key_type\", \"value_type\")",
            "",
            "    def __repr__(self):",
            "        return f\"HashMap[{self.key_type}, {self.value_type}]\"",
            "",
            "    # TODO not sure this is used?",
            "    def compare_type(self, other):",
            "        return (",
            "            super().compare_type(other)",
            "            and self.key_type == other.key_type",
            "            and self.value_type == other.value_type",
            "        )",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript]) -> \"HashMapT\":",
            "        if (",
            "            not isinstance(node, vy_ast.Subscript)",
            "            or not isinstance(node.slice, vy_ast.Index)",
            "            or not isinstance(node.slice.value, vy_ast.Tuple)",
            "            or len(node.slice.value.elements) != 2",
            "        ):",
            "            raise StructureException(",
            "                (",
            "                    \"HashMap must be defined with a key type and a value type, \"",
            "                    \"e.g. my_hashmap: HashMap[k, v]\"",
            "                ),",
            "                node,",
            "            )",
            "        # if location != DataLocation.STORAGE or is_immutable:",
            "        #    raise StructureException(\"HashMap can only be declared as a storage variable\", node)",
            "",
            "        k_ast, v_ast = node.slice.value.elements",
            "        key_type = type_from_annotation(k_ast)",
            "        if not key_type._as_hashmap_key:",
            "            raise InvalidType(\"can only use primitive types as HashMap key!\", k_ast)",
            "",
            "        value_type = type_from_annotation(v_ast)",
            "",
            "        return cls(key_type, value_type)",
            "",
            "",
            "class _SequenceT(_SubscriptableT):",
            "    \"\"\"",
            "    Private base class for sequence types (i.e., index is an int)",
            "",
            "    Arguments",
            "    ---------",
            "    length : int",
            "        Number of items in the type.",
            "    \"\"\"",
            "",
            "    _equality_attrs: tuple = (\"value_type\", \"length\")",
            "",
            "    _is_array_type: bool = True",
            "",
            "    def __init__(self, value_type: VyperType, length: int):",
            "        if not 0 < length < 2**256:",
            "            raise InvalidType(\"Array length is invalid\")",
            "",
            "        if length >= 2**64:",
            "            warnings.warn(\"Use of large arrays can be unsafe!\")",
            "",
            "        super().__init__(UINT256_T, value_type)",
            "        self.length = length",
            "",
            "    @property",
            "    def count(self):",
            "        \"\"\"",
            "        Alias for API compatibility",
            "        \"\"\"",
            "        return self.length",
            "",
            "    def validate_index_type(self, node):",
            "        # TODO break this cycle",
            "        from vyper.semantics.analysis.utils import validate_expected_type",
            "",
            "        if isinstance(node, vy_ast.Int):",
            "            if node.value < 0:",
            "                raise ArrayIndexException(\"Vyper does not support negative indexing\", node)",
            "            if node.value >= self.length:",
            "                raise ArrayIndexException(\"Index out of range\", node)",
            "",
            "        validate_expected_type(node, IntegerT.any())",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "",
            "# override value at `k` with `val`, but inserting it before other keys",
            "# for formatting reasons. besides insertion order, equivalent to",
            "# `{k: val, **xs}`",
            "def _set_first_key(xs: Dict[str, Any], k: str, val: Any) -> dict:",
            "    xs.pop(k, None)",
            "    return {k: val, **xs}",
            "",
            "",
            "class SArrayT(_SequenceT):",
            "    \"\"\"",
            "    Static array type",
            "    \"\"\"",
            "",
            "    def __init__(self, value_type: VyperType, length: int) -> None:",
            "        super().__init__(value_type, length)",
            "",
            "    def __repr__(self):",
            "        return f\"{self.value_type}[{self.length}]\"",
            "",
            "    @property",
            "    def _as_array(self):",
            "        # a static array is arrayable if its value_type is arrayble.",
            "        return self.value_type._as_array",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_StaticArray(self.value_type.abi_type, self.length)",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:",
            "        ret = self.value_type.to_abi_arg()",
            "        # modify the child name in place",
            "        ret[\"type\"] += f\"[{self.length}]\"",
            "        return _set_first_key(ret, \"name\", name)",
            "",
            "    # TODO rename to `memory_bytes_required`",
            "    @property",
            "    def size_in_bytes(self):",
            "        return self.value_type.size_in_bytes * self.length",
            "",
            "    @property",
            "    def subtype(self):",
            "        \"\"\"",
            "        Alias for API compatibility with codegen",
            "        \"\"\"",
            "        return self.value_type",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.value_type",
            "",
            "    def compare_type(self, other):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length != other.length:",
            "            return False",
            "        return self.value_type.compare_type(other.value_type)",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Subscript) -> \"SArrayT\":",
            "        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):",
            "            raise StructureException(",
            "                \"Arrays must be defined with base type and length, e.g. bool[5]\", node",
            "            )",
            "",
            "        value_type = type_from_annotation(node.value)",
            "",
            "        if not value_type._as_array:",
            "            raise StructureException(f\"arrays of {value_type} are not allowed!\")",
            "",
            "        # note: validates index is a vy_ast.Int.",
            "        length = get_index_value(node.slice)",
            "        return cls(value_type, length)",
            "",
            "",
            "class DArrayT(_SequenceT):",
            "    \"\"\"",
            "    Dynamic array type",
            "    \"\"\"",
            "",
            "    _valid_literal = (vy_ast.List,)",
            "    _as_array = True",
            "    _id = \"DynArray\"",
            "",
            "    def __init__(self, value_type: VyperType, length: int) -> None:",
            "        super().__init__(value_type, length)",
            "",
            "        from vyper.semantics.types.function import MemberFunctionT",
            "",
            "        self.add_member(\"append\", MemberFunctionT(self, \"append\", [self.value_type], None, True))",
            "        self.add_member(\"pop\", MemberFunctionT(self, \"pop\", [], self.value_type, True))",
            "",
            "    def __repr__(self):",
            "        return f\"DynArray[{self.value_type}, {self.length}]\"",
            "",
            "    @property",
            "    def subtype(self):",
            "        \"\"\"",
            "        Alias for backwards compatibility.",
            "        \"\"\"",
            "        return self.value_type",
            "",
            "    @property",
            "    def count(self):",
            "        \"\"\"",
            "        Alias for backwards compatibility.",
            "        \"\"\"",
            "        return self.length",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_DynamicArray(self.value_type.abi_type, self.length)",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:",
            "        ret = self.value_type.to_abi_arg()",
            "        # modify the child name in place.",
            "        ret[\"type\"] += \"[]\"",
            "        return _set_first_key(ret, \"name\", name)",
            "",
            "    # TODO rename me to memory_bytes_required",
            "    @property",
            "    def size_in_bytes(self):",
            "        # one length word + size of the array items",
            "        return 32 + self.value_type.size_in_bytes * self.length",
            "",
            "    def compare_type(self, other):",
            "        # TODO allow static array to be assigned to dyn array?",
            "        # if not isinstance(other, (DArrayT, SArrayT)):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length < other.length:",
            "            return False",
            "        return self.value_type.compare_type(other.value_type)",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Subscript) -> \"DArrayT\":",
            "        if (",
            "            not isinstance(node, vy_ast.Subscript)",
            "            or not isinstance(node.slice, vy_ast.Index)",
            "            or not isinstance(node.slice.value, vy_ast.Tuple)",
            "            or not isinstance(node.slice.value.elements[1], vy_ast.Int)",
            "            or len(node.slice.value.elements) != 2",
            "        ):",
            "            raise StructureException(",
            "                \"DynArray must be defined with base type and max length, e.g. DynArray[bool, 5]\",",
            "                node,",
            "            )",
            "",
            "        value_type = type_from_annotation(node.slice.value.elements[0])",
            "        if not value_type._as_darray:",
            "            raise StructureException(f\"Arrays of {value_type} are not allowed\", node)",
            "",
            "        max_length = node.slice.value.elements[1].value",
            "        return cls(value_type, max_length)",
            "",
            "",
            "class TupleT(VyperType):",
            "    \"\"\"",
            "    Tuple type definition.",
            "",
            "    This class is used to represent multiple return values from",
            "    functions.",
            "    \"\"\"",
            "",
            "    _equality_attrs = (\"members\",)",
            "",
            "    def __init__(self, member_types: Tuple[VyperType, ...]) -> None:",
            "        super().__init__()",
            "        self.member_types = member_types",
            "        self.key_type = UINT256_T  # API Compatibility",
            "",
            "    def __repr__(self):",
            "        return \"(\" + \", \".join(repr(t) for t in self.member_types) + \")\"",
            "",
            "    @property",
            "    def length(self):",
            "        return len(self.member_types)",
            "",
            "    def tuple_members(self):",
            "        return [v for (_k, v) in self.tuple_items()]",
            "",
            "    def tuple_keys(self):",
            "        return [k for (k, _v) in self.tuple_items()]",
            "",
            "    def tuple_items(self):",
            "        return list(enumerate(self.member_types))",
            "",
            "    @classmethod",
            "    def from_annotation(cls, node: vy_ast.Tuple) -> VyperType:",
            "        values = node.elements",
            "        types = tuple(type_from_annotation(v) for v in values)",
            "        return cls(types)",
            "",
            "    @property",
            "    def abi_type(self) -> ABIType:",
            "        return ABI_Tuple([t.abi_type for t in self.member_types])",
            "",
            "    def to_abi_arg(self, name: str = \"\") -> dict:",
            "        components = [t.to_abi_arg() for t in self.member_types]",
            "        return {\"name\": name, \"type\": \"tuple\", \"components\": components}",
            "",
            "    @property",
            "    def size_in_bytes(self):",
            "        return sum(i.size_in_bytes for i in self.member_types)",
            "",
            "    def validate_index_type(self, node):",
            "        if not isinstance(node, vy_ast.Int):",
            "            raise InvalidType(\"Tuple indexes must be literals\", node)",
            "        if node.value < 0:",
            "            raise ArrayIndexException(\"Vyper does not support negative indexing\", node)",
            "        if node.value >= self.length:",
            "            raise ArrayIndexException(\"Index out of range\", node)",
            "",
            "    def get_subscripted_type(self, node):",
            "        return self.member_types[node.value]",
            "",
            "    def compare_type(self, other):",
            "        if not isinstance(self, type(other)):",
            "            return False",
            "        if self.length != other.length:",
            "            return False",
            "        return all(a.compare_type(b) for (a, b) in zip(self.member_types, other.member_types))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "vyper.semantics.types.subscriptable._SequenceT",
            "pypiserver._app"
        ]
    }
}