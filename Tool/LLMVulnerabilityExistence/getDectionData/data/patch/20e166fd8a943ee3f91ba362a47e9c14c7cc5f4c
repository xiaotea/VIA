{
    "keystoneclient/middleware/auth_token.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " import datetime"
            },
            "3": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import httplib"
            },
            "4": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " import logging"
            },
            "5": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " import os"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+import requests"
            },
            "7": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": " import stat"
            },
            "8": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " import tempfile"
            },
            "9": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " import time"
            },
            "10": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "                help='Required if Keystone server requires client certificate'),"
            },
            "11": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     cfg.StrOpt('keyfile',"
            },
            "12": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "                help='Required if Keystone server requires client certificate'),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    cfg.StrOpt('cafile', default=None,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+               help='A PEM encoded Certificate Authority to use when '"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                    'verifying HTTPs connections. Defaults to system CAs.'),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+    cfg.BoolOpt('insecure', default=False, help='Verify HTTPS connections.'),"
            },
            "17": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "     cfg.StrOpt('signing_dir',"
            },
            "18": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "                help='Directory used to cache files related to PKI tokens'),"
            },
            "19": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "     cfg.ListOpt('memcached_servers',"
            },
            "20": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "                                     (True, 'true', 't', '1', 'on', 'yes', 'y'))"
            },
            "21": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 359,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         # where to find the auth service (we use this to validate tokens)"
            },
            "23": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.auth_host = self._conf_get('auth_host')"
            },
            "24": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.auth_port = int(self._conf_get('auth_port'))"
            },
            "25": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.auth_protocol = self._conf_get('auth_protocol')"
            },
            "26": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not self._conf_get('http_handler'):"
            },
            "27": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if self.auth_protocol == 'http':"
            },
            "28": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.http_client_class = httplib.HTTPConnection"
            },
            "29": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "30": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.http_client_class = httplib.HTTPSConnection"
            },
            "31": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "32": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Really only used for unit testing, since we need to"
            },
            "33": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # have a fake handler set up before we issue an http"
            },
            "34": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # request to get the list of versions supported by the"
            },
            "35": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # server at the end of this initialization"
            },
            "36": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.http_client_class = self._conf_get('http_handler')"
            },
            "37": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        auth_host = self._conf_get('auth_host')"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        auth_port = int(self._conf_get('auth_port'))"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        auth_protocol = self._conf_get('auth_protocol')"
            },
            "41": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "         self.auth_admin_prefix = self._conf_get('auth_admin_prefix')"
            },
            "42": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         self.auth_uri = self._conf_get('auth_uri')"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+        if netaddr.valid_ipv6(auth_host):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+            # Note(dzyu) it is an IPv6 address, so it needs to be wrapped"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+            # with '[]' to generate a valid IPv6 URL, based on"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+            # http://www.ietf.org/rfc/rfc2732.txt"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+            auth_host = '[%s]' % auth_host"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+        self.request_uri = '%s://%s:%s' % (auth_protocol, auth_host, auth_port)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "         if self.auth_uri is None:"
            },
            "53": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "             self.LOG.warning("
            },
            "54": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "                 'Configuring auth_uri to point to the public identity '"
            },
            "55": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "                 'endpoint is required; clients may not be able to '"
            },
            "56": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "                 'authenticate against an admin endpoint')"
            },
            "57": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            host = self.auth_host"
            },
            "58": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if netaddr.valid_ipv6(host):"
            },
            "59": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Note(dzyu) it is an IPv6 address, so it needs to be wrapped"
            },
            "60": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # with '[]' to generate a valid IPv6 URL, based on"
            },
            "61": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # http://www.ietf.org/rfc/rfc2732.txt"
            },
            "62": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                host = '[%s]' % host"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "             # FIXME(dolph): drop support for this fallback behavior as"
            },
            "65": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "             # documented in bug 1207517"
            },
            "66": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.auth_uri = '%s://%s:%s' % (self.auth_protocol,"
            },
            "67": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                            host,"
            },
            "68": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                            self.auth_port)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+            self.auth_uri = self.request_uri"
            },
            "70": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 384,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         # SSL"
            },
            "72": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         self.cert_file = self._conf_get('certfile')"
            },
            "73": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "         self.key_file = self._conf_get('keyfile')"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        self.ssl_ca_file = self._conf_get('cafile')"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+        self.ssl_insecure = self._conf_get('insecure')"
            },
            "76": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 390,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 391,
                "PatchRowcode": "         # signing"
            },
            "78": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 392,
                "PatchRowcode": "         self.signing_dirname = self._conf_get('signing_dir')"
            },
            "79": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "         val = '%s/signing_cert.pem' % self.signing_dirname"
            },
            "80": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         self.signing_cert_file_name = val"
            },
            "81": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         val = '%s/cacert.pem' % self.signing_dirname"
            },
            "82": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.ca_file_name = val"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+        self.signing_ca_file_name = val"
            },
            "84": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         val = '%s/revoked.pem' % self.signing_dirname"
            },
            "85": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "         self.revoked_file_name = val"
            },
            "86": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 405,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 501,
                "PatchRowcode": "     def _get_supported_versions(self):"
            },
            "88": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         versions = []"
            },
            "89": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "         response, data = self._json_request('GET', '/')"
            },
            "90": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status == 501:"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+        if response.status_code == 501:"
            },
            "92": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "             self.LOG.warning(\"Old keystone installation found...assuming v2.0\")"
            },
            "93": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "             versions.append(\"v2.0\")"
            },
            "94": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif response.status != 300:"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+        elif response.status_code != 300:"
            },
            "96": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "             self.LOG.error('Unable to get version info from keystone: %s' %"
            },
            "97": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           response.status)"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+                           response.status_code)"
            },
            "99": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "             raise ServiceError('Unable to get version info from keystone')"
            },
            "100": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "         else:"
            },
            "101": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "             try:"
            },
            "102": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 644,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 645,
                "PatchRowcode": "         return self.admin_token"
            },
            "104": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 646,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _get_http_connection(self):"
            },
            "106": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.auth_protocol == 'http':"
            },
            "107": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.http_client_class(self.auth_host, self.auth_port,"
            },
            "108": {
                "beforePatchRowNumber": 654,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          timeout=self.http_connect_timeout)"
            },
            "109": {
                "beforePatchRowNumber": 655,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "110": {
                "beforePatchRowNumber": 656,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.http_client_class(self.auth_host,"
            },
            "111": {
                "beforePatchRowNumber": 657,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          self.auth_port,"
            },
            "112": {
                "beforePatchRowNumber": 658,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          self.key_file,"
            },
            "113": {
                "beforePatchRowNumber": 659,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          self.cert_file,"
            },
            "114": {
                "beforePatchRowNumber": 660,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                          timeout=self.http_connect_timeout)"
            },
            "115": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "116": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "     def _http_request(self, method, path, **kwargs):"
            },
            "117": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": 648,
                "PatchRowcode": "         \"\"\"HTTP request helper used to make unspecified content type requests."
            },
            "118": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": 649,
                "PatchRowcode": " "
            },
            "119": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": 653,
                "PatchRowcode": "         :raise ServerError when unable to communicate with keystone"
            },
            "120": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 654,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": 655,
                "PatchRowcode": "         \"\"\""
            },
            "122": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        conn = self._get_http_connection()"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+        url = \"%s/%s\" % (self.request_uri, path.lstrip('/'))"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+        kwargs.setdefault('timeout', self.http_connect_timeout)"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+        if self.cert_file and self.key_file:"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+            kwargs['cert'] = (self.cert_file, self.key_file)"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+        elif self.cert_file or self.key_file:"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 662,
                "PatchRowcode": "+            self.LOG.warn('Cannot use only a cert or key file. '"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+                          'Please provide both. Ignoring.')"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 664,
                "PatchRowcode": "+"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 665,
                "PatchRowcode": "+        kwargs['verify'] = self.ssl_ca_file or True"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+        if self.ssl_insecure:"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+            kwargs['verify'] = False"
            },
            "135": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 668,
                "PatchRowcode": " "
            },
            "136": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 669,
                "PatchRowcode": "         RETRIES = self.http_request_max_retries"
            },
            "137": {
                "beforePatchRowNumber": 674,
                "afterPatchRowNumber": 670,
                "PatchRowcode": "         retry = 0"
            },
            "138": {
                "beforePatchRowNumber": 675,
                "afterPatchRowNumber": 671,
                "PatchRowcode": "         while True:"
            },
            "139": {
                "beforePatchRowNumber": 676,
                "afterPatchRowNumber": 672,
                "PatchRowcode": "             try:"
            },
            "140": {
                "beforePatchRowNumber": 677,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                conn.request(method, path, **kwargs)"
            },
            "141": {
                "beforePatchRowNumber": 678,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                response = conn.getresponse()"
            },
            "142": {
                "beforePatchRowNumber": 679,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                body = response.read()"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+                response = requests.request(method, url, **kwargs)"
            },
            "144": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": 674,
                "PatchRowcode": "                 break"
            },
            "145": {
                "beforePatchRowNumber": 681,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "             except Exception as e:"
            },
            "146": {
                "beforePatchRowNumber": 682,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if retry == RETRIES:"
            },
            "147": {
                "beforePatchRowNumber": 683,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self.LOG.error('HTTP connection exception: %s' % e)"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 676,
                "PatchRowcode": "+                if retry >= RETRIES:"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+                    self.LOG.error('HTTP connection exception: %s', e)"
            },
            "150": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 678,
                "PatchRowcode": "                     raise NetworkError('Unable to communicate with keystone')"
            },
            "151": {
                "beforePatchRowNumber": 685,
                "afterPatchRowNumber": 679,
                "PatchRowcode": "                 # NOTE(vish): sleep 0.5, 1, 2"
            },
            "152": {
                "beforePatchRowNumber": 686,
                "afterPatchRowNumber": 680,
                "PatchRowcode": "                 self.LOG.warn('Retrying on HTTP connection exception: %s' % e)"
            },
            "153": {
                "beforePatchRowNumber": 687,
                "afterPatchRowNumber": 681,
                "PatchRowcode": "                 time.sleep(2.0 ** retry / 2)"
            },
            "154": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": 682,
                "PatchRowcode": "                 retry += 1"
            },
            "155": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            finally:"
            },
            "156": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                conn.close()"
            },
            "157": {
                "beforePatchRowNumber": 691,
                "afterPatchRowNumber": 683,
                "PatchRowcode": " "
            },
            "158": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return response, body"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 684,
                "PatchRowcode": "+        return response"
            },
            "160": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 685,
                "PatchRowcode": " "
            },
            "161": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 686,
                "PatchRowcode": "     def _json_request(self, method, path, body=None, additional_headers=None):"
            },
            "162": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "         \"\"\"HTTP request helper used to make json requests."
            },
            "163": {
                "beforePatchRowNumber": 714,
                "afterPatchRowNumber": 706,
                "PatchRowcode": "             kwargs['headers'].update(additional_headers)"
            },
            "164": {
                "beforePatchRowNumber": 715,
                "afterPatchRowNumber": 707,
                "PatchRowcode": " "
            },
            "165": {
                "beforePatchRowNumber": 716,
                "afterPatchRowNumber": 708,
                "PatchRowcode": "         if body:"
            },
            "166": {
                "beforePatchRowNumber": 717,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            kwargs['body'] = jsonutils.dumps(body)"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 709,
                "PatchRowcode": "+            kwargs['data'] = jsonutils.dumps(body)"
            },
            "168": {
                "beforePatchRowNumber": 718,
                "afterPatchRowNumber": 710,
                "PatchRowcode": " "
            },
            "169": {
                "beforePatchRowNumber": 719,
                "afterPatchRowNumber": 711,
                "PatchRowcode": "         path = self.auth_admin_prefix + path"
            },
            "170": {
                "beforePatchRowNumber": 720,
                "afterPatchRowNumber": 712,
                "PatchRowcode": " "
            },
            "171": {
                "beforePatchRowNumber": 721,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response, body = self._http_request(method, path, **kwargs)"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 713,
                "PatchRowcode": "+        response = self._http_request(method, path, **kwargs)"
            },
            "173": {
                "beforePatchRowNumber": 722,
                "afterPatchRowNumber": 714,
                "PatchRowcode": " "
            },
            "174": {
                "beforePatchRowNumber": 723,
                "afterPatchRowNumber": 715,
                "PatchRowcode": "         try:"
            },
            "175": {
                "beforePatchRowNumber": 724,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data = jsonutils.loads(body)"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 716,
                "PatchRowcode": "+            data = jsonutils.loads(response.text)"
            },
            "177": {
                "beforePatchRowNumber": 725,
                "afterPatchRowNumber": 717,
                "PatchRowcode": "         except ValueError:"
            },
            "178": {
                "beforePatchRowNumber": 726,
                "afterPatchRowNumber": 718,
                "PatchRowcode": "             self.LOG.debug('Keystone did not return json-encoded body')"
            },
            "179": {
                "beforePatchRowNumber": 727,
                "afterPatchRowNumber": 719,
                "PatchRowcode": "             data = {}"
            },
            "180": {
                "beforePatchRowNumber": 1090,
                "afterPatchRowNumber": 1082,
                "PatchRowcode": "                 '/v2.0/tokens/%s' % safe_quote(user_token),"
            },
            "181": {
                "beforePatchRowNumber": 1091,
                "afterPatchRowNumber": 1083,
                "PatchRowcode": "                 additional_headers=headers)"
            },
            "182": {
                "beforePatchRowNumber": 1092,
                "afterPatchRowNumber": 1084,
                "PatchRowcode": " "
            },
            "183": {
                "beforePatchRowNumber": 1093,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status == 200:"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1085,
                "PatchRowcode": "+        if response.status_code == 200:"
            },
            "185": {
                "beforePatchRowNumber": 1094,
                "afterPatchRowNumber": 1086,
                "PatchRowcode": "             return data"
            },
            "186": {
                "beforePatchRowNumber": 1095,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status == 404:"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1087,
                "PatchRowcode": "+        if response.status_code == 404:"
            },
            "188": {
                "beforePatchRowNumber": 1096,
                "afterPatchRowNumber": 1088,
                "PatchRowcode": "             self.LOG.warn(\"Authorization failed for token %s\", user_token)"
            },
            "189": {
                "beforePatchRowNumber": 1097,
                "afterPatchRowNumber": 1089,
                "PatchRowcode": "             raise InvalidUserToken('Token authorization failed')"
            },
            "190": {
                "beforePatchRowNumber": 1098,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status == 401:"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1090,
                "PatchRowcode": "+        if response.status_code == 401:"
            },
            "192": {
                "beforePatchRowNumber": 1099,
                "afterPatchRowNumber": 1091,
                "PatchRowcode": "             self.LOG.info("
            },
            "193": {
                "beforePatchRowNumber": 1100,
                "afterPatchRowNumber": 1092,
                "PatchRowcode": "                 'Keystone rejected admin token %s, resetting', headers)"
            },
            "194": {
                "beforePatchRowNumber": 1101,
                "afterPatchRowNumber": 1093,
                "PatchRowcode": "             self.admin_token = None"
            },
            "195": {
                "beforePatchRowNumber": 1102,
                "afterPatchRowNumber": 1094,
                "PatchRowcode": "         else:"
            },
            "196": {
                "beforePatchRowNumber": 1103,
                "afterPatchRowNumber": 1095,
                "PatchRowcode": "             self.LOG.error('Bad response code while validating token: %s' %"
            },
            "197": {
                "beforePatchRowNumber": 1104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           response.status)"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1096,
                "PatchRowcode": "+                           response.status_code)"
            },
            "199": {
                "beforePatchRowNumber": 1105,
                "afterPatchRowNumber": 1097,
                "PatchRowcode": "         if retry:"
            },
            "200": {
                "beforePatchRowNumber": 1106,
                "afterPatchRowNumber": 1098,
                "PatchRowcode": "             self.LOG.info('Retrying validation')"
            },
            "201": {
                "beforePatchRowNumber": 1107,
                "afterPatchRowNumber": 1099,
                "PatchRowcode": "             return self._validate_user_token(user_token, False)"
            },
            "202": {
                "beforePatchRowNumber": 1135,
                "afterPatchRowNumber": 1127,
                "PatchRowcode": "         while True:"
            },
            "203": {
                "beforePatchRowNumber": 1136,
                "afterPatchRowNumber": 1128,
                "PatchRowcode": "             try:"
            },
            "204": {
                "beforePatchRowNumber": 1137,
                "afterPatchRowNumber": 1129,
                "PatchRowcode": "                 output = cms.cms_verify(data, self.signing_cert_file_name,"
            },
            "205": {
                "beforePatchRowNumber": 1138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                        self.ca_file_name)"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1130,
                "PatchRowcode": "+                                        self.signing_ca_file_name)"
            },
            "207": {
                "beforePatchRowNumber": 1139,
                "afterPatchRowNumber": 1131,
                "PatchRowcode": "             except cms.subprocess.CalledProcessError as err:"
            },
            "208": {
                "beforePatchRowNumber": 1140,
                "afterPatchRowNumber": 1132,
                "PatchRowcode": "                 if self.cert_file_missing(err.output,"
            },
            "209": {
                "beforePatchRowNumber": 1141,
                "afterPatchRowNumber": 1133,
                "PatchRowcode": "                                           self.signing_cert_file_name):"
            },
            "210": {
                "beforePatchRowNumber": 1142,
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "                     self.fetch_signing_cert()"
            },
            "211": {
                "beforePatchRowNumber": 1143,
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "                     continue"
            },
            "212": {
                "beforePatchRowNumber": 1144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if self.cert_file_missing(err.output, self.ca_file_name):"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "+                if self.cert_file_missing(err.output,"
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "+                                          self.signing_ca_file_name):"
            },
            "215": {
                "beforePatchRowNumber": 1145,
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "                     self.fetch_ca_cert()"
            },
            "216": {
                "beforePatchRowNumber": 1146,
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "                     continue"
            },
            "217": {
                "beforePatchRowNumber": 1147,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "                 self.LOG.warning('Verify error: %s' % err)"
            },
            "218": {
                "beforePatchRowNumber": 1221,
                "afterPatchRowNumber": 1214,
                "PatchRowcode": "         headers = {'X-Auth-Token': self.get_admin_token()}"
            },
            "219": {
                "beforePatchRowNumber": 1222,
                "afterPatchRowNumber": 1215,
                "PatchRowcode": "         response, data = self._json_request('GET', '/v2.0/tokens/revoked',"
            },
            "220": {
                "beforePatchRowNumber": 1223,
                "afterPatchRowNumber": 1216,
                "PatchRowcode": "                                             additional_headers=headers)"
            },
            "221": {
                "beforePatchRowNumber": 1224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status == 401:"
            },
            "222": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1217,
                "PatchRowcode": "+        if response.status_code == 401:"
            },
            "223": {
                "beforePatchRowNumber": 1225,
                "afterPatchRowNumber": 1218,
                "PatchRowcode": "             if retry:"
            },
            "224": {
                "beforePatchRowNumber": 1226,
                "afterPatchRowNumber": 1219,
                "PatchRowcode": "                 self.LOG.info("
            },
            "225": {
                "beforePatchRowNumber": 1227,
                "afterPatchRowNumber": 1220,
                "PatchRowcode": "                     'Keystone rejected admin token %s, resetting admin token',"
            },
            "226": {
                "beforePatchRowNumber": 1228,
                "afterPatchRowNumber": 1221,
                "PatchRowcode": "                     headers)"
            },
            "227": {
                "beforePatchRowNumber": 1229,
                "afterPatchRowNumber": 1222,
                "PatchRowcode": "                 self.admin_token = None"
            },
            "228": {
                "beforePatchRowNumber": 1230,
                "afterPatchRowNumber": 1223,
                "PatchRowcode": "                 return self.fetch_revocation_list(retry=False)"
            },
            "229": {
                "beforePatchRowNumber": 1231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.status != 200:"
            },
            "230": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1224,
                "PatchRowcode": "+        if response.status_code != 200:"
            },
            "231": {
                "beforePatchRowNumber": 1232,
                "afterPatchRowNumber": 1225,
                "PatchRowcode": "             raise ServiceError('Unable to fetch token revocation list.')"
            },
            "232": {
                "beforePatchRowNumber": 1233,
                "afterPatchRowNumber": 1226,
                "PatchRowcode": "         if 'signed' not in data:"
            },
            "233": {
                "beforePatchRowNumber": 1234,
                "afterPatchRowNumber": 1227,
                "PatchRowcode": "             raise ServiceError('Revocation list improperly formatted.')"
            },
            "234": {
                "beforePatchRowNumber": 1237,
                "afterPatchRowNumber": 1230,
                "PatchRowcode": "     def fetch_signing_cert(self):"
            },
            "235": {
                "beforePatchRowNumber": 1238,
                "afterPatchRowNumber": 1231,
                "PatchRowcode": "         path = self.auth_admin_prefix.rstrip('/')"
            },
            "236": {
                "beforePatchRowNumber": 1239,
                "afterPatchRowNumber": 1232,
                "PatchRowcode": "         path += '/v2.0/certificates/signing'"
            },
            "237": {
                "beforePatchRowNumber": 1240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response, data = self._http_request('GET', path)"
            },
            "238": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1233,
                "PatchRowcode": "+        response = self._http_request('GET', path)"
            },
            "239": {
                "beforePatchRowNumber": 1241,
                "afterPatchRowNumber": 1234,
                "PatchRowcode": " "
            },
            "240": {
                "beforePatchRowNumber": 1242,
                "afterPatchRowNumber": 1235,
                "PatchRowcode": "         def write_cert_file(data):"
            },
            "241": {
                "beforePatchRowNumber": 1243,
                "afterPatchRowNumber": 1236,
                "PatchRowcode": "             with open(self.signing_cert_file_name, 'w') as certfile:"
            },
            "242": {
                "beforePatchRowNumber": 1246,
                "afterPatchRowNumber": 1239,
                "PatchRowcode": "         try:"
            },
            "243": {
                "beforePatchRowNumber": 1247,
                "afterPatchRowNumber": 1240,
                "PatchRowcode": "             #todo check response"
            },
            "244": {
                "beforePatchRowNumber": 1248,
                "afterPatchRowNumber": 1241,
                "PatchRowcode": "             try:"
            },
            "245": {
                "beforePatchRowNumber": 1249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                write_cert_file(data)"
            },
            "246": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1242,
                "PatchRowcode": "+                write_cert_file(response.text)"
            },
            "247": {
                "beforePatchRowNumber": 1250,
                "afterPatchRowNumber": 1243,
                "PatchRowcode": "             except IOError:"
            },
            "248": {
                "beforePatchRowNumber": 1251,
                "afterPatchRowNumber": 1244,
                "PatchRowcode": "                 self.verify_signing_dir()"
            },
            "249": {
                "beforePatchRowNumber": 1252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                write_cert_file(data)"
            },
            "250": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1245,
                "PatchRowcode": "+                write_cert_file(response.text)"
            },
            "251": {
                "beforePatchRowNumber": 1253,
                "afterPatchRowNumber": 1246,
                "PatchRowcode": "         except (AssertionError, KeyError):"
            },
            "252": {
                "beforePatchRowNumber": 1254,
                "afterPatchRowNumber": 1247,
                "PatchRowcode": "             self.LOG.warn("
            },
            "253": {
                "beforePatchRowNumber": 1255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Unexpected response from keystone service: %s\", data)"
            },
            "254": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1248,
                "PatchRowcode": "+                \"Unexpected response from keystone service: %s\", response.text)"
            },
            "255": {
                "beforePatchRowNumber": 1256,
                "afterPatchRowNumber": 1249,
                "PatchRowcode": "             raise ServiceError('invalid json response')"
            },
            "256": {
                "beforePatchRowNumber": 1257,
                "afterPatchRowNumber": 1250,
                "PatchRowcode": " "
            },
            "257": {
                "beforePatchRowNumber": 1258,
                "afterPatchRowNumber": 1251,
                "PatchRowcode": "     def fetch_ca_cert(self):"
            },
            "258": {
                "beforePatchRowNumber": 1259,
                "afterPatchRowNumber": 1252,
                "PatchRowcode": "         path = self.auth_admin_prefix.rstrip('/') + '/v2.0/certificates/ca'"
            },
            "259": {
                "beforePatchRowNumber": 1260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response, data = self._http_request('GET', path)"
            },
            "260": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1253,
                "PatchRowcode": "+        response = self._http_request('GET', path)"
            },
            "261": {
                "beforePatchRowNumber": 1261,
                "afterPatchRowNumber": 1254,
                "PatchRowcode": " "
            },
            "262": {
                "beforePatchRowNumber": 1262,
                "afterPatchRowNumber": 1255,
                "PatchRowcode": "         try:"
            },
            "263": {
                "beforePatchRowNumber": 1263,
                "afterPatchRowNumber": 1256,
                "PatchRowcode": "             #todo check response"
            },
            "264": {
                "beforePatchRowNumber": 1264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            with open(self.ca_file_name, 'w') as certfile:"
            },
            "265": {
                "beforePatchRowNumber": 1265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                certfile.write(data)"
            },
            "266": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1257,
                "PatchRowcode": "+            with open(self.signing_ca_file_name, 'w') as certfile:"
            },
            "267": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1258,
                "PatchRowcode": "+                certfile.write(response.text)"
            },
            "268": {
                "beforePatchRowNumber": 1266,
                "afterPatchRowNumber": 1259,
                "PatchRowcode": "         except (AssertionError, KeyError):"
            },
            "269": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": 1260,
                "PatchRowcode": "             self.LOG.warn("
            },
            "270": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"Unexpected response from keystone service: %s\", data)"
            },
            "271": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1261,
                "PatchRowcode": "+                \"Unexpected response from keystone service: %s\", response.text)"
            },
            "272": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": 1262,
                "PatchRowcode": "             raise ServiceError('invalid json response')"
            },
            "273": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": 1263,
                "PatchRowcode": " "
            },
            "274": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": 1264,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
            "# implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"",
            "TOKEN-BASED AUTH MIDDLEWARE",
            "",
            "This WSGI component:",
            "",
            "* Verifies that incoming client requests have valid tokens by validating",
            "  tokens with the auth service.",
            "* Rejects unauthenticated requests UNLESS it is in 'delay_auth_decision'",
            "  mode, which means the final decision is delegated to the downstream WSGI",
            "  component (usually the OpenStack service)",
            "* Collects and forwards identity information based on a valid token",
            "  such as user name, tenant, etc",
            "",
            "Refer to: http://keystone.openstack.org/middlewarearchitecture.html",
            "",
            "HEADERS",
            "-------",
            "",
            "* Headers starting with HTTP\\_ is a standard http header",
            "* Headers starting with HTTP_X is an extended http header",
            "",
            "Coming in from initial call from client or customer",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "HTTP_X_AUTH_TOKEN",
            "    The client token being passed in.",
            "",
            "HTTP_X_STORAGE_TOKEN",
            "    The client token being passed in (legacy Rackspace use) to support",
            "    swift/cloud files",
            "",
            "Used for communication between components",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "WWW-Authenticate",
            "    HTTP header returned to a user indicating which endpoint to use",
            "    to retrieve a new token",
            "",
            "What we add to the request for use by the OpenStack service",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "HTTP_X_IDENTITY_STATUS",
            "    'Confirmed' or 'Invalid'",
            "    The underlying service will only see a value of 'Invalid' if the Middleware",
            "    is configured to run in 'delay_auth_decision' mode",
            "",
            "HTTP_X_DOMAIN_ID",
            "    Identity service managed unique identifier, string. Only present if",
            "    this is a domain-scoped v3 token.",
            "",
            "HTTP_X_DOMAIN_NAME",
            "    Unique domain name, string. Only present if this is a domain-scoped",
            "    v3 token.",
            "",
            "HTTP_X_PROJECT_ID",
            "    Identity service managed unique identifier, string. Only present if",
            "    this is a project-scoped v3 token, or a tenant-scoped v2 token.",
            "",
            "HTTP_X_PROJECT_NAME",
            "    Project name, unique within owning domain, string. Only present if",
            "    this is a project-scoped v3 token, or a tenant-scoped v2 token.",
            "",
            "HTTP_X_PROJECT_DOMAIN_ID",
            "    Identity service managed unique identifier of owning domain of",
            "    project, string.  Only present if this is a project-scoped v3 token. If",
            "    this variable is set, this indicates that the PROJECT_NAME can only",
            "    be assumed to be unique within this domain.",
            "",
            "HTTP_X_PROJECT_DOMAIN_NAME",
            "    Name of owning domain of project, string. Only present if this is a",
            "    project-scoped v3 token. If this variable is set, this indicates that",
            "    the PROJECT_NAME can only be assumed to be unique within this domain.",
            "",
            "HTTP_X_USER_ID",
            "    Identity-service managed unique identifier, string",
            "",
            "HTTP_X_USER_NAME",
            "    User identifier, unique within owning domain, string",
            "",
            "HTTP_X_USER_DOMAIN_ID",
            "    Identity service managed unique identifier of owning domain of",
            "    user, string. If this variable is set, this indicates that the USER_NAME",
            "    can only be assumed to be unique within this domain.",
            "",
            "HTTP_X_USER_DOMAIN_NAME",
            "    Name of owning domain of user, string. If this variable is set, this",
            "    indicates that the USER_NAME can only be assumed to be unique within",
            "    this domain.",
            "",
            "HTTP_X_ROLES",
            "    Comma delimited list of case-sensitive role names",
            "",
            "HTTP_X_SERVICE_CATALOG",
            "    json encoded keystone service catalog (optional).",
            "",
            "HTTP_X_TENANT_ID",
            "    *Deprecated* in favor of HTTP_X_PROJECT_ID",
            "    Identity service managed unique identifier, string. For v3 tokens, this",
            "    will be set to the same value as HTTP_X_PROJECT_ID",
            "",
            "HTTP_X_TENANT_NAME",
            "    *Deprecated* in favor of HTTP_X_PROJECT_NAME",
            "    Project identifier, unique within owning domain, string. For v3 tokens,",
            "    this will be set to the same value as HTTP_X_PROJECT_NAME",
            "",
            "HTTP_X_TENANT",
            "    *Deprecated* in favor of HTTP_X_TENANT_ID and HTTP_X_TENANT_NAME",
            "    Keystone-assigned unique identifier, string. For v3 tokens, this",
            "    will be set to the same value as HTTP_X_PROJECT_ID",
            "",
            "HTTP_X_USER",
            "    *Deprecated* in favor of HTTP_X_USER_ID and HTTP_X_USER_NAME",
            "    User name, unique within owning domain, string",
            "",
            "HTTP_X_ROLE",
            "    *Deprecated* in favor of HTTP_X_ROLES",
            "    Will contain the same values as HTTP_X_ROLES.",
            "",
            "OTHER ENVIRONMENT VARIABLES",
            "---------------------------",
            "",
            "keystone.token_info",
            "    Information about the token discovered in the process of",
            "    validation.  This may include extended information returned by the",
            "    Keystone token validation call, as well as basic information about",
            "    the tenant and user.",
            "",
            "\"\"\"",
            "",
            "import datetime",
            "import httplib",
            "import logging",
            "import os",
            "import stat",
            "import tempfile",
            "import time",
            "import urllib",
            "",
            "import netaddr",
            "import six",
            "",
            "from keystoneclient.common import cms",
            "from keystoneclient.middleware import memcache_crypt",
            "from keystoneclient.openstack.common import jsonutils",
            "from keystoneclient.openstack.common import memorycache",
            "from keystoneclient.openstack.common import timeutils",
            "from keystoneclient import utils",
            "",
            "CONF = None",
            "# to pass gate before oslo-config is deployed everywhere,",
            "# try application copies first",
            "for app in 'nova', 'glance', 'quantum', 'cinder':",
            "    try:",
            "        cfg = __import__('%s.openstack.common.cfg' % app,",
            "                         fromlist=['%s.openstack.common' % app])",
            "        # test which application middleware is running in",
            "        if hasattr(cfg, 'CONF') and 'config_file' in cfg.CONF:",
            "            CONF = cfg.CONF",
            "            break",
            "    except ImportError:",
            "        pass",
            "if not CONF:",
            "    from oslo.config import cfg",
            "    CONF = cfg.CONF",
            "",
            "# alternative middleware configuration in the main application's",
            "# configuration file e.g. in nova.conf",
            "# [keystone_authtoken]",
            "# auth_host = 127.0.0.1",
            "# auth_port = 35357",
            "# auth_protocol = http",
            "# admin_tenant_name = admin",
            "# admin_user = admin",
            "# admin_password = badpassword",
            "",
            "# when deploy Keystone auth_token middleware with Swift, user may elect",
            "# to use Swift memcache instead of the local Keystone memcache. Swift memcache",
            "# is passed in from the request environment and its identified by the",
            "# 'swift.cache' key. However it could be different, depending on deployment.",
            "# To use Swift memcache, you must set the 'cache' option to the environment",
            "# key where the Swift cache object is stored.",
            "opts = [",
            "    cfg.StrOpt('auth_admin_prefix',",
            "               default='',",
            "               help='Prefix to prepend at the beginning of the path'),",
            "    cfg.StrOpt('auth_host',",
            "               default='127.0.0.1',",
            "               help='Host providing the admin Identity API endpoint'),",
            "    cfg.IntOpt('auth_port',",
            "               default=35357,",
            "               help='Port of the admin Identity API endpoint'),",
            "    cfg.StrOpt('auth_protocol',",
            "               default='https',",
            "               help='Protocol of the admin Identity API endpoint'",
            "               '(http or https)'),",
            "    cfg.StrOpt('auth_uri',",
            "               default=None,",
            "               # FIXME(dolph): should be default='http://127.0.0.1:5000/v2.0/',",
            "               # or (depending on client support) an unversioned, publicly",
            "               # accessible identity endpoint (see bug 1207517)",
            "               help='Complete public Identity API endpoint'),",
            "    cfg.StrOpt('auth_version',",
            "               default=None,",
            "               help='API version of the admin Identity API endpoint'),",
            "    cfg.BoolOpt('delay_auth_decision',",
            "                default=False,",
            "                help='Do not handle authorization requests within the'",
            "                ' middleware, but delegate the authorization decision to'",
            "                ' downstream WSGI components'),",
            "    cfg.BoolOpt('http_connect_timeout',",
            "                default=None,",
            "                help='Request timeout value for communicating with Identity'",
            "                ' API server.'),",
            "    cfg.IntOpt('http_request_max_retries',",
            "               default=3,",
            "               help='How many times are we trying to reconnect when'",
            "               ' communicating with Identity API Server.'),",
            "    cfg.StrOpt('http_handler',",
            "               default=None,",
            "               help='Allows to pass in the name of a fake http_handler'",
            "               ' callback function used instead of httplib.HTTPConnection or'",
            "               ' httplib.HTTPSConnection. Useful for unit testing where'",
            "               ' network is not available.'),",
            "    cfg.StrOpt('admin_token',",
            "               secret=True,",
            "               help='Single shared secret with the Keystone configuration'",
            "               ' used for bootstrapping a Keystone installation, or otherwise'",
            "               ' bypassing the normal authentication process.'),",
            "    cfg.StrOpt('admin_user',",
            "               help='Keystone account username'),",
            "    cfg.StrOpt('admin_password',",
            "               secret=True,",
            "               help='Keystone account password'),",
            "    cfg.StrOpt('admin_tenant_name',",
            "               default='admin',",
            "               help='Keystone service account tenant name to validate'",
            "               ' user tokens'),",
            "    cfg.StrOpt('cache',",
            "               default=None,",
            "               help='Env key for the swift cache'),",
            "    cfg.StrOpt('certfile',",
            "               help='Required if Keystone server requires client certificate'),",
            "    cfg.StrOpt('keyfile',",
            "               help='Required if Keystone server requires client certificate'),",
            "    cfg.StrOpt('signing_dir',",
            "               help='Directory used to cache files related to PKI tokens'),",
            "    cfg.ListOpt('memcached_servers',",
            "                deprecated_name='memcache_servers',",
            "                help='If defined, the memcache server(s) to use for'",
            "                ' caching'),",
            "    cfg.IntOpt('token_cache_time',",
            "               default=300,",
            "               help='In order to prevent excessive requests and validations,'",
            "               ' the middleware uses an in-memory cache for the tokens the'",
            "               ' Keystone API returns. This is only valid if memcache_servers'",
            "               ' is defined. Set to -1 to disable caching completely.'),",
            "    cfg.IntOpt('revocation_cache_time',",
            "               default=1,",
            "               help='Value only used for unit testing'),",
            "    cfg.StrOpt('memcache_security_strategy',",
            "               default=None,",
            "               help='(optional) if defined, indicate whether token data'",
            "               ' should be authenticated or authenticated and encrypted.'",
            "               ' Acceptable values are MAC or ENCRYPT.  If MAC, token data is'",
            "               ' authenticated (with HMAC) in the cache. If ENCRYPT, token'",
            "               ' data is encrypted and authenticated in the cache. If the'",
            "               ' value is not one of these options or empty, auth_token will'",
            "               ' raise an exception on initialization.'),",
            "    cfg.StrOpt('memcache_secret_key',",
            "               default=None,",
            "               secret=True,",
            "               help='(optional, mandatory if memcache_security_strategy is'",
            "               ' defined) this string is used for key derivation.')",
            "]",
            "CONF.register_opts(opts, group='keystone_authtoken')",
            "",
            "LIST_OF_VERSIONS_TO_ATTEMPT = ['v2.0', 'v3.0']",
            "CACHE_KEY_TEMPLATE = 'tokens/%s'",
            "",
            "",
            "def will_expire_soon(expiry):",
            "    \"\"\"Determines if expiration is about to occur.",
            "",
            "    :param expiry: a datetime of the expected expiration",
            "    :returns: boolean : true if expiration is within 30 seconds",
            "    \"\"\"",
            "    soon = (timeutils.utcnow() + datetime.timedelta(seconds=30))",
            "    return expiry < soon",
            "",
            "",
            "def safe_quote(s):",
            "    \"\"\"URL-encode strings that are not already URL-encoded.\"\"\"",
            "    return urllib.quote(s) if s == urllib.unquote(s) else s",
            "",
            "",
            "class InvalidUserToken(Exception):",
            "    pass",
            "",
            "",
            "class ServiceError(Exception):",
            "    pass",
            "",
            "",
            "class ConfigurationError(Exception):",
            "    pass",
            "",
            "",
            "class NetworkError(Exception):",
            "    pass",
            "",
            "",
            "class MiniResp(object):",
            "    def __init__(self, error_message, env, headers=[]):",
            "        # The HEAD method is unique: it must never return a body, even if",
            "        # it reports an error (RFC-2616 clause 9.4). We relieve callers",
            "        # from varying the error responses depending on the method.",
            "        if env['REQUEST_METHOD'] == 'HEAD':",
            "            self.body = ['']",
            "        else:",
            "            self.body = [error_message]",
            "        self.headers = list(headers)",
            "        self.headers.append(('Content-type', 'text/plain'))",
            "",
            "",
            "class AuthProtocol(object):",
            "    \"\"\"Auth Middleware that handles authenticating client calls.\"\"\"",
            "",
            "    def __init__(self, app, conf):",
            "        self.LOG = logging.getLogger(conf.get('log_name', __name__))",
            "        self.LOG.info('Starting keystone auth_token middleware')",
            "        self.conf = conf",
            "        self.app = app",
            "",
            "        # delay_auth_decision means we still allow unauthenticated requests",
            "        # through and we let the downstream service make the final decision",
            "        self.delay_auth_decision = (self._conf_get('delay_auth_decision') in",
            "                                    (True, 'true', 't', '1', 'on', 'yes', 'y'))",
            "",
            "        # where to find the auth service (we use this to validate tokens)",
            "        self.auth_host = self._conf_get('auth_host')",
            "        self.auth_port = int(self._conf_get('auth_port'))",
            "        self.auth_protocol = self._conf_get('auth_protocol')",
            "        if not self._conf_get('http_handler'):",
            "            if self.auth_protocol == 'http':",
            "                self.http_client_class = httplib.HTTPConnection",
            "            else:",
            "                self.http_client_class = httplib.HTTPSConnection",
            "        else:",
            "            # Really only used for unit testing, since we need to",
            "            # have a fake handler set up before we issue an http",
            "            # request to get the list of versions supported by the",
            "            # server at the end of this initialization",
            "            self.http_client_class = self._conf_get('http_handler')",
            "",
            "        self.auth_admin_prefix = self._conf_get('auth_admin_prefix')",
            "        self.auth_uri = self._conf_get('auth_uri')",
            "        if self.auth_uri is None:",
            "            self.LOG.warning(",
            "                'Configuring auth_uri to point to the public identity '",
            "                'endpoint is required; clients may not be able to '",
            "                'authenticate against an admin endpoint')",
            "            host = self.auth_host",
            "            if netaddr.valid_ipv6(host):",
            "                # Note(dzyu) it is an IPv6 address, so it needs to be wrapped",
            "                # with '[]' to generate a valid IPv6 URL, based on",
            "                # http://www.ietf.org/rfc/rfc2732.txt",
            "                host = '[%s]' % host",
            "            # FIXME(dolph): drop support for this fallback behavior as",
            "            # documented in bug 1207517",
            "            self.auth_uri = '%s://%s:%s' % (self.auth_protocol,",
            "                                            host,",
            "                                            self.auth_port)",
            "",
            "        # SSL",
            "        self.cert_file = self._conf_get('certfile')",
            "        self.key_file = self._conf_get('keyfile')",
            "",
            "        # signing",
            "        self.signing_dirname = self._conf_get('signing_dir')",
            "        if self.signing_dirname is None:",
            "            self.signing_dirname = tempfile.mkdtemp(prefix='keystone-signing-')",
            "        self.LOG.info('Using %s as cache directory for signing certificate' %",
            "                      self.signing_dirname)",
            "        self.verify_signing_dir()",
            "",
            "        val = '%s/signing_cert.pem' % self.signing_dirname",
            "        self.signing_cert_file_name = val",
            "        val = '%s/cacert.pem' % self.signing_dirname",
            "        self.ca_file_name = val",
            "        val = '%s/revoked.pem' % self.signing_dirname",
            "        self.revoked_file_name = val",
            "",
            "        # Credentials used to verify this component with the Auth service since",
            "        # validating tokens is a privileged call",
            "        self.admin_token = self._conf_get('admin_token')",
            "        self.admin_token_expiry = None",
            "        self.admin_user = self._conf_get('admin_user')",
            "        self.admin_password = self._conf_get('admin_password')",
            "        self.admin_tenant_name = self._conf_get('admin_tenant_name')",
            "",
            "        # Token caching via memcache",
            "        self._cache = None",
            "        self._cache_initialized = False    # cache already initialzied?",
            "        # memcache value treatment, ENCRYPT or MAC",
            "        self._memcache_security_strategy = \\",
            "            self._conf_get('memcache_security_strategy')",
            "        if self._memcache_security_strategy is not None:",
            "            self._memcache_security_strategy = \\",
            "                self._memcache_security_strategy.upper()",
            "        self._memcache_secret_key = \\",
            "            self._conf_get('memcache_secret_key')",
            "        self._assert_valid_memcache_protection_config()",
            "        # By default the token will be cached for 5 minutes",
            "        self.token_cache_time = int(self._conf_get('token_cache_time'))",
            "        self._token_revocation_list = None",
            "        self._token_revocation_list_fetched_time = None",
            "        self.token_revocation_list_cache_timeout = datetime.timedelta(",
            "            seconds=self._conf_get('revocation_cache_time'))",
            "        http_connect_timeout_cfg = self._conf_get('http_connect_timeout')",
            "        self.http_connect_timeout = (http_connect_timeout_cfg and",
            "                                     int(http_connect_timeout_cfg))",
            "        self.auth_version = None",
            "        self.http_request_max_retries = \\",
            "            self._conf_get('http_request_max_retries')",
            "",
            "    def _assert_valid_memcache_protection_config(self):",
            "        if self._memcache_security_strategy:",
            "            if self._memcache_security_strategy not in ('MAC', 'ENCRYPT'):",
            "                raise Exception('memcache_security_strategy must be '",
            "                                'ENCRYPT or MAC')",
            "            if not self._memcache_secret_key:",
            "                raise Exception('mecmache_secret_key must be defined when '",
            "                                'a memcache_security_strategy is defined')",
            "",
            "    def _init_cache(self, env):",
            "        cache = self._conf_get('cache')",
            "        memcache_servers = self._conf_get('memcached_servers')",
            "",
            "        if cache and env.get(cache, None) is not None:",
            "            # use the cache from the upstream filter",
            "            self.LOG.info('Using %s memcache for caching token', cache)",
            "            self._cache = env.get(cache)",
            "        else:",
            "            # use Keystone memcache",
            "            self._cache = memorycache.get_client(memcache_servers)",
            "        self._cache_initialized = True",
            "",
            "    def _conf_get(self, name):",
            "        # try config from paste-deploy first",
            "        if name in self.conf:",
            "            return self.conf[name]",
            "        else:",
            "            return CONF.keystone_authtoken[name]",
            "",
            "    def _choose_api_version(self):",
            "        \"\"\"Determine the api version that we should use.\"\"\"",
            "",
            "        # If the configuration specifies an auth_version we will just",
            "        # assume that is correct and use it.  We could, of course, check",
            "        # that this version is supported by the server, but in case",
            "        # there are some problems in the field, we want as little code",
            "        # as possible in the way of letting auth_token talk to the",
            "        # server.",
            "        if self._conf_get('auth_version'):",
            "            version_to_use = self._conf_get('auth_version')",
            "            self.LOG.info('Auth Token proceeding with requested %s apis',",
            "                          version_to_use)",
            "        else:",
            "            version_to_use = None",
            "            versions_supported_by_server = self._get_supported_versions()",
            "            if versions_supported_by_server:",
            "                for version in LIST_OF_VERSIONS_TO_ATTEMPT:",
            "                    if version in versions_supported_by_server:",
            "                        version_to_use = version",
            "                        break",
            "            if version_to_use:",
            "                self.LOG.info('Auth Token confirmed use of %s apis',",
            "                              version_to_use)",
            "            else:",
            "                self.LOG.error(",
            "                    'Attempted versions [%s] not in list supported by '",
            "                    'server [%s]',",
            "                    ', '.join(LIST_OF_VERSIONS_TO_ATTEMPT),",
            "                    ', '.join(versions_supported_by_server))",
            "                raise ServiceError('No compatible apis supported by server')",
            "        return version_to_use",
            "",
            "    def _get_supported_versions(self):",
            "        versions = []",
            "        response, data = self._json_request('GET', '/')",
            "        if response.status == 501:",
            "            self.LOG.warning(\"Old keystone installation found...assuming v2.0\")",
            "            versions.append(\"v2.0\")",
            "        elif response.status != 300:",
            "            self.LOG.error('Unable to get version info from keystone: %s' %",
            "                           response.status)",
            "            raise ServiceError('Unable to get version info from keystone')",
            "        else:",
            "            try:",
            "                for version in data['versions']['values']:",
            "                    versions.append(version['id'])",
            "            except KeyError:",
            "                self.LOG.error(",
            "                    'Invalid version response format from server', data)",
            "                raise ServiceError('Unable to parse version response '",
            "                                   'from keystone')",
            "",
            "        self.LOG.debug('Server reports support for api versions: %s',",
            "                       ', '.join(versions))",
            "        return versions",
            "",
            "    def __call__(self, env, start_response):",
            "        \"\"\"Handle incoming request.",
            "",
            "        Authenticate send downstream on success. Reject request if",
            "        we can't authenticate.",
            "",
            "        \"\"\"",
            "        self.LOG.debug('Authenticating user token')",
            "",
            "        # initialize memcache if we haven't done so",
            "        if not self._cache_initialized:",
            "            self._init_cache(env)",
            "",
            "        try:",
            "            self._remove_auth_headers(env)",
            "            user_token = self._get_user_token_from_header(env)",
            "            token_info = self._validate_user_token(user_token)",
            "            env['keystone.token_info'] = token_info",
            "            user_headers = self._build_user_headers(token_info)",
            "            self._add_headers(env, user_headers)",
            "            return self.app(env, start_response)",
            "",
            "        except InvalidUserToken:",
            "            if self.delay_auth_decision:",
            "                self.LOG.info(",
            "                    'Invalid user token - deferring reject downstream')",
            "                self._add_headers(env, {'X-Identity-Status': 'Invalid'})",
            "                return self.app(env, start_response)",
            "            else:",
            "                self.LOG.info('Invalid user token - rejecting request')",
            "                return self._reject_request(env, start_response)",
            "",
            "        except ServiceError as e:",
            "            self.LOG.critical('Unable to obtain admin token: %s' % e)",
            "            resp = MiniResp('Service unavailable', env)",
            "            start_response('503 Service Unavailable', resp.headers)",
            "            return resp.body",
            "",
            "    def _remove_auth_headers(self, env):",
            "        \"\"\"Remove headers so a user can't fake authentication.",
            "",
            "        :param env: wsgi request environment",
            "",
            "        \"\"\"",
            "        auth_headers = (",
            "            'X-Identity-Status',",
            "            'X-Domain-Id',",
            "            'X-Domain-Name',",
            "            'X-Project-Id',",
            "            'X-Project-Name',",
            "            'X-Project-Domain-Id',",
            "            'X-Project-Domain-Name',",
            "            'X-User-Id',",
            "            'X-User-Name',",
            "            'X-User-Domain-Id',",
            "            'X-User-Domain-Name',",
            "            'X-Roles',",
            "            'X-Service-Catalog',",
            "            # Deprecated",
            "            'X-User',",
            "            'X-Tenant-Id',",
            "            'X-Tenant-Name',",
            "            'X-Tenant',",
            "            'X-Role',",
            "        )",
            "        self.LOG.debug('Removing headers from request environment: %s' %",
            "                       ','.join(auth_headers))",
            "        self._remove_headers(env, auth_headers)",
            "",
            "    def _get_user_token_from_header(self, env):",
            "        \"\"\"Get token id from request.",
            "",
            "        :param env: wsgi request environment",
            "        :return token id",
            "        :raises InvalidUserToken if no token is provided in request",
            "",
            "        \"\"\"",
            "        token = self._get_header(env, 'X-Auth-Token',",
            "                                 self._get_header(env, 'X-Storage-Token'))",
            "        if token:",
            "            return token",
            "        else:",
            "            if not self.delay_auth_decision:",
            "                self.LOG.warn(\"Unable to find authentication token\"",
            "                              \" in headers\")",
            "                self.LOG.debug(\"Headers: %s\", env)",
            "            raise InvalidUserToken('Unable to find token in headers')",
            "",
            "    def _reject_request(self, env, start_response):",
            "        \"\"\"Redirect client to auth server.",
            "",
            "        :param env: wsgi request environment",
            "        :param start_response: wsgi response callback",
            "        :returns HTTPUnauthorized http response",
            "",
            "        \"\"\"",
            "        headers = [('WWW-Authenticate', 'Keystone uri=\\'%s\\'' % self.auth_uri)]",
            "        resp = MiniResp('Authentication required', env, headers)",
            "        start_response('401 Unauthorized', resp.headers)",
            "        return resp.body",
            "",
            "    def get_admin_token(self):",
            "        \"\"\"Return admin token, possibly fetching a new one.",
            "",
            "        if self.admin_token_expiry is set from fetching an admin token, check",
            "        it for expiration, and request a new token is the existing token",
            "        is about to expire.",
            "",
            "        :return admin token id",
            "        :raise ServiceError when unable to retrieve token from keystone",
            "",
            "        \"\"\"",
            "        if self.admin_token_expiry:",
            "            if will_expire_soon(self.admin_token_expiry):",
            "                self.admin_token = None",
            "",
            "        if not self.admin_token:",
            "            (self.admin_token,",
            "             self.admin_token_expiry) = self._request_admin_token()",
            "",
            "        return self.admin_token",
            "",
            "    def _get_http_connection(self):",
            "        if self.auth_protocol == 'http':",
            "            return self.http_client_class(self.auth_host, self.auth_port,",
            "                                          timeout=self.http_connect_timeout)",
            "        else:",
            "            return self.http_client_class(self.auth_host,",
            "                                          self.auth_port,",
            "                                          self.key_file,",
            "                                          self.cert_file,",
            "                                          timeout=self.http_connect_timeout)",
            "",
            "    def _http_request(self, method, path, **kwargs):",
            "        \"\"\"HTTP request helper used to make unspecified content type requests.",
            "",
            "        :param method: http method",
            "        :param path: relative request url",
            "        :return (http response object, response body)",
            "        :raise ServerError when unable to communicate with keystone",
            "",
            "        \"\"\"",
            "        conn = self._get_http_connection()",
            "",
            "        RETRIES = self.http_request_max_retries",
            "        retry = 0",
            "        while True:",
            "            try:",
            "                conn.request(method, path, **kwargs)",
            "                response = conn.getresponse()",
            "                body = response.read()",
            "                break",
            "            except Exception as e:",
            "                if retry == RETRIES:",
            "                    self.LOG.error('HTTP connection exception: %s' % e)",
            "                    raise NetworkError('Unable to communicate with keystone')",
            "                # NOTE(vish): sleep 0.5, 1, 2",
            "                self.LOG.warn('Retrying on HTTP connection exception: %s' % e)",
            "                time.sleep(2.0 ** retry / 2)",
            "                retry += 1",
            "            finally:",
            "                conn.close()",
            "",
            "        return response, body",
            "",
            "    def _json_request(self, method, path, body=None, additional_headers=None):",
            "        \"\"\"HTTP request helper used to make json requests.",
            "",
            "        :param method: http method",
            "        :param path: relative request url",
            "        :param body: dict to encode to json as request body. Optional.",
            "        :param additional_headers: dict of additional headers to send with",
            "                                   http request. Optional.",
            "        :return (http response object, response body parsed as json)",
            "        :raise ServerError when unable to communicate with keystone",
            "",
            "        \"\"\"",
            "        kwargs = {",
            "            'headers': {",
            "                'Content-type': 'application/json',",
            "                'Accept': 'application/json',",
            "            },",
            "        }",
            "",
            "        if additional_headers:",
            "            kwargs['headers'].update(additional_headers)",
            "",
            "        if body:",
            "            kwargs['body'] = jsonutils.dumps(body)",
            "",
            "        path = self.auth_admin_prefix + path",
            "",
            "        response, body = self._http_request(method, path, **kwargs)",
            "",
            "        try:",
            "            data = jsonutils.loads(body)",
            "        except ValueError:",
            "            self.LOG.debug('Keystone did not return json-encoded body')",
            "            data = {}",
            "",
            "        return response, data",
            "",
            "    def _request_admin_token(self):",
            "        \"\"\"Retrieve new token as admin user from keystone.",
            "",
            "        :return token id upon success",
            "        :raises ServerError when unable to communicate with keystone",
            "",
            "        Irrespective of the auth version we are going to use for the",
            "        user token, for simplicity we always use a v2 admin token to",
            "        validate the user token.",
            "",
            "        \"\"\"",
            "        params = {",
            "            'auth': {",
            "                'passwordCredentials': {",
            "                    'username': self.admin_user,",
            "                    'password': self.admin_password,",
            "                },",
            "                'tenantName': self.admin_tenant_name,",
            "            }",
            "        }",
            "",
            "        response, data = self._json_request('POST',",
            "                                            '/v2.0/tokens',",
            "                                            body=params)",
            "",
            "        try:",
            "            token = data['access']['token']['id']",
            "            expiry = data['access']['token']['expires']",
            "            if not (token and expiry):",
            "                raise AssertionError('invalid token or expire')",
            "            datetime_expiry = timeutils.parse_isotime(expiry)",
            "            return (token, timeutils.normalize_time(datetime_expiry))",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "        except (ValueError):",
            "            self.LOG.warn(",
            "                \"Unable to parse expiration time from token: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "",
            "    def _validate_user_token(self, user_token, retry=True):",
            "        \"\"\"Authenticate user using PKI",
            "",
            "        :param user_token: user's token id",
            "        :param retry: Ignored, as it is not longer relevant",
            "        :return uncrypted body of the token if the token is valid",
            "        :raise InvalidUserToken if token is rejected",
            "        :no longer raises ServiceError since it no longer makes RPC",
            "",
            "        \"\"\"",
            "        token_id = None",
            "",
            "        try:",
            "            token_id = cms.cms_hash_token(user_token)",
            "            cached = self._cache_get(token_id)",
            "            if cached:",
            "                return cached",
            "            if cms.is_ans1_token(user_token):",
            "                verified = self.verify_signed_token(user_token)",
            "                data = jsonutils.loads(verified)",
            "            else:",
            "                data = self.verify_uuid_token(user_token, retry)",
            "            expires = self._confirm_token_not_expired(data)",
            "            self._cache_put(token_id, data, expires)",
            "            return data",
            "        except NetworkError:",
            "            self.LOG.debug('Token validation failure.', exc_info=True)",
            "            self.LOG.warn(\"Authorization failed for token %s\", token_id)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        except Exception:",
            "            self.LOG.debug('Token validation failure.', exc_info=True)",
            "            if token_id:",
            "                self._cache_store_invalid(token_id)",
            "            self.LOG.warn(\"Authorization failed for token %s\", token_id)",
            "            raise InvalidUserToken('Token authorization failed')",
            "",
            "    def _token_is_v2(self, token_info):",
            "        return ('access' in token_info)",
            "",
            "    def _token_is_v3(self, token_info):",
            "        return ('token' in token_info)",
            "",
            "    def _build_user_headers(self, token_info):",
            "        \"\"\"Convert token object into headers.",
            "",
            "        Build headers that represent authenticated user - see main",
            "        doc info at start of file for details of headers to be defined.",
            "",
            "        :param token_info: token object returned by keystone on authentication",
            "        :raise InvalidUserToken when unable to parse token object",
            "",
            "        \"\"\"",
            "        def get_tenant_info():",
            "            \"\"\"Returns a (tenant_id, tenant_name) tuple from context.\"\"\"",
            "            def essex():",
            "                \"\"\"Essex puts the tenant ID and name on the token.\"\"\"",
            "                return (token['tenant']['id'], token['tenant']['name'])",
            "",
            "            def pre_diablo():",
            "                \"\"\"Pre-diablo, Keystone only provided tenantId.\"\"\"",
            "                return (token['tenantId'], token['tenantId'])",
            "",
            "            def default_tenant():",
            "                \"\"\"Pre-grizzly, assume the user's default tenant.\"\"\"",
            "                return (user['tenantId'], user['tenantName'])",
            "",
            "            for method in [essex, pre_diablo, default_tenant]:",
            "                try:",
            "                    return method()",
            "                except KeyError:",
            "                    pass",
            "",
            "            raise InvalidUserToken('Unable to determine tenancy.')",
            "",
            "        # For clarity. set all those attributes that are optional in",
            "        # either a v2 or v3 token to None first",
            "        domain_id = None",
            "        domain_name = None",
            "        project_id = None",
            "        project_name = None",
            "        user_domain_id = None",
            "        user_domain_name = None",
            "        project_domain_id = None",
            "        project_domain_name = None",
            "",
            "        if self._token_is_v2(token_info):",
            "            user = token_info['access']['user']",
            "            token = token_info['access']['token']",
            "            roles = ','.join([role['name'] for role in user.get('roles', [])])",
            "            catalog_root = token_info['access']",
            "            catalog_key = 'serviceCatalog'",
            "            project_id, project_name = get_tenant_info()",
            "        else:",
            "            #v3 token",
            "            token = token_info['token']",
            "            user = token['user']",
            "            user_domain_id = user['domain']['id']",
            "            user_domain_name = user['domain']['name']",
            "            roles = (','.join([role['name']",
            "                     for role in token.get('roles', [])]))",
            "            catalog_root = token",
            "            catalog_key = 'catalog'",
            "            # For v3, the server will put in the default project if there is",
            "            # one, so no need for us to add it here (like we do for a v2 token)",
            "            if 'domain' in token:",
            "                domain_id = token['domain']['id']",
            "                domain_name = token['domain']['name']",
            "            elif 'project' in token:",
            "                project_id = token['project']['id']",
            "                project_name = token['project']['name']",
            "                project_domain_id = token['project']['domain']['id']",
            "                project_domain_name = token['project']['domain']['name']",
            "",
            "        user_id = user['id']",
            "        user_name = user['name']",
            "",
            "        rval = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Domain-Id': domain_id,",
            "            'X-Domain-Name': domain_name,",
            "            'X-Project-Id': project_id,",
            "            'X-Project-Name': project_name,",
            "            'X-Project-Domain-Id': project_domain_id,",
            "            'X-Project-Domain-Name': project_domain_name,",
            "            'X-User-Id': user_id,",
            "            'X-User-Name': user_name,",
            "            'X-User-Domain-Id': user_domain_id,",
            "            'X-User-Domain-Name': user_domain_name,",
            "            'X-Roles': roles,",
            "            # Deprecated",
            "            'X-User': user_name,",
            "            'X-Tenant-Id': project_id,",
            "            'X-Tenant-Name': project_name,",
            "            'X-Tenant': project_name,",
            "            'X-Role': roles,",
            "        }",
            "",
            "        try:",
            "            catalog = catalog_root[catalog_key]",
            "            rval['X-Service-Catalog'] = jsonutils.dumps(catalog)",
            "        except KeyError:",
            "            pass",
            "",
            "        return rval",
            "",
            "    def _header_to_env_var(self, key):",
            "        \"\"\"Convert header to wsgi env variable.",
            "",
            "        :param key: http header name (ex. 'X-Auth-Token')",
            "        :return wsgi env variable name (ex. 'HTTP_X_AUTH_TOKEN')",
            "",
            "        \"\"\"",
            "        return 'HTTP_%s' % key.replace('-', '_').upper()",
            "",
            "    def _add_headers(self, env, headers):",
            "        \"\"\"Add http headers to environment.\"\"\"",
            "        for (k, v) in six.iteritems(headers):",
            "            env_key = self._header_to_env_var(k)",
            "            env[env_key] = v",
            "",
            "    def _remove_headers(self, env, keys):",
            "        \"\"\"Remove http headers from environment.\"\"\"",
            "        for k in keys:",
            "            env_key = self._header_to_env_var(k)",
            "            try:",
            "                del env[env_key]",
            "            except KeyError:",
            "                pass",
            "",
            "    def _get_header(self, env, key, default=None):",
            "        \"\"\"Get http header from environment.\"\"\"",
            "        env_key = self._header_to_env_var(key)",
            "        return env.get(env_key, default)",
            "",
            "    def _cache_get(self, token_id, ignore_expires=False):",
            "        \"\"\"Return token information from cache.",
            "",
            "        If token is invalid raise InvalidUserToken",
            "        return token only if fresh (not expired).",
            "        \"\"\"",
            "",
            "        if self._cache and token_id:",
            "            if self._memcache_security_strategy is None:",
            "                key = CACHE_KEY_TEMPLATE % token_id",
            "                serialized = self._cache.get(key)",
            "            else:",
            "                keys = memcache_crypt.derive_keys(",
            "                    token_id,",
            "                    self._memcache_secret_key,",
            "                    self._memcache_security_strategy)",
            "                cache_key = CACHE_KEY_TEMPLATE % (",
            "                    memcache_crypt.get_cache_key(keys))",
            "                raw_cached = self._cache.get(cache_key)",
            "                try:",
            "                    # unprotect_data will return None if raw_cached is None",
            "                    serialized = memcache_crypt.unprotect_data(keys,",
            "                                                               raw_cached)",
            "                except Exception:",
            "                    msg = 'Failed to decrypt/verify cache data'",
            "                    self.LOG.exception(msg)",
            "                    # this should have the same effect as data not",
            "                    # found in cache",
            "                    serialized = None",
            "",
            "            if serialized is None:",
            "                return None",
            "",
            "            # Note that 'invalid' and (data, expires) are the only",
            "            # valid types of serialized cache entries, so there is not",
            "            # a collision with jsonutils.loads(serialized) == None.",
            "            cached = jsonutils.loads(serialized)",
            "            if cached == 'invalid':",
            "                self.LOG.debug('Cached Token %s is marked unauthorized',",
            "                               token_id)",
            "                raise InvalidUserToken('Token authorization failed')",
            "",
            "            data, expires = cached",
            "            if ignore_expires or time.time() < float(expires):",
            "                self.LOG.debug('Returning cached token %s', token_id)",
            "                return data",
            "            else:",
            "                self.LOG.debug('Cached Token %s seems expired', token_id)",
            "",
            "    def _cache_store(self, token_id, data):",
            "        \"\"\"Store value into memcache.",
            "",
            "        data may be the string 'invalid' or a tuple like (data, expires)",
            "",
            "        \"\"\"",
            "        serialized_data = jsonutils.dumps(data)",
            "        if self._memcache_security_strategy is None:",
            "            cache_key = CACHE_KEY_TEMPLATE % token_id",
            "            data_to_store = serialized_data",
            "        else:",
            "            keys = memcache_crypt.derive_keys(",
            "                token_id,",
            "                self._memcache_secret_key,",
            "                self._memcache_security_strategy)",
            "            cache_key = CACHE_KEY_TEMPLATE % memcache_crypt.get_cache_key(keys)",
            "            data_to_store = memcache_crypt.protect_data(keys, serialized_data)",
            "",
            "        # Historically the swift cache conection used the argument",
            "        # timeout= for the cache timeout, but this has been unified",
            "        # with the official python memcache client with time= since",
            "        # grizzly, we still need to handle folsom for a while until",
            "        # this could get removed.",
            "        try:",
            "            self._cache.set(cache_key,",
            "                            data_to_store,",
            "                            time=self.token_cache_time)",
            "        except(TypeError):",
            "            self._cache.set(cache_key,",
            "                            data_to_store,",
            "                            timeout=self.token_cache_time)",
            "",
            "    def _confirm_token_not_expired(self, data):",
            "        if not data:",
            "            raise InvalidUserToken('Token authorization failed')",
            "        if self._token_is_v2(data):",
            "            timestamp = data['access']['token']['expires']",
            "        elif self._token_is_v3(data):",
            "            timestamp = data['token']['expires_at']",
            "        else:",
            "            raise InvalidUserToken('Token authorization failed')",
            "        expires = timeutils.parse_isotime(timestamp).strftime('%s')",
            "        if time.time() >= float(expires):",
            "            self.LOG.debug('Token expired a %s', timestamp)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        return expires",
            "",
            "    def _cache_put(self, token_id, data, expires):",
            "        \"\"\"Put token data into the cache.",
            "",
            "        Stores the parsed expire date in cache allowing",
            "        quick check of token freshness on retrieval.",
            "",
            "        \"\"\"",
            "        if self._cache:",
            "                self.LOG.debug('Storing %s token in memcache', token_id)",
            "                self._cache_store(token_id, (data, expires))",
            "",
            "    def _cache_store_invalid(self, token_id):",
            "        \"\"\"Store invalid token in cache.\"\"\"",
            "        if self._cache:",
            "            self.LOG.debug(",
            "                'Marking token %s as unauthorized in memcache', token_id)",
            "            self._cache_store(token_id, 'invalid')",
            "",
            "    def cert_file_missing(self, proc_output, file_name):",
            "        return (file_name in proc_output and not os.path.exists(file_name))",
            "",
            "    def verify_uuid_token(self, user_token, retry=True):",
            "        \"\"\"Authenticate user token with keystone.",
            "",
            "        :param user_token: user's token id",
            "        :param retry: flag that forces the middleware to retry",
            "                      user authentication when an indeterminate",
            "                      response is received. Optional.",
            "        :return token object received from keystone on success",
            "        :raise InvalidUserToken if token is rejected",
            "        :raise ServiceError if unable to authenticate token",
            "",
            "        \"\"\"",
            "        # Determine the highest api version we can use.",
            "        if not self.auth_version:",
            "            self.auth_version = self._choose_api_version()",
            "",
            "        if self.auth_version == 'v3.0':",
            "            headers = {'X-Auth-Token': self.get_admin_token(),",
            "                       'X-Subject-Token': safe_quote(user_token)}",
            "            response, data = self._json_request(",
            "                'GET',",
            "                '/v3/auth/tokens',",
            "                additional_headers=headers)",
            "        else:",
            "            headers = {'X-Auth-Token': self.get_admin_token()}",
            "            response, data = self._json_request(",
            "                'GET',",
            "                '/v2.0/tokens/%s' % safe_quote(user_token),",
            "                additional_headers=headers)",
            "",
            "        if response.status == 200:",
            "            return data",
            "        if response.status == 404:",
            "            self.LOG.warn(\"Authorization failed for token %s\", user_token)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        if response.status == 401:",
            "            self.LOG.info(",
            "                'Keystone rejected admin token %s, resetting', headers)",
            "            self.admin_token = None",
            "        else:",
            "            self.LOG.error('Bad response code while validating token: %s' %",
            "                           response.status)",
            "        if retry:",
            "            self.LOG.info('Retrying validation')",
            "            return self._validate_user_token(user_token, False)",
            "        else:",
            "            self.LOG.warn(\"Invalid user token: %s. Keystone response: %s.\",",
            "                          user_token, data)",
            "",
            "            raise InvalidUserToken()",
            "",
            "    def is_signed_token_revoked(self, signed_text):",
            "        \"\"\"Indicate whether the token appears in the revocation list.\"\"\"",
            "        revocation_list = self.token_revocation_list",
            "        revoked_tokens = revocation_list.get('revoked', [])",
            "        if not revoked_tokens:",
            "            return",
            "        revoked_ids = (x['id'] for x in revoked_tokens)",
            "        token_id = utils.hash_signed_token(signed_text)",
            "        for revoked_id in revoked_ids:",
            "            if token_id == revoked_id:",
            "                self.LOG.debug('Token %s is marked as having been revoked',",
            "                               token_id)",
            "                return True",
            "        return False",
            "",
            "    def cms_verify(self, data):",
            "        \"\"\"Verifies the signature of the provided data's IAW CMS syntax.",
            "",
            "        If either of the certificate files are missing, fetch them and",
            "        retry.",
            "        \"\"\"",
            "        while True:",
            "            try:",
            "                output = cms.cms_verify(data, self.signing_cert_file_name,",
            "                                        self.ca_file_name)",
            "            except cms.subprocess.CalledProcessError as err:",
            "                if self.cert_file_missing(err.output,",
            "                                          self.signing_cert_file_name):",
            "                    self.fetch_signing_cert()",
            "                    continue",
            "                if self.cert_file_missing(err.output, self.ca_file_name):",
            "                    self.fetch_ca_cert()",
            "                    continue",
            "                self.LOG.warning('Verify error: %s' % err)",
            "                raise err",
            "            return output",
            "",
            "    def verify_signed_token(self, signed_text):",
            "        \"\"\"Check that the token is unrevoked and has a valid signature.\"\"\"",
            "        if self.is_signed_token_revoked(signed_text):",
            "            raise InvalidUserToken('Token has been revoked')",
            "",
            "        formatted = cms.token_to_cms(signed_text)",
            "        return self.cms_verify(formatted)",
            "",
            "    def verify_signing_dir(self):",
            "        if os.path.exists(self.signing_dirname):",
            "            if not os.access(self.signing_dirname, os.W_OK):",
            "                raise ConfigurationError(",
            "                    'unable to access signing_dir %s' % self.signing_dirname)",
            "            if os.stat(self.signing_dirname).st_uid != os.getuid():",
            "                self.LOG.warning(",
            "                    'signing_dir is not owned by %s' % os.getuid())",
            "            current_mode = stat.S_IMODE(os.stat(self.signing_dirname).st_mode)",
            "            if current_mode != stat.S_IRWXU:",
            "                self.LOG.warning(",
            "                    'signing_dir mode is %s instead of %s' %",
            "                    (oct(current_mode), oct(stat.S_IRWXU)))",
            "        else:",
            "            os.makedirs(self.signing_dirname, stat.S_IRWXU)",
            "",
            "    @property",
            "    def token_revocation_list_fetched_time(self):",
            "        if not self._token_revocation_list_fetched_time:",
            "            # If the fetched list has been written to disk, use its",
            "            # modification time.",
            "            if os.path.exists(self.revoked_file_name):",
            "                mtime = os.path.getmtime(self.revoked_file_name)",
            "                fetched_time = datetime.datetime.fromtimestamp(mtime)",
            "            # Otherwise the list will need to be fetched.",
            "            else:",
            "                fetched_time = datetime.datetime.min",
            "            self._token_revocation_list_fetched_time = fetched_time",
            "        return self._token_revocation_list_fetched_time",
            "",
            "    @token_revocation_list_fetched_time.setter",
            "    def token_revocation_list_fetched_time(self, value):",
            "        self._token_revocation_list_fetched_time = value",
            "",
            "    @property",
            "    def token_revocation_list(self):",
            "        timeout = (self.token_revocation_list_fetched_time +",
            "                   self.token_revocation_list_cache_timeout)",
            "        list_is_current = timeutils.utcnow() < timeout",
            "",
            "        if list_is_current:",
            "            # Load the list from disk if required",
            "            if not self._token_revocation_list:",
            "                with open(self.revoked_file_name, 'r') as f:",
            "                    self._token_revocation_list = jsonutils.loads(f.read())",
            "        else:",
            "            self.token_revocation_list = self.fetch_revocation_list()",
            "        return self._token_revocation_list",
            "",
            "    @token_revocation_list.setter",
            "    def token_revocation_list(self, value):",
            "        \"\"\"Save a revocation list to memory and to disk.",
            "",
            "        :param value: A json-encoded revocation list",
            "",
            "        \"\"\"",
            "        self._token_revocation_list = jsonutils.loads(value)",
            "        self.token_revocation_list_fetched_time = timeutils.utcnow()",
            "        with open(self.revoked_file_name, 'w') as f:",
            "            f.write(value)",
            "",
            "    def fetch_revocation_list(self, retry=True):",
            "        headers = {'X-Auth-Token': self.get_admin_token()}",
            "        response, data = self._json_request('GET', '/v2.0/tokens/revoked',",
            "                                            additional_headers=headers)",
            "        if response.status == 401:",
            "            if retry:",
            "                self.LOG.info(",
            "                    'Keystone rejected admin token %s, resetting admin token',",
            "                    headers)",
            "                self.admin_token = None",
            "                return self.fetch_revocation_list(retry=False)",
            "        if response.status != 200:",
            "            raise ServiceError('Unable to fetch token revocation list.')",
            "        if 'signed' not in data:",
            "            raise ServiceError('Revocation list improperly formatted.')",
            "        return self.cms_verify(data['signed'])",
            "",
            "    def fetch_signing_cert(self):",
            "        path = self.auth_admin_prefix.rstrip('/')",
            "        path += '/v2.0/certificates/signing'",
            "        response, data = self._http_request('GET', path)",
            "",
            "        def write_cert_file(data):",
            "            with open(self.signing_cert_file_name, 'w') as certfile:",
            "                certfile.write(data)",
            "",
            "        try:",
            "            #todo check response",
            "            try:",
            "                write_cert_file(data)",
            "            except IOError:",
            "                self.verify_signing_dir()",
            "                write_cert_file(data)",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "",
            "    def fetch_ca_cert(self):",
            "        path = self.auth_admin_prefix.rstrip('/') + '/v2.0/certificates/ca'",
            "        response, data = self._http_request('GET', path)",
            "",
            "        try:",
            "            #todo check response",
            "            with open(self.ca_file_name, 'w') as certfile:",
            "                certfile.write(data)",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "",
            "",
            "def filter_factory(global_conf, **local_conf):",
            "    \"\"\"Returns a WSGI filter app for use with paste.deploy.\"\"\"",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "",
            "    def auth_filter(app):",
            "        return AuthProtocol(app, conf)",
            "    return auth_filter",
            "",
            "",
            "def app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AuthProtocol(None, conf)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
            "# implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"",
            "TOKEN-BASED AUTH MIDDLEWARE",
            "",
            "This WSGI component:",
            "",
            "* Verifies that incoming client requests have valid tokens by validating",
            "  tokens with the auth service.",
            "* Rejects unauthenticated requests UNLESS it is in 'delay_auth_decision'",
            "  mode, which means the final decision is delegated to the downstream WSGI",
            "  component (usually the OpenStack service)",
            "* Collects and forwards identity information based on a valid token",
            "  such as user name, tenant, etc",
            "",
            "Refer to: http://keystone.openstack.org/middlewarearchitecture.html",
            "",
            "HEADERS",
            "-------",
            "",
            "* Headers starting with HTTP\\_ is a standard http header",
            "* Headers starting with HTTP_X is an extended http header",
            "",
            "Coming in from initial call from client or customer",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "HTTP_X_AUTH_TOKEN",
            "    The client token being passed in.",
            "",
            "HTTP_X_STORAGE_TOKEN",
            "    The client token being passed in (legacy Rackspace use) to support",
            "    swift/cloud files",
            "",
            "Used for communication between components",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "WWW-Authenticate",
            "    HTTP header returned to a user indicating which endpoint to use",
            "    to retrieve a new token",
            "",
            "What we add to the request for use by the OpenStack service",
            "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
            "",
            "HTTP_X_IDENTITY_STATUS",
            "    'Confirmed' or 'Invalid'",
            "    The underlying service will only see a value of 'Invalid' if the Middleware",
            "    is configured to run in 'delay_auth_decision' mode",
            "",
            "HTTP_X_DOMAIN_ID",
            "    Identity service managed unique identifier, string. Only present if",
            "    this is a domain-scoped v3 token.",
            "",
            "HTTP_X_DOMAIN_NAME",
            "    Unique domain name, string. Only present if this is a domain-scoped",
            "    v3 token.",
            "",
            "HTTP_X_PROJECT_ID",
            "    Identity service managed unique identifier, string. Only present if",
            "    this is a project-scoped v3 token, or a tenant-scoped v2 token.",
            "",
            "HTTP_X_PROJECT_NAME",
            "    Project name, unique within owning domain, string. Only present if",
            "    this is a project-scoped v3 token, or a tenant-scoped v2 token.",
            "",
            "HTTP_X_PROJECT_DOMAIN_ID",
            "    Identity service managed unique identifier of owning domain of",
            "    project, string.  Only present if this is a project-scoped v3 token. If",
            "    this variable is set, this indicates that the PROJECT_NAME can only",
            "    be assumed to be unique within this domain.",
            "",
            "HTTP_X_PROJECT_DOMAIN_NAME",
            "    Name of owning domain of project, string. Only present if this is a",
            "    project-scoped v3 token. If this variable is set, this indicates that",
            "    the PROJECT_NAME can only be assumed to be unique within this domain.",
            "",
            "HTTP_X_USER_ID",
            "    Identity-service managed unique identifier, string",
            "",
            "HTTP_X_USER_NAME",
            "    User identifier, unique within owning domain, string",
            "",
            "HTTP_X_USER_DOMAIN_ID",
            "    Identity service managed unique identifier of owning domain of",
            "    user, string. If this variable is set, this indicates that the USER_NAME",
            "    can only be assumed to be unique within this domain.",
            "",
            "HTTP_X_USER_DOMAIN_NAME",
            "    Name of owning domain of user, string. If this variable is set, this",
            "    indicates that the USER_NAME can only be assumed to be unique within",
            "    this domain.",
            "",
            "HTTP_X_ROLES",
            "    Comma delimited list of case-sensitive role names",
            "",
            "HTTP_X_SERVICE_CATALOG",
            "    json encoded keystone service catalog (optional).",
            "",
            "HTTP_X_TENANT_ID",
            "    *Deprecated* in favor of HTTP_X_PROJECT_ID",
            "    Identity service managed unique identifier, string. For v3 tokens, this",
            "    will be set to the same value as HTTP_X_PROJECT_ID",
            "",
            "HTTP_X_TENANT_NAME",
            "    *Deprecated* in favor of HTTP_X_PROJECT_NAME",
            "    Project identifier, unique within owning domain, string. For v3 tokens,",
            "    this will be set to the same value as HTTP_X_PROJECT_NAME",
            "",
            "HTTP_X_TENANT",
            "    *Deprecated* in favor of HTTP_X_TENANT_ID and HTTP_X_TENANT_NAME",
            "    Keystone-assigned unique identifier, string. For v3 tokens, this",
            "    will be set to the same value as HTTP_X_PROJECT_ID",
            "",
            "HTTP_X_USER",
            "    *Deprecated* in favor of HTTP_X_USER_ID and HTTP_X_USER_NAME",
            "    User name, unique within owning domain, string",
            "",
            "HTTP_X_ROLE",
            "    *Deprecated* in favor of HTTP_X_ROLES",
            "    Will contain the same values as HTTP_X_ROLES.",
            "",
            "OTHER ENVIRONMENT VARIABLES",
            "---------------------------",
            "",
            "keystone.token_info",
            "    Information about the token discovered in the process of",
            "    validation.  This may include extended information returned by the",
            "    Keystone token validation call, as well as basic information about",
            "    the tenant and user.",
            "",
            "\"\"\"",
            "",
            "import datetime",
            "import logging",
            "import os",
            "import requests",
            "import stat",
            "import tempfile",
            "import time",
            "import urllib",
            "",
            "import netaddr",
            "import six",
            "",
            "from keystoneclient.common import cms",
            "from keystoneclient.middleware import memcache_crypt",
            "from keystoneclient.openstack.common import jsonutils",
            "from keystoneclient.openstack.common import memorycache",
            "from keystoneclient.openstack.common import timeutils",
            "from keystoneclient import utils",
            "",
            "CONF = None",
            "# to pass gate before oslo-config is deployed everywhere,",
            "# try application copies first",
            "for app in 'nova', 'glance', 'quantum', 'cinder':",
            "    try:",
            "        cfg = __import__('%s.openstack.common.cfg' % app,",
            "                         fromlist=['%s.openstack.common' % app])",
            "        # test which application middleware is running in",
            "        if hasattr(cfg, 'CONF') and 'config_file' in cfg.CONF:",
            "            CONF = cfg.CONF",
            "            break",
            "    except ImportError:",
            "        pass",
            "if not CONF:",
            "    from oslo.config import cfg",
            "    CONF = cfg.CONF",
            "",
            "# alternative middleware configuration in the main application's",
            "# configuration file e.g. in nova.conf",
            "# [keystone_authtoken]",
            "# auth_host = 127.0.0.1",
            "# auth_port = 35357",
            "# auth_protocol = http",
            "# admin_tenant_name = admin",
            "# admin_user = admin",
            "# admin_password = badpassword",
            "",
            "# when deploy Keystone auth_token middleware with Swift, user may elect",
            "# to use Swift memcache instead of the local Keystone memcache. Swift memcache",
            "# is passed in from the request environment and its identified by the",
            "# 'swift.cache' key. However it could be different, depending on deployment.",
            "# To use Swift memcache, you must set the 'cache' option to the environment",
            "# key where the Swift cache object is stored.",
            "opts = [",
            "    cfg.StrOpt('auth_admin_prefix',",
            "               default='',",
            "               help='Prefix to prepend at the beginning of the path'),",
            "    cfg.StrOpt('auth_host',",
            "               default='127.0.0.1',",
            "               help='Host providing the admin Identity API endpoint'),",
            "    cfg.IntOpt('auth_port',",
            "               default=35357,",
            "               help='Port of the admin Identity API endpoint'),",
            "    cfg.StrOpt('auth_protocol',",
            "               default='https',",
            "               help='Protocol of the admin Identity API endpoint'",
            "               '(http or https)'),",
            "    cfg.StrOpt('auth_uri',",
            "               default=None,",
            "               # FIXME(dolph): should be default='http://127.0.0.1:5000/v2.0/',",
            "               # or (depending on client support) an unversioned, publicly",
            "               # accessible identity endpoint (see bug 1207517)",
            "               help='Complete public Identity API endpoint'),",
            "    cfg.StrOpt('auth_version',",
            "               default=None,",
            "               help='API version of the admin Identity API endpoint'),",
            "    cfg.BoolOpt('delay_auth_decision',",
            "                default=False,",
            "                help='Do not handle authorization requests within the'",
            "                ' middleware, but delegate the authorization decision to'",
            "                ' downstream WSGI components'),",
            "    cfg.BoolOpt('http_connect_timeout',",
            "                default=None,",
            "                help='Request timeout value for communicating with Identity'",
            "                ' API server.'),",
            "    cfg.IntOpt('http_request_max_retries',",
            "               default=3,",
            "               help='How many times are we trying to reconnect when'",
            "               ' communicating with Identity API Server.'),",
            "    cfg.StrOpt('http_handler',",
            "               default=None,",
            "               help='Allows to pass in the name of a fake http_handler'",
            "               ' callback function used instead of httplib.HTTPConnection or'",
            "               ' httplib.HTTPSConnection. Useful for unit testing where'",
            "               ' network is not available.'),",
            "    cfg.StrOpt('admin_token',",
            "               secret=True,",
            "               help='Single shared secret with the Keystone configuration'",
            "               ' used for bootstrapping a Keystone installation, or otherwise'",
            "               ' bypassing the normal authentication process.'),",
            "    cfg.StrOpt('admin_user',",
            "               help='Keystone account username'),",
            "    cfg.StrOpt('admin_password',",
            "               secret=True,",
            "               help='Keystone account password'),",
            "    cfg.StrOpt('admin_tenant_name',",
            "               default='admin',",
            "               help='Keystone service account tenant name to validate'",
            "               ' user tokens'),",
            "    cfg.StrOpt('cache',",
            "               default=None,",
            "               help='Env key for the swift cache'),",
            "    cfg.StrOpt('certfile',",
            "               help='Required if Keystone server requires client certificate'),",
            "    cfg.StrOpt('keyfile',",
            "               help='Required if Keystone server requires client certificate'),",
            "    cfg.StrOpt('cafile', default=None,",
            "               help='A PEM encoded Certificate Authority to use when '",
            "                    'verifying HTTPs connections. Defaults to system CAs.'),",
            "    cfg.BoolOpt('insecure', default=False, help='Verify HTTPS connections.'),",
            "    cfg.StrOpt('signing_dir',",
            "               help='Directory used to cache files related to PKI tokens'),",
            "    cfg.ListOpt('memcached_servers',",
            "                deprecated_name='memcache_servers',",
            "                help='If defined, the memcache server(s) to use for'",
            "                ' caching'),",
            "    cfg.IntOpt('token_cache_time',",
            "               default=300,",
            "               help='In order to prevent excessive requests and validations,'",
            "               ' the middleware uses an in-memory cache for the tokens the'",
            "               ' Keystone API returns. This is only valid if memcache_servers'",
            "               ' is defined. Set to -1 to disable caching completely.'),",
            "    cfg.IntOpt('revocation_cache_time',",
            "               default=1,",
            "               help='Value only used for unit testing'),",
            "    cfg.StrOpt('memcache_security_strategy',",
            "               default=None,",
            "               help='(optional) if defined, indicate whether token data'",
            "               ' should be authenticated or authenticated and encrypted.'",
            "               ' Acceptable values are MAC or ENCRYPT.  If MAC, token data is'",
            "               ' authenticated (with HMAC) in the cache. If ENCRYPT, token'",
            "               ' data is encrypted and authenticated in the cache. If the'",
            "               ' value is not one of these options or empty, auth_token will'",
            "               ' raise an exception on initialization.'),",
            "    cfg.StrOpt('memcache_secret_key',",
            "               default=None,",
            "               secret=True,",
            "               help='(optional, mandatory if memcache_security_strategy is'",
            "               ' defined) this string is used for key derivation.')",
            "]",
            "CONF.register_opts(opts, group='keystone_authtoken')",
            "",
            "LIST_OF_VERSIONS_TO_ATTEMPT = ['v2.0', 'v3.0']",
            "CACHE_KEY_TEMPLATE = 'tokens/%s'",
            "",
            "",
            "def will_expire_soon(expiry):",
            "    \"\"\"Determines if expiration is about to occur.",
            "",
            "    :param expiry: a datetime of the expected expiration",
            "    :returns: boolean : true if expiration is within 30 seconds",
            "    \"\"\"",
            "    soon = (timeutils.utcnow() + datetime.timedelta(seconds=30))",
            "    return expiry < soon",
            "",
            "",
            "def safe_quote(s):",
            "    \"\"\"URL-encode strings that are not already URL-encoded.\"\"\"",
            "    return urllib.quote(s) if s == urllib.unquote(s) else s",
            "",
            "",
            "class InvalidUserToken(Exception):",
            "    pass",
            "",
            "",
            "class ServiceError(Exception):",
            "    pass",
            "",
            "",
            "class ConfigurationError(Exception):",
            "    pass",
            "",
            "",
            "class NetworkError(Exception):",
            "    pass",
            "",
            "",
            "class MiniResp(object):",
            "    def __init__(self, error_message, env, headers=[]):",
            "        # The HEAD method is unique: it must never return a body, even if",
            "        # it reports an error (RFC-2616 clause 9.4). We relieve callers",
            "        # from varying the error responses depending on the method.",
            "        if env['REQUEST_METHOD'] == 'HEAD':",
            "            self.body = ['']",
            "        else:",
            "            self.body = [error_message]",
            "        self.headers = list(headers)",
            "        self.headers.append(('Content-type', 'text/plain'))",
            "",
            "",
            "class AuthProtocol(object):",
            "    \"\"\"Auth Middleware that handles authenticating client calls.\"\"\"",
            "",
            "    def __init__(self, app, conf):",
            "        self.LOG = logging.getLogger(conf.get('log_name', __name__))",
            "        self.LOG.info('Starting keystone auth_token middleware')",
            "        self.conf = conf",
            "        self.app = app",
            "",
            "        # delay_auth_decision means we still allow unauthenticated requests",
            "        # through and we let the downstream service make the final decision",
            "        self.delay_auth_decision = (self._conf_get('delay_auth_decision') in",
            "                                    (True, 'true', 't', '1', 'on', 'yes', 'y'))",
            "",
            "        # where to find the auth service (we use this to validate tokens)",
            "        auth_host = self._conf_get('auth_host')",
            "        auth_port = int(self._conf_get('auth_port'))",
            "        auth_protocol = self._conf_get('auth_protocol')",
            "        self.auth_admin_prefix = self._conf_get('auth_admin_prefix')",
            "        self.auth_uri = self._conf_get('auth_uri')",
            "",
            "        if netaddr.valid_ipv6(auth_host):",
            "            # Note(dzyu) it is an IPv6 address, so it needs to be wrapped",
            "            # with '[]' to generate a valid IPv6 URL, based on",
            "            # http://www.ietf.org/rfc/rfc2732.txt",
            "            auth_host = '[%s]' % auth_host",
            "",
            "        self.request_uri = '%s://%s:%s' % (auth_protocol, auth_host, auth_port)",
            "",
            "        if self.auth_uri is None:",
            "            self.LOG.warning(",
            "                'Configuring auth_uri to point to the public identity '",
            "                'endpoint is required; clients may not be able to '",
            "                'authenticate against an admin endpoint')",
            "",
            "            # FIXME(dolph): drop support for this fallback behavior as",
            "            # documented in bug 1207517",
            "            self.auth_uri = self.request_uri",
            "",
            "        # SSL",
            "        self.cert_file = self._conf_get('certfile')",
            "        self.key_file = self._conf_get('keyfile')",
            "        self.ssl_ca_file = self._conf_get('cafile')",
            "        self.ssl_insecure = self._conf_get('insecure')",
            "",
            "        # signing",
            "        self.signing_dirname = self._conf_get('signing_dir')",
            "        if self.signing_dirname is None:",
            "            self.signing_dirname = tempfile.mkdtemp(prefix='keystone-signing-')",
            "        self.LOG.info('Using %s as cache directory for signing certificate' %",
            "                      self.signing_dirname)",
            "        self.verify_signing_dir()",
            "",
            "        val = '%s/signing_cert.pem' % self.signing_dirname",
            "        self.signing_cert_file_name = val",
            "        val = '%s/cacert.pem' % self.signing_dirname",
            "        self.signing_ca_file_name = val",
            "        val = '%s/revoked.pem' % self.signing_dirname",
            "        self.revoked_file_name = val",
            "",
            "        # Credentials used to verify this component with the Auth service since",
            "        # validating tokens is a privileged call",
            "        self.admin_token = self._conf_get('admin_token')",
            "        self.admin_token_expiry = None",
            "        self.admin_user = self._conf_get('admin_user')",
            "        self.admin_password = self._conf_get('admin_password')",
            "        self.admin_tenant_name = self._conf_get('admin_tenant_name')",
            "",
            "        # Token caching via memcache",
            "        self._cache = None",
            "        self._cache_initialized = False    # cache already initialzied?",
            "        # memcache value treatment, ENCRYPT or MAC",
            "        self._memcache_security_strategy = \\",
            "            self._conf_get('memcache_security_strategy')",
            "        if self._memcache_security_strategy is not None:",
            "            self._memcache_security_strategy = \\",
            "                self._memcache_security_strategy.upper()",
            "        self._memcache_secret_key = \\",
            "            self._conf_get('memcache_secret_key')",
            "        self._assert_valid_memcache_protection_config()",
            "        # By default the token will be cached for 5 minutes",
            "        self.token_cache_time = int(self._conf_get('token_cache_time'))",
            "        self._token_revocation_list = None",
            "        self._token_revocation_list_fetched_time = None",
            "        self.token_revocation_list_cache_timeout = datetime.timedelta(",
            "            seconds=self._conf_get('revocation_cache_time'))",
            "        http_connect_timeout_cfg = self._conf_get('http_connect_timeout')",
            "        self.http_connect_timeout = (http_connect_timeout_cfg and",
            "                                     int(http_connect_timeout_cfg))",
            "        self.auth_version = None",
            "        self.http_request_max_retries = \\",
            "            self._conf_get('http_request_max_retries')",
            "",
            "    def _assert_valid_memcache_protection_config(self):",
            "        if self._memcache_security_strategy:",
            "            if self._memcache_security_strategy not in ('MAC', 'ENCRYPT'):",
            "                raise Exception('memcache_security_strategy must be '",
            "                                'ENCRYPT or MAC')",
            "            if not self._memcache_secret_key:",
            "                raise Exception('mecmache_secret_key must be defined when '",
            "                                'a memcache_security_strategy is defined')",
            "",
            "    def _init_cache(self, env):",
            "        cache = self._conf_get('cache')",
            "        memcache_servers = self._conf_get('memcached_servers')",
            "",
            "        if cache and env.get(cache, None) is not None:",
            "            # use the cache from the upstream filter",
            "            self.LOG.info('Using %s memcache for caching token', cache)",
            "            self._cache = env.get(cache)",
            "        else:",
            "            # use Keystone memcache",
            "            self._cache = memorycache.get_client(memcache_servers)",
            "        self._cache_initialized = True",
            "",
            "    def _conf_get(self, name):",
            "        # try config from paste-deploy first",
            "        if name in self.conf:",
            "            return self.conf[name]",
            "        else:",
            "            return CONF.keystone_authtoken[name]",
            "",
            "    def _choose_api_version(self):",
            "        \"\"\"Determine the api version that we should use.\"\"\"",
            "",
            "        # If the configuration specifies an auth_version we will just",
            "        # assume that is correct and use it.  We could, of course, check",
            "        # that this version is supported by the server, but in case",
            "        # there are some problems in the field, we want as little code",
            "        # as possible in the way of letting auth_token talk to the",
            "        # server.",
            "        if self._conf_get('auth_version'):",
            "            version_to_use = self._conf_get('auth_version')",
            "            self.LOG.info('Auth Token proceeding with requested %s apis',",
            "                          version_to_use)",
            "        else:",
            "            version_to_use = None",
            "            versions_supported_by_server = self._get_supported_versions()",
            "            if versions_supported_by_server:",
            "                for version in LIST_OF_VERSIONS_TO_ATTEMPT:",
            "                    if version in versions_supported_by_server:",
            "                        version_to_use = version",
            "                        break",
            "            if version_to_use:",
            "                self.LOG.info('Auth Token confirmed use of %s apis',",
            "                              version_to_use)",
            "            else:",
            "                self.LOG.error(",
            "                    'Attempted versions [%s] not in list supported by '",
            "                    'server [%s]',",
            "                    ', '.join(LIST_OF_VERSIONS_TO_ATTEMPT),",
            "                    ', '.join(versions_supported_by_server))",
            "                raise ServiceError('No compatible apis supported by server')",
            "        return version_to_use",
            "",
            "    def _get_supported_versions(self):",
            "        versions = []",
            "        response, data = self._json_request('GET', '/')",
            "        if response.status_code == 501:",
            "            self.LOG.warning(\"Old keystone installation found...assuming v2.0\")",
            "            versions.append(\"v2.0\")",
            "        elif response.status_code != 300:",
            "            self.LOG.error('Unable to get version info from keystone: %s' %",
            "                           response.status_code)",
            "            raise ServiceError('Unable to get version info from keystone')",
            "        else:",
            "            try:",
            "                for version in data['versions']['values']:",
            "                    versions.append(version['id'])",
            "            except KeyError:",
            "                self.LOG.error(",
            "                    'Invalid version response format from server', data)",
            "                raise ServiceError('Unable to parse version response '",
            "                                   'from keystone')",
            "",
            "        self.LOG.debug('Server reports support for api versions: %s',",
            "                       ', '.join(versions))",
            "        return versions",
            "",
            "    def __call__(self, env, start_response):",
            "        \"\"\"Handle incoming request.",
            "",
            "        Authenticate send downstream on success. Reject request if",
            "        we can't authenticate.",
            "",
            "        \"\"\"",
            "        self.LOG.debug('Authenticating user token')",
            "",
            "        # initialize memcache if we haven't done so",
            "        if not self._cache_initialized:",
            "            self._init_cache(env)",
            "",
            "        try:",
            "            self._remove_auth_headers(env)",
            "            user_token = self._get_user_token_from_header(env)",
            "            token_info = self._validate_user_token(user_token)",
            "            env['keystone.token_info'] = token_info",
            "            user_headers = self._build_user_headers(token_info)",
            "            self._add_headers(env, user_headers)",
            "            return self.app(env, start_response)",
            "",
            "        except InvalidUserToken:",
            "            if self.delay_auth_decision:",
            "                self.LOG.info(",
            "                    'Invalid user token - deferring reject downstream')",
            "                self._add_headers(env, {'X-Identity-Status': 'Invalid'})",
            "                return self.app(env, start_response)",
            "            else:",
            "                self.LOG.info('Invalid user token - rejecting request')",
            "                return self._reject_request(env, start_response)",
            "",
            "        except ServiceError as e:",
            "            self.LOG.critical('Unable to obtain admin token: %s' % e)",
            "            resp = MiniResp('Service unavailable', env)",
            "            start_response('503 Service Unavailable', resp.headers)",
            "            return resp.body",
            "",
            "    def _remove_auth_headers(self, env):",
            "        \"\"\"Remove headers so a user can't fake authentication.",
            "",
            "        :param env: wsgi request environment",
            "",
            "        \"\"\"",
            "        auth_headers = (",
            "            'X-Identity-Status',",
            "            'X-Domain-Id',",
            "            'X-Domain-Name',",
            "            'X-Project-Id',",
            "            'X-Project-Name',",
            "            'X-Project-Domain-Id',",
            "            'X-Project-Domain-Name',",
            "            'X-User-Id',",
            "            'X-User-Name',",
            "            'X-User-Domain-Id',",
            "            'X-User-Domain-Name',",
            "            'X-Roles',",
            "            'X-Service-Catalog',",
            "            # Deprecated",
            "            'X-User',",
            "            'X-Tenant-Id',",
            "            'X-Tenant-Name',",
            "            'X-Tenant',",
            "            'X-Role',",
            "        )",
            "        self.LOG.debug('Removing headers from request environment: %s' %",
            "                       ','.join(auth_headers))",
            "        self._remove_headers(env, auth_headers)",
            "",
            "    def _get_user_token_from_header(self, env):",
            "        \"\"\"Get token id from request.",
            "",
            "        :param env: wsgi request environment",
            "        :return token id",
            "        :raises InvalidUserToken if no token is provided in request",
            "",
            "        \"\"\"",
            "        token = self._get_header(env, 'X-Auth-Token',",
            "                                 self._get_header(env, 'X-Storage-Token'))",
            "        if token:",
            "            return token",
            "        else:",
            "            if not self.delay_auth_decision:",
            "                self.LOG.warn(\"Unable to find authentication token\"",
            "                              \" in headers\")",
            "                self.LOG.debug(\"Headers: %s\", env)",
            "            raise InvalidUserToken('Unable to find token in headers')",
            "",
            "    def _reject_request(self, env, start_response):",
            "        \"\"\"Redirect client to auth server.",
            "",
            "        :param env: wsgi request environment",
            "        :param start_response: wsgi response callback",
            "        :returns HTTPUnauthorized http response",
            "",
            "        \"\"\"",
            "        headers = [('WWW-Authenticate', 'Keystone uri=\\'%s\\'' % self.auth_uri)]",
            "        resp = MiniResp('Authentication required', env, headers)",
            "        start_response('401 Unauthorized', resp.headers)",
            "        return resp.body",
            "",
            "    def get_admin_token(self):",
            "        \"\"\"Return admin token, possibly fetching a new one.",
            "",
            "        if self.admin_token_expiry is set from fetching an admin token, check",
            "        it for expiration, and request a new token is the existing token",
            "        is about to expire.",
            "",
            "        :return admin token id",
            "        :raise ServiceError when unable to retrieve token from keystone",
            "",
            "        \"\"\"",
            "        if self.admin_token_expiry:",
            "            if will_expire_soon(self.admin_token_expiry):",
            "                self.admin_token = None",
            "",
            "        if not self.admin_token:",
            "            (self.admin_token,",
            "             self.admin_token_expiry) = self._request_admin_token()",
            "",
            "        return self.admin_token",
            "",
            "    def _http_request(self, method, path, **kwargs):",
            "        \"\"\"HTTP request helper used to make unspecified content type requests.",
            "",
            "        :param method: http method",
            "        :param path: relative request url",
            "        :return (http response object, response body)",
            "        :raise ServerError when unable to communicate with keystone",
            "",
            "        \"\"\"",
            "        url = \"%s/%s\" % (self.request_uri, path.lstrip('/'))",
            "",
            "        kwargs.setdefault('timeout', self.http_connect_timeout)",
            "        if self.cert_file and self.key_file:",
            "            kwargs['cert'] = (self.cert_file, self.key_file)",
            "        elif self.cert_file or self.key_file:",
            "            self.LOG.warn('Cannot use only a cert or key file. '",
            "                          'Please provide both. Ignoring.')",
            "",
            "        kwargs['verify'] = self.ssl_ca_file or True",
            "        if self.ssl_insecure:",
            "            kwargs['verify'] = False",
            "",
            "        RETRIES = self.http_request_max_retries",
            "        retry = 0",
            "        while True:",
            "            try:",
            "                response = requests.request(method, url, **kwargs)",
            "                break",
            "            except Exception as e:",
            "                if retry >= RETRIES:",
            "                    self.LOG.error('HTTP connection exception: %s', e)",
            "                    raise NetworkError('Unable to communicate with keystone')",
            "                # NOTE(vish): sleep 0.5, 1, 2",
            "                self.LOG.warn('Retrying on HTTP connection exception: %s' % e)",
            "                time.sleep(2.0 ** retry / 2)",
            "                retry += 1",
            "",
            "        return response",
            "",
            "    def _json_request(self, method, path, body=None, additional_headers=None):",
            "        \"\"\"HTTP request helper used to make json requests.",
            "",
            "        :param method: http method",
            "        :param path: relative request url",
            "        :param body: dict to encode to json as request body. Optional.",
            "        :param additional_headers: dict of additional headers to send with",
            "                                   http request. Optional.",
            "        :return (http response object, response body parsed as json)",
            "        :raise ServerError when unable to communicate with keystone",
            "",
            "        \"\"\"",
            "        kwargs = {",
            "            'headers': {",
            "                'Content-type': 'application/json',",
            "                'Accept': 'application/json',",
            "            },",
            "        }",
            "",
            "        if additional_headers:",
            "            kwargs['headers'].update(additional_headers)",
            "",
            "        if body:",
            "            kwargs['data'] = jsonutils.dumps(body)",
            "",
            "        path = self.auth_admin_prefix + path",
            "",
            "        response = self._http_request(method, path, **kwargs)",
            "",
            "        try:",
            "            data = jsonutils.loads(response.text)",
            "        except ValueError:",
            "            self.LOG.debug('Keystone did not return json-encoded body')",
            "            data = {}",
            "",
            "        return response, data",
            "",
            "    def _request_admin_token(self):",
            "        \"\"\"Retrieve new token as admin user from keystone.",
            "",
            "        :return token id upon success",
            "        :raises ServerError when unable to communicate with keystone",
            "",
            "        Irrespective of the auth version we are going to use for the",
            "        user token, for simplicity we always use a v2 admin token to",
            "        validate the user token.",
            "",
            "        \"\"\"",
            "        params = {",
            "            'auth': {",
            "                'passwordCredentials': {",
            "                    'username': self.admin_user,",
            "                    'password': self.admin_password,",
            "                },",
            "                'tenantName': self.admin_tenant_name,",
            "            }",
            "        }",
            "",
            "        response, data = self._json_request('POST',",
            "                                            '/v2.0/tokens',",
            "                                            body=params)",
            "",
            "        try:",
            "            token = data['access']['token']['id']",
            "            expiry = data['access']['token']['expires']",
            "            if not (token and expiry):",
            "                raise AssertionError('invalid token or expire')",
            "            datetime_expiry = timeutils.parse_isotime(expiry)",
            "            return (token, timeutils.normalize_time(datetime_expiry))",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "        except (ValueError):",
            "            self.LOG.warn(",
            "                \"Unable to parse expiration time from token: %s\", data)",
            "            raise ServiceError('invalid json response')",
            "",
            "    def _validate_user_token(self, user_token, retry=True):",
            "        \"\"\"Authenticate user using PKI",
            "",
            "        :param user_token: user's token id",
            "        :param retry: Ignored, as it is not longer relevant",
            "        :return uncrypted body of the token if the token is valid",
            "        :raise InvalidUserToken if token is rejected",
            "        :no longer raises ServiceError since it no longer makes RPC",
            "",
            "        \"\"\"",
            "        token_id = None",
            "",
            "        try:",
            "            token_id = cms.cms_hash_token(user_token)",
            "            cached = self._cache_get(token_id)",
            "            if cached:",
            "                return cached",
            "            if cms.is_ans1_token(user_token):",
            "                verified = self.verify_signed_token(user_token)",
            "                data = jsonutils.loads(verified)",
            "            else:",
            "                data = self.verify_uuid_token(user_token, retry)",
            "            expires = self._confirm_token_not_expired(data)",
            "            self._cache_put(token_id, data, expires)",
            "            return data",
            "        except NetworkError:",
            "            self.LOG.debug('Token validation failure.', exc_info=True)",
            "            self.LOG.warn(\"Authorization failed for token %s\", token_id)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        except Exception:",
            "            self.LOG.debug('Token validation failure.', exc_info=True)",
            "            if token_id:",
            "                self._cache_store_invalid(token_id)",
            "            self.LOG.warn(\"Authorization failed for token %s\", token_id)",
            "            raise InvalidUserToken('Token authorization failed')",
            "",
            "    def _token_is_v2(self, token_info):",
            "        return ('access' in token_info)",
            "",
            "    def _token_is_v3(self, token_info):",
            "        return ('token' in token_info)",
            "",
            "    def _build_user_headers(self, token_info):",
            "        \"\"\"Convert token object into headers.",
            "",
            "        Build headers that represent authenticated user - see main",
            "        doc info at start of file for details of headers to be defined.",
            "",
            "        :param token_info: token object returned by keystone on authentication",
            "        :raise InvalidUserToken when unable to parse token object",
            "",
            "        \"\"\"",
            "        def get_tenant_info():",
            "            \"\"\"Returns a (tenant_id, tenant_name) tuple from context.\"\"\"",
            "            def essex():",
            "                \"\"\"Essex puts the tenant ID and name on the token.\"\"\"",
            "                return (token['tenant']['id'], token['tenant']['name'])",
            "",
            "            def pre_diablo():",
            "                \"\"\"Pre-diablo, Keystone only provided tenantId.\"\"\"",
            "                return (token['tenantId'], token['tenantId'])",
            "",
            "            def default_tenant():",
            "                \"\"\"Pre-grizzly, assume the user's default tenant.\"\"\"",
            "                return (user['tenantId'], user['tenantName'])",
            "",
            "            for method in [essex, pre_diablo, default_tenant]:",
            "                try:",
            "                    return method()",
            "                except KeyError:",
            "                    pass",
            "",
            "            raise InvalidUserToken('Unable to determine tenancy.')",
            "",
            "        # For clarity. set all those attributes that are optional in",
            "        # either a v2 or v3 token to None first",
            "        domain_id = None",
            "        domain_name = None",
            "        project_id = None",
            "        project_name = None",
            "        user_domain_id = None",
            "        user_domain_name = None",
            "        project_domain_id = None",
            "        project_domain_name = None",
            "",
            "        if self._token_is_v2(token_info):",
            "            user = token_info['access']['user']",
            "            token = token_info['access']['token']",
            "            roles = ','.join([role['name'] for role in user.get('roles', [])])",
            "            catalog_root = token_info['access']",
            "            catalog_key = 'serviceCatalog'",
            "            project_id, project_name = get_tenant_info()",
            "        else:",
            "            #v3 token",
            "            token = token_info['token']",
            "            user = token['user']",
            "            user_domain_id = user['domain']['id']",
            "            user_domain_name = user['domain']['name']",
            "            roles = (','.join([role['name']",
            "                     for role in token.get('roles', [])]))",
            "            catalog_root = token",
            "            catalog_key = 'catalog'",
            "            # For v3, the server will put in the default project if there is",
            "            # one, so no need for us to add it here (like we do for a v2 token)",
            "            if 'domain' in token:",
            "                domain_id = token['domain']['id']",
            "                domain_name = token['domain']['name']",
            "            elif 'project' in token:",
            "                project_id = token['project']['id']",
            "                project_name = token['project']['name']",
            "                project_domain_id = token['project']['domain']['id']",
            "                project_domain_name = token['project']['domain']['name']",
            "",
            "        user_id = user['id']",
            "        user_name = user['name']",
            "",
            "        rval = {",
            "            'X-Identity-Status': 'Confirmed',",
            "            'X-Domain-Id': domain_id,",
            "            'X-Domain-Name': domain_name,",
            "            'X-Project-Id': project_id,",
            "            'X-Project-Name': project_name,",
            "            'X-Project-Domain-Id': project_domain_id,",
            "            'X-Project-Domain-Name': project_domain_name,",
            "            'X-User-Id': user_id,",
            "            'X-User-Name': user_name,",
            "            'X-User-Domain-Id': user_domain_id,",
            "            'X-User-Domain-Name': user_domain_name,",
            "            'X-Roles': roles,",
            "            # Deprecated",
            "            'X-User': user_name,",
            "            'X-Tenant-Id': project_id,",
            "            'X-Tenant-Name': project_name,",
            "            'X-Tenant': project_name,",
            "            'X-Role': roles,",
            "        }",
            "",
            "        try:",
            "            catalog = catalog_root[catalog_key]",
            "            rval['X-Service-Catalog'] = jsonutils.dumps(catalog)",
            "        except KeyError:",
            "            pass",
            "",
            "        return rval",
            "",
            "    def _header_to_env_var(self, key):",
            "        \"\"\"Convert header to wsgi env variable.",
            "",
            "        :param key: http header name (ex. 'X-Auth-Token')",
            "        :return wsgi env variable name (ex. 'HTTP_X_AUTH_TOKEN')",
            "",
            "        \"\"\"",
            "        return 'HTTP_%s' % key.replace('-', '_').upper()",
            "",
            "    def _add_headers(self, env, headers):",
            "        \"\"\"Add http headers to environment.\"\"\"",
            "        for (k, v) in six.iteritems(headers):",
            "            env_key = self._header_to_env_var(k)",
            "            env[env_key] = v",
            "",
            "    def _remove_headers(self, env, keys):",
            "        \"\"\"Remove http headers from environment.\"\"\"",
            "        for k in keys:",
            "            env_key = self._header_to_env_var(k)",
            "            try:",
            "                del env[env_key]",
            "            except KeyError:",
            "                pass",
            "",
            "    def _get_header(self, env, key, default=None):",
            "        \"\"\"Get http header from environment.\"\"\"",
            "        env_key = self._header_to_env_var(key)",
            "        return env.get(env_key, default)",
            "",
            "    def _cache_get(self, token_id, ignore_expires=False):",
            "        \"\"\"Return token information from cache.",
            "",
            "        If token is invalid raise InvalidUserToken",
            "        return token only if fresh (not expired).",
            "        \"\"\"",
            "",
            "        if self._cache and token_id:",
            "            if self._memcache_security_strategy is None:",
            "                key = CACHE_KEY_TEMPLATE % token_id",
            "                serialized = self._cache.get(key)",
            "            else:",
            "                keys = memcache_crypt.derive_keys(",
            "                    token_id,",
            "                    self._memcache_secret_key,",
            "                    self._memcache_security_strategy)",
            "                cache_key = CACHE_KEY_TEMPLATE % (",
            "                    memcache_crypt.get_cache_key(keys))",
            "                raw_cached = self._cache.get(cache_key)",
            "                try:",
            "                    # unprotect_data will return None if raw_cached is None",
            "                    serialized = memcache_crypt.unprotect_data(keys,",
            "                                                               raw_cached)",
            "                except Exception:",
            "                    msg = 'Failed to decrypt/verify cache data'",
            "                    self.LOG.exception(msg)",
            "                    # this should have the same effect as data not",
            "                    # found in cache",
            "                    serialized = None",
            "",
            "            if serialized is None:",
            "                return None",
            "",
            "            # Note that 'invalid' and (data, expires) are the only",
            "            # valid types of serialized cache entries, so there is not",
            "            # a collision with jsonutils.loads(serialized) == None.",
            "            cached = jsonutils.loads(serialized)",
            "            if cached == 'invalid':",
            "                self.LOG.debug('Cached Token %s is marked unauthorized',",
            "                               token_id)",
            "                raise InvalidUserToken('Token authorization failed')",
            "",
            "            data, expires = cached",
            "            if ignore_expires or time.time() < float(expires):",
            "                self.LOG.debug('Returning cached token %s', token_id)",
            "                return data",
            "            else:",
            "                self.LOG.debug('Cached Token %s seems expired', token_id)",
            "",
            "    def _cache_store(self, token_id, data):",
            "        \"\"\"Store value into memcache.",
            "",
            "        data may be the string 'invalid' or a tuple like (data, expires)",
            "",
            "        \"\"\"",
            "        serialized_data = jsonutils.dumps(data)",
            "        if self._memcache_security_strategy is None:",
            "            cache_key = CACHE_KEY_TEMPLATE % token_id",
            "            data_to_store = serialized_data",
            "        else:",
            "            keys = memcache_crypt.derive_keys(",
            "                token_id,",
            "                self._memcache_secret_key,",
            "                self._memcache_security_strategy)",
            "            cache_key = CACHE_KEY_TEMPLATE % memcache_crypt.get_cache_key(keys)",
            "            data_to_store = memcache_crypt.protect_data(keys, serialized_data)",
            "",
            "        # Historically the swift cache conection used the argument",
            "        # timeout= for the cache timeout, but this has been unified",
            "        # with the official python memcache client with time= since",
            "        # grizzly, we still need to handle folsom for a while until",
            "        # this could get removed.",
            "        try:",
            "            self._cache.set(cache_key,",
            "                            data_to_store,",
            "                            time=self.token_cache_time)",
            "        except(TypeError):",
            "            self._cache.set(cache_key,",
            "                            data_to_store,",
            "                            timeout=self.token_cache_time)",
            "",
            "    def _confirm_token_not_expired(self, data):",
            "        if not data:",
            "            raise InvalidUserToken('Token authorization failed')",
            "        if self._token_is_v2(data):",
            "            timestamp = data['access']['token']['expires']",
            "        elif self._token_is_v3(data):",
            "            timestamp = data['token']['expires_at']",
            "        else:",
            "            raise InvalidUserToken('Token authorization failed')",
            "        expires = timeutils.parse_isotime(timestamp).strftime('%s')",
            "        if time.time() >= float(expires):",
            "            self.LOG.debug('Token expired a %s', timestamp)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        return expires",
            "",
            "    def _cache_put(self, token_id, data, expires):",
            "        \"\"\"Put token data into the cache.",
            "",
            "        Stores the parsed expire date in cache allowing",
            "        quick check of token freshness on retrieval.",
            "",
            "        \"\"\"",
            "        if self._cache:",
            "                self.LOG.debug('Storing %s token in memcache', token_id)",
            "                self._cache_store(token_id, (data, expires))",
            "",
            "    def _cache_store_invalid(self, token_id):",
            "        \"\"\"Store invalid token in cache.\"\"\"",
            "        if self._cache:",
            "            self.LOG.debug(",
            "                'Marking token %s as unauthorized in memcache', token_id)",
            "            self._cache_store(token_id, 'invalid')",
            "",
            "    def cert_file_missing(self, proc_output, file_name):",
            "        return (file_name in proc_output and not os.path.exists(file_name))",
            "",
            "    def verify_uuid_token(self, user_token, retry=True):",
            "        \"\"\"Authenticate user token with keystone.",
            "",
            "        :param user_token: user's token id",
            "        :param retry: flag that forces the middleware to retry",
            "                      user authentication when an indeterminate",
            "                      response is received. Optional.",
            "        :return token object received from keystone on success",
            "        :raise InvalidUserToken if token is rejected",
            "        :raise ServiceError if unable to authenticate token",
            "",
            "        \"\"\"",
            "        # Determine the highest api version we can use.",
            "        if not self.auth_version:",
            "            self.auth_version = self._choose_api_version()",
            "",
            "        if self.auth_version == 'v3.0':",
            "            headers = {'X-Auth-Token': self.get_admin_token(),",
            "                       'X-Subject-Token': safe_quote(user_token)}",
            "            response, data = self._json_request(",
            "                'GET',",
            "                '/v3/auth/tokens',",
            "                additional_headers=headers)",
            "        else:",
            "            headers = {'X-Auth-Token': self.get_admin_token()}",
            "            response, data = self._json_request(",
            "                'GET',",
            "                '/v2.0/tokens/%s' % safe_quote(user_token),",
            "                additional_headers=headers)",
            "",
            "        if response.status_code == 200:",
            "            return data",
            "        if response.status_code == 404:",
            "            self.LOG.warn(\"Authorization failed for token %s\", user_token)",
            "            raise InvalidUserToken('Token authorization failed')",
            "        if response.status_code == 401:",
            "            self.LOG.info(",
            "                'Keystone rejected admin token %s, resetting', headers)",
            "            self.admin_token = None",
            "        else:",
            "            self.LOG.error('Bad response code while validating token: %s' %",
            "                           response.status_code)",
            "        if retry:",
            "            self.LOG.info('Retrying validation')",
            "            return self._validate_user_token(user_token, False)",
            "        else:",
            "            self.LOG.warn(\"Invalid user token: %s. Keystone response: %s.\",",
            "                          user_token, data)",
            "",
            "            raise InvalidUserToken()",
            "",
            "    def is_signed_token_revoked(self, signed_text):",
            "        \"\"\"Indicate whether the token appears in the revocation list.\"\"\"",
            "        revocation_list = self.token_revocation_list",
            "        revoked_tokens = revocation_list.get('revoked', [])",
            "        if not revoked_tokens:",
            "            return",
            "        revoked_ids = (x['id'] for x in revoked_tokens)",
            "        token_id = utils.hash_signed_token(signed_text)",
            "        for revoked_id in revoked_ids:",
            "            if token_id == revoked_id:",
            "                self.LOG.debug('Token %s is marked as having been revoked',",
            "                               token_id)",
            "                return True",
            "        return False",
            "",
            "    def cms_verify(self, data):",
            "        \"\"\"Verifies the signature of the provided data's IAW CMS syntax.",
            "",
            "        If either of the certificate files are missing, fetch them and",
            "        retry.",
            "        \"\"\"",
            "        while True:",
            "            try:",
            "                output = cms.cms_verify(data, self.signing_cert_file_name,",
            "                                        self.signing_ca_file_name)",
            "            except cms.subprocess.CalledProcessError as err:",
            "                if self.cert_file_missing(err.output,",
            "                                          self.signing_cert_file_name):",
            "                    self.fetch_signing_cert()",
            "                    continue",
            "                if self.cert_file_missing(err.output,",
            "                                          self.signing_ca_file_name):",
            "                    self.fetch_ca_cert()",
            "                    continue",
            "                self.LOG.warning('Verify error: %s' % err)",
            "                raise err",
            "            return output",
            "",
            "    def verify_signed_token(self, signed_text):",
            "        \"\"\"Check that the token is unrevoked and has a valid signature.\"\"\"",
            "        if self.is_signed_token_revoked(signed_text):",
            "            raise InvalidUserToken('Token has been revoked')",
            "",
            "        formatted = cms.token_to_cms(signed_text)",
            "        return self.cms_verify(formatted)",
            "",
            "    def verify_signing_dir(self):",
            "        if os.path.exists(self.signing_dirname):",
            "            if not os.access(self.signing_dirname, os.W_OK):",
            "                raise ConfigurationError(",
            "                    'unable to access signing_dir %s' % self.signing_dirname)",
            "            if os.stat(self.signing_dirname).st_uid != os.getuid():",
            "                self.LOG.warning(",
            "                    'signing_dir is not owned by %s' % os.getuid())",
            "            current_mode = stat.S_IMODE(os.stat(self.signing_dirname).st_mode)",
            "            if current_mode != stat.S_IRWXU:",
            "                self.LOG.warning(",
            "                    'signing_dir mode is %s instead of %s' %",
            "                    (oct(current_mode), oct(stat.S_IRWXU)))",
            "        else:",
            "            os.makedirs(self.signing_dirname, stat.S_IRWXU)",
            "",
            "    @property",
            "    def token_revocation_list_fetched_time(self):",
            "        if not self._token_revocation_list_fetched_time:",
            "            # If the fetched list has been written to disk, use its",
            "            # modification time.",
            "            if os.path.exists(self.revoked_file_name):",
            "                mtime = os.path.getmtime(self.revoked_file_name)",
            "                fetched_time = datetime.datetime.fromtimestamp(mtime)",
            "            # Otherwise the list will need to be fetched.",
            "            else:",
            "                fetched_time = datetime.datetime.min",
            "            self._token_revocation_list_fetched_time = fetched_time",
            "        return self._token_revocation_list_fetched_time",
            "",
            "    @token_revocation_list_fetched_time.setter",
            "    def token_revocation_list_fetched_time(self, value):",
            "        self._token_revocation_list_fetched_time = value",
            "",
            "    @property",
            "    def token_revocation_list(self):",
            "        timeout = (self.token_revocation_list_fetched_time +",
            "                   self.token_revocation_list_cache_timeout)",
            "        list_is_current = timeutils.utcnow() < timeout",
            "",
            "        if list_is_current:",
            "            # Load the list from disk if required",
            "            if not self._token_revocation_list:",
            "                with open(self.revoked_file_name, 'r') as f:",
            "                    self._token_revocation_list = jsonutils.loads(f.read())",
            "        else:",
            "            self.token_revocation_list = self.fetch_revocation_list()",
            "        return self._token_revocation_list",
            "",
            "    @token_revocation_list.setter",
            "    def token_revocation_list(self, value):",
            "        \"\"\"Save a revocation list to memory and to disk.",
            "",
            "        :param value: A json-encoded revocation list",
            "",
            "        \"\"\"",
            "        self._token_revocation_list = jsonutils.loads(value)",
            "        self.token_revocation_list_fetched_time = timeutils.utcnow()",
            "        with open(self.revoked_file_name, 'w') as f:",
            "            f.write(value)",
            "",
            "    def fetch_revocation_list(self, retry=True):",
            "        headers = {'X-Auth-Token': self.get_admin_token()}",
            "        response, data = self._json_request('GET', '/v2.0/tokens/revoked',",
            "                                            additional_headers=headers)",
            "        if response.status_code == 401:",
            "            if retry:",
            "                self.LOG.info(",
            "                    'Keystone rejected admin token %s, resetting admin token',",
            "                    headers)",
            "                self.admin_token = None",
            "                return self.fetch_revocation_list(retry=False)",
            "        if response.status_code != 200:",
            "            raise ServiceError('Unable to fetch token revocation list.')",
            "        if 'signed' not in data:",
            "            raise ServiceError('Revocation list improperly formatted.')",
            "        return self.cms_verify(data['signed'])",
            "",
            "    def fetch_signing_cert(self):",
            "        path = self.auth_admin_prefix.rstrip('/')",
            "        path += '/v2.0/certificates/signing'",
            "        response = self._http_request('GET', path)",
            "",
            "        def write_cert_file(data):",
            "            with open(self.signing_cert_file_name, 'w') as certfile:",
            "                certfile.write(data)",
            "",
            "        try:",
            "            #todo check response",
            "            try:",
            "                write_cert_file(response.text)",
            "            except IOError:",
            "                self.verify_signing_dir()",
            "                write_cert_file(response.text)",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", response.text)",
            "            raise ServiceError('invalid json response')",
            "",
            "    def fetch_ca_cert(self):",
            "        path = self.auth_admin_prefix.rstrip('/') + '/v2.0/certificates/ca'",
            "        response = self._http_request('GET', path)",
            "",
            "        try:",
            "            #todo check response",
            "            with open(self.signing_ca_file_name, 'w') as certfile:",
            "                certfile.write(response.text)",
            "        except (AssertionError, KeyError):",
            "            self.LOG.warn(",
            "                \"Unexpected response from keystone service: %s\", response.text)",
            "            raise ServiceError('invalid json response')",
            "",
            "",
            "def filter_factory(global_conf, **local_conf):",
            "    \"\"\"Returns a WSGI filter app for use with paste.deploy.\"\"\"",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "",
            "    def auth_filter(app):",
            "        return AuthProtocol(app, conf)",
            "    return auth_filter",
            "",
            "",
            "def app_factory(global_conf, **local_conf):",
            "    conf = global_conf.copy()",
            "    conf.update(local_conf)",
            "    return AuthProtocol(None, conf)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "148": [],
            "357": [
                "AuthProtocol",
                "__init__"
            ],
            "358": [
                "AuthProtocol",
                "__init__"
            ],
            "359": [
                "AuthProtocol",
                "__init__"
            ],
            "360": [
                "AuthProtocol",
                "__init__"
            ],
            "361": [
                "AuthProtocol",
                "__init__"
            ],
            "362": [
                "AuthProtocol",
                "__init__"
            ],
            "363": [
                "AuthProtocol",
                "__init__"
            ],
            "364": [
                "AuthProtocol",
                "__init__"
            ],
            "365": [
                "AuthProtocol",
                "__init__"
            ],
            "366": [
                "AuthProtocol",
                "__init__"
            ],
            "367": [
                "AuthProtocol",
                "__init__"
            ],
            "368": [
                "AuthProtocol",
                "__init__"
            ],
            "369": [
                "AuthProtocol",
                "__init__"
            ],
            "370": [
                "AuthProtocol",
                "__init__"
            ],
            "371": [
                "AuthProtocol",
                "__init__"
            ],
            "379": [
                "AuthProtocol",
                "__init__"
            ],
            "380": [
                "AuthProtocol",
                "__init__"
            ],
            "381": [
                "AuthProtocol",
                "__init__"
            ],
            "382": [
                "AuthProtocol",
                "__init__"
            ],
            "383": [
                "AuthProtocol",
                "__init__"
            ],
            "384": [
                "AuthProtocol",
                "__init__"
            ],
            "387": [
                "AuthProtocol",
                "__init__"
            ],
            "388": [
                "AuthProtocol",
                "__init__"
            ],
            "389": [
                "AuthProtocol",
                "__init__"
            ],
            "406": [
                "AuthProtocol",
                "__init__"
            ],
            "508": [
                "AuthProtocol",
                "_get_supported_versions"
            ],
            "511": [
                "AuthProtocol",
                "_get_supported_versions"
            ],
            "513": [
                "AuthProtocol",
                "_get_supported_versions"
            ],
            "651": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "652": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "653": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "654": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "655": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "656": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "657": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "658": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "659": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "660": [
                "AuthProtocol",
                "_get_http_connection"
            ],
            "661": [
                "AuthProtocol"
            ],
            "671": [
                "AuthProtocol",
                "_http_request"
            ],
            "677": [
                "AuthProtocol",
                "_http_request"
            ],
            "678": [
                "AuthProtocol",
                "_http_request"
            ],
            "679": [
                "AuthProtocol",
                "_http_request"
            ],
            "682": [
                "AuthProtocol",
                "_http_request"
            ],
            "683": [
                "AuthProtocol",
                "_http_request"
            ],
            "689": [
                "AuthProtocol",
                "_http_request"
            ],
            "690": [
                "AuthProtocol",
                "_http_request"
            ],
            "692": [
                "AuthProtocol",
                "_http_request"
            ],
            "717": [
                "AuthProtocol",
                "_json_request"
            ],
            "721": [
                "AuthProtocol",
                "_json_request"
            ],
            "724": [
                "AuthProtocol",
                "_json_request"
            ],
            "1093": [
                "AuthProtocol",
                "verify_uuid_token"
            ],
            "1095": [
                "AuthProtocol",
                "verify_uuid_token"
            ],
            "1098": [
                "AuthProtocol",
                "verify_uuid_token"
            ],
            "1104": [
                "AuthProtocol",
                "verify_uuid_token"
            ],
            "1138": [
                "AuthProtocol",
                "cms_verify"
            ],
            "1144": [
                "AuthProtocol",
                "cms_verify"
            ],
            "1224": [
                "AuthProtocol",
                "fetch_revocation_list"
            ],
            "1231": [
                "AuthProtocol",
                "fetch_revocation_list"
            ],
            "1240": [
                "AuthProtocol",
                "fetch_signing_cert"
            ],
            "1249": [
                "AuthProtocol",
                "fetch_signing_cert"
            ],
            "1252": [
                "AuthProtocol",
                "fetch_signing_cert"
            ],
            "1255": [
                "AuthProtocol",
                "fetch_signing_cert"
            ],
            "1260": [
                "AuthProtocol",
                "fetch_ca_cert"
            ],
            "1264": [
                "AuthProtocol",
                "fetch_ca_cert"
            ],
            "1265": [
                "AuthProtocol",
                "fetch_ca_cert"
            ],
            "1268": [
                "AuthProtocol",
                "fetch_ca_cert"
            ]
        },
        "addLocation": []
    }
}