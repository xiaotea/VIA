{
    "keystone/assignment/backends/sql.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "             session = sql.get_session()"
            },
            "1": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         q = session.query(RoleAssignment)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        def _calc_assignment_type():"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            # Figure out the assignment type we're checking for from the args."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            if user_id:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                if tenant_id:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                    return AssignmentType.USER_PROJECT"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                else:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                    return AssignmentType.USER_DOMAIN"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            else:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+                if tenant_id:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                    return AssignmentType.GROUP_PROJECT"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                else:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                    return AssignmentType.GROUP_DOMAIN"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        q = q.filter_by(type=_calc_assignment_type())"
            },
            "18": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         q = q.filter_by(actor_id=user_id or group_id)"
            },
            "19": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         q = q.filter_by(target_id=tenant_id or domain_id)"
            },
            "20": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         refs = q.all()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012-13 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import six",
            "import sqlalchemy",
            "",
            "from keystone import assignment",
            "from keystone import clean",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class AssignmentType:",
            "    USER_PROJECT = 'UserProject'",
            "    GROUP_PROJECT = 'GroupProject'",
            "    USER_DOMAIN = 'UserDomain'",
            "    GROUP_DOMAIN = 'GroupDomain'",
            "",
            "",
            "class Assignment(assignment.Driver):",
            "",
            "    def _get_project(self, session, project_id):",
            "        project_ref = session.query(Project).get(project_id)",
            "        if project_ref is None:",
            "            raise exception.ProjectNotFound(project_id=project_id)",
            "        return project_ref",
            "",
            "    def get_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            return self._get_project(session, tenant_id).to_dict()",
            "",
            "    def get_project_by_name(self, tenant_name, domain_id):",
            "        with sql.transaction() as session:",
            "            query = session.query(Project)",
            "            query = query.filter_by(name=tenant_name)",
            "            query = query.filter_by(domain_id=domain_id)",
            "            try:",
            "                project_ref = query.one()",
            "            except sql.NotFound:",
            "                raise exception.ProjectNotFound(project_id=tenant_name)",
            "            return project_ref.to_dict()",
            "",
            "    def list_user_ids_for_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            self._get_project(session, tenant_id)",
            "            query = session.query(RoleAssignment.actor_id)",
            "            query = query.filter_by(type=AssignmentType.USER_PROJECT)",
            "            query = query.filter_by(target_id=tenant_id)",
            "            query = query.distinct('actor_id', 'target_id')",
            "            assignments = query.all()",
            "            return [assignment.actor_id for assignment in assignments]",
            "",
            "    def _get_metadata(self, user_id=None, tenant_id=None,",
            "                      domain_id=None, group_id=None, session=None):",
            "        # TODO(henry-nash): This method represents the last vestiges of the old",
            "        # metadata concept in this driver.  Although we no longer need it here,",
            "        # since the Manager layer uses the metadata concept across all",
            "        # assignment drivers, we need to remove it from all of them in order to",
            "        # finally remove this method.",
            "",
            "        # We aren't given a session when called by the manager directly.",
            "        if session is None:",
            "            session = sql.get_session()",
            "",
            "        q = session.query(RoleAssignment)",
            "        q = q.filter_by(actor_id=user_id or group_id)",
            "        q = q.filter_by(target_id=tenant_id or domain_id)",
            "        refs = q.all()",
            "        if not refs:",
            "            raise exception.MetadataNotFound()",
            "",
            "        metadata_ref = {}",
            "        metadata_ref['roles'] = []",
            "        for assignment in refs:",
            "            role_ref = {}",
            "            role_ref['id'] = assignment.role_id",
            "            if assignment.inherited and (",
            "                    assignment.type == AssignmentType.USER_DOMAIN or",
            "                    assignment.type == AssignmentType.GROUP_DOMAIN):",
            "                role_ref['inherited_to'] = 'projects'",
            "            metadata_ref['roles'].append(role_ref)",
            "",
            "        return metadata_ref",
            "",
            "    def create_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "",
            "        def calculate_type(user_id, group_id, project_id, domain_id):",
            "            if user_id and project_id:",
            "                return AssignmentType.USER_PROJECT",
            "            elif user_id and domain_id:",
            "                return AssignmentType.USER_DOMAIN",
            "            elif group_id and project_id:",
            "                return AssignmentType.GROUP_PROJECT",
            "            elif group_id and domain_id:",
            "                return AssignmentType.GROUP_DOMAIN",
            "            else:",
            "                message_data = ', '.join(",
            "                    [user_id, group_id, project_id, domain_id])",
            "                raise exception.Error(message=_(",
            "                    'Unexpected combination of grant attributes - '",
            "                    'User, Group, Project, Domain: %s') % message_data)",
            "",
            "        with sql.transaction() as session:",
            "            self._get_role(session, role_id)",
            "",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            if project_id and inherited_to_projects:",
            "                msg = _('Inherited roles can only be assigned to domains')",
            "                raise exception.Conflict(type='role grant', details=msg)",
            "",
            "        type = calculate_type(user_id, group_id, project_id, domain_id)",
            "        try:",
            "            with sql.transaction() as session:",
            "                session.add(RoleAssignment(",
            "                    type=type,",
            "                    actor_id=user_id or group_id,",
            "                    target_id=project_id or domain_id,",
            "                    role_id=role_id,",
            "                    inherited=inherited_to_projects))",
            "        except sql.DBDuplicateEntry:",
            "            # The v3 grant APIs are silent if the assignment already exists",
            "            pass",
            "",
            "    def list_grants(self, user_id=None, group_id=None,",
            "                    domain_id=None, project_id=None,",
            "                    inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            q = session.query(Role).join(RoleAssignment)",
            "            q = q.filter(RoleAssignment.actor_id == (user_id or group_id))",
            "            q = q.filter(RoleAssignment.target_id == (project_id or domain_id))",
            "            q = q.filter(RoleAssignment.inherited == inherited_to_projects)",
            "            q = q.filter(Role.id == RoleAssignment.role_id)",
            "            return [x.to_dict() for x in q.all()]",
            "",
            "    def _build_grant_filter(self, session, role_id, user_id, group_id,",
            "                            domain_id, project_id, inherited_to_projects):",
            "        q = session.query(RoleAssignment)",
            "        q = q.filter_by(actor_id=user_id or group_id)",
            "        q = q.filter_by(target_id=project_id or domain_id)",
            "        q = q.filter_by(role_id=role_id)",
            "        q = q.filter_by(inherited=inherited_to_projects)",
            "        return q",
            "",
            "    def get_grant(self, role_id, user_id=None, group_id=None,",
            "                  domain_id=None, project_id=None,",
            "                  inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            role_ref = self._get_role(session, role_id)",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            try:",
            "                q = self._build_grant_filter(",
            "                    session, role_id, user_id, group_id, domain_id, project_id,",
            "                    inherited_to_projects)",
            "                q.one()",
            "            except sql.NotFound:",
            "                raise exception.RoleNotFound(role_id=role_id)",
            "",
            "            return role_ref.to_dict()",
            "",
            "    def delete_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            self._get_role(session, role_id)",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            q = self._build_grant_filter(",
            "                session, role_id, user_id, group_id, domain_id, project_id,",
            "                inherited_to_projects)",
            "            if not q.delete(False):",
            "                raise exception.RoleNotFound(role_id=role_id)",
            "",
            "    @sql.truncated",
            "    def list_projects(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Project)",
            "            project_refs = sql.filter_limit_query(Project, query, hints)",
            "            return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "    def list_projects_in_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            self._get_domain(session, domain_id)",
            "            query = session.query(Project)",
            "            project_refs = query.filter_by(domain_id=domain_id)",
            "            return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "    def list_projects_for_user(self, user_id, group_ids, hints):",
            "        # TODO(henry-nash): Now that we have a single assignment table, we",
            "        # should be able to honor the hints list that is provided.",
            "",
            "        def _project_ids_to_dicts(session, ids):",
            "            if not ids:",
            "                return []",
            "            else:",
            "                query = session.query(Project)",
            "                query = query.filter(Project.id.in_(ids))",
            "                project_refs = query.all()",
            "                return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "        with sql.transaction() as session:",
            "            # First get a list of the projects and domains for which the user",
            "            # has any kind of role assigned",
            "",
            "            actor_list = [user_id]",
            "            if group_ids:",
            "                actor_list = actor_list + group_ids",
            "",
            "            query = session.query(RoleAssignment)",
            "            query = query.filter(RoleAssignment.actor_id.in_(actor_list))",
            "            assignments = query.all()",
            "",
            "            project_ids = set()",
            "            for assignment in assignments:",
            "                if (assignment.type == AssignmentType.USER_PROJECT or",
            "                        assignment.type == AssignmentType.GROUP_PROJECT):",
            "                    project_ids.add(assignment.target_id)",
            "",
            "            if not CONF.os_inherit.enabled:",
            "                return _project_ids_to_dicts(session, project_ids)",
            "",
            "            # Inherited roles are enabled, so check to see if this user has any",
            "            # such roles (direct or group) on any domain, in which case we must",
            "            # add in all the projects in that domain.",
            "",
            "            domain_ids = set()",
            "            for assignment in assignments:",
            "                if ((assignment.type == AssignmentType.USER_DOMAIN or",
            "                    assignment.type == AssignmentType.GROUP_DOMAIN) and",
            "                        assignment.inherited):",
            "                    domain_ids.add(assignment.target_id)",
            "",
            "            # Get the projects that are owned by all of these domains and",
            "            # add them in to the project id list",
            "",
            "            if domain_ids:",
            "                query = session.query(Project.id)",
            "                query = query.filter(Project.domain_id.in_(domain_ids))",
            "                for project_ref in query.all():",
            "                    project_ids.add(project_ref.id)",
            "",
            "            return _project_ids_to_dicts(session, project_ids)",
            "",
            "    def get_roles_for_groups(self, group_ids, project_id=None, domain_id=None):",
            "",
            "        if project_id is not None:",
            "            assignment_type = AssignmentType.GROUP_PROJECT",
            "            target_id = project_id",
            "        elif domain_id is not None:",
            "            assignment_type = AssignmentType.GROUP_DOMAIN",
            "            target_id = domain_id",
            "        else:",
            "            raise AttributeError(_(\"Must specify either domain or project\"))",
            "",
            "        sql_constraints = sqlalchemy.and_(",
            "            RoleAssignment.type == assignment_type,",
            "            RoleAssignment.target_id == target_id,",
            "            Role.id == RoleAssignment.role_id,",
            "            RoleAssignment.actor_id.in_(group_ids))",
            "",
            "        session = sql.get_session()",
            "        with session.begin():",
            "            query = session.query(Role).filter(",
            "                sql_constraints).distinct()",
            "        return [role.to_dict() for role in query.all()]",
            "",
            "    def _list_entities_for_groups(self, group_ids, entity):",
            "        if entity == Domain:",
            "            assignment_type = AssignmentType.GROUP_DOMAIN",
            "        else:",
            "            assignment_type = AssignmentType.GROUP_PROJECT",
            "",
            "        group_sql_conditions = sqlalchemy.and_(",
            "            RoleAssignment.type == assignment_type,",
            "            entity.id == RoleAssignment.target_id,",
            "            RoleAssignment.actor_id.in_(group_ids))",
            "",
            "        session = sql.get_session()",
            "        with session.begin():",
            "            query = session.query(entity).filter(",
            "                group_sql_conditions)",
            "        return [x.to_dict() for x in query.all()]",
            "",
            "    def list_projects_for_groups(self, group_ids):",
            "        return self._list_entities_for_groups(group_ids, Project)",
            "",
            "    def list_domains_for_groups(self, group_ids):",
            "        return self._list_entities_for_groups(group_ids, Domain)",
            "",
            "    def add_role_to_user_and_project(self, user_id, tenant_id, role_id):",
            "        with sql.transaction() as session:",
            "            self._get_project(session, tenant_id)",
            "            self._get_role(session, role_id)",
            "",
            "        try:",
            "            with sql.transaction() as session:",
            "                session.add(RoleAssignment(",
            "                    type=AssignmentType.USER_PROJECT,",
            "                    actor_id=user_id, target_id=tenant_id,",
            "                    role_id=role_id, inherited=False))",
            "        except sql.DBDuplicateEntry:",
            "            msg = ('User %s already has role %s in tenant %s'",
            "                   % (user_id, role_id, tenant_id))",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "",
            "    def remove_role_from_user_and_project(self, user_id, tenant_id, role_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=user_id)",
            "            q = q.filter_by(target_id=tenant_id)",
            "            q = q.filter_by(role_id=role_id)",
            "            if q.delete() == 0:",
            "                raise exception.RoleNotFound(message=_(",
            "                    'Cannot remove role that has not been granted, %s') %",
            "                    role_id)",
            "",
            "    def list_role_assignments(self):",
            "",
            "        def denormalize_role(ref):",
            "            assignment = {}",
            "            if ref.type == AssignmentType.USER_PROJECT:",
            "                assignment['user_id'] = ref.actor_id",
            "                assignment['project_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.USER_DOMAIN:",
            "                assignment['user_id'] = ref.actor_id",
            "                assignment['domain_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.GROUP_PROJECT:",
            "                assignment['group_id'] = ref.actor_id",
            "                assignment['project_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.GROUP_DOMAIN:",
            "                assignment['group_id'] = ref.actor_id",
            "                assignment['domain_id'] = ref.target_id",
            "            else:",
            "                raise exception.Error(message=_(",
            "                    'Unexpected assignment type encountered, %s') %",
            "                    ref.type)",
            "            assignment['role_id'] = ref.role_id",
            "            if ref.inherited and (ref.type == AssignmentType.USER_DOMAIN or",
            "                                  ref.type == AssignmentType.GROUP_DOMAIN):",
            "                assignment['inherited_to_projects'] = 'projects'",
            "            return assignment",
            "",
            "        with sql.transaction() as session:",
            "            refs = session.query(RoleAssignment).all()",
            "            return [denormalize_role(ref) for ref in refs]",
            "",
            "    # CRUD",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def create_project(self, tenant_id, tenant):",
            "        tenant['name'] = clean.project_name(tenant['name'])",
            "        with sql.transaction() as session:",
            "            tenant_ref = Project.from_dict(tenant)",
            "            session.add(tenant_ref)",
            "            return tenant_ref.to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def update_project(self, tenant_id, tenant):",
            "        if 'name' in tenant:",
            "            tenant['name'] = clean.project_name(tenant['name'])",
            "",
            "        with sql.transaction() as session:",
            "            tenant_ref = self._get_project(session, tenant_id)",
            "            old_project_dict = tenant_ref.to_dict()",
            "            for k in tenant:",
            "                old_project_dict[k] = tenant[k]",
            "            new_project = Project.from_dict(old_project_dict)",
            "            for attr in Project.attributes:",
            "                if attr != 'id':",
            "                    setattr(tenant_ref, attr, getattr(new_project, attr))",
            "            tenant_ref.extra = new_project.extra",
            "            return tenant_ref.to_dict(include_extra_dict=True)",
            "",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def delete_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            tenant_ref = self._get_project(session, tenant_id)",
            "",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(target_id=tenant_id)",
            "            q.delete(False)",
            "",
            "            session.delete(tenant_ref)",
            "",
            "    # domain crud",
            "",
            "    @sql.handle_conflicts(conflict_type='domain')",
            "    def create_domain(self, domain_id, domain):",
            "        with sql.transaction() as session:",
            "            ref = Domain.from_dict(domain)",
            "            session.add(ref)",
            "        return ref.to_dict()",
            "",
            "    @sql.truncated",
            "    def list_domains(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Domain)",
            "            refs = sql.filter_limit_query(Domain, query, hints)",
            "            return [ref.to_dict() for ref in refs]",
            "",
            "    def _get_domain(self, session, domain_id):",
            "        ref = session.query(Domain).get(domain_id)",
            "        if ref is None:",
            "            raise exception.DomainNotFound(domain_id=domain_id)",
            "        return ref",
            "",
            "    def get_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            return self._get_domain(session, domain_id).to_dict()",
            "",
            "    def get_domain_by_name(self, domain_name):",
            "        with sql.transaction() as session:",
            "            try:",
            "                ref = (session.query(Domain).",
            "                       filter_by(name=domain_name).one())",
            "            except sql.NotFound:",
            "                raise exception.DomainNotFound(domain_id=domain_name)",
            "            return ref.to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='domain')",
            "    def update_domain(self, domain_id, domain):",
            "        with sql.transaction() as session:",
            "            ref = self._get_domain(session, domain_id)",
            "            old_dict = ref.to_dict()",
            "            for k in domain:",
            "                old_dict[k] = domain[k]",
            "            new_domain = Domain.from_dict(old_dict)",
            "            for attr in Domain.attributes:",
            "                if attr != 'id':",
            "                    setattr(ref, attr, getattr(new_domain, attr))",
            "            ref.extra = new_domain.extra",
            "            return ref.to_dict()",
            "",
            "    def delete_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            ref = self._get_domain(session, domain_id)",
            "",
            "            # TODO(henry-nash): Although the controller will ensure deletion of",
            "            # all users & groups within the domain (which will cause all",
            "            # assignments for those users/groups to also be deleted), there",
            "            # could still be assignments on this domain for users/groups in",
            "            # other domains - so we should delete these here (see Bug #1277847)",
            "",
            "            session.delete(ref)",
            "",
            "    # role crud",
            "",
            "    @sql.handle_conflicts(conflict_type='role')",
            "    def create_role(self, role_id, role):",
            "        with sql.transaction() as session:",
            "            ref = Role.from_dict(role)",
            "            session.add(ref)",
            "            return ref.to_dict()",
            "",
            "    @sql.truncated",
            "    def list_roles(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Role)",
            "            refs = sql.filter_limit_query(Role, query, hints)",
            "            return [ref.to_dict() for ref in refs]",
            "",
            "    def _get_role(self, session, role_id):",
            "        ref = session.query(Role).get(role_id)",
            "        if ref is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return ref",
            "",
            "    def get_role(self, role_id):",
            "        with sql.transaction() as session:",
            "            return self._get_role(session, role_id).to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='role')",
            "    def update_role(self, role_id, role):",
            "        with sql.transaction() as session:",
            "            ref = self._get_role(session, role_id)",
            "            old_dict = ref.to_dict()",
            "            for k in role:",
            "                old_dict[k] = role[k]",
            "            new_role = Role.from_dict(old_dict)",
            "            for attr in Role.attributes:",
            "                if attr != 'id':",
            "                    setattr(ref, attr, getattr(new_role, attr))",
            "            ref.extra = new_role.extra",
            "            return ref.to_dict()",
            "",
            "    def delete_role(self, role_id):",
            "        with sql.transaction() as session:",
            "            ref = self._get_role(session, role_id)",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(role_id=role_id)",
            "            q.delete(False)",
            "            session.delete(ref)",
            "",
            "    def delete_user(self, user_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=user_id)",
            "            q.delete(False)",
            "",
            "    def delete_group(self, group_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=group_id)",
            "            q.delete(False)",
            "",
            "",
            "class Domain(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'domain'",
            "    attributes = ['id', 'name', 'enabled']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(64), nullable=False)",
            "    enabled = sql.Column(sql.Boolean, default=True, nullable=False)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    __table_args__ = (sql.UniqueConstraint('name'), {})",
            "",
            "",
            "class Project(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'project'",
            "    attributes = ['id', 'name', 'domain_id', 'description', 'enabled']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(64), nullable=False)",
            "    domain_id = sql.Column(sql.String(64), sql.ForeignKey('domain.id'),",
            "                           nullable=False)",
            "    description = sql.Column(sql.Text())",
            "    enabled = sql.Column(sql.Boolean)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    # Unique constraint across two columns to create the separation",
            "    # rather than just only 'name' being unique",
            "    __table_args__ = (sql.UniqueConstraint('domain_id', 'name'), {})",
            "",
            "",
            "class Role(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'role'",
            "    attributes = ['id', 'name']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(255), unique=True, nullable=False)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    __table_args__ = (sql.UniqueConstraint('name'), {})",
            "",
            "",
            "class RoleAssignment(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'assignment'",
            "    attributes = ['type', 'actor_id', 'target_id', 'role_id', 'inherited']",
            "    # NOTE(henry-nash); Postgres requires a name to be defined for an Enum",
            "    type = sql.Column(",
            "        sql.Enum(AssignmentType.USER_PROJECT, AssignmentType.GROUP_PROJECT,",
            "                 AssignmentType.USER_DOMAIN, AssignmentType.GROUP_DOMAIN,",
            "                 name='type'),",
            "        nullable=False)",
            "    actor_id = sql.Column(sql.String(64), nullable=False)",
            "    target_id = sql.Column(sql.String(64), nullable=False)",
            "    role_id = sql.Column(sql.String(64), sql.ForeignKey('role.id'),",
            "                         nullable=False)",
            "    inherited = sql.Column(sql.Boolean, default=False, nullable=False)",
            "    __table_args__ = (sql.PrimaryKeyConstraint('type', 'actor_id', 'target_id',",
            "                                               'role_id'), {})",
            "",
            "    def to_dict(self):",
            "        \"\"\"Override parent to_dict() method with a simpler implementation.",
            "",
            "        RoleAssignment doesn't have non-indexed 'extra' attributes, so the",
            "        parent implementation is not applicable.",
            "        \"\"\"",
            "        return dict(six.iteritems(self))"
        ],
        "afterPatchFile": [
            "# Copyright 2012-13 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import six",
            "import sqlalchemy",
            "",
            "from keystone import assignment",
            "from keystone import clean",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class AssignmentType:",
            "    USER_PROJECT = 'UserProject'",
            "    GROUP_PROJECT = 'GroupProject'",
            "    USER_DOMAIN = 'UserDomain'",
            "    GROUP_DOMAIN = 'GroupDomain'",
            "",
            "",
            "class Assignment(assignment.Driver):",
            "",
            "    def _get_project(self, session, project_id):",
            "        project_ref = session.query(Project).get(project_id)",
            "        if project_ref is None:",
            "            raise exception.ProjectNotFound(project_id=project_id)",
            "        return project_ref",
            "",
            "    def get_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            return self._get_project(session, tenant_id).to_dict()",
            "",
            "    def get_project_by_name(self, tenant_name, domain_id):",
            "        with sql.transaction() as session:",
            "            query = session.query(Project)",
            "            query = query.filter_by(name=tenant_name)",
            "            query = query.filter_by(domain_id=domain_id)",
            "            try:",
            "                project_ref = query.one()",
            "            except sql.NotFound:",
            "                raise exception.ProjectNotFound(project_id=tenant_name)",
            "            return project_ref.to_dict()",
            "",
            "    def list_user_ids_for_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            self._get_project(session, tenant_id)",
            "            query = session.query(RoleAssignment.actor_id)",
            "            query = query.filter_by(type=AssignmentType.USER_PROJECT)",
            "            query = query.filter_by(target_id=tenant_id)",
            "            query = query.distinct('actor_id', 'target_id')",
            "            assignments = query.all()",
            "            return [assignment.actor_id for assignment in assignments]",
            "",
            "    def _get_metadata(self, user_id=None, tenant_id=None,",
            "                      domain_id=None, group_id=None, session=None):",
            "        # TODO(henry-nash): This method represents the last vestiges of the old",
            "        # metadata concept in this driver.  Although we no longer need it here,",
            "        # since the Manager layer uses the metadata concept across all",
            "        # assignment drivers, we need to remove it from all of them in order to",
            "        # finally remove this method.",
            "",
            "        # We aren't given a session when called by the manager directly.",
            "        if session is None:",
            "            session = sql.get_session()",
            "",
            "        q = session.query(RoleAssignment)",
            "",
            "        def _calc_assignment_type():",
            "            # Figure out the assignment type we're checking for from the args.",
            "            if user_id:",
            "                if tenant_id:",
            "                    return AssignmentType.USER_PROJECT",
            "                else:",
            "                    return AssignmentType.USER_DOMAIN",
            "            else:",
            "                if tenant_id:",
            "                    return AssignmentType.GROUP_PROJECT",
            "                else:",
            "                    return AssignmentType.GROUP_DOMAIN",
            "",
            "        q = q.filter_by(type=_calc_assignment_type())",
            "        q = q.filter_by(actor_id=user_id or group_id)",
            "        q = q.filter_by(target_id=tenant_id or domain_id)",
            "        refs = q.all()",
            "        if not refs:",
            "            raise exception.MetadataNotFound()",
            "",
            "        metadata_ref = {}",
            "        metadata_ref['roles'] = []",
            "        for assignment in refs:",
            "            role_ref = {}",
            "            role_ref['id'] = assignment.role_id",
            "            if assignment.inherited and (",
            "                    assignment.type == AssignmentType.USER_DOMAIN or",
            "                    assignment.type == AssignmentType.GROUP_DOMAIN):",
            "                role_ref['inherited_to'] = 'projects'",
            "            metadata_ref['roles'].append(role_ref)",
            "",
            "        return metadata_ref",
            "",
            "    def create_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "",
            "        def calculate_type(user_id, group_id, project_id, domain_id):",
            "            if user_id and project_id:",
            "                return AssignmentType.USER_PROJECT",
            "            elif user_id and domain_id:",
            "                return AssignmentType.USER_DOMAIN",
            "            elif group_id and project_id:",
            "                return AssignmentType.GROUP_PROJECT",
            "            elif group_id and domain_id:",
            "                return AssignmentType.GROUP_DOMAIN",
            "            else:",
            "                message_data = ', '.join(",
            "                    [user_id, group_id, project_id, domain_id])",
            "                raise exception.Error(message=_(",
            "                    'Unexpected combination of grant attributes - '",
            "                    'User, Group, Project, Domain: %s') % message_data)",
            "",
            "        with sql.transaction() as session:",
            "            self._get_role(session, role_id)",
            "",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            if project_id and inherited_to_projects:",
            "                msg = _('Inherited roles can only be assigned to domains')",
            "                raise exception.Conflict(type='role grant', details=msg)",
            "",
            "        type = calculate_type(user_id, group_id, project_id, domain_id)",
            "        try:",
            "            with sql.transaction() as session:",
            "                session.add(RoleAssignment(",
            "                    type=type,",
            "                    actor_id=user_id or group_id,",
            "                    target_id=project_id or domain_id,",
            "                    role_id=role_id,",
            "                    inherited=inherited_to_projects))",
            "        except sql.DBDuplicateEntry:",
            "            # The v3 grant APIs are silent if the assignment already exists",
            "            pass",
            "",
            "    def list_grants(self, user_id=None, group_id=None,",
            "                    domain_id=None, project_id=None,",
            "                    inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            q = session.query(Role).join(RoleAssignment)",
            "            q = q.filter(RoleAssignment.actor_id == (user_id or group_id))",
            "            q = q.filter(RoleAssignment.target_id == (project_id or domain_id))",
            "            q = q.filter(RoleAssignment.inherited == inherited_to_projects)",
            "            q = q.filter(Role.id == RoleAssignment.role_id)",
            "            return [x.to_dict() for x in q.all()]",
            "",
            "    def _build_grant_filter(self, session, role_id, user_id, group_id,",
            "                            domain_id, project_id, inherited_to_projects):",
            "        q = session.query(RoleAssignment)",
            "        q = q.filter_by(actor_id=user_id or group_id)",
            "        q = q.filter_by(target_id=project_id or domain_id)",
            "        q = q.filter_by(role_id=role_id)",
            "        q = q.filter_by(inherited=inherited_to_projects)",
            "        return q",
            "",
            "    def get_grant(self, role_id, user_id=None, group_id=None,",
            "                  domain_id=None, project_id=None,",
            "                  inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            role_ref = self._get_role(session, role_id)",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            try:",
            "                q = self._build_grant_filter(",
            "                    session, role_id, user_id, group_id, domain_id, project_id,",
            "                    inherited_to_projects)",
            "                q.one()",
            "            except sql.NotFound:",
            "                raise exception.RoleNotFound(role_id=role_id)",
            "",
            "            return role_ref.to_dict()",
            "",
            "    def delete_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        with sql.transaction() as session:",
            "            self._get_role(session, role_id)",
            "            if domain_id:",
            "                self._get_domain(session, domain_id)",
            "            if project_id:",
            "                self._get_project(session, project_id)",
            "",
            "            q = self._build_grant_filter(",
            "                session, role_id, user_id, group_id, domain_id, project_id,",
            "                inherited_to_projects)",
            "            if not q.delete(False):",
            "                raise exception.RoleNotFound(role_id=role_id)",
            "",
            "    @sql.truncated",
            "    def list_projects(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Project)",
            "            project_refs = sql.filter_limit_query(Project, query, hints)",
            "            return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "    def list_projects_in_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            self._get_domain(session, domain_id)",
            "            query = session.query(Project)",
            "            project_refs = query.filter_by(domain_id=domain_id)",
            "            return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "    def list_projects_for_user(self, user_id, group_ids, hints):",
            "        # TODO(henry-nash): Now that we have a single assignment table, we",
            "        # should be able to honor the hints list that is provided.",
            "",
            "        def _project_ids_to_dicts(session, ids):",
            "            if not ids:",
            "                return []",
            "            else:",
            "                query = session.query(Project)",
            "                query = query.filter(Project.id.in_(ids))",
            "                project_refs = query.all()",
            "                return [project_ref.to_dict() for project_ref in project_refs]",
            "",
            "        with sql.transaction() as session:",
            "            # First get a list of the projects and domains for which the user",
            "            # has any kind of role assigned",
            "",
            "            actor_list = [user_id]",
            "            if group_ids:",
            "                actor_list = actor_list + group_ids",
            "",
            "            query = session.query(RoleAssignment)",
            "            query = query.filter(RoleAssignment.actor_id.in_(actor_list))",
            "            assignments = query.all()",
            "",
            "            project_ids = set()",
            "            for assignment in assignments:",
            "                if (assignment.type == AssignmentType.USER_PROJECT or",
            "                        assignment.type == AssignmentType.GROUP_PROJECT):",
            "                    project_ids.add(assignment.target_id)",
            "",
            "            if not CONF.os_inherit.enabled:",
            "                return _project_ids_to_dicts(session, project_ids)",
            "",
            "            # Inherited roles are enabled, so check to see if this user has any",
            "            # such roles (direct or group) on any domain, in which case we must",
            "            # add in all the projects in that domain.",
            "",
            "            domain_ids = set()",
            "            for assignment in assignments:",
            "                if ((assignment.type == AssignmentType.USER_DOMAIN or",
            "                    assignment.type == AssignmentType.GROUP_DOMAIN) and",
            "                        assignment.inherited):",
            "                    domain_ids.add(assignment.target_id)",
            "",
            "            # Get the projects that are owned by all of these domains and",
            "            # add them in to the project id list",
            "",
            "            if domain_ids:",
            "                query = session.query(Project.id)",
            "                query = query.filter(Project.domain_id.in_(domain_ids))",
            "                for project_ref in query.all():",
            "                    project_ids.add(project_ref.id)",
            "",
            "            return _project_ids_to_dicts(session, project_ids)",
            "",
            "    def get_roles_for_groups(self, group_ids, project_id=None, domain_id=None):",
            "",
            "        if project_id is not None:",
            "            assignment_type = AssignmentType.GROUP_PROJECT",
            "            target_id = project_id",
            "        elif domain_id is not None:",
            "            assignment_type = AssignmentType.GROUP_DOMAIN",
            "            target_id = domain_id",
            "        else:",
            "            raise AttributeError(_(\"Must specify either domain or project\"))",
            "",
            "        sql_constraints = sqlalchemy.and_(",
            "            RoleAssignment.type == assignment_type,",
            "            RoleAssignment.target_id == target_id,",
            "            Role.id == RoleAssignment.role_id,",
            "            RoleAssignment.actor_id.in_(group_ids))",
            "",
            "        session = sql.get_session()",
            "        with session.begin():",
            "            query = session.query(Role).filter(",
            "                sql_constraints).distinct()",
            "        return [role.to_dict() for role in query.all()]",
            "",
            "    def _list_entities_for_groups(self, group_ids, entity):",
            "        if entity == Domain:",
            "            assignment_type = AssignmentType.GROUP_DOMAIN",
            "        else:",
            "            assignment_type = AssignmentType.GROUP_PROJECT",
            "",
            "        group_sql_conditions = sqlalchemy.and_(",
            "            RoleAssignment.type == assignment_type,",
            "            entity.id == RoleAssignment.target_id,",
            "            RoleAssignment.actor_id.in_(group_ids))",
            "",
            "        session = sql.get_session()",
            "        with session.begin():",
            "            query = session.query(entity).filter(",
            "                group_sql_conditions)",
            "        return [x.to_dict() for x in query.all()]",
            "",
            "    def list_projects_for_groups(self, group_ids):",
            "        return self._list_entities_for_groups(group_ids, Project)",
            "",
            "    def list_domains_for_groups(self, group_ids):",
            "        return self._list_entities_for_groups(group_ids, Domain)",
            "",
            "    def add_role_to_user_and_project(self, user_id, tenant_id, role_id):",
            "        with sql.transaction() as session:",
            "            self._get_project(session, tenant_id)",
            "            self._get_role(session, role_id)",
            "",
            "        try:",
            "            with sql.transaction() as session:",
            "                session.add(RoleAssignment(",
            "                    type=AssignmentType.USER_PROJECT,",
            "                    actor_id=user_id, target_id=tenant_id,",
            "                    role_id=role_id, inherited=False))",
            "        except sql.DBDuplicateEntry:",
            "            msg = ('User %s already has role %s in tenant %s'",
            "                   % (user_id, role_id, tenant_id))",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "",
            "    def remove_role_from_user_and_project(self, user_id, tenant_id, role_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=user_id)",
            "            q = q.filter_by(target_id=tenant_id)",
            "            q = q.filter_by(role_id=role_id)",
            "            if q.delete() == 0:",
            "                raise exception.RoleNotFound(message=_(",
            "                    'Cannot remove role that has not been granted, %s') %",
            "                    role_id)",
            "",
            "    def list_role_assignments(self):",
            "",
            "        def denormalize_role(ref):",
            "            assignment = {}",
            "            if ref.type == AssignmentType.USER_PROJECT:",
            "                assignment['user_id'] = ref.actor_id",
            "                assignment['project_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.USER_DOMAIN:",
            "                assignment['user_id'] = ref.actor_id",
            "                assignment['domain_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.GROUP_PROJECT:",
            "                assignment['group_id'] = ref.actor_id",
            "                assignment['project_id'] = ref.target_id",
            "            elif ref.type == AssignmentType.GROUP_DOMAIN:",
            "                assignment['group_id'] = ref.actor_id",
            "                assignment['domain_id'] = ref.target_id",
            "            else:",
            "                raise exception.Error(message=_(",
            "                    'Unexpected assignment type encountered, %s') %",
            "                    ref.type)",
            "            assignment['role_id'] = ref.role_id",
            "            if ref.inherited and (ref.type == AssignmentType.USER_DOMAIN or",
            "                                  ref.type == AssignmentType.GROUP_DOMAIN):",
            "                assignment['inherited_to_projects'] = 'projects'",
            "            return assignment",
            "",
            "        with sql.transaction() as session:",
            "            refs = session.query(RoleAssignment).all()",
            "            return [denormalize_role(ref) for ref in refs]",
            "",
            "    # CRUD",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def create_project(self, tenant_id, tenant):",
            "        tenant['name'] = clean.project_name(tenant['name'])",
            "        with sql.transaction() as session:",
            "            tenant_ref = Project.from_dict(tenant)",
            "            session.add(tenant_ref)",
            "            return tenant_ref.to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def update_project(self, tenant_id, tenant):",
            "        if 'name' in tenant:",
            "            tenant['name'] = clean.project_name(tenant['name'])",
            "",
            "        with sql.transaction() as session:",
            "            tenant_ref = self._get_project(session, tenant_id)",
            "            old_project_dict = tenant_ref.to_dict()",
            "            for k in tenant:",
            "                old_project_dict[k] = tenant[k]",
            "            new_project = Project.from_dict(old_project_dict)",
            "            for attr in Project.attributes:",
            "                if attr != 'id':",
            "                    setattr(tenant_ref, attr, getattr(new_project, attr))",
            "            tenant_ref.extra = new_project.extra",
            "            return tenant_ref.to_dict(include_extra_dict=True)",
            "",
            "    @sql.handle_conflicts(conflict_type='project')",
            "    def delete_project(self, tenant_id):",
            "        with sql.transaction() as session:",
            "            tenant_ref = self._get_project(session, tenant_id)",
            "",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(target_id=tenant_id)",
            "            q.delete(False)",
            "",
            "            session.delete(tenant_ref)",
            "",
            "    # domain crud",
            "",
            "    @sql.handle_conflicts(conflict_type='domain')",
            "    def create_domain(self, domain_id, domain):",
            "        with sql.transaction() as session:",
            "            ref = Domain.from_dict(domain)",
            "            session.add(ref)",
            "        return ref.to_dict()",
            "",
            "    @sql.truncated",
            "    def list_domains(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Domain)",
            "            refs = sql.filter_limit_query(Domain, query, hints)",
            "            return [ref.to_dict() for ref in refs]",
            "",
            "    def _get_domain(self, session, domain_id):",
            "        ref = session.query(Domain).get(domain_id)",
            "        if ref is None:",
            "            raise exception.DomainNotFound(domain_id=domain_id)",
            "        return ref",
            "",
            "    def get_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            return self._get_domain(session, domain_id).to_dict()",
            "",
            "    def get_domain_by_name(self, domain_name):",
            "        with sql.transaction() as session:",
            "            try:",
            "                ref = (session.query(Domain).",
            "                       filter_by(name=domain_name).one())",
            "            except sql.NotFound:",
            "                raise exception.DomainNotFound(domain_id=domain_name)",
            "            return ref.to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='domain')",
            "    def update_domain(self, domain_id, domain):",
            "        with sql.transaction() as session:",
            "            ref = self._get_domain(session, domain_id)",
            "            old_dict = ref.to_dict()",
            "            for k in domain:",
            "                old_dict[k] = domain[k]",
            "            new_domain = Domain.from_dict(old_dict)",
            "            for attr in Domain.attributes:",
            "                if attr != 'id':",
            "                    setattr(ref, attr, getattr(new_domain, attr))",
            "            ref.extra = new_domain.extra",
            "            return ref.to_dict()",
            "",
            "    def delete_domain(self, domain_id):",
            "        with sql.transaction() as session:",
            "            ref = self._get_domain(session, domain_id)",
            "",
            "            # TODO(henry-nash): Although the controller will ensure deletion of",
            "            # all users & groups within the domain (which will cause all",
            "            # assignments for those users/groups to also be deleted), there",
            "            # could still be assignments on this domain for users/groups in",
            "            # other domains - so we should delete these here (see Bug #1277847)",
            "",
            "            session.delete(ref)",
            "",
            "    # role crud",
            "",
            "    @sql.handle_conflicts(conflict_type='role')",
            "    def create_role(self, role_id, role):",
            "        with sql.transaction() as session:",
            "            ref = Role.from_dict(role)",
            "            session.add(ref)",
            "            return ref.to_dict()",
            "",
            "    @sql.truncated",
            "    def list_roles(self, hints):",
            "        with sql.transaction() as session:",
            "            query = session.query(Role)",
            "            refs = sql.filter_limit_query(Role, query, hints)",
            "            return [ref.to_dict() for ref in refs]",
            "",
            "    def _get_role(self, session, role_id):",
            "        ref = session.query(Role).get(role_id)",
            "        if ref is None:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return ref",
            "",
            "    def get_role(self, role_id):",
            "        with sql.transaction() as session:",
            "            return self._get_role(session, role_id).to_dict()",
            "",
            "    @sql.handle_conflicts(conflict_type='role')",
            "    def update_role(self, role_id, role):",
            "        with sql.transaction() as session:",
            "            ref = self._get_role(session, role_id)",
            "            old_dict = ref.to_dict()",
            "            for k in role:",
            "                old_dict[k] = role[k]",
            "            new_role = Role.from_dict(old_dict)",
            "            for attr in Role.attributes:",
            "                if attr != 'id':",
            "                    setattr(ref, attr, getattr(new_role, attr))",
            "            ref.extra = new_role.extra",
            "            return ref.to_dict()",
            "",
            "    def delete_role(self, role_id):",
            "        with sql.transaction() as session:",
            "            ref = self._get_role(session, role_id)",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(role_id=role_id)",
            "            q.delete(False)",
            "            session.delete(ref)",
            "",
            "    def delete_user(self, user_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=user_id)",
            "            q.delete(False)",
            "",
            "    def delete_group(self, group_id):",
            "        with sql.transaction() as session:",
            "            q = session.query(RoleAssignment)",
            "            q = q.filter_by(actor_id=group_id)",
            "            q.delete(False)",
            "",
            "",
            "class Domain(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'domain'",
            "    attributes = ['id', 'name', 'enabled']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(64), nullable=False)",
            "    enabled = sql.Column(sql.Boolean, default=True, nullable=False)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    __table_args__ = (sql.UniqueConstraint('name'), {})",
            "",
            "",
            "class Project(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'project'",
            "    attributes = ['id', 'name', 'domain_id', 'description', 'enabled']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(64), nullable=False)",
            "    domain_id = sql.Column(sql.String(64), sql.ForeignKey('domain.id'),",
            "                           nullable=False)",
            "    description = sql.Column(sql.Text())",
            "    enabled = sql.Column(sql.Boolean)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    # Unique constraint across two columns to create the separation",
            "    # rather than just only 'name' being unique",
            "    __table_args__ = (sql.UniqueConstraint('domain_id', 'name'), {})",
            "",
            "",
            "class Role(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'role'",
            "    attributes = ['id', 'name']",
            "    id = sql.Column(sql.String(64), primary_key=True)",
            "    name = sql.Column(sql.String(255), unique=True, nullable=False)",
            "    extra = sql.Column(sql.JsonBlob())",
            "    __table_args__ = (sql.UniqueConstraint('name'), {})",
            "",
            "",
            "class RoleAssignment(sql.ModelBase, sql.DictBase):",
            "    __tablename__ = 'assignment'",
            "    attributes = ['type', 'actor_id', 'target_id', 'role_id', 'inherited']",
            "    # NOTE(henry-nash); Postgres requires a name to be defined for an Enum",
            "    type = sql.Column(",
            "        sql.Enum(AssignmentType.USER_PROJECT, AssignmentType.GROUP_PROJECT,",
            "                 AssignmentType.USER_DOMAIN, AssignmentType.GROUP_DOMAIN,",
            "                 name='type'),",
            "        nullable=False)",
            "    actor_id = sql.Column(sql.String(64), nullable=False)",
            "    target_id = sql.Column(sql.String(64), nullable=False)",
            "    role_id = sql.Column(sql.String(64), sql.ForeignKey('role.id'),",
            "                         nullable=False)",
            "    inherited = sql.Column(sql.Boolean, default=False, nullable=False)",
            "    __table_args__ = (sql.PrimaryKeyConstraint('type', 'actor_id', 'target_id',",
            "                                               'role_id'), {})",
            "",
            "    def to_dict(self):",
            "        \"\"\"Override parent to_dict() method with a simpler implementation.",
            "",
            "        RoleAssignment doesn't have non-indexed 'extra' attributes, so the",
            "        parent implementation is not applicable.",
            "        \"\"\"",
            "        return dict(six.iteritems(self))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.Airflow",
            "keystone.assignment.backends.sql.Assignment._get_metadata.role_ref",
            "keystone.assignment.backends.sql.Assignment._get_metadata.metadata_ref",
            "keystone.assignment.backends.sql.Assignment._get_metadata"
        ]
    },
    "keystone/tests/test_backend.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1405,
                "afterPatchRowNumber": 1405,
                "PatchRowcode": "         self.assertIn(role_list[1]['id'], combined_role_list)"
            },
            "1": {
                "beforePatchRowNumber": 1406,
                "afterPatchRowNumber": 1406,
                "PatchRowcode": "         self.assertIn(role_list[2]['id'], combined_role_list)"
            },
            "2": {
                "beforePatchRowNumber": 1407,
                "afterPatchRowNumber": 1407,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1408,
                "PatchRowcode": "+    def test_get_roles_for_user_and_project_user_group_same_id(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1409,
                "PatchRowcode": "+        \"\"\"When a user has the same ID as a group,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1410,
                "PatchRowcode": "+        get_roles_for_user_and_project returns only the roles for the user and"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1411,
                "PatchRowcode": "+        not the group."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1412,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1413,
                "PatchRowcode": "+        \"\"\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1414,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1415,
                "PatchRowcode": "+        # Setup: create user, group with same ID, role, and project;"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1416,
                "PatchRowcode": "+        # assign the group the role on the project."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1417,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1418,
                "PatchRowcode": "+        user_group_id = uuid.uuid4().hex"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1419,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1420,
                "PatchRowcode": "+        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1421,
                "PatchRowcode": "+                 'domain_id': DEFAULT_DOMAIN_ID, }"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1422,
                "PatchRowcode": "+        self.identity_api.create_user(user_group_id, user1)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1423,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1424,
                "PatchRowcode": "+        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1425,
                "PatchRowcode": "+                  'domain_id': DEFAULT_DOMAIN_ID, }"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1426,
                "PatchRowcode": "+        self.identity_api.create_group(user_group_id, group1)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1427,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1428,
                "PatchRowcode": "+        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1429,
                "PatchRowcode": "+        self.assignment_api.create_role(role1['id'], role1)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1430,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1431,
                "PatchRowcode": "+        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1432,
                "PatchRowcode": "+                    'domain_id': DEFAULT_DOMAIN_ID, }"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1433,
                "PatchRowcode": "+        self.assignment_api.create_project(project1['id'], project1)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1434,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1435,
                "PatchRowcode": "+        self.assignment_api.create_grant(role1['id'],"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1436,
                "PatchRowcode": "+                                         group_id=user_group_id,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1437,
                "PatchRowcode": "+                                         project_id=project1['id'])"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1438,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1439,
                "PatchRowcode": "+        # Check the roles, shouldn't be any since the user wasn't granted any."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1440,
                "PatchRowcode": "+        roles = self.assignment_api.get_roles_for_user_and_project("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1441,
                "PatchRowcode": "+            user_group_id, project1['id'])"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1442,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1443,
                "PatchRowcode": "+        self.assertEqual([], roles, 'role for group is %s' % role1['id'])"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1444,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": 1408,
                "afterPatchRowNumber": 1445,
                "PatchRowcode": "     def test_delete_role_with_user_and_group_grants(self):"
            },
            "41": {
                "beforePatchRowNumber": 1409,
                "afterPatchRowNumber": 1446,
                "PatchRowcode": "         role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}"
            },
            "42": {
                "beforePatchRowNumber": 1410,
                "afterPatchRowNumber": 1447,
                "PatchRowcode": "         self.assignment_api.create_role(role1['id'], role1)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import mock",
            "import uuid",
            "",
            "from keystoneclient.common import cms",
            "import six",
            "from testtools import matchers",
            "",
            "from keystone.catalog import core",
            "from keystone.common import driver_hints",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import filtering",
            "from keystone.tests import test_utils",
            "from keystone.token import provider",
            "",
            "",
            "CONF = config.CONF",
            "DEFAULT_DOMAIN_ID = CONF.identity.default_domain_id",
            "TIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'",
            "NULL_OBJECT = object()",
            "",
            "",
            "class IdentityTests(object):",
            "    def _get_domain_fixture(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        return domain",
            "",
            "    def test_project_add_and_remove_user_role(self):",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertNotIn(self.user_two['id'], user_ids)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            tenant_id=self.tenant_bar['id'],",
            "            user_id=self.user_two['id'],",
            "            role_id=self.role_other['id'])",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertIn(self.user_two['id'], user_ids)",
            "",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            tenant_id=self.tenant_bar['id'],",
            "            user_id=self.user_two['id'],",
            "            role_id=self.role_other['id'])",
            "",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertNotIn(self.user_two['id'], user_ids)",
            "",
            "    def test_remove_user_role_not_assigned(self):",
            "        # Expect failure if attempt to remove a role that was never assigned to",
            "        # the user.",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.",
            "                          remove_role_from_user_and_project,",
            "                          tenant_id=self.tenant_bar['id'],",
            "                          user_id=self.user_two['id'],",
            "                          role_id=self.role_other['id'])",
            "",
            "    def test_authenticate_bad_user(self):",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=uuid.uuid4().hex,",
            "                          password=self.user_foo['password'])",
            "",
            "    def test_authenticate_bad_password(self):",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=self.user_foo['id'],",
            "                          password=uuid.uuid4().hex)",
            "",
            "    def test_authenticate(self):",
            "        user_ref = self.identity_api.authenticate(",
            "            context={},",
            "            user_id=self.user_sna['id'],",
            "            password=self.user_sna['password'])",
            "        # NOTE(termie): the password field is left in user_sna to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_sna.pop('password')",
            "        self.user_sna['enabled'] = True",
            "        self.assertDictEqual(user_ref, self.user_sna)",
            "",
            "    def test_authenticate_and_get_roles_no_metadata(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        user_ref = self.identity_api.authenticate(",
            "            context={},",
            "            user_id=user['id'],",
            "            password=user['password'])",
            "        self.assertNotIn('password', user_ref)",
            "        # NOTE(termie): the password field is left in user_sna to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        user.pop('password')",
            "        self.assertDictContainsSubset(user, user_ref)",
            "        role_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user['id'], self.tenant_baz['id'])",
            "        self.assertEqual(1, len(role_list))",
            "        self.assertIn(CONF.member_role_id, role_list)",
            "",
            "    def test_authenticate_if_no_password_set(self):",
            "        id_ = uuid.uuid4().hex",
            "        user = {",
            "            'id': id_,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=id_,",
            "                          password='password')",
            "",
            "    def test_create_unicode_user_name(self):",
            "        unicode_name = u'name \\u540d\\u5b57'",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': unicode_name,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        ref = self.identity_api.create_user(user['id'], user)",
            "        self.assertEqual(unicode_name, ref['name'])",
            "",
            "    def test_get_project(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "    def test_get_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_project_by_name(self):",
            "        tenant_ref = self.assignment_api.get_project_by_name(",
            "            self.tenant_bar['name'],",
            "            DEFAULT_DOMAIN_ID)",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "    def test_get_project_by_name_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project_by_name,",
            "                          uuid.uuid4().hex,",
            "                          DEFAULT_DOMAIN_ID)",
            "",
            "    def test_list_user_ids_for_project(self):",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_baz['id'])",
            "        self.assertEqual(2, len(user_ids))",
            "        self.assertIn(self.user_two['id'], user_ids)",
            "        self.assertIn(self.user_badguy['id'], user_ids)",
            "",
            "    def test_list_user_ids_for_project_no_duplicates(self):",
            "        # Create user",
            "        user_ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'password': uuid.uuid4().hex,",
            "            'enabled': True}",
            "        self.identity_api.create_user(user_ref['id'], user_ref)",
            "        # Create project",
            "        project_ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(",
            "            project_ref['id'], project_ref)",
            "        # Create 2 roles and give user each role in project",
            "        for i in range(2):",
            "            role_ref = {",
            "                'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role_ref['id'], role_ref)",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                user_id=user_ref['id'],",
            "                tenant_id=project_ref['id'],",
            "                role_id=role_ref['id'])",
            "        # Get the list of user_ids in project",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            project_ref['id'])",
            "        # Ensure the user is only returned once",
            "        self.assertEqual(1, len(user_ids))",
            "",
            "    def test_get_project_user_ids_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.list_user_ids_for_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_user(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        # NOTE(termie): the password field is left in user_foo to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "    def test_get_user_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_user_by_name(self):",
            "        user_ref = self.identity_api.get_user_by_name(",
            "            self.user_foo['name'], DEFAULT_DOMAIN_ID)",
            "        # NOTE(termie): the password field is left in user_foo to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "    def test_get_user_by_name_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user_by_name,",
            "                          uuid.uuid4().hex,",
            "                          DEFAULT_DOMAIN_ID)",
            "",
            "    def test_get_role(self):",
            "        role_ref = self.assignment_api.get_role(self.role_admin['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, self.role_admin)",
            "",
            "    def test_get_role_404(self):",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_duplicate_role_name_fails(self):",
            "        role = {'id': 'fake1',",
            "                'name': 'fake1name'}",
            "        self.assignment_api.create_role('fake1', role)",
            "        role['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_role,",
            "                          'fake2',",
            "                          role)",
            "",
            "    def test_rename_duplicate_role_name_fails(self):",
            "        role1 = {",
            "            'id': 'fake1',",
            "            'name': 'fake1name'",
            "        }",
            "        role2 = {",
            "            'id': 'fake2',",
            "            'name': 'fake2name'",
            "        }",
            "        self.assignment_api.create_role('fake1', role1)",
            "        self.assignment_api.create_role('fake2', role2)",
            "        role1['name'] = 'fake2name'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.update_role,",
            "                          'fake1',",
            "                          role1)",
            "",
            "    def test_create_duplicate_user_id_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_duplicate_user_name_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_user,",
            "                          'fake2',",
            "                          user)",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        user1 = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': uuid.uuid4().hex}",
            "        user2 = {'id': uuid.uuid4().hex,",
            "                 'name': user1['name'],",
            "                 'domain_id': new_domain['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        self.identity_api.create_user(user2['id'], user2)",
            "",
            "    def test_move_user_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': domain1['id'],",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['domain_id'] = domain2['id']",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a user in domain1",
            "        user1 = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        # Now create a user in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        user2 = {'id': uuid.uuid4().hex,",
            "                 'name': user1['name'],",
            "                 'domain_id': domain2['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user2['id'], user2)",
            "        # Now try and move user1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        user1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_user,",
            "                          user1['id'],",
            "                          user1)",
            "",
            "    def test_rename_duplicate_user_name_fails(self):",
            "        user1 = {'id': 'fake1',",
            "                 'name': 'fake1',",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': 'fakepass',",
            "                 'tenants': ['bar']}",
            "        user2 = {'id': 'fake2',",
            "                 'name': 'fake2',",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': 'fakepass',",
            "                 'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user1)",
            "        self.identity_api.create_user('fake2', user2)",
            "        user2['name'] = 'fake1'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_user,",
            "                          'fake2',",
            "                          user2)",
            "",
            "    def test_update_user_id_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['id'] = 'fake2'",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual('fake1', user_ref['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          'fake2')",
            "",
            "    def test_create_duplicate_project_id_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_project,",
            "                          'fake1',",
            "                          tenant)",
            "",
            "    def test_create_duplicate_project_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_project,",
            "                          'fake1',",
            "                          tenant)",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        tenant1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        tenant2 = {'id': uuid.uuid4().hex, 'name': tenant1['name'],",
            "                   'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(tenant1['id'], tenant1)",
            "        self.assignment_api.create_project(tenant2['id'], tenant2)",
            "",
            "    def test_move_project_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project['domain_id'] = domain2['id']",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a project in domain1",
            "        project1 = {'id': uuid.uuid4().hex,",
            "                    'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        # Now create a project in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        project2 = {'id': uuid.uuid4().hex,",
            "                    'name': project1['name'],",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        # Now try and move project1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        project1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.update_project,",
            "                          project1['id'],",
            "                          project1)",
            "",
            "    def test_rename_duplicate_project_name_fails(self):",
            "        tenant1 = {'id': 'fake1', 'name': 'fake1',",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        tenant2 = {'id': 'fake2', 'name': 'fake2',",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant1)",
            "        self.assignment_api.create_project('fake2', tenant2)",
            "        tenant2['name'] = 'fake1'",
            "        self.assertRaises(exception.Error,",
            "                          self.assignment_api.update_project,",
            "                          'fake2',",
            "                          tenant2)",
            "",
            "    def test_update_project_id_does_nothing(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['id'] = 'fake2'",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual('fake1', tenant_ref['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          'fake2')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        \"\"\"Test for unfiltered listing role assignments.",
            "",
            "        Test Plan:",
            "",
            "        - Create a domain, with a user, group & project",
            "        - Find how many role assignments already exist (from default",
            "          fixtures)",
            "        - Create a grant of each type (user/group on project/domain)",
            "        - Check the number of assignments has gone up by 4 and that",
            "          the entries we added are in the list returned",
            "        - Check that if we list assignments by role_id, then we get back",
            "          assignments that only contain that role.",
            "",
            "        \"\"\"",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grants already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "        existing_assignments_for_role = len(",
            "            self.assignment_api.list_role_assignments_for_role(",
            "                role_id='admin'))",
            "",
            "        # Now create the grants (roles are defined in default_fixtures)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='admin')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the full list of assignments - check it is gone up by 4",
            "        assignment_list = self.assignment_api.list_role_assignments()",
            "        self.assertEqual(existing_assignments + 4, len(assignment_list))",
            "",
            "        # Now check that each of our four new entries are in the list",
            "        self.assertIn(",
            "            {'user_id': new_user['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'member'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'user_id': new_user['id'], 'project_id': new_project['id'],",
            "             'role_id': 'other'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'project_id': new_project['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "",
            "        # Read back the list of assignments for just the admin role, checking",
            "        # this only goes up by two.",
            "        assignment_list = self.assignment_api.list_role_assignments_for_role(",
            "            role_id='admin')",
            "        self.assertEqual(existing_assignments_for_role + 2,",
            "                         len(assignment_list))",
            "",
            "        # Now check that each of our two new entries are in the list",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'project_id': new_project['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        assignment_list = self.assignment_api.list_role_assignments_for_role(",
            "            role_id=uuid.uuid4().hex)",
            "        self.assertEqual([], assignment_list)",
            "",
            "    def test_add_duplicate_role_grant(self):",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(self.role_admin['id'], roles_ref)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], self.role_admin['id'])",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          self.role_admin['id'])",
            "",
            "    def test_get_role_by_user_and_project_with_user_in_group(self):",
            "        \"\"\"Test for get role by user and project, user was added into a group.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user, a project & a group, add this user to group",
            "        - Create roles and grant them to user and project",
            "        - Check the role list get by the user and project was as expected",
            "",
            "        \"\"\"",
            "        user_ref = {'id': uuid.uuid4().hex,",
            "                    'name': uuid.uuid4().hex,",
            "                    'domain_id': DEFAULT_DOMAIN_ID,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "        self.identity_api.create_user(user_ref['id'], user_ref)",
            "",
            "        project_ref = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(project_ref['id'], project_ref)",
            "",
            "        group = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID}",
            "        group_id = self.identity_api.create_group(group['id'], group)['id']",
            "        self.identity_api.add_user_to_group(user_ref['id'], group_id)",
            "",
            "        role_ref_list = []",
            "        for i in range(2):",
            "            role_ref = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role_ref['id'], role_ref)",
            "            role_ref_list.append(role_ref)",
            "",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                user_id=user_ref['id'],",
            "                tenant_id=project_ref['id'],",
            "                role_id=role_ref['id'])",
            "",
            "        role_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user_id=user_ref['id'],",
            "            tenant_id=project_ref['id'])",
            "",
            "        self.assertEqual(set(role_list),",
            "                         set([role_ref['id'] for role_ref in role_ref_list]))",
            "",
            "    def test_get_role_by_user_and_project(self):",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(self.role_admin['id'], roles_ref)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], self.role_admin['id'])",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref)",
            "        self.assertNotIn('member', roles_ref)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref)",
            "        self.assertIn('member', roles_ref)",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        \"\"\"Test for getting roles for user on a domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a domain, with 2 users",
            "        - Check no roles yet exit",
            "        - Give user1 two roles on the domain, user2 one role",
            "        - Get roles on user1 and the domain - maybe sure we only",
            "          get back the 2 roles on user1",
            "        - Delete both roles from user1",
            "        - Check we get no roles back for user1 on domain",
            "",
            "        \"\"\"",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user1['id'], new_user1)",
            "        new_user2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user2['id'], new_user2)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user1['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        # Now create the grants (roles are defined in default_fixtures)",
            "        self.assignment_api.create_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.create_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(user_id=new_user2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='admin')",
            "        # Read back the roles for user1 on domain",
            "        roles_ids = self.assignment_api.get_roles_for_user_and_domain(",
            "            new_user1['id'], new_domain['id'])",
            "        self.assertEqual(2, len(roles_ids))",
            "        self.assertIn(self.role_member['id'], roles_ids)",
            "        self.assertIn(self.role_other['id'], roles_ids)",
            "",
            "        # Now delete both grants for user1",
            "        self.assignment_api.delete_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.delete_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='other')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user1['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "    def test_get_roles_for_user_and_domain_404(self):",
            "        \"\"\"Test errors raised when getting roles for user on a domain.",
            "",
            "        Test Plan:",
            "",
            "        - Check non-existing user gives UserNotFound",
            "        - Check non-existing domain gives DomainNotFound",
            "",
            "        \"\"\"",
            "        new_domain = self._get_domain_fixture()",
            "        new_user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user1['id'], new_user1)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_domain,",
            "                          uuid.uuid4().hex,",
            "                          new_domain['id'])",
            "",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_domain,",
            "                          new_user1['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_roles_for_user_and_project_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_project,",
            "                          uuid.uuid4().hex,",
            "                          self.tenant_bar['id'])",
            "",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_project,",
            "                          self.user_foo['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_add_role_to_user_and_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          uuid.uuid4().hex,",
            "                          self.role_admin['id'])",
            "",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_add_role_to_user_and_project_no_user(self):",
            "        # If add_role_to_user_and_project and the user doesn't exist, then",
            "        # no error.",
            "        user_id_not_exist = uuid.uuid4().hex",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id_not_exist, self.tenant_bar['id'], self.role_admin['id'])",
            "",
            "    def test_remove_role_from_user_and_project(self):",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn('member', roles_ref)",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.",
            "                          remove_role_from_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          'member')",
            "",
            "    def test_get_role_grant_by_user_and_project(self):",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'],",
            "                      [role_ref['id'] for role_ref in roles_ref])",
            "",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref_ids)",
            "        self.assertIn('member', roles_ref_ids)",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': 'secret', 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_group2 = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                      'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group2['id'], new_group2)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        new_user2 = {'id': uuid.uuid4().hex, 'name': 'new_user2',",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user2['id'], new_user2)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        # First check we have no grants",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        # Now add the grant we are going to test for, and some others as",
            "        # well just to make sure we get back the right one",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "",
            "        self.assignment_api.create_grant(group_id=new_group2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(user_id=new_user2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': 'secret', 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=new_user['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        group1_domain1_role = {'id': uuid.uuid4().hex,",
            "                               'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(group1_domain1_role['id'],",
            "                                        group1_domain1_role)",
            "        group1_domain2_role = {'id': uuid.uuid4().hex,",
            "                               'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(group1_domain2_role['id'],",
            "                                        group1_domain2_role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': domain1['id'],",
            "                  'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=group1_domain1_role['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=group1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertDictEqual(roles_ref[0], group1_domain1_role)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertDictEqual(roles_ref[0], group1_domain2_role)",
            "",
            "        self.assignment_api.delete_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=group1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=group1['id'],",
            "                          domain_id=domain2['id'],",
            "                          role_id=group1_domain2_role['id'])",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        user1_domain1_role = {'id': uuid.uuid4().hex,",
            "                              'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(user1_domain1_role['id'],",
            "                                        user1_domain1_role)",
            "        user1_domain2_role = {'id': uuid.uuid4().hex,",
            "                              'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(user1_domain2_role['id'],",
            "                                        user1_domain2_role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=user1_domain1_role['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=user1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertDictEqual(roles_ref[0], user1_domain1_role)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertDictEqual(roles_ref[0], user1_domain2_role)",
            "",
            "        self.assignment_api.delete_grant(user_id=user1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=user1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=user1['id'],",
            "                          domain_id=domain2['id'],",
            "                          role_id=user1_domain2_role['id'])",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        role2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role2['id'], role2)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role2['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(role1['id'], roles_ref_ids)",
            "        self.assertIn(role2['id'], roles_ref_ids)",
            "",
            "        self.assignment_api.delete_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assertDictEqual(roles_ref[0], role2)",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        role2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role2['id'], role2)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role2['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(role1['id'], roles_ref_ids)",
            "        self.assertIn(role2['id'], roles_ref_ids)",
            "",
            "        self.assignment_api.delete_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assertDictEqual(roles_ref[0], role2)",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        # Can delete a grant where the user doesn't exist.",
            "        role_id = uuid.uuid4().hex",
            "        role = {'id': role_id, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role_id, role)",
            "",
            "        user_id = uuid.uuid4().hex",
            "",
            "        self.assignment_api.create_grant(role_id, user_id=user_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "        self.assignment_api.delete_grant(role_id, user_id=user_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        # Can delete a grant where the group doesn't exist.",
            "        role_id = uuid.uuid4().hex",
            "        role = {'id': role_id, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role_id, role)",
            "",
            "        group_id = uuid.uuid4().hex",
            "",
            "        self.assignment_api.create_grant(role_id, group_id=group_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "        self.assignment_api.delete_grant(role_id, group_id=group_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        role_list = []",
            "        for _ in range(10):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[3]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[4]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[5]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[6]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[7]['id'])",
            "        roles_ref = self.assignment_api.list_grants(user_id=user1['id'],",
            "                                                    domain_id=domain1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[0], roles_ref)",
            "        self.assertIn(role_list[1], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(group_id=group1['id'],",
            "                                                    domain_id=domain1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[2], roles_ref)",
            "        self.assertIn(role_list[3], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(user_id=user1['id'],",
            "                                                    project_id=project1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[4], roles_ref)",
            "        self.assertIn(role_list[5], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(group_id=group1['id'],",
            "                                                    project_id=project1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[6], roles_ref)",
            "        self.assertIn(role_list[7], roles_ref)",
            "",
            "        # Now test the alternate way of getting back lists of grants,",
            "        # where user and group roles are combined.  These should match",
            "        # the above results.",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(4, len(combined_list))",
            "        self.assertIn(role_list[4]['id'], combined_list)",
            "        self.assertIn(role_list[5]['id'], combined_list)",
            "        self.assertIn(role_list[6]['id'], combined_list)",
            "        self.assertIn(role_list[7]['id'], combined_list)",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(4, len(combined_role_list))",
            "        self.assertIn(role_list[0]['id'], combined_role_list)",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "        self.assertIn(role_list[2]['id'], combined_role_list)",
            "        self.assertIn(role_list[3]['id'], combined_role_list)",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        \"\"\"Test multiple group roles for user on project and domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create 6 roles",
            "        - Create a domain, with a project, user and two groups",
            "        - Make the user a member of both groups",
            "        - Check no roles yet exit",
            "        - Assign a role to each user and both groups on both the",
            "          project and domain",
            "        - Get a list of effective roles for the user on both the",
            "          project and domain, checking we get back the correct three",
            "          roles",
            "",
            "        \"\"\"",
            "        role_list = []",
            "        for _ in range(6):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[3]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[4]['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[5]['id'])",
            "",
            "        # Read by the roles, ensuring we get the correct 3 roles for",
            "        # both project and domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(3, len(combined_list))",
            "        self.assertIn(role_list[3]['id'], combined_list)",
            "        self.assertIn(role_list[4]['id'], combined_list)",
            "        self.assertIn(role_list[5]['id'], combined_list)",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(3, len(combined_role_list))",
            "        self.assertIn(role_list[0]['id'], combined_role_list)",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "        self.assertIn(role_list[2]['id'], combined_role_list)",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assignment_api.delete_role(role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.identity_api.add_user_to_group(user_id=user1['id'],",
            "                                            group_id=group1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.identity_api.check_user_in_group(",
            "            user_id=user1['id'],",
            "            group_id=group1['id'])",
            "        self.identity_api.delete_user(user1['id'])",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          user1['id'],",
            "                          group1['id'])",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.identity_api.add_user_to_group(user_id=user1['id'],",
            "                                            group_id=group1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.identity_api.check_user_in_group(",
            "            user_id=user1['id'],",
            "            group_id=group1['id'])",
            "        self.identity_api.delete_group(group1['id'])",
            "        self.identity_api.get_user(user1['id'])",
            "",
            "    def test_delete_domain_with_user_group_project_links(self):",
            "        # TODO(chungg):add test case once expected behaviour defined",
            "        pass",
            "",
            "    def test_role_crud(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role['id'], role)",
            "        role_ref = self.assignment_api.get_role(role['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, role)",
            "",
            "        role['name'] = uuid.uuid4().hex",
            "        updated_role_ref = self.assignment_api.update_role(role['id'], role)",
            "        role_ref = self.assignment_api.get_role(role['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, role)",
            "        self.assertDictEqual(role_ref_dict, updated_role_ref)",
            "",
            "        self.assignment_api.delete_role(role['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role['id'])",
            "",
            "    def test_update_role_404(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.update_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "    def test_add_user_to_project(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertIn(self.tenant_baz, tenants)",
            "",
            "    def test_add_user_to_project_missing_default_role(self):",
            "        self.assignment_api.delete_role(CONF.member_role_id)",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          CONF.member_role_id)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        tenants = (",
            "            self.assignment_api.list_projects_for_user(self.user_foo['id']))",
            "        self.assertIn(self.tenant_baz, tenants)",
            "        default_role = self.assignment_api.get_role(CONF.member_role_id)",
            "        self.assertIsNotNone(default_role)",
            "",
            "    def test_add_user_to_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.add_user_to_project,",
            "                          uuid.uuid4().hex,",
            "                          self.user_foo['id'])",
            "",
            "    def test_add_user_to_project_no_user(self):",
            "        # If add_user_to_project and the user doesn't exist, then",
            "        # no error.",
            "        user_id_not_exist = uuid.uuid4().hex",
            "        self.assignment_api.add_user_to_project(self.tenant_bar['id'],",
            "                                                user_id_not_exist)",
            "",
            "    def test_remove_user_from_project(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        self.assignment_api.remove_user_from_project(self.tenant_baz['id'],",
            "                                                     self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertNotIn(self.tenant_baz, tenants)",
            "",
            "    def test_remove_user_from_project_race_delete_role(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            tenant_id=self.tenant_baz['id'],",
            "            user_id=self.user_foo['id'],",
            "            role_id=self.role_other['id'])",
            "",
            "        # Mock a race condition, delete a role after",
            "        # get_roles_for_user_and_project() is called in",
            "        # remove_user_from_project().",
            "        roles = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_baz['id'])",
            "        self.assignment_api.delete_role(self.role_other['id'])",
            "        self.assignment_api.get_roles_for_user_and_project = mock.Mock(",
            "            return_value=roles)",
            "        self.assignment_api.remove_user_from_project(self.tenant_baz['id'],",
            "                                                     self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertNotIn(self.tenant_baz, tenants)",
            "",
            "    def test_remove_user_from_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          uuid.uuid4().hex,",
            "                          self.user_foo['id'])",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          self.tenant_bar['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          self.tenant_baz['id'],",
            "                          self.user_foo['id'])",
            "",
            "    def test_list_user_project_ids_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.update_project,",
            "                          uuid.uuid4().hex,",
            "                          dict())",
            "",
            "    def test_delete_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.delete_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_user_404(self):",
            "        user_id = uuid.uuid4().hex",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.update_user,",
            "                          user_id,",
            "                          {'id': user_id,",
            "                           'domain_id': DEFAULT_DOMAIN_ID})",
            "",
            "    def test_delete_user_with_project_association(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_bar['id'],",
            "                                                user['id'])",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          user['id'])",
            "",
            "    def test_delete_user_with_project_roles(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          user['id'])",
            "",
            "    def test_delete_user_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.delete_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_role_404(self):",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.delete_role,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_update_delete_unicode_project(self):",
            "        unicode_project_name = u'name \\u540d\\u5b57'",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': unicode_project_name,",
            "                   'description': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        self.assignment_api.update_project(project['id'], project)",
            "        self.assignment_api.delete_project(project['id'])",
            "",
            "    def test_create_project_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "    def test_create_project_with_no_enabled_field(self):",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "        project = self.assignment_api.get_project(ref['id'])",
            "        self.assertIs(project['enabled'], True)",
            "",
            "    def test_create_project_long_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'a' * 65,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_project_blank_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': '',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_project_invalid_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': None,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "        tenant = {'id': 'fake1', 'name': 123,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_blank_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = ''",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_long_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = 'a' * 65",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_invalid_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = None",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "        tenant['name'] = 123",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_user_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.identity_api.create_user(ref['id'], ref)",
            "",
            "    def test_create_user_long_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'a' * 256,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_user_blank_name_fails(self):",
            "        user = {'id': 'fake1', 'name': '',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_user_missed_password(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        self.identity_api.get_user('fake1')",
            "        # Make sure  the user is not allowed to login",
            "        # with a password that  is empty string or None",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password='')",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password=None)",
            "",
            "    def test_create_user_none_password(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'password': None,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        self.identity_api.get_user('fake1')",
            "        # Make sure  the user is not allowed to login",
            "        # with a password that  is empty string or None",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password='')",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password=None)",
            "",
            "    def test_create_user_invalid_name_fails(self):",
            "        user = {'id': 'fake1', 'name': None,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "        user = {'id': 'fake1', 'name': 123,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_project_invalid_enabled_type_string(self):",
            "            project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'enabled': True,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "            self.assignment_api.create_project(project['id'], project)",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertEqual(True, project_ref['enabled'])",
            "",
            "            # Strings are not valid boolean values",
            "            project['enabled'] = \"false\"",
            "            self.assertRaises(exception.ValidationError,",
            "                              self.assignment_api.update_project,",
            "                              project['id'],",
            "                              project)",
            "",
            "    def test_create_project_invalid_enabled_type_string(self):",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   # invalid string value",
            "                   'enabled': \"true\"}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          project['id'],",
            "                          project)",
            "",
            "    def test_create_user_invalid_enabled_type_string(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex,",
            "                # invalid string value",
            "                'enabled': \"true\"}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          user['id'],",
            "                          user)",
            "",
            "    def test_update_user_long_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = 'a' * 256",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_user_blank_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = ''",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_user_invalid_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "",
            "        user['name'] = None",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "        user['name'] = 123",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_list_users(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('password', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups(self):",
            "        group1 = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        group2 = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(2, len(groups))",
            "        group_ids = []",
            "        for group in groups:",
            "            group_ids.append(group.get('id'))",
            "        self.assertIn(group1['id'], group_ids)",
            "        self.assertIn(group2['id'], group_ids)",
            "",
            "    def test_list_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(3, len(domains))",
            "        domain_ids = []",
            "        for domain in domains:",
            "            domain_ids.append(domain.get('id'))",
            "        self.assertIn(DEFAULT_DOMAIN_ID, domain_ids)",
            "        self.assertIn(domain1['id'], domain_ids)",
            "        self.assertIn(domain2['id'], domain_ids)",
            "",
            "    def test_list_projects(self):",
            "        projects = self.assignment_api.list_projects()",
            "        self.assertEqual(4, len(projects))",
            "        project_ids = []",
            "        for project in projects:",
            "            project_ids.append(project.get('id'))",
            "        self.assertIn(self.tenant_bar['id'], project_ids)",
            "        self.assertIn(self.tenant_baz['id'], project_ids)",
            "",
            "    def test_list_projects_for_domain(self):",
            "        project_ids = ([x['id'] for x in",
            "                       self.assignment_api.list_projects_in_domain(",
            "                           DEFAULT_DOMAIN_ID)])",
            "        self.assertEqual(4, len(project_ids))",
            "        self.assertIn(self.tenant_bar['id'], project_ids)",
            "        self.assertIn(self.tenant_baz['id'], project_ids)",
            "        self.assertIn(self.tenant_mtu['id'], project_ids)",
            "        self.assertIn(self.tenant_service['id'], project_ids)",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        project_ids = ([x['id'] for x in",
            "                       self.assignment_api.list_projects_in_domain(",
            "                           domain1['id'])])",
            "        self.assertEqual(2, len(project_ids))",
            "        self.assertIn(project1['id'], project_ids)",
            "        self.assertIn(project2['id'], project_ids)",
            "",
            "    def test_list_roles(self):",
            "        roles = self.assignment_api.list_roles()",
            "        self.assertEqual(len(default_fixtures.ROLES), len(roles))",
            "        role_ids = set(role['id'] for role in roles)",
            "        expected_role_ids = set(role['id'] for role in default_fixtures.ROLES)",
            "        self.assertEqual(expected_role_ids, role_ids)",
            "",
            "    def test_delete_project_with_role_assignments(self):",
            "        tenant = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(tenant['id'], tenant)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], tenant['id'], 'member')",
            "        self.assignment_api.delete_project(tenant['id'])",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.get_project,",
            "                          tenant['id'])",
            "",
            "    def test_delete_role_check_role_grant(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        alt_role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role['id'], role)",
            "        self.assignment_api.create_role(alt_role['id'], alt_role)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], role['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], alt_role['id'])",
            "        self.assignment_api.delete_role(role['id'])",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(role['id'], roles_ref)",
            "        self.assertIn(alt_role['id'], roles_ref)",
            "",
            "    def test_create_project_doesnt_modify_passed_in_dict(self):",
            "        new_project = {'id': 'tenant_id', 'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "        original_project = new_project.copy()",
            "        self.assignment_api.create_project('tenant_id', new_project)",
            "        self.assertDictEqual(original_project, new_project)",
            "",
            "    def test_create_user_doesnt_modify_passed_in_dict(self):",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        original_user = new_user.copy()",
            "        self.identity_api.create_user('user_id', new_user)",
            "        self.assertDictEqual(original_user, new_user)",
            "",
            "    def test_update_user_enable(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        user['enabled'] = False",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(user['enabled'], user_ref['enabled'])",
            "",
            "        # If not present, enabled field should not be updated",
            "        del user['enabled']",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(False, user_ref['enabled'])",
            "",
            "        user['enabled'] = True",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(user['enabled'], user_ref['enabled'])",
            "",
            "        del user['enabled']",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        # Integers are valid Python's booleans. Explicitly test it.",
            "        user['enabled'] = 0",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(False, user_ref['enabled'])",
            "",
            "        # Any integers other than 0 are interpreted as True",
            "        user['enabled'] = -42",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "    def test_update_user_name(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        self.assertEqual(user['name'], user_ref['name'])",
            "",
            "        changed_name = user_ref['name'] + '_changed'",
            "        user_ref['name'] = changed_name",
            "        updated_user = self.identity_api.update_user(user_ref['id'], user_ref)",
            "",
            "        # NOTE(dstanek): the SQL backend adds an 'extra' field containing a",
            "        #                dictionary of the extra fields in addition to the",
            "        #                fields in the object. For the details see:",
            "        #                SqlIdentity.test_update_project_returns_extra",
            "        updated_user.pop('extra', None)",
            "",
            "        self.assertDictEqual(user_ref, updated_user)",
            "",
            "        user_ref = self.identity_api.get_user(user_ref['id'])",
            "        self.assertEqual(changed_name, user_ref['name'])",
            "",
            "    def test_update_user_enable_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        # Strings are not valid boolean values",
            "        user['enabled'] = \"false\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_project_enable(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(True, tenant_ref['enabled'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(tenant['enabled'], tenant_ref['enabled'])",
            "",
            "        # If not present, enabled field should not be updated",
            "        del tenant['enabled']",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(False, tenant_ref['enabled'])",
            "",
            "        tenant['enabled'] = True",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(tenant['enabled'], tenant_ref['enabled'])",
            "",
            "        del tenant['enabled']",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(True, tenant_ref['enabled'])",
            "",
            "    def test_add_user_to_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "",
            "        found = False",
            "        for x in groups:",
            "            if (x['id'] == new_group['id']):",
            "                found = True",
            "        self.assertTrue(found)",
            "",
            "    def test_add_user_to_group_404(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_check_user_in_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        self.identity_api.check_user_in_group(new_user['id'], new_group['id'])",
            "",
            "    def test_create_invalid_domain_fails(self):",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': \"doesnotexist\",",
            "                     'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.identity_api.create_group,",
            "                          new_group['id'],",
            "                          new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': \"doesnotexist\"}",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.identity_api.create_user,",
            "                          new_user['id'], new_user)",
            "",
            "    def test_check_user_not_in_group(self):",
            "        new_group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          new_user['id'],",
            "                          new_group['id'])",
            "",
            "    def test_check_user_in_group_404(self):",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        new_group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_list_users_in_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        # Make sure we get an empty list back on a new group, not an error.",
            "        user_refs = self.identity_api.list_users_in_group(new_group['id'])",
            "        self.assertEqual([], user_refs)",
            "        # Make sure we get the correct users back once they have been added",
            "        # to the group.",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        user_refs = self.identity_api.list_users_in_group(new_group['id'])",
            "        found = False",
            "        for x in user_refs:",
            "            if (x['id'] == new_user['id']):",
            "                found = True",
            "            self.assertNotIn('password', x)",
            "        self.assertTrue(found)",
            "",
            "    def test_list_users_in_group_404(self):",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.list_users_in_group,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_list_groups_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        test_groups = []",
            "        test_users = []",
            "        GROUP_COUNT = 3",
            "        USER_COUNT = 2",
            "",
            "        for x in range(0, USER_COUNT):",
            "            new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                        'password': uuid.uuid4().hex, 'enabled': True,",
            "                        'domain_id': domain['id']}",
            "            test_users.append(new_user)",
            "            self.identity_api.create_user(new_user['id'], new_user)",
            "        positive_user = test_users[0]",
            "        negative_user = test_users[1]",
            "",
            "        for x in range(0, USER_COUNT):",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                test_users[x]['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "        for x in range(0, GROUP_COUNT):",
            "            before_count = x",
            "            after_count = x + 1",
            "            new_group = {'id': uuid.uuid4().hex,",
            "                         'domain_id': domain['id'],",
            "                         'name': uuid.uuid4().hex}",
            "            self.identity_api.create_group(new_group['id'], new_group)",
            "            test_groups.append(new_group)",
            "",
            "            # add the user to the group and ensure that the",
            "            # group count increases by one for each",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(before_count, len(group_refs))",
            "            self.identity_api.add_user_to_group(",
            "                positive_user['id'],",
            "                new_group['id'])",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(after_count, len(group_refs))",
            "",
            "            # Make sure the group count for the unrelated user did not change",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                negative_user['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "        # remove the user from each group and ensure that",
            "        # the group count reduces by one for each",
            "        for x in range(0, 3):",
            "            before_count = GROUP_COUNT - x",
            "            after_count = GROUP_COUNT - x - 1",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(before_count, len(group_refs))",
            "            self.identity_api.remove_user_from_group(",
            "                positive_user['id'],",
            "                test_groups[x]['id'])",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(after_count, len(group_refs))",
            "            # Make sure the group count for the unrelated user",
            "            # did not change",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                negative_user['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "    def test_remove_user_from_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "        self.assertIn(new_group['id'], [x['id'] for x in groups])",
            "        self.identity_api.remove_user_from_group(new_user['id'],",
            "                                                 new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "        self.assertNotIn(new_group['id'], [x['id'] for x in groups])",
            "",
            "    def test_remove_user_from_group_404(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_group_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictContainsSubset(group, group_ref)",
            "",
            "        group['name'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictContainsSubset(group, group_ref)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_duplicate_group_name_fails(self):",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': uuid.uuid4().hex}",
            "        group2 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': group1['name']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_group,",
            "                          group2['id'], group2)",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': uuid.uuid4().hex}",
            "        group2 = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                  'name': group1['name']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "    def test_move_group_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id']}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group['domain_id'] = domain2['id']",
            "        self.identity_api.update_group(group['id'], group)",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a group in domain1",
            "        group1 = {'id': uuid.uuid4().hex,",
            "                  'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        # Now create a group in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        group2 = {'id': uuid.uuid4().hex,",
            "                  'name': group1['name'],",
            "                  'domain_id': domain2['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        # Now try and move group1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        group1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_group,",
            "                          group1['id'],",
            "                          group1)",
            "",
            "    def test_project_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictContainsSubset(project, project_ref)",
            "",
            "        project['name'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictContainsSubset(project, project_ref)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_project_update_missing_attrs_with_a_value(self):",
            "        # Creating a project with no description attribute.",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   'enabled': True}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # Add a description attribute.",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "    def test_project_update_missing_attrs_with_a_falsey_value(self):",
            "        # Creating a project with no description attribute.",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   'enabled': True}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # Add a description attribute.",
            "        project['description'] = ''",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        domain_ref = self.assignment_api.get_domain(domain['id'])",
            "        self.assertDictEqual(domain_ref, domain)",
            "",
            "        domain['name'] = uuid.uuid4().hex",
            "        self.assignment_api.update_domain(domain['id'], domain)",
            "        domain_ref = self.assignment_api.get_domain(domain['id'])",
            "        self.assertDictEqual(domain_ref, domain)",
            "",
            "        # Ensure an 'enabled' domain cannot be deleted",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_domain,",
            "                          domain_id=domain['id'])",
            "",
            "        # Disable the domain",
            "        domain['enabled'] = False",
            "        self.assignment_api.update_domain(domain['id'], domain)",
            "",
            "        # Delete the domain",
            "        self.assignment_api.delete_domain(domain['id'])",
            "",
            "        # Make sure the domain no longer exists",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower()}",
            "        self.assignment_api.create_domain(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.assignment_api.create_domain(ref['id'], ref)",
            "",
            "    def test_attribute_update(self):",
            "        project = {",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # pick a key known to be non-existent",
            "        key = 'description'",
            "",
            "        def assert_key_equals(value):",
            "            project_ref = self.assignment_api.update_project(",
            "                project['id'], project)",
            "            self.assertEqual(value, project_ref[key])",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertEqual(value, project_ref[key])",
            "",
            "        def assert_get_key_is(value):",
            "            project_ref = self.assignment_api.update_project(",
            "                project['id'], project)",
            "            self.assertIs(project_ref.get(key), value)",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertIs(project_ref.get(key), value)",
            "",
            "        # add an attribute that doesn't exist, set it to a falsey value",
            "        value = ''",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "        # set an attribute with a falsey value to null",
            "        value = None",
            "        project[key] = value",
            "        assert_get_key_is(value)",
            "",
            "        # do it again, in case updating from this situation is handled oddly",
            "        value = None",
            "        project[key] = value",
            "        assert_get_key_is(value)",
            "",
            "        # set a possibly-null value to a falsey value",
            "        value = ''",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "        # set a falsey value to a truthy value",
            "        value = uuid.uuid4().hex",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "    def test_user_crud(self):",
            "        user = {'domain_id': DEFAULT_DOMAIN_ID,",
            "                'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex, 'password': 'passw0rd'}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictContainsSubset(user, user_ref_dict)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictContainsSubset(user, user_ref_dict)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        # Create two groups each with a role on a different project, and",
            "        # make user1 a member of both groups.  Both these new projects",
            "        # should now be included, along with any direct user grants.",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        self.identity_api.add_user_to_group(user1['id'], group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'], group2['id'])",
            "",
            "        # Create 3 grants, one user grant, the other two as group grants",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(3, len(user_projects))",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        domain_id = domain['id']",
            "        # Create Domain",
            "        self.assignment_api.create_domain(domain_id, domain)",
            "        domain_ref = self.assignment_api.get_domain(domain_id)",
            "        updated_domain_ref = copy.deepcopy(domain_ref)",
            "        updated_domain_ref['name'] = uuid.uuid4().hex",
            "        # Update domain, bypassing assignment api manager",
            "        self.assignment_api.driver.update_domain(domain_id, updated_domain_ref)",
            "        # Verify get_domain still returns the domain",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_domain.invalidate(self.assignment_api,",
            "                                                  domain_id)",
            "        # Verify get_domain returns the updated domain",
            "        self.assertDictContainsSubset(",
            "            updated_domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Update the domain back to original ref, using the assignment api",
            "        # manager",
            "        self.assignment_api.update_domain(domain_id, domain_ref)",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Make sure domain is 'disabled', bypass assignment api manager",
            "        domain_ref_disabled = domain_ref.copy()",
            "        domain_ref_disabled['enabled'] = False",
            "        self.assignment_api.driver.update_domain(domain_id,",
            "                                                 domain_ref_disabled)",
            "        # Delete domain, bypassing assignment api manager",
            "        self.assignment_api.driver.delete_domain(domain_id)",
            "        # Verify get_domain still returns the domain",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_domain.invalidate(self.assignment_api,",
            "                                                  domain_id)",
            "        # Verify get_domain now raises DomainNotFound",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain, domain_id)",
            "        # Recreate Domain",
            "        self.assignment_api.create_domain(domain_id, domain)",
            "        self.assignment_api.get_domain(domain_id)",
            "        # Make sure domain is 'disabled', bypass assignment api manager",
            "        domain['enabled'] = False",
            "        self.assignment_api.driver.update_domain(domain_id, domain)",
            "        # Delete domain",
            "        self.assignment_api.delete_domain(domain_id)",
            "        # verify DomainNotFound raised",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain_id)",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': domain['id']}",
            "        project_id = project['id']",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['name'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_role_crud(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        role_id = role['id']",
            "        # Create role",
            "        self.assignment_api.create_role(role_id, role)",
            "        role_ref = self.assignment_api.get_role(role_id)",
            "        updated_role_ref = copy.deepcopy(role_ref)",
            "        updated_role_ref['name'] = uuid.uuid4().hex",
            "        # Update role, bypassing the assignment api manager",
            "        self.assignment_api.driver.update_role(role_id, updated_role_ref)",
            "        # Verify get_role still returns old ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Invalidate Cache",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                role_id)",
            "        # Verify get_role returns the new role_ref",
            "        self.assertDictEqual(updated_role_ref,",
            "                             self.assignment_api.get_role(role_id))",
            "        # Update role back to original via the assignment api manager",
            "        self.assignment_api.update_role(role_id, role_ref)",
            "        # Verify get_role returns the original role ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Delete role bypassing the assignment api manager",
            "        self.assignment_api.driver.delete_role(role_id)",
            "        # Verify get_role still returns the role_ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_role.invalidate(self.assignment_api, role_id)",
            "        # Verify RoleNotFound is now raised",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role_id)",
            "        # recreate role",
            "        self.assignment_api.create_role(role_id, role)",
            "        self.assignment_api.get_role(role_id)",
            "        # delete role via the assignment api manager",
            "        self.assignment_api.delete_role(role_id)",
            "        # verity RoleNotFound is now raised",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role_id)",
            "",
            "    def create_user_dict(self, **attributes):",
            "        user_dict = {'id': uuid.uuid4().hex,",
            "                     'name': uuid.uuid4().hex,",
            "                     'domain_id': DEFAULT_DOMAIN_ID,",
            "                     'enabled': True}",
            "        user_dict.update(attributes)",
            "        return user_dict",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "",
            "        self.assertEqual(attr_value, user['arbitrary_attr'])",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        self.identity_api.create_user(user_data['id'], user_data)",
            "",
            "        user = self.identity_api.get_user(user_data['id'])",
            "        self.assertEqual(attr_value, user['arbitrary_attr'])",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        user_data = self.create_user_dict()",
            "",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "        attr_value = uuid.uuid4().hex",
            "        user['arbitrary_attr'] = attr_value",
            "        updated_user = self.identity_api.update_user(user['id'], user)",
            "",
            "        self.assertEqual(attr_value, updated_user['arbitrary_attr'])",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        new_attr_value = uuid.uuid4().hex",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "        user['arbitrary_attr'] = new_attr_value",
            "        updated_user = self.identity_api.update_user(user['id'], user)",
            "",
            "        self.assertEqual(new_attr_value, updated_user['arbitrary_attr'])",
            "",
            "    def test_create_grant_no_user(self):",
            "        # If call create_grant with a user that doesn't exist, doesn't fail.",
            "        self.assignment_api.create_grant(",
            "            self.role_other['id'],",
            "            user_id=uuid.uuid4().hex,",
            "            project_id=self.tenant_bar['id'])",
            "",
            "    def test_create_grant_no_group(self):",
            "        # If call create_grant with a group that doesn't exist, doesn't fail.",
            "        self.assignment_api.create_grant(",
            "            self.role_other['id'],",
            "            group_id=uuid.uuid4().hex,",
            "            project_id=self.tenant_bar['id'])",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain_name = 'default'",
            "",
            "        domain = {'id': uuid.uuid4().hex, 'name': domain_name, 'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain_name)",
            "        self.assertEqual(domain, domain_ref)",
            "",
            "    def test_get_not_default_domain_by_name(self):",
            "        domain_name = 'foo'",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain_by_name,",
            "                          domain_name)",
            "",
            "",
            "class TokenTests(object):",
            "    def _create_token_id(self):",
            "        # Use a token signed by the cms module",
            "        token_id = \"\"",
            "        for i in range(1, 20):",
            "            token_id += uuid.uuid4().hex",
            "        return cms.cms_sign_token(token_id,",
            "                                  CONF.signing.certfile,",
            "                                  CONF.signing.keyfile)",
            "",
            "    def test_token_crud(self):",
            "        token_id = self._create_token_id()",
            "        data = {'id': token_id, 'a': 'b',",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        expires = data_ref.pop('expires')",
            "        data_ref.pop('user_id')",
            "        self.assertIsInstance(expires, datetime.datetime)",
            "        data_ref.pop('id')",
            "        data.pop('id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        new_data_ref = self.token_api.get_token(token_id)",
            "        expires = new_data_ref.pop('expires')",
            "        self.assertIsInstance(expires, datetime.datetime)",
            "        new_data_ref.pop('user_id')",
            "        new_data_ref.pop('id')",
            "",
            "        self.assertEqual(data, new_data_ref)",
            "",
            "        self.token_api.delete_token(token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.delete_token, token_id)",
            "",
            "    def create_token_sample_data(self, token_id=None, tenant_id=None,",
            "                                 trust_id=None, user_id=None, expires=None):",
            "        if token_id is None:",
            "            token_id = self._create_token_id()",
            "        if user_id is None:",
            "            user_id = 'testuserid'",
            "        # FIXME(morganfainberg): These tokens look nothing like \"Real\" tokens.",
            "        # This should be updated when token_api is updated to merge in the",
            "        # issue_token logic from the providers (token issuance should be a",
            "        # pipeline).  The fix should be in implementation of blueprint:",
            "        # token-issuance-pipeline",
            "        data = {'id': token_id, 'a': 'b',",
            "                'user': {'id': user_id}}",
            "        if tenant_id is not None:",
            "            data['tenant'] = {'id': tenant_id, 'name': tenant_id}",
            "        if tenant_id is NULL_OBJECT:",
            "            data['tenant'] = None",
            "        if expires is not None:",
            "            data['expires'] = expires",
            "        if trust_id is not None:",
            "            data['trust_id'] = trust_id",
            "            data.setdefault('access', {}).setdefault('trust', {})",
            "            # Testuserid2 is used here since a trustee will be different in",
            "            # the cases of impersonation and therefore should not match the",
            "            # token's user_id.",
            "            data['access']['trust']['trustee_user_id'] = 'testuserid2'",
            "        data['token_version'] = provider.V2",
            "        # Issue token stores a copy of all token data at token['token_data'].",
            "        # This emulates that assumption as part of the test.",
            "        data['token_data'] = copy.deepcopy(data)",
            "        new_token = self.token_api.create_token(token_id, data)",
            "        return new_token['id'], data",
            "",
            "    def test_delete_tokens(self):",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid')",
            "        token_id2, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid')",
            "        token_id3, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            user_id='testuserid1')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(2, len(tokens))",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_tokens(user_id='testuserid',",
            "                                     tenant_id='testtenantid')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id1)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id2)",
            "",
            "        self.token_api.get_token(token_id3)",
            "",
            "    def test_delete_tokens_trust(self):",
            "        tokens = self.token_api._list_tokens(user_id='testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            trust_id='testtrustid')",
            "        token_id2, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            user_id='testuserid1',",
            "            trust_id='testtrustid1')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_tokens(user_id='testuserid',",
            "                                     tenant_id='testtenantid',",
            "                                     trust_id='testtrustid')",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id1)",
            "        self.token_api.get_token(token_id2)",
            "",
            "    def _test_token_list(self, token_list_fn):",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data()",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id1, tokens)",
            "        token_id2, data = self.create_token_sample_data()",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(2, len(tokens))",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_token(token_id1)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.token_api.delete_token(token_id2)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertNotIn(token_id1, tokens)",
            "",
            "        # tenant-specific tokens",
            "        tenant1 = uuid.uuid4().hex",
            "        tenant2 = uuid.uuid4().hex",
            "        token_id3, data = self.create_token_sample_data(tenant_id=tenant1)",
            "        token_id4, data = self.create_token_sample_data(tenant_id=tenant2)",
            "        # test for existing but empty tenant (LP:1078497)",
            "        token_id5, data = self.create_token_sample_data(tenant_id=NULL_OBJECT)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(3, len(tokens))",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertIn(token_id3, tokens)",
            "        self.assertIn(token_id4, tokens)",
            "        self.assertIn(token_id5, tokens)",
            "        tokens = token_list_fn('testuserid', tenant2)",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertNotIn(token_id3, tokens)",
            "        self.assertIn(token_id4, tokens)",
            "",
            "    def test_token_list(self):",
            "        self._test_token_list(self.token_api._list_tokens)",
            "",
            "    def test_token_list_deprecated_public_interface(self):",
            "        # TODO(morganfainberg): Remove once token_api.list_tokens is removed",
            "        # (post Icehouse release)",
            "        self._test_token_list(self.token_api.list_tokens)",
            "",
            "    def test_token_list_trust(self):",
            "        trust_id = uuid.uuid4().hex",
            "        token_id5, data = self.create_token_sample_data(trust_id=trust_id)",
            "        tokens = self.token_api._list_tokens('testuserid', trust_id=trust_id)",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id5, tokens)",
            "",
            "    def test_get_token_404(self):",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token,",
            "                          uuid.uuid4().hex)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token,",
            "                          None)",
            "",
            "    def test_delete_token_404(self):",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.delete_token,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_expired_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() - datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id)",
            "",
            "    def test_null_expires_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        data = {'id': token_id, 'id_hash': token_id, 'a': 'b', 'expires': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        self.assertIsNotNone(data_ref['expires'])",
            "        new_data_ref = self.token_api.get_token(token_id)",
            "",
            "        # MySQL doesn't store microseconds, so discard them before testing",
            "        data_ref['expires'] = data_ref['expires'].replace(microsecond=0)",
            "        new_data_ref['expires'] = new_data_ref['expires'].replace(",
            "            microsecond=0)",
            "",
            "        self.assertEqual(data_ref, new_data_ref)",
            "",
            "    def check_list_revoked_tokens(self, token_ids):",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        for token_id in token_ids:",
            "            self.assertIn(token_id, revoked_ids)",
            "",
            "    def delete_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        self.token_api.delete_token(token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_api.get_token,",
            "            data_ref['id'])",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_api.delete_token,",
            "            data_ref['id'])",
            "        return token_id",
            "",
            "    def test_list_revoked_tokens_returns_empty_list(self):",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertEqual([], revoked_ids)",
            "",
            "    def test_list_revoked_tokens_for_single_token(self):",
            "        self.check_list_revoked_tokens([self.delete_token()])",
            "",
            "    def test_list_revoked_tokens_for_multiple_tokens(self):",
            "        self.check_list_revoked_tokens([self.delete_token()",
            "                                        for x in six.moves.range(2)])",
            "",
            "    def test_flush_expired_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() - datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() + datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        self.token_api.flush_expired_tokens()",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id, tokens)",
            "",
            "    @tests.skip_if_cache_disabled('token')",
            "    def test_revocation_list_cache(self):",
            "        expire_time = timeutils.utcnow() + datetime.timedelta(minutes=10)",
            "        token_id = uuid.uuid4().hex",
            "        token_data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                      'expires': expire_time,",
            "                      'trust_id': None,",
            "                      'user': {'id': 'testuserid'}}",
            "        token2_id = uuid.uuid4().hex",
            "        token2_data = {'id_hash': token2_id, 'id': token2_id, 'a': 'b',",
            "                       'expires': expire_time,",
            "                       'trust_id': None,",
            "                       'user': {'id': 'testuserid'}}",
            "        # Create 2 Tokens.",
            "        self.token_api.create_token(token_id, token_data)",
            "        self.token_api.create_token(token2_id, token2_data)",
            "        # Verify the revocation list is empty.",
            "        self.assertEqual([], self.token_api.list_revoked_tokens())",
            "        # Delete a token directly, bypassing the manager.",
            "        self.token_api.driver.delete_token(token_id)",
            "        # Verify the revocation list is still empty.",
            "        self.assertEqual([], self.token_api.list_revoked_tokens())",
            "        # Invalidate the revocation list.",
            "        self.token_api.invalidate_revocation_list()",
            "        # Verify the deleted token is in the revocation list.",
            "        revoked_tokens = [x['id']",
            "                          for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id, revoked_tokens)",
            "        # Delete the second token, through the manager",
            "        self.token_api.delete_token(token2_id)",
            "        revoked_tokens = [x['id']",
            "                          for x in self.token_api.list_revoked_tokens()]",
            "        # Verify both tokens are in the revocation list.",
            "        self.assertIn(token_id, revoked_tokens)",
            "        self.assertIn(token2_id, revoked_tokens)",
            "",
            "    def _test_predictable_revoked_pki_token_id(self, hash_fn):",
            "        token_id = self._create_token_id()",
            "        token_id_hash = hash_fn(token_id).hexdigest()",
            "        token = {'user': {'id': uuid.uuid4().hex}}",
            "",
            "        self.token_api.create_token(token_id, token)",
            "        self.token_api.delete_token(token_id)",
            "",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id_hash, revoked_ids)",
            "        self.assertNotIn(token_id, revoked_ids)",
            "        for t in self.token_api.list_revoked_tokens():",
            "            self.assertIn('expires', t)",
            "",
            "    def test_predictable_revoked_pki_token_id_default(self):",
            "        self._test_predictable_revoked_pki_token_id(hashlib.md5)",
            "",
            "    def test_predictable_revoked_pki_token_id_sha256(self):",
            "        self.config_fixture.config(group='token', hash_algorithm='sha256')",
            "        self._test_predictable_revoked_pki_token_id(hashlib.sha256)",
            "",
            "    def test_predictable_revoked_uuid_token_id(self):",
            "        token_id = uuid.uuid4().hex",
            "        token = {'user': {'id': uuid.uuid4().hex}}",
            "",
            "        self.token_api.create_token(token_id, token)",
            "        self.token_api.delete_token(token_id)",
            "",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id, revoked_ids)",
            "        for t in self.token_api.list_revoked_tokens():",
            "            self.assertIn('expires', t)",
            "",
            "    def test_create_unicode_token_id(self):",
            "        token_id = six.text_type(self._create_token_id())",
            "        self.create_token_sample_data(token_id=token_id)",
            "        self.token_api.get_token(token_id)",
            "",
            "    def test_create_unicode_user_id(self):",
            "        user_id = six.text_type(uuid.uuid4().hex)",
            "        token_id, data = self.create_token_sample_data(user_id=user_id)",
            "        self.token_api.get_token(token_id)",
            "",
            "    def test_list_tokens_unicode_user_id(self):",
            "        user_id = six.text_type(uuid.uuid4().hex)",
            "        self.token_api.list_tokens(user_id)",
            "",
            "    def test_token_expire_timezone(self):",
            "",
            "        @test_utils.timezone",
            "        def _create_token(expire_time):",
            "            token_id = uuid.uuid4().hex",
            "            user_id = six.text_type(uuid.uuid4().hex)",
            "            return self.create_token_sample_data(token_id=token_id,",
            "                                                 user_id=user_id,",
            "                                                 expires=expire_time)",
            "",
            "        for d in ['+0', '-11', '-8', '-5', '+5', '+8', '+14']:",
            "            test_utils.TZ = 'UTC' + d",
            "            expire_time = timeutils.utcnow() + datetime.timedelta(minutes=1)",
            "            token_id, data_in = _create_token(expire_time)",
            "            data_get = self.token_api.get_token(token_id)",
            "",
            "            self.assertEqual(data_in['id'], data_get['id'],",
            "                             'TZ=%s' % test_utils.TZ)",
            "",
            "            expire_time_expired = (",
            "                timeutils.utcnow() + datetime.timedelta(minutes=-1))",
            "            token_id, data_in = _create_token(expire_time_expired)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_api.get_token, data_in['id'])",
            "",
            "",
            "class TokenCacheInvalidation(object):",
            "    def _create_test_data(self):",
            "        self.user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex,",
            "                     'domain_id': DEFAULT_DOMAIN_ID, 'enabled': True}",
            "        self.tenant = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID, 'enabled': True}",
            "",
            "        # Create an equivalent of a scoped token",
            "        token_dict = {'user': self.user, 'tenant': self.tenant,",
            "                      'metadata': {}, 'id': 'placeholder'}",
            "        token_id, data = self.token_provider_api.issue_v2_token(token_dict)",
            "        self.scoped_token_id = token_id",
            "",
            "        # ..and an un-scoped one",
            "        token_dict = {'user': self.user, 'tenant': None,",
            "                      'metadata': {}, 'id': 'placeholder'}",
            "        token_id, data = self.token_provider_api.issue_v2_token(token_dict)",
            "        self.unscoped_token_id = token_id",
            "",
            "        # Validate them, in the various ways possible - this will load the",
            "        # responses into the token cache.",
            "        self._check_scoped_tokens_are_valid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "    def _check_unscoped_tokens_are_invalid(self):",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.unscoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.unscoped_token_id)",
            "",
            "    def _check_scoped_tokens_are_invalid(self):",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.scoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.scoped_token_id,",
            "            self.tenant['id'])",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.scoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.scoped_token_id,",
            "            self.tenant['id'])",
            "",
            "    def _check_scoped_tokens_are_valid(self):",
            "        self.token_provider_api.validate_token(self.scoped_token_id)",
            "        self.token_provider_api.validate_token(",
            "            self.scoped_token_id, belongs_to=self.tenant['id'])",
            "        self.token_provider_api.validate_v2_token(self.scoped_token_id)",
            "        self.token_provider_api.validate_v2_token(",
            "            self.scoped_token_id, belongs_to=self.tenant['id'])",
            "",
            "    def _check_unscoped_tokens_are_valid(self):",
            "        self.token_provider_api.validate_token(self.unscoped_token_id)",
            "        self.token_provider_api.validate_v2_token(self.unscoped_token_id)",
            "",
            "    def test_delete_unscoped_token(self):",
            "        self.token_api.delete_token(self.unscoped_token_id)",
            "        self._check_unscoped_tokens_are_invalid()",
            "        self._check_scoped_tokens_are_valid()",
            "",
            "    def test_delete_scoped_token_by_id(self):",
            "        self.token_api.delete_token(self.scoped_token_id)",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "    def test_delete_scoped_token_by_user(self):",
            "        self.token_api.delete_tokens(self.user['id'])",
            "        # Since we are deleting all tokens for this user, they should all",
            "        # now be invalid.",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_invalid()",
            "",
            "    def test_delete_scoped_token_by_user_and_tenant(self):",
            "        self.token_api.delete_tokens(self.user['id'],",
            "                                     tenant_id=self.tenant['id'])",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "",
            "class TrustTests(object):",
            "    def create_sample_trust(self, new_id, remaining_uses=None):",
            "        self.trustor = self.user_foo",
            "        self.trustee = self.user_two",
            "        trust_data = (self.trust_api.create_trust",
            "                      (new_id,",
            "                       {'trustor_user_id': self.trustor['id'],",
            "                        'trustee_user_id': self.user_two['id'],",
            "                        'project_id': self.tenant_bar['id'],",
            "                        'expires_at': timeutils.",
            "                        parse_isotime('2031-02-18T18:10:00Z'),",
            "                        'impersonation': True,",
            "                        'remaining_uses': remaining_uses},",
            "                       roles=[{\"id\": \"member\"},",
            "                              {\"id\": \"other\"},",
            "                              {\"id\": \"browser\"}]))",
            "        return trust_data",
            "",
            "    def test_delete_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "        trust_id = trust_data['id']",
            "        self.assertIsNotNone(trust_data)",
            "        trust_data = self.trust_api.get_trust(trust_id)",
            "        self.assertEqual(new_id, trust_data['id'])",
            "        self.trust_api.delete_trust(trust_id)",
            "        self.assertIsNone(self.trust_api.get_trust(trust_id))",
            "",
            "    def test_delete_trust_not_found(self):",
            "        trust_id = uuid.uuid4().hex",
            "        self.assertRaises(exception.TrustNotFound,",
            "                          self.trust_api.delete_trust,",
            "                          trust_id)",
            "",
            "    def test_get_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "        trust_id = trust_data['id']",
            "        self.assertIsNotNone(trust_data)",
            "        trust_data = self.trust_api.get_trust(trust_id)",
            "        self.assertEqual(new_id, trust_data['id'])",
            "",
            "    def test_create_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "",
            "        self.assertEqual(new_id, trust_data['id'])",
            "        self.assertEqual(self.trustee['id'], trust_data['trustee_user_id'])",
            "        self.assertEqual(self.trustor['id'], trust_data['trustor_user_id'])",
            "        self.assertTrue(timeutils.normalize_time(trust_data['expires_at']) >",
            "                        timeutils.utcnow())",
            "",
            "        self.assertEqual([{'id': 'member'},",
            "                          {'id': 'other'},",
            "                          {'id': 'browser'}], trust_data['roles'])",
            "",
            "    def test_list_trust_by_trustee(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts_for_trustee(self.trustee['id'])",
            "        self.assertEqual(3, len(trusts))",
            "        self.assertEqual(trusts[0][\"trustee_user_id\"], self.trustee['id'])",
            "        trusts = self.trust_api.list_trusts_for_trustee(self.trustor['id'])",
            "        self.assertEqual(0, len(trusts))",
            "",
            "    def test_list_trust_by_trustor(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts_for_trustor(self.trustor['id'])",
            "        self.assertEqual(3, len(trusts))",
            "        self.assertEqual(trusts[0][\"trustor_user_id\"], self.trustor['id'])",
            "        trusts = self.trust_api.list_trusts_for_trustor(self.trustee['id'])",
            "        self.assertEqual(0, len(trusts))",
            "",
            "    def test_list_trusts(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts()",
            "        self.assertEqual(3, len(trusts))",
            "",
            "    def test_trust_has_remaining_uses_positive(self):",
            "        # create a trust with limited uses, check that we have uses left",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex,",
            "                                              remaining_uses=5)",
            "        self.assertEqual(5, trust_data['remaining_uses'])",
            "        # create a trust with unlimited uses, check that we have uses left",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex)",
            "        self.assertIsNone(trust_data['remaining_uses'])",
            "",
            "    def test_trust_has_remaining_uses_negative(self):",
            "        # try to create a trust with no remaining uses, check that it fails",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.create_sample_trust,",
            "                          uuid.uuid4().hex,",
            "                          remaining_uses=0)",
            "        # try to create a trust with negative remaining uses,",
            "        # check that it fails",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.create_sample_trust,",
            "                          uuid.uuid4().hex,",
            "                          remaining_uses=-12)",
            "",
            "    def test_consume_use(self):",
            "        # consume a trust repeatedly until it has no uses anymore",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex,",
            "                                              remaining_uses=2)",
            "        self.trust_api.consume_use(trust_data['id'])",
            "        t = self.trust_api.get_trust(trust_data['id'])",
            "        self.assertEqual(1, t['remaining_uses'])",
            "        self.trust_api.consume_use(trust_data['id'])",
            "        # This was the last use, the trust isn't available anymore",
            "        self.assertIsNone(self.trust_api.get_trust(trust_data['id']))",
            "",
            "",
            "class CommonHelperTests(tests.TestCase):",
            "    def test_format_helper_raises_malformed_on_missing_key(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%(foo)s/%(bar)s\",",
            "                          {\"foo\": \"1\"})",
            "",
            "    def test_format_helper_raises_malformed_on_wrong_type(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%foo%s\",",
            "                          {\"foo\": \"1\"})",
            "",
            "    def test_format_helper_raises_malformed_on_incomplete_format(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%(foo)\",",
            "                          {\"foo\": \"1\"})",
            "",
            "",
            "class CatalogTests(object):",
            "    def test_region_crud(self):",
            "        # create",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        res = self.catalog_api.create_region(",
            "            new_region.copy())",
            "        # Ensure that we don't need to have a",
            "        # parent_region_id in the original supplied",
            "        # ref dict, but that it will be returned from",
            "        # the endpoint, with None value.",
            "        expected_region = new_region.copy()",
            "        expected_region['parent_region_id'] = None",
            "        self.assertDictEqual(res, expected_region)",
            "",
            "        # Test adding another region with the one above",
            "        # as its parent. We will check below whether deleting",
            "        # the parent successfully deletes any child regions.",
            "        parent_region_id = region_id",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "            'parent_region_id': parent_region_id",
            "        }",
            "        self.catalog_api.create_region(",
            "            new_region.copy())",
            "",
            "        # list",
            "        regions = self.catalog_api.list_regions()",
            "        self.assertThat(regions, matchers.HasLength(2))",
            "        region_ids = [x['id'] for x in regions]",
            "        self.assertIn(parent_region_id, region_ids)",
            "        self.assertIn(region_id, region_ids)",
            "",
            "        # delete",
            "        self.catalog_api.delete_region(parent_region_id)",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.delete_region,",
            "                          parent_region_id)",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          parent_region_id)",
            "        # Ensure the child is also gone...",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          region_id)",
            "",
            "    def test_create_region_with_duplicate_id(self):",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex",
            "        }",
            "        self.catalog_api.create_region(new_region)",
            "        # Create region again with duplicate id",
            "        self.assertRaises(exception.Conflict,",
            "                          self.catalog_api.create_region,",
            "                          new_region)",
            "",
            "    def test_get_region_404(self):",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_region_404(self):",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.delete_region,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_region_invalid_parent_region_404(self):",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "            'parent_region_id': 'nonexisting'",
            "        }",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.create_region,",
            "                          new_region)",
            "",
            "    def test_service_crud(self):",
            "        # create",
            "        service_id = uuid.uuid4().hex",
            "        new_service = {",
            "            'id': service_id,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        res = self.catalog_api.create_service(",
            "            service_id,",
            "            new_service.copy())",
            "        new_service['enabled'] = True",
            "        self.assertDictEqual(new_service, res)",
            "",
            "        # list",
            "        services = self.catalog_api.list_services()",
            "        self.assertIn(service_id, [x['id'] for x in services])",
            "",
            "        # delete",
            "        self.catalog_api.delete_service(service_id)",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.delete_service,",
            "                          service_id)",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.get_service,",
            "                          service_id)",
            "",
            "    def test_delete_service_with_endpoint(self):",
            "        # create a service",
            "        service = {",
            "            'id': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service['id'], service)",
            "",
            "        # create an endpoint attached to the service",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'region': uuid.uuid4().hex,",
            "            'interface': uuid.uuid4().hex[:8],",
            "            'url': uuid.uuid4().hex,",
            "            'service_id': service['id'],",
            "        }",
            "        self.catalog_api.create_endpoint(endpoint['id'], endpoint)",
            "",
            "        # deleting the service should also delete the endpoint",
            "        self.catalog_api.delete_service(service['id'])",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.get_endpoint,",
            "                          endpoint['id'])",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.delete_endpoint,",
            "                          endpoint['id'])",
            "",
            "    def test_get_service_404(self):",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.get_service,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_service_404(self):",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.delete_service,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_endpoint_404(self):",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'service_id': uuid.uuid4().hex,",
            "        }",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.create_endpoint,",
            "                          endpoint['id'],",
            "                          endpoint)",
            "",
            "    def test_get_endpoint_404(self):",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.get_endpoint,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_endpoint_404(self):",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.delete_endpoint,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_endpoint(self):",
            "        service = {",
            "            'id': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service['id'], service.copy())",
            "",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'region': \"0\" * 255,",
            "            'service_id': service['id'],",
            "            'interface': 'public',",
            "            'url': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_endpoint(endpoint['id'], endpoint.copy())",
            "",
            "    def _create_endpoints(self):",
            "        # Creates a service and 2 endpoints for the service in the same region.",
            "        # The 'public' interface is enabled and the 'internal' interface is",
            "        # disabled.",
            "",
            "        def create_endpoint(service_id, region, **kwargs):",
            "            id_ = uuid.uuid4().hex",
            "            ref = {",
            "                'id': id_,",
            "                'interface': 'public',",
            "                'region': region,",
            "                'service_id': service_id,",
            "                'url': 'http://localhost/%s' % uuid.uuid4().hex,",
            "            }",
            "            ref.update(kwargs)",
            "            self.catalog_api.create_endpoint(id_, ref)",
            "            return ref",
            "",
            "        # Create a service for use with the endpoints.",
            "        service_id = uuid.uuid4().hex",
            "        service_ref = {",
            "            'id': service_id,",
            "            'name': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service_id, service_ref)",
            "",
            "        region = uuid.uuid4().hex",
            "",
            "        # Create endpoints",
            "        enabled_endpoint_ref = create_endpoint(service_id, region)",
            "        disabled_endpoint_ref = create_endpoint(",
            "            service_id, region, enabled=False, interface='internal')",
            "",
            "        return service_ref, enabled_endpoint_ref, disabled_endpoint_ref",
            "",
            "    def test_get_catalog_endpoint_disabled(self):",
            "        \"\"\"Get back only enabled endpoints when get the v2 catalog.\"\"\"",
            "",
            "        service_ref, enabled_endpoint_ref, dummy_disabled_endpoint_ref = (",
            "            self._create_endpoints())",
            "",
            "        user_id = uuid.uuid4().hex",
            "        project_id = uuid.uuid4().hex",
            "        catalog = self.catalog_api.get_catalog(user_id, project_id)",
            "",
            "        exp_entry = {",
            "            'id': enabled_endpoint_ref['id'],",
            "            'name': service_ref['name'],",
            "            'publicURL': enabled_endpoint_ref['url'],",
            "        }",
            "",
            "        region = enabled_endpoint_ref['region']",
            "        self.assertEqual(exp_entry, catalog[region][service_ref['type']])",
            "",
            "    def test_get_v3_catalog_endpoint_disabled(self):",
            "        \"\"\"Get back only enabled endpoints when get the v3 catalog.\"\"\"",
            "",
            "        enabled_endpoint_ref = self._create_endpoints()[1]",
            "",
            "        user_id = uuid.uuid4().hex",
            "        project_id = uuid.uuid4().hex",
            "        catalog = self.catalog_api.get_v3_catalog(user_id, project_id)",
            "",
            "        endpoint_ids = [x['id'] for x in catalog[0]['endpoints']]",
            "        self.assertEqual([enabled_endpoint_ref['id']], endpoint_ids)",
            "",
            "",
            "class PolicyTests(object):",
            "    def _new_policy_ref(self):",
            "        return {",
            "            'id': uuid.uuid4().hex,",
            "            'policy': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'endpoint_id': uuid.uuid4().hex,",
            "        }",
            "",
            "    def assertEqualPolicies(self, a, b):",
            "        self.assertEqual(a['id'], b['id'])",
            "        self.assertEqual(a['endpoint_id'], b['endpoint_id'])",
            "        self.assertEqual(a['policy'], b['policy'])",
            "        self.assertEqual(a['type'], b['type'])",
            "",
            "    def test_create(self):",
            "        ref = self._new_policy_ref()",
            "        res = self.policy_api.create_policy(ref['id'], ref)",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_get(self):",
            "        ref = self._new_policy_ref()",
            "        res = self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        res = self.policy_api.get_policy(ref['id'])",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_list(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        res = self.policy_api.list_policies()",
            "        res = [x for x in res if x['id'] == ref['id']][0]",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_update(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "        orig = ref",
            "",
            "        ref = self._new_policy_ref()",
            "",
            "        # (cannot change policy ID)",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.policy_api.update_policy,",
            "                          orig['id'],",
            "                          ref)",
            "",
            "        ref['id'] = orig['id']",
            "        res = self.policy_api.update_policy(orig['id'], ref)",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_delete(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        self.policy_api.delete_policy(ref['id'])",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.delete_policy,",
            "                          ref['id'])",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.get_policy,",
            "                          ref['id'])",
            "        res = self.policy_api.list_policies()",
            "        self.assertFalse(len([x for x in res if x['id'] == ref['id']]))",
            "",
            "    def test_get_policy_404(self):",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.get_policy,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_policy_404(self):",
            "        ref = self._new_policy_ref()",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.update_policy,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_delete_policy_404(self):",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.delete_policy,",
            "                          uuid.uuid4().hex)",
            "",
            "",
            "class InheritanceTests(object):",
            "",
            "    def test_inherited_role_grants_for_user(self):",
            "        \"\"\"Test inherited user roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create 3 roles",
            "        - Create a domain, with a project and a user",
            "        - Check no roles yet exit",
            "        - Assign a direct user role to the project and a (non-inherited)",
            "          user role to the domain",
            "        - Get a list of effective roles - should only get the one direct role",
            "        - Now add an inherited user role to the domain",
            "        - Get a list of effective roles - should have two roles, one",
            "          direct and one by virtue of the inherited user role",
            "        - Also get effective roles for the domain - the role marked as",
            "          inherited should not show up",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        role_list = []",
            "        for _ in range(3):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        # Create the first two roles - the domain one is not inherited",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "",
            "        # Now get the effective roles for the user and project, this",
            "        # should only include the direct role assignment on the project",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(1, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "",
            "        # Now add an inherited role on the domain",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'],",
            "                                         inherited_to_projects=True)",
            "",
            "        # Now get the effective roles for the user and project again, this",
            "        # should now include the inherited role on the domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[2]['id'], combined_list)",
            "",
            "        # Finally, check that the inherited role does not appear as a valid",
            "        # directly assigned role on the domain itself",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(1, len(combined_role_list))",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "",
            "    def test_inherited_role_grants_for_group(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create 4 roles",
            "        - Create a domain, with a project, user and two groups",
            "        - Make the user a member of both groups",
            "        - Check no roles yet exit",
            "        - Assign a direct user role to the project and a (non-inherited)",
            "          group role on the domain",
            "        - Get a list of effective roles - should only get the one direct role",
            "        - Now add two inherited group roles to the domain",
            "        - Get a list of effective roles - should have three roles, one",
            "          direct and two by virtue of inherited group roles",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        role_list = []",
            "        for _ in range(4):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        # Create two roles - the domain one is not inherited",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "",
            "        # Now get the effective roles for the user and project, this",
            "        # should only include the direct role assignment on the project",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(1, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "",
            "        # Now add to more group roles, both inherited, to the domain",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'],",
            "                                         inherited_to_projects=True)",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[3]['id'],",
            "                                         inherited_to_projects=True)",
            "",
            "        # Now get the effective roles for the user and project again, this",
            "        # should now include the inherited roles on the domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(3, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[2]['id'], combined_list)",
            "        self.assertIn(role_list[3]['id'], combined_list)",
            "",
            "    def test_list_projects_for_user_with_inherited_grants(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create a domain, with two projects and a user",
            "        - Assign an inherited user role on the domain, as well as a direct",
            "          user role to a separate project in a different domain",
            "        - Get a list of projects for user, should return all three projects",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        # Create 2 grants, one on a project and one inherited grant",
            "        # on the domain",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        # Should get back all three projects, one by virtue of the direct",
            "        # grant, plus both projects in the domain",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(3, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_inherited_group_grants(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create two domains, each with two projects",
            "        - Create a user and group",
            "        - Make the user a member of the group",
            "        - Assign a user role two projects, an inherited",
            "          group role to one domain and an inherited regular role on",
            "          the other domain",
            "        - Get a list of projects for user, should return both pairs of projects",
            "          from the domain, plus the one separate project",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        project3 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project3['id'], project3)",
            "        project4 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project4['id'], project4)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.add_user_to_group(user1['id'], group1['id'])",
            "",
            "        # Create 4 grants:",
            "        # - one user grant on a project in domain2",
            "        # - one user grant on a project in the default domain",
            "        # - one inherited user grant on domain",
            "        # - one inherited group grant on domain2",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project3['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        # Should get back all five projects, but without a duplicate for",
            "        # project3 (since it has both a direct user role and an inherited role)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(5, len(user_projects))",
            "",
            "",
            "class FilterTests(filtering.FilterTests):",
            "    def test_list_users_filtered(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "",
            "        for entity in ['user', 'group', 'project']:",
            "            # Create 20 entities, 14 of which are in domain1",
            "            entity_list = self._create_test_data(entity, 6)",
            "            domain1_entity_list = self._create_test_data(entity, 14,",
            "                                                         domain1['id'])",
            "",
            "            # Should get back the 14 entities in domain1",
            "            hints = driver_hints.Hints()",
            "            hints.add_filter('domain_id', domain1['id'])",
            "            entities = self._list_entities(entity)(hints=hints)",
            "            self.assertEqual(14, len(entities))",
            "            self._match_with_list(entities, domain1_entity_list)",
            "            # Check the driver has removed the filter from the list hints",
            "            self.assertFalse(hints.get_exact_filter_by_name('domain_id'))",
            "",
            "            # Try filtering to get one an exact item out of the list",
            "            hints = driver_hints.Hints()",
            "            hints.add_filter('name', domain1_entity_list[10]['name'])",
            "            entities = self._list_entities(entity)(hints=hints)",
            "            self.assertEqual(1, len(entities))",
            "            self.assertEqual(entities[0]['id'], domain1_entity_list[10]['id'])",
            "            # Check the driver has removed the filter from the list hints",
            "            self.assertFalse(hints.get_exact_filter_by_name('name'))",
            "            self._delete_test_data(entity, entity_list)",
            "            self._delete_test_data(entity, domain1_entity_list)",
            "",
            "    def test_list_users_inexact_filtered(self):",
            "        # Create 20 users",
            "        user_list = self._create_test_data('user', 20)",
            "        # Set up some names that we can filter on",
            "        user = user_list[5]",
            "        user['name'] = 'The'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[6]",
            "        user['name'] = 'The Ministry'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[7]",
            "        user['name'] = 'The Ministry of'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[8]",
            "        user['name'] = 'The Ministry of Silly'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[9]",
            "        user['name'] = 'The Ministry of Silly Walks'",
            "        self.identity_api.update_user(user['id'], user)",
            "        # ...and one for useful case insensitivity testing",
            "        user = user_list[10]",
            "        user['name'] = 'The ministry of silly walks OF'",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'ministry', comparator='contains')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(5, len(users))",
            "        self._match_with_list(users, user_list,",
            "                              list_start=6, list_end=11)",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'The', comparator='startswith')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(6, len(users))",
            "        self._match_with_list(users, user_list,",
            "                              list_start=5, list_end=11)",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'of', comparator='endswith')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual(user_list[7]['id'], users[0]['id'])",
            "        self.assertEqual(user_list[10]['id'], users[1]['id'])",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        # TODO(henry-nash): Add some case sensitive tests.  The issue",
            "        # is that MySQL 0.7, by default, is installed in case",
            "        # insensitive mode (which is what is run by default for our",
            "        # SQL backend tests).  For production deployments. OpenStack",
            "        # assumes a case sensitive database.  For these tests, therefore, we",
            "        # need to be able to check the sensitivity of the database so as to",
            "        # know whether to run case sensitive tests here.",
            "",
            "        self._delete_test_data('user', user_list)",
            "",
            "    def test_filter_sql_injection_attack(self):",
            "        \"\"\"Test against sql injection attack on filters",
            "",
            "        Test Plan:",
            "        - Attempt to get all entities back by passing a two-term attribute",
            "        - Attempt to piggyback filter to damage DB (e.g. drop table)",
            "",
            "        \"\"\"",
            "        # Check we have some users",
            "        users = self.identity_api.list_users()",
            "        self.assertTrue(len(users) > 0)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', \"anything' or 'x'='x\")",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(0, len(users))",
            "",
            "        # See if we can add a SQL command...use the group table instead of the",
            "        # user table since 'user' is reserved word for SQLAlchemy.",
            "        group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', \"x'; drop table group\")",
            "        groups = self.identity_api.list_groups(hints=hints)",
            "        self.assertEqual(0, len(groups))",
            "",
            "        groups = self.identity_api.list_groups()",
            "        self.assertTrue(len(groups) > 0)",
            "",
            "",
            "class LimitTests(filtering.FilterTests):",
            "    ENTITIES = ['user', 'group', 'project']",
            "",
            "    def setUp(self):",
            "        \"\"\"Setup for Limit Test Cases.\"\"\"",
            "",
            "        self.domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(self.domain1['id'], self.domain1)",
            "        self.addCleanup(self.clean_up_domain)",
            "",
            "        self.entity_lists = {}",
            "        self.domain1_entity_lists = {}",
            "",
            "        for entity in self.ENTITIES:",
            "            # Create 20 entities, 14 of which are in domain1",
            "            self.entity_lists[entity] = self._create_test_data(entity, 6)",
            "            self.domain1_entity_lists[entity] = self._create_test_data(",
            "                entity, 14, self.domain1['id'])",
            "        self.addCleanup(self.clean_up_entities)",
            "",
            "    def clean_up_domain(self):",
            "        \"\"\"Clean up domain test data from Limit Test Cases.\"\"\"",
            "",
            "        self.domain1['enabled'] = False",
            "        self.assignment_api.update_domain(self.domain1['id'], self.domain1)",
            "        self.assignment_api.delete_domain(self.domain1['id'])",
            "        del self.domain1",
            "",
            "    def clean_up_entities(self):",
            "        \"\"\"Clean up entity test data from Limit Test Cases.\"\"\"",
            "        for entity in self.ENTITIES:",
            "            self._delete_test_data(entity, self.entity_lists[entity])",
            "            self._delete_test_data(entity, self.domain1_entity_lists[entity])",
            "        del self.entity_lists",
            "        del self.domain1_entity_lists",
            "",
            "    def _test_list_entity_filtered_and_limited(self, entity):",
            "        self.config_fixture.config(list_limit=10)",
            "        # Should get back just 10 entities in domain1",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('domain_id', self.domain1['id'])",
            "        entities = self._list_entities(entity)(hints=hints)",
            "        self.assertEqual(hints.get_limit()['limit'], len(entities))",
            "        self.assertTrue(hints.get_limit()['truncated'])",
            "        self._match_with_list(entities, self.domain1_entity_lists[entity])",
            "",
            "        # Override with driver specific limit",
            "        if entity == 'project':",
            "            self.config_fixture.config(group='assignment', list_limit=5)",
            "        else:",
            "            self.config_fixture.config(group='identity', list_limit=5)",
            "",
            "        # Should get back just 5 users in domain1",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('domain_id', self.domain1['id'])",
            "        entities = self._list_entities(entity)(hints=hints)",
            "        self.assertEqual(hints.get_limit()['limit'], len(entities))",
            "        self._match_with_list(entities, self.domain1_entity_lists[entity])",
            "",
            "        # Finally, let's pretend we want to get the full list of entities,",
            "        # even with the limits set, as part of some internal calculation.",
            "        # Calling the API without a hints list should achieve this, and",
            "        # return at least the 20 entries we created (there may be other",
            "        # entities lying around created by other tests/setup).",
            "        entities = self._list_entities(entity)()",
            "        self.assertTrue(len(entities) >= 20)",
            "",
            "    def test_list_users_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('user')",
            "",
            "    def test_list_groups_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('group')",
            "",
            "    def test_list_projects_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('project')"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import mock",
            "import uuid",
            "",
            "from keystoneclient.common import cms",
            "import six",
            "from testtools import matchers",
            "",
            "from keystone.catalog import core",
            "from keystone.common import driver_hints",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import filtering",
            "from keystone.tests import test_utils",
            "from keystone.token import provider",
            "",
            "",
            "CONF = config.CONF",
            "DEFAULT_DOMAIN_ID = CONF.identity.default_domain_id",
            "TIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'",
            "NULL_OBJECT = object()",
            "",
            "",
            "class IdentityTests(object):",
            "    def _get_domain_fixture(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        return domain",
            "",
            "    def test_project_add_and_remove_user_role(self):",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertNotIn(self.user_two['id'], user_ids)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            tenant_id=self.tenant_bar['id'],",
            "            user_id=self.user_two['id'],",
            "            role_id=self.role_other['id'])",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertIn(self.user_two['id'], user_ids)",
            "",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            tenant_id=self.tenant_bar['id'],",
            "            user_id=self.user_two['id'],",
            "            role_id=self.role_other['id'])",
            "",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_bar['id'])",
            "        self.assertNotIn(self.user_two['id'], user_ids)",
            "",
            "    def test_remove_user_role_not_assigned(self):",
            "        # Expect failure if attempt to remove a role that was never assigned to",
            "        # the user.",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.",
            "                          remove_role_from_user_and_project,",
            "                          tenant_id=self.tenant_bar['id'],",
            "                          user_id=self.user_two['id'],",
            "                          role_id=self.role_other['id'])",
            "",
            "    def test_authenticate_bad_user(self):",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=uuid.uuid4().hex,",
            "                          password=self.user_foo['password'])",
            "",
            "    def test_authenticate_bad_password(self):",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=self.user_foo['id'],",
            "                          password=uuid.uuid4().hex)",
            "",
            "    def test_authenticate(self):",
            "        user_ref = self.identity_api.authenticate(",
            "            context={},",
            "            user_id=self.user_sna['id'],",
            "            password=self.user_sna['password'])",
            "        # NOTE(termie): the password field is left in user_sna to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_sna.pop('password')",
            "        self.user_sna['enabled'] = True",
            "        self.assertDictEqual(user_ref, self.user_sna)",
            "",
            "    def test_authenticate_and_get_roles_no_metadata(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        user_ref = self.identity_api.authenticate(",
            "            context={},",
            "            user_id=user['id'],",
            "            password=user['password'])",
            "        self.assertNotIn('password', user_ref)",
            "        # NOTE(termie): the password field is left in user_sna to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        user.pop('password')",
            "        self.assertDictContainsSubset(user, user_ref)",
            "        role_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user['id'], self.tenant_baz['id'])",
            "        self.assertEqual(1, len(role_list))",
            "        self.assertIn(CONF.member_role_id, role_list)",
            "",
            "    def test_authenticate_if_no_password_set(self):",
            "        id_ = uuid.uuid4().hex",
            "        user = {",
            "            'id': id_,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=id_,",
            "                          password='password')",
            "",
            "    def test_create_unicode_user_name(self):",
            "        unicode_name = u'name \\u540d\\u5b57'",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': unicode_name,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        ref = self.identity_api.create_user(user['id'], user)",
            "        self.assertEqual(unicode_name, ref['name'])",
            "",
            "    def test_get_project(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "    def test_get_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_project_by_name(self):",
            "        tenant_ref = self.assignment_api.get_project_by_name(",
            "            self.tenant_bar['name'],",
            "            DEFAULT_DOMAIN_ID)",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "    def test_get_project_by_name_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project_by_name,",
            "                          uuid.uuid4().hex,",
            "                          DEFAULT_DOMAIN_ID)",
            "",
            "    def test_list_user_ids_for_project(self):",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            self.tenant_baz['id'])",
            "        self.assertEqual(2, len(user_ids))",
            "        self.assertIn(self.user_two['id'], user_ids)",
            "        self.assertIn(self.user_badguy['id'], user_ids)",
            "",
            "    def test_list_user_ids_for_project_no_duplicates(self):",
            "        # Create user",
            "        user_ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'password': uuid.uuid4().hex,",
            "            'enabled': True}",
            "        self.identity_api.create_user(user_ref['id'], user_ref)",
            "        # Create project",
            "        project_ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(",
            "            project_ref['id'], project_ref)",
            "        # Create 2 roles and give user each role in project",
            "        for i in range(2):",
            "            role_ref = {",
            "                'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role_ref['id'], role_ref)",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                user_id=user_ref['id'],",
            "                tenant_id=project_ref['id'],",
            "                role_id=role_ref['id'])",
            "        # Get the list of user_ids in project",
            "        user_ids = self.assignment_api.list_user_ids_for_project(",
            "            project_ref['id'])",
            "        # Ensure the user is only returned once",
            "        self.assertEqual(1, len(user_ids))",
            "",
            "    def test_get_project_user_ids_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.list_user_ids_for_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_user(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        # NOTE(termie): the password field is left in user_foo to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "    def test_get_user_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_user_by_name(self):",
            "        user_ref = self.identity_api.get_user_by_name(",
            "            self.user_foo['name'], DEFAULT_DOMAIN_ID)",
            "        # NOTE(termie): the password field is left in user_foo to make",
            "        #               it easier to authenticate in tests, but should",
            "        #               not be returned by the api",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "    def test_get_user_by_name_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user_by_name,",
            "                          uuid.uuid4().hex,",
            "                          DEFAULT_DOMAIN_ID)",
            "",
            "    def test_get_role(self):",
            "        role_ref = self.assignment_api.get_role(self.role_admin['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, self.role_admin)",
            "",
            "    def test_get_role_404(self):",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_duplicate_role_name_fails(self):",
            "        role = {'id': 'fake1',",
            "                'name': 'fake1name'}",
            "        self.assignment_api.create_role('fake1', role)",
            "        role['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_role,",
            "                          'fake2',",
            "                          role)",
            "",
            "    def test_rename_duplicate_role_name_fails(self):",
            "        role1 = {",
            "            'id': 'fake1',",
            "            'name': 'fake1name'",
            "        }",
            "        role2 = {",
            "            'id': 'fake2',",
            "            'name': 'fake2name'",
            "        }",
            "        self.assignment_api.create_role('fake1', role1)",
            "        self.assignment_api.create_role('fake2', role2)",
            "        role1['name'] = 'fake2name'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.update_role,",
            "                          'fake1',",
            "                          role1)",
            "",
            "    def test_create_duplicate_user_id_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_duplicate_user_name_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_user,",
            "                          'fake2',",
            "                          user)",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        user1 = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': uuid.uuid4().hex}",
            "        user2 = {'id': uuid.uuid4().hex,",
            "                 'name': user1['name'],",
            "                 'domain_id': new_domain['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        self.identity_api.create_user(user2['id'], user2)",
            "",
            "    def test_move_user_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': domain1['id'],",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['domain_id'] = domain2['id']",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a user in domain1",
            "        user1 = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        # Now create a user in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        user2 = {'id': uuid.uuid4().hex,",
            "                 'name': user1['name'],",
            "                 'domain_id': domain2['id'],",
            "                 'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user2['id'], user2)",
            "        # Now try and move user1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        user1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_user,",
            "                          user1['id'],",
            "                          user1)",
            "",
            "    def test_rename_duplicate_user_name_fails(self):",
            "        user1 = {'id': 'fake1',",
            "                 'name': 'fake1',",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': 'fakepass',",
            "                 'tenants': ['bar']}",
            "        user2 = {'id': 'fake2',",
            "                 'name': 'fake2',",
            "                 'domain_id': DEFAULT_DOMAIN_ID,",
            "                 'password': 'fakepass',",
            "                 'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user1)",
            "        self.identity_api.create_user('fake2', user2)",
            "        user2['name'] = 'fake1'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_user,",
            "                          'fake2',",
            "                          user2)",
            "",
            "    def test_update_user_id_fails(self):",
            "        user = {'id': 'fake1',",
            "                'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': 'fakepass',",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['id'] = 'fake2'",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual('fake1', user_ref['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          'fake2')",
            "",
            "    def test_create_duplicate_project_id_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_project,",
            "                          'fake1',",
            "                          tenant)",
            "",
            "    def test_create_duplicate_project_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['id'] = 'fake2'",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_project,",
            "                          'fake1',",
            "                          tenant)",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        tenant1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        tenant2 = {'id': uuid.uuid4().hex, 'name': tenant1['name'],",
            "                   'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(tenant1['id'], tenant1)",
            "        self.assignment_api.create_project(tenant2['id'], tenant2)",
            "",
            "    def test_move_project_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project['domain_id'] = domain2['id']",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a project in domain1",
            "        project1 = {'id': uuid.uuid4().hex,",
            "                    'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        # Now create a project in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        project2 = {'id': uuid.uuid4().hex,",
            "                    'name': project1['name'],",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        # Now try and move project1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        project1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.update_project,",
            "                          project1['id'],",
            "                          project1)",
            "",
            "    def test_rename_duplicate_project_name_fails(self):",
            "        tenant1 = {'id': 'fake1', 'name': 'fake1',",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        tenant2 = {'id': 'fake2', 'name': 'fake2',",
            "                   'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant1)",
            "        self.assignment_api.create_project('fake2', tenant2)",
            "        tenant2['name'] = 'fake1'",
            "        self.assertRaises(exception.Error,",
            "                          self.assignment_api.update_project,",
            "                          'fake2',",
            "                          tenant2)",
            "",
            "    def test_update_project_id_does_nothing(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['id'] = 'fake2'",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual('fake1', tenant_ref['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          'fake2')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        \"\"\"Test for unfiltered listing role assignments.",
            "",
            "        Test Plan:",
            "",
            "        - Create a domain, with a user, group & project",
            "        - Find how many role assignments already exist (from default",
            "          fixtures)",
            "        - Create a grant of each type (user/group on project/domain)",
            "        - Check the number of assignments has gone up by 4 and that",
            "          the entries we added are in the list returned",
            "        - Check that if we list assignments by role_id, then we get back",
            "          assignments that only contain that role.",
            "",
            "        \"\"\"",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grants already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "        existing_assignments_for_role = len(",
            "            self.assignment_api.list_role_assignments_for_role(",
            "                role_id='admin'))",
            "",
            "        # Now create the grants (roles are defined in default_fixtures)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='admin')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the full list of assignments - check it is gone up by 4",
            "        assignment_list = self.assignment_api.list_role_assignments()",
            "        self.assertEqual(existing_assignments + 4, len(assignment_list))",
            "",
            "        # Now check that each of our four new entries are in the list",
            "        self.assertIn(",
            "            {'user_id': new_user['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'member'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'user_id': new_user['id'], 'project_id': new_project['id'],",
            "             'role_id': 'other'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'project_id': new_project['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "",
            "        # Read back the list of assignments for just the admin role, checking",
            "        # this only goes up by two.",
            "        assignment_list = self.assignment_api.list_role_assignments_for_role(",
            "            role_id='admin')",
            "        self.assertEqual(existing_assignments_for_role + 2,",
            "                         len(assignment_list))",
            "",
            "        # Now check that each of our two new entries are in the list",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'domain_id': new_domain['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "        self.assertIn(",
            "            {'group_id': new_group['id'], 'project_id': new_project['id'],",
            "             'role_id': 'admin'},",
            "            assignment_list)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        assignment_list = self.assignment_api.list_role_assignments_for_role(",
            "            role_id=uuid.uuid4().hex)",
            "        self.assertEqual([], assignment_list)",
            "",
            "    def test_add_duplicate_role_grant(self):",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(self.role_admin['id'], roles_ref)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], self.role_admin['id'])",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          self.role_admin['id'])",
            "",
            "    def test_get_role_by_user_and_project_with_user_in_group(self):",
            "        \"\"\"Test for get role by user and project, user was added into a group.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user, a project & a group, add this user to group",
            "        - Create roles and grant them to user and project",
            "        - Check the role list get by the user and project was as expected",
            "",
            "        \"\"\"",
            "        user_ref = {'id': uuid.uuid4().hex,",
            "                    'name': uuid.uuid4().hex,",
            "                    'domain_id': DEFAULT_DOMAIN_ID,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "        self.identity_api.create_user(user_ref['id'], user_ref)",
            "",
            "        project_ref = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(project_ref['id'], project_ref)",
            "",
            "        group = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID}",
            "        group_id = self.identity_api.create_group(group['id'], group)['id']",
            "        self.identity_api.add_user_to_group(user_ref['id'], group_id)",
            "",
            "        role_ref_list = []",
            "        for i in range(2):",
            "            role_ref = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role_ref['id'], role_ref)",
            "            role_ref_list.append(role_ref)",
            "",
            "            self.assignment_api.add_role_to_user_and_project(",
            "                user_id=user_ref['id'],",
            "                tenant_id=project_ref['id'],",
            "                role_id=role_ref['id'])",
            "",
            "        role_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user_id=user_ref['id'],",
            "            tenant_id=project_ref['id'])",
            "",
            "        self.assertEqual(set(role_list),",
            "                         set([role_ref['id'] for role_ref in role_ref_list]))",
            "",
            "    def test_get_role_by_user_and_project(self):",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(self.role_admin['id'], roles_ref)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], self.role_admin['id'])",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref)",
            "        self.assertNotIn('member', roles_ref)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref)",
            "        self.assertIn('member', roles_ref)",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        \"\"\"Test for getting roles for user on a domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a domain, with 2 users",
            "        - Check no roles yet exit",
            "        - Give user1 two roles on the domain, user2 one role",
            "        - Get roles on user1 and the domain - maybe sure we only",
            "          get back the 2 roles on user1",
            "        - Delete both roles from user1",
            "        - Check we get no roles back for user1 on domain",
            "",
            "        \"\"\"",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user1['id'], new_user1)",
            "        new_user2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user2['id'], new_user2)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user1['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        # Now create the grants (roles are defined in default_fixtures)",
            "        self.assignment_api.create_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.create_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(user_id=new_user2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='admin')",
            "        # Read back the roles for user1 on domain",
            "        roles_ids = self.assignment_api.get_roles_for_user_and_domain(",
            "            new_user1['id'], new_domain['id'])",
            "        self.assertEqual(2, len(roles_ids))",
            "        self.assertIn(self.role_member['id'], roles_ids)",
            "        self.assertIn(self.role_other['id'], roles_ids)",
            "",
            "        # Now delete both grants for user1",
            "        self.assignment_api.delete_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        self.assignment_api.delete_grant(user_id=new_user1['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='other')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user1['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "    def test_get_roles_for_user_and_domain_404(self):",
            "        \"\"\"Test errors raised when getting roles for user on a domain.",
            "",
            "        Test Plan:",
            "",
            "        - Check non-existing user gives UserNotFound",
            "        - Check non-existing domain gives DomainNotFound",
            "",
            "        \"\"\"",
            "        new_domain = self._get_domain_fixture()",
            "        new_user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user1['id'], new_user1)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_domain,",
            "                          uuid.uuid4().hex,",
            "                          new_domain['id'])",
            "",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_domain,",
            "                          new_user1['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_get_roles_for_user_and_project_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_project,",
            "                          uuid.uuid4().hex,",
            "                          self.tenant_bar['id'])",
            "",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_roles_for_user_and_project,",
            "                          self.user_foo['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_add_role_to_user_and_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          uuid.uuid4().hex,",
            "                          self.role_admin['id'])",
            "",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.add_role_to_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_add_role_to_user_and_project_no_user(self):",
            "        # If add_role_to_user_and_project and the user doesn't exist, then",
            "        # no error.",
            "        user_id_not_exist = uuid.uuid4().hex",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id_not_exist, self.tenant_bar['id'], self.role_admin['id'])",
            "",
            "    def test_remove_role_from_user_and_project(self):",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        self.assignment_api.remove_role_from_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], 'member')",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn('member', roles_ref)",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.",
            "                          remove_role_from_user_and_project,",
            "                          self.user_foo['id'],",
            "                          self.tenant_bar['id'],",
            "                          'member')",
            "",
            "    def test_get_role_grant_by_user_and_project(self):",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertIn(self.role_admin['id'],",
            "                      [role_ref['id'] for role_ref in roles_ref])",
            "",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_bar['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(self.role_admin['id'], roles_ref_ids)",
            "        self.assertIn('member', roles_ref_ids)",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': 'secret', 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_group2 = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                      'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group2['id'], new_group2)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        new_user2 = {'id': uuid.uuid4().hex, 'name': 'new_user2',",
            "                     'password': uuid.uuid4().hex, 'enabled': True,",
            "                     'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user2['id'], new_user2)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        # First check we have no grants",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        # Now add the grant we are going to test for, and some others as",
            "        # well just to make sure we get back the right one",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "",
            "        self.assignment_api.create_grant(group_id=new_group2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(user_id=new_user2['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': 'secret', 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=new_user['id'],",
            "                                         domain_id=new_domain['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=new_user['id'],",
            "            domain_id=new_domain['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=new_user['id'],",
            "                          domain_id=new_domain['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        group1_domain1_role = {'id': uuid.uuid4().hex,",
            "                               'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(group1_domain1_role['id'],",
            "                                        group1_domain1_role)",
            "        group1_domain2_role = {'id': uuid.uuid4().hex,",
            "                               'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(group1_domain2_role['id'],",
            "                                        group1_domain2_role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': domain1['id'],",
            "                  'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=group1_domain1_role['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=group1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertDictEqual(roles_ref[0], group1_domain1_role)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertDictEqual(roles_ref[0], group1_domain2_role)",
            "",
            "        self.assignment_api.delete_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=group1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=group1['id'],",
            "                          domain_id=domain2['id'],",
            "                          role_id=group1_domain2_role['id'])",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        user1_domain1_role = {'id': uuid.uuid4().hex,",
            "                              'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(user1_domain1_role['id'],",
            "                                        user1_domain1_role)",
            "        user1_domain2_role = {'id': uuid.uuid4().hex,",
            "                              'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(user1_domain2_role['id'],",
            "                                        user1_domain2_role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=user1_domain1_role['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=user1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertDictEqual(roles_ref[0], user1_domain1_role)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertDictEqual(roles_ref[0], user1_domain2_role)",
            "",
            "        self.assignment_api.delete_grant(user_id=user1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=user1_domain2_role['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain2['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=user1['id'],",
            "                          domain_id=domain2['id'],",
            "                          role_id=user1_domain2_role['id'])",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        role2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role2['id'], role2)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role2['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(role1['id'], roles_ref_ids)",
            "        self.assertIn(role2['id'], roles_ref_ids)",
            "",
            "        self.assignment_api.delete_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assertDictEqual(roles_ref[0], role2)",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        role2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role2['id'], role2)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role2['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "",
            "        roles_ref_ids = []",
            "        for ref in roles_ref:",
            "            roles_ref_ids.append(ref['id'])",
            "        self.assertIn(role1['id'], roles_ref_ids)",
            "        self.assertIn(role2['id'], roles_ref_ids)",
            "",
            "        self.assignment_api.delete_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assertDictEqual(roles_ref[0], role2)",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        # Can delete a grant where the user doesn't exist.",
            "        role_id = uuid.uuid4().hex",
            "        role = {'id': role_id, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role_id, role)",
            "",
            "        user_id = uuid.uuid4().hex",
            "",
            "        self.assignment_api.create_grant(role_id, user_id=user_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "        self.assignment_api.delete_grant(role_id, user_id=user_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        # Can delete a grant where the group doesn't exist.",
            "        role_id = uuid.uuid4().hex",
            "        role = {'id': role_id, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role_id, role)",
            "",
            "        group_id = uuid.uuid4().hex",
            "",
            "        self.assignment_api.create_grant(role_id, group_id=group_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "        self.assignment_api.delete_grant(role_id, group_id=group_id,",
            "                                         project_id=self.tenant_bar['id'])",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        role_list = []",
            "        for _ in range(10):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[3]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[4]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[5]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[6]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[7]['id'])",
            "        roles_ref = self.assignment_api.list_grants(user_id=user1['id'],",
            "                                                    domain_id=domain1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[0], roles_ref)",
            "        self.assertIn(role_list[1], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(group_id=group1['id'],",
            "                                                    domain_id=domain1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[2], roles_ref)",
            "        self.assertIn(role_list[3], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(user_id=user1['id'],",
            "                                                    project_id=project1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[4], roles_ref)",
            "        self.assertIn(role_list[5], roles_ref)",
            "        roles_ref = self.assignment_api.list_grants(group_id=group1['id'],",
            "                                                    project_id=project1['id'])",
            "        self.assertEqual(2, len(roles_ref))",
            "        self.assertIn(role_list[6], roles_ref)",
            "        self.assertIn(role_list[7], roles_ref)",
            "",
            "        # Now test the alternate way of getting back lists of grants,",
            "        # where user and group roles are combined.  These should match",
            "        # the above results.",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(4, len(combined_list))",
            "        self.assertIn(role_list[4]['id'], combined_list)",
            "        self.assertIn(role_list[5]['id'], combined_list)",
            "        self.assertIn(role_list[6]['id'], combined_list)",
            "        self.assertIn(role_list[7]['id'], combined_list)",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(4, len(combined_role_list))",
            "        self.assertIn(role_list[0]['id'], combined_role_list)",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "        self.assertIn(role_list[2]['id'], combined_role_list)",
            "        self.assertIn(role_list[3]['id'], combined_role_list)",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        \"\"\"Test multiple group roles for user on project and domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create 6 roles",
            "        - Create a domain, with a project, user and two groups",
            "        - Make the user a member of both groups",
            "        - Check no roles yet exit",
            "        - Assign a role to each user and both groups on both the",
            "          project and domain",
            "        - Get a list of effective roles for the user on both the",
            "          project and domain, checking we get back the correct three",
            "          roles",
            "",
            "        \"\"\"",
            "        role_list = []",
            "        for _ in range(6):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[3]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[4]['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[5]['id'])",
            "",
            "        # Read by the roles, ensuring we get the correct 3 roles for",
            "        # both project and domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(3, len(combined_list))",
            "        self.assertIn(role_list[3]['id'], combined_list)",
            "        self.assertIn(role_list[4]['id'], combined_list)",
            "        self.assertIn(role_list[5]['id'], combined_list)",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(3, len(combined_role_list))",
            "        self.assertIn(role_list[0]['id'], combined_role_list)",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "        self.assertIn(role_list[2]['id'], combined_role_list)",
            "",
            "    def test_get_roles_for_user_and_project_user_group_same_id(self):",
            "        \"\"\"When a user has the same ID as a group,",
            "        get_roles_for_user_and_project returns only the roles for the user and",
            "        not the group.",
            "",
            "        \"\"\"",
            "",
            "        # Setup: create user, group with same ID, role, and project;",
            "        # assign the group the role on the project.",
            "",
            "        user_group_id = uuid.uuid4().hex",
            "",
            "        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID, }",
            "        self.identity_api.create_user(user_group_id, user1)",
            "",
            "        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                  'domain_id': DEFAULT_DOMAIN_ID, }",
            "        self.identity_api.create_group(user_group_id, group1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': DEFAULT_DOMAIN_ID, }",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.create_grant(role1['id'],",
            "                                         group_id=user_group_id,",
            "                                         project_id=project1['id'])",
            "",
            "        # Check the roles, shouldn't be any since the user wasn't granted any.",
            "        roles = self.assignment_api.get_roles_for_user_and_project(",
            "            user_group_id, project1['id'])",
            "",
            "        self.assertEqual([], roles, 'role for group is %s' % role1['id'])",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.assignment_api.delete_role(role1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.identity_api.add_user_to_group(user_id=user1['id'],",
            "                                            group_id=group1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.identity_api.check_user_in_group(",
            "            user_id=user1['id'],",
            "            group_id=group1['id'])",
            "        self.identity_api.delete_user(user1['id'])",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          user1['id'],",
            "                          group1['id'])",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role1['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role1['id'])",
            "        self.identity_api.add_user_to_group(user_id=user1['id'],",
            "                                            group_id=group1['id'])",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=group1['id'],",
            "            domain_id=domain1['id'])",
            "        self.assertEqual(1, len(roles_ref))",
            "        self.identity_api.check_user_in_group(",
            "            user_id=user1['id'],",
            "            group_id=group1['id'])",
            "        self.identity_api.delete_group(group1['id'])",
            "        self.identity_api.get_user(user1['id'])",
            "",
            "    def test_delete_domain_with_user_group_project_links(self):",
            "        # TODO(chungg):add test case once expected behaviour defined",
            "        pass",
            "",
            "    def test_role_crud(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role['id'], role)",
            "        role_ref = self.assignment_api.get_role(role['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, role)",
            "",
            "        role['name'] = uuid.uuid4().hex",
            "        updated_role_ref = self.assignment_api.update_role(role['id'], role)",
            "        role_ref = self.assignment_api.get_role(role['id'])",
            "        role_ref_dict = dict((x, role_ref[x]) for x in role_ref)",
            "        self.assertDictEqual(role_ref_dict, role)",
            "        self.assertDictEqual(role_ref_dict, updated_role_ref)",
            "",
            "        self.assignment_api.delete_role(role['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role['id'])",
            "",
            "    def test_update_role_404(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.update_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "    def test_add_user_to_project(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertIn(self.tenant_baz, tenants)",
            "",
            "    def test_add_user_to_project_missing_default_role(self):",
            "        self.assignment_api.delete_role(CONF.member_role_id)",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          CONF.member_role_id)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        tenants = (",
            "            self.assignment_api.list_projects_for_user(self.user_foo['id']))",
            "        self.assertIn(self.tenant_baz, tenants)",
            "        default_role = self.assignment_api.get_role(CONF.member_role_id)",
            "        self.assertIsNotNone(default_role)",
            "",
            "    def test_add_user_to_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.add_user_to_project,",
            "                          uuid.uuid4().hex,",
            "                          self.user_foo['id'])",
            "",
            "    def test_add_user_to_project_no_user(self):",
            "        # If add_user_to_project and the user doesn't exist, then",
            "        # no error.",
            "        user_id_not_exist = uuid.uuid4().hex",
            "        self.assignment_api.add_user_to_project(self.tenant_bar['id'],",
            "                                                user_id_not_exist)",
            "",
            "    def test_remove_user_from_project(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        self.assignment_api.remove_user_from_project(self.tenant_baz['id'],",
            "                                                     self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertNotIn(self.tenant_baz, tenants)",
            "",
            "    def test_remove_user_from_project_race_delete_role(self):",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                self.user_foo['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            tenant_id=self.tenant_baz['id'],",
            "            user_id=self.user_foo['id'],",
            "            role_id=self.role_other['id'])",
            "",
            "        # Mock a race condition, delete a role after",
            "        # get_roles_for_user_and_project() is called in",
            "        # remove_user_from_project().",
            "        roles = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_baz['id'])",
            "        self.assignment_api.delete_role(self.role_other['id'])",
            "        self.assignment_api.get_roles_for_user_and_project = mock.Mock(",
            "            return_value=roles)",
            "        self.assignment_api.remove_user_from_project(self.tenant_baz['id'],",
            "                                                     self.user_foo['id'])",
            "        tenants = self.assignment_api.list_projects_for_user(",
            "            self.user_foo['id'])",
            "        self.assertNotIn(self.tenant_baz, tenants)",
            "",
            "    def test_remove_user_from_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          uuid.uuid4().hex,",
            "                          self.user_foo['id'])",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          self.tenant_bar['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.remove_user_from_project,",
            "                          self.tenant_baz['id'],",
            "                          self.user_foo['id'])",
            "",
            "    def test_list_user_project_ids_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.update_project,",
            "                          uuid.uuid4().hex,",
            "                          dict())",
            "",
            "    def test_delete_project_404(self):",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.delete_project,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_user_404(self):",
            "        user_id = uuid.uuid4().hex",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.update_user,",
            "                          user_id,",
            "                          {'id': user_id,",
            "                           'domain_id': DEFAULT_DOMAIN_ID})",
            "",
            "    def test_delete_user_with_project_association(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_bar['id'],",
            "                                                user['id'])",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          user['id'])",
            "",
            "    def test_delete_user_with_project_roles(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user['id'],",
            "            self.tenant_bar['id'],",
            "            self.role_member['id'])",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.assignment_api.list_projects_for_user,",
            "                          user['id'])",
            "",
            "    def test_delete_user_404(self):",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.delete_user,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_role_404(self):",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.delete_role,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_update_delete_unicode_project(self):",
            "        unicode_project_name = u'name \\u540d\\u5b57'",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': unicode_project_name,",
            "                   'description': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        self.assignment_api.update_project(project['id'], project)",
            "        self.assignment_api.delete_project(project['id'])",
            "",
            "    def test_create_project_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "    def test_create_project_with_no_enabled_field(self):",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(ref['id'], ref)",
            "",
            "        project = self.assignment_api.get_project(ref['id'])",
            "        self.assertIs(project['enabled'], True)",
            "",
            "    def test_create_project_long_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'a' * 65,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_project_blank_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': '',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_project_invalid_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': None,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "        tenant = {'id': 'fake1', 'name': 123,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_blank_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = ''",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_long_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = 'a' * 65",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_update_project_invalid_name_fails(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1',",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant['name'] = None",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "        tenant['name'] = 123",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.update_project,",
            "                          tenant['id'],",
            "                          tenant)",
            "",
            "    def test_create_user_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower(),",
            "            'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.identity_api.create_user(ref['id'], ref)",
            "",
            "    def test_create_user_long_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'a' * 256,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_user_blank_name_fails(self):",
            "        user = {'id': 'fake1', 'name': '',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_create_user_missed_password(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        self.identity_api.get_user('fake1')",
            "        # Make sure  the user is not allowed to login",
            "        # with a password that  is empty string or None",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password='')",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password=None)",
            "",
            "    def test_create_user_none_password(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'password': None,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        self.identity_api.get_user('fake1')",
            "        # Make sure  the user is not allowed to login",
            "        # with a password that  is empty string or None",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password='')",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id='fake1',",
            "                          password=None)",
            "",
            "    def test_create_user_invalid_name_fails(self):",
            "        user = {'id': 'fake1', 'name': None,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "        user = {'id': 'fake1', 'name': 123,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_project_invalid_enabled_type_string(self):",
            "            project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'enabled': True,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "            self.assignment_api.create_project(project['id'], project)",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertEqual(True, project_ref['enabled'])",
            "",
            "            # Strings are not valid boolean values",
            "            project['enabled'] = \"false\"",
            "            self.assertRaises(exception.ValidationError,",
            "                              self.assignment_api.update_project,",
            "                              project['id'],",
            "                              project)",
            "",
            "    def test_create_project_invalid_enabled_type_string(self):",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   # invalid string value",
            "                   'enabled': \"true\"}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.assignment_api.create_project,",
            "                          project['id'],",
            "                          project)",
            "",
            "    def test_create_user_invalid_enabled_type_string(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'domain_id': DEFAULT_DOMAIN_ID,",
            "                'password': uuid.uuid4().hex,",
            "                # invalid string value",
            "                'enabled': \"true\"}",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.create_user,",
            "                          user['id'],",
            "                          user)",
            "",
            "    def test_update_user_long_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = 'a' * 256",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_user_blank_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user['name'] = ''",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_user_invalid_name_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1',",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "",
            "        user['name'] = None",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "        user['name'] = 123",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_list_users(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('password', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups(self):",
            "        group1 = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        group2 = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(2, len(groups))",
            "        group_ids = []",
            "        for group in groups:",
            "            group_ids.append(group.get('id'))",
            "        self.assertIn(group1['id'], group_ids)",
            "        self.assertIn(group2['id'], group_ids)",
            "",
            "    def test_list_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(3, len(domains))",
            "        domain_ids = []",
            "        for domain in domains:",
            "            domain_ids.append(domain.get('id'))",
            "        self.assertIn(DEFAULT_DOMAIN_ID, domain_ids)",
            "        self.assertIn(domain1['id'], domain_ids)",
            "        self.assertIn(domain2['id'], domain_ids)",
            "",
            "    def test_list_projects(self):",
            "        projects = self.assignment_api.list_projects()",
            "        self.assertEqual(4, len(projects))",
            "        project_ids = []",
            "        for project in projects:",
            "            project_ids.append(project.get('id'))",
            "        self.assertIn(self.tenant_bar['id'], project_ids)",
            "        self.assertIn(self.tenant_baz['id'], project_ids)",
            "",
            "    def test_list_projects_for_domain(self):",
            "        project_ids = ([x['id'] for x in",
            "                       self.assignment_api.list_projects_in_domain(",
            "                           DEFAULT_DOMAIN_ID)])",
            "        self.assertEqual(4, len(project_ids))",
            "        self.assertIn(self.tenant_bar['id'], project_ids)",
            "        self.assertIn(self.tenant_baz['id'], project_ids)",
            "        self.assertIn(self.tenant_mtu['id'], project_ids)",
            "        self.assertIn(self.tenant_service['id'], project_ids)",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        project_ids = ([x['id'] for x in",
            "                       self.assignment_api.list_projects_in_domain(",
            "                           domain1['id'])])",
            "        self.assertEqual(2, len(project_ids))",
            "        self.assertIn(project1['id'], project_ids)",
            "        self.assertIn(project2['id'], project_ids)",
            "",
            "    def test_list_roles(self):",
            "        roles = self.assignment_api.list_roles()",
            "        self.assertEqual(len(default_fixtures.ROLES), len(roles))",
            "        role_ids = set(role['id'] for role in roles)",
            "        expected_role_ids = set(role['id'] for role in default_fixtures.ROLES)",
            "        self.assertEqual(expected_role_ids, role_ids)",
            "",
            "    def test_delete_project_with_role_assignments(self):",
            "        tenant = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project(tenant['id'], tenant)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], tenant['id'], 'member')",
            "        self.assignment_api.delete_project(tenant['id'])",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.get_project,",
            "                          tenant['id'])",
            "",
            "    def test_delete_role_check_role_grant(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        alt_role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role['id'], role)",
            "        self.assignment_api.create_role(alt_role['id'], alt_role)",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], role['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'], alt_role['id'])",
            "        self.assignment_api.delete_role(role['id'])",
            "        roles_ref = self.assignment_api.get_roles_for_user_and_project(",
            "            self.user_foo['id'], self.tenant_bar['id'])",
            "        self.assertNotIn(role['id'], roles_ref)",
            "        self.assertIn(alt_role['id'], roles_ref)",
            "",
            "    def test_create_project_doesnt_modify_passed_in_dict(self):",
            "        new_project = {'id': 'tenant_id', 'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID}",
            "        original_project = new_project.copy()",
            "        self.assignment_api.create_project('tenant_id', new_project)",
            "        self.assertDictEqual(original_project, new_project)",
            "",
            "    def test_create_user_doesnt_modify_passed_in_dict(self):",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        original_user = new_user.copy()",
            "        self.identity_api.create_user('user_id', new_user)",
            "        self.assertDictEqual(original_user, new_user)",
            "",
            "    def test_update_user_enable(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        user['enabled'] = False",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(user['enabled'], user_ref['enabled'])",
            "",
            "        # If not present, enabled field should not be updated",
            "        del user['enabled']",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(False, user_ref['enabled'])",
            "",
            "        user['enabled'] = True",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(user['enabled'], user_ref['enabled'])",
            "",
            "        del user['enabled']",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        # Integers are valid Python's booleans. Explicitly test it.",
            "        user['enabled'] = 0",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(False, user_ref['enabled'])",
            "",
            "        # Any integers other than 0 are interpreted as True",
            "        user['enabled'] = -42",
            "        self.identity_api.update_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "    def test_update_user_name(self):",
            "        user = {'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex,",
            "                'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        self.assertEqual(user['name'], user_ref['name'])",
            "",
            "        changed_name = user_ref['name'] + '_changed'",
            "        user_ref['name'] = changed_name",
            "        updated_user = self.identity_api.update_user(user_ref['id'], user_ref)",
            "",
            "        # NOTE(dstanek): the SQL backend adds an 'extra' field containing a",
            "        #                dictionary of the extra fields in addition to the",
            "        #                fields in the object. For the details see:",
            "        #                SqlIdentity.test_update_project_returns_extra",
            "        updated_user.pop('extra', None)",
            "",
            "        self.assertDictEqual(user_ref, updated_user)",
            "",
            "        user_ref = self.identity_api.get_user(user_ref['id'])",
            "        self.assertEqual(changed_name, user_ref['name'])",
            "",
            "    def test_update_user_enable_fails(self):",
            "        user = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user('fake1', user)",
            "        user_ref = self.identity_api.get_user('fake1')",
            "        self.assertEqual(True, user_ref['enabled'])",
            "",
            "        # Strings are not valid boolean values",
            "        user['enabled'] = \"false\"",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.identity_api.update_user,",
            "                          'fake1',",
            "                          user)",
            "",
            "    def test_update_project_enable(self):",
            "        tenant = {'id': 'fake1', 'name': 'fake1', 'enabled': True,",
            "                  'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.assignment_api.create_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(True, tenant_ref['enabled'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(tenant['enabled'], tenant_ref['enabled'])",
            "",
            "        # If not present, enabled field should not be updated",
            "        del tenant['enabled']",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(False, tenant_ref['enabled'])",
            "",
            "        tenant['enabled'] = True",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(tenant['enabled'], tenant_ref['enabled'])",
            "",
            "        del tenant['enabled']",
            "        self.assignment_api.update_project('fake1', tenant)",
            "        tenant_ref = self.assignment_api.get_project('fake1')",
            "        self.assertEqual(True, tenant_ref['enabled'])",
            "",
            "    def test_add_user_to_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "",
            "        found = False",
            "        for x in groups:",
            "            if (x['id'] == new_group['id']):",
            "                found = True",
            "        self.assertTrue(found)",
            "",
            "    def test_add_user_to_group_404(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.add_user_to_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_check_user_in_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        self.identity_api.check_user_in_group(new_user['id'], new_group['id'])",
            "",
            "    def test_create_invalid_domain_fails(self):",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': \"doesnotexist\",",
            "                     'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.identity_api.create_group,",
            "                          new_group['id'],",
            "                          new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': \"doesnotexist\"}",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.identity_api.create_user,",
            "                          new_user['id'], new_user)",
            "",
            "    def test_check_user_not_in_group(self):",
            "        new_group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          new_user['id'],",
            "                          new_group['id'])",
            "",
            "    def test_check_user_in_group_404(self):",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        new_group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.check_user_in_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_list_users_in_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        # Make sure we get an empty list back on a new group, not an error.",
            "        user_refs = self.identity_api.list_users_in_group(new_group['id'])",
            "        self.assertEqual([], user_refs)",
            "        # Make sure we get the correct users back once they have been added",
            "        # to the group.",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        user_refs = self.identity_api.list_users_in_group(new_group['id'])",
            "        found = False",
            "        for x in user_refs:",
            "            if (x['id'] == new_user['id']):",
            "                found = True",
            "            self.assertNotIn('password', x)",
            "        self.assertTrue(found)",
            "",
            "    def test_list_users_in_group_404(self):",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.list_users_in_group,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_list_groups_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        test_groups = []",
            "        test_users = []",
            "        GROUP_COUNT = 3",
            "        USER_COUNT = 2",
            "",
            "        for x in range(0, USER_COUNT):",
            "            new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                        'password': uuid.uuid4().hex, 'enabled': True,",
            "                        'domain_id': domain['id']}",
            "            test_users.append(new_user)",
            "            self.identity_api.create_user(new_user['id'], new_user)",
            "        positive_user = test_users[0]",
            "        negative_user = test_users[1]",
            "",
            "        for x in range(0, USER_COUNT):",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                test_users[x]['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "        for x in range(0, GROUP_COUNT):",
            "            before_count = x",
            "            after_count = x + 1",
            "            new_group = {'id': uuid.uuid4().hex,",
            "                         'domain_id': domain['id'],",
            "                         'name': uuid.uuid4().hex}",
            "            self.identity_api.create_group(new_group['id'], new_group)",
            "            test_groups.append(new_group)",
            "",
            "            # add the user to the group and ensure that the",
            "            # group count increases by one for each",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(before_count, len(group_refs))",
            "            self.identity_api.add_user_to_group(",
            "                positive_user['id'],",
            "                new_group['id'])",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(after_count, len(group_refs))",
            "",
            "            # Make sure the group count for the unrelated user did not change",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                negative_user['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "        # remove the user from each group and ensure that",
            "        # the group count reduces by one for each",
            "        for x in range(0, 3):",
            "            before_count = GROUP_COUNT - x",
            "            after_count = GROUP_COUNT - x - 1",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(before_count, len(group_refs))",
            "            self.identity_api.remove_user_from_group(",
            "                positive_user['id'],",
            "                test_groups[x]['id'])",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                positive_user['id'])",
            "            self.assertEqual(after_count, len(group_refs))",
            "            # Make sure the group count for the unrelated user",
            "            # did not change",
            "            group_refs = self.identity_api.list_groups_for_user(",
            "                negative_user['id'])",
            "            self.assertEqual(0, len(group_refs))",
            "",
            "    def test_remove_user_from_group(self):",
            "        domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "        self.assertIn(new_group['id'], [x['id'] for x in groups])",
            "        self.identity_api.remove_user_from_group(new_user['id'],",
            "                                                 new_group['id'])",
            "        groups = self.identity_api.list_groups_for_user(new_user['id'])",
            "        self.assertNotIn(new_group['id'], [x['id'] for x in groups])",
            "",
            "    def test_remove_user_from_group_404(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          new_user['id'],",
            "                          uuid.uuid4().hex)",
            "",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          uuid.uuid4().hex,",
            "                          new_group['id'])",
            "",
            "        self.assertRaises(exception.NotFound,",
            "                          self.identity_api.remove_user_from_group,",
            "                          uuid.uuid4().hex,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_group_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        group = {'id': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictContainsSubset(group, group_ref)",
            "",
            "        group['name'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictContainsSubset(group, group_ref)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_duplicate_group_name_fails(self):",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': uuid.uuid4().hex}",
            "        group2 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': group1['name']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.create_group,",
            "                          group2['id'], group2)",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        new_domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(new_domain['id'], new_domain)",
            "        group1 = {'id': uuid.uuid4().hex, 'domain_id': DEFAULT_DOMAIN_ID,",
            "                  'name': uuid.uuid4().hex}",
            "        group2 = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                  'name': group1['name']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "    def test_move_group_between_domains(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        group = {'id': uuid.uuid4().hex,",
            "                 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id']}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group['domain_id'] = domain2['id']",
            "        self.identity_api.update_group(group['id'], group)",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        # First, create a group in domain1",
            "        group1 = {'id': uuid.uuid4().hex,",
            "                  'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        # Now create a group in domain2 with a potentially clashing",
            "        # name - which should work since we have domain separation",
            "        group2 = {'id': uuid.uuid4().hex,",
            "                  'name': group1['name'],",
            "                  'domain_id': domain2['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        # Now try and move group1 into the 2nd domain - which should",
            "        # fail since the names clash",
            "        group1['domain_id'] = domain2['id']",
            "        self.assertRaises(exception.Conflict,",
            "                          self.identity_api.update_group,",
            "                          group1['id'],",
            "                          group1)",
            "",
            "    def test_project_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictContainsSubset(project, project_ref)",
            "",
            "        project['name'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictContainsSubset(project, project_ref)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_project_update_missing_attrs_with_a_value(self):",
            "        # Creating a project with no description attribute.",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   'enabled': True}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # Add a description attribute.",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "    def test_project_update_missing_attrs_with_a_falsey_value(self):",
            "        # Creating a project with no description attribute.",
            "        project = {'id': uuid.uuid4().hex,",
            "                   'name': uuid.uuid4().hex,",
            "                   'domain_id': DEFAULT_DOMAIN_ID,",
            "                   'enabled': True}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # Add a description attribute.",
            "        project['description'] = ''",
            "        self.assignment_api.update_project(project['id'], project)",
            "",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        domain_ref = self.assignment_api.get_domain(domain['id'])",
            "        self.assertDictEqual(domain_ref, domain)",
            "",
            "        domain['name'] = uuid.uuid4().hex",
            "        self.assignment_api.update_domain(domain['id'], domain)",
            "        domain_ref = self.assignment_api.get_domain(domain['id'])",
            "        self.assertDictEqual(domain_ref, domain)",
            "",
            "        # Ensure an 'enabled' domain cannot be deleted",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_domain,",
            "                          domain_id=domain['id'])",
            "",
            "        # Disable the domain",
            "        domain['enabled'] = False",
            "        self.assignment_api.update_domain(domain['id'], domain)",
            "",
            "        # Delete the domain",
            "        self.assignment_api.delete_domain(domain['id'])",
            "",
            "        # Make sure the domain no longer exists",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # create a ref with a lowercase name",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex.lower()}",
            "        self.assignment_api.create_domain(ref['id'], ref)",
            "",
            "        # assign a new ID with the same name, but this time in uppercase",
            "        ref['id'] = uuid.uuid4().hex",
            "        ref['name'] = ref['name'].upper()",
            "        self.assignment_api.create_domain(ref['id'], ref)",
            "",
            "    def test_attribute_update(self):",
            "        project = {",
            "            'domain_id': DEFAULT_DOMAIN_ID,",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_project(project['id'], project)",
            "",
            "        # pick a key known to be non-existent",
            "        key = 'description'",
            "",
            "        def assert_key_equals(value):",
            "            project_ref = self.assignment_api.update_project(",
            "                project['id'], project)",
            "            self.assertEqual(value, project_ref[key])",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertEqual(value, project_ref[key])",
            "",
            "        def assert_get_key_is(value):",
            "            project_ref = self.assignment_api.update_project(",
            "                project['id'], project)",
            "            self.assertIs(project_ref.get(key), value)",
            "            project_ref = self.assignment_api.get_project(project['id'])",
            "            self.assertIs(project_ref.get(key), value)",
            "",
            "        # add an attribute that doesn't exist, set it to a falsey value",
            "        value = ''",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "        # set an attribute with a falsey value to null",
            "        value = None",
            "        project[key] = value",
            "        assert_get_key_is(value)",
            "",
            "        # do it again, in case updating from this situation is handled oddly",
            "        value = None",
            "        project[key] = value",
            "        assert_get_key_is(value)",
            "",
            "        # set a possibly-null value to a falsey value",
            "        value = ''",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "        # set a falsey value to a truthy value",
            "        value = uuid.uuid4().hex",
            "        project[key] = value",
            "        assert_key_equals(value)",
            "",
            "    def test_user_crud(self):",
            "        user = {'domain_id': DEFAULT_DOMAIN_ID,",
            "                'id': uuid.uuid4().hex,",
            "                'name': uuid.uuid4().hex, 'password': 'passw0rd'}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictContainsSubset(user, user_ref_dict)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictContainsSubset(user, user_ref_dict)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        # Create two groups each with a role on a different project, and",
            "        # make user1 a member of both groups.  Both these new projects",
            "        # should now be included, along with any direct user grants.",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        self.identity_api.add_user_to_group(user1['id'], group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'], group2['id'])",
            "",
            "        # Create 3 grants, one user grant, the other two as group grants",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(3, len(user_projects))",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        domain_id = domain['id']",
            "        # Create Domain",
            "        self.assignment_api.create_domain(domain_id, domain)",
            "        domain_ref = self.assignment_api.get_domain(domain_id)",
            "        updated_domain_ref = copy.deepcopy(domain_ref)",
            "        updated_domain_ref['name'] = uuid.uuid4().hex",
            "        # Update domain, bypassing assignment api manager",
            "        self.assignment_api.driver.update_domain(domain_id, updated_domain_ref)",
            "        # Verify get_domain still returns the domain",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_domain.invalidate(self.assignment_api,",
            "                                                  domain_id)",
            "        # Verify get_domain returns the updated domain",
            "        self.assertDictContainsSubset(",
            "            updated_domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Update the domain back to original ref, using the assignment api",
            "        # manager",
            "        self.assignment_api.update_domain(domain_id, domain_ref)",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Make sure domain is 'disabled', bypass assignment api manager",
            "        domain_ref_disabled = domain_ref.copy()",
            "        domain_ref_disabled['enabled'] = False",
            "        self.assignment_api.driver.update_domain(domain_id,",
            "                                                 domain_ref_disabled)",
            "        # Delete domain, bypassing assignment api manager",
            "        self.assignment_api.driver.delete_domain(domain_id)",
            "        # Verify get_domain still returns the domain",
            "        self.assertDictContainsSubset(",
            "            domain_ref, self.assignment_api.get_domain(domain_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_domain.invalidate(self.assignment_api,",
            "                                                  domain_id)",
            "        # Verify get_domain now raises DomainNotFound",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain, domain_id)",
            "        # Recreate Domain",
            "        self.assignment_api.create_domain(domain_id, domain)",
            "        self.assignment_api.get_domain(domain_id)",
            "        # Make sure domain is 'disabled', bypass assignment api manager",
            "        domain['enabled'] = False",
            "        self.assignment_api.driver.update_domain(domain_id, domain)",
            "        # Delete domain",
            "        self.assignment_api.delete_domain(domain_id)",
            "        # verify DomainNotFound raised",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain_id)",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True}",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': domain['id']}",
            "        project_id = project['id']",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['name'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_role_crud(self):",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        role_id = role['id']",
            "        # Create role",
            "        self.assignment_api.create_role(role_id, role)",
            "        role_ref = self.assignment_api.get_role(role_id)",
            "        updated_role_ref = copy.deepcopy(role_ref)",
            "        updated_role_ref['name'] = uuid.uuid4().hex",
            "        # Update role, bypassing the assignment api manager",
            "        self.assignment_api.driver.update_role(role_id, updated_role_ref)",
            "        # Verify get_role still returns old ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Invalidate Cache",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                role_id)",
            "        # Verify get_role returns the new role_ref",
            "        self.assertDictEqual(updated_role_ref,",
            "                             self.assignment_api.get_role(role_id))",
            "        # Update role back to original via the assignment api manager",
            "        self.assignment_api.update_role(role_id, role_ref)",
            "        # Verify get_role returns the original role ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Delete role bypassing the assignment api manager",
            "        self.assignment_api.driver.delete_role(role_id)",
            "        # Verify get_role still returns the role_ref",
            "        self.assertDictEqual(role_ref, self.assignment_api.get_role(role_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_role.invalidate(self.assignment_api, role_id)",
            "        # Verify RoleNotFound is now raised",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role_id)",
            "        # recreate role",
            "        self.assignment_api.create_role(role_id, role)",
            "        self.assignment_api.get_role(role_id)",
            "        # delete role via the assignment api manager",
            "        self.assignment_api.delete_role(role_id)",
            "        # verity RoleNotFound is now raised",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          role_id)",
            "",
            "    def create_user_dict(self, **attributes):",
            "        user_dict = {'id': uuid.uuid4().hex,",
            "                     'name': uuid.uuid4().hex,",
            "                     'domain_id': DEFAULT_DOMAIN_ID,",
            "                     'enabled': True}",
            "        user_dict.update(attributes)",
            "        return user_dict",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "",
            "        self.assertEqual(attr_value, user['arbitrary_attr'])",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        self.identity_api.create_user(user_data['id'], user_data)",
            "",
            "        user = self.identity_api.get_user(user_data['id'])",
            "        self.assertEqual(attr_value, user['arbitrary_attr'])",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        user_data = self.create_user_dict()",
            "",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "        attr_value = uuid.uuid4().hex",
            "        user['arbitrary_attr'] = attr_value",
            "        updated_user = self.identity_api.update_user(user['id'], user)",
            "",
            "        self.assertEqual(attr_value, updated_user['arbitrary_attr'])",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        attr_value = uuid.uuid4().hex",
            "        user_data = self.create_user_dict(arbitrary_attr=attr_value)",
            "",
            "        new_attr_value = uuid.uuid4().hex",
            "        user = self.identity_api.create_user(user_data['id'], user_data)",
            "        user['arbitrary_attr'] = new_attr_value",
            "        updated_user = self.identity_api.update_user(user['id'], user)",
            "",
            "        self.assertEqual(new_attr_value, updated_user['arbitrary_attr'])",
            "",
            "    def test_create_grant_no_user(self):",
            "        # If call create_grant with a user that doesn't exist, doesn't fail.",
            "        self.assignment_api.create_grant(",
            "            self.role_other['id'],",
            "            user_id=uuid.uuid4().hex,",
            "            project_id=self.tenant_bar['id'])",
            "",
            "    def test_create_grant_no_group(self):",
            "        # If call create_grant with a group that doesn't exist, doesn't fail.",
            "        self.assignment_api.create_grant(",
            "            self.role_other['id'],",
            "            group_id=uuid.uuid4().hex,",
            "            project_id=self.tenant_bar['id'])",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain_name = 'default'",
            "",
            "        domain = {'id': uuid.uuid4().hex, 'name': domain_name, 'enabled': True}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain_name)",
            "        self.assertEqual(domain, domain_ref)",
            "",
            "    def test_get_not_default_domain_by_name(self):",
            "        domain_name = 'foo'",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain_by_name,",
            "                          domain_name)",
            "",
            "",
            "class TokenTests(object):",
            "    def _create_token_id(self):",
            "        # Use a token signed by the cms module",
            "        token_id = \"\"",
            "        for i in range(1, 20):",
            "            token_id += uuid.uuid4().hex",
            "        return cms.cms_sign_token(token_id,",
            "                                  CONF.signing.certfile,",
            "                                  CONF.signing.keyfile)",
            "",
            "    def test_token_crud(self):",
            "        token_id = self._create_token_id()",
            "        data = {'id': token_id, 'a': 'b',",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        expires = data_ref.pop('expires')",
            "        data_ref.pop('user_id')",
            "        self.assertIsInstance(expires, datetime.datetime)",
            "        data_ref.pop('id')",
            "        data.pop('id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        new_data_ref = self.token_api.get_token(token_id)",
            "        expires = new_data_ref.pop('expires')",
            "        self.assertIsInstance(expires, datetime.datetime)",
            "        new_data_ref.pop('user_id')",
            "        new_data_ref.pop('id')",
            "",
            "        self.assertEqual(data, new_data_ref)",
            "",
            "        self.token_api.delete_token(token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.delete_token, token_id)",
            "",
            "    def create_token_sample_data(self, token_id=None, tenant_id=None,",
            "                                 trust_id=None, user_id=None, expires=None):",
            "        if token_id is None:",
            "            token_id = self._create_token_id()",
            "        if user_id is None:",
            "            user_id = 'testuserid'",
            "        # FIXME(morganfainberg): These tokens look nothing like \"Real\" tokens.",
            "        # This should be updated when token_api is updated to merge in the",
            "        # issue_token logic from the providers (token issuance should be a",
            "        # pipeline).  The fix should be in implementation of blueprint:",
            "        # token-issuance-pipeline",
            "        data = {'id': token_id, 'a': 'b',",
            "                'user': {'id': user_id}}",
            "        if tenant_id is not None:",
            "            data['tenant'] = {'id': tenant_id, 'name': tenant_id}",
            "        if tenant_id is NULL_OBJECT:",
            "            data['tenant'] = None",
            "        if expires is not None:",
            "            data['expires'] = expires",
            "        if trust_id is not None:",
            "            data['trust_id'] = trust_id",
            "            data.setdefault('access', {}).setdefault('trust', {})",
            "            # Testuserid2 is used here since a trustee will be different in",
            "            # the cases of impersonation and therefore should not match the",
            "            # token's user_id.",
            "            data['access']['trust']['trustee_user_id'] = 'testuserid2'",
            "        data['token_version'] = provider.V2",
            "        # Issue token stores a copy of all token data at token['token_data'].",
            "        # This emulates that assumption as part of the test.",
            "        data['token_data'] = copy.deepcopy(data)",
            "        new_token = self.token_api.create_token(token_id, data)",
            "        return new_token['id'], data",
            "",
            "    def test_delete_tokens(self):",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid')",
            "        token_id2, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid')",
            "        token_id3, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            user_id='testuserid1')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(2, len(tokens))",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_tokens(user_id='testuserid',",
            "                                     tenant_id='testtenantid')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id1)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id2)",
            "",
            "        self.token_api.get_token(token_id3)",
            "",
            "    def test_delete_tokens_trust(self):",
            "        tokens = self.token_api._list_tokens(user_id='testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            trust_id='testtrustid')",
            "        token_id2, data = self.create_token_sample_data(",
            "            tenant_id='testtenantid',",
            "            user_id='testuserid1',",
            "            trust_id='testtrustid1')",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_tokens(user_id='testuserid',",
            "                                     tenant_id='testtenantid',",
            "                                     trust_id='testtrustid')",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id1)",
            "        self.token_api.get_token(token_id2)",
            "",
            "    def _test_token_list(self, token_list_fn):",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(0, len(tokens))",
            "        token_id1, data = self.create_token_sample_data()",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id1, tokens)",
            "        token_id2, data = self.create_token_sample_data()",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(2, len(tokens))",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertIn(token_id1, tokens)",
            "        self.token_api.delete_token(token_id1)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertIn(token_id2, tokens)",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.token_api.delete_token(token_id2)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertNotIn(token_id1, tokens)",
            "",
            "        # tenant-specific tokens",
            "        tenant1 = uuid.uuid4().hex",
            "        tenant2 = uuid.uuid4().hex",
            "        token_id3, data = self.create_token_sample_data(tenant_id=tenant1)",
            "        token_id4, data = self.create_token_sample_data(tenant_id=tenant2)",
            "        # test for existing but empty tenant (LP:1078497)",
            "        token_id5, data = self.create_token_sample_data(tenant_id=NULL_OBJECT)",
            "        tokens = token_list_fn('testuserid')",
            "        self.assertEqual(3, len(tokens))",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertIn(token_id3, tokens)",
            "        self.assertIn(token_id4, tokens)",
            "        self.assertIn(token_id5, tokens)",
            "        tokens = token_list_fn('testuserid', tenant2)",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertNotIn(token_id1, tokens)",
            "        self.assertNotIn(token_id2, tokens)",
            "        self.assertNotIn(token_id3, tokens)",
            "        self.assertIn(token_id4, tokens)",
            "",
            "    def test_token_list(self):",
            "        self._test_token_list(self.token_api._list_tokens)",
            "",
            "    def test_token_list_deprecated_public_interface(self):",
            "        # TODO(morganfainberg): Remove once token_api.list_tokens is removed",
            "        # (post Icehouse release)",
            "        self._test_token_list(self.token_api.list_tokens)",
            "",
            "    def test_token_list_trust(self):",
            "        trust_id = uuid.uuid4().hex",
            "        token_id5, data = self.create_token_sample_data(trust_id=trust_id)",
            "        tokens = self.token_api._list_tokens('testuserid', trust_id=trust_id)",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id5, tokens)",
            "",
            "    def test_get_token_404(self):",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token,",
            "                          uuid.uuid4().hex)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token,",
            "                          None)",
            "",
            "    def test_delete_token_404(self):",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.delete_token,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_expired_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() - datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.token_api.get_token, token_id)",
            "",
            "    def test_null_expires_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        data = {'id': token_id, 'id_hash': token_id, 'a': 'b', 'expires': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        self.assertIsNotNone(data_ref['expires'])",
            "        new_data_ref = self.token_api.get_token(token_id)",
            "",
            "        # MySQL doesn't store microseconds, so discard them before testing",
            "        data_ref['expires'] = data_ref['expires'].replace(microsecond=0)",
            "        new_data_ref['expires'] = new_data_ref['expires'].replace(",
            "            microsecond=0)",
            "",
            "        self.assertEqual(data_ref, new_data_ref)",
            "",
            "    def check_list_revoked_tokens(self, token_ids):",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        for token_id in token_ids:",
            "            self.assertIn(token_id, revoked_ids)",
            "",
            "    def delete_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        self.token_api.delete_token(token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_api.get_token,",
            "            data_ref['id'])",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_api.delete_token,",
            "            data_ref['id'])",
            "        return token_id",
            "",
            "    def test_list_revoked_tokens_returns_empty_list(self):",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertEqual([], revoked_ids)",
            "",
            "    def test_list_revoked_tokens_for_single_token(self):",
            "        self.check_list_revoked_tokens([self.delete_token()])",
            "",
            "    def test_list_revoked_tokens_for_multiple_tokens(self):",
            "        self.check_list_revoked_tokens([self.delete_token()",
            "                                        for x in six.moves.range(2)])",
            "",
            "    def test_flush_expired_token(self):",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() - datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        token_id = uuid.uuid4().hex",
            "        expire_time = timeutils.utcnow() + datetime.timedelta(minutes=1)",
            "        data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                'expires': expire_time,",
            "                'trust_id': None,",
            "                'user': {'id': 'testuserid'}}",
            "        data_ref = self.token_api.create_token(token_id, data)",
            "        data_ref.pop('user_id')",
            "        self.assertDictEqual(data_ref, data)",
            "",
            "        self.token_api.flush_expired_tokens()",
            "        tokens = self.token_api._list_tokens('testuserid')",
            "        self.assertEqual(1, len(tokens))",
            "        self.assertIn(token_id, tokens)",
            "",
            "    @tests.skip_if_cache_disabled('token')",
            "    def test_revocation_list_cache(self):",
            "        expire_time = timeutils.utcnow() + datetime.timedelta(minutes=10)",
            "        token_id = uuid.uuid4().hex",
            "        token_data = {'id_hash': token_id, 'id': token_id, 'a': 'b',",
            "                      'expires': expire_time,",
            "                      'trust_id': None,",
            "                      'user': {'id': 'testuserid'}}",
            "        token2_id = uuid.uuid4().hex",
            "        token2_data = {'id_hash': token2_id, 'id': token2_id, 'a': 'b',",
            "                       'expires': expire_time,",
            "                       'trust_id': None,",
            "                       'user': {'id': 'testuserid'}}",
            "        # Create 2 Tokens.",
            "        self.token_api.create_token(token_id, token_data)",
            "        self.token_api.create_token(token2_id, token2_data)",
            "        # Verify the revocation list is empty.",
            "        self.assertEqual([], self.token_api.list_revoked_tokens())",
            "        # Delete a token directly, bypassing the manager.",
            "        self.token_api.driver.delete_token(token_id)",
            "        # Verify the revocation list is still empty.",
            "        self.assertEqual([], self.token_api.list_revoked_tokens())",
            "        # Invalidate the revocation list.",
            "        self.token_api.invalidate_revocation_list()",
            "        # Verify the deleted token is in the revocation list.",
            "        revoked_tokens = [x['id']",
            "                          for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id, revoked_tokens)",
            "        # Delete the second token, through the manager",
            "        self.token_api.delete_token(token2_id)",
            "        revoked_tokens = [x['id']",
            "                          for x in self.token_api.list_revoked_tokens()]",
            "        # Verify both tokens are in the revocation list.",
            "        self.assertIn(token_id, revoked_tokens)",
            "        self.assertIn(token2_id, revoked_tokens)",
            "",
            "    def _test_predictable_revoked_pki_token_id(self, hash_fn):",
            "        token_id = self._create_token_id()",
            "        token_id_hash = hash_fn(token_id).hexdigest()",
            "        token = {'user': {'id': uuid.uuid4().hex}}",
            "",
            "        self.token_api.create_token(token_id, token)",
            "        self.token_api.delete_token(token_id)",
            "",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id_hash, revoked_ids)",
            "        self.assertNotIn(token_id, revoked_ids)",
            "        for t in self.token_api.list_revoked_tokens():",
            "            self.assertIn('expires', t)",
            "",
            "    def test_predictable_revoked_pki_token_id_default(self):",
            "        self._test_predictable_revoked_pki_token_id(hashlib.md5)",
            "",
            "    def test_predictable_revoked_pki_token_id_sha256(self):",
            "        self.config_fixture.config(group='token', hash_algorithm='sha256')",
            "        self._test_predictable_revoked_pki_token_id(hashlib.sha256)",
            "",
            "    def test_predictable_revoked_uuid_token_id(self):",
            "        token_id = uuid.uuid4().hex",
            "        token = {'user': {'id': uuid.uuid4().hex}}",
            "",
            "        self.token_api.create_token(token_id, token)",
            "        self.token_api.delete_token(token_id)",
            "",
            "        revoked_ids = [x['id'] for x in self.token_api.list_revoked_tokens()]",
            "        self.assertIn(token_id, revoked_ids)",
            "        for t in self.token_api.list_revoked_tokens():",
            "            self.assertIn('expires', t)",
            "",
            "    def test_create_unicode_token_id(self):",
            "        token_id = six.text_type(self._create_token_id())",
            "        self.create_token_sample_data(token_id=token_id)",
            "        self.token_api.get_token(token_id)",
            "",
            "    def test_create_unicode_user_id(self):",
            "        user_id = six.text_type(uuid.uuid4().hex)",
            "        token_id, data = self.create_token_sample_data(user_id=user_id)",
            "        self.token_api.get_token(token_id)",
            "",
            "    def test_list_tokens_unicode_user_id(self):",
            "        user_id = six.text_type(uuid.uuid4().hex)",
            "        self.token_api.list_tokens(user_id)",
            "",
            "    def test_token_expire_timezone(self):",
            "",
            "        @test_utils.timezone",
            "        def _create_token(expire_time):",
            "            token_id = uuid.uuid4().hex",
            "            user_id = six.text_type(uuid.uuid4().hex)",
            "            return self.create_token_sample_data(token_id=token_id,",
            "                                                 user_id=user_id,",
            "                                                 expires=expire_time)",
            "",
            "        for d in ['+0', '-11', '-8', '-5', '+5', '+8', '+14']:",
            "            test_utils.TZ = 'UTC' + d",
            "            expire_time = timeutils.utcnow() + datetime.timedelta(minutes=1)",
            "            token_id, data_in = _create_token(expire_time)",
            "            data_get = self.token_api.get_token(token_id)",
            "",
            "            self.assertEqual(data_in['id'], data_get['id'],",
            "                             'TZ=%s' % test_utils.TZ)",
            "",
            "            expire_time_expired = (",
            "                timeutils.utcnow() + datetime.timedelta(minutes=-1))",
            "            token_id, data_in = _create_token(expire_time_expired)",
            "            self.assertRaises(exception.TokenNotFound,",
            "                              self.token_api.get_token, data_in['id'])",
            "",
            "",
            "class TokenCacheInvalidation(object):",
            "    def _create_test_data(self):",
            "        self.user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'password': uuid.uuid4().hex,",
            "                     'domain_id': DEFAULT_DOMAIN_ID, 'enabled': True}",
            "        self.tenant = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                       'domain_id': DEFAULT_DOMAIN_ID, 'enabled': True}",
            "",
            "        # Create an equivalent of a scoped token",
            "        token_dict = {'user': self.user, 'tenant': self.tenant,",
            "                      'metadata': {}, 'id': 'placeholder'}",
            "        token_id, data = self.token_provider_api.issue_v2_token(token_dict)",
            "        self.scoped_token_id = token_id",
            "",
            "        # ..and an un-scoped one",
            "        token_dict = {'user': self.user, 'tenant': None,",
            "                      'metadata': {}, 'id': 'placeholder'}",
            "        token_id, data = self.token_provider_api.issue_v2_token(token_dict)",
            "        self.unscoped_token_id = token_id",
            "",
            "        # Validate them, in the various ways possible - this will load the",
            "        # responses into the token cache.",
            "        self._check_scoped_tokens_are_valid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "    def _check_unscoped_tokens_are_invalid(self):",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.unscoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.unscoped_token_id)",
            "",
            "    def _check_scoped_tokens_are_invalid(self):",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.scoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_token,",
            "            self.scoped_token_id,",
            "            self.tenant['id'])",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.scoped_token_id)",
            "        self.assertRaises(",
            "            exception.TokenNotFound,",
            "            self.token_provider_api.validate_v2_token,",
            "            self.scoped_token_id,",
            "            self.tenant['id'])",
            "",
            "    def _check_scoped_tokens_are_valid(self):",
            "        self.token_provider_api.validate_token(self.scoped_token_id)",
            "        self.token_provider_api.validate_token(",
            "            self.scoped_token_id, belongs_to=self.tenant['id'])",
            "        self.token_provider_api.validate_v2_token(self.scoped_token_id)",
            "        self.token_provider_api.validate_v2_token(",
            "            self.scoped_token_id, belongs_to=self.tenant['id'])",
            "",
            "    def _check_unscoped_tokens_are_valid(self):",
            "        self.token_provider_api.validate_token(self.unscoped_token_id)",
            "        self.token_provider_api.validate_v2_token(self.unscoped_token_id)",
            "",
            "    def test_delete_unscoped_token(self):",
            "        self.token_api.delete_token(self.unscoped_token_id)",
            "        self._check_unscoped_tokens_are_invalid()",
            "        self._check_scoped_tokens_are_valid()",
            "",
            "    def test_delete_scoped_token_by_id(self):",
            "        self.token_api.delete_token(self.scoped_token_id)",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "    def test_delete_scoped_token_by_user(self):",
            "        self.token_api.delete_tokens(self.user['id'])",
            "        # Since we are deleting all tokens for this user, they should all",
            "        # now be invalid.",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_invalid()",
            "",
            "    def test_delete_scoped_token_by_user_and_tenant(self):",
            "        self.token_api.delete_tokens(self.user['id'],",
            "                                     tenant_id=self.tenant['id'])",
            "        self._check_scoped_tokens_are_invalid()",
            "        self._check_unscoped_tokens_are_valid()",
            "",
            "",
            "class TrustTests(object):",
            "    def create_sample_trust(self, new_id, remaining_uses=None):",
            "        self.trustor = self.user_foo",
            "        self.trustee = self.user_two",
            "        trust_data = (self.trust_api.create_trust",
            "                      (new_id,",
            "                       {'trustor_user_id': self.trustor['id'],",
            "                        'trustee_user_id': self.user_two['id'],",
            "                        'project_id': self.tenant_bar['id'],",
            "                        'expires_at': timeutils.",
            "                        parse_isotime('2031-02-18T18:10:00Z'),",
            "                        'impersonation': True,",
            "                        'remaining_uses': remaining_uses},",
            "                       roles=[{\"id\": \"member\"},",
            "                              {\"id\": \"other\"},",
            "                              {\"id\": \"browser\"}]))",
            "        return trust_data",
            "",
            "    def test_delete_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "        trust_id = trust_data['id']",
            "        self.assertIsNotNone(trust_data)",
            "        trust_data = self.trust_api.get_trust(trust_id)",
            "        self.assertEqual(new_id, trust_data['id'])",
            "        self.trust_api.delete_trust(trust_id)",
            "        self.assertIsNone(self.trust_api.get_trust(trust_id))",
            "",
            "    def test_delete_trust_not_found(self):",
            "        trust_id = uuid.uuid4().hex",
            "        self.assertRaises(exception.TrustNotFound,",
            "                          self.trust_api.delete_trust,",
            "                          trust_id)",
            "",
            "    def test_get_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "        trust_id = trust_data['id']",
            "        self.assertIsNotNone(trust_data)",
            "        trust_data = self.trust_api.get_trust(trust_id)",
            "        self.assertEqual(new_id, trust_data['id'])",
            "",
            "    def test_create_trust(self):",
            "        new_id = uuid.uuid4().hex",
            "        trust_data = self.create_sample_trust(new_id)",
            "",
            "        self.assertEqual(new_id, trust_data['id'])",
            "        self.assertEqual(self.trustee['id'], trust_data['trustee_user_id'])",
            "        self.assertEqual(self.trustor['id'], trust_data['trustor_user_id'])",
            "        self.assertTrue(timeutils.normalize_time(trust_data['expires_at']) >",
            "                        timeutils.utcnow())",
            "",
            "        self.assertEqual([{'id': 'member'},",
            "                          {'id': 'other'},",
            "                          {'id': 'browser'}], trust_data['roles'])",
            "",
            "    def test_list_trust_by_trustee(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts_for_trustee(self.trustee['id'])",
            "        self.assertEqual(3, len(trusts))",
            "        self.assertEqual(trusts[0][\"trustee_user_id\"], self.trustee['id'])",
            "        trusts = self.trust_api.list_trusts_for_trustee(self.trustor['id'])",
            "        self.assertEqual(0, len(trusts))",
            "",
            "    def test_list_trust_by_trustor(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts_for_trustor(self.trustor['id'])",
            "        self.assertEqual(3, len(trusts))",
            "        self.assertEqual(trusts[0][\"trustor_user_id\"], self.trustor['id'])",
            "        trusts = self.trust_api.list_trusts_for_trustor(self.trustee['id'])",
            "        self.assertEqual(0, len(trusts))",
            "",
            "    def test_list_trusts(self):",
            "        for i in range(3):",
            "            self.create_sample_trust(uuid.uuid4().hex)",
            "        trusts = self.trust_api.list_trusts()",
            "        self.assertEqual(3, len(trusts))",
            "",
            "    def test_trust_has_remaining_uses_positive(self):",
            "        # create a trust with limited uses, check that we have uses left",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex,",
            "                                              remaining_uses=5)",
            "        self.assertEqual(5, trust_data['remaining_uses'])",
            "        # create a trust with unlimited uses, check that we have uses left",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex)",
            "        self.assertIsNone(trust_data['remaining_uses'])",
            "",
            "    def test_trust_has_remaining_uses_negative(self):",
            "        # try to create a trust with no remaining uses, check that it fails",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.create_sample_trust,",
            "                          uuid.uuid4().hex,",
            "                          remaining_uses=0)",
            "        # try to create a trust with negative remaining uses,",
            "        # check that it fails",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.create_sample_trust,",
            "                          uuid.uuid4().hex,",
            "                          remaining_uses=-12)",
            "",
            "    def test_consume_use(self):",
            "        # consume a trust repeatedly until it has no uses anymore",
            "        trust_data = self.create_sample_trust(uuid.uuid4().hex,",
            "                                              remaining_uses=2)",
            "        self.trust_api.consume_use(trust_data['id'])",
            "        t = self.trust_api.get_trust(trust_data['id'])",
            "        self.assertEqual(1, t['remaining_uses'])",
            "        self.trust_api.consume_use(trust_data['id'])",
            "        # This was the last use, the trust isn't available anymore",
            "        self.assertIsNone(self.trust_api.get_trust(trust_data['id']))",
            "",
            "",
            "class CommonHelperTests(tests.TestCase):",
            "    def test_format_helper_raises_malformed_on_missing_key(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%(foo)s/%(bar)s\",",
            "                          {\"foo\": \"1\"})",
            "",
            "    def test_format_helper_raises_malformed_on_wrong_type(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%foo%s\",",
            "                          {\"foo\": \"1\"})",
            "",
            "    def test_format_helper_raises_malformed_on_incomplete_format(self):",
            "        self.assertRaises(exception.MalformedEndpoint,",
            "                          core.format_url,",
            "                          \"http://%(foo)\",",
            "                          {\"foo\": \"1\"})",
            "",
            "",
            "class CatalogTests(object):",
            "    def test_region_crud(self):",
            "        # create",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        res = self.catalog_api.create_region(",
            "            new_region.copy())",
            "        # Ensure that we don't need to have a",
            "        # parent_region_id in the original supplied",
            "        # ref dict, but that it will be returned from",
            "        # the endpoint, with None value.",
            "        expected_region = new_region.copy()",
            "        expected_region['parent_region_id'] = None",
            "        self.assertDictEqual(res, expected_region)",
            "",
            "        # Test adding another region with the one above",
            "        # as its parent. We will check below whether deleting",
            "        # the parent successfully deletes any child regions.",
            "        parent_region_id = region_id",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "            'parent_region_id': parent_region_id",
            "        }",
            "        self.catalog_api.create_region(",
            "            new_region.copy())",
            "",
            "        # list",
            "        regions = self.catalog_api.list_regions()",
            "        self.assertThat(regions, matchers.HasLength(2))",
            "        region_ids = [x['id'] for x in regions]",
            "        self.assertIn(parent_region_id, region_ids)",
            "        self.assertIn(region_id, region_ids)",
            "",
            "        # delete",
            "        self.catalog_api.delete_region(parent_region_id)",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.delete_region,",
            "                          parent_region_id)",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          parent_region_id)",
            "        # Ensure the child is also gone...",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          region_id)",
            "",
            "    def test_create_region_with_duplicate_id(self):",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex",
            "        }",
            "        self.catalog_api.create_region(new_region)",
            "        # Create region again with duplicate id",
            "        self.assertRaises(exception.Conflict,",
            "                          self.catalog_api.create_region,",
            "                          new_region)",
            "",
            "    def test_get_region_404(self):",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.get_region,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_region_404(self):",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.delete_region,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_region_invalid_parent_region_404(self):",
            "        region_id = uuid.uuid4().hex",
            "        new_region = {",
            "            'id': region_id,",
            "            'description': uuid.uuid4().hex,",
            "            'parent_region_id': 'nonexisting'",
            "        }",
            "        self.assertRaises(exception.RegionNotFound,",
            "                          self.catalog_api.create_region,",
            "                          new_region)",
            "",
            "    def test_service_crud(self):",
            "        # create",
            "        service_id = uuid.uuid4().hex",
            "        new_service = {",
            "            'id': service_id,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        res = self.catalog_api.create_service(",
            "            service_id,",
            "            new_service.copy())",
            "        new_service['enabled'] = True",
            "        self.assertDictEqual(new_service, res)",
            "",
            "        # list",
            "        services = self.catalog_api.list_services()",
            "        self.assertIn(service_id, [x['id'] for x in services])",
            "",
            "        # delete",
            "        self.catalog_api.delete_service(service_id)",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.delete_service,",
            "                          service_id)",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.get_service,",
            "                          service_id)",
            "",
            "    def test_delete_service_with_endpoint(self):",
            "        # create a service",
            "        service = {",
            "            'id': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service['id'], service)",
            "",
            "        # create an endpoint attached to the service",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'region': uuid.uuid4().hex,",
            "            'interface': uuid.uuid4().hex[:8],",
            "            'url': uuid.uuid4().hex,",
            "            'service_id': service['id'],",
            "        }",
            "        self.catalog_api.create_endpoint(endpoint['id'], endpoint)",
            "",
            "        # deleting the service should also delete the endpoint",
            "        self.catalog_api.delete_service(service['id'])",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.get_endpoint,",
            "                          endpoint['id'])",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.delete_endpoint,",
            "                          endpoint['id'])",
            "",
            "    def test_get_service_404(self):",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.get_service,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_service_404(self):",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.delete_service,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_endpoint_404(self):",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'service_id': uuid.uuid4().hex,",
            "        }",
            "        self.assertRaises(exception.ServiceNotFound,",
            "                          self.catalog_api.create_endpoint,",
            "                          endpoint['id'],",
            "                          endpoint)",
            "",
            "    def test_get_endpoint_404(self):",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.get_endpoint,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_delete_endpoint_404(self):",
            "        self.assertRaises(exception.EndpointNotFound,",
            "                          self.catalog_api.delete_endpoint,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_create_endpoint(self):",
            "        service = {",
            "            'id': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service['id'], service.copy())",
            "",
            "        endpoint = {",
            "            'id': uuid.uuid4().hex,",
            "            'region': \"0\" * 255,",
            "            'service_id': service['id'],",
            "            'interface': 'public',",
            "            'url': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_endpoint(endpoint['id'], endpoint.copy())",
            "",
            "    def _create_endpoints(self):",
            "        # Creates a service and 2 endpoints for the service in the same region.",
            "        # The 'public' interface is enabled and the 'internal' interface is",
            "        # disabled.",
            "",
            "        def create_endpoint(service_id, region, **kwargs):",
            "            id_ = uuid.uuid4().hex",
            "            ref = {",
            "                'id': id_,",
            "                'interface': 'public',",
            "                'region': region,",
            "                'service_id': service_id,",
            "                'url': 'http://localhost/%s' % uuid.uuid4().hex,",
            "            }",
            "            ref.update(kwargs)",
            "            self.catalog_api.create_endpoint(id_, ref)",
            "            return ref",
            "",
            "        # Create a service for use with the endpoints.",
            "        service_id = uuid.uuid4().hex",
            "        service_ref = {",
            "            'id': service_id,",
            "            'name': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "        }",
            "        self.catalog_api.create_service(service_id, service_ref)",
            "",
            "        region = uuid.uuid4().hex",
            "",
            "        # Create endpoints",
            "        enabled_endpoint_ref = create_endpoint(service_id, region)",
            "        disabled_endpoint_ref = create_endpoint(",
            "            service_id, region, enabled=False, interface='internal')",
            "",
            "        return service_ref, enabled_endpoint_ref, disabled_endpoint_ref",
            "",
            "    def test_get_catalog_endpoint_disabled(self):",
            "        \"\"\"Get back only enabled endpoints when get the v2 catalog.\"\"\"",
            "",
            "        service_ref, enabled_endpoint_ref, dummy_disabled_endpoint_ref = (",
            "            self._create_endpoints())",
            "",
            "        user_id = uuid.uuid4().hex",
            "        project_id = uuid.uuid4().hex",
            "        catalog = self.catalog_api.get_catalog(user_id, project_id)",
            "",
            "        exp_entry = {",
            "            'id': enabled_endpoint_ref['id'],",
            "            'name': service_ref['name'],",
            "            'publicURL': enabled_endpoint_ref['url'],",
            "        }",
            "",
            "        region = enabled_endpoint_ref['region']",
            "        self.assertEqual(exp_entry, catalog[region][service_ref['type']])",
            "",
            "    def test_get_v3_catalog_endpoint_disabled(self):",
            "        \"\"\"Get back only enabled endpoints when get the v3 catalog.\"\"\"",
            "",
            "        enabled_endpoint_ref = self._create_endpoints()[1]",
            "",
            "        user_id = uuid.uuid4().hex",
            "        project_id = uuid.uuid4().hex",
            "        catalog = self.catalog_api.get_v3_catalog(user_id, project_id)",
            "",
            "        endpoint_ids = [x['id'] for x in catalog[0]['endpoints']]",
            "        self.assertEqual([enabled_endpoint_ref['id']], endpoint_ids)",
            "",
            "",
            "class PolicyTests(object):",
            "    def _new_policy_ref(self):",
            "        return {",
            "            'id': uuid.uuid4().hex,",
            "            'policy': uuid.uuid4().hex,",
            "            'type': uuid.uuid4().hex,",
            "            'endpoint_id': uuid.uuid4().hex,",
            "        }",
            "",
            "    def assertEqualPolicies(self, a, b):",
            "        self.assertEqual(a['id'], b['id'])",
            "        self.assertEqual(a['endpoint_id'], b['endpoint_id'])",
            "        self.assertEqual(a['policy'], b['policy'])",
            "        self.assertEqual(a['type'], b['type'])",
            "",
            "    def test_create(self):",
            "        ref = self._new_policy_ref()",
            "        res = self.policy_api.create_policy(ref['id'], ref)",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_get(self):",
            "        ref = self._new_policy_ref()",
            "        res = self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        res = self.policy_api.get_policy(ref['id'])",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_list(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        res = self.policy_api.list_policies()",
            "        res = [x for x in res if x['id'] == ref['id']][0]",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_update(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "        orig = ref",
            "",
            "        ref = self._new_policy_ref()",
            "",
            "        # (cannot change policy ID)",
            "        self.assertRaises(exception.ValidationError,",
            "                          self.policy_api.update_policy,",
            "                          orig['id'],",
            "                          ref)",
            "",
            "        ref['id'] = orig['id']",
            "        res = self.policy_api.update_policy(orig['id'], ref)",
            "        self.assertEqualPolicies(ref, res)",
            "",
            "    def test_delete(self):",
            "        ref = self._new_policy_ref()",
            "        self.policy_api.create_policy(ref['id'], ref)",
            "",
            "        self.policy_api.delete_policy(ref['id'])",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.delete_policy,",
            "                          ref['id'])",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.get_policy,",
            "                          ref['id'])",
            "        res = self.policy_api.list_policies()",
            "        self.assertFalse(len([x for x in res if x['id'] == ref['id']]))",
            "",
            "    def test_get_policy_404(self):",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.get_policy,",
            "                          uuid.uuid4().hex)",
            "",
            "    def test_update_policy_404(self):",
            "        ref = self._new_policy_ref()",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.update_policy,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_delete_policy_404(self):",
            "        self.assertRaises(exception.PolicyNotFound,",
            "                          self.policy_api.delete_policy,",
            "                          uuid.uuid4().hex)",
            "",
            "",
            "class InheritanceTests(object):",
            "",
            "    def test_inherited_role_grants_for_user(self):",
            "        \"\"\"Test inherited user roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create 3 roles",
            "        - Create a domain, with a project and a user",
            "        - Check no roles yet exit",
            "        - Assign a direct user role to the project and a (non-inherited)",
            "          user role to the domain",
            "        - Get a list of effective roles - should only get the one direct role",
            "        - Now add an inherited user role to the domain",
            "        - Get a list of effective roles - should have two roles, one",
            "          direct and one by virtue of the inherited user role",
            "        - Also get effective roles for the domain - the role marked as",
            "          inherited should not show up",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        role_list = []",
            "        for _ in range(3):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        # Create the first two roles - the domain one is not inherited",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "",
            "        # Now get the effective roles for the user and project, this",
            "        # should only include the direct role assignment on the project",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(1, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "",
            "        # Now add an inherited role on the domain",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'],",
            "                                         inherited_to_projects=True)",
            "",
            "        # Now get the effective roles for the user and project again, this",
            "        # should now include the inherited role on the domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[2]['id'], combined_list)",
            "",
            "        # Finally, check that the inherited role does not appear as a valid",
            "        # directly assigned role on the domain itself",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], domain1['id'])",
            "        self.assertEqual(1, len(combined_role_list))",
            "        self.assertIn(role_list[1]['id'], combined_role_list)",
            "",
            "    def test_inherited_role_grants_for_group(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create 4 roles",
            "        - Create a domain, with a project, user and two groups",
            "        - Make the user a member of both groups",
            "        - Check no roles yet exit",
            "        - Assign a direct user role to the project and a (non-inherited)",
            "          group role on the domain",
            "        - Get a list of effective roles - should only get the one direct role",
            "        - Now add two inherited group roles to the domain",
            "        - Get a list of effective roles - should have three roles, one",
            "          direct and two by virtue of inherited group roles",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        role_list = []",
            "        for _ in range(4):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': domain1['id'], 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain1['id'], 'enabled': True}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain1['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(user1['id'],",
            "                                            group2['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=user1['id'],",
            "            project_id=project1['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        # Create two roles - the domain one is not inherited",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=role_list[0]['id'])",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[1]['id'])",
            "",
            "        # Now get the effective roles for the user and project, this",
            "        # should only include the direct role assignment on the project",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(1, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "",
            "        # Now add to more group roles, both inherited, to the domain",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[2]['id'],",
            "                                         inherited_to_projects=True)",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         domain_id=domain1['id'],",
            "                                         role_id=role_list[3]['id'],",
            "                                         inherited_to_projects=True)",
            "",
            "        # Now get the effective roles for the user and project again, this",
            "        # should now include the inherited roles on the domain",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'], project1['id'])",
            "        self.assertEqual(3, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[2]['id'], combined_list)",
            "        self.assertIn(role_list[3]['id'], combined_list)",
            "",
            "    def test_list_projects_for_user_with_inherited_grants(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create a domain, with two projects and a user",
            "        - Assign an inherited user role on the domain, as well as a direct",
            "          user role to a separate project in a different domain",
            "        - Get a list of projects for user, should return all three projects",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        # Create 2 grants, one on a project and one inherited grant",
            "        # on the domain",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        # Should get back all three projects, one by virtue of the direct",
            "        # grant, plus both projects in the domain",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(3, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_inherited_group_grants(self):",
            "        \"\"\"Test inherited group roles.",
            "",
            "        Test Plan:",
            "",
            "        - Enable OS-INHERIT extension",
            "        - Create two domains, each with two projects",
            "        - Create a user and group",
            "        - Make the user a member of the group",
            "        - Assign a user role two projects, an inherited",
            "          group role to one domain and an inherited regular role on",
            "          the other domain",
            "        - Get a list of projects for user, should return both pairs of projects",
            "          from the domain, plus the one separate project",
            "",
            "        \"\"\"",
            "        self.config_fixture.config(group='os_inherit', enabled=True)",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain['id'], domain)",
            "        domain2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain2['id'], domain2)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "        project3 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project3['id'], project3)",
            "        project4 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain2['id']}",
            "        self.assignment_api.create_project(project4['id'], project4)",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        self.identity_api.add_user_to_group(user1['id'], group1['id'])",
            "",
            "        # Create 4 grants:",
            "        # - one user grant on a project in domain2",
            "        # - one user grant on a project in the default domain",
            "        # - one inherited user grant on domain",
            "        # - one inherited group grant on domain2",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=project3['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         domain_id=domain['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        self.assignment_api.create_grant(group_id=group1['id'],",
            "                                         domain_id=domain2['id'],",
            "                                         role_id=self.role_admin['id'],",
            "                                         inherited_to_projects=True)",
            "        # Should get back all five projects, but without a duplicate for",
            "        # project3 (since it has both a direct user role and an inherited role)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(5, len(user_projects))",
            "",
            "",
            "class FilterTests(filtering.FilterTests):",
            "    def test_list_users_filtered(self):",
            "        domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(domain1['id'], domain1)",
            "",
            "        for entity in ['user', 'group', 'project']:",
            "            # Create 20 entities, 14 of which are in domain1",
            "            entity_list = self._create_test_data(entity, 6)",
            "            domain1_entity_list = self._create_test_data(entity, 14,",
            "                                                         domain1['id'])",
            "",
            "            # Should get back the 14 entities in domain1",
            "            hints = driver_hints.Hints()",
            "            hints.add_filter('domain_id', domain1['id'])",
            "            entities = self._list_entities(entity)(hints=hints)",
            "            self.assertEqual(14, len(entities))",
            "            self._match_with_list(entities, domain1_entity_list)",
            "            # Check the driver has removed the filter from the list hints",
            "            self.assertFalse(hints.get_exact_filter_by_name('domain_id'))",
            "",
            "            # Try filtering to get one an exact item out of the list",
            "            hints = driver_hints.Hints()",
            "            hints.add_filter('name', domain1_entity_list[10]['name'])",
            "            entities = self._list_entities(entity)(hints=hints)",
            "            self.assertEqual(1, len(entities))",
            "            self.assertEqual(entities[0]['id'], domain1_entity_list[10]['id'])",
            "            # Check the driver has removed the filter from the list hints",
            "            self.assertFalse(hints.get_exact_filter_by_name('name'))",
            "            self._delete_test_data(entity, entity_list)",
            "            self._delete_test_data(entity, domain1_entity_list)",
            "",
            "    def test_list_users_inexact_filtered(self):",
            "        # Create 20 users",
            "        user_list = self._create_test_data('user', 20)",
            "        # Set up some names that we can filter on",
            "        user = user_list[5]",
            "        user['name'] = 'The'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[6]",
            "        user['name'] = 'The Ministry'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[7]",
            "        user['name'] = 'The Ministry of'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[8]",
            "        user['name'] = 'The Ministry of Silly'",
            "        self.identity_api.update_user(user['id'], user)",
            "        user = user_list[9]",
            "        user['name'] = 'The Ministry of Silly Walks'",
            "        self.identity_api.update_user(user['id'], user)",
            "        # ...and one for useful case insensitivity testing",
            "        user = user_list[10]",
            "        user['name'] = 'The ministry of silly walks OF'",
            "        self.identity_api.update_user(user['id'], user)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'ministry', comparator='contains')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(5, len(users))",
            "        self._match_with_list(users, user_list,",
            "                              list_start=6, list_end=11)",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'The', comparator='startswith')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(6, len(users))",
            "        self._match_with_list(users, user_list,",
            "                              list_start=5, list_end=11)",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', 'of', comparator='endswith')",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual(user_list[7]['id'], users[0]['id'])",
            "        self.assertEqual(user_list[10]['id'], users[1]['id'])",
            "        # TODO(henry-nash) Check inexact filter has been removed.",
            "",
            "        # TODO(henry-nash): Add some case sensitive tests.  The issue",
            "        # is that MySQL 0.7, by default, is installed in case",
            "        # insensitive mode (which is what is run by default for our",
            "        # SQL backend tests).  For production deployments. OpenStack",
            "        # assumes a case sensitive database.  For these tests, therefore, we",
            "        # need to be able to check the sensitivity of the database so as to",
            "        # know whether to run case sensitive tests here.",
            "",
            "        self._delete_test_data('user', user_list)",
            "",
            "    def test_filter_sql_injection_attack(self):",
            "        \"\"\"Test against sql injection attack on filters",
            "",
            "        Test Plan:",
            "        - Attempt to get all entities back by passing a two-term attribute",
            "        - Attempt to piggyback filter to damage DB (e.g. drop table)",
            "",
            "        \"\"\"",
            "        # Check we have some users",
            "        users = self.identity_api.list_users()",
            "        self.assertTrue(len(users) > 0)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', \"anything' or 'x'='x\")",
            "        users = self.identity_api.list_users(hints=hints)",
            "        self.assertEqual(0, len(users))",
            "",
            "        # See if we can add a SQL command...use the group table instead of the",
            "        # user table since 'user' is reserved word for SQLAlchemy.",
            "        group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': DEFAULT_DOMAIN_ID}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('name', \"x'; drop table group\")",
            "        groups = self.identity_api.list_groups(hints=hints)",
            "        self.assertEqual(0, len(groups))",
            "",
            "        groups = self.identity_api.list_groups()",
            "        self.assertTrue(len(groups) > 0)",
            "",
            "",
            "class LimitTests(filtering.FilterTests):",
            "    ENTITIES = ['user', 'group', 'project']",
            "",
            "    def setUp(self):",
            "        \"\"\"Setup for Limit Test Cases.\"\"\"",
            "",
            "        self.domain1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_domain(self.domain1['id'], self.domain1)",
            "        self.addCleanup(self.clean_up_domain)",
            "",
            "        self.entity_lists = {}",
            "        self.domain1_entity_lists = {}",
            "",
            "        for entity in self.ENTITIES:",
            "            # Create 20 entities, 14 of which are in domain1",
            "            self.entity_lists[entity] = self._create_test_data(entity, 6)",
            "            self.domain1_entity_lists[entity] = self._create_test_data(",
            "                entity, 14, self.domain1['id'])",
            "        self.addCleanup(self.clean_up_entities)",
            "",
            "    def clean_up_domain(self):",
            "        \"\"\"Clean up domain test data from Limit Test Cases.\"\"\"",
            "",
            "        self.domain1['enabled'] = False",
            "        self.assignment_api.update_domain(self.domain1['id'], self.domain1)",
            "        self.assignment_api.delete_domain(self.domain1['id'])",
            "        del self.domain1",
            "",
            "    def clean_up_entities(self):",
            "        \"\"\"Clean up entity test data from Limit Test Cases.\"\"\"",
            "        for entity in self.ENTITIES:",
            "            self._delete_test_data(entity, self.entity_lists[entity])",
            "            self._delete_test_data(entity, self.domain1_entity_lists[entity])",
            "        del self.entity_lists",
            "        del self.domain1_entity_lists",
            "",
            "    def _test_list_entity_filtered_and_limited(self, entity):",
            "        self.config_fixture.config(list_limit=10)",
            "        # Should get back just 10 entities in domain1",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('domain_id', self.domain1['id'])",
            "        entities = self._list_entities(entity)(hints=hints)",
            "        self.assertEqual(hints.get_limit()['limit'], len(entities))",
            "        self.assertTrue(hints.get_limit()['truncated'])",
            "        self._match_with_list(entities, self.domain1_entity_lists[entity])",
            "",
            "        # Override with driver specific limit",
            "        if entity == 'project':",
            "            self.config_fixture.config(group='assignment', list_limit=5)",
            "        else:",
            "            self.config_fixture.config(group='identity', list_limit=5)",
            "",
            "        # Should get back just 5 users in domain1",
            "        hints = driver_hints.Hints()",
            "        hints.add_filter('domain_id', self.domain1['id'])",
            "        entities = self._list_entities(entity)(hints=hints)",
            "        self.assertEqual(hints.get_limit()['limit'], len(entities))",
            "        self._match_with_list(entities, self.domain1_entity_lists[entity])",
            "",
            "        # Finally, let's pretend we want to get the full list of entities,",
            "        # even with the limits set, as part of some internal calculation.",
            "        # Calling the API without a hints list should achieve this, and",
            "        # return at least the 20 entries we created (there may be other",
            "        # entities lying around created by other tests/setup).",
            "        entities = self._list_entities(entity)()",
            "        self.assertTrue(len(entities) >= 20)",
            "",
            "    def test_list_users_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('user')",
            "",
            "    def test_list_groups_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('group')",
            "",
            "    def test_list_projects_filtered_and_limited(self):",
            "        self._test_list_entity_filtered_and_limited('project')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.Airflow",
            "keystone.tests.test_backend.IdentityTests.self"
        ]
    },
    "keystone/tests/test_backend_ldap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1250,
                "afterPatchRowNumber": 1250,
                "PatchRowcode": "             user1['id'], CONF.identity.default_domain_id)"
            },
            "1": {
                "beforePatchRowNumber": 1251,
                "afterPatchRowNumber": 1251,
                "PatchRowcode": "         self.assertEqual(0, len(combined_role_list))"
            },
            "2": {
                "beforePatchRowNumber": 1252,
                "afterPatchRowNumber": 1252,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1253,
                "PatchRowcode": "+    def test_get_roles_for_user_and_project_user_group_same_id(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1254,
                "PatchRowcode": "+        \"\"\"When a user has the same ID as a group,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1255,
                "PatchRowcode": "+        get_roles_for_user_and_project returns the roles for the group."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1256,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1257,
                "PatchRowcode": "+        Overriding this test for LDAP because it works differently. The role"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1258,
                "PatchRowcode": "+        for the group is returned. This is bug 1309228."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1259,
                "PatchRowcode": "+        \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1260,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1261,
                "PatchRowcode": "+        # Setup: create user, group with same ID, role, and project;"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1262,
                "PatchRowcode": "+        # assign the group the role on the project."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1263,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1264,
                "PatchRowcode": "+        user_group_id = uuid.uuid4().hex"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1265,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1266,
                "PatchRowcode": "+        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1267,
                "PatchRowcode": "+                 'domain_id': CONF.identity.default_domain_id, }"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1268,
                "PatchRowcode": "+        self.identity_api.create_user(user_group_id, user1)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1269,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "+        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "+                  'domain_id': CONF.identity.default_domain_id, }"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "+        self.identity_api.create_group(user_group_id, group1)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "+        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "+        self.assignment_api.create_role(role1['id'], role1)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "+        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "+                    'domain_id': CONF.identity.default_domain_id, }"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "+        self.assignment_api.create_project(project1['id'], project1)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "+        self.assignment_api.create_grant(role1['id'],"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "+                                         group_id=user_group_id,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "+                                         project_id=project1['id'])"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1285,
                "PatchRowcode": "+        # Check the roles, shouldn't be any since the user wasn't granted any."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "+        roles = self.assignment_api.get_roles_for_user_and_project("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1287,
                "PatchRowcode": "+            user_group_id, project1['id'])"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1288,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1289,
                "PatchRowcode": "+        self.assertEqual([role1['id']], roles,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1290,
                "PatchRowcode": "+                         'role for group is %s' % role1['id'])"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1291,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 1253,
                "afterPatchRowNumber": 1292,
                "PatchRowcode": "     def test_list_projects_for_alternate_domain(self):"
            },
            "43": {
                "beforePatchRowNumber": 1254,
                "afterPatchRowNumber": 1293,
                "PatchRowcode": "         self.skipTest("
            },
            "44": {
                "beforePatchRowNumber": 1255,
                "afterPatchRowNumber": 1294,
                "PatchRowcode": "             'N/A: LDAP does not support multiple domains')"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import uuid",
            "",
            "import ldap",
            "import mock",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone.common import cache",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common.ldap import core as common_ldap_core",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import fakeldap",
            "from keystone.tests.ksfixtures import database",
            "from keystone.tests import test_backend",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class BaseLDAPIdentity(test_backend.IdentityTests):",
            "",
            "    def setUp(self):",
            "        super(BaseLDAPIdentity, self).setUp()",
            "        self.clear_database()",
            "",
            "        common_ldap.register_handler('fake://', fakeldap.FakeLdap)",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.addCleanup(common_ldap_core._HANDLERS.clear)",
            "",
            "    def _get_domain_fixture(self):",
            "        \"\"\"Domains in LDAP are read-only, so just return the static one.\"\"\"",
            "        return self.assignment_api.get_domain(CONF.identity.default_domain_id)",
            "",
            "    def clear_database(self):",
            "        for shelf in fakeldap.FakeShelves:",
            "            fakeldap.FakeShelves[shelf].clear()",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Only one backend unless we are using separate domain backends",
            "        self.load_backends()",
            "",
            "    def get_config(self, domain_id):",
            "        # Only one conf structure unless we are using separate domain backends",
            "        return CONF",
            "",
            "    def config_overrides(self):",
            "        super(BaseLDAPIdentity, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "",
            "    def config_files(self):",
            "        config_files = super(BaseLDAPIdentity, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def test_build_tree(self):",
            "        \"\"\"Regression test for building the tree names",
            "        \"\"\"",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        self.assertTrue(user_api)",
            "        self.assertEqual(\"ou=Users,%s\" % CONF.ldap.suffix, user_api.tree_dn)",
            "",
            "    def test_configurable_allowed_user_actions(self):",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', user_ref['id'])",
            "",
            "        user['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "",
            "        self.identity_api.delete_user(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_user_actions(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        conf.ldap.user_allow_update = False",
            "        conf.ldap.user_allow_delete = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          u'f\u00e4k\u00e91',",
            "                          user)",
            "",
            "        self.user_foo['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.update_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.delete_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_configurable_forbidden_create_existing_user(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "    def test_user_filter(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "        conf = self.get_config(user_ref['domain_id'])",
            "        conf.ldap.user_filter = '(CN=DOES_NOT_MATCH)'",
            "        self.reload_backends(user_ref['domain_id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual([], roles_ref)",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertNotEmpty(roles_ref)",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group2['id'])",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        user_projects = self.assignment_api.list_projects_for_user(",
            "            new_user['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_user_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_group_between_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grant already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the list of assignments - check it is gone up by 2",
            "        after_assignments = len(self.assignment_api.list_role_assignments())",
            "        self.assertEqual(existing_assignments + 2, after_assignments)",
            "",
            "    def test_list_role_assignments_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "",
            "        # Read back the list of assignments and ensure",
            "        # that the LDAP dumb member isn't listed.",
            "        assignment_ids = [a['user_id'] for a in",
            "                          self.assignment_api.list_role_assignments()]",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertNotIn(dumb_id, assignment_ids)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_group_members_missing_entry(self):",
            "        \"\"\"List group members with deleted user.",
            "",
            "        If a group has a deleted entry for a member, the non-deleted members",
            "        are returned.",
            "",
            "        \"\"\"",
            "",
            "        # Create a group",
            "        group_id = None",
            "        group = dict(name=uuid.uuid4().hex,",
            "                     domain_id=CONF.identity.default_domain_id)",
            "        group_id = self.identity_api.create_group(group_id, group)['id']",
            "",
            "        # Create a couple of users and add them to the group.",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_1_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_1_id, group_id)",
            "",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_2_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_2_id, group_id)",
            "",
            "        # Delete user 2",
            "        # NOTE(blk-u): need to go directly to user interface to keep from",
            "        # updating the group.",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.delete(user_2_id)",
            "",
            "        # List group users and verify only user 1.",
            "        res = self.identity_api.list_users_in_group(group_id)",
            "",
            "        self.assertEqual(1, len(res), \"Expected 1 entry (user_1)\")",
            "        self.assertEqual(user_1_id, res[0]['id'], \"Expected user 1 id\")",
            "",
            "    def test_list_group_members_when_no_members(self):",
            "        # List group members when there is no member in the group.",
            "        # No exception should be raised.",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.list_users_in_group(group['id'])",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(",
            "            [assignment.calc_default_domain()],",
            "            domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains changes is the new default_domain_id.",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(new_domain_id, domains[0]['id'])",
            "",
            "    def test_authenticate_requires_simple_bind(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': test_backend.DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "            'enabled': True,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.LDAP_USER = None",
            "        driver.user.LDAP_PASSWORD = None",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=user['id'],",
            "                          password=None,",
            "                          domain_scope=user['domain_id'])",
            "",
            "    # (spzala)The group and domain crud tests below override the standard ones",
            "    # in test_backend.py so that we can exclude the update name test, since we",
            "    # do not yet support the update of either group or domain names with LDAP.",
            "    # In the tests below, the update is demonstrated by updating description.",
            "    # Refer to bug 1136403 for more detail.",
            "    def test_group_crud(self):",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "        group['description'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_user_none_mapping(self):",
            "        # When create a user where an attribute maps to None, the entry is",
            "        # created without that attribute and it doesn't fail with a TypeError.",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_attribute_ignore = ['enabled', 'email',",
            "                                           'tenants', 'tenantId']",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'default_project_id': 'maps_to_none',",
            "                }",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "    def test_update_user_name(self):",
            "        \"\"\"A user's name cannot be changed through the LDAP driver.\"\"\"",
            "        self.assertRaises(exception.Conflict,",
            "                          super(BaseLDAPIdentity, self).test_update_user_name)",
            "",
            "    def test_attribute_update(self):",
            "        self.skipTest(\"Blank value in a required field is an error in LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_user_id_comma(self):",
            "        \"\"\"Even if the user has a , in their ID, groups can be listed.\"\"\"",
            "",
            "        # Create a user with a , in their ID",
            "        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!",
            "        user_id = u'Doe, John'",
            "        user = {",
            "            'id': user_id,",
            "            'name': self.getUniqueString(),",
            "            'password': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_user(user_id, user)",
            "",
            "        # Create a group",
            "        group_id = uuid.uuid4().hex",
            "        group = {",
            "            'id': group_id,",
            "            'name': self.getUniqueString(prefix='tuidc'),",
            "            'description': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_group(group_id, group)",
            "",
            "        # Put the user in the group",
            "        self.identity_api.add_user_to_group(user_id, group_id)",
            "",
            "        # List groups for user.",
            "        ref_list = self.identity_api.list_groups_for_user(user_id)",
            "",
            "        self.assertThat(ref_list, matchers.Equals([group]))",
            "",
            "",
            "class LDAPIdentity(BaseLDAPIdentity, tests.TestCase):",
            "",
            "    def setUp(self):",
            "        # NOTE(dstanek): The database must be setup prior to calling the",
            "        # parent's setUp. The parent's setUp uses services (like",
            "        # credentials) that require a database.",
            "        self.useFixture(database.Database())",
            "        super(LDAPIdentity, self).setUp()",
            "",
            "    def test_configurable_allowed_project_actions(self):",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True}",
            "        self.assignment_api.create_project(u'f\u00e4k\u00e91', tenant)",
            "        tenant_ref = self.assignment_api.get_project(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', tenant_ref['id'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project(u'f\u00e4k\u00e91', tenant)",
            "",
            "        self.assignment_api.delete_project(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_subtree_delete(self):",
            "        self.config_fixture.config(group='ldap', allow_subtree_delete=True)",
            "        self.load_backends()",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role1['id'])",
            "",
            "        self.assignment_api.delete_project(project1['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project1['id'])",
            "",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(0, len(list))",
            "",
            "    def test_configurable_forbidden_project_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_allow_create=False, tenant_allow_update=False,",
            "            tenant_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_project,",
            "                          u'f\u00e4k\u00e91',",
            "                          tenant)",
            "",
            "        self.tenant_bar['enabled'] = False",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_project,",
            "                          self.tenant_bar['id'],",
            "                          self.tenant_bar)",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_configurable_allowed_role_actions(self):",
            "        role = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assignment_api.create_role(u'f\u00e4k\u00e91', role)",
            "        role_ref = self.assignment_api.get_role(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', role_ref['id'])",
            "",
            "        role['name'] = u'f\u00e4k\u00e92'",
            "        self.assignment_api.update_role(u'f\u00e4k\u00e91', role)",
            "",
            "        self.assignment_api.delete_role(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_role_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', role_allow_create=False, role_allow_update=False,",
            "            role_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "        self.role_member['name'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_role,",
            "                          self.role_member['id'],",
            "                          self.role_member)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_project_filter(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_filter  will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assignment_api.get_role(self.role_member['id'])",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_bar['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_role_filter(self):",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertDictEqual(role_ref, self.role_member)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_filter will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          dumb_id)",
            "",
            "    def test_project_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_name_attribute='ou',",
            "            tenant_desc_attribute='description',",
            "            tenant_enabled_attribute='enabled')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['name'])",
            "        self.assertEqual(",
            "            self.tenant_baz['description'],",
            "            tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_name_attribute='description',",
            "                                   tenant_desc_attribute='ou')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['description'], tenant_ref['name'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "    def test_project_attribute_ignore(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            tenant_attribute_ignore=['name', 'description', 'enabled'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change configs values in tests",
            "        # that could affect what the drivers would return up to the manager.",
            "        # This solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertNotIn('name', tenant_ref)",
            "        self.assertNotIn('description', tenant_ref)",
            "        self.assertNotIn('enabled', tenant_ref)",
            "",
            "    def test_role_attribute_mapping(self):",
            "        self.config_fixture.config(group='ldap', role_name_attribute='ou')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertEqual(self.role_member['name'], role_ref['name'])",
            "",
            "        self.config_fixture.config(group='ldap', role_name_attribute='sn')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_role_attribute_ignore(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_attribute_ignore=['name'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.config_fixture.config(group='ldap', user_enabled_mask=2,",
            "                                   user_enabled_default='512')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        ldap_ = self.identity_api.driver.user.get_connection()",
            "",
            "        def get_enabled_vals():",
            "            user_dn = self.identity_api.driver.user._id_to_dn_string(u'f\u00e4k\u00e91')",
            "            enabled_attr_name = CONF.ldap.user_enabled_attribute",
            "",
            "            res = ldap_.search_s(user_dn,",
            "                                 ldap.SCOPE_BASE,",
            "                                 u'(sn=f\u00e4k\u00e91)')",
            "            return res[0][1][enabled_attr_name]",
            "",
            "        user = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True,",
            "                'domain_id': CONF.identity.default_domain_id}",
            "",
            "        user_ref = self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "        # Use assertIs rather than assertTrue because assertIs will assert the",
            "        # value is a Boolean as expected.",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = False",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([514], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'simple_bind_s')",
            "    def test_user_api_get_connection_no_user_password(self, mocked_method):",
            "        \"\"\"Don't bind in case the user and password are blank.\"\"\"",
            "        # Ensure the username/password are in-fact blank",
            "        self.config_fixture.config(group='ldap', user=None, password=None)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "        self.assertFalse(mocked_method.called,",
            "                         msg='`simple_bind_s` method was unexpectedly called')",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_off(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=False)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertFalse(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_on(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=True)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertTrue(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_debug_level_set(self, mocked_fakeldap):",
            "        level = 12345",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            debug_level=level)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # debug_level. Check to make sure the value of debug_level",
            "        # is as expected.",
            "        self.assertEqual(level, mocked_fakeldap.call_args[-1]['debug_level'])",
            "",
            "    def test_wrong_ldap_scope(self):",
            "        self.config_fixture.config(group='ldap', query_scope=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP scope: %s. *' % CONF.ldap.query_scope,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_wrong_alias_dereferencing(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   alias_dereferencing=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP deref option: %s\\.' % CONF.ldap.alias_dereferencing,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_user_extra_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:name'])",
            "        self.load_backends()",
            "        user = {",
            "            'id': 'extra_attributes',",
            "            'name': 'EXTRA_ATTRIBUTES',",
            "            'password': 'extra',",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        dn, attrs = self.identity_api.driver.user._ldap_get(user['id'])",
            "        self.assertTrue(user['name'] in attrs['description'])",
            "",
            "    def test_user_extra_attribute_mapping_description_is_returned(self):",
            "        # Given a mapping like description:description, the description is",
            "        # returned.",
            "",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:description'])",
            "        self.load_backends()",
            "",
            "        description = uuid.uuid4().hex",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': description,",
            "            'password': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        res = self.identity_api.driver.user.get_all()",
            "",
            "        new_user = [u for u in res if u['id'] == user['id']][0]",
            "        self.assertThat(new_user['description'], matchers.Equals(description))",
            "",
            "    @mock.patch.object(common_ldap_core.BaseLdap, '_ldap_get')",
            "    def test_user_mixed_case_attribute(self, mock_ldap_get):",
            "        # Mock the search results to return attribute names",
            "        # with unexpected case.",
            "        mock_ldap_get.return_value = (",
            "            'cn=junk,dc=example,dc=com',",
            "            {",
            "                'sN': [uuid.uuid4().hex],",
            "                'eMaIl': [uuid.uuid4().hex]",
            "            }",
            "        )",
            "        user = self.identity_api.get_user('junk')",
            "        self.assertEqual(mock_ldap_get.return_value[1]['sN'][0],",
            "                         user['name'])",
            "        self.assertEqual(mock_ldap_get.return_value[1]['eMaIl'][0],",
            "                         user['email'])",
            "",
            "    def test_parse_extra_attribute_mapping(self):",
            "        option_list = ['description:name', 'gecos:password',",
            "                       'fake:invalid', 'invalid1', 'invalid2:',",
            "                       'description:name:something']",
            "        mapping = self.identity_api.driver.user._parse_extra_attrs(option_list)",
            "        expected_dict = {'description': 'name', 'gecos': 'password',",
            "                         'fake': 'invalid', 'invalid2': ''}",
            "        self.assertDictEqual(expected_dict, mapping)",
            "",
            "# TODO(henry-nash): These need to be removed when the full LDAP implementation",
            "# is submitted - see Bugs 1092187, 1101287, 1101276, 1101289",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True, 'description': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "        domain['description'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.update_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.update_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.delete_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.delete_domain,",
            "                          CONF.identity.default_domain_id)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # domains are read-only, so case sensitivity isn't an issue",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_cache_layer_domain_crud(self):",
            "        # TODO(morganfainberg): This also needs to be removed when full LDAP",
            "        # implementation is submitted.  No need to duplicate the above test,",
            "        # just skip this time.",
            "        self.skipTest('Domains are read-only against LDAP')",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAP implementation does not currently support the",
            "        #              updating of a project name so this method override",
            "        #              provides a different update test",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex, 'enabled': True",
            "                   }",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        # NOTE(morganfainberg): LDAP implementation does not currently support",
            "        # updating project names.  This method override provides a different",
            "        # update test.",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex}",
            "        project_id = project['id']",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['description'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        # This is a partial implementation of the standard test that",
            "        # is defined in test_backend.py.  It omits both domain and",
            "        # group grants. since neither of these are yet supported by",
            "        # the ldap backend.",
            "",
            "        role_list = []",
            "        for _ in range(2):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[0]['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[1]['id'])",
            "",
            "        # Although list_grants are not yet supported, we can test the",
            "        # alternate way of getting back lists of grants, where user",
            "        # and group roles are combined.  Only directly assigned user",
            "        # roles are available, since group grants are not yet supported",
            "",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[1]['id'], combined_list)",
            "",
            "        # Finally, although domain roles are not implemented, check we can",
            "        # issue the combined get roles call with benign results, since thus is",
            "        # used in token generation",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], CONF.identity.default_domain_id)",
            "        self.assertEqual(0, len(combined_role_list))",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_create_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_create_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain = self._get_domain_fixture()",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain['name'])",
            "        self.assertEqual(domain_ref, domain)",
            "",
            "    def test_base_ldap_connection_deref_option(self):",
            "        def get_conn(deref_name):",
            "            self.config_fixture.config(group='ldap',",
            "                                       alias_dereferencing=deref_name)",
            "            base_ldap = common_ldap.BaseLdap(CONF)",
            "            return base_ldap.get_connection()",
            "",
            "        conn = get_conn('default')",
            "        self.assertEqual(ldap.get_option(ldap.OPT_DEREF),",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('always')",
            "        self.assertEqual(ldap.DEREF_ALWAYS,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('finding')",
            "        self.assertEqual(ldap.DEREF_FINDING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('never')",
            "        self.assertEqual(ldap.DEREF_NEVER,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('searching')",
            "        self.assertEqual(ldap.DEREF_SEARCHING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "    def test_list_users_no_dn(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('dn', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups_no_dn(self):",
            "        # Create some test groups.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "        # Fetch the test groups and ensure that they don't contain a dn.",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "    def test_list_groups_for_user_no_dn(self):",
            "        # Create a test user.",
            "        user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'password': uuid.uuid4().hex,",
            "                'enabled': True}",
            "        self.identity_api.create_user(user['id'], user)",
            "        # Create some test groups and add the test user as a member.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "            self.identity_api.add_user_to_group(user['id'], group['id'])",
            "        # Fetch the groups for the test user",
            "        # and ensure they don't contain a dn.",
            "        groups = self.identity_api.list_groups_for_user(user['id'])",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "",
            "class LDAPIdentityEnabledEmulation(LDAPIdentity):",
            "    def setUp(self):",
            "        super(LDAPIdentityEnabledEmulation, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        for obj in [self.tenant_bar, self.tenant_baz, self.user_foo,",
            "                    self.user_two, self.user_badguy]:",
            "            obj.setdefault('enabled', True)",
            "",
            "    def config_files(self):",
            "        config_files = super(LDAPIdentityEnabledEmulation, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def config_overrides(self):",
            "        super(LDAPIdentityEnabledEmulation, self).config_overrides()",
            "        self.config_fixture.config(group='ldap',",
            "                                   user_enabled_emulation=True,",
            "                                   tenant_enabled_emulation=True)",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAPIdentityEnabledEmulation will create an",
            "        #              enabled key in the project dictionary so this",
            "        #              method override handles this side-effect",
            "        project = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'description': uuid.uuid4().hex}",
            "",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        # self.assignment_api.create_project adds an enabled",
            "        # key with a value of True when LDAPIdentityEnabledEmulation",
            "        # is used so we now add this expected key to the project dictionary",
            "        project['enabled'] = True",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_user_crud(self):",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.skipTest(",
            "            \"Enabled emulation conflicts with enabled mask\")",
            "",
            "",
            "class LdapIdentitySqlAssignment(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                                tests.TestCase):",
            "",
            "    def config_files(self):",
            "        config_files = super(LdapIdentitySqlAssignment, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap_sql.conf'))",
            "        return config_files",
            "",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(LdapIdentitySqlAssignment, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        cache.configure_cache_region(cache.REGION)",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self.load_fixtures(default_fixtures)",
            "        # defaulted by the data load",
            "        self.user_foo['enabled'] = True",
            "",
            "    def config_overrides(self):",
            "        super(LdapIdentitySqlAssignment, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def test_domain_crud(self):",
            "        pass",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual([assignment.calc_default_domain()], domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains doesn't change because the SQL identity",
            "        # backend reads it from the database, which doesn't get updated by",
            "        # config change.",
            "",
            "        orig_default_domain_id = CONF.identity.default_domain_id",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(orig_default_domain_id, domains[0]['id'])",
            "",
            "    def test_project_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_role_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "",
            "class MultiLDAPandSQLIdentity(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                              tests.TestCase):",
            "    \"\"\"Class to test common SQL plus individual LDAP backends.",
            "",
            "    We define a set of domains and domain-specific backends:",
            "",
            "    - A separate LDAP backend for the default domain",
            "    - A separate LDAP backend for domain1",
            "    - domain2 shares the same LDAP as domain1, but uses a different",
            "      tree attach point",
            "    - An SQL backend for all other domains (which will include domain3",
            "      and domain4)",
            "",
            "    Normally one would expect that the default domain would be handled as",
            "    part of the \"other domains\" - however the above provides better",
            "    test coverage since most of the existing backend tests use the default",
            "    domain.",
            "",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(MultiLDAPandSQLIdentity, self).setUp()",
            "",
            "        self.load_backends()",
            "",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self._setup_domain_test_data()",
            "",
            "        # All initial domain data setup complete, time to switch on support",
            "        # for separate backends per domain.",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   domain_specific_drivers_enabled=True,",
            "                                   domain_config_dir=tests.TESTSDIR)",
            "",
            "        self._set_domain_configs()",
            "        self.clear_database()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "    def config_overrides(self):",
            "        super(MultiLDAPandSQLIdentity, self).config_overrides()",
            "        # Make sure identity and assignment are actually SQL drivers,",
            "        # BaseLDAPIdentity sets these options to use LDAP.",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.sql.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def _setup_domain_test_data(self):",
            "",
            "        def create_domain(domain):",
            "            try:",
            "                ref = self.assignment_api.create_domain(",
            "                    domain['id'], domain)",
            "            except exception.Conflict:",
            "                ref = (",
            "                    self.assignment_api.get_domain_by_name(domain['name']))",
            "            return ref",
            "",
            "        self.domain_default = create_domain(assignment.calc_default_domain())",
            "        self.domain1 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain1'})",
            "        self.domain2 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain2'})",
            "        self.domain3 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain3'})",
            "        self.domain4 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain4'})",
            "",
            "    def _set_domain_configs(self):",
            "        # We need to load the domain configs explicitly to ensure the",
            "        # test overrides are included.",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.Default.conf')],",
            "            'Default')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain1.conf')],",
            "            'domain1')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain2.conf')],",
            "            'domain2')",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Just reload the driver for this domain - which will pickup",
            "        # any updated cfg",
            "        self.identity_api.domain_configs.reload_domain_driver(",
            "            self.identity_api.assignment_api, domain_id)",
            "",
            "    def get_config(self, domain_id):",
            "        # Get the config for this domain, will return CONF",
            "        # if no specific config defined for this domain",
            "        return self.identity_api.domain_configs.get_domain_conf(domain_id)",
            "",
            "    def test_list_domains(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_domain_segregation(self):",
            "        \"\"\"Test that separate configs have segregated the domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user in each of the domains",
            "        - Make sure that you can only find a given user in its",
            "          relevant domain",
            "        - Make sure that for a backend that supports multiple domains",
            "          you can get the users via any of the domain scopes",
            "",
            "        \"\"\"",
            "        def create_user(domain_id):",
            "            user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain_id,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "            self.identity_api.create_user(user['id'], user)",
            "            return user",
            "",
            "        userd = create_user(CONF.identity.default_domain_id)",
            "        user1 = create_user(self.domain1['id'])",
            "        user2 = create_user(self.domain2['id'])",
            "        user3 = create_user(self.domain3['id'])",
            "        user4 = create_user(self.domain4['id'])",
            "",
            "        # Now check that I can read user1 with the appropriate domain",
            "        # scope, but won't find it if the wrong scope is used",
            "",
            "        ref = self.identity_api.get_user(",
            "            userd['id'], domain_scope=CONF.identity.default_domain_id)",
            "        del userd['password']",
            "        self.assertDictEqual(ref, userd)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain1['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain2['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain3['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain4['id'])",
            "",
            "        ref = self.identity_api.get_user(",
            "            user1['id'], domain_scope=self.domain1['id'])",
            "        del user1['password']",
            "        self.assertDictEqual(ref, user1)",
            "        ref = self.identity_api.get_user(",
            "            user2['id'], domain_scope=self.domain2['id'])",
            "        del user2['password']",
            "        self.assertDictEqual(ref, user2)",
            "",
            "        # Domains 3 and 4 share the same backend, so you should be",
            "        # able to see user3 and 4 from either",
            "",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain3['id'])",
            "        del user3['password']",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain4['id'])",
            "        del user4['password']",
            "        self.assertDictEqual(ref, user4)",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain4['id'])",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain3['id'])",
            "        self.assertDictEqual(ref, user4)",
            "",
            "    def test_scanning_of_config_dir(self):",
            "        \"\"\"Test the Manager class scans the config directory.",
            "",
            "        The setup for the main tests above load the domain configs directly",
            "        so that the test overrides can be included. This test just makes sure",
            "        that the standard config directory scanning does pick up the relevant",
            "        domain config files.",
            "",
            "        \"\"\"",
            "        # Confirm that config has drivers_enabled as True, which we will",
            "        # check has been set to False later in this test",
            "        self.assertTrue(config.CONF.identity.domain_specific_drivers_enabled)",
            "        self.load_backends()",
            "        # Execute any command to trigger the lazy loading of domain configs",
            "        self.identity_api.list_users(domain_scope=self.domain1['id'])",
            "        # ...and now check the domain configs have been set up",
            "        self.assertIn('default', self.identity_api.domain_configs)",
            "        self.assertIn(self.domain1['id'], self.identity_api.domain_configs)",
            "        self.assertIn(self.domain2['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain3['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain4['id'], self.identity_api.domain_configs)",
            "",
            "        # Finally check that a domain specific config contains items from both",
            "        # the primary config and the domain specific config",
            "        conf = self.identity_api.domain_configs.get_domain_conf(",
            "            self.domain1['id'])",
            "        # This should now be false, as is the default, since this is not",
            "        # set in the standard primary config file",
            "        self.assertFalse(conf.identity.domain_specific_drivers_enabled)",
            "        # ..and make sure a domain-specific options is also set",
            "        self.assertEqual('fake://memory1', conf.ldap.url)",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import uuid",
            "",
            "import ldap",
            "import mock",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone.common import cache",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common.ldap import core as common_ldap_core",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import fakeldap",
            "from keystone.tests.ksfixtures import database",
            "from keystone.tests import test_backend",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class BaseLDAPIdentity(test_backend.IdentityTests):",
            "",
            "    def setUp(self):",
            "        super(BaseLDAPIdentity, self).setUp()",
            "        self.clear_database()",
            "",
            "        common_ldap.register_handler('fake://', fakeldap.FakeLdap)",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.addCleanup(common_ldap_core._HANDLERS.clear)",
            "",
            "    def _get_domain_fixture(self):",
            "        \"\"\"Domains in LDAP are read-only, so just return the static one.\"\"\"",
            "        return self.assignment_api.get_domain(CONF.identity.default_domain_id)",
            "",
            "    def clear_database(self):",
            "        for shelf in fakeldap.FakeShelves:",
            "            fakeldap.FakeShelves[shelf].clear()",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Only one backend unless we are using separate domain backends",
            "        self.load_backends()",
            "",
            "    def get_config(self, domain_id):",
            "        # Only one conf structure unless we are using separate domain backends",
            "        return CONF",
            "",
            "    def config_overrides(self):",
            "        super(BaseLDAPIdentity, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "",
            "    def config_files(self):",
            "        config_files = super(BaseLDAPIdentity, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def test_build_tree(self):",
            "        \"\"\"Regression test for building the tree names",
            "        \"\"\"",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        self.assertTrue(user_api)",
            "        self.assertEqual(\"ou=Users,%s\" % CONF.ldap.suffix, user_api.tree_dn)",
            "",
            "    def test_configurable_allowed_user_actions(self):",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', user_ref['id'])",
            "",
            "        user['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "",
            "        self.identity_api.delete_user(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_user_actions(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        conf.ldap.user_allow_update = False",
            "        conf.ldap.user_allow_delete = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          u'f\u00e4k\u00e91',",
            "                          user)",
            "",
            "        self.user_foo['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.update_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.delete_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_configurable_forbidden_create_existing_user(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "    def test_user_filter(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "        conf = self.get_config(user_ref['domain_id'])",
            "        conf.ldap.user_filter = '(CN=DOES_NOT_MATCH)'",
            "        self.reload_backends(user_ref['domain_id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual([], roles_ref)",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertNotEmpty(roles_ref)",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group2['id'])",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        user_projects = self.assignment_api.list_projects_for_user(",
            "            new_user['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_user_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_group_between_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grant already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the list of assignments - check it is gone up by 2",
            "        after_assignments = len(self.assignment_api.list_role_assignments())",
            "        self.assertEqual(existing_assignments + 2, after_assignments)",
            "",
            "    def test_list_role_assignments_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "",
            "        # Read back the list of assignments and ensure",
            "        # that the LDAP dumb member isn't listed.",
            "        assignment_ids = [a['user_id'] for a in",
            "                          self.assignment_api.list_role_assignments()]",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertNotIn(dumb_id, assignment_ids)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_group_members_missing_entry(self):",
            "        \"\"\"List group members with deleted user.",
            "",
            "        If a group has a deleted entry for a member, the non-deleted members",
            "        are returned.",
            "",
            "        \"\"\"",
            "",
            "        # Create a group",
            "        group_id = None",
            "        group = dict(name=uuid.uuid4().hex,",
            "                     domain_id=CONF.identity.default_domain_id)",
            "        group_id = self.identity_api.create_group(group_id, group)['id']",
            "",
            "        # Create a couple of users and add them to the group.",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_1_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_1_id, group_id)",
            "",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_2_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_2_id, group_id)",
            "",
            "        # Delete user 2",
            "        # NOTE(blk-u): need to go directly to user interface to keep from",
            "        # updating the group.",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.delete(user_2_id)",
            "",
            "        # List group users and verify only user 1.",
            "        res = self.identity_api.list_users_in_group(group_id)",
            "",
            "        self.assertEqual(1, len(res), \"Expected 1 entry (user_1)\")",
            "        self.assertEqual(user_1_id, res[0]['id'], \"Expected user 1 id\")",
            "",
            "    def test_list_group_members_when_no_members(self):",
            "        # List group members when there is no member in the group.",
            "        # No exception should be raised.",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.list_users_in_group(group['id'])",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(",
            "            [assignment.calc_default_domain()],",
            "            domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains changes is the new default_domain_id.",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(new_domain_id, domains[0]['id'])",
            "",
            "    def test_authenticate_requires_simple_bind(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': test_backend.DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "            'enabled': True,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.LDAP_USER = None",
            "        driver.user.LDAP_PASSWORD = None",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=user['id'],",
            "                          password=None,",
            "                          domain_scope=user['domain_id'])",
            "",
            "    # (spzala)The group and domain crud tests below override the standard ones",
            "    # in test_backend.py so that we can exclude the update name test, since we",
            "    # do not yet support the update of either group or domain names with LDAP.",
            "    # In the tests below, the update is demonstrated by updating description.",
            "    # Refer to bug 1136403 for more detail.",
            "    def test_group_crud(self):",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "        group['description'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_user_none_mapping(self):",
            "        # When create a user where an attribute maps to None, the entry is",
            "        # created without that attribute and it doesn't fail with a TypeError.",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_attribute_ignore = ['enabled', 'email',",
            "                                           'tenants', 'tenantId']",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'default_project_id': 'maps_to_none',",
            "                }",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "    def test_update_user_name(self):",
            "        \"\"\"A user's name cannot be changed through the LDAP driver.\"\"\"",
            "        self.assertRaises(exception.Conflict,",
            "                          super(BaseLDAPIdentity, self).test_update_user_name)",
            "",
            "    def test_attribute_update(self):",
            "        self.skipTest(\"Blank value in a required field is an error in LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_user_id_comma(self):",
            "        \"\"\"Even if the user has a , in their ID, groups can be listed.\"\"\"",
            "",
            "        # Create a user with a , in their ID",
            "        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!",
            "        user_id = u'Doe, John'",
            "        user = {",
            "            'id': user_id,",
            "            'name': self.getUniqueString(),",
            "            'password': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_user(user_id, user)",
            "",
            "        # Create a group",
            "        group_id = uuid.uuid4().hex",
            "        group = {",
            "            'id': group_id,",
            "            'name': self.getUniqueString(prefix='tuidc'),",
            "            'description': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_group(group_id, group)",
            "",
            "        # Put the user in the group",
            "        self.identity_api.add_user_to_group(user_id, group_id)",
            "",
            "        # List groups for user.",
            "        ref_list = self.identity_api.list_groups_for_user(user_id)",
            "",
            "        self.assertThat(ref_list, matchers.Equals([group]))",
            "",
            "",
            "class LDAPIdentity(BaseLDAPIdentity, tests.TestCase):",
            "",
            "    def setUp(self):",
            "        # NOTE(dstanek): The database must be setup prior to calling the",
            "        # parent's setUp. The parent's setUp uses services (like",
            "        # credentials) that require a database.",
            "        self.useFixture(database.Database())",
            "        super(LDAPIdentity, self).setUp()",
            "",
            "    def test_configurable_allowed_project_actions(self):",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True}",
            "        self.assignment_api.create_project(u'f\u00e4k\u00e91', tenant)",
            "        tenant_ref = self.assignment_api.get_project(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', tenant_ref['id'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project(u'f\u00e4k\u00e91', tenant)",
            "",
            "        self.assignment_api.delete_project(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_subtree_delete(self):",
            "        self.config_fixture.config(group='ldap', allow_subtree_delete=True)",
            "        self.load_backends()",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role1['id'])",
            "",
            "        self.assignment_api.delete_project(project1['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project1['id'])",
            "",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(0, len(list))",
            "",
            "    def test_configurable_forbidden_project_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_allow_create=False, tenant_allow_update=False,",
            "            tenant_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_project,",
            "                          u'f\u00e4k\u00e91',",
            "                          tenant)",
            "",
            "        self.tenant_bar['enabled'] = False",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_project,",
            "                          self.tenant_bar['id'],",
            "                          self.tenant_bar)",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_configurable_allowed_role_actions(self):",
            "        role = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assignment_api.create_role(u'f\u00e4k\u00e91', role)",
            "        role_ref = self.assignment_api.get_role(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', role_ref['id'])",
            "",
            "        role['name'] = u'f\u00e4k\u00e92'",
            "        self.assignment_api.update_role(u'f\u00e4k\u00e91', role)",
            "",
            "        self.assignment_api.delete_role(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_role_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', role_allow_create=False, role_allow_update=False,",
            "            role_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "        self.role_member['name'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_role,",
            "                          self.role_member['id'],",
            "                          self.role_member)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_project_filter(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_filter  will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assignment_api.get_role(self.role_member['id'])",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_bar['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_role_filter(self):",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertDictEqual(role_ref, self.role_member)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_filter will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          dumb_id)",
            "",
            "    def test_project_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_name_attribute='ou',",
            "            tenant_desc_attribute='description',",
            "            tenant_enabled_attribute='enabled')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['name'])",
            "        self.assertEqual(",
            "            self.tenant_baz['description'],",
            "            tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_name_attribute='description',",
            "                                   tenant_desc_attribute='ou')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['description'], tenant_ref['name'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "    def test_project_attribute_ignore(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            tenant_attribute_ignore=['name', 'description', 'enabled'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change configs values in tests",
            "        # that could affect what the drivers would return up to the manager.",
            "        # This solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertNotIn('name', tenant_ref)",
            "        self.assertNotIn('description', tenant_ref)",
            "        self.assertNotIn('enabled', tenant_ref)",
            "",
            "    def test_role_attribute_mapping(self):",
            "        self.config_fixture.config(group='ldap', role_name_attribute='ou')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertEqual(self.role_member['name'], role_ref['name'])",
            "",
            "        self.config_fixture.config(group='ldap', role_name_attribute='sn')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_role_attribute_ignore(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_attribute_ignore=['name'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.config_fixture.config(group='ldap', user_enabled_mask=2,",
            "                                   user_enabled_default='512')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        ldap_ = self.identity_api.driver.user.get_connection()",
            "",
            "        def get_enabled_vals():",
            "            user_dn = self.identity_api.driver.user._id_to_dn_string(u'f\u00e4k\u00e91')",
            "            enabled_attr_name = CONF.ldap.user_enabled_attribute",
            "",
            "            res = ldap_.search_s(user_dn,",
            "                                 ldap.SCOPE_BASE,",
            "                                 u'(sn=f\u00e4k\u00e91)')",
            "            return res[0][1][enabled_attr_name]",
            "",
            "        user = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True,",
            "                'domain_id': CONF.identity.default_domain_id}",
            "",
            "        user_ref = self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "        # Use assertIs rather than assertTrue because assertIs will assert the",
            "        # value is a Boolean as expected.",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = False",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([514], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'simple_bind_s')",
            "    def test_user_api_get_connection_no_user_password(self, mocked_method):",
            "        \"\"\"Don't bind in case the user and password are blank.\"\"\"",
            "        # Ensure the username/password are in-fact blank",
            "        self.config_fixture.config(group='ldap', user=None, password=None)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "        self.assertFalse(mocked_method.called,",
            "                         msg='`simple_bind_s` method was unexpectedly called')",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_off(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=False)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertFalse(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_on(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=True)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertTrue(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_debug_level_set(self, mocked_fakeldap):",
            "        level = 12345",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            debug_level=level)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # debug_level. Check to make sure the value of debug_level",
            "        # is as expected.",
            "        self.assertEqual(level, mocked_fakeldap.call_args[-1]['debug_level'])",
            "",
            "    def test_wrong_ldap_scope(self):",
            "        self.config_fixture.config(group='ldap', query_scope=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP scope: %s. *' % CONF.ldap.query_scope,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_wrong_alias_dereferencing(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   alias_dereferencing=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP deref option: %s\\.' % CONF.ldap.alias_dereferencing,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_user_extra_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:name'])",
            "        self.load_backends()",
            "        user = {",
            "            'id': 'extra_attributes',",
            "            'name': 'EXTRA_ATTRIBUTES',",
            "            'password': 'extra',",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        dn, attrs = self.identity_api.driver.user._ldap_get(user['id'])",
            "        self.assertTrue(user['name'] in attrs['description'])",
            "",
            "    def test_user_extra_attribute_mapping_description_is_returned(self):",
            "        # Given a mapping like description:description, the description is",
            "        # returned.",
            "",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:description'])",
            "        self.load_backends()",
            "",
            "        description = uuid.uuid4().hex",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': description,",
            "            'password': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        res = self.identity_api.driver.user.get_all()",
            "",
            "        new_user = [u for u in res if u['id'] == user['id']][0]",
            "        self.assertThat(new_user['description'], matchers.Equals(description))",
            "",
            "    @mock.patch.object(common_ldap_core.BaseLdap, '_ldap_get')",
            "    def test_user_mixed_case_attribute(self, mock_ldap_get):",
            "        # Mock the search results to return attribute names",
            "        # with unexpected case.",
            "        mock_ldap_get.return_value = (",
            "            'cn=junk,dc=example,dc=com',",
            "            {",
            "                'sN': [uuid.uuid4().hex],",
            "                'eMaIl': [uuid.uuid4().hex]",
            "            }",
            "        )",
            "        user = self.identity_api.get_user('junk')",
            "        self.assertEqual(mock_ldap_get.return_value[1]['sN'][0],",
            "                         user['name'])",
            "        self.assertEqual(mock_ldap_get.return_value[1]['eMaIl'][0],",
            "                         user['email'])",
            "",
            "    def test_parse_extra_attribute_mapping(self):",
            "        option_list = ['description:name', 'gecos:password',",
            "                       'fake:invalid', 'invalid1', 'invalid2:',",
            "                       'description:name:something']",
            "        mapping = self.identity_api.driver.user._parse_extra_attrs(option_list)",
            "        expected_dict = {'description': 'name', 'gecos': 'password',",
            "                         'fake': 'invalid', 'invalid2': ''}",
            "        self.assertDictEqual(expected_dict, mapping)",
            "",
            "# TODO(henry-nash): These need to be removed when the full LDAP implementation",
            "# is submitted - see Bugs 1092187, 1101287, 1101276, 1101289",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True, 'description': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "        domain['description'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.update_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.update_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.delete_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.delete_domain,",
            "                          CONF.identity.default_domain_id)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # domains are read-only, so case sensitivity isn't an issue",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_cache_layer_domain_crud(self):",
            "        # TODO(morganfainberg): This also needs to be removed when full LDAP",
            "        # implementation is submitted.  No need to duplicate the above test,",
            "        # just skip this time.",
            "        self.skipTest('Domains are read-only against LDAP')",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAP implementation does not currently support the",
            "        #              updating of a project name so this method override",
            "        #              provides a different update test",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex, 'enabled': True",
            "                   }",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        # NOTE(morganfainberg): LDAP implementation does not currently support",
            "        # updating project names.  This method override provides a different",
            "        # update test.",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex}",
            "        project_id = project['id']",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['description'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        # This is a partial implementation of the standard test that",
            "        # is defined in test_backend.py.  It omits both domain and",
            "        # group grants. since neither of these are yet supported by",
            "        # the ldap backend.",
            "",
            "        role_list = []",
            "        for _ in range(2):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[0]['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[1]['id'])",
            "",
            "        # Although list_grants are not yet supported, we can test the",
            "        # alternate way of getting back lists of grants, where user",
            "        # and group roles are combined.  Only directly assigned user",
            "        # roles are available, since group grants are not yet supported",
            "",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[1]['id'], combined_list)",
            "",
            "        # Finally, although domain roles are not implemented, check we can",
            "        # issue the combined get roles call with benign results, since thus is",
            "        # used in token generation",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], CONF.identity.default_domain_id)",
            "        self.assertEqual(0, len(combined_role_list))",
            "",
            "    def test_get_roles_for_user_and_project_user_group_same_id(self):",
            "        \"\"\"When a user has the same ID as a group,",
            "        get_roles_for_user_and_project returns the roles for the group.",
            "",
            "        Overriding this test for LDAP because it works differently. The role",
            "        for the group is returned. This is bug 1309228.",
            "        \"\"\"",
            "",
            "        # Setup: create user, group with same ID, role, and project;",
            "        # assign the group the role on the project.",
            "",
            "        user_group_id = uuid.uuid4().hex",
            "",
            "        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id, }",
            "        self.identity_api.create_user(user_group_id, user1)",
            "",
            "        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                  'domain_id': CONF.identity.default_domain_id, }",
            "        self.identity_api.create_group(user_group_id, group1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id, }",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.create_grant(role1['id'],",
            "                                         group_id=user_group_id,",
            "                                         project_id=project1['id'])",
            "",
            "        # Check the roles, shouldn't be any since the user wasn't granted any.",
            "        roles = self.assignment_api.get_roles_for_user_and_project(",
            "            user_group_id, project1['id'])",
            "",
            "        self.assertEqual([role1['id']], roles,",
            "                         'role for group is %s' % role1['id'])",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_create_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_create_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain = self._get_domain_fixture()",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain['name'])",
            "        self.assertEqual(domain_ref, domain)",
            "",
            "    def test_base_ldap_connection_deref_option(self):",
            "        def get_conn(deref_name):",
            "            self.config_fixture.config(group='ldap',",
            "                                       alias_dereferencing=deref_name)",
            "            base_ldap = common_ldap.BaseLdap(CONF)",
            "            return base_ldap.get_connection()",
            "",
            "        conn = get_conn('default')",
            "        self.assertEqual(ldap.get_option(ldap.OPT_DEREF),",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('always')",
            "        self.assertEqual(ldap.DEREF_ALWAYS,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('finding')",
            "        self.assertEqual(ldap.DEREF_FINDING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('never')",
            "        self.assertEqual(ldap.DEREF_NEVER,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('searching')",
            "        self.assertEqual(ldap.DEREF_SEARCHING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "    def test_list_users_no_dn(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('dn', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups_no_dn(self):",
            "        # Create some test groups.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "        # Fetch the test groups and ensure that they don't contain a dn.",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "    def test_list_groups_for_user_no_dn(self):",
            "        # Create a test user.",
            "        user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'password': uuid.uuid4().hex,",
            "                'enabled': True}",
            "        self.identity_api.create_user(user['id'], user)",
            "        # Create some test groups and add the test user as a member.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "            self.identity_api.add_user_to_group(user['id'], group['id'])",
            "        # Fetch the groups for the test user",
            "        # and ensure they don't contain a dn.",
            "        groups = self.identity_api.list_groups_for_user(user['id'])",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "",
            "class LDAPIdentityEnabledEmulation(LDAPIdentity):",
            "    def setUp(self):",
            "        super(LDAPIdentityEnabledEmulation, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        for obj in [self.tenant_bar, self.tenant_baz, self.user_foo,",
            "                    self.user_two, self.user_badguy]:",
            "            obj.setdefault('enabled', True)",
            "",
            "    def config_files(self):",
            "        config_files = super(LDAPIdentityEnabledEmulation, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def config_overrides(self):",
            "        super(LDAPIdentityEnabledEmulation, self).config_overrides()",
            "        self.config_fixture.config(group='ldap',",
            "                                   user_enabled_emulation=True,",
            "                                   tenant_enabled_emulation=True)",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAPIdentityEnabledEmulation will create an",
            "        #              enabled key in the project dictionary so this",
            "        #              method override handles this side-effect",
            "        project = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'description': uuid.uuid4().hex}",
            "",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        # self.assignment_api.create_project adds an enabled",
            "        # key with a value of True when LDAPIdentityEnabledEmulation",
            "        # is used so we now add this expected key to the project dictionary",
            "        project['enabled'] = True",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_user_crud(self):",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.skipTest(",
            "            \"Enabled emulation conflicts with enabled mask\")",
            "",
            "",
            "class LdapIdentitySqlAssignment(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                                tests.TestCase):",
            "",
            "    def config_files(self):",
            "        config_files = super(LdapIdentitySqlAssignment, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap_sql.conf'))",
            "        return config_files",
            "",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(LdapIdentitySqlAssignment, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        cache.configure_cache_region(cache.REGION)",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self.load_fixtures(default_fixtures)",
            "        # defaulted by the data load",
            "        self.user_foo['enabled'] = True",
            "",
            "    def config_overrides(self):",
            "        super(LdapIdentitySqlAssignment, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def test_domain_crud(self):",
            "        pass",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual([assignment.calc_default_domain()], domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains doesn't change because the SQL identity",
            "        # backend reads it from the database, which doesn't get updated by",
            "        # config change.",
            "",
            "        orig_default_domain_id = CONF.identity.default_domain_id",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(orig_default_domain_id, domains[0]['id'])",
            "",
            "    def test_project_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_role_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "",
            "class MultiLDAPandSQLIdentity(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                              tests.TestCase):",
            "    \"\"\"Class to test common SQL plus individual LDAP backends.",
            "",
            "    We define a set of domains and domain-specific backends:",
            "",
            "    - A separate LDAP backend for the default domain",
            "    - A separate LDAP backend for domain1",
            "    - domain2 shares the same LDAP as domain1, but uses a different",
            "      tree attach point",
            "    - An SQL backend for all other domains (which will include domain3",
            "      and domain4)",
            "",
            "    Normally one would expect that the default domain would be handled as",
            "    part of the \"other domains\" - however the above provides better",
            "    test coverage since most of the existing backend tests use the default",
            "    domain.",
            "",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(MultiLDAPandSQLIdentity, self).setUp()",
            "",
            "        self.load_backends()",
            "",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self._setup_domain_test_data()",
            "",
            "        # All initial domain data setup complete, time to switch on support",
            "        # for separate backends per domain.",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   domain_specific_drivers_enabled=True,",
            "                                   domain_config_dir=tests.TESTSDIR)",
            "",
            "        self._set_domain_configs()",
            "        self.clear_database()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "    def config_overrides(self):",
            "        super(MultiLDAPandSQLIdentity, self).config_overrides()",
            "        # Make sure identity and assignment are actually SQL drivers,",
            "        # BaseLDAPIdentity sets these options to use LDAP.",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.sql.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def _setup_domain_test_data(self):",
            "",
            "        def create_domain(domain):",
            "            try:",
            "                ref = self.assignment_api.create_domain(",
            "                    domain['id'], domain)",
            "            except exception.Conflict:",
            "                ref = (",
            "                    self.assignment_api.get_domain_by_name(domain['name']))",
            "            return ref",
            "",
            "        self.domain_default = create_domain(assignment.calc_default_domain())",
            "        self.domain1 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain1'})",
            "        self.domain2 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain2'})",
            "        self.domain3 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain3'})",
            "        self.domain4 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain4'})",
            "",
            "    def _set_domain_configs(self):",
            "        # We need to load the domain configs explicitly to ensure the",
            "        # test overrides are included.",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.Default.conf')],",
            "            'Default')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain1.conf')],",
            "            'domain1')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain2.conf')],",
            "            'domain2')",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Just reload the driver for this domain - which will pickup",
            "        # any updated cfg",
            "        self.identity_api.domain_configs.reload_domain_driver(",
            "            self.identity_api.assignment_api, domain_id)",
            "",
            "    def get_config(self, domain_id):",
            "        # Get the config for this domain, will return CONF",
            "        # if no specific config defined for this domain",
            "        return self.identity_api.domain_configs.get_domain_conf(domain_id)",
            "",
            "    def test_list_domains(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_domain_segregation(self):",
            "        \"\"\"Test that separate configs have segregated the domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user in each of the domains",
            "        - Make sure that you can only find a given user in its",
            "          relevant domain",
            "        - Make sure that for a backend that supports multiple domains",
            "          you can get the users via any of the domain scopes",
            "",
            "        \"\"\"",
            "        def create_user(domain_id):",
            "            user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain_id,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "            self.identity_api.create_user(user['id'], user)",
            "            return user",
            "",
            "        userd = create_user(CONF.identity.default_domain_id)",
            "        user1 = create_user(self.domain1['id'])",
            "        user2 = create_user(self.domain2['id'])",
            "        user3 = create_user(self.domain3['id'])",
            "        user4 = create_user(self.domain4['id'])",
            "",
            "        # Now check that I can read user1 with the appropriate domain",
            "        # scope, but won't find it if the wrong scope is used",
            "",
            "        ref = self.identity_api.get_user(",
            "            userd['id'], domain_scope=CONF.identity.default_domain_id)",
            "        del userd['password']",
            "        self.assertDictEqual(ref, userd)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain1['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain2['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain3['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain4['id'])",
            "",
            "        ref = self.identity_api.get_user(",
            "            user1['id'], domain_scope=self.domain1['id'])",
            "        del user1['password']",
            "        self.assertDictEqual(ref, user1)",
            "        ref = self.identity_api.get_user(",
            "            user2['id'], domain_scope=self.domain2['id'])",
            "        del user2['password']",
            "        self.assertDictEqual(ref, user2)",
            "",
            "        # Domains 3 and 4 share the same backend, so you should be",
            "        # able to see user3 and 4 from either",
            "",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain3['id'])",
            "        del user3['password']",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain4['id'])",
            "        del user4['password']",
            "        self.assertDictEqual(ref, user4)",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain4['id'])",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain3['id'])",
            "        self.assertDictEqual(ref, user4)",
            "",
            "    def test_scanning_of_config_dir(self):",
            "        \"\"\"Test the Manager class scans the config directory.",
            "",
            "        The setup for the main tests above load the domain configs directly",
            "        so that the test overrides can be included. This test just makes sure",
            "        that the standard config directory scanning does pick up the relevant",
            "        domain config files.",
            "",
            "        \"\"\"",
            "        # Confirm that config has drivers_enabled as True, which we will",
            "        # check has been set to False later in this test",
            "        self.assertTrue(config.CONF.identity.domain_specific_drivers_enabled)",
            "        self.load_backends()",
            "        # Execute any command to trigger the lazy loading of domain configs",
            "        self.identity_api.list_users(domain_scope=self.domain1['id'])",
            "        # ...and now check the domain configs have been set up",
            "        self.assertIn('default', self.identity_api.domain_configs)",
            "        self.assertIn(self.domain1['id'], self.identity_api.domain_configs)",
            "        self.assertIn(self.domain2['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain3['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain4['id'], self.identity_api.domain_configs)",
            "",
            "        # Finally check that a domain specific config contains items from both",
            "        # the primary config and the domain specific config",
            "        conf = self.identity_api.domain_configs.get_domain_conf(",
            "            self.domain1['id'])",
            "        # This should now be false, as is the default, since this is not",
            "        # set in the standard primary config file",
            "        self.assertFalse(conf.identity.domain_specific_drivers_enabled)",
            "        # ..and make sure a domain-specific options is also set",
            "        self.assertEqual('fake://memory1', conf.ldap.url)",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "airflow.www.views.Airflow",
            "keystone.tests.test_backend_ldap.BaseLDAPIdentity.self",
            "keystone.tests.test_backend_ldap.LDAPIdentity.self"
        ]
    }
}