{
    "strawberry/aiohttp/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             GRAPHQL_WS_PROTOCOL,"
            },
            "1": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         ),"
            },
            "2": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         connection_init_wait_timeout: timedelta = timedelta(minutes=1),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     ) -> None:"
            },
            "5": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         self.schema = schema"
            },
            "6": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         self.allow_queries_via_get = allow_queries_via_get"
            },
            "7": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         self.debug = debug"
            },
            "8": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         self.subscription_protocols = subscription_protocols"
            },
            "9": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.connection_init_wait_timeout = connection_init_wait_timeout"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "11": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "13": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             warnings.warn("
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import warnings",
            "from datetime import timedelta",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from aiohttp import web",
            "from aiohttp.multipart import BodyPartReader",
            "from strawberry.aiohttp.handlers import (",
            "    GraphQLTransportWSHandler,",
            "    GraphQLWSHandler,",
            ")",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "class AioHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: web.Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query.copy()  # type: ignore[attr-defined]",
            "",
            "    async def get_body(self) -> str:",
            "        return (await self.request.content.read()).decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        reader = await self.request.multipart()",
            "",
            "        data: Dict[str, Any] = {}",
            "        files: Dict[str, Any] = {}",
            "",
            "        async for field in reader:",
            "            assert isinstance(field, BodyPartReader)",
            "            assert field.name",
            "",
            "            if field.filename:",
            "                files[field.name] = BytesIO(await field.read(decode=False))",
            "            else:",
            "                data[field.name] = await field.text()",
            "",
            "        return FormData(files=files, form=data)",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"content-type\")",
            "",
            "",
            "class GraphQLView(",
            "    AsyncBaseHTTPView[",
            "        web.Request,",
            "        Union[web.Response, web.StreamResponse],",
            "        web.Response,",
            "        Context,",
            "        RootValue,",
            "    ]",
            "):",
            "    # Mark the view as coroutine so that AIOHTTP does not confuse it with a deprecated",
            "    # bare handler function.",
            "    _is_coroutine = asyncio.coroutines._is_coroutine  # type: ignore[attr-defined]",
            "",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = AioHTTPRequestAdapter",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = True,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        subscription_protocols: Iterable[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.subscription_protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    async def render_graphql_ide(self, request: web.Request) -> web.Response:",
            "        return web.Response(text=self.graphql_ide_html, content_type=\"text/html\")",
            "",
            "    async def get_sub_response(self, request: web.Request) -> web.Response:",
            "        return web.Response()",
            "",
            "    async def __call__(self, request: web.Request) -> web.StreamResponse:",
            "        ws = web.WebSocketResponse(protocols=self.subscription_protocols)",
            "        ws_test = ws.can_prepare(request)",
            "",
            "        if not ws_test.ok:",
            "            try:",
            "                return await self.run(request=request)",
            "            except HTTPException as e:",
            "                return web.Response(",
            "                    body=e.reason,",
            "                    status=e.status_code,",
            "                )",
            "",
            "        if ws_test.protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "            return await self.graphql_transport_ws_handler_class(",
            "                schema=self.schema,",
            "                debug=self.debug,",
            "                connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                get_context=self.get_context,  # type: ignore",
            "                get_root_value=self.get_root_value,",
            "                request=request,",
            "            ).handle()",
            "        elif ws_test.protocol == GRAPHQL_WS_PROTOCOL:",
            "            return await self.graphql_ws_handler_class(",
            "                schema=self.schema,",
            "                debug=self.debug,",
            "                keep_alive=self.keep_alive,",
            "                keep_alive_interval=self.keep_alive_interval,",
            "                get_context=self.get_context,",
            "                get_root_value=self.get_root_value,",
            "                request=request,",
            "            ).handle()",
            "        else:",
            "            await ws.prepare(request)",
            "            await ws.close(code=4406, message=b\"Subprotocol not acceptable\")",
            "            return ws",
            "",
            "    async def get_root_value(self, request: web.Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    async def get_context(",
            "        self, request: web.Request, response: web.Response",
            "    ) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: web.Response",
            "    ) -> web.Response:",
            "        sub_response.text = self.encode_json(response_data)",
            "        sub_response.content_type = \"application/json\"",
            "",
            "        return sub_response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: web.Request,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: web.Response,",
            "        headers: Dict[str, str],",
            "    ) -> web.StreamResponse:",
            "        response = web.StreamResponse(",
            "            status=sub_response.status,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "        await response.prepare(request)",
            "",
            "        async for data in stream():",
            "            await response.write(data.encode())",
            "",
            "        await response.write_eof()",
            "",
            "        return response",
            "",
            "",
            "__all__ = [\"GraphQLView\"]"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import warnings",
            "from datetime import timedelta",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from aiohttp import web",
            "from aiohttp.multipart import BodyPartReader",
            "from strawberry.aiohttp.handlers import (",
            "    GraphQLTransportWSHandler,",
            "    GraphQLWSHandler,",
            ")",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "class AioHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: web.Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query.copy()  # type: ignore[attr-defined]",
            "",
            "    async def get_body(self) -> str:",
            "        return (await self.request.content.read()).decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        reader = await self.request.multipart()",
            "",
            "        data: Dict[str, Any] = {}",
            "        files: Dict[str, Any] = {}",
            "",
            "        async for field in reader:",
            "            assert isinstance(field, BodyPartReader)",
            "            assert field.name",
            "",
            "            if field.filename:",
            "                files[field.name] = BytesIO(await field.read(decode=False))",
            "            else:",
            "                data[field.name] = await field.text()",
            "",
            "        return FormData(files=files, form=data)",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"content-type\")",
            "",
            "",
            "class GraphQLView(",
            "    AsyncBaseHTTPView[",
            "        web.Request,",
            "        Union[web.Response, web.StreamResponse],",
            "        web.Response,",
            "        Context,",
            "        RootValue,",
            "    ]",
            "):",
            "    # Mark the view as coroutine so that AIOHTTP does not confuse it with a deprecated",
            "    # bare handler function.",
            "    _is_coroutine = asyncio.coroutines._is_coroutine  # type: ignore[attr-defined]",
            "",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = AioHTTPRequestAdapter",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = True,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        subscription_protocols: Iterable[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "        multipart_uploads_enabled: bool = False,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.subscription_protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    async def render_graphql_ide(self, request: web.Request) -> web.Response:",
            "        return web.Response(text=self.graphql_ide_html, content_type=\"text/html\")",
            "",
            "    async def get_sub_response(self, request: web.Request) -> web.Response:",
            "        return web.Response()",
            "",
            "    async def __call__(self, request: web.Request) -> web.StreamResponse:",
            "        ws = web.WebSocketResponse(protocols=self.subscription_protocols)",
            "        ws_test = ws.can_prepare(request)",
            "",
            "        if not ws_test.ok:",
            "            try:",
            "                return await self.run(request=request)",
            "            except HTTPException as e:",
            "                return web.Response(",
            "                    body=e.reason,",
            "                    status=e.status_code,",
            "                )",
            "",
            "        if ws_test.protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "            return await self.graphql_transport_ws_handler_class(",
            "                schema=self.schema,",
            "                debug=self.debug,",
            "                connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                get_context=self.get_context,  # type: ignore",
            "                get_root_value=self.get_root_value,",
            "                request=request,",
            "            ).handle()",
            "        elif ws_test.protocol == GRAPHQL_WS_PROTOCOL:",
            "            return await self.graphql_ws_handler_class(",
            "                schema=self.schema,",
            "                debug=self.debug,",
            "                keep_alive=self.keep_alive,",
            "                keep_alive_interval=self.keep_alive_interval,",
            "                get_context=self.get_context,",
            "                get_root_value=self.get_root_value,",
            "                request=request,",
            "            ).handle()",
            "        else:",
            "            await ws.prepare(request)",
            "            await ws.close(code=4406, message=b\"Subprotocol not acceptable\")",
            "            return ws",
            "",
            "    async def get_root_value(self, request: web.Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    async def get_context(",
            "        self, request: web.Request, response: web.Response",
            "    ) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: web.Response",
            "    ) -> web.Response:",
            "        sub_response.text = self.encode_json(response_data)",
            "        sub_response.content_type = \"application/json\"",
            "",
            "        return sub_response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: web.Request,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: web.Response,",
            "        headers: Dict[str, str],",
            "    ) -> web.StreamResponse:",
            "        response = web.StreamResponse(",
            "            status=sub_response.status,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "        await response.prepare(request)",
            "",
            "        async for data in stream():",
            "            await response.write(data.encode())",
            "",
            "        await response.write_eof()",
            "",
            "        return response",
            "",
            "",
            "__all__ = [\"GraphQLView\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "yt_dlp.YoutubeDL",
            "strawberry.aiohttp.views.GraphQLView"
        ]
    },
    "strawberry/asgi/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             GRAPHQL_WS_PROTOCOL,"
            },
            "1": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         ),"
            },
            "2": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         connection_init_wait_timeout: timedelta = timedelta(minutes=1),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "     ) -> None:"
            },
            "5": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         self.schema = schema"
            },
            "6": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         self.allow_queries_via_get = allow_queries_via_get"
            },
            "7": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self.debug = debug"
            },
            "8": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         self.protocols = subscription_protocols"
            },
            "9": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         self.connection_init_wait_timeout = connection_init_wait_timeout"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "11": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "13": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "             warnings.warn("
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from datetime import timedelta",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlette import status",
            "from starlette.requests import Request",
            "from starlette.responses import (",
            "    HTMLResponse,",
            "    PlainTextResponse,",
            "    Response,",
            "    StreamingResponse,",
            ")",
            "from starlette.websockets import WebSocket",
            "",
            "from strawberry.asgi.handlers import (",
            "    GraphQLTransportWSHandler,",
            "    GraphQLWSHandler,",
            ")",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from starlette.types import Receive, Scope, Send",
            "",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "class ASGIRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query_params",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.headers.get(\"content-type\")",
            "",
            "    async def get_body(self) -> bytes:",
            "        return await self.request.body()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        multipart_data = await self.request.form()",
            "",
            "        return FormData(",
            "            files=multipart_data,",
            "            form=multipart_data,",
            "        )",
            "",
            "",
            "class GraphQL(",
            "    AsyncBaseHTTPView[",
            "        Union[Request, WebSocket],",
            "        Response,",
            "        Response,",
            "        Context,",
            "        RootValue,",
            "    ]",
            "):",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = ASGIRequestAdapter  # pyright: ignore",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = False,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        subscription_protocols: Sequence[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] == \"http\":",
            "            return await self.handle_http(scope, receive, send)",
            "",
            "        elif scope[\"type\"] == \"websocket\":",
            "            ws = WebSocket(scope, receive=receive, send=send)",
            "            preferred_protocol = self.pick_preferred_protocol(ws)",
            "",
            "            if preferred_protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "                await self.graphql_transport_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                    get_context=self.get_context,",
            "                    get_root_value=self.get_root_value,",
            "                    ws=ws,",
            "                ).handle()",
            "",
            "            elif preferred_protocol == GRAPHQL_WS_PROTOCOL:",
            "                await self.graphql_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    keep_alive=self.keep_alive,",
            "                    keep_alive_interval=self.keep_alive_interval,",
            "                    get_context=self.get_context,",
            "                    get_root_value=self.get_root_value,",
            "                    ws=ws,",
            "                ).handle()",
            "",
            "            else:",
            "                # Subprotocol not acceptable",
            "                await ws.close(code=4406)",
            "",
            "        else:  # pragma: no cover",
            "            raise ValueError(\"Unknown scope type: {!r}\".format(scope[\"type\"]))",
            "",
            "    def pick_preferred_protocol(self, ws: WebSocket) -> Optional[str]:",
            "        protocols = ws[\"subprotocols\"]",
            "        intersection = set(protocols) & set(self.protocols)",
            "        sorted_intersection = sorted(intersection, key=protocols.index)",
            "        return next(iter(sorted_intersection), None)",
            "",
            "    async def get_root_value(self, request: Union[Request, WebSocket]) -> Optional[Any]:",
            "        return None",
            "",
            "    async def get_context(",
            "        self, request: Union[Request, WebSocket], response: Response",
            "    ) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    async def get_sub_response(",
            "        self,",
            "        request: Union[Request, WebSocket],",
            "    ) -> Response:",
            "        sub_response = Response()",
            "        sub_response.status_code = None  # type: ignore",
            "        del sub_response.headers[\"content-length\"]",
            "",
            "        return sub_response",
            "",
            "    async def handle_http(",
            "        self,",
            "        scope: Scope,",
            "        receive: Receive,",
            "        send: Send,",
            "    ) -> None:",
            "        request = Request(scope=scope, receive=receive)",
            "",
            "        try:",
            "            response = await self.run(request)",
            "        except HTTPException as e:",
            "            response = PlainTextResponse(e.reason, status_code=e.status_code)  # pyright: ignore",
            "",
            "        await response(scope, receive, send)",
            "",
            "    async def render_graphql_ide(self, request: Union[Request, WebSocket]) -> Response:",
            "        return HTMLResponse(self.graphql_ide_html)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        response = Response(",
            "            self.encode_json(response_data),",
            "            status_code=status.HTTP_200_OK,",
            "            media_type=\"application/json\",",
            "        )",
            "",
            "        response.headers.raw.extend(sub_response.headers.raw)",
            "",
            "        if sub_response.background:",
            "            response.background = sub_response.background",
            "",
            "        if sub_response.status_code:",
            "            response.status_code = sub_response.status_code",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request | WebSocket,",
            "        stream: Callable[[], AsyncIterator[str]],",
            "        sub_response: Response,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        return StreamingResponse(",
            "            stream(),",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from datetime import timedelta",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Sequence,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlette import status",
            "from starlette.requests import Request",
            "from starlette.responses import (",
            "    HTMLResponse,",
            "    PlainTextResponse,",
            "    Response,",
            "    StreamingResponse,",
            ")",
            "from starlette.websockets import WebSocket",
            "",
            "from strawberry.asgi.handlers import (",
            "    GraphQLTransportWSHandler,",
            "    GraphQLWSHandler,",
            ")",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from starlette.types import Receive, Scope, Send",
            "",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "class ASGIRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query_params",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.headers.get(\"content-type\")",
            "",
            "    async def get_body(self) -> bytes:",
            "        return await self.request.body()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        multipart_data = await self.request.form()",
            "",
            "        return FormData(",
            "            files=multipart_data,",
            "            form=multipart_data,",
            "        )",
            "",
            "",
            "class GraphQL(",
            "    AsyncBaseHTTPView[",
            "        Union[Request, WebSocket],",
            "        Response,",
            "        Response,",
            "        Context,",
            "        RootValue,",
            "    ]",
            "):",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = ASGIRequestAdapter  # pyright: ignore",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = False,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        subscription_protocols: Sequence[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "        multipart_uploads_enabled: bool = False,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] == \"http\":",
            "            return await self.handle_http(scope, receive, send)",
            "",
            "        elif scope[\"type\"] == \"websocket\":",
            "            ws = WebSocket(scope, receive=receive, send=send)",
            "            preferred_protocol = self.pick_preferred_protocol(ws)",
            "",
            "            if preferred_protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "                await self.graphql_transport_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                    get_context=self.get_context,",
            "                    get_root_value=self.get_root_value,",
            "                    ws=ws,",
            "                ).handle()",
            "",
            "            elif preferred_protocol == GRAPHQL_WS_PROTOCOL:",
            "                await self.graphql_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    keep_alive=self.keep_alive,",
            "                    keep_alive_interval=self.keep_alive_interval,",
            "                    get_context=self.get_context,",
            "                    get_root_value=self.get_root_value,",
            "                    ws=ws,",
            "                ).handle()",
            "",
            "            else:",
            "                # Subprotocol not acceptable",
            "                await ws.close(code=4406)",
            "",
            "        else:  # pragma: no cover",
            "            raise ValueError(\"Unknown scope type: {!r}\".format(scope[\"type\"]))",
            "",
            "    def pick_preferred_protocol(self, ws: WebSocket) -> Optional[str]:",
            "        protocols = ws[\"subprotocols\"]",
            "        intersection = set(protocols) & set(self.protocols)",
            "        sorted_intersection = sorted(intersection, key=protocols.index)",
            "        return next(iter(sorted_intersection), None)",
            "",
            "    async def get_root_value(self, request: Union[Request, WebSocket]) -> Optional[Any]:",
            "        return None",
            "",
            "    async def get_context(",
            "        self, request: Union[Request, WebSocket], response: Response",
            "    ) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    async def get_sub_response(",
            "        self,",
            "        request: Union[Request, WebSocket],",
            "    ) -> Response:",
            "        sub_response = Response()",
            "        sub_response.status_code = None  # type: ignore",
            "        del sub_response.headers[\"content-length\"]",
            "",
            "        return sub_response",
            "",
            "    async def handle_http(",
            "        self,",
            "        scope: Scope,",
            "        receive: Receive,",
            "        send: Send,",
            "    ) -> None:",
            "        request = Request(scope=scope, receive=receive)",
            "",
            "        try:",
            "            response = await self.run(request)",
            "        except HTTPException as e:",
            "            response = PlainTextResponse(e.reason, status_code=e.status_code)  # pyright: ignore",
            "",
            "        await response(scope, receive, send)",
            "",
            "    async def render_graphql_ide(self, request: Union[Request, WebSocket]) -> Response:",
            "        return HTMLResponse(self.graphql_ide_html)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        response = Response(",
            "            self.encode_json(response_data),",
            "            status_code=status.HTTP_200_OK,",
            "            media_type=\"application/json\",",
            "        )",
            "",
            "        response.headers.raw.extend(sub_response.headers.raw)",
            "",
            "        if sub_response.background:",
            "            response.background = sub_response.background",
            "",
            "        if sub_response.status_code:",
            "            response.status_code = sub_response.status_code",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request | WebSocket,",
            "        stream: Callable[[], AsyncIterator[str]],",
            "        sub_response: Response,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        return StreamingResponse(",
            "            stream(),",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "yt_dlp.YoutubeDL",
            "strawberry.asgi.GraphQL"
        ]
    },
    "strawberry/channels/handlers/http_handler.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         graphql_ide: Optional[GraphQL_IDE] = \"graphiql\","
            },
            "1": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         allow_queries_via_get: bool = True,"
            },
            "2": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "         subscriptions_enabled: bool = True,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "5": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     ) -> None:"
            },
            "6": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         self.schema = schema"
            },
            "7": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         self.allow_queries_via_get = allow_queries_via_get"
            },
            "8": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         self.subscriptions_enabled = subscriptions_enabled"
            },
            "9": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         self._ide_subscriptions_enabled = subscriptions_enabled"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "11": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "13": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             warnings.warn("
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import dataclasses",
            "import json",
            "import warnings",
            "from functools import cached_property",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            ")",
            "from typing_extensions import assert_never",
            "from urllib.parse import parse_qs",
            "",
            "from django.conf import settings",
            "from django.core.files import uploadhandler",
            "from django.http.multipartparser import MultiPartParser",
            "",
            "from channels.db import database_sync_to_async",
            "from channels.generic.http import AsyncHttpConsumer",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import SyncBaseHTTPView, SyncHTTPRequestAdapter",
            "from strawberry.http.temporal_response import TemporalResponse",
            "from strawberry.http.types import FormData",
            "from strawberry.http.typevars import Context, RootValue",
            "from strawberry.types.unset import UNSET",
            "",
            "from .base import ChannelsConsumer",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.http.types import HTTPMethod, QueryParams",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "@dataclasses.dataclass",
            "class ChannelsResponse:",
            "    content: bytes",
            "    status: int = 200",
            "    content_type: str = \"application/json\"",
            "    headers: Dict[bytes, bytes] = dataclasses.field(default_factory=dict)",
            "",
            "",
            "@dataclasses.dataclass",
            "class MultipartChannelsResponse:",
            "    stream: Callable[[], AsyncGenerator[str, None]]",
            "    status: int = 200",
            "    content_type: str = \"multipart/mixed;boundary=graphql;subscriptionSpec=1.0\"",
            "    headers: Dict[bytes, bytes] = dataclasses.field(default_factory=dict)",
            "",
            "",
            "@dataclasses.dataclass",
            "class ChannelsRequest:",
            "    consumer: ChannelsConsumer",
            "    body: bytes",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        query_params_str = self.consumer.scope[\"query_string\"].decode()",
            "",
            "        query_params = {}",
            "        for key, value in parse_qs(query_params_str, keep_blank_values=True).items():",
            "            # Only one argument per key is expected here",
            "            query_params[key] = value[0]",
            "",
            "        return query_params",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return {",
            "            header_name.decode().lower(): header_value.decode()",
            "            for header_name, header_value in self.consumer.scope[\"headers\"]",
            "        }",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return self.consumer.scope[\"method\"].upper()",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"content-type\", None)",
            "",
            "    @cached_property",
            "    def form_data(self) -> FormData:",
            "        upload_handlers = [",
            "            uploadhandler.load_handler(handler)",
            "            for handler in settings.FILE_UPLOAD_HANDLERS",
            "        ]",
            "",
            "        parser = MultiPartParser(",
            "            {",
            "                \"CONTENT_TYPE\": self.headers.get(\"content-type\"),",
            "                \"CONTENT_LENGTH\": self.headers.get(\"content-length\", \"0\"),",
            "            },",
            "            BytesIO(self.body),",
            "            upload_handlers,",
            "        )",
            "",
            "        querydict, files = parser.parse()",
            "",
            "        form = {",
            "            \"operations\": querydict.get(\"operations\", \"{}\"),",
            "            \"map\": querydict.get(\"map\", \"{}\"),",
            "        }",
            "",
            "        return FormData(files=files, form=form)",
            "",
            "",
            "class BaseChannelsRequestAdapter:",
            "    def __init__(self, request: ChannelsRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query_params",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return self.request.method",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class ChannelsRequestAdapter(BaseChannelsRequestAdapter, AsyncHTTPRequestAdapter):",
            "    async def get_body(self) -> bytes:",
            "        return self.request.body",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return self.request.form_data",
            "",
            "",
            "class SyncChannelsRequestAdapter(BaseChannelsRequestAdapter, SyncHTTPRequestAdapter):",
            "    @property",
            "    def body(self) -> bytes:",
            "        return self.request.body",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.form_data[\"form\"]",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.form_data[\"files\"]",
            "",
            "",
            "class BaseGraphQLHTTPConsumer(ChannelsConsumer, AsyncHttpConsumer):",
            "    graphql_ide_html: str",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        subscriptions_enabled: bool = True,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.subscriptions_enabled = subscriptions_enabled",
            "        self._ide_subscriptions_enabled = subscriptions_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        super().__init__(**kwargs)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: TemporalResponse",
            "    ) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=json.dumps(response_data).encode(),",
            "            status=sub_response.status_code,",
            "            headers={k.encode(): v.encode() for k, v in sub_response.headers.items()},",
            "        )",
            "",
            "    async def handle(self, body: bytes) -> None:",
            "        request = ChannelsRequest(consumer=self, body=body)",
            "        try:",
            "            response = await self.run(request)",
            "",
            "            if b\"Content-Type\" not in response.headers:",
            "                response.headers[b\"Content-Type\"] = response.content_type.encode()",
            "",
            "            if isinstance(response, MultipartChannelsResponse):",
            "                response.headers[b\"Transfer-Encoding\"] = b\"chunked\"",
            "                await self.send_headers(headers=response.headers)",
            "",
            "                async for chunk in response.stream():",
            "                    await self.send_body(chunk.encode(\"utf-8\"), more_body=True)",
            "",
            "                await self.send_body(b\"\", more_body=False)",
            "",
            "            elif isinstance(response, ChannelsResponse):",
            "                await self.send_response(",
            "                    response.status,",
            "                    response.content,",
            "                    headers=response.headers,",
            "                )",
            "            else:",
            "                assert_never(response)",
            "        except HTTPException as e:",
            "            await self.send_response(e.status_code, e.reason.encode())",
            "",
            "",
            "class GraphQLHTTPConsumer(",
            "    BaseGraphQLHTTPConsumer,",
            "    AsyncBaseHTTPView[",
            "        ChannelsRequest,",
            "        Union[ChannelsResponse, MultipartChannelsResponse],",
            "        TemporalResponse,",
            "        Context,",
            "        RootValue,",
            "    ],",
            "):",
            "    \"\"\"A consumer to provide a view for GraphQL over HTTP.",
            "",
            "    To use this, place it in your ProtocolTypeRouter for your channels project:",
            "",
            "    ```",
            "    from strawberry.channels import GraphQLHttpRouter",
            "    from channels.routing import ProtocolTypeRouter",
            "    from django.core.asgi import get_asgi_application",
            "",
            "    application = ProtocolTypeRouter({",
            "        \"http\": URLRouter([",
            "            re_path(\"^graphql\", GraphQLHTTPRouter(schema=schema)),",
            "            re_path(\"^\", get_asgi_application()),",
            "        ]),",
            "        \"websocket\": URLRouter([",
            "            re_path(\"^ws/graphql\", GraphQLWebSocketRouter(schema=schema)),",
            "        ]),",
            "    })",
            "    ```",
            "    \"\"\"",
            "",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = ChannelsRequestAdapter",
            "",
            "    async def get_root_value(self, request: ChannelsRequest) -> Optional[RootValue]:",
            "        return None  # pragma: no cover",
            "",
            "    async def get_context(",
            "        self, request: ChannelsRequest, response: TemporalResponse",
            "    ) -> Context:",
            "        return {",
            "            \"request\": request,",
            "            \"response\": response,",
            "        }  # type: ignore",
            "",
            "    async def get_sub_response(self, request: ChannelsRequest) -> TemporalResponse:",
            "        return TemporalResponse()",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: ChannelsRequest,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: TemporalResponse,",
            "        headers: Dict[str, str],",
            "    ) -> MultipartChannelsResponse:",
            "        status = sub_response.status_code or 200",
            "",
            "        response_headers = {",
            "            k.encode(): v.encode() for k, v in sub_response.headers.items()",
            "        }",
            "        response_headers.update({k.encode(): v.encode() for k, v in headers.items()})",
            "",
            "        return MultipartChannelsResponse(",
            "            stream=stream, status=status, headers=response_headers",
            "        )",
            "",
            "    async def render_graphql_ide(self, request: ChannelsRequest) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=self.graphql_ide_html.encode(), content_type=\"text/html\"",
            "        )",
            "",
            "",
            "class SyncGraphQLHTTPConsumer(",
            "    BaseGraphQLHTTPConsumer,",
            "    SyncBaseHTTPView[",
            "        ChannelsRequest,",
            "        ChannelsResponse,",
            "        TemporalResponse,",
            "        Context,",
            "        RootValue,",
            "    ],",
            "):",
            "    \"\"\"Synchronous version of the HTTPConsumer.",
            "",
            "    This is the same as `GraphQLHTTPConsumer`, but it can be used with",
            "    synchronous schemas (i.e. the schema's resolvers are expected to be",
            "    synchronous and not asynchronous).",
            "    \"\"\"",
            "",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = SyncChannelsRequestAdapter",
            "",
            "    def get_root_value(self, request: ChannelsRequest) -> Optional[RootValue]:",
            "        return None  # pragma: no cover",
            "",
            "    def get_context(",
            "        self, request: ChannelsRequest, response: TemporalResponse",
            "    ) -> Context:",
            "        return {",
            "            \"request\": request,",
            "            \"response\": response,",
            "        }  # type: ignore",
            "",
            "    def get_sub_response(self, request: ChannelsRequest) -> TemporalResponse:",
            "        return TemporalResponse()",
            "",
            "    def render_graphql_ide(self, request: ChannelsRequest) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=self.graphql_ide_html.encode(), content_type=\"text/html\"",
            "        )",
            "",
            "    # Sync channels is actually async, but it uses database_sync_to_async to call",
            "    # handlers in a threadpool. Check SyncConsumer's documentation for more info:",
            "    # https://github.com/django/channels/blob/main/channels/consumer.py#L104",
            "    @database_sync_to_async  # pyright: ignore[reportIncompatibleMethodOverride]",
            "    def run(",
            "        self,",
            "        request: ChannelsRequest,",
            "        context: Optional[Context] = UNSET,",
            "        root_value: Optional[RootValue] = UNSET,",
            "    ) -> ChannelsResponse | MultipartChannelsResponse:",
            "        return super().run(request, context, root_value)",
            "",
            "",
            "__all__ = [\"GraphQLHTTPConsumer\", \"SyncGraphQLHTTPConsumer\"]"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import dataclasses",
            "import json",
            "import warnings",
            "from functools import cached_property",
            "from io import BytesIO",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            ")",
            "from typing_extensions import assert_never",
            "from urllib.parse import parse_qs",
            "",
            "from django.conf import settings",
            "from django.core.files import uploadhandler",
            "from django.http.multipartparser import MultiPartParser",
            "",
            "from channels.db import database_sync_to_async",
            "from channels.generic.http import AsyncHttpConsumer",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import SyncBaseHTTPView, SyncHTTPRequestAdapter",
            "from strawberry.http.temporal_response import TemporalResponse",
            "from strawberry.http.types import FormData",
            "from strawberry.http.typevars import Context, RootValue",
            "from strawberry.types.unset import UNSET",
            "",
            "from .base import ChannelsConsumer",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.http.types import HTTPMethod, QueryParams",
            "    from strawberry.schema import BaseSchema",
            "",
            "",
            "@dataclasses.dataclass",
            "class ChannelsResponse:",
            "    content: bytes",
            "    status: int = 200",
            "    content_type: str = \"application/json\"",
            "    headers: Dict[bytes, bytes] = dataclasses.field(default_factory=dict)",
            "",
            "",
            "@dataclasses.dataclass",
            "class MultipartChannelsResponse:",
            "    stream: Callable[[], AsyncGenerator[str, None]]",
            "    status: int = 200",
            "    content_type: str = \"multipart/mixed;boundary=graphql;subscriptionSpec=1.0\"",
            "    headers: Dict[bytes, bytes] = dataclasses.field(default_factory=dict)",
            "",
            "",
            "@dataclasses.dataclass",
            "class ChannelsRequest:",
            "    consumer: ChannelsConsumer",
            "    body: bytes",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        query_params_str = self.consumer.scope[\"query_string\"].decode()",
            "",
            "        query_params = {}",
            "        for key, value in parse_qs(query_params_str, keep_blank_values=True).items():",
            "            # Only one argument per key is expected here",
            "            query_params[key] = value[0]",
            "",
            "        return query_params",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return {",
            "            header_name.decode().lower(): header_value.decode()",
            "            for header_name, header_value in self.consumer.scope[\"headers\"]",
            "        }",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return self.consumer.scope[\"method\"].upper()",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"content-type\", None)",
            "",
            "    @cached_property",
            "    def form_data(self) -> FormData:",
            "        upload_handlers = [",
            "            uploadhandler.load_handler(handler)",
            "            for handler in settings.FILE_UPLOAD_HANDLERS",
            "        ]",
            "",
            "        parser = MultiPartParser(",
            "            {",
            "                \"CONTENT_TYPE\": self.headers.get(\"content-type\"),",
            "                \"CONTENT_LENGTH\": self.headers.get(\"content-length\", \"0\"),",
            "            },",
            "            BytesIO(self.body),",
            "            upload_handlers,",
            "        )",
            "",
            "        querydict, files = parser.parse()",
            "",
            "        form = {",
            "            \"operations\": querydict.get(\"operations\", \"{}\"),",
            "            \"map\": querydict.get(\"map\", \"{}\"),",
            "        }",
            "",
            "        return FormData(files=files, form=form)",
            "",
            "",
            "class BaseChannelsRequestAdapter:",
            "    def __init__(self, request: ChannelsRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.query_params",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return self.request.method",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class ChannelsRequestAdapter(BaseChannelsRequestAdapter, AsyncHTTPRequestAdapter):",
            "    async def get_body(self) -> bytes:",
            "        return self.request.body",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return self.request.form_data",
            "",
            "",
            "class SyncChannelsRequestAdapter(BaseChannelsRequestAdapter, SyncHTTPRequestAdapter):",
            "    @property",
            "    def body(self) -> bytes:",
            "        return self.request.body",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.form_data[\"form\"]",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.form_data[\"files\"]",
            "",
            "",
            "class BaseGraphQLHTTPConsumer(ChannelsConsumer, AsyncHttpConsumer):",
            "    graphql_ide_html: str",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        subscriptions_enabled: bool = True,",
            "        multipart_uploads_enabled: bool = False,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.subscriptions_enabled = subscriptions_enabled",
            "        self._ide_subscriptions_enabled = subscriptions_enabled",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        super().__init__(**kwargs)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: TemporalResponse",
            "    ) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=json.dumps(response_data).encode(),",
            "            status=sub_response.status_code,",
            "            headers={k.encode(): v.encode() for k, v in sub_response.headers.items()},",
            "        )",
            "",
            "    async def handle(self, body: bytes) -> None:",
            "        request = ChannelsRequest(consumer=self, body=body)",
            "        try:",
            "            response = await self.run(request)",
            "",
            "            if b\"Content-Type\" not in response.headers:",
            "                response.headers[b\"Content-Type\"] = response.content_type.encode()",
            "",
            "            if isinstance(response, MultipartChannelsResponse):",
            "                response.headers[b\"Transfer-Encoding\"] = b\"chunked\"",
            "                await self.send_headers(headers=response.headers)",
            "",
            "                async for chunk in response.stream():",
            "                    await self.send_body(chunk.encode(\"utf-8\"), more_body=True)",
            "",
            "                await self.send_body(b\"\", more_body=False)",
            "",
            "            elif isinstance(response, ChannelsResponse):",
            "                await self.send_response(",
            "                    response.status,",
            "                    response.content,",
            "                    headers=response.headers,",
            "                )",
            "            else:",
            "                assert_never(response)",
            "        except HTTPException as e:",
            "            await self.send_response(e.status_code, e.reason.encode())",
            "",
            "",
            "class GraphQLHTTPConsumer(",
            "    BaseGraphQLHTTPConsumer,",
            "    AsyncBaseHTTPView[",
            "        ChannelsRequest,",
            "        Union[ChannelsResponse, MultipartChannelsResponse],",
            "        TemporalResponse,",
            "        Context,",
            "        RootValue,",
            "    ],",
            "):",
            "    \"\"\"A consumer to provide a view for GraphQL over HTTP.",
            "",
            "    To use this, place it in your ProtocolTypeRouter for your channels project:",
            "",
            "    ```",
            "    from strawberry.channels import GraphQLHttpRouter",
            "    from channels.routing import ProtocolTypeRouter",
            "    from django.core.asgi import get_asgi_application",
            "",
            "    application = ProtocolTypeRouter({",
            "        \"http\": URLRouter([",
            "            re_path(\"^graphql\", GraphQLHTTPRouter(schema=schema)),",
            "            re_path(\"^\", get_asgi_application()),",
            "        ]),",
            "        \"websocket\": URLRouter([",
            "            re_path(\"^ws/graphql\", GraphQLWebSocketRouter(schema=schema)),",
            "        ]),",
            "    })",
            "    ```",
            "    \"\"\"",
            "",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = ChannelsRequestAdapter",
            "",
            "    async def get_root_value(self, request: ChannelsRequest) -> Optional[RootValue]:",
            "        return None  # pragma: no cover",
            "",
            "    async def get_context(",
            "        self, request: ChannelsRequest, response: TemporalResponse",
            "    ) -> Context:",
            "        return {",
            "            \"request\": request,",
            "            \"response\": response,",
            "        }  # type: ignore",
            "",
            "    async def get_sub_response(self, request: ChannelsRequest) -> TemporalResponse:",
            "        return TemporalResponse()",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: ChannelsRequest,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: TemporalResponse,",
            "        headers: Dict[str, str],",
            "    ) -> MultipartChannelsResponse:",
            "        status = sub_response.status_code or 200",
            "",
            "        response_headers = {",
            "            k.encode(): v.encode() for k, v in sub_response.headers.items()",
            "        }",
            "        response_headers.update({k.encode(): v.encode() for k, v in headers.items()})",
            "",
            "        return MultipartChannelsResponse(",
            "            stream=stream, status=status, headers=response_headers",
            "        )",
            "",
            "    async def render_graphql_ide(self, request: ChannelsRequest) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=self.graphql_ide_html.encode(), content_type=\"text/html\"",
            "        )",
            "",
            "",
            "class SyncGraphQLHTTPConsumer(",
            "    BaseGraphQLHTTPConsumer,",
            "    SyncBaseHTTPView[",
            "        ChannelsRequest,",
            "        ChannelsResponse,",
            "        TemporalResponse,",
            "        Context,",
            "        RootValue,",
            "    ],",
            "):",
            "    \"\"\"Synchronous version of the HTTPConsumer.",
            "",
            "    This is the same as `GraphQLHTTPConsumer`, but it can be used with",
            "    synchronous schemas (i.e. the schema's resolvers are expected to be",
            "    synchronous and not asynchronous).",
            "    \"\"\"",
            "",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = SyncChannelsRequestAdapter",
            "",
            "    def get_root_value(self, request: ChannelsRequest) -> Optional[RootValue]:",
            "        return None  # pragma: no cover",
            "",
            "    def get_context(",
            "        self, request: ChannelsRequest, response: TemporalResponse",
            "    ) -> Context:",
            "        return {",
            "            \"request\": request,",
            "            \"response\": response,",
            "        }  # type: ignore",
            "",
            "    def get_sub_response(self, request: ChannelsRequest) -> TemporalResponse:",
            "        return TemporalResponse()",
            "",
            "    def render_graphql_ide(self, request: ChannelsRequest) -> ChannelsResponse:",
            "        return ChannelsResponse(",
            "            content=self.graphql_ide_html.encode(), content_type=\"text/html\"",
            "        )",
            "",
            "    # Sync channels is actually async, but it uses database_sync_to_async to call",
            "    # handlers in a threadpool. Check SyncConsumer's documentation for more info:",
            "    # https://github.com/django/channels/blob/main/channels/consumer.py#L104",
            "    @database_sync_to_async  # pyright: ignore[reportIncompatibleMethodOverride]",
            "    def run(",
            "        self,",
            "        request: ChannelsRequest,",
            "        context: Optional[Context] = UNSET,",
            "        root_value: Optional[RootValue] = UNSET,",
            "    ) -> ChannelsResponse | MultipartChannelsResponse:",
            "        return super().run(request, context, root_value)",
            "",
            "",
            "__all__ = [\"GraphQLHTTPConsumer\", \"SyncGraphQLHTTPConsumer\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "strawberry.channels.handlers.http_handler.BaseGraphQLHTTPConsumer",
            "yt_dlp.YoutubeDL"
        ]
    },
    "strawberry/django/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from django.template.exceptions import TemplateDoesNotExist"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from django.template.loader import render_to_string"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from django.template.response import TemplateResponse"
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.decorators import classonlymethod, method_decorator"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.views.decorators.csrf import csrf_exempt"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+from django.utils.decorators import classonlymethod"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from django.views.generic import View"
            },
            "7": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter"
            },
            "9": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         graphql_ide: Optional[GraphQL_IDE] = \"graphiql\","
            },
            "10": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         allow_queries_via_get: bool = True,"
            },
            "11": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         subscriptions_enabled: bool = False,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "13": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "14": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     ) -> None:"
            },
            "15": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         self.schema = schema"
            },
            "16": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         self.allow_queries_via_get = allow_queries_via_get"
            },
            "17": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         self.subscriptions_enabled = subscriptions_enabled"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "19": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "21": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             warnings.warn("
            },
            "22": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "     def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:"
            },
            "23": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         return TemporalHttpResponse()"
            },
            "24": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 232,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @method_decorator(csrf_exempt)"
            },
            "26": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     def dispatch("
            },
            "27": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         self, request: HttpRequest, *args: Any, **kwargs: Any"
            },
            "28": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:"
            },
            "29": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "     async def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:"
            },
            "30": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         return TemporalHttpResponse()"
            },
            "31": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @method_decorator(csrf_exempt)"
            },
            "33": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "     async def dispatch(  # pyright: ignore"
            },
            "34": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         self, request: HttpRequest, *args: Any, **kwargs: Any"
            },
            "35": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "     ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import warnings",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from asgiref.sync import markcoroutinefunction",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.http import (",
            "    HttpRequest,",
            "    HttpResponse,",
            "    HttpResponseNotAllowed,",
            "    JsonResponse,",
            "    StreamingHttpResponse,",
            ")",
            "from django.http.response import HttpResponseBase",
            "from django.template import RequestContext, Template",
            "from django.template.exceptions import TemplateDoesNotExist",
            "from django.template.loader import render_to_string",
            "from django.template.response import TemplateResponse",
            "from django.utils.decorators import classonlymethod, method_decorator",
            "from django.views.decorators.csrf import csrf_exempt",
            "from django.views.generic import View",
            "",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import SyncBaseHTTPView, SyncHTTPRequestAdapter",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "",
            "from .context import StrawberryDjangoContext",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "",
            "    from ..schema import BaseSchema",
            "",
            "",
            "# TODO: remove this and unify temporal responses",
            "class TemporalHttpResponse(JsonResponse):",
            "    status_code: Optional[int] = None  # pyright: ignore",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__({})",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"Adopted from Django to handle `status_code=None`.\"\"\"",
            "        if self.status_code is not None:",
            "            return super().__repr__()",
            "",
            "        return \"<{cls} status_code={status_code}{content_type}>\".format(  # noqa: UP032",
            "            cls=self.__class__.__name__,",
            "            status_code=self.status_code,",
            "            content_type=self._content_type_for_repr,  # pyright: ignore",
            "        )",
            "",
            "",
            "class DjangoHTTPRequestAdapter(SyncHTTPRequestAdapter):",
            "    def __init__(self, request: HttpRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.GET.dict()",
            "",
            "    @property",
            "    def body(self) -> Union[str, bytes]:",
            "        return self.request.body.decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        assert self.request.method is not None",
            "",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.POST",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.FILES",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class AsyncDjangoHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: HttpRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.GET.dict()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        assert self.request.method is not None",
            "",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"Content-type\")",
            "",
            "    async def get_body(self) -> str:",
            "        return self.request.body.decode()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return FormData(",
            "            files=self.request.FILES,",
            "            form=self.request.POST,",
            "        )",
            "",
            "",
            "class BaseView:",
            "    _ide_replace_variables = False",
            "    graphql_ide_html: str",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[str] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        subscriptions_enabled: bool = False,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.subscriptions_enabled = subscriptions_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        super().__init__(**kwargs)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: HttpResponse",
            "    ) -> HttpResponseBase:",
            "        data = self.encode_json(response_data)",
            "",
            "        response = HttpResponse(",
            "            data,",
            "            content_type=\"application/json\",",
            "        )",
            "",
            "        for name, value in sub_response.items():",
            "            response[name] = value",
            "",
            "        if sub_response.status_code:",
            "            response.status_code = sub_response.status_code",
            "",
            "        for name, value in sub_response.cookies.items():",
            "            response.cookies[name] = value",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: HttpRequest,",
            "        stream: Callable[[], AsyncIterator[Any]],",
            "        sub_response: TemporalHttpResponse,",
            "        headers: Dict[str, str],",
            "    ) -> HttpResponseBase:",
            "        return StreamingHttpResponse(",
            "            streaming_content=stream(),",
            "            status=sub_response.status_code,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "    def encode_json(self, response_data: GraphQLHTTPResponse) -> str:",
            "        return json.dumps(response_data, cls=DjangoJSONEncoder)",
            "",
            "",
            "class GraphQLView(",
            "    BaseView,",
            "    SyncBaseHTTPView[",
            "        HttpRequest, HttpResponseBase, TemporalHttpResponse, Context, RootValue",
            "    ],",
            "    View,",
            "):",
            "    subscriptions_enabled = False",
            "    graphiql: Optional[bool] = None",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "    allow_queries_via_get = True",
            "    schema: BaseSchema = None  # type: ignore",
            "    request_adapter_class = DjangoHTTPRequestAdapter",
            "",
            "    def get_root_value(self, request: HttpRequest) -> Optional[RootValue]:",
            "        return None",
            "",
            "    def get_context(self, request: HttpRequest, response: HttpResponse) -> Any:",
            "        return StrawberryDjangoContext(request=request, response=response)",
            "",
            "    def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:",
            "        return TemporalHttpResponse()",
            "",
            "    @method_decorator(csrf_exempt)",
            "    def dispatch(",
            "        self, request: HttpRequest, *args: Any, **kwargs: Any",
            "    ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:",
            "        try:",
            "            return self.run(request=request)",
            "        except HTTPException as e:",
            "            return HttpResponse(",
            "                content=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    def render_graphql_ide(self, request: HttpRequest) -> HttpResponse:",
            "        try:",
            "            template = Template(render_to_string(\"graphql/graphiql.html\"))",
            "        except TemplateDoesNotExist:",
            "            template = Template(self.graphql_ide_html)",
            "",
            "        context = {\"SUBSCRIPTION_ENABLED\": json.dumps(self.subscriptions_enabled)}",
            "",
            "        response = TemplateResponse(request=request, template=None, context=context)",
            "        response.content = template.render(RequestContext(request, context))",
            "",
            "        return response",
            "",
            "",
            "class AsyncGraphQLView(",
            "    BaseView,",
            "    AsyncBaseHTTPView[",
            "        HttpRequest, HttpResponseBase, TemporalHttpResponse, Context, RootValue",
            "    ],",
            "    View,",
            "):",
            "    subscriptions_enabled = False",
            "    graphiql: Optional[bool] = None",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "    allow_queries_via_get = True",
            "    schema: BaseSchema = None  # type: ignore",
            "    request_adapter_class = AsyncDjangoHTTPRequestAdapter",
            "",
            "    @classonlymethod  # pyright: ignore[reportIncompatibleMethodOverride]",
            "    def as_view(cls, **initkwargs: Any) -> Callable[..., HttpResponse]:",
            "        # This code tells django that this view is async, see docs here:",
            "        # https://docs.djangoproject.com/en/3.1/topics/async/#async-views",
            "",
            "        view = super().as_view(**initkwargs)",
            "        markcoroutinefunction(view)",
            "",
            "        return view",
            "",
            "    async def get_root_value(self, request: HttpRequest) -> Any:",
            "        return None",
            "",
            "    async def get_context(self, request: HttpRequest, response: HttpResponse) -> Any:",
            "        return StrawberryDjangoContext(request=request, response=response)",
            "",
            "    async def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:",
            "        return TemporalHttpResponse()",
            "",
            "    @method_decorator(csrf_exempt)",
            "    async def dispatch(  # pyright: ignore",
            "        self, request: HttpRequest, *args: Any, **kwargs: Any",
            "    ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:",
            "        try:",
            "            return await self.run(request=request)",
            "        except HTTPException as e:",
            "            return HttpResponse(",
            "                content=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    async def render_graphql_ide(self, request: HttpRequest) -> HttpResponse:",
            "        try:",
            "            template = Template(render_to_string(\"graphql/graphiql.html\"))",
            "        except TemplateDoesNotExist:",
            "            template = Template(self.graphql_ide_html)",
            "",
            "        context = {\"SUBSCRIPTION_ENABLED\": json.dumps(self.subscriptions_enabled)}",
            "",
            "        response = TemplateResponse(request=request, template=None, context=context)",
            "        response.content = template.render(RequestContext(request, context))",
            "",
            "        return response",
            "",
            "",
            "__all__ = [\"GraphQLView\", \"AsyncGraphQLView\"]"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import warnings",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from asgiref.sync import markcoroutinefunction",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.http import (",
            "    HttpRequest,",
            "    HttpResponse,",
            "    HttpResponseNotAllowed,",
            "    JsonResponse,",
            "    StreamingHttpResponse,",
            ")",
            "from django.http.response import HttpResponseBase",
            "from django.template import RequestContext, Template",
            "from django.template.exceptions import TemplateDoesNotExist",
            "from django.template.loader import render_to_string",
            "from django.template.response import TemplateResponse",
            "from django.utils.decorators import classonlymethod",
            "from django.views.generic import View",
            "",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import SyncBaseHTTPView, SyncHTTPRequestAdapter",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import (",
            "    Context,",
            "    RootValue,",
            ")",
            "",
            "from .context import StrawberryDjangoContext",
            "",
            "if TYPE_CHECKING:",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "",
            "    from ..schema import BaseSchema",
            "",
            "",
            "# TODO: remove this and unify temporal responses",
            "class TemporalHttpResponse(JsonResponse):",
            "    status_code: Optional[int] = None  # pyright: ignore",
            "",
            "    def __init__(self) -> None:",
            "        super().__init__({})",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"Adopted from Django to handle `status_code=None`.\"\"\"",
            "        if self.status_code is not None:",
            "            return super().__repr__()",
            "",
            "        return \"<{cls} status_code={status_code}{content_type}>\".format(  # noqa: UP032",
            "            cls=self.__class__.__name__,",
            "            status_code=self.status_code,",
            "            content_type=self._content_type_for_repr,  # pyright: ignore",
            "        )",
            "",
            "",
            "class DjangoHTTPRequestAdapter(SyncHTTPRequestAdapter):",
            "    def __init__(self, request: HttpRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.GET.dict()",
            "",
            "    @property",
            "    def body(self) -> Union[str, bytes]:",
            "        return self.request.body.decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        assert self.request.method is not None",
            "",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.POST",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.FILES",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class AsyncDjangoHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: HttpRequest) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.GET.dict()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        assert self.request.method is not None",
            "",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.headers.get(\"Content-type\")",
            "",
            "    async def get_body(self) -> str:",
            "        return self.request.body.decode()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return FormData(",
            "            files=self.request.FILES,",
            "            form=self.request.POST,",
            "        )",
            "",
            "",
            "class BaseView:",
            "    _ide_replace_variables = False",
            "    graphql_ide_html: str",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[str] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        subscriptions_enabled: bool = False,",
            "        multipart_uploads_enabled: bool = False,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.subscriptions_enabled = subscriptions_enabled",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        super().__init__(**kwargs)",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: HttpResponse",
            "    ) -> HttpResponseBase:",
            "        data = self.encode_json(response_data)",
            "",
            "        response = HttpResponse(",
            "            data,",
            "            content_type=\"application/json\",",
            "        )",
            "",
            "        for name, value in sub_response.items():",
            "            response[name] = value",
            "",
            "        if sub_response.status_code:",
            "            response.status_code = sub_response.status_code",
            "",
            "        for name, value in sub_response.cookies.items():",
            "            response.cookies[name] = value",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: HttpRequest,",
            "        stream: Callable[[], AsyncIterator[Any]],",
            "        sub_response: TemporalHttpResponse,",
            "        headers: Dict[str, str],",
            "    ) -> HttpResponseBase:",
            "        return StreamingHttpResponse(",
            "            streaming_content=stream(),",
            "            status=sub_response.status_code,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "    def encode_json(self, response_data: GraphQLHTTPResponse) -> str:",
            "        return json.dumps(response_data, cls=DjangoJSONEncoder)",
            "",
            "",
            "class GraphQLView(",
            "    BaseView,",
            "    SyncBaseHTTPView[",
            "        HttpRequest, HttpResponseBase, TemporalHttpResponse, Context, RootValue",
            "    ],",
            "    View,",
            "):",
            "    subscriptions_enabled = False",
            "    graphiql: Optional[bool] = None",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "    allow_queries_via_get = True",
            "    schema: BaseSchema = None  # type: ignore",
            "    request_adapter_class = DjangoHTTPRequestAdapter",
            "",
            "    def get_root_value(self, request: HttpRequest) -> Optional[RootValue]:",
            "        return None",
            "",
            "    def get_context(self, request: HttpRequest, response: HttpResponse) -> Any:",
            "        return StrawberryDjangoContext(request=request, response=response)",
            "",
            "    def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:",
            "        return TemporalHttpResponse()",
            "",
            "    def dispatch(",
            "        self, request: HttpRequest, *args: Any, **kwargs: Any",
            "    ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:",
            "        try:",
            "            return self.run(request=request)",
            "        except HTTPException as e:",
            "            return HttpResponse(",
            "                content=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    def render_graphql_ide(self, request: HttpRequest) -> HttpResponse:",
            "        try:",
            "            template = Template(render_to_string(\"graphql/graphiql.html\"))",
            "        except TemplateDoesNotExist:",
            "            template = Template(self.graphql_ide_html)",
            "",
            "        context = {\"SUBSCRIPTION_ENABLED\": json.dumps(self.subscriptions_enabled)}",
            "",
            "        response = TemplateResponse(request=request, template=None, context=context)",
            "        response.content = template.render(RequestContext(request, context))",
            "",
            "        return response",
            "",
            "",
            "class AsyncGraphQLView(",
            "    BaseView,",
            "    AsyncBaseHTTPView[",
            "        HttpRequest, HttpResponseBase, TemporalHttpResponse, Context, RootValue",
            "    ],",
            "    View,",
            "):",
            "    subscriptions_enabled = False",
            "    graphiql: Optional[bool] = None",
            "    graphql_ide: Optional[GraphQL_IDE] = \"graphiql\"",
            "    allow_queries_via_get = True",
            "    schema: BaseSchema = None  # type: ignore",
            "    request_adapter_class = AsyncDjangoHTTPRequestAdapter",
            "",
            "    @classonlymethod  # pyright: ignore[reportIncompatibleMethodOverride]",
            "    def as_view(cls, **initkwargs: Any) -> Callable[..., HttpResponse]:",
            "        # This code tells django that this view is async, see docs here:",
            "        # https://docs.djangoproject.com/en/3.1/topics/async/#async-views",
            "",
            "        view = super().as_view(**initkwargs)",
            "        markcoroutinefunction(view)",
            "",
            "        return view",
            "",
            "    async def get_root_value(self, request: HttpRequest) -> Any:",
            "        return None",
            "",
            "    async def get_context(self, request: HttpRequest, response: HttpResponse) -> Any:",
            "        return StrawberryDjangoContext(request=request, response=response)",
            "",
            "    async def get_sub_response(self, request: HttpRequest) -> TemporalHttpResponse:",
            "        return TemporalHttpResponse()",
            "",
            "    async def dispatch(  # pyright: ignore",
            "        self, request: HttpRequest, *args: Any, **kwargs: Any",
            "    ) -> Union[HttpResponseNotAllowed, TemplateResponse, HttpResponseBase]:",
            "        try:",
            "            return await self.run(request=request)",
            "        except HTTPException as e:",
            "            return HttpResponse(",
            "                content=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    async def render_graphql_ide(self, request: HttpRequest) -> HttpResponse:",
            "        try:",
            "            template = Template(render_to_string(\"graphql/graphiql.html\"))",
            "        except TemplateDoesNotExist:",
            "            template = Template(self.graphql_ide_html)",
            "",
            "        context = {\"SUBSCRIPTION_ENABLED\": json.dumps(self.subscriptions_enabled)}",
            "",
            "        response = TemplateResponse(request=request, template=None, context=context)",
            "        response.content = template.render(RequestContext(request, context))",
            "",
            "        return response",
            "",
            "",
            "__all__ = [\"GraphQLView\", \"AsyncGraphQLView\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [],
            "32": [],
            "232": [
                "GraphQLView"
            ],
            "291": [
                "AsyncGraphQLView"
            ]
        },
        "addLocation": []
    },
    "strawberry/fastapi/router.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         generate_unique_id_function: Callable[[APIRoute], str] = Default("
            },
            "1": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "             generate_unique_id"
            },
            "2": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         ),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "5": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     ) -> None:"
            },
            "6": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         super().__init__("
            },
            "7": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         self.protocols = subscription_protocols"
            },
            "9": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         self.connection_init_wait_timeout = connection_init_wait_timeout"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "11": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "13": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "             warnings.warn("
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from datetime import timedelta",
            "from inspect import signature",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Sequence,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlette import status",
            "from starlette.background import BackgroundTasks  # noqa: TCH002",
            "from starlette.requests import HTTPConnection, Request",
            "from starlette.responses import (",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            "    Response,",
            "    StreamingResponse,",
            ")",
            "from starlette.websockets import WebSocket",
            "",
            "from fastapi import APIRouter, Depends, params",
            "from fastapi.datastructures import Default",
            "from fastapi.routing import APIRoute",
            "from fastapi.utils import generate_unique_id",
            "from strawberry.asgi import ASGIRequestAdapter",
            "from strawberry.exceptions import InvalidCustomContext",
            "from strawberry.fastapi.context import BaseContext, CustomContext",
            "from strawberry.fastapi.handlers import GraphQLTransportWSHandler, GraphQLWSHandler",
            "from strawberry.http import process_result",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.typevars import Context, RootValue",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from enum import Enum",
            "",
            "    from starlette.routing import BaseRoute",
            "    from starlette.types import ASGIApp, Lifespan",
            "",
            "    from strawberry.fastapi.context import MergedContext",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "    from strawberry.types import ExecutionResult",
            "",
            "",
            "class GraphQLRouter(",
            "    AsyncBaseHTTPView[Request, Response, Response, Context, RootValue], APIRouter",
            "):",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = ASGIRequestAdapter",
            "",
            "    @staticmethod",
            "    async def __get_root_value() -> None:",
            "        return None",
            "",
            "    @staticmethod",
            "    def __get_context_getter(",
            "        custom_getter: Callable[",
            "            ..., Union[Optional[CustomContext], Awaitable[Optional[CustomContext]]]",
            "        ],",
            "    ) -> Callable[..., Awaitable[CustomContext]]:",
            "        async def dependency(",
            "            custom_context: Optional[CustomContext],",
            "            background_tasks: BackgroundTasks,",
            "            connection: HTTPConnection,",
            "            response: Response = None,  # type: ignore",
            "        ) -> MergedContext:",
            "            request = cast(Union[Request, WebSocket], connection)",
            "            if isinstance(custom_context, BaseContext):",
            "                custom_context.request = request",
            "                custom_context.background_tasks = background_tasks",
            "                custom_context.response = response",
            "                return custom_context",
            "            default_context = {",
            "                \"request\": request,",
            "                \"background_tasks\": background_tasks,",
            "                \"response\": response,",
            "            }",
            "            if isinstance(custom_context, dict):",
            "                return {",
            "                    **default_context,",
            "                    **custom_context,",
            "                }",
            "            elif custom_context is None:",
            "                return default_context",
            "            else:",
            "                raise InvalidCustomContext()",
            "",
            "        # replace the signature parameters of dependency...",
            "        # ...with the old parameters minus the first argument as it will be replaced...",
            "        # ...with the value obtained by injecting custom_getter context as a dependency.",
            "        sig = signature(dependency)",
            "        sig = sig.replace(",
            "            parameters=[",
            "                *list(sig.parameters.values())[1:],",
            "                sig.parameters[\"custom_context\"].replace(",
            "                    default=Depends(custom_getter)",
            "                ),",
            "            ],",
            "        )",
            "        # there is an ongoing issue with types and .__signature__ applied to Callables:",
            "        # https://github.com/python/mypy/issues/5958, as of 14/12/21",
            "        # as such, the below line has its typing ignored by MyPy",
            "        dependency.__signature__ = sig  # type: ignore",
            "        return dependency",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        path: str = \"\",",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = False,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        root_value_getter: Optional[Callable[[], RootValue]] = None,",
            "        context_getter: Optional[Callable[..., Optional[Context]]] = None,",
            "        subscription_protocols: Sequence[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "        prefix: str = \"\",",
            "        tags: Optional[List[Union[str, Enum]]] = None,",
            "        dependencies: Optional[Sequence[params.Depends]] = None,",
            "        default_response_class: Type[Response] = Default(JSONResponse),",
            "        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,",
            "        callbacks: Optional[List[BaseRoute]] = None,",
            "        routes: Optional[List[BaseRoute]] = None,",
            "        redirect_slashes: bool = True,",
            "        default: Optional[ASGIApp] = None,",
            "        dependency_overrides_provider: Optional[Any] = None,",
            "        route_class: Type[APIRoute] = APIRoute,",
            "        on_startup: Optional[Sequence[Callable[[], Any]]] = None,",
            "        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,",
            "        lifespan: Optional[Lifespan[Any]] = None,",
            "        deprecated: Optional[bool] = None,",
            "        include_in_schema: bool = True,",
            "        generate_unique_id_function: Callable[[APIRoute], str] = Default(",
            "            generate_unique_id",
            "        ),",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        super().__init__(",
            "            prefix=prefix,",
            "            tags=tags,",
            "            dependencies=dependencies,",
            "            default_response_class=default_response_class,",
            "            responses=responses,",
            "            callbacks=callbacks,",
            "            routes=routes,",
            "            redirect_slashes=redirect_slashes,",
            "            default=default,",
            "            dependency_overrides_provider=dependency_overrides_provider,",
            "            route_class=route_class,",
            "            on_startup=on_startup,",
            "            on_shutdown=on_shutdown,",
            "            lifespan=lifespan,",
            "            deprecated=deprecated,",
            "            include_in_schema=include_in_schema,",
            "            generate_unique_id_function=generate_unique_id_function,",
            "            **kwargs,",
            "        )",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.root_value_getter = root_value_getter or self.__get_root_value",
            "        # TODO: clean this type up",
            "        self.context_getter = self.__get_context_getter(",
            "            context_getter or (lambda: None)  # type: ignore",
            "        )",
            "        self.protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        @self.get(",
            "            path,",
            "            responses={",
            "                200: {",
            "                    \"description\": \"The GraphiQL integrated development environment.\",",
            "                },",
            "                404: {",
            "                    \"description\": (",
            "                        \"Not found if GraphiQL or query via GET are not enabled.\"",
            "                    )",
            "                },",
            "            },",
            "            include_in_schema=graphiql or allow_queries_via_get,",
            "        )",
            "        async def handle_http_get(  # pyright: ignore",
            "            request: Request,",
            "            response: Response,",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> Response:",
            "            self.temporal_response = response",
            "",
            "            try:",
            "                return await self.run(",
            "                    request=request, context=context, root_value=root_value",
            "                )",
            "            except HTTPException as e:",
            "                return PlainTextResponse(",
            "                    e.reason,",
            "                    status_code=e.status_code,",
            "                )",
            "",
            "        @self.post(path)",
            "        async def handle_http_post(  # pyright: ignore",
            "            request: Request,",
            "            response: Response,",
            "            # TODO: use Annotated in future",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> Response:",
            "            self.temporal_response = response",
            "",
            "            try:",
            "                return await self.run(",
            "                    request=request, context=context, root_value=root_value",
            "                )",
            "            except HTTPException as e:",
            "                return PlainTextResponse(",
            "                    e.reason,",
            "                    status_code=e.status_code,",
            "                )",
            "",
            "        @self.websocket(path)",
            "        async def websocket_endpoint(  # pyright: ignore",
            "            websocket: WebSocket,",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> None:",
            "            async def _get_context() -> Context:",
            "                return context",
            "",
            "            async def _get_root_value() -> RootValue:",
            "                return root_value",
            "",
            "            preferred_protocol = self.pick_preferred_protocol(websocket)",
            "            if preferred_protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "                await self.graphql_transport_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                    get_context=_get_context,",
            "                    get_root_value=_get_root_value,",
            "                    ws=websocket,",
            "                ).handle()",
            "            elif preferred_protocol == GRAPHQL_WS_PROTOCOL:",
            "                await self.graphql_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    keep_alive=self.keep_alive,",
            "                    keep_alive_interval=self.keep_alive_interval,",
            "                    get_context=_get_context,",
            "                    get_root_value=_get_root_value,",
            "                    ws=websocket,",
            "                ).handle()",
            "            else:",
            "                # Code 4406 is \"Subprotocol not acceptable\"",
            "                await websocket.close(code=4406)",
            "",
            "    def pick_preferred_protocol(self, ws: WebSocket) -> Optional[str]:",
            "        protocols = ws[\"subprotocols\"]",
            "        intersection = set(protocols) & set(self.protocols)",
            "        return min(",
            "            intersection,",
            "            key=lambda i: protocols.index(i),",
            "            default=None,",
            "        )",
            "",
            "    async def render_graphql_ide(self, request: Request) -> HTMLResponse:",
            "        return HTMLResponse(self.graphql_ide_html)",
            "",
            "    async def process_result(",
            "        self, request: Request, result: ExecutionResult",
            "    ) -> GraphQLHTTPResponse:",
            "        return process_result(result)",
            "",
            "    async def get_context(",
            "        self, request: Request, response: Response",
            "    ) -> Context:  # pragma: no cover",
            "        raise ValueError(\"`get_context` is not used by FastAPI GraphQL Router\")",
            "",
            "    async def get_root_value(",
            "        self, request: Request",
            "    ) -> Optional[RootValue]:  # pragma: no cover",
            "        raise ValueError(\"`get_root_value` is not used by FastAPI GraphQL Router\")",
            "",
            "    async def get_sub_response(self, request: Request) -> Response:",
            "        return self.temporal_response",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        response = Response(",
            "            self.encode_json(response_data),",
            "            media_type=\"application/json\",",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "        )",
            "",
            "        response.headers.raw.extend(sub_response.headers.raw)",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request,",
            "        stream: Callable[[], AsyncIterator[str]],",
            "        sub_response: Response,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        return StreamingResponse(",
            "            stream(),",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "",
            "__all__ = [\"GraphQLRouter\"]"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from datetime import timedelta",
            "from inspect import signature",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Sequence,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlette import status",
            "from starlette.background import BackgroundTasks  # noqa: TCH002",
            "from starlette.requests import HTTPConnection, Request",
            "from starlette.responses import (",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            "    Response,",
            "    StreamingResponse,",
            ")",
            "from starlette.websockets import WebSocket",
            "",
            "from fastapi import APIRouter, Depends, params",
            "from fastapi.datastructures import Default",
            "from fastapi.routing import APIRoute",
            "from fastapi.utils import generate_unique_id",
            "from strawberry.asgi import ASGIRequestAdapter",
            "from strawberry.exceptions import InvalidCustomContext",
            "from strawberry.fastapi.context import BaseContext, CustomContext",
            "from strawberry.fastapi.handlers import GraphQLTransportWSHandler, GraphQLWSHandler",
            "from strawberry.http import process_result",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.typevars import Context, RootValue",
            "from strawberry.subscriptions import GRAPHQL_TRANSPORT_WS_PROTOCOL, GRAPHQL_WS_PROTOCOL",
            "",
            "if TYPE_CHECKING:",
            "    from enum import Enum",
            "",
            "    from starlette.routing import BaseRoute",
            "    from starlette.types import ASGIApp, Lifespan",
            "",
            "    from strawberry.fastapi.context import MergedContext",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema import BaseSchema",
            "    from strawberry.types import ExecutionResult",
            "",
            "",
            "class GraphQLRouter(",
            "    AsyncBaseHTTPView[Request, Response, Response, Context, RootValue], APIRouter",
            "):",
            "    graphql_ws_handler_class = GraphQLWSHandler",
            "    graphql_transport_ws_handler_class = GraphQLTransportWSHandler",
            "    allow_queries_via_get = True",
            "    request_adapter_class = ASGIRequestAdapter",
            "",
            "    @staticmethod",
            "    async def __get_root_value() -> None:",
            "        return None",
            "",
            "    @staticmethod",
            "    def __get_context_getter(",
            "        custom_getter: Callable[",
            "            ..., Union[Optional[CustomContext], Awaitable[Optional[CustomContext]]]",
            "        ],",
            "    ) -> Callable[..., Awaitable[CustomContext]]:",
            "        async def dependency(",
            "            custom_context: Optional[CustomContext],",
            "            background_tasks: BackgroundTasks,",
            "            connection: HTTPConnection,",
            "            response: Response = None,  # type: ignore",
            "        ) -> MergedContext:",
            "            request = cast(Union[Request, WebSocket], connection)",
            "            if isinstance(custom_context, BaseContext):",
            "                custom_context.request = request",
            "                custom_context.background_tasks = background_tasks",
            "                custom_context.response = response",
            "                return custom_context",
            "            default_context = {",
            "                \"request\": request,",
            "                \"background_tasks\": background_tasks,",
            "                \"response\": response,",
            "            }",
            "            if isinstance(custom_context, dict):",
            "                return {",
            "                    **default_context,",
            "                    **custom_context,",
            "                }",
            "            elif custom_context is None:",
            "                return default_context",
            "            else:",
            "                raise InvalidCustomContext()",
            "",
            "        # replace the signature parameters of dependency...",
            "        # ...with the old parameters minus the first argument as it will be replaced...",
            "        # ...with the value obtained by injecting custom_getter context as a dependency.",
            "        sig = signature(dependency)",
            "        sig = sig.replace(",
            "            parameters=[",
            "                *list(sig.parameters.values())[1:],",
            "                sig.parameters[\"custom_context\"].replace(",
            "                    default=Depends(custom_getter)",
            "                ),",
            "            ],",
            "        )",
            "        # there is an ongoing issue with types and .__signature__ applied to Callables:",
            "        # https://github.com/python/mypy/issues/5958, as of 14/12/21",
            "        # as such, the below line has its typing ignored by MyPy",
            "        dependency.__signature__ = sig  # type: ignore",
            "        return dependency",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        path: str = \"\",",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        keep_alive: bool = False,",
            "        keep_alive_interval: float = 1,",
            "        debug: bool = False,",
            "        root_value_getter: Optional[Callable[[], RootValue]] = None,",
            "        context_getter: Optional[Callable[..., Optional[Context]]] = None,",
            "        subscription_protocols: Sequence[str] = (",
            "            GRAPHQL_TRANSPORT_WS_PROTOCOL,",
            "            GRAPHQL_WS_PROTOCOL,",
            "        ),",
            "        connection_init_wait_timeout: timedelta = timedelta(minutes=1),",
            "        prefix: str = \"\",",
            "        tags: Optional[List[Union[str, Enum]]] = None,",
            "        dependencies: Optional[Sequence[params.Depends]] = None,",
            "        default_response_class: Type[Response] = Default(JSONResponse),",
            "        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,",
            "        callbacks: Optional[List[BaseRoute]] = None,",
            "        routes: Optional[List[BaseRoute]] = None,",
            "        redirect_slashes: bool = True,",
            "        default: Optional[ASGIApp] = None,",
            "        dependency_overrides_provider: Optional[Any] = None,",
            "        route_class: Type[APIRoute] = APIRoute,",
            "        on_startup: Optional[Sequence[Callable[[], Any]]] = None,",
            "        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,",
            "        lifespan: Optional[Lifespan[Any]] = None,",
            "        deprecated: Optional[bool] = None,",
            "        include_in_schema: bool = True,",
            "        generate_unique_id_function: Callable[[APIRoute], str] = Default(",
            "            generate_unique_id",
            "        ),",
            "        multipart_uploads_enabled: bool = False,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        super().__init__(",
            "            prefix=prefix,",
            "            tags=tags,",
            "            dependencies=dependencies,",
            "            default_response_class=default_response_class,",
            "            responses=responses,",
            "            callbacks=callbacks,",
            "            routes=routes,",
            "            redirect_slashes=redirect_slashes,",
            "            default=default,",
            "            dependency_overrides_provider=dependency_overrides_provider,",
            "            route_class=route_class,",
            "            on_startup=on_startup,",
            "            on_shutdown=on_shutdown,",
            "            lifespan=lifespan,",
            "            deprecated=deprecated,",
            "            include_in_schema=include_in_schema,",
            "            generate_unique_id_function=generate_unique_id_function,",
            "            **kwargs,",
            "        )",
            "        self.schema = schema",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.keep_alive = keep_alive",
            "        self.keep_alive_interval = keep_alive_interval",
            "        self.debug = debug",
            "        self.root_value_getter = root_value_getter or self.__get_root_value",
            "        # TODO: clean this type up",
            "        self.context_getter = self.__get_context_getter(",
            "            context_getter or (lambda: None)  # type: ignore",
            "        )",
            "        self.protocols = subscription_protocols",
            "        self.connection_init_wait_timeout = connection_init_wait_timeout",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "        @self.get(",
            "            path,",
            "            responses={",
            "                200: {",
            "                    \"description\": \"The GraphiQL integrated development environment.\",",
            "                },",
            "                404: {",
            "                    \"description\": (",
            "                        \"Not found if GraphiQL or query via GET are not enabled.\"",
            "                    )",
            "                },",
            "            },",
            "            include_in_schema=graphiql or allow_queries_via_get,",
            "        )",
            "        async def handle_http_get(  # pyright: ignore",
            "            request: Request,",
            "            response: Response,",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> Response:",
            "            self.temporal_response = response",
            "",
            "            try:",
            "                return await self.run(",
            "                    request=request, context=context, root_value=root_value",
            "                )",
            "            except HTTPException as e:",
            "                return PlainTextResponse(",
            "                    e.reason,",
            "                    status_code=e.status_code,",
            "                )",
            "",
            "        @self.post(path)",
            "        async def handle_http_post(  # pyright: ignore",
            "            request: Request,",
            "            response: Response,",
            "            # TODO: use Annotated in future",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> Response:",
            "            self.temporal_response = response",
            "",
            "            try:",
            "                return await self.run(",
            "                    request=request, context=context, root_value=root_value",
            "                )",
            "            except HTTPException as e:",
            "                return PlainTextResponse(",
            "                    e.reason,",
            "                    status_code=e.status_code,",
            "                )",
            "",
            "        @self.websocket(path)",
            "        async def websocket_endpoint(  # pyright: ignore",
            "            websocket: WebSocket,",
            "            context: Context = Depends(self.context_getter),",
            "            root_value: RootValue = Depends(self.root_value_getter),",
            "        ) -> None:",
            "            async def _get_context() -> Context:",
            "                return context",
            "",
            "            async def _get_root_value() -> RootValue:",
            "                return root_value",
            "",
            "            preferred_protocol = self.pick_preferred_protocol(websocket)",
            "            if preferred_protocol == GRAPHQL_TRANSPORT_WS_PROTOCOL:",
            "                await self.graphql_transport_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    connection_init_wait_timeout=self.connection_init_wait_timeout,",
            "                    get_context=_get_context,",
            "                    get_root_value=_get_root_value,",
            "                    ws=websocket,",
            "                ).handle()",
            "            elif preferred_protocol == GRAPHQL_WS_PROTOCOL:",
            "                await self.graphql_ws_handler_class(",
            "                    schema=self.schema,",
            "                    debug=self.debug,",
            "                    keep_alive=self.keep_alive,",
            "                    keep_alive_interval=self.keep_alive_interval,",
            "                    get_context=_get_context,",
            "                    get_root_value=_get_root_value,",
            "                    ws=websocket,",
            "                ).handle()",
            "            else:",
            "                # Code 4406 is \"Subprotocol not acceptable\"",
            "                await websocket.close(code=4406)",
            "",
            "    def pick_preferred_protocol(self, ws: WebSocket) -> Optional[str]:",
            "        protocols = ws[\"subprotocols\"]",
            "        intersection = set(protocols) & set(self.protocols)",
            "        return min(",
            "            intersection,",
            "            key=lambda i: protocols.index(i),",
            "            default=None,",
            "        )",
            "",
            "    async def render_graphql_ide(self, request: Request) -> HTMLResponse:",
            "        return HTMLResponse(self.graphql_ide_html)",
            "",
            "    async def process_result(",
            "        self, request: Request, result: ExecutionResult",
            "    ) -> GraphQLHTTPResponse:",
            "        return process_result(result)",
            "",
            "    async def get_context(",
            "        self, request: Request, response: Response",
            "    ) -> Context:  # pragma: no cover",
            "        raise ValueError(\"`get_context` is not used by FastAPI GraphQL Router\")",
            "",
            "    async def get_root_value(",
            "        self, request: Request",
            "    ) -> Optional[RootValue]:  # pragma: no cover",
            "        raise ValueError(\"`get_root_value` is not used by FastAPI GraphQL Router\")",
            "",
            "    async def get_sub_response(self, request: Request) -> Response:",
            "        return self.temporal_response",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        response = Response(",
            "            self.encode_json(response_data),",
            "            media_type=\"application/json\",",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "        )",
            "",
            "        response.headers.raw.extend(sub_response.headers.raw)",
            "",
            "        return response",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request,",
            "        stream: Callable[[], AsyncIterator[str]],",
            "        sub_response: Response,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        return StreamingResponse(",
            "            stream(),",
            "            status_code=sub_response.status_code or status.HTTP_200_OK,",
            "            headers={",
            "                **sub_response.headers,",
            "                **headers,",
            "            },",
            "        )",
            "",
            "",
            "__all__ = [\"GraphQLRouter\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "strawberry.fastapi.router.GraphQLRouter",
            "yt_dlp.YoutubeDL"
        ]
    },
    "strawberry/flask/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         graphiql: Optional[bool] = None,"
            },
            "1": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         graphql_ide: Optional[GraphQL_IDE] = \"graphiql\","
            },
            "2": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         allow_queries_via_get: bool = True,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        multipart_uploads_enabled: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     ) -> None:"
            },
            "5": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self.schema = schema"
            },
            "6": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         self.graphiql = graphiql"
            },
            "7": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         self.allow_queries_via_get = allow_queries_via_get"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        self.multipart_uploads_enabled = multipart_uploads_enabled"
            },
            "9": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         if graphiql is not None:"
            },
            "11": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             warnings.warn("
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from flask import Request, Response, render_template_string, request",
            "from flask.views import View",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import (",
            "    SyncBaseHTTPView,",
            "    SyncHTTPRequestAdapter,",
            ")",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import Context, RootValue",
            "",
            "if TYPE_CHECKING:",
            "    from flask.typing import ResponseReturnValue",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema.base import BaseSchema",
            "",
            "",
            "class FlaskHTTPRequestAdapter(SyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.args.to_dict()",
            "",
            "    @property",
            "    def body(self) -> Union[str, bytes]:",
            "        return self.request.data.decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.form",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.files",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class BaseGraphQLView:",
            "    _ide_subscription_enabled = False",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.graphiql = graphiql",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        sub_response.set_data(self.encode_json(response_data))  # type: ignore",
            "",
            "        return sub_response",
            "",
            "",
            "class GraphQLView(",
            "    BaseGraphQLView,",
            "    SyncBaseHTTPView[Request, Response, Response, Context, RootValue],",
            "    View,",
            "):",
            "    methods = [\"GET\", \"POST\"]",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = FlaskHTTPRequestAdapter",
            "",
            "    def get_context(self, request: Request, response: Response) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    def get_root_value(self, request: Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    def get_sub_response(self, request: Request) -> Response:",
            "        return Response(status=200, content_type=\"application/json\")",
            "",
            "    def dispatch_request(self) -> ResponseReturnValue:",
            "        try:",
            "            return self.run(request=request)",
            "        except HTTPException as e:",
            "            return Response(",
            "                response=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    def render_graphql_ide(self, request: Request) -> Response:",
            "        return render_template_string(self.graphql_ide_html)  # type: ignore",
            "",
            "",
            "class AsyncFlaskHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.args.to_dict()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    async def get_body(self) -> str:",
            "        return self.request.data.decode()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return FormData(",
            "            files=self.request.files,",
            "            form=self.request.form,",
            "        )",
            "",
            "",
            "class AsyncGraphQLView(",
            "    BaseGraphQLView,",
            "    AsyncBaseHTTPView[Request, Response, Response, Context, RootValue],",
            "    View,",
            "):",
            "    methods = [\"GET\", \"POST\"]",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = AsyncFlaskHTTPRequestAdapter",
            "",
            "    async def get_context(self, request: Request, response: Response) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    async def get_root_value(self, request: Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    async def get_sub_response(self, request: Request) -> Response:",
            "        return Response(status=200, content_type=\"application/json\")",
            "",
            "    async def dispatch_request(self) -> ResponseReturnValue:  # type: ignore",
            "        try:",
            "            return await self.run(request=request)",
            "        except HTTPException as e:",
            "            return Response(",
            "                response=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    async def render_graphql_ide(self, request: Request) -> Response:",
            "        return render_template_string(self.graphql_ide_html)  # type: ignore",
            "",
            "",
            "__all__ = [",
            "    \"GraphQLView\",",
            "    \"AsyncGraphQLView\",",
            "]"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Mapping,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from flask import Request, Response, render_template_string, request",
            "from flask.views import View",
            "from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncHTTPRequestAdapter",
            "from strawberry.http.exceptions import HTTPException",
            "from strawberry.http.sync_base_view import (",
            "    SyncBaseHTTPView,",
            "    SyncHTTPRequestAdapter,",
            ")",
            "from strawberry.http.types import FormData, HTTPMethod, QueryParams",
            "from strawberry.http.typevars import Context, RootValue",
            "",
            "if TYPE_CHECKING:",
            "    from flask.typing import ResponseReturnValue",
            "    from strawberry.http import GraphQLHTTPResponse",
            "    from strawberry.http.ides import GraphQL_IDE",
            "    from strawberry.schema.base import BaseSchema",
            "",
            "",
            "class FlaskHTTPRequestAdapter(SyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.args.to_dict()",
            "",
            "    @property",
            "    def body(self) -> Union[str, bytes]:",
            "        return self.request.data.decode()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    @property",
            "    def post_data(self) -> Mapping[str, Union[str, bytes]]:",
            "        return self.request.form",
            "",
            "    @property",
            "    def files(self) -> Mapping[str, Any]:",
            "        return self.request.files",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "",
            "class BaseGraphQLView:",
            "    _ide_subscription_enabled = False",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "",
            "    def __init__(",
            "        self,",
            "        schema: BaseSchema,",
            "        graphiql: Optional[bool] = None,",
            "        graphql_ide: Optional[GraphQL_IDE] = \"graphiql\",",
            "        allow_queries_via_get: bool = True,",
            "        multipart_uploads_enabled: bool = False,",
            "    ) -> None:",
            "        self.schema = schema",
            "        self.graphiql = graphiql",
            "        self.allow_queries_via_get = allow_queries_via_get",
            "        self.multipart_uploads_enabled = multipart_uploads_enabled",
            "",
            "        if graphiql is not None:",
            "            warnings.warn(",
            "                \"The `graphiql` argument is deprecated in favor of `graphql_ide`\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            self.graphql_ide = \"graphiql\" if graphiql else None",
            "        else:",
            "            self.graphql_ide = graphql_ide",
            "",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: Response",
            "    ) -> Response:",
            "        sub_response.set_data(self.encode_json(response_data))  # type: ignore",
            "",
            "        return sub_response",
            "",
            "",
            "class GraphQLView(",
            "    BaseGraphQLView,",
            "    SyncBaseHTTPView[Request, Response, Response, Context, RootValue],",
            "    View,",
            "):",
            "    methods = [\"GET\", \"POST\"]",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = FlaskHTTPRequestAdapter",
            "",
            "    def get_context(self, request: Request, response: Response) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    def get_root_value(self, request: Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    def get_sub_response(self, request: Request) -> Response:",
            "        return Response(status=200, content_type=\"application/json\")",
            "",
            "    def dispatch_request(self) -> ResponseReturnValue:",
            "        try:",
            "            return self.run(request=request)",
            "        except HTTPException as e:",
            "            return Response(",
            "                response=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    def render_graphql_ide(self, request: Request) -> Response:",
            "        return render_template_string(self.graphql_ide_html)  # type: ignore",
            "",
            "",
            "class AsyncFlaskHTTPRequestAdapter(AsyncHTTPRequestAdapter):",
            "    def __init__(self, request: Request) -> None:",
            "        self.request = request",
            "",
            "    @property",
            "    def query_params(self) -> QueryParams:",
            "        return self.request.args.to_dict()",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod:",
            "        return cast(HTTPMethod, self.request.method.upper())",
            "",
            "    @property",
            "    def content_type(self) -> Optional[str]:",
            "        return self.request.content_type",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]:",
            "        return self.request.headers",
            "",
            "    async def get_body(self) -> str:",
            "        return self.request.data.decode()",
            "",
            "    async def get_form_data(self) -> FormData:",
            "        return FormData(",
            "            files=self.request.files,",
            "            form=self.request.form,",
            "        )",
            "",
            "",
            "class AsyncGraphQLView(",
            "    BaseGraphQLView,",
            "    AsyncBaseHTTPView[Request, Response, Response, Context, RootValue],",
            "    View,",
            "):",
            "    methods = [\"GET\", \"POST\"]",
            "    allow_queries_via_get: bool = True",
            "    request_adapter_class = AsyncFlaskHTTPRequestAdapter",
            "",
            "    async def get_context(self, request: Request, response: Response) -> Context:",
            "        return {\"request\": request, \"response\": response}  # type: ignore",
            "",
            "    async def get_root_value(self, request: Request) -> Optional[RootValue]:",
            "        return None",
            "",
            "    async def get_sub_response(self, request: Request) -> Response:",
            "        return Response(status=200, content_type=\"application/json\")",
            "",
            "    async def dispatch_request(self) -> ResponseReturnValue:  # type: ignore",
            "        try:",
            "            return await self.run(request=request)",
            "        except HTTPException as e:",
            "            return Response(",
            "                response=e.reason,",
            "                status=e.status_code,",
            "            )",
            "",
            "    async def render_graphql_ide(self, request: Request) -> Response:",
            "        return render_template_string(self.graphql_ide_html)  # type: ignore",
            "",
            "",
            "__all__ = [",
            "    \"GraphQLView\",",
            "    \"AsyncGraphQLView\",",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "yt_dlp.YoutubeDL",
            "strawberry.flask.views.BaseGraphQLView"
        ]
    },
    "strawberry/http/async_base_view.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "             data = self.parse_query_params(request.query_params)"
            },
            "1": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         elif \"application/json\" in content_type:"
            },
            "2": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "             data = self.parse_json(await request.get_body())"
            },
            "3": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif content_type == \"multipart/form-data\":"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        elif self.multipart_uploads_enabled and content_type == \"multipart/form-data\":"
            },
            "5": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "             data = await self.parse_multipart(request)"
            },
            "6": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "         else:"
            },
            "7": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "             raise HTTPException(400, \"Unsupported content type\")"
            }
        },
        "frontPatchFile": [
            "import abc",
            "import asyncio",
            "import contextlib",
            "import json",
            "from typing import (",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Generic,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from typing_extensions import Literal",
            "",
            "from graphql import GraphQLError",
            "",
            "from strawberry import UNSET",
            "from strawberry.exceptions import MissingQueryError",
            "from strawberry.file_uploads.utils import replace_placeholders_with_files",
            "from strawberry.http import (",
            "    GraphQLHTTPResponse,",
            "    GraphQLRequestData,",
            "    process_result,",
            ")",
            "from strawberry.http.ides import GraphQL_IDE",
            "from strawberry.schema.base import BaseSchema",
            "from strawberry.schema.exceptions import InvalidOperationTypeError",
            "from strawberry.types import ExecutionResult, SubscriptionExecutionResult",
            "from strawberry.types.graphql import OperationType",
            "",
            "from .base import BaseView",
            "from .exceptions import HTTPException",
            "from .parse_content_type import parse_content_type",
            "from .types import FormData, HTTPMethod, QueryParams",
            "from .typevars import Context, Request, Response, RootValue, SubResponse",
            "",
            "",
            "class AsyncHTTPRequestAdapter(abc.ABC):",
            "    @property",
            "    @abc.abstractmethod",
            "    def query_params(self) -> QueryParams: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def method(self) -> HTTPMethod: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def headers(self) -> Mapping[str, str]: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def content_type(self) -> Optional[str]: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_body(self) -> Union[str, bytes]: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_form_data(self) -> FormData: ...",
            "",
            "",
            "class AsyncBaseHTTPView(",
            "    abc.ABC,",
            "    BaseView[Request],",
            "    Generic[Request, Response, SubResponse, Context, RootValue],",
            "):",
            "    schema: BaseSchema",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "    request_adapter_class: Callable[[Request], AsyncHTTPRequestAdapter]",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def allow_queries_via_get(self) -> bool: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_sub_response(self, request: Request) -> SubResponse: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_context(self, request: Request, response: SubResponse) -> Context: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_root_value(self, request: Request) -> Optional[RootValue]: ...",
            "",
            "    @abc.abstractmethod",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: SubResponse",
            "    ) -> Response: ...",
            "",
            "    @abc.abstractmethod",
            "    async def render_graphql_ide(self, request: Request) -> Response: ...",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: SubResponse,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        raise ValueError(\"Multipart responses are not supported\")",
            "",
            "    async def execute_operation(",
            "        self, request: Request, context: Context, root_value: Optional[RootValue]",
            "    ) -> Union[ExecutionResult, SubscriptionExecutionResult]:",
            "        request_adapter = self.request_adapter_class(request)",
            "",
            "        try:",
            "            request_data = await self.parse_http_body(request_adapter)",
            "        except json.decoder.JSONDecodeError as e:",
            "            raise HTTPException(400, \"Unable to parse request body as JSON\") from e",
            "            # DO this only when doing files",
            "        except KeyError as e:",
            "            raise HTTPException(400, \"File(s) missing in form data\") from e",
            "",
            "        allowed_operation_types = OperationType.from_http(request_adapter.method)",
            "",
            "        if not self.allow_queries_via_get and request_adapter.method == \"GET\":",
            "            allowed_operation_types = allowed_operation_types - {OperationType.QUERY}",
            "",
            "        assert self.schema",
            "",
            "        if request_data.protocol == \"multipart-subscription\":",
            "            return await self.schema.subscribe(",
            "                request_data.query,  # type: ignore",
            "                variable_values=request_data.variables,",
            "                context_value=context,",
            "                root_value=root_value,",
            "                operation_name=request_data.operation_name,",
            "            )",
            "",
            "        return await self.schema.execute(",
            "            request_data.query,",
            "            root_value=root_value,",
            "            variable_values=request_data.variables,",
            "            context_value=context,",
            "            operation_name=request_data.operation_name,",
            "            allowed_operation_types=allowed_operation_types,",
            "        )",
            "",
            "    async def parse_multipart(self, request: AsyncHTTPRequestAdapter) -> Dict[str, str]:",
            "        try:",
            "            form_data = await request.get_form_data()",
            "        except ValueError as e:",
            "            raise HTTPException(400, \"Unable to parse the multipart body\") from e",
            "",
            "        operations = form_data[\"form\"].get(\"operations\", \"{}\")",
            "        files_map = form_data[\"form\"].get(\"map\", \"{}\")",
            "",
            "        if isinstance(operations, (bytes, str)):",
            "            operations = self.parse_json(operations)",
            "",
            "        if isinstance(files_map, (bytes, str)):",
            "            files_map = self.parse_json(files_map)",
            "",
            "        try:",
            "            return replace_placeholders_with_files(",
            "                operations, files_map, form_data[\"files\"]",
            "            )",
            "        except KeyError as e:",
            "            raise HTTPException(400, \"File(s) missing in form data\") from e",
            "",
            "    def _handle_errors(",
            "        self, errors: List[GraphQLError], response_data: GraphQLHTTPResponse",
            "    ) -> None:",
            "        \"\"\"Hook to allow custom handling of errors, used by the Sentry Integration.\"\"\"",
            "",
            "    async def run(",
            "        self,",
            "        request: Request,",
            "        context: Optional[Context] = UNSET,",
            "        root_value: Optional[RootValue] = UNSET,",
            "    ) -> Response:",
            "        request_adapter = self.request_adapter_class(request)",
            "",
            "        if not self.is_request_allowed(request_adapter):",
            "            raise HTTPException(405, \"GraphQL only supports GET and POST requests.\")",
            "",
            "        if self.should_render_graphql_ide(request_adapter):",
            "            if self.graphql_ide:",
            "                return await self.render_graphql_ide(request)",
            "            else:",
            "                raise HTTPException(404, \"Not Found\")",
            "",
            "        sub_response = await self.get_sub_response(request)",
            "        context = (",
            "            await self.get_context(request, response=sub_response)",
            "            if context is UNSET",
            "            else context",
            "        )",
            "        root_value = (",
            "            await self.get_root_value(request) if root_value is UNSET else root_value",
            "        )",
            "",
            "        assert context",
            "",
            "        try:",
            "            result = await self.execute_operation(",
            "                request=request, context=context, root_value=root_value",
            "            )",
            "        except InvalidOperationTypeError as e:",
            "            raise HTTPException(",
            "                400, e.as_http_error_reason(request_adapter.method)",
            "            ) from e",
            "        except MissingQueryError as e:",
            "            raise HTTPException(400, \"No GraphQL query found in the request\") from e",
            "",
            "        if isinstance(result, SubscriptionExecutionResult):",
            "            stream = self._get_stream(request, result)",
            "",
            "            return await self.create_streaming_response(",
            "                request,",
            "                stream,",
            "                sub_response,",
            "                headers={",
            "                    \"Transfer-Encoding\": \"chunked\",",
            "                    \"Content-Type\": \"multipart/mixed;boundary=graphql;subscriptionSpec=1.0,application/json\",",
            "                },",
            "            )",
            "",
            "        response_data = await self.process_result(request=request, result=result)",
            "",
            "        if result.errors:",
            "            self._handle_errors(result.errors, response_data)",
            "",
            "        return self.create_response(",
            "            response_data=response_data, sub_response=sub_response",
            "        )",
            "",
            "    def encode_multipart_data(self, data: Any, separator: str) -> str:",
            "        return \"\".join(",
            "            [",
            "                f\"\\r\\n--{separator}\\r\\n\",",
            "                \"Content-Type: application/json\\r\\n\\r\\n\",",
            "                self.encode_json(data),",
            "                \"\\n\",",
            "            ]",
            "        )",
            "",
            "    def _stream_with_heartbeat(",
            "        self, stream: Callable[[], AsyncGenerator[str, None]]",
            "    ) -> Callable[[], AsyncGenerator[str, None]]:",
            "        \"\"\"Adds a heartbeat to the stream, to prevent the connection from closing when there are no messages being sent.\"\"\"",
            "        queue: asyncio.Queue[Tuple[bool, Any]] = asyncio.Queue(1)",
            "",
            "        cancelling = False",
            "",
            "        async def drain() -> None:",
            "            try:",
            "                async for item in stream():",
            "                    await queue.put((False, item))",
            "            except Exception as e:",
            "                if not cancelling:",
            "                    await queue.put((True, e))",
            "                else:",
            "                    raise",
            "",
            "        async def heartbeat() -> None:",
            "            while True:",
            "                await queue.put((False, self.encode_multipart_data({}, \"graphql\")))",
            "",
            "                await asyncio.sleep(5)",
            "",
            "        async def merged() -> AsyncGenerator[str, None]:",
            "            heartbeat_task = asyncio.create_task(heartbeat())",
            "            task = asyncio.create_task(drain())",
            "",
            "            async def cancel_tasks() -> None:",
            "                nonlocal cancelling",
            "                cancelling = True",
            "                task.cancel()",
            "",
            "                with contextlib.suppress(asyncio.CancelledError):",
            "                    await task",
            "",
            "                heartbeat_task.cancel()",
            "",
            "                with contextlib.suppress(asyncio.CancelledError):",
            "                    await heartbeat_task",
            "",
            "            try:",
            "                while not task.done():",
            "                    raised, data = await queue.get()",
            "",
            "                    if raised:",
            "                        await cancel_tasks()",
            "                        raise data",
            "",
            "                    yield data",
            "            finally:",
            "                await cancel_tasks()",
            "",
            "        return merged",
            "",
            "    def _get_stream(",
            "        self,",
            "        request: Request,",
            "        result: SubscriptionExecutionResult,",
            "        separator: str = \"graphql\",",
            "    ) -> Callable[[], AsyncGenerator[str, None]]:",
            "        async def stream() -> AsyncGenerator[str, None]:",
            "            async for value in result:",
            "                response = await self.process_result(request, value)",
            "                yield self.encode_multipart_data({\"payload\": response}, separator)",
            "",
            "            yield f\"\\r\\n--{separator}--\\r\\n\"",
            "",
            "        return self._stream_with_heartbeat(stream)",
            "",
            "    async def parse_multipart_subscriptions(",
            "        self, request: AsyncHTTPRequestAdapter",
            "    ) -> Dict[str, str]:",
            "        if request.method == \"GET\":",
            "            return self.parse_query_params(request.query_params)",
            "",
            "        return self.parse_json(await request.get_body())",
            "",
            "    async def parse_http_body(",
            "        self, request: AsyncHTTPRequestAdapter",
            "    ) -> GraphQLRequestData:",
            "        headers = {key.lower(): value for key, value in request.headers.items()}",
            "        content_type, _ = parse_content_type(request.content_type or \"\")",
            "        accept = headers.get(\"accept\", \"\")",
            "",
            "        protocol: Literal[\"http\", \"multipart-subscription\"] = \"http\"",
            "",
            "        if self._is_multipart_subscriptions(*parse_content_type(accept)):",
            "            protocol = \"multipart-subscription\"",
            "",
            "        if request.method == \"GET\":",
            "            data = self.parse_query_params(request.query_params)",
            "        elif \"application/json\" in content_type:",
            "            data = self.parse_json(await request.get_body())",
            "        elif content_type == \"multipart/form-data\":",
            "            data = await self.parse_multipart(request)",
            "        else:",
            "            raise HTTPException(400, \"Unsupported content type\")",
            "",
            "        return GraphQLRequestData(",
            "            query=data.get(\"query\"),",
            "            variables=data.get(\"variables\"),",
            "            operation_name=data.get(\"operationName\"),",
            "            protocol=protocol,",
            "        )",
            "",
            "    async def process_result(",
            "        self, request: Request, result: ExecutionResult",
            "    ) -> GraphQLHTTPResponse:",
            "        return process_result(result)",
            "",
            "",
            "__all__ = [\"AsyncBaseHTTPView\"]"
        ],
        "afterPatchFile": [
            "import abc",
            "import asyncio",
            "import contextlib",
            "import json",
            "from typing import (",
            "    Any,",
            "    AsyncGenerator,",
            "    Callable,",
            "    Dict,",
            "    Generic,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from typing_extensions import Literal",
            "",
            "from graphql import GraphQLError",
            "",
            "from strawberry import UNSET",
            "from strawberry.exceptions import MissingQueryError",
            "from strawberry.file_uploads.utils import replace_placeholders_with_files",
            "from strawberry.http import (",
            "    GraphQLHTTPResponse,",
            "    GraphQLRequestData,",
            "    process_result,",
            ")",
            "from strawberry.http.ides import GraphQL_IDE",
            "from strawberry.schema.base import BaseSchema",
            "from strawberry.schema.exceptions import InvalidOperationTypeError",
            "from strawberry.types import ExecutionResult, SubscriptionExecutionResult",
            "from strawberry.types.graphql import OperationType",
            "",
            "from .base import BaseView",
            "from .exceptions import HTTPException",
            "from .parse_content_type import parse_content_type",
            "from .types import FormData, HTTPMethod, QueryParams",
            "from .typevars import Context, Request, Response, RootValue, SubResponse",
            "",
            "",
            "class AsyncHTTPRequestAdapter(abc.ABC):",
            "    @property",
            "    @abc.abstractmethod",
            "    def query_params(self) -> QueryParams: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def method(self) -> HTTPMethod: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def headers(self) -> Mapping[str, str]: ...",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def content_type(self) -> Optional[str]: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_body(self) -> Union[str, bytes]: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_form_data(self) -> FormData: ...",
            "",
            "",
            "class AsyncBaseHTTPView(",
            "    abc.ABC,",
            "    BaseView[Request],",
            "    Generic[Request, Response, SubResponse, Context, RootValue],",
            "):",
            "    schema: BaseSchema",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "    request_adapter_class: Callable[[Request], AsyncHTTPRequestAdapter]",
            "",
            "    @property",
            "    @abc.abstractmethod",
            "    def allow_queries_via_get(self) -> bool: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_sub_response(self, request: Request) -> SubResponse: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_context(self, request: Request, response: SubResponse) -> Context: ...",
            "",
            "    @abc.abstractmethod",
            "    async def get_root_value(self, request: Request) -> Optional[RootValue]: ...",
            "",
            "    @abc.abstractmethod",
            "    def create_response(",
            "        self, response_data: GraphQLHTTPResponse, sub_response: SubResponse",
            "    ) -> Response: ...",
            "",
            "    @abc.abstractmethod",
            "    async def render_graphql_ide(self, request: Request) -> Response: ...",
            "",
            "    async def create_streaming_response(",
            "        self,",
            "        request: Request,",
            "        stream: Callable[[], AsyncGenerator[str, None]],",
            "        sub_response: SubResponse,",
            "        headers: Dict[str, str],",
            "    ) -> Response:",
            "        raise ValueError(\"Multipart responses are not supported\")",
            "",
            "    async def execute_operation(",
            "        self, request: Request, context: Context, root_value: Optional[RootValue]",
            "    ) -> Union[ExecutionResult, SubscriptionExecutionResult]:",
            "        request_adapter = self.request_adapter_class(request)",
            "",
            "        try:",
            "            request_data = await self.parse_http_body(request_adapter)",
            "        except json.decoder.JSONDecodeError as e:",
            "            raise HTTPException(400, \"Unable to parse request body as JSON\") from e",
            "            # DO this only when doing files",
            "        except KeyError as e:",
            "            raise HTTPException(400, \"File(s) missing in form data\") from e",
            "",
            "        allowed_operation_types = OperationType.from_http(request_adapter.method)",
            "",
            "        if not self.allow_queries_via_get and request_adapter.method == \"GET\":",
            "            allowed_operation_types = allowed_operation_types - {OperationType.QUERY}",
            "",
            "        assert self.schema",
            "",
            "        if request_data.protocol == \"multipart-subscription\":",
            "            return await self.schema.subscribe(",
            "                request_data.query,  # type: ignore",
            "                variable_values=request_data.variables,",
            "                context_value=context,",
            "                root_value=root_value,",
            "                operation_name=request_data.operation_name,",
            "            )",
            "",
            "        return await self.schema.execute(",
            "            request_data.query,",
            "            root_value=root_value,",
            "            variable_values=request_data.variables,",
            "            context_value=context,",
            "            operation_name=request_data.operation_name,",
            "            allowed_operation_types=allowed_operation_types,",
            "        )",
            "",
            "    async def parse_multipart(self, request: AsyncHTTPRequestAdapter) -> Dict[str, str]:",
            "        try:",
            "            form_data = await request.get_form_data()",
            "        except ValueError as e:",
            "            raise HTTPException(400, \"Unable to parse the multipart body\") from e",
            "",
            "        operations = form_data[\"form\"].get(\"operations\", \"{}\")",
            "        files_map = form_data[\"form\"].get(\"map\", \"{}\")",
            "",
            "        if isinstance(operations, (bytes, str)):",
            "            operations = self.parse_json(operations)",
            "",
            "        if isinstance(files_map, (bytes, str)):",
            "            files_map = self.parse_json(files_map)",
            "",
            "        try:",
            "            return replace_placeholders_with_files(",
            "                operations, files_map, form_data[\"files\"]",
            "            )",
            "        except KeyError as e:",
            "            raise HTTPException(400, \"File(s) missing in form data\") from e",
            "",
            "    def _handle_errors(",
            "        self, errors: List[GraphQLError], response_data: GraphQLHTTPResponse",
            "    ) -> None:",
            "        \"\"\"Hook to allow custom handling of errors, used by the Sentry Integration.\"\"\"",
            "",
            "    async def run(",
            "        self,",
            "        request: Request,",
            "        context: Optional[Context] = UNSET,",
            "        root_value: Optional[RootValue] = UNSET,",
            "    ) -> Response:",
            "        request_adapter = self.request_adapter_class(request)",
            "",
            "        if not self.is_request_allowed(request_adapter):",
            "            raise HTTPException(405, \"GraphQL only supports GET and POST requests.\")",
            "",
            "        if self.should_render_graphql_ide(request_adapter):",
            "            if self.graphql_ide:",
            "                return await self.render_graphql_ide(request)",
            "            else:",
            "                raise HTTPException(404, \"Not Found\")",
            "",
            "        sub_response = await self.get_sub_response(request)",
            "        context = (",
            "            await self.get_context(request, response=sub_response)",
            "            if context is UNSET",
            "            else context",
            "        )",
            "        root_value = (",
            "            await self.get_root_value(request) if root_value is UNSET else root_value",
            "        )",
            "",
            "        assert context",
            "",
            "        try:",
            "            result = await self.execute_operation(",
            "                request=request, context=context, root_value=root_value",
            "            )",
            "        except InvalidOperationTypeError as e:",
            "            raise HTTPException(",
            "                400, e.as_http_error_reason(request_adapter.method)",
            "            ) from e",
            "        except MissingQueryError as e:",
            "            raise HTTPException(400, \"No GraphQL query found in the request\") from e",
            "",
            "        if isinstance(result, SubscriptionExecutionResult):",
            "            stream = self._get_stream(request, result)",
            "",
            "            return await self.create_streaming_response(",
            "                request,",
            "                stream,",
            "                sub_response,",
            "                headers={",
            "                    \"Transfer-Encoding\": \"chunked\",",
            "                    \"Content-Type\": \"multipart/mixed;boundary=graphql;subscriptionSpec=1.0,application/json\",",
            "                },",
            "            )",
            "",
            "        response_data = await self.process_result(request=request, result=result)",
            "",
            "        if result.errors:",
            "            self._handle_errors(result.errors, response_data)",
            "",
            "        return self.create_response(",
            "            response_data=response_data, sub_response=sub_response",
            "        )",
            "",
            "    def encode_multipart_data(self, data: Any, separator: str) -> str:",
            "        return \"\".join(",
            "            [",
            "                f\"\\r\\n--{separator}\\r\\n\",",
            "                \"Content-Type: application/json\\r\\n\\r\\n\",",
            "                self.encode_json(data),",
            "                \"\\n\",",
            "            ]",
            "        )",
            "",
            "    def _stream_with_heartbeat(",
            "        self, stream: Callable[[], AsyncGenerator[str, None]]",
            "    ) -> Callable[[], AsyncGenerator[str, None]]:",
            "        \"\"\"Adds a heartbeat to the stream, to prevent the connection from closing when there are no messages being sent.\"\"\"",
            "        queue: asyncio.Queue[Tuple[bool, Any]] = asyncio.Queue(1)",
            "",
            "        cancelling = False",
            "",
            "        async def drain() -> None:",
            "            try:",
            "                async for item in stream():",
            "                    await queue.put((False, item))",
            "            except Exception as e:",
            "                if not cancelling:",
            "                    await queue.put((True, e))",
            "                else:",
            "                    raise",
            "",
            "        async def heartbeat() -> None:",
            "            while True:",
            "                await queue.put((False, self.encode_multipart_data({}, \"graphql\")))",
            "",
            "                await asyncio.sleep(5)",
            "",
            "        async def merged() -> AsyncGenerator[str, None]:",
            "            heartbeat_task = asyncio.create_task(heartbeat())",
            "            task = asyncio.create_task(drain())",
            "",
            "            async def cancel_tasks() -> None:",
            "                nonlocal cancelling",
            "                cancelling = True",
            "                task.cancel()",
            "",
            "                with contextlib.suppress(asyncio.CancelledError):",
            "                    await task",
            "",
            "                heartbeat_task.cancel()",
            "",
            "                with contextlib.suppress(asyncio.CancelledError):",
            "                    await heartbeat_task",
            "",
            "            try:",
            "                while not task.done():",
            "                    raised, data = await queue.get()",
            "",
            "                    if raised:",
            "                        await cancel_tasks()",
            "                        raise data",
            "",
            "                    yield data",
            "            finally:",
            "                await cancel_tasks()",
            "",
            "        return merged",
            "",
            "    def _get_stream(",
            "        self,",
            "        request: Request,",
            "        result: SubscriptionExecutionResult,",
            "        separator: str = \"graphql\",",
            "    ) -> Callable[[], AsyncGenerator[str, None]]:",
            "        async def stream() -> AsyncGenerator[str, None]:",
            "            async for value in result:",
            "                response = await self.process_result(request, value)",
            "                yield self.encode_multipart_data({\"payload\": response}, separator)",
            "",
            "            yield f\"\\r\\n--{separator}--\\r\\n\"",
            "",
            "        return self._stream_with_heartbeat(stream)",
            "",
            "    async def parse_multipart_subscriptions(",
            "        self, request: AsyncHTTPRequestAdapter",
            "    ) -> Dict[str, str]:",
            "        if request.method == \"GET\":",
            "            return self.parse_query_params(request.query_params)",
            "",
            "        return self.parse_json(await request.get_body())",
            "",
            "    async def parse_http_body(",
            "        self, request: AsyncHTTPRequestAdapter",
            "    ) -> GraphQLRequestData:",
            "        headers = {key.lower(): value for key, value in request.headers.items()}",
            "        content_type, _ = parse_content_type(request.content_type or \"\")",
            "        accept = headers.get(\"accept\", \"\")",
            "",
            "        protocol: Literal[\"http\", \"multipart-subscription\"] = \"http\"",
            "",
            "        if self._is_multipart_subscriptions(*parse_content_type(accept)):",
            "            protocol = \"multipart-subscription\"",
            "",
            "        if request.method == \"GET\":",
            "            data = self.parse_query_params(request.query_params)",
            "        elif \"application/json\" in content_type:",
            "            data = self.parse_json(await request.get_body())",
            "        elif self.multipart_uploads_enabled and content_type == \"multipart/form-data\":",
            "            data = await self.parse_multipart(request)",
            "        else:",
            "            raise HTTPException(400, \"Unsupported content type\")",
            "",
            "        return GraphQLRequestData(",
            "            query=data.get(\"query\"),",
            "            variables=data.get(\"variables\"),",
            "            operation_name=data.get(\"operationName\"),",
            "            protocol=protocol,",
            "        )",
            "",
            "    async def process_result(",
            "        self, request: Request, result: ExecutionResult",
            "    ) -> GraphQLHTTPResponse:",
            "        return process_result(result)",
            "",
            "",
            "__all__ = [\"AsyncBaseHTTPView\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "336": [
                "AsyncBaseHTTPView"
            ]
        },
        "addLocation": []
    },
    "strawberry/http/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " class BaseView(Generic[Request]):"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     graphql_ide: Optional[GraphQL_IDE]"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    multipart_uploads_enabled: bool = False"
            },
            "4": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     # TODO: we might remove this in future :)"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     _ide_replace_variables: bool = True"
            }
        },
        "frontPatchFile": [
            "import json",
            "from typing import Any, Dict, Generic, List, Mapping, Optional, Union",
            "from typing_extensions import Protocol",
            "",
            "from strawberry.http import GraphQLHTTPResponse",
            "from strawberry.http.ides import GraphQL_IDE, get_graphql_ide_html",
            "from strawberry.http.types import HTTPMethod, QueryParams",
            "",
            "from .exceptions import HTTPException",
            "from .typevars import Request",
            "",
            "",
            "class BaseRequestProtocol(Protocol):",
            "    @property",
            "    def query_params(self) -> Mapping[str, Optional[Union[str, List[str]]]]: ...",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod: ...",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]: ...",
            "",
            "",
            "class BaseView(Generic[Request]):",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "",
            "    # TODO: we might remove this in future :)",
            "    _ide_replace_variables: bool = True",
            "    _ide_subscription_enabled: bool = True",
            "",
            "    def should_render_graphql_ide(self, request: BaseRequestProtocol) -> bool:",
            "        return (",
            "            request.method == \"GET\"",
            "            and request.query_params.get(\"query\") is None",
            "            and any(",
            "                supported_header in request.headers.get(\"accept\", \"\")",
            "                for supported_header in (\"text/html\", \"*/*\")",
            "            )",
            "        )",
            "",
            "    def is_request_allowed(self, request: BaseRequestProtocol) -> bool:",
            "        return request.method in (\"GET\", \"POST\")",
            "",
            "    def parse_json(self, data: Union[str, bytes]) -> Any:",
            "        try:",
            "            return json.loads(data)",
            "        except json.JSONDecodeError as e:",
            "            raise HTTPException(400, \"Unable to parse request body as JSON\") from e",
            "",
            "    def encode_json(self, response_data: GraphQLHTTPResponse) -> str:",
            "        return json.dumps(response_data)",
            "",
            "    def parse_query_params(self, params: QueryParams) -> Dict[str, Any]:",
            "        params = dict(params)",
            "",
            "        if \"variables\" in params:",
            "            variables = params[\"variables\"]",
            "",
            "            if variables:",
            "                params[\"variables\"] = self.parse_json(variables)",
            "",
            "        return params",
            "",
            "    @property",
            "    def graphql_ide_html(self) -> str:",
            "        return get_graphql_ide_html(",
            "            subscription_enabled=self._ide_subscription_enabled,",
            "            replace_variables=self._ide_replace_variables,",
            "            graphql_ide=self.graphql_ide,",
            "        )",
            "",
            "    def _is_multipart_subscriptions(",
            "        self, content_type: str, params: Dict[str, str]",
            "    ) -> bool:",
            "        if content_type != \"multipart/mixed\":",
            "            return False",
            "",
            "        if params.get(\"boundary\") != \"graphql\":",
            "            return False",
            "",
            "        return params.get(\"subscriptionspec\", \"\").startswith(\"1.0\")",
            "",
            "",
            "__all__ = [\"BaseView\"]"
        ],
        "afterPatchFile": [
            "import json",
            "from typing import Any, Dict, Generic, List, Mapping, Optional, Union",
            "from typing_extensions import Protocol",
            "",
            "from strawberry.http import GraphQLHTTPResponse",
            "from strawberry.http.ides import GraphQL_IDE, get_graphql_ide_html",
            "from strawberry.http.types import HTTPMethod, QueryParams",
            "",
            "from .exceptions import HTTPException",
            "from .typevars import Request",
            "",
            "",
            "class BaseRequestProtocol(Protocol):",
            "    @property",
            "    def query_params(self) -> Mapping[str, Optional[Union[str, List[str]]]]: ...",
            "",
            "    @property",
            "    def method(self) -> HTTPMethod: ...",
            "",
            "    @property",
            "    def headers(self) -> Mapping[str, str]: ...",
            "",
            "",
            "class BaseView(Generic[Request]):",
            "    graphql_ide: Optional[GraphQL_IDE]",
            "    multipart_uploads_enabled: bool = False",
            "",
            "    # TODO: we might remove this in future :)",
            "    _ide_replace_variables: bool = True",
            "    _ide_subscription_enabled: bool = True",
            "",
            "    def should_render_graphql_ide(self, request: BaseRequestProtocol) -> bool:",
            "        return (",
            "            request.method == \"GET\"",
            "            and request.query_params.get(\"query\") is None",
            "            and any(",
            "                supported_header in request.headers.get(\"accept\", \"\")",
            "                for supported_header in (\"text/html\", \"*/*\")",
            "            )",
            "        )",
            "",
            "    def is_request_allowed(self, request: BaseRequestProtocol) -> bool:",
            "        return request.method in (\"GET\", \"POST\")",
            "",
            "    def parse_json(self, data: Union[str, bytes]) -> Any:",
            "        try:",
            "            return json.loads(data)",
            "        except json.JSONDecodeError as e:",
            "            raise HTTPException(400, \"Unable to parse request body as JSON\") from e",
            "",
            "    def encode_json(self, response_data: GraphQLHTTPResponse) -> str:",
            "        return json.dumps(response_data)",
            "",
            "    def parse_query_params(self, params: QueryParams) -> Dict[str, Any]:",
            "        params = dict(params)",
            "",
            "        if \"variables\" in params:",
            "            variables = params[\"variables\"]",
            "",
            "            if variables:",
            "                params[\"variables\"] = self.parse_json(variables)",
            "",
            "        return params",
            "",
            "    @property",
            "    def graphql_ide_html(self) -> str:",
            "        return get_graphql_ide_html(",
            "            subscription_enabled=self._ide_subscription_enabled,",
            "            replace_variables=self._ide_replace_variables,",
            "            graphql_ide=self.graphql_ide,",
            "        )",
            "",
            "    def _is_multipart_subscriptions(",
            "        self, content_type: str, params: Dict[str, str]",
            "    ) -> bool:",
            "        if content_type != \"multipart/mixed\":",
            "            return False",
            "",
            "        if params.get(\"boundary\") != \"graphql\":",
            "            return False",
            "",
            "        return params.get(\"subscriptionspec\", \"\").startswith(\"1.0\")",
            "",
            "",
            "__all__ = [\"BaseView\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "strawberry.http.base.BaseView.self"
        ]
    }
}