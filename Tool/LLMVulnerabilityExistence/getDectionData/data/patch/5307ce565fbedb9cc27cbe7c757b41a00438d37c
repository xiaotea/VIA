{
    "django/contrib/auth/middleware.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             # authenticated remote-user, or return (leaving request.user set to"
            },
            "1": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             # AnonymousUser by the AuthenticationMiddleware)."
            },
            "2": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             if request.user.is_authenticated():"
            },
            "3": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "4": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    stored_backend = load_backend(request.session.get("
            },
            "5": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        auth.BACKEND_SESSION_KEY, ''))"
            },
            "6": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if isinstance(stored_backend, RemoteUserBackend):"
            },
            "7": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        auth.logout(request)"
            },
            "8": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except ImportError:"
            },
            "9": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # backend failed to load"
            },
            "10": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    auth.logout(request)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                self._remove_invalid_user(request)"
            },
            "12": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "             return"
            },
            "13": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         # If the user is already authenticated and that user is the user we are"
            },
            "14": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         # getting passed in the headers, then the correct user is already"
            },
            "15": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         # persisted in the session and we don't need to continue."
            },
            "16": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         if request.user.is_authenticated():"
            },
            "17": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             if request.user.get_username() == self.clean_username(username, request):"
            },
            "18": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                 return"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            else:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                # An authenticated user is associated with the request, but"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                # it does not match the authorized user in the header."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                self._remove_invalid_user(request)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         # We are seeing this user for the first time in this session, attempt"
            },
            "25": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         # to authenticate the user."
            },
            "26": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         user = auth.authenticate(remote_user=username)"
            },
            "27": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         except AttributeError:  # Backend has no clean_username method."
            },
            "28": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             pass"
            },
            "29": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         return username"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+    def _remove_invalid_user(self, request):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        \"\"\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        Removes the current authenticated user in the request which is invalid"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        but only if the user is authenticated via the RemoteUserBackend."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        \"\"\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        try:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            stored_backend = load_backend(request.session.get(auth.BACKEND_SESSION_KEY, ''))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        except ImportError:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+            # backend failed to load"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            auth.logout(request)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        else:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            if isinstance(stored_backend, RemoteUserBackend):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                auth.logout(request)"
            }
        },
        "frontPatchFile": [
            "from django.contrib import auth",
            "from django.contrib.auth import load_backend",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.functional import SimpleLazyObject",
            "",
            "",
            "def get_user(request):",
            "    if not hasattr(request, '_cached_user'):",
            "        request._cached_user = auth.get_user(request)",
            "    return request._cached_user",
            "",
            "",
            "class AuthenticationMiddleware(object):",
            "    def process_request(self, request):",
            "        assert hasattr(request, 'session'), (",
            "            \"The Django authentication middleware requires session middleware \"",
            "            \"to be installed. Edit your MIDDLEWARE_CLASSES setting to insert \"",
            "            \"'django.contrib.sessions.middleware.SessionMiddleware' before \"",
            "            \"'django.contrib.auth.middleware.AuthenticationMiddleware'.\"",
            "        )",
            "        request.user = SimpleLazyObject(lambda: get_user(request))",
            "",
            "",
            "class SessionAuthenticationMiddleware(object):",
            "    \"\"\"",
            "    Middleware for invalidating a user's sessions that don't correspond to the",
            "    user's current session authentication hash (generated based on the user's",
            "    password for AbstractUser).",
            "    \"\"\"",
            "    def process_request(self, request):",
            "        user = request.user",
            "        if user and hasattr(user, 'get_session_auth_hash'):",
            "            session_hash = request.session.get(auth.HASH_SESSION_KEY)",
            "            session_hash_verified = session_hash and constant_time_compare(",
            "                session_hash,",
            "                user.get_session_auth_hash()",
            "            )",
            "            if not session_hash_verified:",
            "                auth.logout(request)",
            "",
            "",
            "class RemoteUserMiddleware(object):",
            "    \"\"\"",
            "    Middleware for utilizing Web-server-provided authentication.",
            "",
            "    If request.user is not authenticated, then this middleware attempts to",
            "    authenticate the username passed in the ``REMOTE_USER`` request header.",
            "    If authentication is successful, the user is automatically logged in to",
            "    persist the user in the session.",
            "",
            "    The header used is configurable and defaults to ``REMOTE_USER``.  Subclass",
            "    this class and change the ``header`` attribute if you need to use a",
            "    different header.",
            "    \"\"\"",
            "",
            "    # Name of request header to grab username from.  This will be the key as",
            "    # used in the request.META dictionary, i.e. the normalization of headers to",
            "    # all uppercase and the addition of \"HTTP_\" prefix apply.",
            "    header = \"REMOTE_USER\"",
            "",
            "    def process_request(self, request):",
            "        # AuthenticationMiddleware is required so that request.user exists.",
            "        if not hasattr(request, 'user'):",
            "            raise ImproperlyConfigured(",
            "                \"The Django remote user auth middleware requires the\"",
            "                \" authentication middleware to be installed.  Edit your\"",
            "                \" MIDDLEWARE_CLASSES setting to insert\"",
            "                \" 'django.contrib.auth.middleware.AuthenticationMiddleware'\"",
            "                \" before the RemoteUserMiddleware class.\")",
            "        try:",
            "            username = request.META[self.header]",
            "        except KeyError:",
            "            # If specified header doesn't exist then remove any existing",
            "            # authenticated remote-user, or return (leaving request.user set to",
            "            # AnonymousUser by the AuthenticationMiddleware).",
            "            if request.user.is_authenticated():",
            "                try:",
            "                    stored_backend = load_backend(request.session.get(",
            "                        auth.BACKEND_SESSION_KEY, ''))",
            "                    if isinstance(stored_backend, RemoteUserBackend):",
            "                        auth.logout(request)",
            "                except ImportError:",
            "                    # backend failed to load",
            "                    auth.logout(request)",
            "            return",
            "        # If the user is already authenticated and that user is the user we are",
            "        # getting passed in the headers, then the correct user is already",
            "        # persisted in the session and we don't need to continue.",
            "        if request.user.is_authenticated():",
            "            if request.user.get_username() == self.clean_username(username, request):",
            "                return",
            "        # We are seeing this user for the first time in this session, attempt",
            "        # to authenticate the user.",
            "        user = auth.authenticate(remote_user=username)",
            "        if user:",
            "            # User is valid.  Set request.user and persist user in the session",
            "            # by logging the user in.",
            "            request.user = user",
            "            auth.login(request, user)",
            "",
            "    def clean_username(self, username, request):",
            "        \"\"\"",
            "        Allows the backend to clean the username, if the backend defines a",
            "        clean_username method.",
            "        \"\"\"",
            "        backend_str = request.session[auth.BACKEND_SESSION_KEY]",
            "        backend = auth.load_backend(backend_str)",
            "        try:",
            "            username = backend.clean_username(username)",
            "        except AttributeError:  # Backend has no clean_username method.",
            "            pass",
            "        return username"
        ],
        "afterPatchFile": [
            "from django.contrib import auth",
            "from django.contrib.auth import load_backend",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.functional import SimpleLazyObject",
            "",
            "",
            "def get_user(request):",
            "    if not hasattr(request, '_cached_user'):",
            "        request._cached_user = auth.get_user(request)",
            "    return request._cached_user",
            "",
            "",
            "class AuthenticationMiddleware(object):",
            "    def process_request(self, request):",
            "        assert hasattr(request, 'session'), (",
            "            \"The Django authentication middleware requires session middleware \"",
            "            \"to be installed. Edit your MIDDLEWARE_CLASSES setting to insert \"",
            "            \"'django.contrib.sessions.middleware.SessionMiddleware' before \"",
            "            \"'django.contrib.auth.middleware.AuthenticationMiddleware'.\"",
            "        )",
            "        request.user = SimpleLazyObject(lambda: get_user(request))",
            "",
            "",
            "class SessionAuthenticationMiddleware(object):",
            "    \"\"\"",
            "    Middleware for invalidating a user's sessions that don't correspond to the",
            "    user's current session authentication hash (generated based on the user's",
            "    password for AbstractUser).",
            "    \"\"\"",
            "    def process_request(self, request):",
            "        user = request.user",
            "        if user and hasattr(user, 'get_session_auth_hash'):",
            "            session_hash = request.session.get(auth.HASH_SESSION_KEY)",
            "            session_hash_verified = session_hash and constant_time_compare(",
            "                session_hash,",
            "                user.get_session_auth_hash()",
            "            )",
            "            if not session_hash_verified:",
            "                auth.logout(request)",
            "",
            "",
            "class RemoteUserMiddleware(object):",
            "    \"\"\"",
            "    Middleware for utilizing Web-server-provided authentication.",
            "",
            "    If request.user is not authenticated, then this middleware attempts to",
            "    authenticate the username passed in the ``REMOTE_USER`` request header.",
            "    If authentication is successful, the user is automatically logged in to",
            "    persist the user in the session.",
            "",
            "    The header used is configurable and defaults to ``REMOTE_USER``.  Subclass",
            "    this class and change the ``header`` attribute if you need to use a",
            "    different header.",
            "    \"\"\"",
            "",
            "    # Name of request header to grab username from.  This will be the key as",
            "    # used in the request.META dictionary, i.e. the normalization of headers to",
            "    # all uppercase and the addition of \"HTTP_\" prefix apply.",
            "    header = \"REMOTE_USER\"",
            "",
            "    def process_request(self, request):",
            "        # AuthenticationMiddleware is required so that request.user exists.",
            "        if not hasattr(request, 'user'):",
            "            raise ImproperlyConfigured(",
            "                \"The Django remote user auth middleware requires the\"",
            "                \" authentication middleware to be installed.  Edit your\"",
            "                \" MIDDLEWARE_CLASSES setting to insert\"",
            "                \" 'django.contrib.auth.middleware.AuthenticationMiddleware'\"",
            "                \" before the RemoteUserMiddleware class.\")",
            "        try:",
            "            username = request.META[self.header]",
            "        except KeyError:",
            "            # If specified header doesn't exist then remove any existing",
            "            # authenticated remote-user, or return (leaving request.user set to",
            "            # AnonymousUser by the AuthenticationMiddleware).",
            "            if request.user.is_authenticated():",
            "                self._remove_invalid_user(request)",
            "            return",
            "        # If the user is already authenticated and that user is the user we are",
            "        # getting passed in the headers, then the correct user is already",
            "        # persisted in the session and we don't need to continue.",
            "        if request.user.is_authenticated():",
            "            if request.user.get_username() == self.clean_username(username, request):",
            "                return",
            "            else:",
            "                # An authenticated user is associated with the request, but",
            "                # it does not match the authorized user in the header.",
            "                self._remove_invalid_user(request)",
            "",
            "        # We are seeing this user for the first time in this session, attempt",
            "        # to authenticate the user.",
            "        user = auth.authenticate(remote_user=username)",
            "        if user:",
            "            # User is valid.  Set request.user and persist user in the session",
            "            # by logging the user in.",
            "            request.user = user",
            "            auth.login(request, user)",
            "",
            "    def clean_username(self, username, request):",
            "        \"\"\"",
            "        Allows the backend to clean the username, if the backend defines a",
            "        clean_username method.",
            "        \"\"\"",
            "        backend_str = request.session[auth.BACKEND_SESSION_KEY]",
            "        backend = auth.load_backend(backend_str)",
            "        try:",
            "            username = backend.clean_username(username)",
            "        except AttributeError:  # Backend has no clean_username method.",
            "            pass",
            "        return username",
            "",
            "    def _remove_invalid_user(self, request):",
            "        \"\"\"",
            "        Removes the current authenticated user in the request which is invalid",
            "        but only if the user is authenticated via the RemoteUserBackend.",
            "        \"\"\"",
            "        try:",
            "            stored_backend = load_backend(request.session.get(auth.BACKEND_SESSION_KEY, ''))",
            "        except ImportError:",
            "            # backend failed to load",
            "            auth.logout(request)",
            "        else:",
            "            if isinstance(stored_backend, RemoteUserBackend):",
            "                auth.logout(request)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "79": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "80": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "81": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "82": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "83": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "84": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "85": [
                "RemoteUserMiddleware",
                "process_request"
            ],
            "86": [
                "RemoteUserMiddleware",
                "process_request"
            ]
        },
        "addLocation": []
    },
    "django/contrib/auth/tests/test_remote_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         response = self.client.get('/remote_user/')"
            },
            "1": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         self.assertEqual(response.context['user'].username, 'modeluser')"
            },
            "2": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    def test_user_switch_forces_new_login(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        Tests that if the username in the header changes between requests"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        that the original user is logged out"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        \"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        User.objects.create(username='knownuser')"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        # Known user authenticates"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        response = self.client.get('/remote_user/',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+                                   **{self.header: self.known_user})"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        self.assertEqual(response.context['user'].username, 'knownuser')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        # During the session, the REMOTE_USER changes to a different user."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        response = self.client.get('/remote_user/',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                                   **{self.header: \"newnewuser\"})"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        # Ensure that the current user is not the prior remote_user"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        # In backends that create a new user, username is \"newnewuser\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        # In backends that do not create new users, it is '' (anonymous user)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        self.assertNotEqual(response.context['user'].username, 'knownuser')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     def tearDown(self):"
            },
            "22": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         \"\"\"Restores settings to avoid breaking other tests.\"\"\""
            },
            "23": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         settings.MIDDLEWARE_CLASSES = self.curr_middleware"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import authenticate",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.contrib.auth.middleware import RemoteUserMiddleware",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.test import TestCase, override_settings",
            "from django.utils import timezone",
            "",
            "",
            "@skipIfCustomUser",
            "@override_settings(ROOT_URLCONF='django.contrib.auth.tests.urls')",
            "class RemoteUserTest(TestCase):",
            "",
            "    middleware = 'django.contrib.auth.middleware.RemoteUserMiddleware'",
            "    backend = 'django.contrib.auth.backends.RemoteUserBackend'",
            "    header = 'REMOTE_USER'",
            "",
            "    # Usernames to be passed in REMOTE_USER for the test_known_user test case.",
            "    known_user = 'knownuser'",
            "    known_user2 = 'knownuser2'",
            "",
            "    def setUp(self):",
            "        self.curr_middleware = settings.MIDDLEWARE_CLASSES",
            "        self.curr_auth = settings.AUTHENTICATION_BACKENDS",
            "        settings.MIDDLEWARE_CLASSES += (self.middleware,)",
            "        settings.AUTHENTICATION_BACKENDS += (self.backend,)",
            "",
            "    def test_no_remote_user(self):",
            "        \"\"\"",
            "        Tests requests where no remote user is specified and insures that no",
            "        users get created.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "",
            "        response = self.client.get('/remote_user/')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', **{self.header: None})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', **{self.header: ''})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header does not exist",
            "        as a User.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertEqual(response.context['user'].username, 'newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "        User.objects.get(username='newuser')",
            "",
            "        # Another request with same user should not create any new users.",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header is a valid User.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        User.objects.create(username='knownuser2')",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "        # Test that a different user passed in the headers causes the new user",
            "        # to be logged in.",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user2})",
            "        self.assertEqual(response.context['user'].username, 'knownuser2')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_last_login(self):",
            "        \"\"\"",
            "        Tests that a user's last_login is set the first time they make a",
            "        request but not updated in subsequent requests with the same session.",
            "        \"\"\"",
            "        user = User.objects.create(username='knownuser')",
            "        # Set last_login to something so we can determine if it changes.",
            "        default_login = datetime(2000, 1, 1)",
            "        if settings.USE_TZ:",
            "            default_login = default_login.replace(tzinfo=timezone.utc)",
            "        user.last_login = default_login",
            "        user.save()",
            "",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertNotEqual(default_login, response.context['user'].last_login)",
            "",
            "        user = User.objects.get(username='knownuser')",
            "        user.last_login = default_login",
            "        user.save()",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(default_login, response.context['user'].last_login)",
            "",
            "    def test_header_disappears(self):",
            "        \"\"\"",
            "        Tests that a logged in user is logged out automatically when",
            "        the REMOTE_USER header disappears during the same browser session.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        # Known user authenticates",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        # During the session, the REMOTE_USER header disappears. Should trigger logout.",
            "        response = self.client.get('/remote_user/')",
            "        self.assertEqual(response.context['user'].is_anonymous(), True)",
            "        # verify the remoteuser middleware will not remove a user",
            "        # authenticated via another backend",
            "        User.objects.create_user(username='modeluser', password='foo')",
            "        self.client.login(username='modeluser', password='foo')",
            "        authenticate(username='modeluser', password='foo')",
            "        response = self.client.get('/remote_user/')",
            "        self.assertEqual(response.context['user'].username, 'modeluser')",
            "",
            "    def tearDown(self):",
            "        \"\"\"Restores settings to avoid breaking other tests.\"\"\"",
            "        settings.MIDDLEWARE_CLASSES = self.curr_middleware",
            "        settings.AUTHENTICATION_BACKENDS = self.curr_auth",
            "",
            "",
            "class RemoteUserNoCreateBackend(RemoteUserBackend):",
            "    \"\"\"Backend that doesn't create unknown users.\"\"\"",
            "    create_unknown_user = False",
            "",
            "",
            "@skipIfCustomUser",
            "class RemoteUserNoCreateTest(RemoteUserTest):",
            "    \"\"\"",
            "    Contains the same tests as RemoteUserTest, but using a custom auth backend",
            "    class that doesn't create unknown users.",
            "    \"\"\"",
            "",
            "    backend = 'django.contrib.auth.tests.test_remote_user.RemoteUserNoCreateBackend'",
            "",
            "    def test_unknown_user(self):",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "",
            "class CustomRemoteUserBackend(RemoteUserBackend):",
            "    \"\"\"",
            "    Backend that overrides RemoteUserBackend methods.",
            "    \"\"\"",
            "",
            "    def clean_username(self, username):",
            "        \"\"\"",
            "        Grabs username before the @ character.",
            "        \"\"\"",
            "        return username.split('@')[0]",
            "",
            "    def configure_user(self, user):",
            "        \"\"\"",
            "        Sets user's email address.",
            "        \"\"\"",
            "        user.email = 'user@example.com'",
            "        user.save()",
            "        return user",
            "",
            "",
            "@skipIfCustomUser",
            "class RemoteUserCustomTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserBackend subclass that overrides the clean_username",
            "    and configure_user methods.",
            "    \"\"\"",
            "",
            "    backend = 'django.contrib.auth.tests.test_remote_user.CustomRemoteUserBackend'",
            "    # REMOTE_USER strings with email addresses for the custom backend to",
            "    # clean.",
            "    known_user = 'knownuser@example.com'",
            "    known_user2 = 'knownuser2@example.com'",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        The strings passed in REMOTE_USER should be cleaned and the known users",
            "        should not have been configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_known_user()",
            "        self.assertEqual(User.objects.get(username='knownuser').email, '')",
            "        self.assertEqual(User.objects.get(username='knownuser2').email, '')",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        The unknown user created should be configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_unknown_user()",
            "        newuser = User.objects.get(username='newuser')",
            "        self.assertEqual(newuser.email, 'user@example.com')",
            "",
            "",
            "class CustomHeaderMiddleware(RemoteUserMiddleware):",
            "    \"\"\"",
            "    Middleware that overrides custom HTTP auth user header.",
            "    \"\"\"",
            "    header = 'HTTP_AUTHUSER'",
            "",
            "",
            "@skipIfCustomUser",
            "class CustomHeaderRemoteUserTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserMiddleware subclass with custom HTTP auth user",
            "    header.",
            "    \"\"\"",
            "    middleware = (",
            "        'django.contrib.auth.tests.test_remote_user.CustomHeaderMiddleware'",
            "    )",
            "    header = 'HTTP_AUTHUSER'"
        ],
        "afterPatchFile": [
            "from datetime import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import authenticate",
            "from django.contrib.auth.backends import RemoteUserBackend",
            "from django.contrib.auth.middleware import RemoteUserMiddleware",
            "from django.contrib.auth.models import User",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.test import TestCase, override_settings",
            "from django.utils import timezone",
            "",
            "",
            "@skipIfCustomUser",
            "@override_settings(ROOT_URLCONF='django.contrib.auth.tests.urls')",
            "class RemoteUserTest(TestCase):",
            "",
            "    middleware = 'django.contrib.auth.middleware.RemoteUserMiddleware'",
            "    backend = 'django.contrib.auth.backends.RemoteUserBackend'",
            "    header = 'REMOTE_USER'",
            "",
            "    # Usernames to be passed in REMOTE_USER for the test_known_user test case.",
            "    known_user = 'knownuser'",
            "    known_user2 = 'knownuser2'",
            "",
            "    def setUp(self):",
            "        self.curr_middleware = settings.MIDDLEWARE_CLASSES",
            "        self.curr_auth = settings.AUTHENTICATION_BACKENDS",
            "        settings.MIDDLEWARE_CLASSES += (self.middleware,)",
            "        settings.AUTHENTICATION_BACKENDS += (self.backend,)",
            "",
            "    def test_no_remote_user(self):",
            "        \"\"\"",
            "        Tests requests where no remote user is specified and insures that no",
            "        users get created.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "",
            "        response = self.client.get('/remote_user/')",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', **{self.header: None})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "        response = self.client.get('/remote_user/', **{self.header: ''})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header does not exist",
            "        as a User.",
            "        \"\"\"",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertEqual(response.context['user'].username, 'newuser')",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "        User.objects.get(username='newuser')",
            "",
            "        # Another request with same user should not create any new users.",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertEqual(User.objects.count(), num_users + 1)",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        Tests the case where the username passed in the header is a valid User.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        User.objects.create(username='knownuser2')",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "        # Test that a different user passed in the headers causes the new user",
            "        # to be logged in.",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user2})",
            "        self.assertEqual(response.context['user'].username, 'knownuser2')",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "    def test_last_login(self):",
            "        \"\"\"",
            "        Tests that a user's last_login is set the first time they make a",
            "        request but not updated in subsequent requests with the same session.",
            "        \"\"\"",
            "        user = User.objects.create(username='knownuser')",
            "        # Set last_login to something so we can determine if it changes.",
            "        default_login = datetime(2000, 1, 1)",
            "        if settings.USE_TZ:",
            "            default_login = default_login.replace(tzinfo=timezone.utc)",
            "        user.last_login = default_login",
            "        user.save()",
            "",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertNotEqual(default_login, response.context['user'].last_login)",
            "",
            "        user = User.objects.get(username='knownuser')",
            "        user.last_login = default_login",
            "        user.save()",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(default_login, response.context['user'].last_login)",
            "",
            "    def test_header_disappears(self):",
            "        \"\"\"",
            "        Tests that a logged in user is logged out automatically when",
            "        the REMOTE_USER header disappears during the same browser session.",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        # Known user authenticates",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        # During the session, the REMOTE_USER header disappears. Should trigger logout.",
            "        response = self.client.get('/remote_user/')",
            "        self.assertEqual(response.context['user'].is_anonymous(), True)",
            "        # verify the remoteuser middleware will not remove a user",
            "        # authenticated via another backend",
            "        User.objects.create_user(username='modeluser', password='foo')",
            "        self.client.login(username='modeluser', password='foo')",
            "        authenticate(username='modeluser', password='foo')",
            "        response = self.client.get('/remote_user/')",
            "        self.assertEqual(response.context['user'].username, 'modeluser')",
            "",
            "    def test_user_switch_forces_new_login(self):",
            "        \"\"\"",
            "        Tests that if the username in the header changes between requests",
            "        that the original user is logged out",
            "        \"\"\"",
            "        User.objects.create(username='knownuser')",
            "        # Known user authenticates",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: self.known_user})",
            "        self.assertEqual(response.context['user'].username, 'knownuser')",
            "        # During the session, the REMOTE_USER changes to a different user.",
            "        response = self.client.get('/remote_user/',",
            "                                   **{self.header: \"newnewuser\"})",
            "        # Ensure that the current user is not the prior remote_user",
            "        # In backends that create a new user, username is \"newnewuser\"",
            "        # In backends that do not create new users, it is '' (anonymous user)",
            "        self.assertNotEqual(response.context['user'].username, 'knownuser')",
            "",
            "    def tearDown(self):",
            "        \"\"\"Restores settings to avoid breaking other tests.\"\"\"",
            "        settings.MIDDLEWARE_CLASSES = self.curr_middleware",
            "        settings.AUTHENTICATION_BACKENDS = self.curr_auth",
            "",
            "",
            "class RemoteUserNoCreateBackend(RemoteUserBackend):",
            "    \"\"\"Backend that doesn't create unknown users.\"\"\"",
            "    create_unknown_user = False",
            "",
            "",
            "@skipIfCustomUser",
            "class RemoteUserNoCreateTest(RemoteUserTest):",
            "    \"\"\"",
            "    Contains the same tests as RemoteUserTest, but using a custom auth backend",
            "    class that doesn't create unknown users.",
            "    \"\"\"",
            "",
            "    backend = 'django.contrib.auth.tests.test_remote_user.RemoteUserNoCreateBackend'",
            "",
            "    def test_unknown_user(self):",
            "        num_users = User.objects.count()",
            "        response = self.client.get('/remote_user/', **{self.header: 'newuser'})",
            "        self.assertTrue(response.context['user'].is_anonymous())",
            "        self.assertEqual(User.objects.count(), num_users)",
            "",
            "",
            "class CustomRemoteUserBackend(RemoteUserBackend):",
            "    \"\"\"",
            "    Backend that overrides RemoteUserBackend methods.",
            "    \"\"\"",
            "",
            "    def clean_username(self, username):",
            "        \"\"\"",
            "        Grabs username before the @ character.",
            "        \"\"\"",
            "        return username.split('@')[0]",
            "",
            "    def configure_user(self, user):",
            "        \"\"\"",
            "        Sets user's email address.",
            "        \"\"\"",
            "        user.email = 'user@example.com'",
            "        user.save()",
            "        return user",
            "",
            "",
            "@skipIfCustomUser",
            "class RemoteUserCustomTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserBackend subclass that overrides the clean_username",
            "    and configure_user methods.",
            "    \"\"\"",
            "",
            "    backend = 'django.contrib.auth.tests.test_remote_user.CustomRemoteUserBackend'",
            "    # REMOTE_USER strings with email addresses for the custom backend to",
            "    # clean.",
            "    known_user = 'knownuser@example.com'",
            "    known_user2 = 'knownuser2@example.com'",
            "",
            "    def test_known_user(self):",
            "        \"\"\"",
            "        The strings passed in REMOTE_USER should be cleaned and the known users",
            "        should not have been configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_known_user()",
            "        self.assertEqual(User.objects.get(username='knownuser').email, '')",
            "        self.assertEqual(User.objects.get(username='knownuser2').email, '')",
            "",
            "    def test_unknown_user(self):",
            "        \"\"\"",
            "        The unknown user created should be configured with an email address.",
            "        \"\"\"",
            "        super(RemoteUserCustomTest, self).test_unknown_user()",
            "        newuser = User.objects.get(username='newuser')",
            "        self.assertEqual(newuser.email, 'user@example.com')",
            "",
            "",
            "class CustomHeaderMiddleware(RemoteUserMiddleware):",
            "    \"\"\"",
            "    Middleware that overrides custom HTTP auth user header.",
            "    \"\"\"",
            "    header = 'HTTP_AUTHUSER'",
            "",
            "",
            "@skipIfCustomUser",
            "class CustomHeaderRemoteUserTest(RemoteUserTest):",
            "    \"\"\"",
            "    Tests a custom RemoteUserMiddleware subclass with custom HTTP auth user",
            "    header.",
            "    \"\"\"",
            "    middleware = (",
            "        'django.contrib.auth.tests.test_remote_user.CustomHeaderMiddleware'",
            "    )",
            "    header = 'HTTP_AUTHUSER'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "shuup.front.urls",
            "django.contrib.auth.tests.test_remote_user.RemoteUserTest.self"
        ]
    }
}