{
    "snapcraft/formatting_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     :param str prepend: String to prepend to each path in the definition."
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     :param str separator: String to place between each path in the definition."
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     if not paths:"
            },
            "5": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         raise ValueError(\"Failed to format '${}': no paths supplied\".format(envvar))"
            },
            "6": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return '{envvar}=\"${envvar}{separator}{paths}\"'.format("
            },
            "8": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        envvar=envvar,"
            },
            "9": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        separator=separator,"
            },
            "10": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        paths=combine_paths(paths, prepend, separator),"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    )"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    combined_paths = combine_paths(paths, prepend, separator)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    if separator.isspace():"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        formatted = f'{envvar}=\"${envvar}{separator}{combined_paths}\"'"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    else:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        formatted = f'{envvar}=\"${{{envvar}:+${envvar}{separator}}}{combined_paths}\"'"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    return formatted"
            },
            "20": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " def humanize_list("
            }
        },
        "frontPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2016 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from typing import Iterable, Sized",
            "",
            "",
            "def combine_paths(paths: Iterable[str], prepend: str, separator: str) -> str:",
            "    \"\"\"Combine list of paths into a string.",
            "",
            "    :param list paths: List of paths to stringify.",
            "    :param str prepend: String to prepend to each path in the string.",
            "    :param str separator: String to place between each path in the string.",
            "    \"\"\"",
            "",
            "    paths = [\"{}{}\".format(prepend, p) for p in paths]",
            "    return separator.join(paths)",
            "",
            "",
            "def format_path_variable(",
            "    envvar: str, paths: Iterable[str], prepend: str, separator: str",
            ") -> str:",
            "    \"\"\"Return a path-like environment variable definition that appends.",
            "",
            "    :param str envvar: The environment variable in question.",
            "    :param list paths: The paths to append to the environment variable.",
            "    :param str prepend: String to prepend to each path in the definition.",
            "    :param str separator: String to place between each path in the definition.",
            "    \"\"\"",
            "",
            "    if not paths:",
            "        raise ValueError(\"Failed to format '${}': no paths supplied\".format(envvar))",
            "",
            "    return '{envvar}=\"${envvar}{separator}{paths}\"'.format(",
            "        envvar=envvar,",
            "        separator=separator,",
            "        paths=combine_paths(paths, prepend, separator),",
            "    )",
            "",
            "",
            "def humanize_list(",
            "    items: Iterable[str], conjunction: str, item_format: str = \"{!r}\"",
            ") -> str:",
            "    \"\"\"Format a list into a human-readable string.",
            "",
            "    :param list items: List to humanize.",
            "    :param str conjunction: The conjunction used to join the final element to",
            "                            the rest of the list (e.g. 'and').",
            "    :param str item_format: Format string to use per item.",
            "    \"\"\"",
            "",
            "    if not items:",
            "        return \"\"",
            "",
            "    quoted_items = [item_format.format(item) for item in sorted(items)]",
            "    if len(quoted_items) == 1:",
            "        return quoted_items[0]",
            "",
            "    humanized = \", \".join(quoted_items[:-1])",
            "",
            "    if len(quoted_items) > 2:",
            "        humanized += \",\"",
            "",
            "    return \"{} {} {}\".format(humanized, conjunction, quoted_items[-1])",
            "",
            "",
            "def pluralize(container: Sized, if_one: str, if_multiple: str) -> str:",
            "    if len(container) == 1:",
            "        return if_one",
            "    else:",
            "        return if_multiple"
        ],
        "afterPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2016 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from typing import Iterable, Sized",
            "",
            "",
            "def combine_paths(paths: Iterable[str], prepend: str, separator: str) -> str:",
            "    \"\"\"Combine list of paths into a string.",
            "",
            "    :param list paths: List of paths to stringify.",
            "    :param str prepend: String to prepend to each path in the string.",
            "    :param str separator: String to place between each path in the string.",
            "    \"\"\"",
            "",
            "    paths = [\"{}{}\".format(prepend, p) for p in paths]",
            "    return separator.join(paths)",
            "",
            "",
            "def format_path_variable(",
            "    envvar: str, paths: Iterable[str], prepend: str, separator: str",
            ") -> str:",
            "    \"\"\"Return a path-like environment variable definition that appends.",
            "",
            "    :param str envvar: The environment variable in question.",
            "    :param list paths: The paths to append to the environment variable.",
            "    :param str prepend: String to prepend to each path in the definition.",
            "    :param str separator: String to place between each path in the definition.",
            "    \"\"\"",
            "    if not paths:",
            "        raise ValueError(\"Failed to format '${}': no paths supplied\".format(envvar))",
            "",
            "    combined_paths = combine_paths(paths, prepend, separator)",
            "",
            "    if separator.isspace():",
            "        formatted = f'{envvar}=\"${envvar}{separator}{combined_paths}\"'",
            "    else:",
            "        formatted = f'{envvar}=\"${{{envvar}:+${envvar}{separator}}}{combined_paths}\"'",
            "",
            "    return formatted",
            "",
            "",
            "def humanize_list(",
            "    items: Iterable[str], conjunction: str, item_format: str = \"{!r}\"",
            ") -> str:",
            "    \"\"\"Format a list into a human-readable string.",
            "",
            "    :param list items: List to humanize.",
            "    :param str conjunction: The conjunction used to join the final element to",
            "                            the rest of the list (e.g. 'and').",
            "    :param str item_format: Format string to use per item.",
            "    \"\"\"",
            "",
            "    if not items:",
            "        return \"\"",
            "",
            "    quoted_items = [item_format.format(item) for item in sorted(items)]",
            "    if len(quoted_items) == 1:",
            "        return quoted_items[0]",
            "",
            "    humanized = \", \".join(quoted_items[:-1])",
            "",
            "    if len(quoted_items) > 2:",
            "        humanized += \",\"",
            "",
            "    return \"{} {} {}\".format(humanized, conjunction, quoted_items[-1])",
            "",
            "",
            "def pluralize(container: Sized, if_one: str, if_multiple: str) -> str:",
            "    if len(container) == 1:",
            "        return if_one",
            "    else:",
            "        return if_multiple"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "42": [
                "format_path_variable"
            ],
            "46": [
                "format_path_variable"
            ],
            "47": [
                "format_path_variable"
            ],
            "48": [
                "format_path_variable"
            ],
            "49": [
                "format_path_variable"
            ],
            "50": [
                "format_path_variable"
            ]
        },
        "addLocation": []
    },
    "snapcraft/internal/meta/_snap_packaging.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     packaging.setup_assets()"
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     packaging.generate_hook_wrappers()"
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     packaging.write_snap_directory()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    packaging.warn_ld_library_paths()"
            },
            "4": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     return packaging.meta_dir"
            },
            "6": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "         package_snap_path = os.path.join(self.meta_dir, \"snap.yaml\")"
            },
            "8": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 455,
                "PatchRowcode": "         self._snap_meta.write_snap_yaml(path=package_snap_path)"
            },
            "9": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 456,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+    def warn_ld_library_paths(self) -> None:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+        root_ld_library_path = self._snap_meta.environment.get(\"LD_LIBRARY_PATH\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        # Dictionary of app names with LD_LIBRARY_PATH in their environment."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+        app_environment: Dict[str, str] = dict()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+        for app_name, app_props in self._config_data.get(\"apps\", dict()).items():"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+            with contextlib.suppress(KeyError):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+                app_environment[app_name] = app_props[\"environment\"][\"LD_LIBRARY_PATH\"]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+        if root_ld_library_path is None and not app_environment:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+            return"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+        ld_library_path_empty: Set[str] = set()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        if root_ld_library_path is None and app_environment:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+            ld_library_path_empty = {"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+                name"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+                for name, ld_env in app_environment.items()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+                if \"$LD_LIBRARY_PATH\" in ld_env or \"${LD_LIBRARY_PATH}\" in ld_env"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+            }"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+        elif ("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+            root_ld_library_path is not None"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+            and \"LD_LIBRARY_PATH\" in root_ld_library_path"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+        ):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+            ld_library_path_empty = {\".\"}"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+        _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN = re.compile(\"^:|::|:$\")"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+        for name, ld_env in app_environment.items():"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+            if _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN.findall(ld_env):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+                ld_library_path_empty.add(name)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+        if ("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+            root_ld_library_path is not None"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+            and _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN.findall(root_ld_library_path)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        ):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+            ld_library_path_empty.add(\".\")"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+        if ld_library_path_empty:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+            logger.warning("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+                \"CVE-2020-27348: A potentially empty LD_LIBRARY_PATH has been set for environment \""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+                \"in {}. \""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+                \"The current working directory will be added to the library path if empty. \""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+                \"This can cause unexpected libraries to be loaded.\".format("
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+                    formatting_utils.humanize_list(sorted(ld_library_path_empty), \"and\")"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+                )"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+            )"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "     def setup_assets(self) -> None:"
            },
            "58": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "         # We do _setup_from_setup first since it is legacy and let the"
            },
            "59": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         # declarative items take over."
            },
            "60": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "             # All ELF files have had rpath and interpreter patched. Strip all LD_LIBRARY_PATH variables"
            },
            "61": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 568,
                "PatchRowcode": "             env = [e for e in env if not e.startswith(\"export LD_LIBRARY_PATH=\")]"
            },
            "62": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "         else:"
            },
            "63": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            env.append('export LD_LIBRARY_PATH=\"$SNAP_LIBRARY_PATH:$LD_LIBRARY_PATH\"')"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+            env.append("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+                'export LD_LIBRARY_PATH=\"$SNAP_LIBRARY_PATH${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\"'"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 572,
                "PatchRowcode": "+            )"
            },
            "67": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 573,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "         return \"\\n\".join(env)"
            },
            "69": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 575,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2016-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import contextlib",
            "import copy",
            "import distutils.util",
            "import itertools",
            "import logging",
            "import os",
            "import pathlib",
            "import re",
            "import shutil",
            "import stat",
            "import urllib",
            "from typing import Any, Dict, List, Optional, Set  # noqa",
            "",
            "import requests",
            "",
            "from snapcraft import extractors, file_utils, formatting_utils, shell_utils, yaml_utils",
            "from snapcraft.extractors import _metadata",
            "from snapcraft.internal import common, errors, project_loader, states",
            "from snapcraft.internal.deprecations import handle_deprecation_notice",
            "from snapcraft.internal.meta import _manifest, _version",
            "from snapcraft.internal.meta import errors as meta_errors",
            "from snapcraft.internal.meta.application import ApplicationAdapter",
            "from snapcraft.internal.meta.snap import Snap",
            "from snapcraft.internal.project_loader import _config",
            "from snapcraft.project import _schema",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# From snapd's snap/validate.go, appContentWhitelist, with a slight modification: don't",
            "# allow leading slashes.",
            "_APP_COMMAND_PATTERN = re.compile(\"^[A-Za-z0-9. _#:$-][A-Za-z0-9/. _#:$-]*$\")",
            "",
            "",
            "def create_snap_packaging(project_config: _config.Config) -> str:",
            "    \"\"\"Create snap.yaml and related assets in meta.",
            "",
            "    Create the meta directory and provision it with snap.yaml in the snap dir",
            "    using information from config_data. Also copy in the local 'snap'",
            "    directory, and generate wrappers for hooks coming from parts.",
            "",
            "    :param dict config_data: project values defined in snapcraft.yaml.",
            "    :return: meta_dir.",
            "    \"\"\"",
            "",
            "    # Update config_data using metadata extracted from the project",
            "    extracted_metadata = _update_yaml_with_extracted_metadata(",
            "        project_config.data, project_config.parts, project_config.project.prime_dir",
            "    )",
            "",
            "    # Now that we've updated config_data with random stuff extracted from",
            "    # parts, re-validate it to ensure the it still conforms with the schema.",
            "    validator = _schema.Validator(project_config.data)",
            "    validator.validate(source=\"properties\")",
            "",
            "    # Get the required grade if the global state file exists.",
            "    if os.path.exists(project_config.project._get_global_state_file_path()):",
            "        required_grade = states.GlobalState.load(",
            "            filepath=project_config.project._get_global_state_file_path()",
            "        ).get_required_grade()",
            "    else:",
            "        required_grade = None",
            "",
            "    # Update default values",
            "    _update_yaml_with_defaults(",
            "        project_config.data, project_config.validator.schema, required_grade",
            "    )",
            "",
            "    packaging = _SnapPackaging(project_config, extracted_metadata)",
            "    packaging.cleanup()",
            "    packaging.validate_common_ids()",
            "    packaging.finalize_snap_meta_commands()",
            "    packaging.finalize_snap_meta_command_chains()",
            "    packaging.finalize_snap_meta_version()",
            "    packaging.write_snap_yaml()",
            "    packaging.setup_assets()",
            "    packaging.generate_hook_wrappers()",
            "    packaging.write_snap_directory()",
            "",
            "    return packaging.meta_dir",
            "",
            "",
            "def _update_yaml_with_extracted_metadata(",
            "    config_data: Dict[str, Any],",
            "    parts_config: project_loader.PartsConfig,",
            "    prime_dir: str,",
            ") -> Optional[extractors.ExtractedMetadata]:",
            "    if \"adopt-info\" not in config_data:",
            "        return None",
            "",
            "    part_name = config_data[\"adopt-info\"]",
            "    part = parts_config.get_part(part_name)",
            "    if not part:",
            "        raise meta_errors.AdoptedPartMissingError(part_name)",
            "",
            "    pull_state = part.get_pull_state()",
            "    build_state = part.get_build_state()",
            "    stage_state = part.get_stage_state()",
            "    prime_state = part.get_prime_state()",
            "",
            "    # Get the metadata from the pull step first.",
            "    metadata = pull_state.extracted_metadata[\"metadata\"]",
            "",
            "    # Now update it using the metadata from the build step (i.e. the data",
            "    # from the build step takes precedence over the pull step).",
            "    metadata.update(build_state.extracted_metadata[\"metadata\"])",
            "",
            "    # Now make sure any scriptlet data are taken into account. Later steps",
            "    # take precedence, and scriptlet data (even in earlier steps) take",
            "    # precedence over extracted data.",
            "    metadata.update(pull_state.scriptlet_metadata)",
            "    metadata.update(build_state.scriptlet_metadata)",
            "    metadata.update(stage_state.scriptlet_metadata)",
            "    metadata.update(prime_state.scriptlet_metadata)",
            "",
            "    if not metadata:",
            "        # If we didn't end up with any metadata, let's ensure this part was",
            "        # actually supposed to parse info. If not, let's try to be very",
            "        # clear about what's happening, here. We do this after checking for",
            "        # metadata because metadata could be supplied by scriptlets, too.",
            "        if \"parse-info\" not in config_data[\"parts\"][part_name]:",
            "            raise meta_errors.AdoptedPartNotParsingInfo(part_name)",
            "",
            "    _adopt_info(config_data, metadata, prime_dir)",
            "",
            "    return metadata",
            "",
            "",
            "def _adopt_info(",
            "    config_data: Dict[str, Any],",
            "    extracted_metadata: _metadata.ExtractedMetadata,",
            "    prime_dir: str,",
            "):",
            "    ignored_keys = _adopt_keys(config_data, extracted_metadata, prime_dir)",
            "    if ignored_keys:",
            "        logger.warning(",
            "            \"The {keys} {plural_property} {plural_is} specified in adopted \"",
            "            \"info as well as the YAML: taking the {plural_property} from the \"",
            "            \"YAML\".format(",
            "                keys=formatting_utils.humanize_list(list(ignored_keys), \"and\"),",
            "                plural_property=formatting_utils.pluralize(",
            "                    ignored_keys, \"property\", \"properties\"",
            "                ),",
            "                plural_is=formatting_utils.pluralize(ignored_keys, \"is\", \"are\"),",
            "            )",
            "        )",
            "",
            "",
            "def _adopt_keys(",
            "    config_data: Dict[str, Any],",
            "    extracted_metadata: _metadata.ExtractedMetadata,",
            "    prime_dir: str,",
            ") -> Set[str]:",
            "    ignored_keys = set()",
            "    metadata_dict = extracted_metadata.to_dict()",
            "",
            "    # desktop_file_paths and common_ids are special cases that will be handled",
            "    # after all the top level snapcraft.yaml keys.",
            "    ignore = (\"desktop_file_paths\", \"common_id\")",
            "    overrides = ((k, v) for k, v in metadata_dict.items() if k not in ignore)",
            "",
            "    for key, value in overrides:",
            "        if key in config_data:",
            "            ignored_keys.add(key)",
            "        else:",
            "            if key == \"icon\":",
            "                # Extracted appstream icon paths will be relative to prime.",
            "                icon = pathlib.Path(prime_dir, str(value))",
            "                if not icon.exists():",
            "                    # Cannot find icon, ignore silently.",
            "                    continue",
            "",
            "                if _find_icon_file() is None:",
            "                    # Already have icon file, do not overwrite.",
            "                    continue",
            "",
            "            config_data[key] = value",
            "",
            "    if \"desktop_file_paths\" in metadata_dict and \"common_id\" in metadata_dict:",
            "        app_name = _get_app_name_from_common_id(",
            "            config_data, str(metadata_dict[\"common_id\"])",
            "        )",
            "        if app_name and not _desktop_file_exists(app_name):",
            "            for desktop_file_path in [",
            "                os.path.join(prime_dir, d) for d in metadata_dict[\"desktop_file_paths\"]",
            "            ]:",
            "                if os.path.exists(desktop_file_path):",
            "                    config_data[\"apps\"][app_name][\"desktop\"] = desktop_file_path",
            "                    break",
            "",
            "    return ignored_keys",
            "",
            "",
            "def _find_icon_file() -> Optional[pathlib.Path]:",
            "    \"\"\"Check if the icon is specified as a file in the assets dir.",
            "",
            "    The icon file can be in two directories: 'setup/gui' (deprecated) or",
            "    'snap/gui'. The icon can be named 'icon.png' or 'icon.svg'.",
            "",
            "    :returns: Path of found icon, None otherwise.",
            "    \"\"\"",
            "    for icon_path in (",
            "        pathlib.Path(asset_dir, \"gui\", icon_file)",
            "        for (asset_dir, icon_file) in itertools.product(",
            "            [\"setup\", \"snap\"], [\"icon.png\", \"icon.svg\"]",
            "        )",
            "    ):",
            "        if icon_path.exists():",
            "            return icon_path",
            "",
            "    return None",
            "",
            "",
            "def _get_app_name_from_common_id(",
            "    config_data: Dict[str, Any], common_id: str",
            ") -> Optional[str]:",
            "    \"\"\"Get the snap app name with a common-id.",
            "",
            "    :params dict config_data: Project values defined in snapcraft.yaml.",
            "    :params common_id: The common identifier across multiple packaging",
            "        formats.",
            "    :returns: The name of the snap app with the common-id.",
            "",
            "    \"\"\"",
            "    if \"apps\" in config_data:",
            "        for app in config_data[\"apps\"]:",
            "            if config_data[\"apps\"][app].get(\"common-id\") == common_id:",
            "                return app",
            "    return None",
            "",
            "",
            "def _desktop_file_exists(app_name: str) -> bool:",
            "    \"\"\"Check if the desktop file is specified as a file in the assets dir.",
            "",
            "    The desktop file can be in two directories: 'setup/gui' (deprecated) or",
            "    'snap/gui'.",
            "",
            "    :params app_name: The name of the snap app.",
            "    :returns: True if the desktop file exists, False otherwise.",
            "    \"\"\"",
            "    for desktop_path in (",
            "        os.path.join(asset_dir, \"gui\", \"{}.desktop\".format(app_name))",
            "        for asset_dir in [\"setup\", \"snap\"]",
            "    ):",
            "        if os.path.exists(desktop_path):",
            "            return True",
            "    else:",
            "        return False",
            "",
            "",
            "def _update_yaml_with_defaults(",
            "    config_data, schema, required_grade: Optional[str]",
            ") -> None:",
            "    # Ensure that grade and confinement have their defaults applied, if",
            "    # necessary. Defaults are taken from the schema. Technically these are the",
            "    # only two optional keywords currently WITH defaults, but we don't want to",
            "    # risk setting something that we add later on accident.",
            "    if \"confinement\" not in config_data:",
            "        default = schema[\"confinement\"][\"default\"]",
            "        config_data[\"confinement\"] = default",
            "        logger.warning(",
            "            f\"'confinement' property not specified: defaulting to {default!r}\"",
            "        )",
            "",
            "    # Set the grade (or validate).",
            "    if \"grade\" not in config_data:",
            "        if required_grade is None:",
            "            grade = schema[\"grade\"][\"default\"]",
            "        else:",
            "            grade = required_grade",
            "        logger.warning(f\"'grade' property not specified: defaulting to {grade!r}.\")",
            "        config_data[\"grade\"] = grade",
            "    elif config_data[\"grade\"] == \"stable\" and required_grade == \"devel\":",
            "        raise meta_errors.GradeDevelRequiredError(set_grade=config_data[\"grade\"])",
            "",
            "    # Set default adapter",
            "    app_schema = schema[\"apps\"][\"patternProperties\"][\"^[a-zA-Z0-9](?:-?[a-zA-Z0-9])*$\"][",
            "        \"properties\"",
            "    ]",
            "    default_adapter = app_schema[\"adapter\"][\"default\"]",
            "    for app in config_data.get(\"apps\", {}).values():",
            "        if \"adapter\" not in app and \"command-chain\" not in app:",
            "            app[\"adapter\"] = default_adapter",
            "        elif \"adapter\" not in app and \"command-chain\" in app:",
            "            app[\"adapter\"] = \"full\"",
            "",
            "",
            "def _check_passthrough_duplicates_section(yaml: Dict[str, Any]) -> None:",
            "    # Any value already in the original dictionary must",
            "    # not be specified in passthrough at the same time.",
            "    if \"passthrough\" not in yaml:",
            "        return",
            "",
            "    passthrough = yaml[\"passthrough\"]",
            "    duplicates = list(yaml.keys() & passthrough.keys())",
            "    if duplicates:",
            "        raise meta_errors.AmbiguousPassthroughKeyError(duplicates)",
            "",
            "",
            "def _check_passthrough_duplicates(snap_yaml: Dict[str, Any]) -> None:",
            "    \"\"\"Check passthrough properties for duplicate keys.",
            "",
            "    Passthrough options may override assumed/extracted configuration,",
            "    so this check must be done on the original YAML.\"\"\"",
            "",
            "    for section in [\"apps\", \"hooks\"]:",
            "        if section not in snap_yaml:",
            "            continue",
            "",
            "        for value in snap_yaml[section].values():",
            "            _check_passthrough_duplicates_section(value)",
            "",
            "    _check_passthrough_duplicates_section(snap_yaml)",
            "",
            "",
            "class _SnapPackaging:",
            "    def __init__(",
            "        self,",
            "        project_config: _config.Config,",
            "        extracted_metadata: Optional[_metadata.ExtractedMetadata],",
            "    ) -> None:",
            "        self._project_config = project_config",
            "        self._extracted_metadata = extracted_metadata",
            "        self._snapcraft_yaml_path = project_config.project.info.snapcraft_yaml_file_path",
            "        self._prime_dir = project_config.project.prime_dir",
            "        self._parts_dir = project_config.project.parts_dir",
            "",
            "        self._arch_triplet = project_config.project.arch_triplet",
            "        self.meta_dir = os.path.join(self._prime_dir, \"meta\")",
            "        self.meta_gui_dir = os.path.join(self.meta_dir, \"gui\")",
            "        self._config_data = project_config.data.copy()",
            "        self._original_snapcraft_yaml = project_config.project.info.get_raw_snapcraft()",
            "",
            "        self._install_path_pattern = re.compile(",
            "            r\"{}/[a-z0-9][a-z0-9+-]*/install\".format(re.escape(self._parts_dir))",
            "        )",
            "",
            "        os.makedirs(self.meta_dir, exist_ok=True)",
            "",
            "        # TODO: create_snap_packaging managles config data, so we create",
            "        # a new private instance of snap_meta.  Longer term, this needs",
            "        # to converge with project's snap_meta.",
            "        self._snap_meta = Snap.from_dict(project_config.data)",
            "",
            "    def cleanup(self):",
            "        if os.path.exists(self.meta_gui_dir):",
            "            for f in os.listdir(self.meta_gui_dir):",
            "                if os.path.splitext(f)[1] == \".desktop\":",
            "                    os.remove(os.path.join(self.meta_gui_dir, f))",
            "",
            "    def _finalize_icon(self) -> Optional[pathlib.Path]:",
            "        \"\"\"Ensure sure icon is properly configured and installed.",
            "",
            "        Fetch from a remote URL, if required, and place in the meta/gui",
            "        directory.",
            "        \"\"\"",
            "",
            "        # Nothing to do if no icon is configured, search for existing icon.",
            "        icon: Optional[str] = self._config_data.get(\"icon\")",
            "        if icon is None and self._extracted_metadata is not None:",
            "            icon = self._extracted_metadata.get_icon()",
            "",
            "        if icon is None:",
            "            return _find_icon_file()",
            "",
            "        # Extracted appstream icon paths will either:",
            "        # (1) point to a file relative to prime",
            "        # (2) point to a remote http(s) url",
            "        #",
            "        # The 'icon' specified in the snapcraft.yaml has the same",
            "        # constraint as (2) and would have already been validated",
            "        # as existing by the schema.  So we can treat it the same",
            "        # at this point, regardless of the source of the icon.",
            "        parsed_url = urllib.parse.urlparse(icon)",
            "        parsed_path = pathlib.Path(parsed_url.path)",
            "        icon_ext = parsed_path.suffix[1:]",
            "        target_icon_path = pathlib.Path(self.meta_gui_dir, f\"icon.{icon_ext}\")",
            "",
            "        target_icon_path.parent.mkdir(parents=True, exist_ok=True)",
            "        if parsed_url.scheme in [\"http\", \"https\"]:",
            "            # Remote - fetch URL and write to target.",
            "            logger.info(f\"Fetching icon from {icon!r}.\")",
            "            icon_data = requests.get(icon).content",
            "            target_icon_path.write_bytes(icon_data)",
            "        elif parsed_url.scheme == \"\":",
            "            source_path = pathlib.Path(self._prime_dir, parsed_path)",
            "            if source_path.exists():",
            "                # Local - the path should be relative to prime, copy to target.",
            "                file_utils.link_or_copy(str(parsed_path), str(target_icon_path))",
            "            elif parsed_path.exists():",
            "                # Fall back to checking relative to project.",
            "                file_utils.link_or_copy(str(parsed_path), str(target_icon_path))",
            "            else:",
            "                # No icon found, fall back to searching for existing icon.",
            "                return _find_icon_file()",
            "        else:",
            "            raise RuntimeError(f\"Unexpected icon path: {parsed_url!r}\")",
            "",
            "        return target_icon_path",
            "",
            "    def finalize_snap_meta_commands(self) -> None:",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            # Prime commands only if adapter != \"none\",",
            "            # otherwise leave as-is.",
            "            if app.adapter != ApplicationAdapter.NONE:",
            "                app.prime_commands(",
            "                    base=self._project_config.project.info.base,",
            "                    prime_dir=self._prime_dir,",
            "                )",
            "",
            "    def finalize_snap_meta_command_chains(self) -> None:",
            "        snapcraft_runner = self._generate_snapcraft_runner()",
            "        if snapcraft_runner is None:",
            "            return",
            "",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            # Add runner to command chain if adapter is not \"none\".",
            "            if app.adapter != ApplicationAdapter.NONE:",
            "                app.command_chain.insert(0, snapcraft_runner)",
            "",
            "    def finalize_snap_meta_version(self) -> None:",
            "        # Reparse the version, the order should stick.",
            "        version = self._config_data[\"version\"]",
            "        version_script = self._config_data.get(\"version-script\")",
            "",
            "        if version_script:",
            "            # Deprecation warning for use of version-script.",
            "            handle_deprecation_notice(\"dn10\")",
            "",
            "        self._snap_meta.version = _version.get_version(version, version_script)",
            "",
            "    def write_snap_yaml(self) -> None:",
            "        # Ensure snap meta is valid before writing.",
            "        self._snap_meta.validate()",
            "        _check_passthrough_duplicates(self._original_snapcraft_yaml)",
            "",
            "        package_snap_path = os.path.join(self.meta_dir, \"snap.yaml\")",
            "        self._snap_meta.write_snap_yaml(path=package_snap_path)",
            "",
            "    def setup_assets(self) -> None:",
            "        # We do _setup_from_setup first since it is legacy and let the",
            "        # declarative items take over.",
            "        self._setup_gui()",
            "",
            "        icon_path = self._finalize_icon()",
            "        if icon_path is not None:",
            "            if str(icon_path).startswith(self._prime_dir):",
            "                icon_path = icon_path.relative_to(self._prime_dir)",
            "            relative_icon_path: Optional[str] = str(icon_path)",
            "        else:",
            "            relative_icon_path = None",
            "",
            "        snap_name = self._project_config.project.info.name",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            app.write_command_wrappers(prime_dir=self._prime_dir)",
            "            app.write_application_desktop_file(",
            "                snap_name=snap_name,",
            "                prime_dir=self._prime_dir,",
            "                gui_dir=self.meta_gui_dir,",
            "                icon_path=relative_icon_path,",
            "            )",
            "            app.validate_command_chain_executables(self._prime_dir)",
            "",
            "        if self._config_data.get(\"type\", \"\") == \"gadget\":",
            "            if not os.path.exists(\"gadget.yaml\"):",
            "                raise errors.MissingGadgetError()",
            "            file_utils.link_or_copy(",
            "                \"gadget.yaml\", os.path.join(self.meta_dir, \"gadget.yaml\")",
            "            )",
            "",
            "    def _assemble_runtime_environment(self) -> str:",
            "        # Classic confinement or building on a host that does not match the target base",
            "        # means we cannot setup an environment that will work.",
            "        if self._config_data[\"confinement\"] == \"classic\":",
            "            # Temporary workaround for snapd bug not expanding PATH:",
            "            # We generate an empty runner which addresses the issue.",
            "            # https://bugs.launchpad.net/snapd/+bug/1860369",
            "            return \"\"",
            "",
            "        env = list()",
            "        if self._project_config.project._snap_meta.base in (\"core\", \"core16\", \"core18\"):",
            "            common.env = self._project_config.snap_env()",
            "            assembled_env = common.assemble_env()",
            "            common.reset_env()",
            "",
            "            assembled_env = assembled_env.replace(self._prime_dir, \"$SNAP\")",
            "            env.append(self._install_path_pattern.sub(\"$SNAP\", assembled_env))",
            "        else:",
            "            # TODO use something local to the meta package and",
            "            # only add paths for directory items that actually exist.",
            "            runtime_env = project_loader.runtime_env(",
            "                self._prime_dir, self._project_config.project.arch_triplet",
            "            )",
            "            for e in runtime_env:",
            "                env.append(re.sub(self._prime_dir, \"$SNAP\", e))",
            "",
            "        if all(",
            "            [",
            "                part._build_attributes.enable_patchelf()",
            "                for part in self._project_config.all_parts",
            "            ]",
            "        ):",
            "            # All ELF files have had rpath and interpreter patched. Strip all LD_LIBRARY_PATH variables",
            "            env = [e for e in env if not e.startswith(\"export LD_LIBRARY_PATH=\")]",
            "        else:",
            "            env.append('export LD_LIBRARY_PATH=\"$SNAP_LIBRARY_PATH:$LD_LIBRARY_PATH\"')",
            "",
            "        return \"\\n\".join(env)",
            "",
            "    def _generate_snapcraft_runner(self) -> Optional[str]:",
            "        \"\"\"Create runner if required.",
            "",
            "        Return path relative to prime directory, if created.\"\"\"",
            "",
            "        # If there are no apps, or type is snapd, no need to create a runner.",
            "        if not self._snap_meta.apps or self._config_data.get(\"type\") == \"snapd\":",
            "            return None",
            "",
            "        # No more command-chain for core20 and classic confinement.",
            "        # This was a workaround for LP: #1860369.",
            "        if (",
            "            self._snap_meta.base not in (\"core\", \"core16\", \"core18\", None)",
            "            and self._snap_meta.confinement == \"classic\"",
            "        ):",
            "            return None",
            "",
            "        assembled_env = self._assemble_runtime_environment()",
            "",
            "        meta_runner = os.path.join(",
            "            self._prime_dir, \"snap\", \"command-chain\", \"snapcraft-runner\"",
            "        )",
            "",
            "        os.makedirs(os.path.dirname(meta_runner), exist_ok=True)",
            "        with open(meta_runner, \"w\") as f:",
            "            print(\"#!/bin/sh\", file=f)",
            "            print(assembled_env, file=f)",
            "            print('exec \"$@\"', file=f)",
            "        os.chmod(meta_runner, 0o755)",
            "",
            "        return os.path.relpath(meta_runner, self._prime_dir)",
            "",
            "    def _record_manifest_and_source_snapcraft_yaml(self):",
            "        prime_snap_dir = os.path.join(self._prime_dir, \"snap\")",
            "        recorded_snapcraft_yaml_path = os.path.join(prime_snap_dir, \"snapcraft.yaml\")",
            "        if os.path.isfile(recorded_snapcraft_yaml_path):",
            "            os.unlink(recorded_snapcraft_yaml_path)",
            "        manifest_file_path = os.path.join(prime_snap_dir, \"manifest.yaml\")",
            "        if os.path.isfile(manifest_file_path):",
            "            os.unlink(manifest_file_path)",
            "",
            "        # FIXME hide this functionality behind a feature flag for now",
            "        if distutils.util.strtobool(os.environ.get(\"SNAPCRAFT_BUILD_INFO\", \"n\")):",
            "            os.makedirs(prime_snap_dir, exist_ok=True)",
            "            shutil.copy2(self._snapcraft_yaml_path, recorded_snapcraft_yaml_path)",
            "            annotated_snapcraft = _manifest.annotate_snapcraft(",
            "                self._project_config.project, copy.deepcopy(self._config_data)",
            "            )",
            "            with open(manifest_file_path, \"w\") as manifest_file:",
            "                yaml_utils.dump(annotated_snapcraft, stream=manifest_file)",
            "",
            "    def write_snap_directory(self) -> None:",
            "        \"\"\"Record manifest and copy assets found under $SNAPCRAFT_PROJECT_ROOT/snap.",
            "",
            "        These assets have priority over any code generated assets and include:",
            "        - hooks",
            "        - gui",
            "        \"\"\"",
            "        snap_assets_dir = self._project_config.project._get_snapcraft_assets_dir()",
            "        prime_snap_dir = os.path.join(self._prime_dir, \"snap\")",
            "",
            "        snap_dir_iter = itertools.product([prime_snap_dir], [\"hooks\"])",
            "        meta_dir_iter = itertools.product([self.meta_dir], [\"hooks\", \"gui\"])",
            "",
            "        for origin in itertools.chain(snap_dir_iter, meta_dir_iter):",
            "            src_dir = os.path.join(snap_assets_dir, origin[1])",
            "            dst_dir = os.path.join(origin[0], origin[1])",
            "            if os.path.isdir(src_dir):",
            "                os.makedirs(dst_dir, exist_ok=True)",
            "                for asset in os.listdir(src_dir):",
            "                    source = os.path.join(src_dir, asset)",
            "                    destination = os.path.join(dst_dir, asset)",
            "",
            "                    with contextlib.suppress(FileNotFoundError):",
            "                        os.remove(destination)",
            "",
            "                    file_utils.link_or_copy(source, destination, follow_symlinks=True)",
            "",
            "                    # Ensure that the hook is executable in meta/hooks, this is a moot",
            "                    # point considering the prior link_or_copy call, but is technically",
            "                    # correct and allows for this operation to take place only once.",
            "                    if origin[0] == self.meta_dir and origin[1] == \"hooks\":",
            "                        _prepare_hook(destination)",
            "",
            "        self._record_manifest_and_source_snapcraft_yaml()",
            "",
            "    def generate_hook_wrappers(self) -> None:",
            "        \"\"\"Setup hooks in meta.",
            "",
            "        Hooks generated with this criteria:",
            "",
            "        - A stub for every hook definition that contains a command-chain entry",
            "          to ensure the command-chain for a defined hook runs. A command-chain",
            "          with no hook can occur when using extensions.",
            "        - A wrapper from a hook created from hooks found under",
            "          self._prime_dir/snap/hooks, these hooks are usually generated by parts.",
            "        \"\"\"",
            "        hooks_dir = os.path.join(self._prime_dir, \"meta\", \"hooks\")",
            "        snap_hooks_dir = os.path.join(self._prime_dir, \"snap\", \"hooks\")",
            "        hooks_in_snap_dir = (",
            "            os.listdir(snap_hooks_dir) if os.path.isdir(snap_hooks_dir) else []",
            "        )",
            "        hooks_with_command_chain = [",
            "            hook",
            "            for hook in self._snap_meta.hooks.values()",
            "            if hook.command_chain is not None",
            "            and hook.hook_name not in hooks_in_snap_dir",
            "        ]",
            "",
            "        if hooks_with_command_chain or hooks_in_snap_dir:",
            "            os.makedirs(hooks_dir, exist_ok=True)",
            "",
            "        # Create stub hooks as necessary.",
            "        for hook in hooks_with_command_chain:",
            "            hook_path = pathlib.Path(hooks_dir) / hook.hook_name",
            "            if not hook_path.exists():",
            "                hook_path.write_text(\"#!/bin/sh\\n\")",
            "                hook_path.chmod(0o755)",
            "",
            "        # Write wrapper hooks as necessary.",
            "        for hook_name in hooks_in_snap_dir:",
            "            file_path = os.path.join(snap_hooks_dir, hook_name)",
            "            # Make sure the hook is executable",
            "            _prepare_hook(file_path)",
            "",
            "            hook_exec = os.path.join(\"$SNAP\", \"snap\", \"hooks\", hook_name)",
            "            hook_path = pathlib.Path(hooks_dir) / hook_name",
            "            with contextlib.suppress(FileNotFoundError):",
            "                hook_path.unlink()",
            "",
            "            self._write_wrap_exe(hook_exec, str(hook_path))",
            "",
            "    def _setup_gui(self):",
            "        # Handles the setup directory which only contains gui assets.",
            "        setup_dir = \"setup\"",
            "        if not os.path.exists(setup_dir):",
            "            return",
            "",
            "        handle_deprecation_notice(\"dn3\")",
            "",
            "        gui_src = os.path.join(setup_dir, \"gui\")",
            "        if os.path.exists(gui_src):",
            "            for f in os.listdir(gui_src):",
            "                if not os.path.exists(self.meta_gui_dir):",
            "                    os.mkdir(self.meta_gui_dir)",
            "                shutil.copy2(os.path.join(gui_src, f), self.meta_gui_dir)",
            "",
            "    def _write_wrap_exe(self, wrapexec, wrappath, shebang=None, args=None, cwd=None):",
            "        assembled_env = self._assemble_runtime_environment()",
            "",
            "        if args:",
            "            quoted_args = ['\"{}\"'.format(arg) for arg in args]",
            "        else:",
            "            quoted_args = []",
            "        args = \" \".join(quoted_args) + ' \"$@\"' if args else '\"$@\"'",
            "        cwd = \"cd {}\".format(cwd) if cwd else \"\"",
            "",
            "        executable = '\"{}\"'.format(wrapexec)",
            "",
            "        if shebang:",
            "            if shebang.startswith(\"/usr/bin/env \"):",
            "                shebang = shell_utils.which(shebang.split()[1])",
            "            new_shebang = self._install_path_pattern.sub(\"$SNAP\", shebang)",
            "            new_shebang = re.sub(self._prime_dir, \"$SNAP\", new_shebang)",
            "            if new_shebang != shebang:",
            "                # If the shebang was pointing to and executable within the",
            "                # local 'parts' dir, have the wrapper script execute it",
            "                # directly, since we can't use $SNAP in the shebang itself.",
            "                executable = '\"{}\" \"{}\"'.format(new_shebang, wrapexec)",
            "",
            "        with open(wrappath, \"w+\") as f:",
            "            print(\"#!/bin/sh\", file=f)",
            "            if cwd:",
            "                print(\"{}\".format(cwd), file=f)",
            "            print(assembled_env, file=f)",
            "            print(\"exec {} {}\".format(executable, args), file=f)",
            "",
            "        os.chmod(wrappath, 0o755)",
            "",
            "    def validate_common_ids(self) -> None:",
            "        if (",
            "            not self._extracted_metadata",
            "            or not self._extracted_metadata.common_id_list",
            "            or \"apps\" not in self._config_data",
            "        ):",
            "            return",
            "",
            "        common_id_list = self._extracted_metadata.common_id_list",
            "        for app in self._config_data[\"apps\"]:",
            "            app_common_id = self._config_data[\"apps\"][app].get(\"common-id\")",
            "            if app_common_id not in common_id_list:",
            "                logger.warning(",
            "                    \"Common ID {common_id!r} specified in app {app!r} is \"",
            "                    \"not used in any metadata file.\".format(",
            "                        common_id=app_common_id, app=app",
            "                    )",
            "                )",
            "",
            "",
            "def _prepare_hook(hook_path):",
            "    # Ensure hook is executable",
            "    if not os.stat(hook_path).st_mode & stat.S_IEXEC:",
            "        os.chmod(hook_path, 0o755)"
        ],
        "afterPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2016-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import contextlib",
            "import copy",
            "import distutils.util",
            "import itertools",
            "import logging",
            "import os",
            "import pathlib",
            "import re",
            "import shutil",
            "import stat",
            "import urllib",
            "from typing import Any, Dict, List, Optional, Set  # noqa",
            "",
            "import requests",
            "",
            "from snapcraft import extractors, file_utils, formatting_utils, shell_utils, yaml_utils",
            "from snapcraft.extractors import _metadata",
            "from snapcraft.internal import common, errors, project_loader, states",
            "from snapcraft.internal.deprecations import handle_deprecation_notice",
            "from snapcraft.internal.meta import _manifest, _version",
            "from snapcraft.internal.meta import errors as meta_errors",
            "from snapcraft.internal.meta.application import ApplicationAdapter",
            "from snapcraft.internal.meta.snap import Snap",
            "from snapcraft.internal.project_loader import _config",
            "from snapcraft.project import _schema",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "# From snapd's snap/validate.go, appContentWhitelist, with a slight modification: don't",
            "# allow leading slashes.",
            "_APP_COMMAND_PATTERN = re.compile(\"^[A-Za-z0-9. _#:$-][A-Za-z0-9/. _#:$-]*$\")",
            "",
            "",
            "def create_snap_packaging(project_config: _config.Config) -> str:",
            "    \"\"\"Create snap.yaml and related assets in meta.",
            "",
            "    Create the meta directory and provision it with snap.yaml in the snap dir",
            "    using information from config_data. Also copy in the local 'snap'",
            "    directory, and generate wrappers for hooks coming from parts.",
            "",
            "    :param dict config_data: project values defined in snapcraft.yaml.",
            "    :return: meta_dir.",
            "    \"\"\"",
            "",
            "    # Update config_data using metadata extracted from the project",
            "    extracted_metadata = _update_yaml_with_extracted_metadata(",
            "        project_config.data, project_config.parts, project_config.project.prime_dir",
            "    )",
            "",
            "    # Now that we've updated config_data with random stuff extracted from",
            "    # parts, re-validate it to ensure the it still conforms with the schema.",
            "    validator = _schema.Validator(project_config.data)",
            "    validator.validate(source=\"properties\")",
            "",
            "    # Get the required grade if the global state file exists.",
            "    if os.path.exists(project_config.project._get_global_state_file_path()):",
            "        required_grade = states.GlobalState.load(",
            "            filepath=project_config.project._get_global_state_file_path()",
            "        ).get_required_grade()",
            "    else:",
            "        required_grade = None",
            "",
            "    # Update default values",
            "    _update_yaml_with_defaults(",
            "        project_config.data, project_config.validator.schema, required_grade",
            "    )",
            "",
            "    packaging = _SnapPackaging(project_config, extracted_metadata)",
            "    packaging.cleanup()",
            "    packaging.validate_common_ids()",
            "    packaging.finalize_snap_meta_commands()",
            "    packaging.finalize_snap_meta_command_chains()",
            "    packaging.finalize_snap_meta_version()",
            "    packaging.write_snap_yaml()",
            "    packaging.setup_assets()",
            "    packaging.generate_hook_wrappers()",
            "    packaging.write_snap_directory()",
            "    packaging.warn_ld_library_paths()",
            "",
            "    return packaging.meta_dir",
            "",
            "",
            "def _update_yaml_with_extracted_metadata(",
            "    config_data: Dict[str, Any],",
            "    parts_config: project_loader.PartsConfig,",
            "    prime_dir: str,",
            ") -> Optional[extractors.ExtractedMetadata]:",
            "    if \"adopt-info\" not in config_data:",
            "        return None",
            "",
            "    part_name = config_data[\"adopt-info\"]",
            "    part = parts_config.get_part(part_name)",
            "    if not part:",
            "        raise meta_errors.AdoptedPartMissingError(part_name)",
            "",
            "    pull_state = part.get_pull_state()",
            "    build_state = part.get_build_state()",
            "    stage_state = part.get_stage_state()",
            "    prime_state = part.get_prime_state()",
            "",
            "    # Get the metadata from the pull step first.",
            "    metadata = pull_state.extracted_metadata[\"metadata\"]",
            "",
            "    # Now update it using the metadata from the build step (i.e. the data",
            "    # from the build step takes precedence over the pull step).",
            "    metadata.update(build_state.extracted_metadata[\"metadata\"])",
            "",
            "    # Now make sure any scriptlet data are taken into account. Later steps",
            "    # take precedence, and scriptlet data (even in earlier steps) take",
            "    # precedence over extracted data.",
            "    metadata.update(pull_state.scriptlet_metadata)",
            "    metadata.update(build_state.scriptlet_metadata)",
            "    metadata.update(stage_state.scriptlet_metadata)",
            "    metadata.update(prime_state.scriptlet_metadata)",
            "",
            "    if not metadata:",
            "        # If we didn't end up with any metadata, let's ensure this part was",
            "        # actually supposed to parse info. If not, let's try to be very",
            "        # clear about what's happening, here. We do this after checking for",
            "        # metadata because metadata could be supplied by scriptlets, too.",
            "        if \"parse-info\" not in config_data[\"parts\"][part_name]:",
            "            raise meta_errors.AdoptedPartNotParsingInfo(part_name)",
            "",
            "    _adopt_info(config_data, metadata, prime_dir)",
            "",
            "    return metadata",
            "",
            "",
            "def _adopt_info(",
            "    config_data: Dict[str, Any],",
            "    extracted_metadata: _metadata.ExtractedMetadata,",
            "    prime_dir: str,",
            "):",
            "    ignored_keys = _adopt_keys(config_data, extracted_metadata, prime_dir)",
            "    if ignored_keys:",
            "        logger.warning(",
            "            \"The {keys} {plural_property} {plural_is} specified in adopted \"",
            "            \"info as well as the YAML: taking the {plural_property} from the \"",
            "            \"YAML\".format(",
            "                keys=formatting_utils.humanize_list(list(ignored_keys), \"and\"),",
            "                plural_property=formatting_utils.pluralize(",
            "                    ignored_keys, \"property\", \"properties\"",
            "                ),",
            "                plural_is=formatting_utils.pluralize(ignored_keys, \"is\", \"are\"),",
            "            )",
            "        )",
            "",
            "",
            "def _adopt_keys(",
            "    config_data: Dict[str, Any],",
            "    extracted_metadata: _metadata.ExtractedMetadata,",
            "    prime_dir: str,",
            ") -> Set[str]:",
            "    ignored_keys = set()",
            "    metadata_dict = extracted_metadata.to_dict()",
            "",
            "    # desktop_file_paths and common_ids are special cases that will be handled",
            "    # after all the top level snapcraft.yaml keys.",
            "    ignore = (\"desktop_file_paths\", \"common_id\")",
            "    overrides = ((k, v) for k, v in metadata_dict.items() if k not in ignore)",
            "",
            "    for key, value in overrides:",
            "        if key in config_data:",
            "            ignored_keys.add(key)",
            "        else:",
            "            if key == \"icon\":",
            "                # Extracted appstream icon paths will be relative to prime.",
            "                icon = pathlib.Path(prime_dir, str(value))",
            "                if not icon.exists():",
            "                    # Cannot find icon, ignore silently.",
            "                    continue",
            "",
            "                if _find_icon_file() is None:",
            "                    # Already have icon file, do not overwrite.",
            "                    continue",
            "",
            "            config_data[key] = value",
            "",
            "    if \"desktop_file_paths\" in metadata_dict and \"common_id\" in metadata_dict:",
            "        app_name = _get_app_name_from_common_id(",
            "            config_data, str(metadata_dict[\"common_id\"])",
            "        )",
            "        if app_name and not _desktop_file_exists(app_name):",
            "            for desktop_file_path in [",
            "                os.path.join(prime_dir, d) for d in metadata_dict[\"desktop_file_paths\"]",
            "            ]:",
            "                if os.path.exists(desktop_file_path):",
            "                    config_data[\"apps\"][app_name][\"desktop\"] = desktop_file_path",
            "                    break",
            "",
            "    return ignored_keys",
            "",
            "",
            "def _find_icon_file() -> Optional[pathlib.Path]:",
            "    \"\"\"Check if the icon is specified as a file in the assets dir.",
            "",
            "    The icon file can be in two directories: 'setup/gui' (deprecated) or",
            "    'snap/gui'. The icon can be named 'icon.png' or 'icon.svg'.",
            "",
            "    :returns: Path of found icon, None otherwise.",
            "    \"\"\"",
            "    for icon_path in (",
            "        pathlib.Path(asset_dir, \"gui\", icon_file)",
            "        for (asset_dir, icon_file) in itertools.product(",
            "            [\"setup\", \"snap\"], [\"icon.png\", \"icon.svg\"]",
            "        )",
            "    ):",
            "        if icon_path.exists():",
            "            return icon_path",
            "",
            "    return None",
            "",
            "",
            "def _get_app_name_from_common_id(",
            "    config_data: Dict[str, Any], common_id: str",
            ") -> Optional[str]:",
            "    \"\"\"Get the snap app name with a common-id.",
            "",
            "    :params dict config_data: Project values defined in snapcraft.yaml.",
            "    :params common_id: The common identifier across multiple packaging",
            "        formats.",
            "    :returns: The name of the snap app with the common-id.",
            "",
            "    \"\"\"",
            "    if \"apps\" in config_data:",
            "        for app in config_data[\"apps\"]:",
            "            if config_data[\"apps\"][app].get(\"common-id\") == common_id:",
            "                return app",
            "    return None",
            "",
            "",
            "def _desktop_file_exists(app_name: str) -> bool:",
            "    \"\"\"Check if the desktop file is specified as a file in the assets dir.",
            "",
            "    The desktop file can be in two directories: 'setup/gui' (deprecated) or",
            "    'snap/gui'.",
            "",
            "    :params app_name: The name of the snap app.",
            "    :returns: True if the desktop file exists, False otherwise.",
            "    \"\"\"",
            "    for desktop_path in (",
            "        os.path.join(asset_dir, \"gui\", \"{}.desktop\".format(app_name))",
            "        for asset_dir in [\"setup\", \"snap\"]",
            "    ):",
            "        if os.path.exists(desktop_path):",
            "            return True",
            "    else:",
            "        return False",
            "",
            "",
            "def _update_yaml_with_defaults(",
            "    config_data, schema, required_grade: Optional[str]",
            ") -> None:",
            "    # Ensure that grade and confinement have their defaults applied, if",
            "    # necessary. Defaults are taken from the schema. Technically these are the",
            "    # only two optional keywords currently WITH defaults, but we don't want to",
            "    # risk setting something that we add later on accident.",
            "    if \"confinement\" not in config_data:",
            "        default = schema[\"confinement\"][\"default\"]",
            "        config_data[\"confinement\"] = default",
            "        logger.warning(",
            "            f\"'confinement' property not specified: defaulting to {default!r}\"",
            "        )",
            "",
            "    # Set the grade (or validate).",
            "    if \"grade\" not in config_data:",
            "        if required_grade is None:",
            "            grade = schema[\"grade\"][\"default\"]",
            "        else:",
            "            grade = required_grade",
            "        logger.warning(f\"'grade' property not specified: defaulting to {grade!r}.\")",
            "        config_data[\"grade\"] = grade",
            "    elif config_data[\"grade\"] == \"stable\" and required_grade == \"devel\":",
            "        raise meta_errors.GradeDevelRequiredError(set_grade=config_data[\"grade\"])",
            "",
            "    # Set default adapter",
            "    app_schema = schema[\"apps\"][\"patternProperties\"][\"^[a-zA-Z0-9](?:-?[a-zA-Z0-9])*$\"][",
            "        \"properties\"",
            "    ]",
            "    default_adapter = app_schema[\"adapter\"][\"default\"]",
            "    for app in config_data.get(\"apps\", {}).values():",
            "        if \"adapter\" not in app and \"command-chain\" not in app:",
            "            app[\"adapter\"] = default_adapter",
            "        elif \"adapter\" not in app and \"command-chain\" in app:",
            "            app[\"adapter\"] = \"full\"",
            "",
            "",
            "def _check_passthrough_duplicates_section(yaml: Dict[str, Any]) -> None:",
            "    # Any value already in the original dictionary must",
            "    # not be specified in passthrough at the same time.",
            "    if \"passthrough\" not in yaml:",
            "        return",
            "",
            "    passthrough = yaml[\"passthrough\"]",
            "    duplicates = list(yaml.keys() & passthrough.keys())",
            "    if duplicates:",
            "        raise meta_errors.AmbiguousPassthroughKeyError(duplicates)",
            "",
            "",
            "def _check_passthrough_duplicates(snap_yaml: Dict[str, Any]) -> None:",
            "    \"\"\"Check passthrough properties for duplicate keys.",
            "",
            "    Passthrough options may override assumed/extracted configuration,",
            "    so this check must be done on the original YAML.\"\"\"",
            "",
            "    for section in [\"apps\", \"hooks\"]:",
            "        if section not in snap_yaml:",
            "            continue",
            "",
            "        for value in snap_yaml[section].values():",
            "            _check_passthrough_duplicates_section(value)",
            "",
            "    _check_passthrough_duplicates_section(snap_yaml)",
            "",
            "",
            "class _SnapPackaging:",
            "    def __init__(",
            "        self,",
            "        project_config: _config.Config,",
            "        extracted_metadata: Optional[_metadata.ExtractedMetadata],",
            "    ) -> None:",
            "        self._project_config = project_config",
            "        self._extracted_metadata = extracted_metadata",
            "        self._snapcraft_yaml_path = project_config.project.info.snapcraft_yaml_file_path",
            "        self._prime_dir = project_config.project.prime_dir",
            "        self._parts_dir = project_config.project.parts_dir",
            "",
            "        self._arch_triplet = project_config.project.arch_triplet",
            "        self.meta_dir = os.path.join(self._prime_dir, \"meta\")",
            "        self.meta_gui_dir = os.path.join(self.meta_dir, \"gui\")",
            "        self._config_data = project_config.data.copy()",
            "        self._original_snapcraft_yaml = project_config.project.info.get_raw_snapcraft()",
            "",
            "        self._install_path_pattern = re.compile(",
            "            r\"{}/[a-z0-9][a-z0-9+-]*/install\".format(re.escape(self._parts_dir))",
            "        )",
            "",
            "        os.makedirs(self.meta_dir, exist_ok=True)",
            "",
            "        # TODO: create_snap_packaging managles config data, so we create",
            "        # a new private instance of snap_meta.  Longer term, this needs",
            "        # to converge with project's snap_meta.",
            "        self._snap_meta = Snap.from_dict(project_config.data)",
            "",
            "    def cleanup(self):",
            "        if os.path.exists(self.meta_gui_dir):",
            "            for f in os.listdir(self.meta_gui_dir):",
            "                if os.path.splitext(f)[1] == \".desktop\":",
            "                    os.remove(os.path.join(self.meta_gui_dir, f))",
            "",
            "    def _finalize_icon(self) -> Optional[pathlib.Path]:",
            "        \"\"\"Ensure sure icon is properly configured and installed.",
            "",
            "        Fetch from a remote URL, if required, and place in the meta/gui",
            "        directory.",
            "        \"\"\"",
            "",
            "        # Nothing to do if no icon is configured, search for existing icon.",
            "        icon: Optional[str] = self._config_data.get(\"icon\")",
            "        if icon is None and self._extracted_metadata is not None:",
            "            icon = self._extracted_metadata.get_icon()",
            "",
            "        if icon is None:",
            "            return _find_icon_file()",
            "",
            "        # Extracted appstream icon paths will either:",
            "        # (1) point to a file relative to prime",
            "        # (2) point to a remote http(s) url",
            "        #",
            "        # The 'icon' specified in the snapcraft.yaml has the same",
            "        # constraint as (2) and would have already been validated",
            "        # as existing by the schema.  So we can treat it the same",
            "        # at this point, regardless of the source of the icon.",
            "        parsed_url = urllib.parse.urlparse(icon)",
            "        parsed_path = pathlib.Path(parsed_url.path)",
            "        icon_ext = parsed_path.suffix[1:]",
            "        target_icon_path = pathlib.Path(self.meta_gui_dir, f\"icon.{icon_ext}\")",
            "",
            "        target_icon_path.parent.mkdir(parents=True, exist_ok=True)",
            "        if parsed_url.scheme in [\"http\", \"https\"]:",
            "            # Remote - fetch URL and write to target.",
            "            logger.info(f\"Fetching icon from {icon!r}.\")",
            "            icon_data = requests.get(icon).content",
            "            target_icon_path.write_bytes(icon_data)",
            "        elif parsed_url.scheme == \"\":",
            "            source_path = pathlib.Path(self._prime_dir, parsed_path)",
            "            if source_path.exists():",
            "                # Local - the path should be relative to prime, copy to target.",
            "                file_utils.link_or_copy(str(parsed_path), str(target_icon_path))",
            "            elif parsed_path.exists():",
            "                # Fall back to checking relative to project.",
            "                file_utils.link_or_copy(str(parsed_path), str(target_icon_path))",
            "            else:",
            "                # No icon found, fall back to searching for existing icon.",
            "                return _find_icon_file()",
            "        else:",
            "            raise RuntimeError(f\"Unexpected icon path: {parsed_url!r}\")",
            "",
            "        return target_icon_path",
            "",
            "    def finalize_snap_meta_commands(self) -> None:",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            # Prime commands only if adapter != \"none\",",
            "            # otherwise leave as-is.",
            "            if app.adapter != ApplicationAdapter.NONE:",
            "                app.prime_commands(",
            "                    base=self._project_config.project.info.base,",
            "                    prime_dir=self._prime_dir,",
            "                )",
            "",
            "    def finalize_snap_meta_command_chains(self) -> None:",
            "        snapcraft_runner = self._generate_snapcraft_runner()",
            "        if snapcraft_runner is None:",
            "            return",
            "",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            # Add runner to command chain if adapter is not \"none\".",
            "            if app.adapter != ApplicationAdapter.NONE:",
            "                app.command_chain.insert(0, snapcraft_runner)",
            "",
            "    def finalize_snap_meta_version(self) -> None:",
            "        # Reparse the version, the order should stick.",
            "        version = self._config_data[\"version\"]",
            "        version_script = self._config_data.get(\"version-script\")",
            "",
            "        if version_script:",
            "            # Deprecation warning for use of version-script.",
            "            handle_deprecation_notice(\"dn10\")",
            "",
            "        self._snap_meta.version = _version.get_version(version, version_script)",
            "",
            "    def write_snap_yaml(self) -> None:",
            "        # Ensure snap meta is valid before writing.",
            "        self._snap_meta.validate()",
            "        _check_passthrough_duplicates(self._original_snapcraft_yaml)",
            "",
            "        package_snap_path = os.path.join(self.meta_dir, \"snap.yaml\")",
            "        self._snap_meta.write_snap_yaml(path=package_snap_path)",
            "",
            "    def warn_ld_library_paths(self) -> None:",
            "        root_ld_library_path = self._snap_meta.environment.get(\"LD_LIBRARY_PATH\")",
            "        # Dictionary of app names with LD_LIBRARY_PATH in their environment.",
            "        app_environment: Dict[str, str] = dict()",
            "",
            "        for app_name, app_props in self._config_data.get(\"apps\", dict()).items():",
            "            with contextlib.suppress(KeyError):",
            "                app_environment[app_name] = app_props[\"environment\"][\"LD_LIBRARY_PATH\"]",
            "",
            "        if root_ld_library_path is None and not app_environment:",
            "            return",
            "",
            "        ld_library_path_empty: Set[str] = set()",
            "        if root_ld_library_path is None and app_environment:",
            "            ld_library_path_empty = {",
            "                name",
            "                for name, ld_env in app_environment.items()",
            "                if \"$LD_LIBRARY_PATH\" in ld_env or \"${LD_LIBRARY_PATH}\" in ld_env",
            "            }",
            "        elif (",
            "            root_ld_library_path is not None",
            "            and \"LD_LIBRARY_PATH\" in root_ld_library_path",
            "        ):",
            "            ld_library_path_empty = {\".\"}",
            "",
            "        _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN = re.compile(\"^:|::|:$\")",
            "",
            "        for name, ld_env in app_environment.items():",
            "            if _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN.findall(ld_env):",
            "                ld_library_path_empty.add(name)",
            "",
            "        if (",
            "            root_ld_library_path is not None",
            "            and _EMPTY_LD_LIBRARY_PATH_ITEM_PATTERN.findall(root_ld_library_path)",
            "        ):",
            "            ld_library_path_empty.add(\".\")",
            "",
            "        if ld_library_path_empty:",
            "            logger.warning(",
            "                \"CVE-2020-27348: A potentially empty LD_LIBRARY_PATH has been set for environment \"",
            "                \"in {}. \"",
            "                \"The current working directory will be added to the library path if empty. \"",
            "                \"This can cause unexpected libraries to be loaded.\".format(",
            "                    formatting_utils.humanize_list(sorted(ld_library_path_empty), \"and\")",
            "                )",
            "            )",
            "",
            "    def setup_assets(self) -> None:",
            "        # We do _setup_from_setup first since it is legacy and let the",
            "        # declarative items take over.",
            "        self._setup_gui()",
            "",
            "        icon_path = self._finalize_icon()",
            "        if icon_path is not None:",
            "            if str(icon_path).startswith(self._prime_dir):",
            "                icon_path = icon_path.relative_to(self._prime_dir)",
            "            relative_icon_path: Optional[str] = str(icon_path)",
            "        else:",
            "            relative_icon_path = None",
            "",
            "        snap_name = self._project_config.project.info.name",
            "        for app_name, app in self._snap_meta.apps.items():",
            "            app.write_command_wrappers(prime_dir=self._prime_dir)",
            "            app.write_application_desktop_file(",
            "                snap_name=snap_name,",
            "                prime_dir=self._prime_dir,",
            "                gui_dir=self.meta_gui_dir,",
            "                icon_path=relative_icon_path,",
            "            )",
            "            app.validate_command_chain_executables(self._prime_dir)",
            "",
            "        if self._config_data.get(\"type\", \"\") == \"gadget\":",
            "            if not os.path.exists(\"gadget.yaml\"):",
            "                raise errors.MissingGadgetError()",
            "            file_utils.link_or_copy(",
            "                \"gadget.yaml\", os.path.join(self.meta_dir, \"gadget.yaml\")",
            "            )",
            "",
            "    def _assemble_runtime_environment(self) -> str:",
            "        # Classic confinement or building on a host that does not match the target base",
            "        # means we cannot setup an environment that will work.",
            "        if self._config_data[\"confinement\"] == \"classic\":",
            "            # Temporary workaround for snapd bug not expanding PATH:",
            "            # We generate an empty runner which addresses the issue.",
            "            # https://bugs.launchpad.net/snapd/+bug/1860369",
            "            return \"\"",
            "",
            "        env = list()",
            "        if self._project_config.project._snap_meta.base in (\"core\", \"core16\", \"core18\"):",
            "            common.env = self._project_config.snap_env()",
            "            assembled_env = common.assemble_env()",
            "            common.reset_env()",
            "",
            "            assembled_env = assembled_env.replace(self._prime_dir, \"$SNAP\")",
            "            env.append(self._install_path_pattern.sub(\"$SNAP\", assembled_env))",
            "        else:",
            "            # TODO use something local to the meta package and",
            "            # only add paths for directory items that actually exist.",
            "            runtime_env = project_loader.runtime_env(",
            "                self._prime_dir, self._project_config.project.arch_triplet",
            "            )",
            "            for e in runtime_env:",
            "                env.append(re.sub(self._prime_dir, \"$SNAP\", e))",
            "",
            "        if all(",
            "            [",
            "                part._build_attributes.enable_patchelf()",
            "                for part in self._project_config.all_parts",
            "            ]",
            "        ):",
            "            # All ELF files have had rpath and interpreter patched. Strip all LD_LIBRARY_PATH variables",
            "            env = [e for e in env if not e.startswith(\"export LD_LIBRARY_PATH=\")]",
            "        else:",
            "            env.append(",
            "                'export LD_LIBRARY_PATH=\"$SNAP_LIBRARY_PATH${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\"'",
            "            )",
            "",
            "        return \"\\n\".join(env)",
            "",
            "    def _generate_snapcraft_runner(self) -> Optional[str]:",
            "        \"\"\"Create runner if required.",
            "",
            "        Return path relative to prime directory, if created.\"\"\"",
            "",
            "        # If there are no apps, or type is snapd, no need to create a runner.",
            "        if not self._snap_meta.apps or self._config_data.get(\"type\") == \"snapd\":",
            "            return None",
            "",
            "        # No more command-chain for core20 and classic confinement.",
            "        # This was a workaround for LP: #1860369.",
            "        if (",
            "            self._snap_meta.base not in (\"core\", \"core16\", \"core18\", None)",
            "            and self._snap_meta.confinement == \"classic\"",
            "        ):",
            "            return None",
            "",
            "        assembled_env = self._assemble_runtime_environment()",
            "",
            "        meta_runner = os.path.join(",
            "            self._prime_dir, \"snap\", \"command-chain\", \"snapcraft-runner\"",
            "        )",
            "",
            "        os.makedirs(os.path.dirname(meta_runner), exist_ok=True)",
            "        with open(meta_runner, \"w\") as f:",
            "            print(\"#!/bin/sh\", file=f)",
            "            print(assembled_env, file=f)",
            "            print('exec \"$@\"', file=f)",
            "        os.chmod(meta_runner, 0o755)",
            "",
            "        return os.path.relpath(meta_runner, self._prime_dir)",
            "",
            "    def _record_manifest_and_source_snapcraft_yaml(self):",
            "        prime_snap_dir = os.path.join(self._prime_dir, \"snap\")",
            "        recorded_snapcraft_yaml_path = os.path.join(prime_snap_dir, \"snapcraft.yaml\")",
            "        if os.path.isfile(recorded_snapcraft_yaml_path):",
            "            os.unlink(recorded_snapcraft_yaml_path)",
            "        manifest_file_path = os.path.join(prime_snap_dir, \"manifest.yaml\")",
            "        if os.path.isfile(manifest_file_path):",
            "            os.unlink(manifest_file_path)",
            "",
            "        # FIXME hide this functionality behind a feature flag for now",
            "        if distutils.util.strtobool(os.environ.get(\"SNAPCRAFT_BUILD_INFO\", \"n\")):",
            "            os.makedirs(prime_snap_dir, exist_ok=True)",
            "            shutil.copy2(self._snapcraft_yaml_path, recorded_snapcraft_yaml_path)",
            "            annotated_snapcraft = _manifest.annotate_snapcraft(",
            "                self._project_config.project, copy.deepcopy(self._config_data)",
            "            )",
            "            with open(manifest_file_path, \"w\") as manifest_file:",
            "                yaml_utils.dump(annotated_snapcraft, stream=manifest_file)",
            "",
            "    def write_snap_directory(self) -> None:",
            "        \"\"\"Record manifest and copy assets found under $SNAPCRAFT_PROJECT_ROOT/snap.",
            "",
            "        These assets have priority over any code generated assets and include:",
            "        - hooks",
            "        - gui",
            "        \"\"\"",
            "        snap_assets_dir = self._project_config.project._get_snapcraft_assets_dir()",
            "        prime_snap_dir = os.path.join(self._prime_dir, \"snap\")",
            "",
            "        snap_dir_iter = itertools.product([prime_snap_dir], [\"hooks\"])",
            "        meta_dir_iter = itertools.product([self.meta_dir], [\"hooks\", \"gui\"])",
            "",
            "        for origin in itertools.chain(snap_dir_iter, meta_dir_iter):",
            "            src_dir = os.path.join(snap_assets_dir, origin[1])",
            "            dst_dir = os.path.join(origin[0], origin[1])",
            "            if os.path.isdir(src_dir):",
            "                os.makedirs(dst_dir, exist_ok=True)",
            "                for asset in os.listdir(src_dir):",
            "                    source = os.path.join(src_dir, asset)",
            "                    destination = os.path.join(dst_dir, asset)",
            "",
            "                    with contextlib.suppress(FileNotFoundError):",
            "                        os.remove(destination)",
            "",
            "                    file_utils.link_or_copy(source, destination, follow_symlinks=True)",
            "",
            "                    # Ensure that the hook is executable in meta/hooks, this is a moot",
            "                    # point considering the prior link_or_copy call, but is technically",
            "                    # correct and allows for this operation to take place only once.",
            "                    if origin[0] == self.meta_dir and origin[1] == \"hooks\":",
            "                        _prepare_hook(destination)",
            "",
            "        self._record_manifest_and_source_snapcraft_yaml()",
            "",
            "    def generate_hook_wrappers(self) -> None:",
            "        \"\"\"Setup hooks in meta.",
            "",
            "        Hooks generated with this criteria:",
            "",
            "        - A stub for every hook definition that contains a command-chain entry",
            "          to ensure the command-chain for a defined hook runs. A command-chain",
            "          with no hook can occur when using extensions.",
            "        - A wrapper from a hook created from hooks found under",
            "          self._prime_dir/snap/hooks, these hooks are usually generated by parts.",
            "        \"\"\"",
            "        hooks_dir = os.path.join(self._prime_dir, \"meta\", \"hooks\")",
            "        snap_hooks_dir = os.path.join(self._prime_dir, \"snap\", \"hooks\")",
            "        hooks_in_snap_dir = (",
            "            os.listdir(snap_hooks_dir) if os.path.isdir(snap_hooks_dir) else []",
            "        )",
            "        hooks_with_command_chain = [",
            "            hook",
            "            for hook in self._snap_meta.hooks.values()",
            "            if hook.command_chain is not None",
            "            and hook.hook_name not in hooks_in_snap_dir",
            "        ]",
            "",
            "        if hooks_with_command_chain or hooks_in_snap_dir:",
            "            os.makedirs(hooks_dir, exist_ok=True)",
            "",
            "        # Create stub hooks as necessary.",
            "        for hook in hooks_with_command_chain:",
            "            hook_path = pathlib.Path(hooks_dir) / hook.hook_name",
            "            if not hook_path.exists():",
            "                hook_path.write_text(\"#!/bin/sh\\n\")",
            "                hook_path.chmod(0o755)",
            "",
            "        # Write wrapper hooks as necessary.",
            "        for hook_name in hooks_in_snap_dir:",
            "            file_path = os.path.join(snap_hooks_dir, hook_name)",
            "            # Make sure the hook is executable",
            "            _prepare_hook(file_path)",
            "",
            "            hook_exec = os.path.join(\"$SNAP\", \"snap\", \"hooks\", hook_name)",
            "            hook_path = pathlib.Path(hooks_dir) / hook_name",
            "            with contextlib.suppress(FileNotFoundError):",
            "                hook_path.unlink()",
            "",
            "            self._write_wrap_exe(hook_exec, str(hook_path))",
            "",
            "    def _setup_gui(self):",
            "        # Handles the setup directory which only contains gui assets.",
            "        setup_dir = \"setup\"",
            "        if not os.path.exists(setup_dir):",
            "            return",
            "",
            "        handle_deprecation_notice(\"dn3\")",
            "",
            "        gui_src = os.path.join(setup_dir, \"gui\")",
            "        if os.path.exists(gui_src):",
            "            for f in os.listdir(gui_src):",
            "                if not os.path.exists(self.meta_gui_dir):",
            "                    os.mkdir(self.meta_gui_dir)",
            "                shutil.copy2(os.path.join(gui_src, f), self.meta_gui_dir)",
            "",
            "    def _write_wrap_exe(self, wrapexec, wrappath, shebang=None, args=None, cwd=None):",
            "        assembled_env = self._assemble_runtime_environment()",
            "",
            "        if args:",
            "            quoted_args = ['\"{}\"'.format(arg) for arg in args]",
            "        else:",
            "            quoted_args = []",
            "        args = \" \".join(quoted_args) + ' \"$@\"' if args else '\"$@\"'",
            "        cwd = \"cd {}\".format(cwd) if cwd else \"\"",
            "",
            "        executable = '\"{}\"'.format(wrapexec)",
            "",
            "        if shebang:",
            "            if shebang.startswith(\"/usr/bin/env \"):",
            "                shebang = shell_utils.which(shebang.split()[1])",
            "            new_shebang = self._install_path_pattern.sub(\"$SNAP\", shebang)",
            "            new_shebang = re.sub(self._prime_dir, \"$SNAP\", new_shebang)",
            "            if new_shebang != shebang:",
            "                # If the shebang was pointing to and executable within the",
            "                # local 'parts' dir, have the wrapper script execute it",
            "                # directly, since we can't use $SNAP in the shebang itself.",
            "                executable = '\"{}\" \"{}\"'.format(new_shebang, wrapexec)",
            "",
            "        with open(wrappath, \"w+\") as f:",
            "            print(\"#!/bin/sh\", file=f)",
            "            if cwd:",
            "                print(\"{}\".format(cwd), file=f)",
            "            print(assembled_env, file=f)",
            "            print(\"exec {} {}\".format(executable, args), file=f)",
            "",
            "        os.chmod(wrappath, 0o755)",
            "",
            "    def validate_common_ids(self) -> None:",
            "        if (",
            "            not self._extracted_metadata",
            "            or not self._extracted_metadata.common_id_list",
            "            or \"apps\" not in self._config_data",
            "        ):",
            "            return",
            "",
            "        common_id_list = self._extracted_metadata.common_id_list",
            "        for app in self._config_data[\"apps\"]:",
            "            app_common_id = self._config_data[\"apps\"][app].get(\"common-id\")",
            "            if app_common_id not in common_id_list:",
            "                logger.warning(",
            "                    \"Common ID {common_id!r} specified in app {app!r} is \"",
            "                    \"not used in any metadata file.\".format(",
            "                        common_id=app_common_id, app=app",
            "                    )",
            "                )",
            "",
            "",
            "def _prepare_hook(hook_path):",
            "    # Ensure hook is executable",
            "    if not os.stat(hook_path).st_mode & stat.S_IEXEC:",
            "        os.chmod(hook_path, 0o755)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "522": [
                "_SnapPackaging",
                "_assemble_runtime_environment"
            ]
        },
        "addLocation": [
            "snapcraft.internal.meta._snap_packaging.create_snap_packaging.packaging",
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.write_snap_yaml",
            "snapcraft.internal.meta._snap_packaging.create_snap_packaging",
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.self"
        ]
    },
    "snapcraft/internal/project_loader/_config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "         if dependency_paths:"
            },
            "1": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "             # Add more specific LD_LIBRARY_PATH from the dependencies."
            },
            "2": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             env.append("
            },
            "3": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'LD_LIBRARY_PATH=\"' + \":\".join(dependency_paths) + ':$LD_LIBRARY_PATH\"'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+                'LD_LIBRARY_PATH=\"'"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+                + \":\".join(dependency_paths)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+                + '${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\"'"
            },
            "7": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "             )"
            },
            "8": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 358,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "         return env"
            }
        },
        "frontPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2015-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import collections",
            "import logging",
            "import os",
            "import os.path",
            "import re",
            "from typing import List, Set",
            "",
            "import jsonschema",
            "",
            "from snapcraft import formatting_utils, plugins, project",
            "from snapcraft.internal import deprecations, repo, states, steps",
            "from snapcraft.internal.meta.package_repository import PackageRepository",
            "from snapcraft.internal.meta.snap import Snap",
            "from snapcraft.internal.pluginhandler._part_environment import (",
            "    get_snapcraft_global_environment,",
            ")",
            "from snapcraft.project._schema import Validator",
            "",
            "from . import errors, grammar_processing, replace_attr",
            "from ._env import build_env_for_stage, environment_to_replacements, runtime_env",
            "from ._extensions import apply_extensions",
            "from ._parts_config import PartsConfig",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"icon-path\")",
            "def _validate_icon(icon):",
            "    allowed_extensions = [\".png\", \".svg\"]",
            "    extension = os.path.splitext(icon.lower())[1]",
            "    if extension not in allowed_extensions:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            f\"icon {icon!r} must be either a .png or a .svg\"",
            "        )",
            "",
            "    return True",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"epoch\", raises=errors.InvalidEpochError)",
            "def _validate_epoch(instance):",
            "    str_instance = str(instance)",
            "    pattern = re.compile(\"^(?:0|[1-9][0-9]*[*]?)$\")",
            "    if not pattern.match(str_instance):",
            "        raise errors.InvalidEpochError()",
            "",
            "    return True",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"architectures\")",
            "def _validate_architectures(instance):",
            "    standalone_build_ons = collections.Counter()",
            "    build_ons = collections.Counter()",
            "    run_ons = collections.Counter()",
            "",
            "    saw_strings = False",
            "    saw_dicts = False",
            "",
            "    for item in instance:",
            "        # This could either be a dict or a string. In the latter case, the",
            "        # schema will take care of it. We just need to further validate the",
            "        # dict.",
            "        if isinstance(item, str):",
            "            saw_strings = True",
            "        elif isinstance(item, dict):",
            "            saw_dicts = True",
            "            build_on = _get_architectures_set(item, \"build-on\")",
            "            build_ons.update(build_on)",
            "",
            "            # Add to the list of run-ons. However, if no run-on is specified,",
            "            # we know it's implicitly the value of build-on, so use that",
            "            # for validation instead.",
            "            run_on = _get_architectures_set(item, \"run-on\")",
            "            if run_on:",
            "                run_ons.update(run_on)",
            "            else:",
            "                standalone_build_ons.update(build_on)",
            "",
            "    # Architectures can either be a list of strings, or a list of objects.",
            "    # Mixing the two forms is unsupported.",
            "    if saw_strings and saw_dicts:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"every item must either be a string or an object\",",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # At this point, individual build-ons and run-ons have been validated,",
            "    # we just need to validate them across each other.",
            "",
            "    # First of all, if we have a `run-on: [all]` (or a standalone",
            "    # `build-on: [all]`) then we should only have one item in the instance,",
            "    # otherwise we know we'll have multiple snaps claiming they run on the same",
            "    # architectures (i.e. all and something else).",
            "    number_of_snaps = len(instance)",
            "    if \"all\" in run_ons and number_of_snaps > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"one of the items has 'all' in 'run-on', but there are {} \"",
            "            \"items: upon release they will conflict. 'all' should only be \"",
            "            \"used if there is a single item\".format(number_of_snaps),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "    if \"all\" in build_ons and number_of_snaps > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"one of the items has 'all' in 'build-on', but there are {} \"",
            "            \"items: snapcraft doesn't know which one to use. 'all' should \"",
            "            \"only be used if there is a single item\".format(number_of_snaps),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # We want to ensure that multiple `run-on`s (or standalone `build-on`s)",
            "    # don't include the same arch, or they'll clash with each other when",
            "    # releasing.",
            "    all_run_ons = run_ons + standalone_build_ons",
            "    duplicates = {arch for (arch, count) in all_run_ons.items() if count > 1}",
            "    if duplicates:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"multiple items will build snaps that claim to run on {}\".format(",
            "                formatting_utils.humanize_list(duplicates, \"and\")",
            "            ),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # Finally, ensure that multiple `build-on`s don't include the same arch",
            "    # or Snapcraft has no way of knowing which one to use.",
            "    duplicates = {arch for (arch, count) in build_ons.items() if count > 1}",
            "    if duplicates:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"{} {} present in the 'build-on' of multiple items, which means \"",
            "            \"snapcraft doesn't know which 'run-on' to use when building on \"",
            "            \"{} {}\".format(",
            "                formatting_utils.humanize_list(duplicates, \"and\"),",
            "                formatting_utils.pluralize(duplicates, \"is\", \"are\"),",
            "                formatting_utils.pluralize(duplicates, \"that\", \"those\"),",
            "                formatting_utils.pluralize(duplicates, \"architecture\", \"architectures\"),",
            "            ),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    return True",
            "",
            "",
            "def _get_architectures_set(item, name):",
            "    value = item.get(name, set())",
            "    if isinstance(value, str):",
            "        value_set = {value}",
            "    else:",
            "        value_set = set(value)",
            "",
            "    _validate_architectures_set(value_set, name)",
            "",
            "    return value_set",
            "",
            "",
            "def _validate_architectures_set(architectures_set, name):",
            "    if \"all\" in architectures_set and len(architectures_set) > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"'all' can only be used within {!r} by itself, \"",
            "            \"not with other architectures\".format(name),",
            "            path=[\"architectures\"],",
            "            instance=architectures_set,",
            "        )",
            "",
            "",
            "class Config:",
            "    @property",
            "    def part_names(self):",
            "        return self.parts.part_names",
            "",
            "    @property",
            "    def all_parts(self):",
            "        return self.parts.all_parts",
            "",
            "    def __init__(self, project: project.Project) -> None:",
            "        self.build_snaps: Set[str] = set()",
            "        self.project = project",
            "",
            "        # raw_snapcraft_yaml is read only, create a new copy",
            "        snapcraft_yaml = apply_extensions(project.info.get_raw_snapcraft())",
            "",
            "        self.validator = Validator(snapcraft_yaml)",
            "        self.validator.validate()",
            "",
            "        snapcraft_yaml = self._expand_filesets(snapcraft_yaml)",
            "",
            "        self.data = self._expand_env(snapcraft_yaml)",
            "",
            "        self.data[\"architectures\"] = _process_architectures(",
            "            self.data.get(\"architectures\"), project.deb_arch",
            "        )",
            "",
            "        self._ensure_no_duplicate_app_aliases()",
            "",
            "        self._global_grammar_processor = grammar_processing.GlobalGrammarProcessor(",
            "            properties=self.data, project=project",
            "        )",
            "",
            "        # XXX: Resetting snap_meta due to above mangling of data.",
            "        # Convergence to operating on snap_meta will remove this requirement...",
            "        project._snap_meta = Snap.from_dict(self.data)",
            "",
            "        self.parts = PartsConfig(",
            "            parts=self.data, project=project, validator=self.validator",
            "        )",
            "",
            "    def _ensure_no_duplicate_app_aliases(self):",
            "        # Prevent multiple apps within a snap from having duplicate alias names",
            "        aliases = []",
            "        for app_name, app in self.data.get(\"apps\", {}).items():",
            "            aliases.extend(app.get(\"aliases\", []))",
            "",
            "        # The aliases property is actually deprecated:",
            "        if aliases:",
            "            deprecations.handle_deprecation_notice(\"dn5\")",
            "        seen = set()",
            "        duplicates = set()",
            "        for alias in aliases:",
            "            if alias in seen:",
            "                duplicates.add(alias)",
            "            else:",
            "                seen.add(alias)",
            "        if duplicates:",
            "            raise errors.DuplicateAliasError(aliases=duplicates)",
            "",
            "    def _get_required_package_repositories(self) -> List[PackageRepository]:",
            "        package_repos = self.project._snap_meta.package_repositories.copy()",
            "",
            "        v1_plugins = [",
            "            part.plugin",
            "            for part in self.all_parts",
            "            if isinstance(part.plugin, plugins.v1.PluginV1)",
            "        ]",
            "        for plugin in v1_plugins:",
            "            package_repos.extend(plugin.get_required_package_repositories())",
            "",
            "        return package_repos",
            "",
            "    def install_package_repositories(self) -> None:",
            "        package_repos = self._get_required_package_repositories()",
            "        if not package_repos:",
            "            return",
            "",
            "        # Install pre-requisite packages for apt-key, if not installed.",
            "        repo.Repo.install_build_packages(package_names=[\"gnupg\", \"dirmngr\"])",
            "",
            "        keys_path = self.project._get_keys_path()",
            "        changes = [",
            "            package_repo.install(keys_path=keys_path) for package_repo in package_repos",
            "        ]",
            "        if any(changes):",
            "            repo.Repo.refresh_build_packages()",
            "",
            "    def get_build_packages(self) -> Set[str]:",
            "        # Install/update configured package repositories.",
            "        self.install_package_repositories()",
            "",
            "        build_packages = self._global_grammar_processor.get_build_packages()",
            "        build_packages |= set(self.project.additional_build_packages)",
            "",
            "        if self.project._snap_meta.version == \"git\":",
            "            build_packages.add(\"git\")",
            "",
            "        for part in self.all_parts:",
            "            build_packages |= part._grammar_processor.get_build_packages()",
            "",
            "            # TODO: this should not pass in command but the required package,",
            "            #       where the required package is to be determined by the",
            "            #       source handler.",
            "            if part.source_handler and part.source_handler.command:",
            "                # TODO get_packages_for_source_type should not be a thing.",
            "                build_packages |= repo.Repo.get_packages_for_source_type(",
            "                    part.source_handler.command",
            "                )",
            "",
            "            if not isinstance(part.plugin, plugins.v1.PluginV1):",
            "                build_packages |= part.plugin.get_build_packages()",
            "",
            "        return build_packages",
            "",
            "    def get_build_snaps(self) -> Set[str]:",
            "        build_snaps = set()",
            "",
            "        # Add the base.",
            "        if self.project._snap_meta.base is not None:",
            "            build_snaps.add(self.project._snap_meta.base)",
            "",
            "        for part in self.all_parts:",
            "            build_snaps |= part._grammar_processor.get_build_snaps()",
            "            if not isinstance(part.plugin, plugins.v1.PluginV1):",
            "                build_snaps |= part.plugin.get_build_snaps()",
            "",
            "        return build_snaps",
            "",
            "    def get_project_state(self, step: steps.Step):",
            "        \"\"\"Returns a dict of states for the given step of each part.\"\"\"",
            "",
            "        state = {}",
            "        for part in self.parts.all_parts:",
            "            state[part.name] = states.get_state(part.part_state_dir, step)",
            "",
            "        return state",
            "",
            "    def stage_env(self):",
            "        stage_dir = self.project.stage_dir",
            "        env = []",
            "",
            "        env += runtime_env(stage_dir, self.project.arch_triplet)",
            "        env += build_env_for_stage(",
            "            stage_dir, self.data[\"name\"], self.project.arch_triplet",
            "        )",
            "        for part in self.parts.all_parts:",
            "            env += part.env(stage_dir)",
            "",
            "        return env",
            "",
            "    def snap_env(self):",
            "        prime_dir = self.project.prime_dir",
            "        env = []",
            "",
            "        env += runtime_env(prime_dir, self.project.arch_triplet)",
            "        dependency_paths = set()",
            "        for part in self.parts.all_parts:",
            "            env += part.env(prime_dir)",
            "            dependency_paths |= part.get_primed_dependency_paths()",
            "",
            "        # Dependency paths are only valid if they actually exist. Sorting them",
            "        # here as well so the LD_LIBRARY_PATH is consistent between runs.",
            "        dependency_paths = sorted(",
            "            {path for path in dependency_paths if os.path.isdir(path)}",
            "        )",
            "",
            "        if dependency_paths:",
            "            # Add more specific LD_LIBRARY_PATH from the dependencies.",
            "            env.append(",
            "                'LD_LIBRARY_PATH=\"' + \":\".join(dependency_paths) + ':$LD_LIBRARY_PATH\"'",
            "            )",
            "",
            "        return env",
            "",
            "    def project_env(self):",
            "        return [",
            "            '{}=\"{}\"'.format(variable, value)",
            "            for variable, value in get_snapcraft_global_environment(",
            "                self.project",
            "            ).items()",
            "        ]",
            "",
            "    def _expand_env(self, snapcraft_yaml):",
            "        environment_keys = [\"name\", \"version\"]",
            "        for key in snapcraft_yaml:",
            "            if any((key == env_key for env_key in environment_keys)):",
            "                continue",
            "",
            "            replacements = environment_to_replacements(",
            "                get_snapcraft_global_environment(self.project)",
            "            )",
            "",
            "            snapcraft_yaml[key] = replace_attr(snapcraft_yaml[key], replacements)",
            "        return snapcraft_yaml",
            "",
            "    def _expand_filesets(self, snapcraft_yaml):",
            "        parts = snapcraft_yaml.get(\"parts\", {})",
            "",
            "        for part_name in parts:",
            "            for step in (\"stage\", \"prime\"):",
            "                step_fileset = _expand_filesets_for(step, parts[part_name])",
            "                parts[part_name][step] = step_fileset",
            "",
            "        return snapcraft_yaml",
            "",
            "",
            "def _expand_filesets_for(step, properties):",
            "    filesets = properties.get(\"filesets\", {})",
            "    fileset_for_step = properties.get(step, {})",
            "    new_step_set = []",
            "",
            "    for item in fileset_for_step:",
            "        if item.startswith(\"$\"):",
            "            try:",
            "                new_step_set.extend(filesets[item[1:]])",
            "            except KeyError:",
            "                raise errors.SnapcraftLogicError(",
            "                    \"'{}' referred to in the '{}' fileset but it is not \"",
            "                    \"in filesets\".format(item, step)",
            "                )",
            "        else:",
            "            new_step_set.append(item)",
            "",
            "    return new_step_set",
            "",
            "",
            "class _Architecture:",
            "    def __init__(self, *, build_on, run_on=None):",
            "        if isinstance(build_on, str):",
            "            self.build_on = [build_on]",
            "        else:",
            "            self.build_on = build_on",
            "",
            "        # If there is no run_on, it defaults to the value of build_on",
            "        if not run_on:",
            "            self.run_on = self.build_on",
            "        elif isinstance(run_on, str):",
            "            self.run_on = [run_on]",
            "        else:",
            "            self.run_on = run_on",
            "",
            "",
            "def _create_architecture_list(architectures, current_arch):",
            "    if not architectures:",
            "        return [_Architecture(build_on=[current_arch])]",
            "",
            "    build_architectures: List[str] = []",
            "    architecture_list: List[_Architecture] = []",
            "    for item in architectures:",
            "        if isinstance(item, str):",
            "            build_architectures.append(item)",
            "        if isinstance(item, dict):",
            "            architecture_list.append(",
            "                _Architecture(build_on=item.get(\"build-on\"), run_on=item.get(\"run-on\"))",
            "            )",
            "",
            "    if build_architectures:",
            "        architecture_list.append(_Architecture(build_on=build_architectures))",
            "",
            "    return architecture_list",
            "",
            "",
            "def _process_architectures(architectures, current_arch):",
            "    architecture_list = _create_architecture_list(architectures, current_arch)",
            "",
            "    for architecture in architecture_list:",
            "        if current_arch in architecture.build_on or \"all\" in architecture.build_on:",
            "            return architecture.run_on",
            "",
            "    return [current_arch]"
        ],
        "afterPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2015-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import collections",
            "import logging",
            "import os",
            "import os.path",
            "import re",
            "from typing import List, Set",
            "",
            "import jsonschema",
            "",
            "from snapcraft import formatting_utils, plugins, project",
            "from snapcraft.internal import deprecations, repo, states, steps",
            "from snapcraft.internal.meta.package_repository import PackageRepository",
            "from snapcraft.internal.meta.snap import Snap",
            "from snapcraft.internal.pluginhandler._part_environment import (",
            "    get_snapcraft_global_environment,",
            ")",
            "from snapcraft.project._schema import Validator",
            "",
            "from . import errors, grammar_processing, replace_attr",
            "from ._env import build_env_for_stage, environment_to_replacements, runtime_env",
            "from ._extensions import apply_extensions",
            "from ._parts_config import PartsConfig",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"icon-path\")",
            "def _validate_icon(icon):",
            "    allowed_extensions = [\".png\", \".svg\"]",
            "    extension = os.path.splitext(icon.lower())[1]",
            "    if extension not in allowed_extensions:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            f\"icon {icon!r} must be either a .png or a .svg\"",
            "        )",
            "",
            "    return True",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"epoch\", raises=errors.InvalidEpochError)",
            "def _validate_epoch(instance):",
            "    str_instance = str(instance)",
            "    pattern = re.compile(\"^(?:0|[1-9][0-9]*[*]?)$\")",
            "    if not pattern.match(str_instance):",
            "        raise errors.InvalidEpochError()",
            "",
            "    return True",
            "",
            "",
            "@jsonschema.FormatChecker.cls_checks(\"architectures\")",
            "def _validate_architectures(instance):",
            "    standalone_build_ons = collections.Counter()",
            "    build_ons = collections.Counter()",
            "    run_ons = collections.Counter()",
            "",
            "    saw_strings = False",
            "    saw_dicts = False",
            "",
            "    for item in instance:",
            "        # This could either be a dict or a string. In the latter case, the",
            "        # schema will take care of it. We just need to further validate the",
            "        # dict.",
            "        if isinstance(item, str):",
            "            saw_strings = True",
            "        elif isinstance(item, dict):",
            "            saw_dicts = True",
            "            build_on = _get_architectures_set(item, \"build-on\")",
            "            build_ons.update(build_on)",
            "",
            "            # Add to the list of run-ons. However, if no run-on is specified,",
            "            # we know it's implicitly the value of build-on, so use that",
            "            # for validation instead.",
            "            run_on = _get_architectures_set(item, \"run-on\")",
            "            if run_on:",
            "                run_ons.update(run_on)",
            "            else:",
            "                standalone_build_ons.update(build_on)",
            "",
            "    # Architectures can either be a list of strings, or a list of objects.",
            "    # Mixing the two forms is unsupported.",
            "    if saw_strings and saw_dicts:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"every item must either be a string or an object\",",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # At this point, individual build-ons and run-ons have been validated,",
            "    # we just need to validate them across each other.",
            "",
            "    # First of all, if we have a `run-on: [all]` (or a standalone",
            "    # `build-on: [all]`) then we should only have one item in the instance,",
            "    # otherwise we know we'll have multiple snaps claiming they run on the same",
            "    # architectures (i.e. all and something else).",
            "    number_of_snaps = len(instance)",
            "    if \"all\" in run_ons and number_of_snaps > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"one of the items has 'all' in 'run-on', but there are {} \"",
            "            \"items: upon release they will conflict. 'all' should only be \"",
            "            \"used if there is a single item\".format(number_of_snaps),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "    if \"all\" in build_ons and number_of_snaps > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"one of the items has 'all' in 'build-on', but there are {} \"",
            "            \"items: snapcraft doesn't know which one to use. 'all' should \"",
            "            \"only be used if there is a single item\".format(number_of_snaps),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # We want to ensure that multiple `run-on`s (or standalone `build-on`s)",
            "    # don't include the same arch, or they'll clash with each other when",
            "    # releasing.",
            "    all_run_ons = run_ons + standalone_build_ons",
            "    duplicates = {arch for (arch, count) in all_run_ons.items() if count > 1}",
            "    if duplicates:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"multiple items will build snaps that claim to run on {}\".format(",
            "                formatting_utils.humanize_list(duplicates, \"and\")",
            "            ),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    # Finally, ensure that multiple `build-on`s don't include the same arch",
            "    # or Snapcraft has no way of knowing which one to use.",
            "    duplicates = {arch for (arch, count) in build_ons.items() if count > 1}",
            "    if duplicates:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"{} {} present in the 'build-on' of multiple items, which means \"",
            "            \"snapcraft doesn't know which 'run-on' to use when building on \"",
            "            \"{} {}\".format(",
            "                formatting_utils.humanize_list(duplicates, \"and\"),",
            "                formatting_utils.pluralize(duplicates, \"is\", \"are\"),",
            "                formatting_utils.pluralize(duplicates, \"that\", \"those\"),",
            "                formatting_utils.pluralize(duplicates, \"architecture\", \"architectures\"),",
            "            ),",
            "            path=[\"architectures\"],",
            "            instance=instance,",
            "        )",
            "",
            "    return True",
            "",
            "",
            "def _get_architectures_set(item, name):",
            "    value = item.get(name, set())",
            "    if isinstance(value, str):",
            "        value_set = {value}",
            "    else:",
            "        value_set = set(value)",
            "",
            "    _validate_architectures_set(value_set, name)",
            "",
            "    return value_set",
            "",
            "",
            "def _validate_architectures_set(architectures_set, name):",
            "    if \"all\" in architectures_set and len(architectures_set) > 1:",
            "        raise jsonschema.exceptions.ValidationError(",
            "            \"'all' can only be used within {!r} by itself, \"",
            "            \"not with other architectures\".format(name),",
            "            path=[\"architectures\"],",
            "            instance=architectures_set,",
            "        )",
            "",
            "",
            "class Config:",
            "    @property",
            "    def part_names(self):",
            "        return self.parts.part_names",
            "",
            "    @property",
            "    def all_parts(self):",
            "        return self.parts.all_parts",
            "",
            "    def __init__(self, project: project.Project) -> None:",
            "        self.build_snaps: Set[str] = set()",
            "        self.project = project",
            "",
            "        # raw_snapcraft_yaml is read only, create a new copy",
            "        snapcraft_yaml = apply_extensions(project.info.get_raw_snapcraft())",
            "",
            "        self.validator = Validator(snapcraft_yaml)",
            "        self.validator.validate()",
            "",
            "        snapcraft_yaml = self._expand_filesets(snapcraft_yaml)",
            "",
            "        self.data = self._expand_env(snapcraft_yaml)",
            "",
            "        self.data[\"architectures\"] = _process_architectures(",
            "            self.data.get(\"architectures\"), project.deb_arch",
            "        )",
            "",
            "        self._ensure_no_duplicate_app_aliases()",
            "",
            "        self._global_grammar_processor = grammar_processing.GlobalGrammarProcessor(",
            "            properties=self.data, project=project",
            "        )",
            "",
            "        # XXX: Resetting snap_meta due to above mangling of data.",
            "        # Convergence to operating on snap_meta will remove this requirement...",
            "        project._snap_meta = Snap.from_dict(self.data)",
            "",
            "        self.parts = PartsConfig(",
            "            parts=self.data, project=project, validator=self.validator",
            "        )",
            "",
            "    def _ensure_no_duplicate_app_aliases(self):",
            "        # Prevent multiple apps within a snap from having duplicate alias names",
            "        aliases = []",
            "        for app_name, app in self.data.get(\"apps\", {}).items():",
            "            aliases.extend(app.get(\"aliases\", []))",
            "",
            "        # The aliases property is actually deprecated:",
            "        if aliases:",
            "            deprecations.handle_deprecation_notice(\"dn5\")",
            "        seen = set()",
            "        duplicates = set()",
            "        for alias in aliases:",
            "            if alias in seen:",
            "                duplicates.add(alias)",
            "            else:",
            "                seen.add(alias)",
            "        if duplicates:",
            "            raise errors.DuplicateAliasError(aliases=duplicates)",
            "",
            "    def _get_required_package_repositories(self) -> List[PackageRepository]:",
            "        package_repos = self.project._snap_meta.package_repositories.copy()",
            "",
            "        v1_plugins = [",
            "            part.plugin",
            "            for part in self.all_parts",
            "            if isinstance(part.plugin, plugins.v1.PluginV1)",
            "        ]",
            "        for plugin in v1_plugins:",
            "            package_repos.extend(plugin.get_required_package_repositories())",
            "",
            "        return package_repos",
            "",
            "    def install_package_repositories(self) -> None:",
            "        package_repos = self._get_required_package_repositories()",
            "        if not package_repos:",
            "            return",
            "",
            "        # Install pre-requisite packages for apt-key, if not installed.",
            "        repo.Repo.install_build_packages(package_names=[\"gnupg\", \"dirmngr\"])",
            "",
            "        keys_path = self.project._get_keys_path()",
            "        changes = [",
            "            package_repo.install(keys_path=keys_path) for package_repo in package_repos",
            "        ]",
            "        if any(changes):",
            "            repo.Repo.refresh_build_packages()",
            "",
            "    def get_build_packages(self) -> Set[str]:",
            "        # Install/update configured package repositories.",
            "        self.install_package_repositories()",
            "",
            "        build_packages = self._global_grammar_processor.get_build_packages()",
            "        build_packages |= set(self.project.additional_build_packages)",
            "",
            "        if self.project._snap_meta.version == \"git\":",
            "            build_packages.add(\"git\")",
            "",
            "        for part in self.all_parts:",
            "            build_packages |= part._grammar_processor.get_build_packages()",
            "",
            "            # TODO: this should not pass in command but the required package,",
            "            #       where the required package is to be determined by the",
            "            #       source handler.",
            "            if part.source_handler and part.source_handler.command:",
            "                # TODO get_packages_for_source_type should not be a thing.",
            "                build_packages |= repo.Repo.get_packages_for_source_type(",
            "                    part.source_handler.command",
            "                )",
            "",
            "            if not isinstance(part.plugin, plugins.v1.PluginV1):",
            "                build_packages |= part.plugin.get_build_packages()",
            "",
            "        return build_packages",
            "",
            "    def get_build_snaps(self) -> Set[str]:",
            "        build_snaps = set()",
            "",
            "        # Add the base.",
            "        if self.project._snap_meta.base is not None:",
            "            build_snaps.add(self.project._snap_meta.base)",
            "",
            "        for part in self.all_parts:",
            "            build_snaps |= part._grammar_processor.get_build_snaps()",
            "            if not isinstance(part.plugin, plugins.v1.PluginV1):",
            "                build_snaps |= part.plugin.get_build_snaps()",
            "",
            "        return build_snaps",
            "",
            "    def get_project_state(self, step: steps.Step):",
            "        \"\"\"Returns a dict of states for the given step of each part.\"\"\"",
            "",
            "        state = {}",
            "        for part in self.parts.all_parts:",
            "            state[part.name] = states.get_state(part.part_state_dir, step)",
            "",
            "        return state",
            "",
            "    def stage_env(self):",
            "        stage_dir = self.project.stage_dir",
            "        env = []",
            "",
            "        env += runtime_env(stage_dir, self.project.arch_triplet)",
            "        env += build_env_for_stage(",
            "            stage_dir, self.data[\"name\"], self.project.arch_triplet",
            "        )",
            "        for part in self.parts.all_parts:",
            "            env += part.env(stage_dir)",
            "",
            "        return env",
            "",
            "    def snap_env(self):",
            "        prime_dir = self.project.prime_dir",
            "        env = []",
            "",
            "        env += runtime_env(prime_dir, self.project.arch_triplet)",
            "        dependency_paths = set()",
            "        for part in self.parts.all_parts:",
            "            env += part.env(prime_dir)",
            "            dependency_paths |= part.get_primed_dependency_paths()",
            "",
            "        # Dependency paths are only valid if they actually exist. Sorting them",
            "        # here as well so the LD_LIBRARY_PATH is consistent between runs.",
            "        dependency_paths = sorted(",
            "            {path for path in dependency_paths if os.path.isdir(path)}",
            "        )",
            "",
            "        if dependency_paths:",
            "            # Add more specific LD_LIBRARY_PATH from the dependencies.",
            "            env.append(",
            "                'LD_LIBRARY_PATH=\"'",
            "                + \":\".join(dependency_paths)",
            "                + '${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\"'",
            "            )",
            "",
            "        return env",
            "",
            "    def project_env(self):",
            "        return [",
            "            '{}=\"{}\"'.format(variable, value)",
            "            for variable, value in get_snapcraft_global_environment(",
            "                self.project",
            "            ).items()",
            "        ]",
            "",
            "    def _expand_env(self, snapcraft_yaml):",
            "        environment_keys = [\"name\", \"version\"]",
            "        for key in snapcraft_yaml:",
            "            if any((key == env_key for env_key in environment_keys)):",
            "                continue",
            "",
            "            replacements = environment_to_replacements(",
            "                get_snapcraft_global_environment(self.project)",
            "            )",
            "",
            "            snapcraft_yaml[key] = replace_attr(snapcraft_yaml[key], replacements)",
            "        return snapcraft_yaml",
            "",
            "    def _expand_filesets(self, snapcraft_yaml):",
            "        parts = snapcraft_yaml.get(\"parts\", {})",
            "",
            "        for part_name in parts:",
            "            for step in (\"stage\", \"prime\"):",
            "                step_fileset = _expand_filesets_for(step, parts[part_name])",
            "                parts[part_name][step] = step_fileset",
            "",
            "        return snapcraft_yaml",
            "",
            "",
            "def _expand_filesets_for(step, properties):",
            "    filesets = properties.get(\"filesets\", {})",
            "    fileset_for_step = properties.get(step, {})",
            "    new_step_set = []",
            "",
            "    for item in fileset_for_step:",
            "        if item.startswith(\"$\"):",
            "            try:",
            "                new_step_set.extend(filesets[item[1:]])",
            "            except KeyError:",
            "                raise errors.SnapcraftLogicError(",
            "                    \"'{}' referred to in the '{}' fileset but it is not \"",
            "                    \"in filesets\".format(item, step)",
            "                )",
            "        else:",
            "            new_step_set.append(item)",
            "",
            "    return new_step_set",
            "",
            "",
            "class _Architecture:",
            "    def __init__(self, *, build_on, run_on=None):",
            "        if isinstance(build_on, str):",
            "            self.build_on = [build_on]",
            "        else:",
            "            self.build_on = build_on",
            "",
            "        # If there is no run_on, it defaults to the value of build_on",
            "        if not run_on:",
            "            self.run_on = self.build_on",
            "        elif isinstance(run_on, str):",
            "            self.run_on = [run_on]",
            "        else:",
            "            self.run_on = run_on",
            "",
            "",
            "def _create_architecture_list(architectures, current_arch):",
            "    if not architectures:",
            "        return [_Architecture(build_on=[current_arch])]",
            "",
            "    build_architectures: List[str] = []",
            "    architecture_list: List[_Architecture] = []",
            "    for item in architectures:",
            "        if isinstance(item, str):",
            "            build_architectures.append(item)",
            "        if isinstance(item, dict):",
            "            architecture_list.append(",
            "                _Architecture(build_on=item.get(\"build-on\"), run_on=item.get(\"run-on\"))",
            "            )",
            "",
            "    if build_architectures:",
            "        architecture_list.append(_Architecture(build_on=build_architectures))",
            "",
            "    return architecture_list",
            "",
            "",
            "def _process_architectures(architectures, current_arch):",
            "    architecture_list = _create_architecture_list(architectures, current_arch)",
            "",
            "    for architecture in architecture_list:",
            "        if current_arch in architecture.build_on or \"all\" in architecture.build_on:",
            "            return architecture.run_on",
            "",
            "    return [current_arch]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "354": [
                "Config",
                "snap_env"
            ]
        },
        "addLocation": []
    },
    "snapcraft/internal/project_loader/_env.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     env.append("
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         'PATH=\"'"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        + \":\".join("
            },
            "4": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            [\"{0}/usr/sbin\", \"{0}/usr/bin\", \"{0}/sbin\", \"{0}/bin\", \"$PATH\"]"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ).format(root)"
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        + '\"'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        + \":\".join([\"{0}/usr/sbin\", \"{0}/usr/bin\", \"{0}/sbin\", \"{0}/bin\"]).format(root)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        + '${PATH:+:$PATH}\"'"
            },
            "9": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     )"
            },
            "10": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     # Add the default LD_LIBRARY_PATH"
            }
        },
        "frontPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2017-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from typing import Dict, List",
            "",
            "from snapcraft import formatting_utils",
            "from snapcraft.internal import common, elf",
            "",
            "",
            "def runtime_env(root: str, arch_triplet: str) -> List[str]:",
            "    \"\"\"Set the environment variables required for running binaries.\"\"\"",
            "    env = []",
            "",
            "    env.append(",
            "        'PATH=\"'",
            "        + \":\".join(",
            "            [\"{0}/usr/sbin\", \"{0}/usr/bin\", \"{0}/sbin\", \"{0}/bin\", \"$PATH\"]",
            "        ).format(root)",
            "        + '\"'",
            "    )",
            "",
            "    # Add the default LD_LIBRARY_PATH",
            "    paths = common.get_library_paths(root, arch_triplet)",
            "    # Add more specific LD_LIBRARY_PATH from staged packages if necessary",
            "    paths += elf.determine_ld_library_path(root)",
            "",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"LD_LIBRARY_PATH\", paths, prepend=\"\", separator=\":\"",
            "            )",
            "        )",
            "",
            "    return env",
            "",
            "",
            "def build_env(root: str, snap_name: str, arch_triplet: str) -> List[str]:",
            "    \"\"\"Set the environment variables required for building.",
            "",
            "    This is required for the current parts installdir due to stage-packages",
            "    and also to setup the stagedir.",
            "    \"\"\"",
            "    env = []",
            "",
            "    paths = common.get_include_paths(root, arch_triplet)",
            "    if paths:",
            "        for envvar in [\"CPPFLAGS\", \"CFLAGS\", \"CXXFLAGS\"]:",
            "            env.append(",
            "                formatting_utils.format_path_variable(",
            "                    envvar, paths, prepend=\"-isystem\", separator=\" \"",
            "                )",
            "            )",
            "",
            "    paths = common.get_library_paths(root, arch_triplet)",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"LDFLAGS\", paths, prepend=\"-L\", separator=\" \"",
            "            )",
            "        )",
            "",
            "    paths = common.get_pkg_config_paths(root, arch_triplet)",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"PKG_CONFIG_PATH\", paths, prepend=\"\", separator=\":\"",
            "            )",
            "        )",
            "",
            "    return env",
            "",
            "",
            "def build_env_for_stage(stagedir: str, snap_name: str, arch_triplet: str) -> List[str]:",
            "    env = build_env(stagedir, snap_name, arch_triplet)",
            "    env.append('PERL5LIB=\"{0}/usr/share/perl5/\"'.format(stagedir))",
            "",
            "    return env",
            "",
            "",
            "def environment_to_replacements(environment: Dict[str, str]) -> Dict[str, str]:",
            "    replacements = {}  # type: Dict[str, str]",
            "    for variable, value in environment.items():",
            "        # Support both $VAR and ${VAR} syntax",
            "        replacements[\"${}\".format(variable)] = value",
            "        replacements[\"${{{}}}\".format(variable)] = value",
            "",
            "    return replacements"
        ],
        "afterPatchFile": [
            "# -*- Mode:Python; indent-tabs-mode:nil; tab-width:4 -*-",
            "#",
            "# Copyright (C) 2017-2020 Canonical Ltd",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License version 3 as",
            "# published by the Free Software Foundation.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from typing import Dict, List",
            "",
            "from snapcraft import formatting_utils",
            "from snapcraft.internal import common, elf",
            "",
            "",
            "def runtime_env(root: str, arch_triplet: str) -> List[str]:",
            "    \"\"\"Set the environment variables required for running binaries.\"\"\"",
            "    env = []",
            "",
            "    env.append(",
            "        'PATH=\"'",
            "        + \":\".join([\"{0}/usr/sbin\", \"{0}/usr/bin\", \"{0}/sbin\", \"{0}/bin\"]).format(root)",
            "        + '${PATH:+:$PATH}\"'",
            "    )",
            "",
            "    # Add the default LD_LIBRARY_PATH",
            "    paths = common.get_library_paths(root, arch_triplet)",
            "    # Add more specific LD_LIBRARY_PATH from staged packages if necessary",
            "    paths += elf.determine_ld_library_path(root)",
            "",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"LD_LIBRARY_PATH\", paths, prepend=\"\", separator=\":\"",
            "            )",
            "        )",
            "",
            "    return env",
            "",
            "",
            "def build_env(root: str, snap_name: str, arch_triplet: str) -> List[str]:",
            "    \"\"\"Set the environment variables required for building.",
            "",
            "    This is required for the current parts installdir due to stage-packages",
            "    and also to setup the stagedir.",
            "    \"\"\"",
            "    env = []",
            "",
            "    paths = common.get_include_paths(root, arch_triplet)",
            "    if paths:",
            "        for envvar in [\"CPPFLAGS\", \"CFLAGS\", \"CXXFLAGS\"]:",
            "            env.append(",
            "                formatting_utils.format_path_variable(",
            "                    envvar, paths, prepend=\"-isystem\", separator=\" \"",
            "                )",
            "            )",
            "",
            "    paths = common.get_library_paths(root, arch_triplet)",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"LDFLAGS\", paths, prepend=\"-L\", separator=\" \"",
            "            )",
            "        )",
            "",
            "    paths = common.get_pkg_config_paths(root, arch_triplet)",
            "    if paths:",
            "        env.append(",
            "            formatting_utils.format_path_variable(",
            "                \"PKG_CONFIG_PATH\", paths, prepend=\"\", separator=\":\"",
            "            )",
            "        )",
            "",
            "    return env",
            "",
            "",
            "def build_env_for_stage(stagedir: str, snap_name: str, arch_triplet: str) -> List[str]:",
            "    env = build_env(stagedir, snap_name, arch_triplet)",
            "    env.append('PERL5LIB=\"{0}/usr/share/perl5/\"'.format(stagedir))",
            "",
            "    return env",
            "",
            "",
            "def environment_to_replacements(environment: Dict[str, str]) -> Dict[str, str]:",
            "    replacements = {}  # type: Dict[str, str]",
            "    for variable, value in environment.items():",
            "        # Support both $VAR and ${VAR} syntax",
            "        replacements[\"${}\".format(variable)] = value",
            "        replacements[\"${{{}}}\".format(variable)] = value",
            "",
            "    return replacements"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "runtime_env"
            ],
            "30": [
                "runtime_env"
            ],
            "31": [
                "runtime_env"
            ],
            "32": [
                "runtime_env"
            ]
        },
        "addLocation": []
    }
}