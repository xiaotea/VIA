{
    "cps/editbooks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "                 else:"
            },
            "1": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "                     calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\"
            },
            "2": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "                         filter(db.Data.format == book_format).delete()"
            },
            "3": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    kobo_sync_status.remove_synced_book(book.id, True)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+                    if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+                        kobo_sync_status.remove_synced_book(book.id, True)"
            },
            "6": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "                 calibre_db.session.commit()"
            },
            "7": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "             except Exception as ex:"
            },
            "8": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "                 log.debug_or_exception(ex)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "from functools import wraps",
            "",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                    kobo_sync_status.remove_synced_book(book.id, True)",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "        return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "    message = _(\"You are missing permissions to delete books\")",
            "    if jsonResponse:",
            "        return json.dumps({\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                           \"type\": \"danger\",",
            "                           \"format\": \"\",",
            "                           \"message\": message})",
            "    else:",
            "        flash(message, category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "from datetime import datetime",
            "import json",
            "from shutil import copyfile",
            "from uuid import uuid4",
            "from markupsafe import escape",
            "from functools import wraps",
            "",
            "try:",
            "    from lxml.html.clean import clean_html",
            "except ImportError:",
            "    pass",
            "",
            "# Improve this to check if scholarly is available in a global way, like other pythonic libraries",
            "try:",
            "    from scholarly import scholarly",
            "    have_scholar = True",
            "except ImportError:",
            "    have_scholar = False",
            "",
            "from flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response",
            "from flask_babel import gettext as _",
            "from flask_login import current_user, login_required",
            "from sqlalchemy.exc import OperationalError, IntegrityError",
            "from sqlite3 import OperationalError as sqliteOperationalError",
            "from . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status",
            "from . import config, get_locale, ub, db",
            "from . import calibre_db",
            "from .services.worker import WorkerThread",
            "from .tasks.upload import TaskUpload",
            "from .render_template import render_title_template",
            "from .usermanagement import login_required_if_no_ano",
            "",
            "",
            "editbook = Blueprint('editbook', __name__)",
            "log = logger.create()",
            "",
            "",
            "def upload_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_upload():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def edit_required(f):",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_edit() or current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "def search_objects_remove(db_book_object, db_type, input_elements):",
            "    del_elements = []",
            "    for c_elements in db_book_object:",
            "        found = False",
            "        if db_type == 'languages':",
            "            type_elements = c_elements.lang_code",
            "        elif db_type == 'custom':",
            "            type_elements = c_elements.value",
            "        else:",
            "            type_elements = c_elements.name",
            "        for inp_element in input_elements:",
            "            if inp_element.lower() == type_elements.lower():",
            "                # if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        # if the element was not found in the new list, add it to remove list",
            "        if not found:",
            "            del_elements.append(c_elements)",
            "    return del_elements",
            "",
            "",
            "def search_objects_add(db_book_object, db_type, input_elements):",
            "    add_elements = []",
            "    for inp_element in input_elements:",
            "        found = False",
            "        for c_elements in db_book_object:",
            "            if db_type == 'languages':",
            "                type_elements = c_elements.lang_code",
            "            elif db_type == 'custom':",
            "                type_elements = c_elements.value",
            "            else:",
            "                type_elements = c_elements.name",
            "            if inp_element == type_elements:",
            "                found = True",
            "                break",
            "        if not found:",
            "            add_elements.append(inp_element)",
            "    return add_elements",
            "",
            "",
            "def remove_objects(db_book_object, db_session, del_elements):",
            "    changed = False",
            "    if len(del_elements) > 0:",
            "        for del_element in del_elements:",
            "            db_book_object.remove(del_element)",
            "            changed = True",
            "            if len(del_element.books) == 0:",
            "                db_session.delete(del_element)",
            "    return changed",
            "",
            "def add_objects(db_book_object, db_object, db_session, db_type, add_elements):",
            "    changed = False",
            "    if db_type == 'languages':",
            "        db_filter = db_object.lang_code",
            "    elif db_type == 'custom':",
            "        db_filter = db_object.value",
            "    else:",
            "        db_filter = db_object.name",
            "    for add_element in add_elements:",
            "        # check if a element with that name exists",
            "        db_element = db_session.query(db_object).filter(db_filter == add_element).first()",
            "        # if no element is found add it",
            "        # if new_element is None:",
            "        if db_type == 'author':",
            "            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")",
            "        elif db_type == 'series':",
            "            new_element = db_object(add_element, add_element)",
            "        elif db_type == 'custom':",
            "            new_element = db_object(value=add_element)",
            "        elif db_type == 'publisher':",
            "            new_element = db_object(add_element, None)",
            "        else:  # db_type should be tag or language",
            "            new_element = db_object(add_element)",
            "        if db_element is None:",
            "            changed = True",
            "            db_session.add(new_element)",
            "            db_book_object.append(new_element)",
            "        else:",
            "            db_element = create_objects_for_addition(db_element, add_element, db_type)",
            "            changed = True",
            "            # add element to book",
            "            changed = True",
            "            db_book_object.append(db_element)",
            "    return changed",
            "",
            "",
            "def create_objects_for_addition(db_element, add_element, db_type):",
            "    if db_type == 'custom':",
            "        if db_element.value != add_element:",
            "            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible",
            "    elif db_type == 'languages':",
            "        if db_element.lang_code != add_element:",
            "            db_element.lang_code = add_element",
            "    elif db_type == 'series':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element",
            "    elif db_type == 'author':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = add_element.replace('|', ',')",
            "    elif db_type == 'publisher':",
            "        if db_element.name != add_element:",
            "            db_element.name = add_element",
            "            db_element.sort = None",
            "    elif db_element.name != add_element:",
            "        db_element.name = add_element",
            "    return db_element",
            "",
            "",
            "# Modifies different Database objects, first check if elements if elements have to be deleted,",
            "# because they are no longer used, than check if elements have to be added to database",
            "def modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):",
            "    # passing input_elements not as a list may lead to undesired results",
            "    if not isinstance(input_elements, list):",
            "        raise TypeError(str(input_elements) + \" should be passed as a list\")",
            "    input_elements = [x for x in input_elements if x != '']",
            "    # we have all input element (authors, series, tags) names now",
            "    # 1. search for elements to remove",
            "    del_elements = search_objects_remove(db_book_object, db_type, input_elements)",
            "    # 2. search for elements that need to be added",
            "    add_elements = search_objects_add(db_book_object, db_type, input_elements)",
            "    # if there are elements to remove, we remove them now",
            "    changed = remove_objects(db_book_object, db_session, del_elements)",
            "    # if there are elements to add, we add them now!",
            "    if len(add_elements) > 0:",
            "        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)",
            "    return changed",
            "",
            "",
            "def modify_identifiers(input_identifiers, db_identifiers, db_session):",
            "    \"\"\"Modify Identifiers to match input information.",
            "       input_identifiers is a list of read-to-persist Identifiers objects.",
            "       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"",
            "    changed = False",
            "    error = False",
            "    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])",
            "    if len(input_identifiers) != len(input_dict):",
            "        error = True",
            "    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])",
            "    # delete db identifiers not present in input or modify them with input val",
            "    for identifier_type, identifier in db_dict.items():",
            "        if identifier_type not in input_dict.keys():",
            "            db_session.delete(identifier)",
            "            changed = True",
            "        else:",
            "            input_identifier = input_dict[identifier_type]",
            "            identifier.type = input_identifier.type",
            "            identifier.val = input_identifier.val",
            "    # add input identifiers not present in db",
            "    for identifier_type, identifier in input_dict.items():",
            "        if identifier_type not in db_dict.keys():",
            "            db_session.add(identifier)",
            "            changed = True",
            "    return changed, error",
            "",
            "@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_from_details(book_id):",
            "    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')",
            "",
            "",
            "@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])",
            "@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])",
            "@login_required",
            "def delete_book_ajax(book_id, book_format):",
            "    return delete_book_from_table(book_id, book_format, False)",
            "",
            "",
            "def delete_whole_book(book_id, book):",
            "    # delete book from Shelfs, Downloads, Read list",
            "    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()",
            "    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()",
            "    ub.delete_download(book_id)",
            "    ub.session_commit()",
            "",
            "    # check if only this book links to:",
            "    # author, language, series, tags, custom columns",
            "    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')",
            "    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')",
            "    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')",
            "    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')",
            "    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')",
            "",
            "    cc = calibre_db.session.query(db.Custom_Columns). \\",
            "        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "                elif c.datatype == 'rating':",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if len(del_cc.books) == 0:",
            "                        log.debug('remove ' + str(c.id))",
            "                        calibre_db.session.delete(del_cc)",
            "                        calibre_db.session.commit()",
            "                else:",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    log.debug('remove ' + str(c.id))",
            "                    calibre_db.session.delete(del_cc)",
            "                    calibre_db.session.commit()",
            "        else:",
            "            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],",
            "                                   calibre_db.session, 'custom')",
            "    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()",
            "",
            "",
            "def render_delete_book_result(book_format, jsonResponse, warning, book_id):",
            "    if book_format:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Format Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Format Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "    else:",
            "        if jsonResponse:",
            "            return json.dumps([warning, {\"location\": url_for('web.index'),",
            "                                         \"type\": \"success\",",
            "                                         \"format\": book_format,",
            "                                         \"message\": _('Book Successfully Deleted')}])",
            "        else:",
            "            flash(_('Book Successfully Deleted'), category=\"success\")",
            "            return redirect(url_for('web.index'))",
            "",
            "",
            "def delete_book_from_table(book_id, book_format, jsonResponse):",
            "    warning = {}",
            "    if current_user.role_delete_books():",
            "        book = calibre_db.get_book(book_id)",
            "        if book:",
            "            try:",
            "                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())",
            "                if not result:",
            "                    if jsonResponse:",
            "                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                           \"type\": \"danger\",",
            "                                           \"format\": \"\",",
            "                                           \"message\": error}])",
            "                    else:",
            "                        flash(error, category=\"error\")",
            "                        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "                if error:",
            "                    if jsonResponse:",
            "                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                                \"type\": \"warning\",",
            "                                                \"format\": \"\",",
            "                                                \"message\": error}",
            "                    else:",
            "                        flash(error, category=\"warning\")",
            "                if not book_format:",
            "                    delete_whole_book(book_id, book)",
            "                else:",
            "                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\",
            "                        filter(db.Data.format == book_format).delete()",
            "                    if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:",
            "                        kobo_sync_status.remove_synced_book(book.id, True)",
            "                calibre_db.session.commit()",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                calibre_db.session.rollback()",
            "                if jsonResponse:",
            "                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                                        \"type\": \"danger\",",
            "                                        \"format\": \"\",",
            "                                        \"message\": ex}])",
            "                else:",
            "                    flash(str(ex), category=\"error\")",
            "                    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "        else:",
            "            # book not found",
            "            log.error('Book with id \"%s\" could not be deleted: not found', book_id)",
            "        return render_delete_book_result(book_format, jsonResponse, warning, book_id)",
            "    message = _(\"You are missing permissions to delete books\")",
            "    if jsonResponse:",
            "        return json.dumps({\"location\": url_for(\"editbook.edit_book\", book_id=book_id),",
            "                           \"type\": \"danger\",",
            "                           \"format\": \"\",",
            "                           \"message\": message})",
            "    else:",
            "        flash(message, category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "",
            "def render_edit_book(book_id):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    for lang in book.languages:",
            "        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)",
            "",
            "    book = calibre_db.order_authors(book)",
            "",
            "    author_names = []",
            "    for authr in book.authors:",
            "        author_names.append(authr.name.replace('|', ','))",
            "",
            "    # Option for showing convertbook button",
            "    valid_source_formats=list()",
            "    allowed_conversion_formats = list()",
            "    kepub_possible=None",
            "    if config.config_converterpath:",
            "        for file in book.data:",
            "            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:",
            "                valid_source_formats.append(file.format.lower())",
            "    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:",
            "        kepub_possible = True",
            "        if not config.config_converterpath:",
            "            valid_source_formats.append('epub')",
            "",
            "    # Determine what formats don't already exist",
            "    if config.config_converterpath:",
            "        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]",
            "        for file in book.data:",
            "            if file.format.lower() in allowed_conversion_formats:",
            "                allowed_conversion_formats.remove(file.format.lower())",
            "    if kepub_possible:",
            "        allowed_conversion_formats.append('kepub')",
            "    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,",
            "                                 title=_(u\"edit metadata\"), page=\"editbook\",",
            "                                 conversion_formats=allowed_conversion_formats,",
            "                                 config=config,",
            "                                 source_formats=valid_source_formats)",
            "",
            "",
            "def edit_book_ratings(to_save, book):",
            "    changed = False",
            "    if to_save[\"rating\"].strip():",
            "        old_rating = False",
            "        if len(book.ratings) > 0:",
            "            old_rating = book.ratings[0].rating",
            "        ratingx2 = int(float(to_save[\"rating\"]) * 2)",
            "        if ratingx2 != old_rating:",
            "            changed = True",
            "            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()",
            "            if is_rating:",
            "                book.ratings.append(is_rating)",
            "            else:",
            "                new_rating = db.Ratings(rating=ratingx2)",
            "                book.ratings.append(new_rating)",
            "            if old_rating:",
            "                book.ratings.remove(book.ratings[0])",
            "    else:",
            "        if len(book.ratings) > 0:",
            "            book.ratings.remove(book.ratings[0])",
            "            changed = True",
            "    return changed",
            "",
            "def edit_book_tags(tags, book):",
            "    input_tags = tags.split(',')",
            "    input_tags = list(map(lambda it: it.strip(), input_tags))",
            "    # Remove duplicates",
            "    input_tags = helper.uniq(input_tags)",
            "    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')",
            "",
            "",
            "def edit_book_series(series, book):",
            "    input_series = [series.strip()]",
            "    input_series = [x for x in input_series if x != '']",
            "    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')",
            "",
            "",
            "def edit_book_series_index(series_index, book):",
            "    # Add default series_index to book",
            "    modif_date = False",
            "    series_index = series_index or '1'",
            "    if not series_index.replace('.', '', 1).isdigit():",
            "        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")",
            "        return False",
            "    if str(book.series_index) != series_index:",
            "        book.series_index = series_index",
            "        modif_date = True",
            "    return modif_date",
            "",
            "",
            "# Handle book comments/description",
            "def edit_book_comments(comments, book):",
            "    modif_date = False",
            "    if comments:",
            "        comments = clean_html(comments)",
            "    if len(book.comments):",
            "        if book.comments[0].text != comments:",
            "            book.comments[0].text = comments",
            "            modif_date = True",
            "    else:",
            "        if comments:",
            "            book.comments.append(db.Comments(text=comments, book=book.id))",
            "            modif_date = True",
            "    return modif_date",
            "",
            "",
            "def edit_book_languages(languages, book, upload=False, invalid=None):",
            "    input_languages = languages.split(',')",
            "    unknown_languages = []",
            "    if not upload:",
            "        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)",
            "    else:",
            "        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)",
            "    for l in unknown_languages:",
            "        log.error(\"'%s' is not a valid language\", l)",
            "        if isinstance(invalid, list):",
            "            invalid.append(l)",
            "        else:",
            "            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))",
            "    # ToDo: Not working correct",
            "    if upload and len(input_l) == 1:",
            "        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view",
            "        # the book it's language is set to the filter language",
            "        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":",
            "            input_l[0] = calibre_db.session.query(db.Languages). \\",
            "                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code",
            "    # Remove duplicates",
            "    input_l = helper.uniq(input_l)",
            "    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')",
            "",
            "",
            "def edit_book_publisher(publishers, book):",
            "    changed = False",
            "    if publishers:",
            "        publisher = publishers.rstrip().strip()",
            "        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):",
            "            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,",
            "                                              'publisher')",
            "    elif len(book.publishers):",
            "        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')",
            "    return changed",
            "",
            "",
            "def edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if to_save[cc_string] == 'None':",
            "        to_save[cc_string] = None",
            "    elif c.datatype == 'bool':",
            "        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0",
            "    elif c.datatype == 'comments':",
            "        to_save[cc_string] = Markup(to_save[cc_string]).unescape()",
            "        if to_save[cc_string]:",
            "            to_save[cc_string] = clean_html(to_save[cc_string])",
            "    elif c.datatype == 'datetime':",
            "        try:",
            "            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")",
            "        except ValueError:",
            "            to_save[cc_string] = db.Books.DEFAULT_PUBDATE",
            "",
            "    if to_save[cc_string] != cc_db_value:",
            "        if cc_db_value is not None:",
            "            if to_save[cc_string] is not None:",
            "                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])",
            "                changed = True",
            "            else:",
            "                del_cc = getattr(book, cc_string)[0]",
            "                getattr(book, cc_string).remove(del_cc)",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        else:",
            "            cc_class = db.cc_classes[c.id]",
            "            new_cc = cc_class(value=to_save[cc_string], book=book_id)",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "    return changed, to_save",
            "",
            "",
            "def edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):",
            "    changed = False",
            "    if c.datatype == 'rating':",
            "        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))",
            "    if to_save[cc_string].strip() != cc_db_value:",
            "        if cc_db_value is not None:",
            "            # remove old cc_val",
            "            del_cc = getattr(book, cc_string)[0]",
            "            getattr(book, cc_string).remove(del_cc)",
            "            if len(del_cc.books) == 0:",
            "                calibre_db.session.delete(del_cc)",
            "                changed = True",
            "        cc_class = db.cc_classes[c.id]",
            "        new_cc = calibre_db.session.query(cc_class).filter(",
            "            cc_class.value == to_save[cc_string].strip()).first()",
            "        # if no cc val is found add it",
            "        if new_cc is None:",
            "            new_cc = cc_class(value=to_save[cc_string].strip())",
            "            calibre_db.session.add(new_cc)",
            "            changed = True",
            "            calibre_db.session.flush()",
            "            new_cc = calibre_db.session.query(cc_class).filter(",
            "                cc_class.value == to_save[cc_string].strip()).first()",
            "        # add cc value to book",
            "        getattr(book, cc_string).append(new_cc)",
            "    return changed, to_save",
            "",
            "def edit_single_cc_data(book_id, book, column_id, to_save):",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))",
            "          .filter(db.Custom_Columns.id == column_id)",
            "          .all())",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_all_cc_data(book_id, book, to_save):",
            "    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    return edit_cc_data(book_id, book, to_save, cc)",
            "",
            "def edit_cc_data(book_id, book, to_save, cc):",
            "    changed = False",
            "    for c in cc:",
            "        cc_string = \"custom_column_\" + str(c.id)",
            "        if not c.is_multiple:",
            "            if len(getattr(book, cc_string)) > 0:",
            "                cc_db_value = getattr(book, cc_string)[0].value",
            "            else:",
            "                cc_db_value = None",
            "            if to_save[cc_string].strip():",
            "                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:",
            "                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)",
            "                else:",
            "                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)",
            "            else:",
            "                if cc_db_value is not None:",
            "                    # remove old cc_val",
            "                    del_cc = getattr(book, cc_string)[0]",
            "                    getattr(book, cc_string).remove(del_cc)",
            "                    if not del_cc.books or len(del_cc.books) == 0:",
            "                        calibre_db.session.delete(del_cc)",
            "                        changed = True",
            "        else:",
            "            input_tags = to_save[cc_string].split(',')",
            "            input_tags = list(map(lambda it: it.strip(), input_tags))",
            "            changed |= modify_database_object(input_tags,",
            "                                              getattr(book, cc_string),",
            "                                              db.cc_classes[c.id],",
            "                                              calibre_db.session,",
            "                                              'custom')",
            "    return changed",
            "",
            "def upload_single_file(request, book, book_id):",
            "    # Check and handle Uploaded file",
            "    if 'btn-upload-format' in request.files:",
            "        requested_file = request.files['btn-upload-format']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            if '.' in requested_file.filename:",
            "                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),",
            "                          category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_name = book.path.rsplit('/', 1)[-1]",
            "            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))",
            "            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)",
            "",
            "            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "            if not os.path.exists(filepath):",
            "                try:",
            "                    os.makedirs(filepath)",
            "                except OSError:",
            "                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "            try:",
            "                requested_file.save(saved_filename)",
            "            except OSError:",
            "                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            file_size = os.path.getsize(saved_filename)",
            "            is_format = calibre_db.get_book_format(book_id, file_ext.upper())",
            "",
            "            # Format entry already exists, no need to update the database",
            "            if is_format:",
            "                log.warning('Book format %s already existing', file_ext.upper())",
            "            else:",
            "                try:",
            "                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)",
            "                    calibre_db.session.add(db_format)",
            "                    calibre_db.session.commit()",
            "                    calibre_db.update_title_sort(config)",
            "                except (OperationalError, IntegrityError) as e:",
            "                    calibre_db.session.rollback()",
            "                    log.error('Database error: %s', e)",
            "                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "                    return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "            # Queue uploader info",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))",
            "            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)",
            "            WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "            return uploader.process(",
            "                saved_filename, *os.path.splitext(requested_file.filename),",
            "                rarExecutable=config.config_rarfile_location)",
            "",
            "",
            "def upload_cover(request, book):",
            "    if 'btn-upload-cover' in request.files:",
            "        requested_file = request.files['btn-upload-cover']",
            "        # check for empty request",
            "        if requested_file.filename != '':",
            "            if not current_user.role_upload():",
            "                abort(403)",
            "            ret, message = helper.save_cover(requested_file, book.path)",
            "            if ret is True:",
            "                return True",
            "            else:",
            "                flash(message, category=\"error\")",
            "                return False",
            "    return None",
            "",
            "",
            "def handle_title_on_edit(book, book_title):",
            "    # handle book title",
            "    book_title = book_title.rstrip().strip()",
            "    if book.title != book_title:",
            "        if book_title == '':",
            "            book_title = _(u'Unknown')",
            "        book.title = book_title",
            "        return True",
            "    return False",
            "",
            "",
            "def handle_author_on_edit(book, author_name, update_stored=True):",
            "    # handle author(s)",
            "    input_authors = author_name.split('&')",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')",
            "",
            "    # Search for each author if author is in database, if not, author name and sorted author name is generated new",
            "    # everything then is assembled for sorted author field in database",
            "    sort_authors_list = list()",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            stored_author = helper.get_sorted_author(inp)",
            "        else:",
            "            stored_author = stored_author.sort",
            "        sort_authors_list.append(helper.get_sorted_author(stored_author))",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    if book.author_sort != sort_authors and update_stored:",
            "        book.author_sort = sort_authors",
            "        change = True",
            "    return input_authors, change",
            "",
            "",
            "@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_book(book_id):",
            "    modif_date = False",
            "",
            "    # create the function for sorting...",
            "    try:",
            "        calibre_db.update_title_sort(config)",
            "    except sqliteOperationalError as e:",
            "        log.debug_or_exception(e)",
            "        calibre_db.session.rollback()",
            "",
            "    # Show form",
            "    if request.method != 'POST':",
            "        return render_edit_book(book_id)",
            "",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "",
            "    # Book not found",
            "    if not book:",
            "        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")",
            "        return redirect(url_for(\"web.index\"))",
            "",
            "    meta = upload_single_file(request, book, book_id)",
            "    if upload_cover(request, book) is True:",
            "        book.has_cover = 1",
            "        modif_date = True",
            "    try:",
            "        to_save = request.form.to_dict()",
            "        merge_metadata(to_save, meta)",
            "        # Update book",
            "        edited_books_id = None",
            "",
            "        # handle book title",
            "        title_change = handle_title_on_edit(book, to_save[\"book_title\"])",
            "",
            "        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])",
            "        if authorchange or title_change:",
            "            edited_books_id = book.id",
            "            modif_date = True",
            "",
            "        if config.config_use_google_drive:",
            "            gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "        error = False",
            "        if edited_books_id:",
            "            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "",
            "        if not error:",
            "            if \"cover_url\" in to_save:",
            "                if to_save[\"cover_url\"]:",
            "                    if not current_user.role_upload():",
            "                        return \"\", (403)",
            "                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):",
            "                        book.has_cover = 0",
            "                    else:",
            "                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)",
            "                        if result is True:",
            "                            book.has_cover = 1",
            "                            modif_date = True",
            "                        else:",
            "                            flash(error, category=\"error\")",
            "",
            "            # Add default series_index to book",
            "            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)",
            "            # Handle book comments/description",
            "            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)",
            "            # Handle identifiers",
            "            input_identifiers = identifier_list(to_save, book)",
            "            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)",
            "            if warning:",
            "                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")",
            "            modif_date |= modification",
            "            # Handle book tags",
            "            modif_date |= edit_book_tags(to_save['tags'], book)",
            "            # Handle book series",
            "            modif_date |= edit_book_series(to_save[\"series\"], book)",
            "            # handle book publisher",
            "            modif_date |= edit_book_publisher(to_save['publisher'], book)",
            "            # handle book languages",
            "            modif_date |= edit_book_languages(to_save['languages'], book)",
            "            # handle book ratings",
            "            modif_date |= edit_book_ratings(to_save, book)",
            "            # handle cc data",
            "            modif_date |= edit_all_cc_data(book_id, book, to_save)",
            "",
            "            if to_save[\"pubdate\"]:",
            "                try:",
            "                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")",
            "                except ValueError:",
            "                    book.pubdate = db.Books.DEFAULT_PUBDATE",
            "            else:",
            "                book.pubdate = db.Books.DEFAULT_PUBDATE",
            "",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "                kobo_sync_status.remove_synced_book(edited_books_id, all=True)",
            "",
            "            calibre_db.session.merge(book)",
            "            calibre_db.session.commit()",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "            if \"detail_view\" in to_save:",
            "                return redirect(url_for('web.show_book', book_id=book.id))",
            "            else:",
            "                flash(_(\"Metadata successfully updated\"), category=\"success\")",
            "                return render_edit_book(book_id)",
            "        else:",
            "            calibre_db.session.rollback()",
            "            flash(error, category=\"error\")",
            "            return render_edit_book(book_id)",
            "    except ValueError as e:",
            "        calibre_db.session.rollback()",
            "        flash(str(e), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "    except Exception as ex:",
            "        log.debug_or_exception(ex)",
            "        calibre_db.session.rollback()",
            "        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")",
            "        return redirect(url_for('web.show_book', book_id=book.id))",
            "",
            "",
            "def merge_metadata(to_save, meta):",
            "    if to_save['author_name'] == _(u'Unknown'):",
            "        to_save['author_name'] = ''",
            "    if to_save['book_title'] == _(u'Unknown'):",
            "        to_save['book_title'] = ''",
            "    for s_field, m_field in [",
            "            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),",
            "            ('series_index', 'series_id'), ('languages', 'languages'),",
            "            ('book_title', 'title')]:",
            "        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')",
            "    to_save[\"description\"] = to_save[\"description\"] or Markup(",
            "        getattr(meta, 'description', '')).unescape()",
            "",
            "",
            "def identifier_list(to_save, book):",
            "    \"\"\"Generate a list of Identifiers from form information\"\"\"",
            "    id_type_prefix = 'identifier-type-'",
            "    id_val_prefix = 'identifier-val-'",
            "    result = []",
            "    for type_key, type_value in to_save.items():",
            "        if not type_key.startswith(id_type_prefix):",
            "            continue",
            "        val_key = id_val_prefix + type_key[len(id_type_prefix):]",
            "        if val_key not in to_save.keys():",
            "            continue",
            "        result.append(db.Identifiers(to_save[val_key], type_value, book.id))",
            "    return result",
            "",
            "",
            "def prepare_authors_on_upload(title, authr):",
            "    if title != _(u'Unknown') and authr != _(u'Unknown'):",
            "        entry = calibre_db.check_exists_book(authr, title)",
            "        if entry:",
            "            log.info(\"Uploaded book probably exists in library\")",
            "            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")",
            "                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")",
            "",
            "    # handle authors",
            "    input_authors = authr.split('&')",
            "    # handle_authors(input_authors)",
            "    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))",
            "    # Remove duplicates in authors list",
            "    input_authors = helper.uniq(input_authors)",
            "",
            "    # we have all author names now",
            "    if input_authors == ['']:",
            "        input_authors = [_(u'Unknown')]  # prevent empty Author",
            "",
            "    sort_authors_list = list()",
            "    db_author = None",
            "    for inp in input_authors:",
            "        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()",
            "        if not stored_author:",
            "            if not db_author:",
            "                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")",
            "                calibre_db.session.add(db_author)",
            "                calibre_db.session.commit()",
            "            sort_author = helper.get_sorted_author(inp)",
            "        else:",
            "            if not db_author:",
            "                db_author = stored_author",
            "            sort_author = stored_author.sort",
            "        sort_authors_list.append(sort_author)",
            "    sort_authors = ' & '.join(sort_authors_list)",
            "    return sort_authors, input_authors, db_author",
            "",
            "",
            "def create_book_on_upload(modif_date, meta):",
            "    title = meta.title",
            "    authr = meta.author",
            "    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)",
            "",
            "    title_dir = helper.get_valid_filename(title)",
            "    author_dir = helper.get_valid_filename(db_author.name)",
            "",
            "    # combine path and normalize path from windows systems",
            "    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')",
            "",
            "    # Calibre adds books with utc as timezone",
            "    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),",
            "                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")",
            "",
            "    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,",
            "                                         'author')",
            "",
            "    # Add series_index to book",
            "    modif_date |= edit_book_series_index(meta.series_id, db_book)",
            "",
            "    # add languages",
            "    invalid=[]",
            "    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)",
            "    if invalid:",
            "        for l in invalid:",
            "            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")",
            "",
            "    # handle tags",
            "    modif_date |= edit_book_tags(meta.tags, db_book)",
            "",
            "    # handle publisher",
            "    modif_date |= edit_book_publisher(meta.publisher, db_book)",
            "",
            "    # handle series",
            "    modif_date |= edit_book_series(meta.series, db_book)",
            "",
            "    # Add file to book",
            "    file_size = os.path.getsize(meta.file_path)",
            "    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)",
            "    db_book.data.append(db_data)",
            "    calibre_db.session.add(db_book)",
            "",
            "    # flush content, get db_book.id available",
            "    calibre_db.session.flush()",
            "    return db_book, input_authors, title_dir",
            "",
            "def file_handling_on_upload(requested_file):",
            "    # check if file extension is correct",
            "    if '.' in requested_file.filename:",
            "        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()",
            "        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:",
            "            flash(",
            "                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",",
            "                  ext=file_ext), category=\"error\")",
            "            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    else:",
            "        flash(_('File to be uploaded must have an extension'), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "    # extract metadata from file",
            "    try:",
            "        meta = uploader.upload(requested_file, config.config_rarfile_location)",
            "    except (IOError, OSError):",
            "        log.error(\"File %s could not saved to temp dir\", requested_file.filename)",
            "        flash(_(u\"File %(filename)s could not saved to temp dir\",",
            "                filename=requested_file.filename), category=\"error\")",
            "        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "    return meta, None",
            "",
            "",
            "def move_coverfile(meta, db_book):",
            "    # move cover to final directory, including book id",
            "    if meta.cover:",
            "        coverfile = meta.cover",
            "    else:",
            "        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')",
            "    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")",
            "    try:",
            "        copyfile(coverfile, new_coverpath)",
            "        if meta.cover:",
            "            os.unlink(meta.cover)",
            "    except OSError as e:",
            "        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)",
            "        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,",
            "                error=e),",
            "              category=\"error\")",
            "",
            "",
            "@editbook.route(\"/upload\", methods=[\"POST\"])",
            "@login_required_if_no_ano",
            "@upload_required",
            "def upload():",
            "    if not config.config_uploading:",
            "        abort(404)",
            "    if request.method == 'POST' and 'btn-upload' in request.files:",
            "        for requested_file in request.files.getlist(\"btn-upload\"):",
            "            try:",
            "                modif_date = False",
            "                # create the function for sorting...",
            "                calibre_db.update_title_sort(config)",
            "                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))",
            "",
            "                meta, error = file_handling_on_upload(requested_file)",
            "                if error:",
            "                    return error",
            "",
            "                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)",
            "",
            "                # Comments needs book id therefore only possible after flush",
            "                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)",
            "",
            "                book_id = db_book.id",
            "                title = db_book.title",
            "",
            "                error = helper.update_dir_structure_file(book_id,",
            "                                                   config.config_calibre_dir,",
            "                                                   input_authors[0],",
            "                                                   meta.file_path,",
            "                                                   title_dir + meta.extension.lower())",
            "",
            "                move_coverfile(meta, db_book)",
            "",
            "                # save data to database, reread data",
            "                calibre_db.session.commit()",
            "",
            "                if config.config_use_google_drive:",
            "                    gdriveutils.updateGdriveCalibreFromLocal()",
            "                if error:",
            "                    flash(error, category=\"error\")",
            "                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))",
            "                uploadText = _(u\"File %(file)s uploaded\", file=link)",
            "                WorkerThread.add(current_user.name, TaskUpload(uploadText))",
            "",
            "                if len(request.files.getlist(\"btn-upload\")) < 2:",
            "                    if current_user.role_edit() or current_user.role_admin():",
            "                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "                    else:",
            "                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}",
            "                        return Response(json.dumps(resp), mimetype='application/json')",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")",
            "        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')",
            "",
            "@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def convert_bookformat(book_id):",
            "    # check to see if we have form fields to work with -  if not send user back",
            "    book_format_from = request.form.get('book_format_from', None)",
            "    book_format_to = request.form.get('book_format_to', None)",
            "",
            "    if (book_format_from is None) or (book_format_to is None):",
            "        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")",
            "        return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)",
            "    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),",
            "                                     book_format_to.upper(), current_user.name)",
            "",
            "    if rtn is None:",
            "        flash(_(u\"Book successfully queued for converting to %(book_format)s\",",
            "                    book_format=book_format_to),",
            "                    category=\"success\")",
            "    else:",
            "        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")",
            "    return redirect(url_for('editbook.edit_book', book_id=book_id))",
            "",
            "@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")",
            "@login_required",
            "def table_get_custom_enum(c_id):",
            "    ret = list()",
            "    cc = (calibre_db.session.query(db.Custom_Columns)",
            "              .filter(db.Custom_Columns.id == c_id)",
            "              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())",
            "    ret.append({'value': \"\", 'text': \"\"})",
            "    for idx, en in enumerate(cc.get_display_dict()['enum_values']):",
            "        ret.append({'value': en, 'text': en})",
            "    return json.dumps(ret)",
            "",
            "",
            "@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])",
            "@login_required_if_no_ano",
            "@edit_required",
            "def edit_list_book(param):",
            "    vals = request.form.to_dict()",
            "    book = calibre_db.get_book(vals['pk'])",
            "    ret = \"\"",
            "    if param =='series_index':",
            "        edit_book_series_index(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')",
            "    elif param =='tags':",
            "        edit_book_tags(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),",
            "                       mimetype='application/json')",
            "    elif param =='series':",
            "        edit_book_series(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),",
            "                       mimetype='application/json')",
            "    elif param =='publishers':",
            "        edit_book_publisher(vals['value'], book)",
            "        ret =  Response(json.dumps({'success': True,",
            "                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),",
            "                       mimetype='application/json')",
            "    elif param =='languages':",
            "        invalid = list()",
            "        edit_book_languages(vals['value'], book, invalid=invalid)",
            "        if invalid:",
            "            ret = Response(json.dumps({'success': False,",
            "                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),",
            "                           mimetype='application/json')",
            "        else:",
            "            lang_names = list()",
            "            for lang in book.languages:",
            "                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))",
            "            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),",
            "                            mimetype='application/json')",
            "    elif param =='author_sort':",
            "        book.author_sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),",
            "                       mimetype='application/json')",
            "    elif param == 'title':",
            "        sort = book.sort",
            "        handle_title_on_edit(book, vals.get('value', \"\"))",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),",
            "                       mimetype='application/json')",
            "    elif param =='sort':",
            "        book.sort = vals['value']",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),",
            "                       mimetype='application/json')",
            "    elif param =='comments':",
            "        edit_book_comments(vals['value'], book)",
            "        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),",
            "                       mimetype='application/json')",
            "    elif param =='authors':",
            "        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")",
            "        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])",
            "        ret = Response(json.dumps({'success': True,",
            "                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),",
            "                       mimetype='application/json')",
            "    elif param.startswith(\"custom_column_\"):",
            "        new_val = dict()",
            "        new_val[param] = vals['value']",
            "        edit_single_cc_data(book.id, book, param[14:], new_val)",
            "        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),",
            "                       mimetype='application/json')",
            "",
            "    book.last_modified = datetime.utcnow()",
            "    try:",
            "        calibre_db.session.commit()",
            "        # revert change for sort if automatic fields link is deactivated",
            "        if param == 'title' and vals.get('checkT') == \"false\":",
            "            book.sort = sort",
            "            calibre_db.session.commit()",
            "    except (OperationalError, IntegrityError) as e:",
            "        calibre_db.session.rollback()",
            "        log.error(\"Database error: %s\", e)",
            "    return ret",
            "",
            "",
            "@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")",
            "@login_required",
            "def get_sorted_entry(field, bookid):",
            "    if field in ['title', 'authors', 'sort', 'author_sort']:",
            "        book = calibre_db.get_filtered_book(bookid)",
            "        if book:",
            "            if field == 'title':",
            "                return json.dumps({'sort': book.sort})",
            "            elif field == 'authors':",
            "                return json.dumps({'author_sort': book.author_sort})",
            "            if field == 'sort':",
            "                return json.dumps({'sort': book.title})",
            "            if field == 'author_sort':",
            "                return json.dumps({'author_sort': book.author})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def simulate_merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    if vals:",
            "        to_book = calibre_db.get_book(vals[0]).title",
            "        vals.pop(0)",
            "        if to_book:",
            "            for book_id in vals:",
            "                from_book = []",
            "                from_book.append(calibre_db.get_book(book_id).title)",
            "            return json.dumps({'to': to_book, 'from': from_book})",
            "    return \"\"",
            "",
            "",
            "@editbook.route(\"/ajax/mergebooks\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def merge_list_book():",
            "    vals = request.get_json().get('Merge_books')",
            "    to_file = list()",
            "    if vals:",
            "        # load all formats from target book",
            "        to_book = calibre_db.get_book(vals[0])",
            "        vals.pop(0)",
            "        if to_book:",
            "            for file in to_book.data:",
            "                to_file.append(file.format)",
            "            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\",
            "                      helper.get_valid_filename(to_book.authors[0].name)",
            "            for book_id in vals:",
            "                from_book = calibre_db.get_book(book_id)",
            "                if from_book:",
            "                    for element in from_book.data:",
            "                        if element.format not in to_file:",
            "                            # create new data entry with: book_id, book_format, uncompressed_size, name",
            "                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         to_book.path,",
            "                                                                         to_name + \".\" + element.format.lower()))",
            "                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,",
            "                                                                         from_book.path,",
            "                                                                         element.name + \".\" + element.format.lower()))",
            "                            copyfile(filepath_old, filepath_new)",
            "                            to_book.data.append(db.Data(to_book.id,",
            "                                                        element.format,",
            "                                                        element.uncompressed_size,",
            "                                                        to_name))",
            "                    delete_book_from_table(from_book.id,\"\", True)",
            "                    return json.dumps({'success': True})",
            "    return \"\"",
            "",
            "@editbook.route(\"/ajax/xchange\", methods=['POST'])",
            "@login_required",
            "@edit_required",
            "def table_xchange_author_title():",
            "    vals = request.get_json().get('xchange')",
            "    if vals:",
            "        for val in vals:",
            "            modif_date = False",
            "            book = calibre_db.get_book(val)",
            "            authors = book.title",
            "            entries = calibre_db.order_authors(book)",
            "            author_names = []",
            "            for authr in entries.authors:",
            "                author_names.append(authr.name.replace('|', ','))",
            "",
            "            title_change = handle_title_on_edit(book, \" \".join(author_names))",
            "            input_authors, authorchange = handle_author_on_edit(book, authors)",
            "            if authorchange or title_change:",
            "                edited_books_id = book.id",
            "                modif_date = True",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "",
            "            if edited_books_id:",
            "                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])",
            "            if modif_date:",
            "                book.last_modified = datetime.utcnow()",
            "            try:",
            "                calibre_db.session.commit()",
            "            except (OperationalError, IntegrityError) as e:",
            "                calibre_db.session.rollback()",
            "                log.error(\"Database error: %s\", e)",
            "                return json.dumps({'success': False})",
            "",
            "            if config.config_use_google_drive:",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "        return json.dumps({'success': True})",
            "    return \"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "344": [
                "delete_book_from_table"
            ]
        },
        "addLocation": []
    },
    "cps/helper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " #  You should have received a copy of the GNU General Public License"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " #  along with this program. If not, see <http://www.gnu.org/licenses/>."
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import sys"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import io"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import mimetypes"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import re"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import shutil"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import time"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+import socket"
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " import unicodedata"
            },
            "12": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from datetime import datetime, timedelta"
            },
            "13": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from tempfile import gettempdir"
            },
            "14": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "16": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import requests"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from babel.dates import format_datetime"
            },
            "19": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from babel.units import format_unit"
            },
            "20": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from flask import send_from_directory, make_response, redirect, abort, url_for"
            },
            "21": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 584,
                "PatchRowcode": " # saves book cover from url"
            },
            "22": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 585,
                "PatchRowcode": " def save_cover_from_url(url, book_path):"
            },
            "23": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "     try:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 587,
                "PatchRowcode": "+        # 127.0.x.x, localhost, [::1], [::ffff:7f00:1]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+        ip = socket.getaddrinfo(urlparse(url).hostname, 0)[0][4][0]"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 589,
                "PatchRowcode": "+        if ip.startswith(\"127.\") or ip.startswith('::ffff:7f') or ip == \"::1\":"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 590,
                "PatchRowcode": "+            log.error(\"Localhost was accessed for cover upload\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 591,
                "PatchRowcode": "+            return False, _(\"You are not allowed to access localhost for cover uploads\")"
            },
            "29": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "         img = requests.get(url, timeout=(10, 200))      # ToDo: Error Handling"
            },
            "30": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "         img.raise_for_status()"
            },
            "31": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "         return save_cover(img, book_path)"
            },
            "32": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except (requests.exceptions.HTTPError,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+    except (socket.gaierror,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+            requests.exceptions.HTTPError,"
            },
            "35": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "             requests.exceptions.ConnectionError,"
            },
            "36": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "             requests.exceptions.Timeout) as ex:"
            },
            "37": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 599,
                "PatchRowcode": "         log.info(u'Cover Download Error %s', ex)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,",
            "#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "import io",
            "import mimetypes",
            "import re",
            "import shutil",
            "import time",
            "import unicodedata",
            "from datetime import datetime, timedelta",
            "from tempfile import gettempdir",
            "",
            "import requests",
            "from babel.dates import format_datetime",
            "from babel.units import format_unit",
            "from flask import send_from_directory, make_response, redirect, abort, url_for",
            "from flask_babel import gettext as _",
            "from flask_login import current_user",
            "from sqlalchemy.sql.expression import true, false, and_, text, func",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import generate_password_hash",
            "from markupsafe import escape",
            "from urllib.parse import quote",
            "",
            "try:",
            "    import unidecode",
            "    use_unidecode = True",
            "except ImportError:",
            "    use_unidecode = False",
            "",
            "from . import calibre_db",
            "from .tasks.convert import TaskConvert",
            "from . import logger, config, get_locale, db, ub",
            "from . import gdriveutils as gd",
            "from .constants import STATIC_DIR as _STATIC_DIR",
            "from .subproc_wrapper import process_wait",
            "from .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS",
            "from .tasks.mail import TaskEmail",
            "",
            "log = logger.create()",
            "",
            "try:",
            "    from wand.image import Image",
            "    from wand.exceptions import MissingDelegateError, BlobError",
            "    use_IM = True",
            "except (ImportError, RuntimeError) as e:",
            "    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)",
            "    use_IM = False",
            "    MissingDelegateError = BaseException",
            "",
            "",
            "# Convert existing book entry to new format",
            "def convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):",
            "    book = calibre_db.get_book(book_id)",
            "    data = calibre_db.get_book_format(book.id, old_book_format)",
            "    file_path = os.path.join(calibrepath, book.path, data.name)",
            "    if not data:",
            "        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)",
            "        log.error(\"convert_book_format: %s\", error_message)",
            "        return error_message",
            "    if config.config_use_google_drive:",
            "        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):",
            "            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",",
            "                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())",
            "            return error_message",
            "    else:",
            "        if not os.path.exists(file_path + \".\" + old_book_format.lower()):",
            "            error_message = _(u\"%(format)s not found: %(fn)s\",",
            "                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())",
            "            return error_message",
            "    # read settings and append converter task to queue",
            "    if kindle_mail:",
            "        settings = config.get_mail_settings()",
            "        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail",
            "        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')",
            "    else:",
            "        settings = dict()",
            "    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss",
            "    txt = u\"{} -> {}: {}\".format(",
            "           old_book_format.upper(),",
            "           new_book_format.upper(),",
            "           link)",
            "    settings['old_book_format'] = old_book_format",
            "    settings['new_book_format'] = new_book_format",
            "    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))",
            "    return None",
            "",
            "",
            "def send_test_mail(kindle_mail, user_name):",
            "    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,",
            "                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),",
            "                                          _(u'This e-mail has been sent via Calibre-Web.')))",
            "    return",
            "",
            "",
            "# Send registration email or password reset email, depending on parameter resend (False means welcome email)",
            "def send_registration_mail(e_mail, user_name, default_password, resend=False):",
            "    txt = \"Hello %s!\\r\\n\" % user_name",
            "    if not resend:",
            "        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"",
            "    txt += \"Please log in to your account using the following informations:\\r\\n\"",
            "    txt += \"User name: %s\\r\\n\" % user_name",
            "    txt += \"Password: %s\\r\\n\" % default_password",
            "    txt += \"Don't forget to change your password after first login.\\r\\n\"",
            "    txt += \"Sincerely\\r\\n\\r\\n\"",
            "    txt += \"Your Calibre-Web team\"",
            "    WorkerThread.add(None, TaskEmail(",
            "        subject=_(u'Get Started with Calibre-Web'),",
            "        filepath=None,",
            "        attachment=None,",
            "        settings=config.get_mail_settings(),",
            "        recipient=e_mail,",
            "        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),",
            "        text=txt",
            "    ))",
            "    return",
            "",
            "",
            "def check_send_to_kindle_with_converter(formats):",
            "    bookformats = list()",
            "    if 'EPUB' in formats and 'MOBI' not in formats:",
            "        bookformats.append({'format': 'Mobi',",
            "                            'convert': 1,",
            "                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
            "                                      orig='Epub',",
            "                                      format='Mobi')})",
            "    if 'AZW3' in formats and not 'MOBI' in formats:",
            "        bookformats.append({'format': 'Mobi',",
            "                            'convert': 2,",
            "                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
            "                                      orig='Azw3',",
            "                                      format='Mobi')})",
            "    return bookformats",
            "",
            "",
            "def check_send_to_kindle(entry):",
            "    \"\"\"",
            "        returns all available book formats for sending to Kindle",
            "    \"\"\"",
            "    formats = list()",
            "    bookformats = list()",
            "    if len(entry.data):",
            "        for ele in iter(entry.data):",
            "            if ele.uncompressed_size < config.mail_size:",
            "                formats.append(ele.format)",
            "        if 'MOBI' in formats:",
            "            bookformats.append({'format': 'Mobi',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Mobi')})",
            "        if 'PDF' in formats:",
            "            bookformats.append({'format': 'Pdf',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Pdf')})",
            "        if 'AZW' in formats:",
            "            bookformats.append({'format': 'Azw',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Azw')})",
            "        if config.config_converterpath:",
            "            bookformats.extend(check_send_to_kindle_with_converter(formats))",
            "        return bookformats",
            "    else:",
            "        log.error(u'Cannot find book entry %d', entry.id)",
            "        return None",
            "",
            "",
            "# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return",
            "# list with supported formats",
            "def check_read_formats(entry):",
            "    EXTENSIONS_READER = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}",
            "    bookformats = list()",
            "    if len(entry.data):",
            "        for ele in iter(entry.data):",
            "            if ele.format.upper() in EXTENSIONS_READER:",
            "                bookformats.append(ele.format.lower())",
            "    return bookformats",
            "",
            "",
            "# Files are processed in the following order/priority:",
            "# 1: If Mobi file is existing, it's directly send to kindle email,",
            "# 2: If Epub file is existing, it's converted and send to kindle email,",
            "# 3: If Pdf file is existing, it's directly send to kindle email",
            "def send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):",
            "    \"\"\"Send email with attachments\"\"\"",
            "    book = calibre_db.get_book(book_id)",
            "",
            "    if convert == 1:",
            "        # returns None if success, otherwise errormessage",
            "        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)",
            "    if convert == 2:",
            "        # returns None if success, otherwise errormessage",
            "        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)",
            "",
            "    for entry in iter(book.data):",
            "        if entry.format.upper() == book_format.upper():",
            "            converted_file_name = entry.name + '.' + book_format.lower()",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))",
            "            EmailText = _(u\"%(book)s send to Kindle\", book=link)",
            "            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,",
            "                             config.get_mail_settings(), kindle_mail,",
            "                             EmailText, _(u'This e-mail has been sent via Calibre-Web.')))",
            "            return",
            "    return _(u\"The requested file could not be read. Maybe wrong permissions?\")",
            "",
            "",
            "def get_valid_filename(value, replace_whitespace=True):",
            "    \"\"\"",
            "    Returns the given string converted to a string that can be used for a clean",
            "    filename. Limits num characters to 128 max.",
            "    \"\"\"",
            "    if value[-1:] == u'.':",
            "        value = value[:-1]+u'_'",
            "    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')",
            "    if use_unidecode:",
            "        if config.config_unicode_filename:",
            "            value = (unidecode.unidecode(value))",
            "    else:",
            "        value = value.replace(u'\u00a7', u'SS')",
            "        value = value.replace(u'\u00df', u'ss')",
            "        value = unicodedata.normalize('NFKD', value)",
            "        re_slugify = re.compile(r'[\\W\\s-]', re.UNICODE)",
            "        value = re_slugify.sub('', value)",
            "    if replace_whitespace:",
            "        #  *+:\\\"/<>? are replaced by _",
            "        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)",
            "        # pipe has to be replaced with comma",
            "        value = re.sub(r'[|]+', u',', value, flags=re.U)",
            "    value = value[:128].strip()",
            "    if not value:",
            "        raise ValueError(\"Filename cannot be empty\")",
            "    return value",
            "",
            "",
            "def split_authors(values):",
            "    authors_list = []",
            "    for value in values:",
            "        authors = re.split('[&;]', value)",
            "        for author in authors:",
            "            commas = author.count(',')",
            "            if commas == 1:",
            "                author_split = author.split(',')",
            "                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())",
            "            elif commas > 1:",
            "                authors_list.extend([x.strip() for x in author.split(',')])",
            "            else:",
            "                authors_list.append(author.strip())",
            "    return authors_list",
            "",
            "",
            "def get_sorted_author(value):",
            "    try:",
            "        if ',' not in value:",
            "            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]",
            "            combined = \"(\" + \")|(\".join(regexes) + \")\"",
            "            value = value.split(\" \")",
            "            if re.match(combined, value[-1].upper()):",
            "                if len(value) > 1:",
            "                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]",
            "                else:",
            "                    value2 = value[0]",
            "            elif len(value) == 1:",
            "                value2 = value[0]",
            "            else:",
            "                value2 = value[-1] + \", \" + \" \".join(value[:-1])",
            "        else:",
            "            value2 = value",
            "    except Exception as ex:",
            "        log.error(\"Sorting author %s failed: %s\", value, ex)",
            "        if isinstance(list, value2):",
            "            value2 = value[0]",
            "        else:",
            "            value2 = value",
            "    return value2",
            "",
            "",
            "# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false",
            "def delete_book_file(book, calibrepath, book_format=None):",
            "    # check that path is 2 elements deep, check that target path has no subfolders",
            "    if book.path.count('/') == 1:",
            "        path = os.path.join(calibrepath, book.path)",
            "        if book_format:",
            "            for file in os.listdir(path):",
            "                if file.upper().endswith(\".\"+book_format):",
            "                    os.remove(os.path.join(path, file))",
            "            return True, None",
            "        else:",
            "            if os.path.isdir(path):",
            "                try:",
            "                    for root, folders, files in os.walk(path):",
            "                        for f in files:",
            "                            os.unlink(os.path.join(root, f))",
            "                        if len(folders):",
            "                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,",
            "                                        book.path, folders))",
            "                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",",
            "                                           id=book.id,",
            "                                           path=book.path)",
            "                    shutil.rmtree(path)",
            "                except (IOError, OSError) as e:",
            "                    log.error(\"Deleting book %s failed: %s\", book.id, e)",
            "                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=e)",
            "                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])",
            "                if not os.listdir(authorpath):",
            "                    try:",
            "                        shutil.rmtree(authorpath)",
            "                    except (IOError, OSError) as e:",
            "                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, e)",
            "                return True, None",
            "",
            "    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",",
            "              book.id, book.path)",
            "    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",",
            "                   id=book.id,",
            "                   path=book.path)",
            "",
            "",
            "# Moves files in file storage during author/title rename, or from temp dir to file storage",
            "def update_dir_structure_file(book_id, calibrepath, first_author, orignal_filepath, db_filename):",
            "    # get book database entry from id, if original path overwrite source with original_filepath",
            "    localbook = calibre_db.get_book(book_id)",
            "    if orignal_filepath:",
            "        path = orignal_filepath",
            "    else:",
            "        path = os.path.join(calibrepath, localbook.path)",
            "",
            "    # Create (current) authordir and titledir from database",
            "    authordir = localbook.path.split('/')[0]",
            "    titledir = localbook.path.split('/')[1]",
            "",
            "    # Create new_authordir from parameter or from database",
            "    # Create new titledir from database and add id",
            "    if first_author:",
            "        new_authordir = get_valid_filename(first_author)",
            "    else:",
            "        new_authordir = get_valid_filename(localbook.authors[0].name)",
            "    new_titledir = get_valid_filename(localbook.title) + \" (\" + str(book_id) + \")\"",
            "",
            "    if titledir != new_titledir or authordir != new_authordir or orignal_filepath:",
            "        new_path = os.path.join(calibrepath, new_authordir, new_titledir)",
            "        new_name = get_valid_filename(localbook.title) + ' - ' + get_valid_filename(new_authordir)",
            "        try:",
            "            if orignal_filepath:",
            "                if not os.path.isdir(new_path):",
            "                    os.makedirs(new_path)",
            "                shutil.move(os.path.normcase(path), os.path.normcase(os.path.join(new_path, db_filename)))",
            "                log.debug(\"Moving title: %s to %s/%s\", path, new_path, new_name)",
            "                # Check new path is not valid path",
            "            else:",
            "                if not os.path.exists(new_path):",
            "                    # move original path to new path",
            "                    log.debug(\"Moving title: %s to %s\", path, new_path)",
            "                    shutil.move(os.path.normcase(path), os.path.normcase(new_path))",
            "                else: # path is valid copy only files to new location (merge)",
            "                    log.info(\"Moving title: %s into existing: %s\", path, new_path)",
            "                    # Take all files and subfolder from old path (strange command)",
            "                    for dir_name, __, file_list in os.walk(path):",
            "                        for file in file_list:",
            "                            shutil.move(os.path.normcase(os.path.join(dir_name, file)),",
            "                                            os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))",
            "                            # os.unlink(os.path.normcase(os.path.join(dir_name, file)))",
            "            # change location in database to new author/title path",
            "            localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\','/')",
            "        except (OSError) as ex:",
            "            log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)",
            "            log.debug(ex, exc_info=True)",
            "            return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",",
            "                     src=path, dest=new_path, error=str(ex))",
            "",
            "        # Rename all files from old names to new names",
            "        try:",
            "            for file_format in localbook.data:",
            "                shutil.move(os.path.normcase(",
            "                    os.path.join(new_path, file_format.name + '.' + file_format.format.lower())),",
            "                    os.path.normcase(os.path.join(new_path, new_name + '.' + file_format.format.lower())))",
            "                file_format.name = new_name",
            "            if not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:",
            "                shutil.rmtree(os.path.dirname(path))",
            "        except (OSError) as ex:",
            "            log.error(\"Rename file in path %s to %s: %s\", new_path, new_name, ex)",
            "            log.debug(ex, exc_info=True)",
            "            return _(\"Rename file in path '%(src)s' to '%(dest)s' failed with error: %(error)s\",",
            "                     src=new_path, dest=new_name, error=str(ex))",
            "    return False",
            "",
            "def update_dir_structure_gdrive(book_id, first_author):",
            "    error = False",
            "    book = calibre_db.get_book(book_id)",
            "    path = book.path",
            "",
            "    authordir = book.path.split('/')[0]",
            "    if first_author:",
            "        new_authordir = get_valid_filename(first_author)",
            "    else:",
            "        new_authordir = get_valid_filename(book.authors[0].name)",
            "    titledir = book.path.split('/')[1]",
            "    new_titledir = get_valid_filename(book.title) + u\" (\" + str(book_id) + u\")\"",
            "",
            "    if titledir != new_titledir:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)",
            "        if gFile:",
            "            gFile['title'] = new_titledir",
            "            gFile.Upload()",
            "            book.path = book.path.split('/')[0] + u'/' + new_titledir",
            "            path = book.path",
            "            gd.updateDatabaseOnEdit(gFile['id'], book.path)     # only child folder affected",
            "        else:",
            "            error = _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found",
            "",
            "    if authordir != new_authordir:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)",
            "        if gFile:",
            "            gd.moveGdriveFolderRemote(gFile, new_authordir)",
            "            book.path = new_authordir + u'/' + book.path.split('/')[1]",
            "            path = book.path",
            "            gd.updateDatabaseOnEdit(gFile['id'], book.path)",
            "        else:",
            "            error = _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found",
            "    # Rename all files from old names to new names",
            "",
            "    if authordir != new_authordir or titledir != new_titledir:",
            "        new_name = get_valid_filename(book.title) + u' - ' + get_valid_filename(new_authordir)",
            "        for file_format in book.data:",
            "            gFile = gd.getFileFromEbooksFolder(path, file_format.name + u'.' + file_format.format.lower())",
            "            if not gFile:",
            "                error = _(u'File %(file)s not found on Google Drive', file=file_format.name)  # file not found",
            "                break",
            "            gd.moveGdriveFileRemote(gFile, new_name + u'.' + file_format.format.lower())",
            "            file_format.name = new_name",
            "    return error",
            "",
            "",
            "def delete_book_gdrive(book, book_format):",
            "    error = None",
            "    if book_format:",
            "        name = ''",
            "        for entry in book.data:",
            "            if entry.format.upper() == book_format:",
            "                name = entry.name + '.' + book_format",
            "        gFile = gd.getFileFromEbooksFolder(book.path, name)",
            "    else:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])",
            "    if gFile:",
            "        gd.deleteDatabaseEntry(gFile['id'])",
            "        gFile.Trash()",
            "    else:",
            "        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found",
            "",
            "    return error is None, error",
            "",
            "",
            "def reset_password(user_id):",
            "    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "    if not existing_user:",
            "        return 0, None",
            "    if not config.get_mail_server_configured():",
            "        return 2, None",
            "    try:",
            "        password = generate_random_password()",
            "        existing_user.password = generate_password_hash(password)",
            "        ub.session.commit()",
            "        send_registration_mail(existing_user.email, existing_user.name, password, True)",
            "        return 1, existing_user.name",
            "    except Exception:",
            "        ub.session.rollback()",
            "        return 0, None",
            "",
            "",
            "def generate_random_password():",
            "    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"",
            "    passlen = 8",
            "    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))",
            "",
            "",
            "def uniq(inpt):",
            "    output = []",
            "    inpt = [ \" \".join(inp.split()) for inp in inpt]",
            "    for x in inpt:",
            "        if x not in output:",
            "            output.append(x)",
            "    return output",
            "",
            "def check_email(email):",
            "    email = valid_email(email)",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():",
            "        log.error(u\"Found an existing account for this e-mail address\")",
            "        raise Exception(_(u\"Found an existing account for this e-mail address\"))",
            "    return email",
            "",
            "",
            "def check_username(username):",
            "    username = username.strip()",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():",
            "        log.error(u\"This username is already taken\")",
            "        raise Exception (_(u\"This username is already taken\"))",
            "    return username",
            "",
            "",
            "def valid_email(email):",
            "    email = email.strip()",
            "    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation",
            "    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",",
            "                     email):",
            "        log.error(u\"Invalid e-mail address format\")",
            "        raise Exception(_(u\"Invalid e-mail address format\"))",
            "    return email",
            "",
            "# ################################# External interface #################################",
            "",
            "",
            "def update_dir_stucture(book_id, calibrepath, first_author=None, orignal_filepath=None, db_filename=None):",
            "    if config.config_use_google_drive:",
            "        return update_dir_structure_gdrive(book_id, first_author)",
            "    else:",
            "        return update_dir_structure_file(book_id, calibrepath, first_author, orignal_filepath, db_filename)",
            "",
            "",
            "def delete_book(book, calibrepath, book_format):",
            "    if config.config_use_google_drive:",
            "        return delete_book_gdrive(book, book_format)",
            "    else:",
            "        return delete_book_file(book, calibrepath, book_format)",
            "",
            "",
            "def get_cover_on_failure(use_generic_cover):",
            "    if use_generic_cover:",
            "        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")",
            "    else:",
            "        return None",
            "",
            "",
            "def get_book_cover(book_id):",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    return get_book_cover_internal(book, use_generic_cover_on_failure=True)",
            "",
            "",
            "def get_book_cover_with_uuid(book_uuid,",
            "                             use_generic_cover_on_failure=True):",
            "    book = calibre_db.get_book_by_uuid(book_uuid)",
            "    return get_book_cover_internal(book, use_generic_cover_on_failure)",
            "",
            "",
            "def get_book_cover_internal(book, use_generic_cover_on_failure):",
            "    if book and book.has_cover:",
            "        if config.config_use_google_drive:",
            "            try:",
            "                if not gd.is_gdrive_ready():",
            "                    return get_cover_on_failure(use_generic_cover_on_failure)",
            "                path = gd.get_cover_via_gdrive(book.path)",
            "                if path:",
            "                    return redirect(path)",
            "                else:",
            "                    log.error('%s/cover.jpg not found on Google Drive', book.path)",
            "                    return get_cover_on_failure(use_generic_cover_on_failure)",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                return get_cover_on_failure(use_generic_cover_on_failure)",
            "        else:",
            "            cover_file_path = os.path.join(config.config_calibre_dir, book.path)",
            "            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):",
            "                return send_from_directory(cover_file_path, \"cover.jpg\")",
            "            else:",
            "                return get_cover_on_failure(use_generic_cover_on_failure)",
            "    else:",
            "        return get_cover_on_failure(use_generic_cover_on_failure)",
            "",
            "",
            "# saves book cover from url",
            "def save_cover_from_url(url, book_path):",
            "    try:",
            "        img = requests.get(url, timeout=(10, 200))      # ToDo: Error Handling",
            "        img.raise_for_status()",
            "        return save_cover(img, book_path)",
            "    except (requests.exceptions.HTTPError,",
            "            requests.exceptions.ConnectionError,",
            "            requests.exceptions.Timeout) as ex:",
            "        log.info(u'Cover Download Error %s', ex)",
            "        return False, _(\"Error Downloading Cover\")",
            "    except MissingDelegateError as ex:",
            "        log.info(u'File Format Error %s', ex)",
            "        return False, _(\"Cover Format Error\")",
            "",
            "",
            "def save_cover_from_filestorage(filepath, saved_filename, img):",
            "    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "    if not os.path.exists(filepath):",
            "        try:",
            "            os.makedirs(filepath)",
            "        except OSError:",
            "            log.error(u\"Failed to create path for cover\")",
            "            return False, _(u\"Failed to create path for cover\")",
            "    try:",
            "        # upload of jgp file without wand",
            "        if isinstance(img, requests.Response):",
            "            with open(os.path.join(filepath, saved_filename), 'wb') as f:",
            "                f.write(img.content)",
            "        else:",
            "            if hasattr(img, \"metadata\"):",
            "                # upload of jpg/png... via url",
            "                img.save(filename=os.path.join(filepath, saved_filename))",
            "                img.close()",
            "            else:",
            "                # upload of jpg/png... from hdd",
            "                img.save(os.path.join(filepath, saved_filename))",
            "    except (IOError, OSError):",
            "        log.error(u\"Cover-file is not a valid image file, or could not be stored\")",
            "        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")",
            "    return True, None",
            "",
            "",
            "# saves book cover to gdrive or locally",
            "def save_cover(img, book_path):",
            "    content_type = img.headers.get('content-type')",
            "",
            "    if use_IM:",
            "        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):",
            "            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")",
            "            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")",
            "        # convert to jpg because calibre only supports jpg",
            "        if content_type != 'image/jpg':",
            "            try:",
            "                if hasattr(img, 'stream'):",
            "                    imgc = Image(blob=img.stream)",
            "                else:",
            "                    imgc = Image(blob=io.BytesIO(img.content))",
            "                imgc.format = 'jpeg'",
            "                imgc.transform_colorspace(\"rgb\")",
            "                img = imgc",
            "            except (BlobError, MissingDelegateError):",
            "                log.error(\"Invalid cover file content\")",
            "                return False, _(\"Invalid cover file content\")",
            "    else:",
            "        if content_type not in 'image/jpeg':",
            "            log.error(\"Only jpg/jpeg files are supported as coverfile\")",
            "            return False, _(\"Only jpg/jpeg files are supported as coverfile\")",
            "",
            "    if config.config_use_google_drive:",
            "        tmp_dir = os.path.join(gettempdir(), 'calibre_web')",
            "",
            "        if not os.path.isdir(tmp_dir):",
            "            os.mkdir(tmp_dir)",
            "        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)",
            "        if ret is True:",
            "            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\",\"/\"),",
            "                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))",
            "            log.info(\"Cover is saved on Google Drive\")",
            "            return True, None",
            "        else:",
            "            return False, message",
            "    else:",
            "        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)",
            "",
            "",
            "def do_download_file(book, book_format, client, data, headers):",
            "    if config.config_use_google_drive:",
            "        #startTime = time.time()",
            "        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)",
            "        #log.debug('%s', time.time() - startTime)",
            "        if df:",
            "            return gd.do_gdrive_download(df, headers)",
            "        else:",
            "            abort(404)",
            "    else:",
            "        filename = os.path.join(config.config_calibre_dir, book.path)",
            "        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):",
            "            # ToDo: improve error handling",
            "            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))",
            "",
            "        if client == \"kobo\" and book_format == \"kepub\":",
            "            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")",
            "",
            "        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))",
            "        # ToDo Check headers parameter",
            "        for element in headers:",
            "            response.headers[element[0]] = element[1]",
            "        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))",
            "        return response",
            "",
            "##################################",
            "",
            "",
            "def check_unrar(unrarLocation):",
            "    if not unrarLocation:",
            "        return",
            "",
            "    if not os.path.exists(unrarLocation):",
            "        return _('Unrar binary file not found')",
            "",
            "    try:",
            "        unrarLocation = [unrarLocation]",
            "        value = process_wait(unrarLocation, pattern='UNRAR (.*) freeware')",
            "        if value:",
            "            version = value.group(1)",
            "            log.debug(\"unrar version %s\", version)",
            "",
            "    except (OSError, UnicodeDecodeError) as err:",
            "        log.debug_or_exception(err)",
            "        return _('Error excecuting UnRar')",
            "",
            "",
            "def json_serial(obj):",
            "    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"",
            "",
            "    if isinstance(obj, datetime):",
            "        return obj.isoformat()",
            "    if isinstance(obj, timedelta):",
            "        return {",
            "            '__type__': 'timedelta',",
            "            'days': obj.days,",
            "            'seconds': obj.seconds,",
            "            'microseconds': obj.microseconds,",
            "        }",
            "    raise TypeError(\"Type %s not serializable\" % type(obj))",
            "",
            "",
            "# helper function for displaying the runtime of tasks",
            "def format_runtime(runtime):",
            "    retVal = \"\"",
            "    if runtime.days:",
            "        retVal = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '",
            "    mins, seconds = divmod(runtime.seconds, 60)",
            "    hours, minutes = divmod(mins, 60)",
            "    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?",
            "    if hours:",
            "        retVal += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)",
            "    elif minutes:",
            "        retVal += '{:2d}:{:02d}s'.format(minutes, seconds)",
            "    else:",
            "        retVal += '{:2d}s'.format(seconds)",
            "    return retVal",
            "",
            "",
            "# helper function to apply localize status information in tasklist entries",
            "def render_task_status(tasklist):",
            "    renderedtasklist = list()",
            "    for __, user, __, task in tasklist:",
            "        if user == current_user.name or current_user.role_admin():",
            "            ret = {}",
            "            if task.start_time:",
            "                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())",
            "                ret['runtime'] = format_runtime(task.runtime)",
            "",
            "            # localize the task status",
            "            if isinstance(task.stat, int):",
            "                if task.stat == STAT_WAITING:",
            "                    ret['status'] = _(u'Waiting')",
            "                elif task.stat == STAT_FAIL:",
            "                    ret['status'] = _(u'Failed')",
            "                elif task.stat == STAT_STARTED:",
            "                    ret['status'] = _(u'Started')",
            "                elif task.stat == STAT_FINISH_SUCCESS:",
            "                    ret['status'] = _(u'Finished')",
            "                else:",
            "                    ret['status'] = _(u'Unknown Status')",
            "",
            "            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)",
            "            ret['progress'] = \"{} %\".format(int(task.progress * 100))",
            "            ret['user'] = escape(user)  # prevent xss",
            "            renderedtasklist.append(ret)",
            "",
            "    return renderedtasklist",
            "",
            "",
            "def tags_filters():",
            "    negtags_list = current_user.list_denied_tags()",
            "    postags_list = current_user.list_allowed_tags()",
            "    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)",
            "    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)",
            "    return and_(pos_content_tags_filter, ~neg_content_tags_filter)",
            "",
            "",
            "# checks if domain is in database (including wildcards)",
            "# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;",
            "# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/",
            "# in all calls the email address is checked for validity",
            "def check_valid_domain(domain_text):",
            "    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"",
            "    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()",
            "    if not len(result):",
            "        return False",
            "    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"",
            "    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()",
            "    return not len(result)",
            "",
            "",
            "def get_cc_columns(filter_config_custom_read=False):",
            "    tmpcc = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    cc = []",
            "    r = None",
            "    if config.config_columns_to_ignore:",
            "        r = re.compile(config.config_columns_to_ignore)",
            "",
            "    for col in tmpcc:",
            "        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:",
            "            continue",
            "        if r and r.match(col.name):",
            "            continue",
            "        cc.append(col)",
            "",
            "    return cc",
            "",
            "",
            "def get_download_link(book_id, book_format, client):",
            "    book_format = book_format.split(\".\")[0]",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if book:",
            "        data1 = calibre_db.get_book_format(book.id, book_format.upper())",
            "    else:",
            "        log.error(\"Book id {} not found for downloading\".format(book_id))",
            "        abort(404)",
            "    if data1:",
            "        # collect downloaded books only for registered user and not for anonymous user",
            "        if current_user.is_authenticated:",
            "            ub.update_download(book_id, int(current_user.id))",
            "        file_name = book.title",
            "        if len(book.authors) > 0:",
            "            file_name = file_name + ' - ' + book.authors[0].name",
            "        file_name = get_valid_filename(file_name, replace_whitespace=False)",
            "        headers = Headers()",
            "        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")",
            "        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (",
            "            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)",
            "        return do_download_file(book, book_format, client, data1, headers)",
            "    else:",
            "        abort(404)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,",
            "#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import io",
            "import mimetypes",
            "import re",
            "import shutil",
            "import socket",
            "import unicodedata",
            "from datetime import datetime, timedelta",
            "from tempfile import gettempdir",
            "from urllib.parse import urlparse",
            "import requests",
            "",
            "from babel.dates import format_datetime",
            "from babel.units import format_unit",
            "from flask import send_from_directory, make_response, redirect, abort, url_for",
            "from flask_babel import gettext as _",
            "from flask_login import current_user",
            "from sqlalchemy.sql.expression import true, false, and_, text, func",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import generate_password_hash",
            "from markupsafe import escape",
            "from urllib.parse import quote",
            "",
            "try:",
            "    import unidecode",
            "    use_unidecode = True",
            "except ImportError:",
            "    use_unidecode = False",
            "",
            "from . import calibre_db",
            "from .tasks.convert import TaskConvert",
            "from . import logger, config, get_locale, db, ub",
            "from . import gdriveutils as gd",
            "from .constants import STATIC_DIR as _STATIC_DIR",
            "from .subproc_wrapper import process_wait",
            "from .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS",
            "from .tasks.mail import TaskEmail",
            "",
            "log = logger.create()",
            "",
            "try:",
            "    from wand.image import Image",
            "    from wand.exceptions import MissingDelegateError, BlobError",
            "    use_IM = True",
            "except (ImportError, RuntimeError) as e:",
            "    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)",
            "    use_IM = False",
            "    MissingDelegateError = BaseException",
            "",
            "",
            "# Convert existing book entry to new format",
            "def convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):",
            "    book = calibre_db.get_book(book_id)",
            "    data = calibre_db.get_book_format(book.id, old_book_format)",
            "    file_path = os.path.join(calibrepath, book.path, data.name)",
            "    if not data:",
            "        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)",
            "        log.error(\"convert_book_format: %s\", error_message)",
            "        return error_message",
            "    if config.config_use_google_drive:",
            "        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):",
            "            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",",
            "                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())",
            "            return error_message",
            "    else:",
            "        if not os.path.exists(file_path + \".\" + old_book_format.lower()):",
            "            error_message = _(u\"%(format)s not found: %(fn)s\",",
            "                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())",
            "            return error_message",
            "    # read settings and append converter task to queue",
            "    if kindle_mail:",
            "        settings = config.get_mail_settings()",
            "        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail",
            "        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')",
            "    else:",
            "        settings = dict()",
            "    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss",
            "    txt = u\"{} -> {}: {}\".format(",
            "           old_book_format.upper(),",
            "           new_book_format.upper(),",
            "           link)",
            "    settings['old_book_format'] = old_book_format",
            "    settings['new_book_format'] = new_book_format",
            "    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))",
            "    return None",
            "",
            "",
            "def send_test_mail(kindle_mail, user_name):",
            "    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,",
            "                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),",
            "                                          _(u'This e-mail has been sent via Calibre-Web.')))",
            "    return",
            "",
            "",
            "# Send registration email or password reset email, depending on parameter resend (False means welcome email)",
            "def send_registration_mail(e_mail, user_name, default_password, resend=False):",
            "    txt = \"Hello %s!\\r\\n\" % user_name",
            "    if not resend:",
            "        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"",
            "    txt += \"Please log in to your account using the following informations:\\r\\n\"",
            "    txt += \"User name: %s\\r\\n\" % user_name",
            "    txt += \"Password: %s\\r\\n\" % default_password",
            "    txt += \"Don't forget to change your password after first login.\\r\\n\"",
            "    txt += \"Sincerely\\r\\n\\r\\n\"",
            "    txt += \"Your Calibre-Web team\"",
            "    WorkerThread.add(None, TaskEmail(",
            "        subject=_(u'Get Started with Calibre-Web'),",
            "        filepath=None,",
            "        attachment=None,",
            "        settings=config.get_mail_settings(),",
            "        recipient=e_mail,",
            "        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),",
            "        text=txt",
            "    ))",
            "    return",
            "",
            "",
            "def check_send_to_kindle_with_converter(formats):",
            "    bookformats = list()",
            "    if 'EPUB' in formats and 'MOBI' not in formats:",
            "        bookformats.append({'format': 'Mobi',",
            "                            'convert': 1,",
            "                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
            "                                      orig='Epub',",
            "                                      format='Mobi')})",
            "    if 'AZW3' in formats and not 'MOBI' in formats:",
            "        bookformats.append({'format': 'Mobi',",
            "                            'convert': 2,",
            "                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',",
            "                                      orig='Azw3',",
            "                                      format='Mobi')})",
            "    return bookformats",
            "",
            "",
            "def check_send_to_kindle(entry):",
            "    \"\"\"",
            "        returns all available book formats for sending to Kindle",
            "    \"\"\"",
            "    formats = list()",
            "    bookformats = list()",
            "    if len(entry.data):",
            "        for ele in iter(entry.data):",
            "            if ele.uncompressed_size < config.mail_size:",
            "                formats.append(ele.format)",
            "        if 'MOBI' in formats:",
            "            bookformats.append({'format': 'Mobi',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Mobi')})",
            "        if 'PDF' in formats:",
            "            bookformats.append({'format': 'Pdf',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Pdf')})",
            "        if 'AZW' in formats:",
            "            bookformats.append({'format': 'Azw',",
            "                                'convert': 0,",
            "                                'text': _('Send %(format)s to Kindle', format='Azw')})",
            "        if config.config_converterpath:",
            "            bookformats.extend(check_send_to_kindle_with_converter(formats))",
            "        return bookformats",
            "    else:",
            "        log.error(u'Cannot find book entry %d', entry.id)",
            "        return None",
            "",
            "",
            "# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return",
            "# list with supported formats",
            "def check_read_formats(entry):",
            "    EXTENSIONS_READER = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}",
            "    bookformats = list()",
            "    if len(entry.data):",
            "        for ele in iter(entry.data):",
            "            if ele.format.upper() in EXTENSIONS_READER:",
            "                bookformats.append(ele.format.lower())",
            "    return bookformats",
            "",
            "",
            "# Files are processed in the following order/priority:",
            "# 1: If Mobi file is existing, it's directly send to kindle email,",
            "# 2: If Epub file is existing, it's converted and send to kindle email,",
            "# 3: If Pdf file is existing, it's directly send to kindle email",
            "def send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):",
            "    \"\"\"Send email with attachments\"\"\"",
            "    book = calibre_db.get_book(book_id)",
            "",
            "    if convert == 1:",
            "        # returns None if success, otherwise errormessage",
            "        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)",
            "    if convert == 2:",
            "        # returns None if success, otherwise errormessage",
            "        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)",
            "",
            "    for entry in iter(book.data):",
            "        if entry.format.upper() == book_format.upper():",
            "            converted_file_name = entry.name + '.' + book_format.lower()",
            "            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))",
            "            EmailText = _(u\"%(book)s send to Kindle\", book=link)",
            "            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,",
            "                             config.get_mail_settings(), kindle_mail,",
            "                             EmailText, _(u'This e-mail has been sent via Calibre-Web.')))",
            "            return",
            "    return _(u\"The requested file could not be read. Maybe wrong permissions?\")",
            "",
            "",
            "def get_valid_filename(value, replace_whitespace=True):",
            "    \"\"\"",
            "    Returns the given string converted to a string that can be used for a clean",
            "    filename. Limits num characters to 128 max.",
            "    \"\"\"",
            "    if value[-1:] == u'.':",
            "        value = value[:-1]+u'_'",
            "    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')",
            "    if use_unidecode:",
            "        if config.config_unicode_filename:",
            "            value = (unidecode.unidecode(value))",
            "    else:",
            "        value = value.replace(u'\u00a7', u'SS')",
            "        value = value.replace(u'\u00df', u'ss')",
            "        value = unicodedata.normalize('NFKD', value)",
            "        re_slugify = re.compile(r'[\\W\\s-]', re.UNICODE)",
            "        value = re_slugify.sub('', value)",
            "    if replace_whitespace:",
            "        #  *+:\\\"/<>? are replaced by _",
            "        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)",
            "        # pipe has to be replaced with comma",
            "        value = re.sub(r'[|]+', u',', value, flags=re.U)",
            "    value = value[:128].strip()",
            "    if not value:",
            "        raise ValueError(\"Filename cannot be empty\")",
            "    return value",
            "",
            "",
            "def split_authors(values):",
            "    authors_list = []",
            "    for value in values:",
            "        authors = re.split('[&;]', value)",
            "        for author in authors:",
            "            commas = author.count(',')",
            "            if commas == 1:",
            "                author_split = author.split(',')",
            "                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())",
            "            elif commas > 1:",
            "                authors_list.extend([x.strip() for x in author.split(',')])",
            "            else:",
            "                authors_list.append(author.strip())",
            "    return authors_list",
            "",
            "",
            "def get_sorted_author(value):",
            "    try:",
            "        if ',' not in value:",
            "            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]",
            "            combined = \"(\" + \")|(\".join(regexes) + \")\"",
            "            value = value.split(\" \")",
            "            if re.match(combined, value[-1].upper()):",
            "                if len(value) > 1:",
            "                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]",
            "                else:",
            "                    value2 = value[0]",
            "            elif len(value) == 1:",
            "                value2 = value[0]",
            "            else:",
            "                value2 = value[-1] + \", \" + \" \".join(value[:-1])",
            "        else:",
            "            value2 = value",
            "    except Exception as ex:",
            "        log.error(\"Sorting author %s failed: %s\", value, ex)",
            "        if isinstance(list, value2):",
            "            value2 = value[0]",
            "        else:",
            "            value2 = value",
            "    return value2",
            "",
            "",
            "# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false",
            "def delete_book_file(book, calibrepath, book_format=None):",
            "    # check that path is 2 elements deep, check that target path has no subfolders",
            "    if book.path.count('/') == 1:",
            "        path = os.path.join(calibrepath, book.path)",
            "        if book_format:",
            "            for file in os.listdir(path):",
            "                if file.upper().endswith(\".\"+book_format):",
            "                    os.remove(os.path.join(path, file))",
            "            return True, None",
            "        else:",
            "            if os.path.isdir(path):",
            "                try:",
            "                    for root, folders, files in os.walk(path):",
            "                        for f in files:",
            "                            os.unlink(os.path.join(root, f))",
            "                        if len(folders):",
            "                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,",
            "                                        book.path, folders))",
            "                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",",
            "                                           id=book.id,",
            "                                           path=book.path)",
            "                    shutil.rmtree(path)",
            "                except (IOError, OSError) as e:",
            "                    log.error(\"Deleting book %s failed: %s\", book.id, e)",
            "                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=e)",
            "                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])",
            "                if not os.listdir(authorpath):",
            "                    try:",
            "                        shutil.rmtree(authorpath)",
            "                    except (IOError, OSError) as e:",
            "                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, e)",
            "                return True, None",
            "",
            "    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",",
            "              book.id, book.path)",
            "    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",",
            "                   id=book.id,",
            "                   path=book.path)",
            "",
            "",
            "# Moves files in file storage during author/title rename, or from temp dir to file storage",
            "def update_dir_structure_file(book_id, calibrepath, first_author, orignal_filepath, db_filename):",
            "    # get book database entry from id, if original path overwrite source with original_filepath",
            "    localbook = calibre_db.get_book(book_id)",
            "    if orignal_filepath:",
            "        path = orignal_filepath",
            "    else:",
            "        path = os.path.join(calibrepath, localbook.path)",
            "",
            "    # Create (current) authordir and titledir from database",
            "    authordir = localbook.path.split('/')[0]",
            "    titledir = localbook.path.split('/')[1]",
            "",
            "    # Create new_authordir from parameter or from database",
            "    # Create new titledir from database and add id",
            "    if first_author:",
            "        new_authordir = get_valid_filename(first_author)",
            "    else:",
            "        new_authordir = get_valid_filename(localbook.authors[0].name)",
            "    new_titledir = get_valid_filename(localbook.title) + \" (\" + str(book_id) + \")\"",
            "",
            "    if titledir != new_titledir or authordir != new_authordir or orignal_filepath:",
            "        new_path = os.path.join(calibrepath, new_authordir, new_titledir)",
            "        new_name = get_valid_filename(localbook.title) + ' - ' + get_valid_filename(new_authordir)",
            "        try:",
            "            if orignal_filepath:",
            "                if not os.path.isdir(new_path):",
            "                    os.makedirs(new_path)",
            "                shutil.move(os.path.normcase(path), os.path.normcase(os.path.join(new_path, db_filename)))",
            "                log.debug(\"Moving title: %s to %s/%s\", path, new_path, new_name)",
            "                # Check new path is not valid path",
            "            else:",
            "                if not os.path.exists(new_path):",
            "                    # move original path to new path",
            "                    log.debug(\"Moving title: %s to %s\", path, new_path)",
            "                    shutil.move(os.path.normcase(path), os.path.normcase(new_path))",
            "                else: # path is valid copy only files to new location (merge)",
            "                    log.info(\"Moving title: %s into existing: %s\", path, new_path)",
            "                    # Take all files and subfolder from old path (strange command)",
            "                    for dir_name, __, file_list in os.walk(path):",
            "                        for file in file_list:",
            "                            shutil.move(os.path.normcase(os.path.join(dir_name, file)),",
            "                                            os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))",
            "                            # os.unlink(os.path.normcase(os.path.join(dir_name, file)))",
            "            # change location in database to new author/title path",
            "            localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\','/')",
            "        except (OSError) as ex:",
            "            log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)",
            "            log.debug(ex, exc_info=True)",
            "            return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",",
            "                     src=path, dest=new_path, error=str(ex))",
            "",
            "        # Rename all files from old names to new names",
            "        try:",
            "            for file_format in localbook.data:",
            "                shutil.move(os.path.normcase(",
            "                    os.path.join(new_path, file_format.name + '.' + file_format.format.lower())),",
            "                    os.path.normcase(os.path.join(new_path, new_name + '.' + file_format.format.lower())))",
            "                file_format.name = new_name",
            "            if not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:",
            "                shutil.rmtree(os.path.dirname(path))",
            "        except (OSError) as ex:",
            "            log.error(\"Rename file in path %s to %s: %s\", new_path, new_name, ex)",
            "            log.debug(ex, exc_info=True)",
            "            return _(\"Rename file in path '%(src)s' to '%(dest)s' failed with error: %(error)s\",",
            "                     src=new_path, dest=new_name, error=str(ex))",
            "    return False",
            "",
            "def update_dir_structure_gdrive(book_id, first_author):",
            "    error = False",
            "    book = calibre_db.get_book(book_id)",
            "    path = book.path",
            "",
            "    authordir = book.path.split('/')[0]",
            "    if first_author:",
            "        new_authordir = get_valid_filename(first_author)",
            "    else:",
            "        new_authordir = get_valid_filename(book.authors[0].name)",
            "    titledir = book.path.split('/')[1]",
            "    new_titledir = get_valid_filename(book.title) + u\" (\" + str(book_id) + u\")\"",
            "",
            "    if titledir != new_titledir:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)",
            "        if gFile:",
            "            gFile['title'] = new_titledir",
            "            gFile.Upload()",
            "            book.path = book.path.split('/')[0] + u'/' + new_titledir",
            "            path = book.path",
            "            gd.updateDatabaseOnEdit(gFile['id'], book.path)     # only child folder affected",
            "        else:",
            "            error = _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found",
            "",
            "    if authordir != new_authordir:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)",
            "        if gFile:",
            "            gd.moveGdriveFolderRemote(gFile, new_authordir)",
            "            book.path = new_authordir + u'/' + book.path.split('/')[1]",
            "            path = book.path",
            "            gd.updateDatabaseOnEdit(gFile['id'], book.path)",
            "        else:",
            "            error = _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found",
            "    # Rename all files from old names to new names",
            "",
            "    if authordir != new_authordir or titledir != new_titledir:",
            "        new_name = get_valid_filename(book.title) + u' - ' + get_valid_filename(new_authordir)",
            "        for file_format in book.data:",
            "            gFile = gd.getFileFromEbooksFolder(path, file_format.name + u'.' + file_format.format.lower())",
            "            if not gFile:",
            "                error = _(u'File %(file)s not found on Google Drive', file=file_format.name)  # file not found",
            "                break",
            "            gd.moveGdriveFileRemote(gFile, new_name + u'.' + file_format.format.lower())",
            "            file_format.name = new_name",
            "    return error",
            "",
            "",
            "def delete_book_gdrive(book, book_format):",
            "    error = None",
            "    if book_format:",
            "        name = ''",
            "        for entry in book.data:",
            "            if entry.format.upper() == book_format:",
            "                name = entry.name + '.' + book_format",
            "        gFile = gd.getFileFromEbooksFolder(book.path, name)",
            "    else:",
            "        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])",
            "    if gFile:",
            "        gd.deleteDatabaseEntry(gFile['id'])",
            "        gFile.Trash()",
            "    else:",
            "        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found",
            "",
            "    return error is None, error",
            "",
            "",
            "def reset_password(user_id):",
            "    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "    if not existing_user:",
            "        return 0, None",
            "    if not config.get_mail_server_configured():",
            "        return 2, None",
            "    try:",
            "        password = generate_random_password()",
            "        existing_user.password = generate_password_hash(password)",
            "        ub.session.commit()",
            "        send_registration_mail(existing_user.email, existing_user.name, password, True)",
            "        return 1, existing_user.name",
            "    except Exception:",
            "        ub.session.rollback()",
            "        return 0, None",
            "",
            "",
            "def generate_random_password():",
            "    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"",
            "    passlen = 8",
            "    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))",
            "",
            "",
            "def uniq(inpt):",
            "    output = []",
            "    inpt = [ \" \".join(inp.split()) for inp in inpt]",
            "    for x in inpt:",
            "        if x not in output:",
            "            output.append(x)",
            "    return output",
            "",
            "def check_email(email):",
            "    email = valid_email(email)",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():",
            "        log.error(u\"Found an existing account for this e-mail address\")",
            "        raise Exception(_(u\"Found an existing account for this e-mail address\"))",
            "    return email",
            "",
            "",
            "def check_username(username):",
            "    username = username.strip()",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():",
            "        log.error(u\"This username is already taken\")",
            "        raise Exception (_(u\"This username is already taken\"))",
            "    return username",
            "",
            "",
            "def valid_email(email):",
            "    email = email.strip()",
            "    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation",
            "    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",",
            "                     email):",
            "        log.error(u\"Invalid e-mail address format\")",
            "        raise Exception(_(u\"Invalid e-mail address format\"))",
            "    return email",
            "",
            "# ################################# External interface #################################",
            "",
            "",
            "def update_dir_stucture(book_id, calibrepath, first_author=None, orignal_filepath=None, db_filename=None):",
            "    if config.config_use_google_drive:",
            "        return update_dir_structure_gdrive(book_id, first_author)",
            "    else:",
            "        return update_dir_structure_file(book_id, calibrepath, first_author, orignal_filepath, db_filename)",
            "",
            "",
            "def delete_book(book, calibrepath, book_format):",
            "    if config.config_use_google_drive:",
            "        return delete_book_gdrive(book, book_format)",
            "    else:",
            "        return delete_book_file(book, calibrepath, book_format)",
            "",
            "",
            "def get_cover_on_failure(use_generic_cover):",
            "    if use_generic_cover:",
            "        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")",
            "    else:",
            "        return None",
            "",
            "",
            "def get_book_cover(book_id):",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    return get_book_cover_internal(book, use_generic_cover_on_failure=True)",
            "",
            "",
            "def get_book_cover_with_uuid(book_uuid,",
            "                             use_generic_cover_on_failure=True):",
            "    book = calibre_db.get_book_by_uuid(book_uuid)",
            "    return get_book_cover_internal(book, use_generic_cover_on_failure)",
            "",
            "",
            "def get_book_cover_internal(book, use_generic_cover_on_failure):",
            "    if book and book.has_cover:",
            "        if config.config_use_google_drive:",
            "            try:",
            "                if not gd.is_gdrive_ready():",
            "                    return get_cover_on_failure(use_generic_cover_on_failure)",
            "                path = gd.get_cover_via_gdrive(book.path)",
            "                if path:",
            "                    return redirect(path)",
            "                else:",
            "                    log.error('%s/cover.jpg not found on Google Drive', book.path)",
            "                    return get_cover_on_failure(use_generic_cover_on_failure)",
            "            except Exception as ex:",
            "                log.debug_or_exception(ex)",
            "                return get_cover_on_failure(use_generic_cover_on_failure)",
            "        else:",
            "            cover_file_path = os.path.join(config.config_calibre_dir, book.path)",
            "            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):",
            "                return send_from_directory(cover_file_path, \"cover.jpg\")",
            "            else:",
            "                return get_cover_on_failure(use_generic_cover_on_failure)",
            "    else:",
            "        return get_cover_on_failure(use_generic_cover_on_failure)",
            "",
            "",
            "# saves book cover from url",
            "def save_cover_from_url(url, book_path):",
            "    try:",
            "        # 127.0.x.x, localhost, [::1], [::ffff:7f00:1]",
            "        ip = socket.getaddrinfo(urlparse(url).hostname, 0)[0][4][0]",
            "        if ip.startswith(\"127.\") or ip.startswith('::ffff:7f') or ip == \"::1\":",
            "            log.error(\"Localhost was accessed for cover upload\")",
            "            return False, _(\"You are not allowed to access localhost for cover uploads\")",
            "        img = requests.get(url, timeout=(10, 200))      # ToDo: Error Handling",
            "        img.raise_for_status()",
            "        return save_cover(img, book_path)",
            "    except (socket.gaierror,",
            "            requests.exceptions.HTTPError,",
            "            requests.exceptions.ConnectionError,",
            "            requests.exceptions.Timeout) as ex:",
            "        log.info(u'Cover Download Error %s', ex)",
            "        return False, _(\"Error Downloading Cover\")",
            "    except MissingDelegateError as ex:",
            "        log.info(u'File Format Error %s', ex)",
            "        return False, _(\"Cover Format Error\")",
            "",
            "",
            "def save_cover_from_filestorage(filepath, saved_filename, img):",
            "    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file",
            "    if not os.path.exists(filepath):",
            "        try:",
            "            os.makedirs(filepath)",
            "        except OSError:",
            "            log.error(u\"Failed to create path for cover\")",
            "            return False, _(u\"Failed to create path for cover\")",
            "    try:",
            "        # upload of jgp file without wand",
            "        if isinstance(img, requests.Response):",
            "            with open(os.path.join(filepath, saved_filename), 'wb') as f:",
            "                f.write(img.content)",
            "        else:",
            "            if hasattr(img, \"metadata\"):",
            "                # upload of jpg/png... via url",
            "                img.save(filename=os.path.join(filepath, saved_filename))",
            "                img.close()",
            "            else:",
            "                # upload of jpg/png... from hdd",
            "                img.save(os.path.join(filepath, saved_filename))",
            "    except (IOError, OSError):",
            "        log.error(u\"Cover-file is not a valid image file, or could not be stored\")",
            "        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")",
            "    return True, None",
            "",
            "",
            "# saves book cover to gdrive or locally",
            "def save_cover(img, book_path):",
            "    content_type = img.headers.get('content-type')",
            "",
            "    if use_IM:",
            "        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):",
            "            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")",
            "            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")",
            "        # convert to jpg because calibre only supports jpg",
            "        if content_type != 'image/jpg':",
            "            try:",
            "                if hasattr(img, 'stream'):",
            "                    imgc = Image(blob=img.stream)",
            "                else:",
            "                    imgc = Image(blob=io.BytesIO(img.content))",
            "                imgc.format = 'jpeg'",
            "                imgc.transform_colorspace(\"rgb\")",
            "                img = imgc",
            "            except (BlobError, MissingDelegateError):",
            "                log.error(\"Invalid cover file content\")",
            "                return False, _(\"Invalid cover file content\")",
            "    else:",
            "        if content_type not in 'image/jpeg':",
            "            log.error(\"Only jpg/jpeg files are supported as coverfile\")",
            "            return False, _(\"Only jpg/jpeg files are supported as coverfile\")",
            "",
            "    if config.config_use_google_drive:",
            "        tmp_dir = os.path.join(gettempdir(), 'calibre_web')",
            "",
            "        if not os.path.isdir(tmp_dir):",
            "            os.mkdir(tmp_dir)",
            "        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)",
            "        if ret is True:",
            "            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\",\"/\"),",
            "                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))",
            "            log.info(\"Cover is saved on Google Drive\")",
            "            return True, None",
            "        else:",
            "            return False, message",
            "    else:",
            "        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)",
            "",
            "",
            "def do_download_file(book, book_format, client, data, headers):",
            "    if config.config_use_google_drive:",
            "        #startTime = time.time()",
            "        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)",
            "        #log.debug('%s', time.time() - startTime)",
            "        if df:",
            "            return gd.do_gdrive_download(df, headers)",
            "        else:",
            "            abort(404)",
            "    else:",
            "        filename = os.path.join(config.config_calibre_dir, book.path)",
            "        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):",
            "            # ToDo: improve error handling",
            "            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))",
            "",
            "        if client == \"kobo\" and book_format == \"kepub\":",
            "            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")",
            "",
            "        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))",
            "        # ToDo Check headers parameter",
            "        for element in headers:",
            "            response.headers[element[0]] = element[1]",
            "        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))",
            "        return response",
            "",
            "##################################",
            "",
            "",
            "def check_unrar(unrarLocation):",
            "    if not unrarLocation:",
            "        return",
            "",
            "    if not os.path.exists(unrarLocation):",
            "        return _('Unrar binary file not found')",
            "",
            "    try:",
            "        unrarLocation = [unrarLocation]",
            "        value = process_wait(unrarLocation, pattern='UNRAR (.*) freeware')",
            "        if value:",
            "            version = value.group(1)",
            "            log.debug(\"unrar version %s\", version)",
            "",
            "    except (OSError, UnicodeDecodeError) as err:",
            "        log.debug_or_exception(err)",
            "        return _('Error excecuting UnRar')",
            "",
            "",
            "def json_serial(obj):",
            "    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"",
            "",
            "    if isinstance(obj, datetime):",
            "        return obj.isoformat()",
            "    if isinstance(obj, timedelta):",
            "        return {",
            "            '__type__': 'timedelta',",
            "            'days': obj.days,",
            "            'seconds': obj.seconds,",
            "            'microseconds': obj.microseconds,",
            "        }",
            "    raise TypeError(\"Type %s not serializable\" % type(obj))",
            "",
            "",
            "# helper function for displaying the runtime of tasks",
            "def format_runtime(runtime):",
            "    retVal = \"\"",
            "    if runtime.days:",
            "        retVal = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '",
            "    mins, seconds = divmod(runtime.seconds, 60)",
            "    hours, minutes = divmod(mins, 60)",
            "    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?",
            "    if hours:",
            "        retVal += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)",
            "    elif minutes:",
            "        retVal += '{:2d}:{:02d}s'.format(minutes, seconds)",
            "    else:",
            "        retVal += '{:2d}s'.format(seconds)",
            "    return retVal",
            "",
            "",
            "# helper function to apply localize status information in tasklist entries",
            "def render_task_status(tasklist):",
            "    renderedtasklist = list()",
            "    for __, user, __, task in tasklist:",
            "        if user == current_user.name or current_user.role_admin():",
            "            ret = {}",
            "            if task.start_time:",
            "                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())",
            "                ret['runtime'] = format_runtime(task.runtime)",
            "",
            "            # localize the task status",
            "            if isinstance(task.stat, int):",
            "                if task.stat == STAT_WAITING:",
            "                    ret['status'] = _(u'Waiting')",
            "                elif task.stat == STAT_FAIL:",
            "                    ret['status'] = _(u'Failed')",
            "                elif task.stat == STAT_STARTED:",
            "                    ret['status'] = _(u'Started')",
            "                elif task.stat == STAT_FINISH_SUCCESS:",
            "                    ret['status'] = _(u'Finished')",
            "                else:",
            "                    ret['status'] = _(u'Unknown Status')",
            "",
            "            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)",
            "            ret['progress'] = \"{} %\".format(int(task.progress * 100))",
            "            ret['user'] = escape(user)  # prevent xss",
            "            renderedtasklist.append(ret)",
            "",
            "    return renderedtasklist",
            "",
            "",
            "def tags_filters():",
            "    negtags_list = current_user.list_denied_tags()",
            "    postags_list = current_user.list_allowed_tags()",
            "    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)",
            "    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)",
            "    return and_(pos_content_tags_filter, ~neg_content_tags_filter)",
            "",
            "",
            "# checks if domain is in database (including wildcards)",
            "# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;",
            "# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/",
            "# in all calls the email address is checked for validity",
            "def check_valid_domain(domain_text):",
            "    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"",
            "    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()",
            "    if not len(result):",
            "        return False",
            "    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"",
            "    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()",
            "    return not len(result)",
            "",
            "",
            "def get_cc_columns(filter_config_custom_read=False):",
            "    tmpcc = calibre_db.session.query(db.Custom_Columns)\\",
            "        .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()",
            "    cc = []",
            "    r = None",
            "    if config.config_columns_to_ignore:",
            "        r = re.compile(config.config_columns_to_ignore)",
            "",
            "    for col in tmpcc:",
            "        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:",
            "            continue",
            "        if r and r.match(col.name):",
            "            continue",
            "        cc.append(col)",
            "",
            "    return cc",
            "",
            "",
            "def get_download_link(book_id, book_format, client):",
            "    book_format = book_format.split(\".\")[0]",
            "    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)",
            "    if book:",
            "        data1 = calibre_db.get_book_format(book.id, book_format.upper())",
            "    else:",
            "        log.error(\"Book id {} not found for downloading\".format(book_id))",
            "        abort(404)",
            "    if data1:",
            "        # collect downloaded books only for registered user and not for anonymous user",
            "        if current_user.is_authenticated:",
            "            ub.update_download(book_id, int(current_user.id))",
            "        file_name = book.title",
            "        if len(book.authors) > 0:",
            "            file_name = file_name + ' - ' + book.authors[0].name",
            "        file_name = get_valid_filename(file_name, replace_whitespace=False)",
            "        headers = Headers()",
            "        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")",
            "        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (",
            "            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)",
            "        return do_download_file(book, book_format, client, data1, headers)",
            "    else:",
            "        abort(404)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": [],
            "26": [],
            "30": [],
            "590": [
                "save_cover_from_url"
            ]
        },
        "addLocation": []
    },
    "cps/kobo_sync_status.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from . import ub"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import datetime"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from sqlalchemy.sql.expression import or_, and_, true"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from sqlalchemy import exc"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " # Add the current book id to kobo_synced_books table for current user, if entry is already present,"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " # do nothing (safety precaution)"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " # Select all entries of current book in kobo_synced_books table, which are from current user and delete them"
            },
            "10": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def remove_synced_book(book_id, all=False):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+def remove_synced_book(book_id, all=False, session=None):"
            },
            "12": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     if not all:"
            },
            "13": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         user = ub.KoboSyncedBooks.user_id == current_user.id"
            },
            "14": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     else:"
            },
            "15": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         user = true()"
            },
            "16": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id) \\"
            },
            "17": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        .filter(user).delete()"
            },
            "18": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ub.session_commit()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    if not session:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id).filter(user).delete()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        ub.session_commit()"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    else:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id).filter(user).delete()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        ub.session_commit(sess=session)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " def change_archived_books(book_id, state=None, message=None):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2021 OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "from flask_login import current_user",
            "from . import ub",
            "import datetime",
            "from sqlalchemy.sql.expression import or_, and_, true",
            "",
            "# Add the current book id to kobo_synced_books table for current user, if entry is already present,",
            "# do nothing (safety precaution)",
            "def add_synced_books(book_id):",
            "    is_present = ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id)\\",
            "        .filter(ub.KoboSyncedBooks.user_id == current_user.id).count()",
            "    if not is_present:",
            "        synced_book = ub.KoboSyncedBooks()",
            "        synced_book.user_id = current_user.id",
            "        synced_book.book_id = book_id",
            "        ub.session.add(synced_book)",
            "        ub.session_commit()",
            "",
            "",
            "# Select all entries of current book in kobo_synced_books table, which are from current user and delete them",
            "def remove_synced_book(book_id, all=False):",
            "    if not all:",
            "        user = ub.KoboSyncedBooks.user_id == current_user.id",
            "    else:",
            "        user = true()",
            "    ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id) \\",
            "        .filter(user).delete()",
            "    ub.session_commit()",
            "",
            "",
            "def change_archived_books(book_id, state=None, message=None):",
            "    archived_book = ub.session.query(ub.ArchivedBook).filter(and_(ub.ArchivedBook.user_id == int(current_user.id),",
            "                                                                  ub.ArchivedBook.book_id == book_id)).first()",
            "    if not archived_book:",
            "        archived_book = ub.ArchivedBook(user_id=current_user.id, book_id=book_id)",
            "",
            "    archived_book.is_archived = state if state else not archived_book.is_archived",
            "    archived_book.last_modified = datetime.datetime.utcnow()",
            "",
            "    ub.session.merge(archived_book)",
            "    ub.session_commit(message)",
            "    return archived_book.is_archived",
            "",
            "",
            "# select all books which are synced by the current user and do not belong to a synced shelf and set them to archive",
            "# select all shelves from current user which are synced and do not belong to the \"only sync\" shelves",
            "def update_on_sync_shelfs(user_id):",
            "    books_to_archive = (ub.session.query(ub.KoboSyncedBooks)",
            "                        .join(ub.BookShelf, ub.KoboSyncedBooks.book_id == ub.BookShelf.book_id, isouter=True)",
            "                        .join(ub.Shelf, ub.Shelf.user_id == user_id, isouter=True)",
            "                        .filter(or_(ub.Shelf.kobo_sync == 0, ub.Shelf.kobo_sync == None))",
            "                        .filter(ub.KoboSyncedBooks.user_id == user_id).all())",
            "    for b in books_to_archive:",
            "        change_archived_books(b.book_id, True)",
            "        ub.session.query(ub.KoboSyncedBooks) \\",
            "            .filter(ub.KoboSyncedBooks.book_id == b.book_id) \\",
            "            .filter(ub.KoboSyncedBooks.user_id == user_id).delete()",
            "        ub.session_commit()",
            "",
            "    # Search all shelf which are currently not synced",
            "    shelves_to_archive = ub.session.query(ub.Shelf).filter(ub.Shelf.user_id == user_id).filter(",
            "        ub.Shelf.kobo_sync == 0).all()",
            "    for a in shelves_to_archive:",
            "        ub.session.add(ub.ShelfArchive(uuid=a.uuid, user_id=user_id))",
            "        ub.session_commit()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2021 OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "from flask_login import current_user",
            "from . import ub",
            "import datetime",
            "from sqlalchemy.sql.expression import or_, and_, true",
            "from sqlalchemy import exc",
            "",
            "# Add the current book id to kobo_synced_books table for current user, if entry is already present,",
            "# do nothing (safety precaution)",
            "def add_synced_books(book_id):",
            "    is_present = ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id)\\",
            "        .filter(ub.KoboSyncedBooks.user_id == current_user.id).count()",
            "    if not is_present:",
            "        synced_book = ub.KoboSyncedBooks()",
            "        synced_book.user_id = current_user.id",
            "        synced_book.book_id = book_id",
            "        ub.session.add(synced_book)",
            "        ub.session_commit()",
            "",
            "",
            "# Select all entries of current book in kobo_synced_books table, which are from current user and delete them",
            "def remove_synced_book(book_id, all=False, session=None):",
            "    if not all:",
            "        user = ub.KoboSyncedBooks.user_id == current_user.id",
            "    else:",
            "        user = true()",
            "    if not session:",
            "        ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id).filter(user).delete()",
            "        ub.session_commit()",
            "    else:",
            "        session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.book_id == book_id).filter(user).delete()",
            "        ub.session_commit(sess=session)",
            "",
            "",
            "",
            "def change_archived_books(book_id, state=None, message=None):",
            "    archived_book = ub.session.query(ub.ArchivedBook).filter(and_(ub.ArchivedBook.user_id == int(current_user.id),",
            "                                                                  ub.ArchivedBook.book_id == book_id)).first()",
            "    if not archived_book:",
            "        archived_book = ub.ArchivedBook(user_id=current_user.id, book_id=book_id)",
            "",
            "    archived_book.is_archived = state if state else not archived_book.is_archived",
            "    archived_book.last_modified = datetime.datetime.utcnow()",
            "",
            "    ub.session.merge(archived_book)",
            "    ub.session_commit(message)",
            "    return archived_book.is_archived",
            "",
            "",
            "# select all books which are synced by the current user and do not belong to a synced shelf and set them to archive",
            "# select all shelves from current user which are synced and do not belong to the \"only sync\" shelves",
            "def update_on_sync_shelfs(user_id):",
            "    books_to_archive = (ub.session.query(ub.KoboSyncedBooks)",
            "                        .join(ub.BookShelf, ub.KoboSyncedBooks.book_id == ub.BookShelf.book_id, isouter=True)",
            "                        .join(ub.Shelf, ub.Shelf.user_id == user_id, isouter=True)",
            "                        .filter(or_(ub.Shelf.kobo_sync == 0, ub.Shelf.kobo_sync == None))",
            "                        .filter(ub.KoboSyncedBooks.user_id == user_id).all())",
            "    for b in books_to_archive:",
            "        change_archived_books(b.book_id, True)",
            "        ub.session.query(ub.KoboSyncedBooks) \\",
            "            .filter(ub.KoboSyncedBooks.book_id == b.book_id) \\",
            "            .filter(ub.KoboSyncedBooks.user_id == user_id).delete()",
            "        ub.session_commit()",
            "",
            "    # Search all shelf which are currently not synced",
            "    shelves_to_archive = ub.session.query(ub.Shelf).filter(ub.Shelf.user_id == user_id).filter(",
            "        ub.Shelf.kobo_sync == 0).all()",
            "    for a in shelves_to_archive:",
            "        ub.session.add(ub.ShelfArchive(uuid=a.uuid, user_id=user_id))",
            "        ub.session_commit()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "39": [
                "remove_synced_book"
            ],
            "44": [
                "remove_synced_book"
            ],
            "45": [
                "remove_synced_book"
            ],
            "46": [
                "remove_synced_book"
            ]
        },
        "addLocation": []
    },
    "cps/tasks/convert.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " #  You should have received a copy of the GNU General Public License"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " #  along with this program. If not, see <http://www.gnu.org/licenses/>."
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import sys"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import re"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from cps import logger, config"
            },
            "8": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from cps.subproc_wrapper import process_open"
            },
            "9": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from flask_babel import gettext as _"
            },
            "10": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask import url_for"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+from cps.kobo_sync_status import remove_synced_book"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+from cps.ub import ini"
            },
            "13": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from cps.tasks.mail import TaskEmail"
            },
            "15": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " from cps import gdriveutils"
            },
            "16": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "                 try:"
            },
            "17": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                     local_db.session.merge(new_format)"
            },
            "18": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                     local_db.session.commit()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+                    if self.settings['new_book_format'].upper() in ['KEPUB', 'EPUB', 'EPUB3']:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                        ub_session = ini()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                        remove_synced_book(book_id, True, ub_session)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                        ub_session.close()"
            },
            "23": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "                 except SQLAlchemyError as e:"
            },
            "24": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "                     local_db.session.rollback()"
            },
            "25": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "                     log.error(\"Database error: %s\", e)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2020 pwr",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "import re",
            "",
            "from glob import glob",
            "from shutil import copyfile",
            "from markupsafe import escape",
            "",
            "from sqlalchemy.exc import SQLAlchemyError",
            "",
            "from cps.services.worker import CalibreTask",
            "from cps import db",
            "from cps import logger, config",
            "from cps.subproc_wrapper import process_open",
            "from flask_babel import gettext as _",
            "from flask import url_for",
            "",
            "from cps.tasks.mail import TaskEmail",
            "from cps import gdriveutils",
            "log = logger.create()",
            "",
            "",
            "class TaskConvert(CalibreTask):",
            "    def __init__(self, file_path, bookid, taskMessage, settings, kindle_mail, user=None):",
            "        super(TaskConvert, self).__init__(taskMessage)",
            "        self.file_path = file_path",
            "        self.bookid = bookid",
            "        self.title = \"\"",
            "        self.settings = settings",
            "        self.kindle_mail = kindle_mail",
            "        self.user = user",
            "",
            "        self.results = dict()",
            "",
            "    def run(self, worker_thread):",
            "        self.worker_thread = worker_thread",
            "        if config.config_use_google_drive:",
            "            worker_db = db.CalibreDB(expire_on_commit=False)",
            "            cur_book = worker_db.get_book(self.bookid)",
            "            self.title = cur_book.title",
            "            data = worker_db.get_book_format(self.bookid, self.settings['old_book_format'])",
            "            df = gdriveutils.getFileFromEbooksFolder(cur_book.path,",
            "                                                     data.name + \".\" + self.settings['old_book_format'].lower())",
            "            if df:",
            "                datafile = os.path.join(config.config_calibre_dir,",
            "                                        cur_book.path,",
            "                                        data.name + u\".\" + self.settings['old_book_format'].lower())",
            "                if not os.path.exists(os.path.join(config.config_calibre_dir, cur_book.path)):",
            "                    os.makedirs(os.path.join(config.config_calibre_dir, cur_book.path))",
            "                df.GetContentFile(datafile)",
            "                worker_db.session.close()",
            "            else:",
            "                error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",",
            "                                  format=self.settings['old_book_format'],",
            "                                  fn=data.name + \".\" + self.settings['old_book_format'].lower())",
            "                worker_db.session.close()",
            "                return error_message",
            "",
            "        filename = self._convert_ebook_format()",
            "        if config.config_use_google_drive:",
            "            os.remove(self.file_path + u'.' + self.settings['old_book_format'].lower())",
            "",
            "        if filename:",
            "            if config.config_use_google_drive:",
            "                # Upload files to gdrive",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "                self._handleSuccess()",
            "            if self.kindle_mail:",
            "                # if we're sending to kindle after converting, create a one-off task and run it immediately",
            "                # todo: figure out how to incorporate this into the progress",
            "                try:",
            "                    EmailText = _(u\"%(book)s send to Kindle\", book=escape(self.title))",
            "                    worker_thread.add(self.user, TaskEmail(self.settings['subject'],",
            "                                                           self.results[\"path\"],",
            "                                                           filename,",
            "                                                           self.settings,",
            "                                                           self.kindle_mail,",
            "                                                           EmailText,",
            "                                                           self.settings['body'],",
            "                                                           internal=True)",
            "                                      )",
            "                except Exception as ex:",
            "                    return self._handleError(str(ex))",
            "",
            "    def _convert_ebook_format(self):",
            "        error_message = None",
            "        local_db = db.CalibreDB(expire_on_commit=False)",
            "        file_path = self.file_path",
            "        book_id = self.bookid",
            "        format_old_ext = u'.' + self.settings['old_book_format'].lower()",
            "        format_new_ext = u'.' + self.settings['new_book_format'].lower()",
            "",
            "        # check to see if destination format already exists - or if book is in database",
            "        # if it does - mark the conversion task as complete and return a success",
            "        # this will allow send to kindle workflow to continue to work",
            "        if os.path.isfile(file_path + format_new_ext) or\\",
            "            local_db.get_book_format(self.bookid, self.settings['new_book_format']):",
            "            log.info(\"Book id %d already converted to %s\", book_id, format_new_ext)",
            "            cur_book = local_db.get_book(book_id)",
            "            self.title = cur_book.title",
            "            self.results['path'] = file_path",
            "            self.results['title'] = self.title",
            "            self._handleSuccess()",
            "            local_db.session.close()",
            "            return os.path.basename(file_path + format_new_ext)",
            "        else:",
            "            log.info(\"Book id %d - target format of %s does not exist. Moving forward with convert.\",",
            "                     book_id,",
            "                     format_new_ext)",
            "",
            "        if config.config_kepubifypath and format_old_ext == '.epub' and format_new_ext == '.kepub':",
            "            check, error_message = self._convert_kepubify(file_path,",
            "                                                          format_old_ext,",
            "                                                          format_new_ext)",
            "        else:",
            "            # check if calibre converter-executable is existing",
            "            if not os.path.exists(config.config_converterpath):",
            "                # ToDo Text is not translated",
            "                self._handleError(_(u\"Calibre ebook-convert %(tool)s not found\", tool=config.config_converterpath))",
            "                return",
            "            check, error_message = self._convert_calibre(file_path, format_old_ext, format_new_ext)",
            "",
            "        if check == 0:",
            "            cur_book = local_db.get_book(book_id)",
            "            if os.path.isfile(file_path + format_new_ext):",
            "                new_format = db.Data(name=cur_book.data[0].name,",
            "                                         book_format=self.settings['new_book_format'].upper(),",
            "                                         book=book_id, uncompressed_size=os.path.getsize(file_path + format_new_ext))",
            "                try:",
            "                    local_db.session.merge(new_format)",
            "                    local_db.session.commit()",
            "                except SQLAlchemyError as e:",
            "                    local_db.session.rollback()",
            "                    log.error(\"Database error: %s\", e)",
            "                    local_db.session.close()",
            "                    self._handleError(error_message)",
            "                    return",
            "                self.results['path'] = cur_book.path",
            "                self.title = cur_book.title",
            "                self.results['title'] = self.title",
            "                if not config.config_use_google_drive:",
            "                    self._handleSuccess()",
            "                return os.path.basename(file_path + format_new_ext)",
            "            else:",
            "                error_message = _('%(format)s format not found on disk', format=format_new_ext.upper())",
            "        local_db.session.close()",
            "        log.info(\"ebook converter failed with error while converting book\")",
            "        if not error_message:",
            "            error_message = _('Ebook converter failed with unknown error')",
            "        self._handleError(error_message)",
            "        return",
            "",
            "    def _convert_kepubify(self, file_path, format_old_ext, format_new_ext):",
            "        quotes = [1, 3]",
            "        command = [config.config_kepubifypath, (file_path + format_old_ext), '-o', os.path.dirname(file_path)]",
            "        try:",
            "            p = process_open(command, quotes)",
            "        except OSError as e:",
            "            return 1, _(u\"Kepubify-converter failed: %(error)s\", error=e)",
            "        self.progress = 0.01",
            "        while True:",
            "            nextline = p.stdout.readlines()",
            "            nextline = [x.strip('\\n') for x in nextline if x != '\\n']",
            "            for line in nextline:",
            "                log.debug(line)",
            "            if p.poll() is not None:",
            "                break",
            "",
            "        # ToD Handle",
            "        # process returncode",
            "        check = p.returncode",
            "",
            "        # move file",
            "        if check == 0:",
            "            converted_file = glob(os.path.join(os.path.dirname(file_path), \"*.kepub.epub\"))",
            "            if len(converted_file) == 1:",
            "                copyfile(converted_file[0], (file_path + format_new_ext))",
            "                os.unlink(converted_file[0])",
            "            else:",
            "                return 1, _(u\"Converted file not found or more than one file in folder %(folder)s\",",
            "                            folder=os.path.dirname(file_path))",
            "        return check, None",
            "",
            "    def _convert_calibre(self, file_path, format_old_ext, format_new_ext):",
            "        try:",
            "            # Linux py2.7 encode as list without quotes no empty element for parameters",
            "            # linux py3.x no encode and as list without quotes no empty element for parameters",
            "            # windows py2.7 encode as string with quotes empty element for parameters is okay",
            "            # windows py 3.x no encode and as string with quotes empty element for parameters is okay",
            "            # separate handling for windows and linux",
            "            quotes = [1, 2]",
            "            command = [config.config_converterpath, (file_path + format_old_ext),",
            "                       (file_path + format_new_ext)]",
            "            quotes_index = 3",
            "            if config.config_calibre:",
            "                parameters = config.config_calibre.split(\" \")",
            "                for param in parameters:",
            "                    command.append(param)",
            "                    quotes.append(quotes_index)",
            "                    quotes_index += 1",
            "",
            "            p = process_open(command, quotes, newlines=False)",
            "        except OSError as e:",
            "            return 1, _(u\"Ebook-converter failed: %(error)s\", error=e)",
            "",
            "        while p.poll() is None:",
            "            nextline = p.stdout.readline()",
            "            if isinstance(nextline, bytes):",
            "                nextline = nextline.decode('utf-8', errors=\"ignore\").strip('\\r\\n')",
            "            if nextline:",
            "                log.debug(nextline)",
            "            # parse progress string from calibre-converter",
            "            progress = re.search(r\"(\\d+)%\\s.*\", nextline)",
            "            if progress:",
            "                self.progress = int(progress.group(1)) / 100",
            "                if config.config_use_google_drive:",
            "                    self.progress *= 0.9",
            "",
            "        # process returncode",
            "        check = p.returncode",
            "        calibre_traceback = p.stderr.readlines()",
            "        error_message = \"\"",
            "        for ele in calibre_traceback:",
            "            ele = ele.decode('utf-8', errors=\"ignore\").strip('\\n')",
            "            log.debug(ele)",
            "            if not ele.startswith('Traceback') and not ele.startswith('  File'):",
            "                error_message = _(\"Calibre failed with error: %(error)s\", error=ele)",
            "        return check, error_message",
            "",
            "    @property",
            "    def name(self):",
            "        return \"Convert\"",
            "",
            "    def __str__(self):",
            "        return \"Convert {} {}\".format(self.bookid, self.kindle_mail)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2020 pwr",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "",
            "from glob import glob",
            "from shutil import copyfile",
            "from markupsafe import escape",
            "",
            "from sqlalchemy.exc import SQLAlchemyError",
            "",
            "from cps.services.worker import CalibreTask",
            "from cps import db",
            "from cps import logger, config",
            "from cps.subproc_wrapper import process_open",
            "from flask_babel import gettext as _",
            "from cps.kobo_sync_status import remove_synced_book",
            "from cps.ub import ini",
            "",
            "from cps.tasks.mail import TaskEmail",
            "from cps import gdriveutils",
            "log = logger.create()",
            "",
            "",
            "class TaskConvert(CalibreTask):",
            "    def __init__(self, file_path, bookid, taskMessage, settings, kindle_mail, user=None):",
            "        super(TaskConvert, self).__init__(taskMessage)",
            "        self.file_path = file_path",
            "        self.bookid = bookid",
            "        self.title = \"\"",
            "        self.settings = settings",
            "        self.kindle_mail = kindle_mail",
            "        self.user = user",
            "",
            "        self.results = dict()",
            "",
            "    def run(self, worker_thread):",
            "        self.worker_thread = worker_thread",
            "        if config.config_use_google_drive:",
            "            worker_db = db.CalibreDB(expire_on_commit=False)",
            "            cur_book = worker_db.get_book(self.bookid)",
            "            self.title = cur_book.title",
            "            data = worker_db.get_book_format(self.bookid, self.settings['old_book_format'])",
            "            df = gdriveutils.getFileFromEbooksFolder(cur_book.path,",
            "                                                     data.name + \".\" + self.settings['old_book_format'].lower())",
            "            if df:",
            "                datafile = os.path.join(config.config_calibre_dir,",
            "                                        cur_book.path,",
            "                                        data.name + u\".\" + self.settings['old_book_format'].lower())",
            "                if not os.path.exists(os.path.join(config.config_calibre_dir, cur_book.path)):",
            "                    os.makedirs(os.path.join(config.config_calibre_dir, cur_book.path))",
            "                df.GetContentFile(datafile)",
            "                worker_db.session.close()",
            "            else:",
            "                error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",",
            "                                  format=self.settings['old_book_format'],",
            "                                  fn=data.name + \".\" + self.settings['old_book_format'].lower())",
            "                worker_db.session.close()",
            "                return error_message",
            "",
            "        filename = self._convert_ebook_format()",
            "        if config.config_use_google_drive:",
            "            os.remove(self.file_path + u'.' + self.settings['old_book_format'].lower())",
            "",
            "        if filename:",
            "            if config.config_use_google_drive:",
            "                # Upload files to gdrive",
            "                gdriveutils.updateGdriveCalibreFromLocal()",
            "                self._handleSuccess()",
            "            if self.kindle_mail:",
            "                # if we're sending to kindle after converting, create a one-off task and run it immediately",
            "                # todo: figure out how to incorporate this into the progress",
            "                try:",
            "                    EmailText = _(u\"%(book)s send to Kindle\", book=escape(self.title))",
            "                    worker_thread.add(self.user, TaskEmail(self.settings['subject'],",
            "                                                           self.results[\"path\"],",
            "                                                           filename,",
            "                                                           self.settings,",
            "                                                           self.kindle_mail,",
            "                                                           EmailText,",
            "                                                           self.settings['body'],",
            "                                                           internal=True)",
            "                                      )",
            "                except Exception as ex:",
            "                    return self._handleError(str(ex))",
            "",
            "    def _convert_ebook_format(self):",
            "        error_message = None",
            "        local_db = db.CalibreDB(expire_on_commit=False)",
            "        file_path = self.file_path",
            "        book_id = self.bookid",
            "        format_old_ext = u'.' + self.settings['old_book_format'].lower()",
            "        format_new_ext = u'.' + self.settings['new_book_format'].lower()",
            "",
            "        # check to see if destination format already exists - or if book is in database",
            "        # if it does - mark the conversion task as complete and return a success",
            "        # this will allow send to kindle workflow to continue to work",
            "        if os.path.isfile(file_path + format_new_ext) or\\",
            "            local_db.get_book_format(self.bookid, self.settings['new_book_format']):",
            "            log.info(\"Book id %d already converted to %s\", book_id, format_new_ext)",
            "            cur_book = local_db.get_book(book_id)",
            "            self.title = cur_book.title",
            "            self.results['path'] = file_path",
            "            self.results['title'] = self.title",
            "            self._handleSuccess()",
            "            local_db.session.close()",
            "            return os.path.basename(file_path + format_new_ext)",
            "        else:",
            "            log.info(\"Book id %d - target format of %s does not exist. Moving forward with convert.\",",
            "                     book_id,",
            "                     format_new_ext)",
            "",
            "        if config.config_kepubifypath and format_old_ext == '.epub' and format_new_ext == '.kepub':",
            "            check, error_message = self._convert_kepubify(file_path,",
            "                                                          format_old_ext,",
            "                                                          format_new_ext)",
            "        else:",
            "            # check if calibre converter-executable is existing",
            "            if not os.path.exists(config.config_converterpath):",
            "                # ToDo Text is not translated",
            "                self._handleError(_(u\"Calibre ebook-convert %(tool)s not found\", tool=config.config_converterpath))",
            "                return",
            "            check, error_message = self._convert_calibre(file_path, format_old_ext, format_new_ext)",
            "",
            "        if check == 0:",
            "            cur_book = local_db.get_book(book_id)",
            "            if os.path.isfile(file_path + format_new_ext):",
            "                new_format = db.Data(name=cur_book.data[0].name,",
            "                                         book_format=self.settings['new_book_format'].upper(),",
            "                                         book=book_id, uncompressed_size=os.path.getsize(file_path + format_new_ext))",
            "                try:",
            "                    local_db.session.merge(new_format)",
            "                    local_db.session.commit()",
            "                    if self.settings['new_book_format'].upper() in ['KEPUB', 'EPUB', 'EPUB3']:",
            "                        ub_session = ini()",
            "                        remove_synced_book(book_id, True, ub_session)",
            "                        ub_session.close()",
            "                except SQLAlchemyError as e:",
            "                    local_db.session.rollback()",
            "                    log.error(\"Database error: %s\", e)",
            "                    local_db.session.close()",
            "                    self._handleError(error_message)",
            "                    return",
            "                self.results['path'] = cur_book.path",
            "                self.title = cur_book.title",
            "                self.results['title'] = self.title",
            "                if not config.config_use_google_drive:",
            "                    self._handleSuccess()",
            "                return os.path.basename(file_path + format_new_ext)",
            "            else:",
            "                error_message = _('%(format)s format not found on disk', format=format_new_ext.upper())",
            "        local_db.session.close()",
            "        log.info(\"ebook converter failed with error while converting book\")",
            "        if not error_message:",
            "            error_message = _('Ebook converter failed with unknown error')",
            "        self._handleError(error_message)",
            "        return",
            "",
            "    def _convert_kepubify(self, file_path, format_old_ext, format_new_ext):",
            "        quotes = [1, 3]",
            "        command = [config.config_kepubifypath, (file_path + format_old_ext), '-o', os.path.dirname(file_path)]",
            "        try:",
            "            p = process_open(command, quotes)",
            "        except OSError as e:",
            "            return 1, _(u\"Kepubify-converter failed: %(error)s\", error=e)",
            "        self.progress = 0.01",
            "        while True:",
            "            nextline = p.stdout.readlines()",
            "            nextline = [x.strip('\\n') for x in nextline if x != '\\n']",
            "            for line in nextline:",
            "                log.debug(line)",
            "            if p.poll() is not None:",
            "                break",
            "",
            "        # ToD Handle",
            "        # process returncode",
            "        check = p.returncode",
            "",
            "        # move file",
            "        if check == 0:",
            "            converted_file = glob(os.path.join(os.path.dirname(file_path), \"*.kepub.epub\"))",
            "            if len(converted_file) == 1:",
            "                copyfile(converted_file[0], (file_path + format_new_ext))",
            "                os.unlink(converted_file[0])",
            "            else:",
            "                return 1, _(u\"Converted file not found or more than one file in folder %(folder)s\",",
            "                            folder=os.path.dirname(file_path))",
            "        return check, None",
            "",
            "    def _convert_calibre(self, file_path, format_old_ext, format_new_ext):",
            "        try:",
            "            # Linux py2.7 encode as list without quotes no empty element for parameters",
            "            # linux py3.x no encode and as list without quotes no empty element for parameters",
            "            # windows py2.7 encode as string with quotes empty element for parameters is okay",
            "            # windows py 3.x no encode and as string with quotes empty element for parameters is okay",
            "            # separate handling for windows and linux",
            "            quotes = [1, 2]",
            "            command = [config.config_converterpath, (file_path + format_old_ext),",
            "                       (file_path + format_new_ext)]",
            "            quotes_index = 3",
            "            if config.config_calibre:",
            "                parameters = config.config_calibre.split(\" \")",
            "                for param in parameters:",
            "                    command.append(param)",
            "                    quotes.append(quotes_index)",
            "                    quotes_index += 1",
            "",
            "            p = process_open(command, quotes, newlines=False)",
            "        except OSError as e:",
            "            return 1, _(u\"Ebook-converter failed: %(error)s\", error=e)",
            "",
            "        while p.poll() is None:",
            "            nextline = p.stdout.readline()",
            "            if isinstance(nextline, bytes):",
            "                nextline = nextline.decode('utf-8', errors=\"ignore\").strip('\\r\\n')",
            "            if nextline:",
            "                log.debug(nextline)",
            "            # parse progress string from calibre-converter",
            "            progress = re.search(r\"(\\d+)%\\s.*\", nextline)",
            "            if progress:",
            "                self.progress = int(progress.group(1)) / 100",
            "                if config.config_use_google_drive:",
            "                    self.progress *= 0.9",
            "",
            "        # process returncode",
            "        check = p.returncode",
            "        calibre_traceback = p.stderr.readlines()",
            "        error_message = \"\"",
            "        for ele in calibre_traceback:",
            "            ele = ele.decode('utf-8', errors=\"ignore\").strip('\\n')",
            "            log.debug(ele)",
            "            if not ele.startswith('Traceback') and not ele.startswith('  File'):",
            "                error_message = _(\"Calibre failed with error: %(error)s\", error=ele)",
            "        return check, error_message",
            "",
            "    @property",
            "    def name(self):",
            "        return \"Convert\"",
            "",
            "    def __str__(self):",
            "        return \"Convert {} {}\".format(self.bookid, self.kindle_mail)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [],
            "34": []
        },
        "addLocation": []
    },
    "cps/ub.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 773,
                "afterPatchRowNumber": 773,
                "PatchRowcode": "     except Exception:"
            },
            "1": {
                "beforePatchRowNumber": 774,
                "afterPatchRowNumber": 774,
                "PatchRowcode": "         session.rollback()"
            },
            "2": {
                "beforePatchRowNumber": 775,
                "afterPatchRowNumber": 775,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 776,
                "PatchRowcode": "+def ini():"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 777,
                "PatchRowcode": "+    global app_DB_path"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 778,
                "PatchRowcode": "+    engine = create_engine(u'sqlite:///{0}'.format(app_DB_path), echo=False)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 779,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 780,
                "PatchRowcode": "+    Session = scoped_session(sessionmaker())"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 781,
                "PatchRowcode": "+    Session.configure(bind=engine)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 782,
                "PatchRowcode": "+    return Session()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 783,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 776,
                "afterPatchRowNumber": 784,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 785,
                "PatchRowcode": " def init_db(app_db_path):"
            },
            "13": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": 786,
                "PatchRowcode": "     # Open session for database connection"
            },
            "14": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 838,
                "PatchRowcode": "             except Exception:"
            },
            "15": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": 839,
                "PatchRowcode": "                 pass"
            },
            "16": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 840,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def session_commit(success=None):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+def session_commit(success=None, sess=None):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+    s = sess if sess else session"
            },
            "20": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 843,
                "PatchRowcode": "     try:"
            },
            "21": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        session.commit()"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+        s.commit()"
            },
            "23": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": 845,
                "PatchRowcode": "         if success:"
            },
            "24": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": 846,
                "PatchRowcode": "             log.info(success)"
            },
            "25": {
                "beforePatchRowNumber": 838,
                "afterPatchRowNumber": 847,
                "PatchRowcode": "     except (exc.OperationalError, exc.InvalidRequestError) as e:"
            },
            "26": {
                "beforePatchRowNumber": 839,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        session.rollback()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 848,
                "PatchRowcode": "+        s.rollback()"
            },
            "28": {
                "beforePatchRowNumber": 840,
                "afterPatchRowNumber": 849,
                "PatchRowcode": "         log.debug_or_exception(e)"
            },
            "29": {
                "beforePatchRowNumber": 841,
                "afterPatchRowNumber": 850,
                "PatchRowcode": "     return \"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2012-2019 mutschler, jkrehm, cervinko, janeczku, OzzieIsaacs, csitko",
            "#                            ok11, issmirnov, idalin",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import sys",
            "import datetime",
            "import itertools",
            "import uuid",
            "from flask import session as flask_session",
            "from binascii import hexlify",
            "",
            "from flask_login import AnonymousUserMixin, current_user",
            "from flask_login import user_logged_in",
            "",
            "try:",
            "    from flask_dance.consumer.backend.sqla import OAuthConsumerMixin",
            "    oauth_support = True",
            "except ImportError as e:",
            "    # fails on flask-dance >1.3, due to renaming",
            "    try:",
            "        from flask_dance.consumer.storage.sqla import OAuthConsumerMixin",
            "        oauth_support = True",
            "    except ImportError as e:",
            "        oauth_support = False",
            "from sqlalchemy import create_engine, exc, exists, event, text",
            "from sqlalchemy import Column, ForeignKey",
            "from sqlalchemy import String, Integer, SmallInteger, Boolean, DateTime, Float, JSON",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.sql.expression import func",
            "try:",
            "    # Compatibility with sqlalchemy 2.0",
            "    from sqlalchemy.orm import declarative_base",
            "except ImportError:",
            "    from sqlalchemy.ext.declarative import declarative_base",
            "from sqlalchemy.orm import backref, relationship, sessionmaker, Session, scoped_session",
            "from werkzeug.security import generate_password_hash",
            "",
            "from . import constants, logger, cli",
            "",
            "log = logger.create()",
            "",
            "session = None",
            "app_DB_path = None",
            "Base = declarative_base()",
            "searched_ids = {}",
            "",
            "logged_in = dict()",
            "",
            "",
            "def signal_store_user_session(object, user):",
            "    store_user_session()",
            "",
            "def store_user_session():",
            "    if flask_session.get('user_id', \"\"):",
            "        flask_session['_user_id'] = flask_session.get('user_id', \"\")",
            "    if flask_session.get('_user_id', \"\"):",
            "        try:",
            "            if not check_user_session(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\")):",
            "                user_session = User_Sessions(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\"))",
            "                session.add(user_session)",
            "                session.commit()",
            "                log.debug(\"Login and store session : \" + flask_session.get('_id', \"\"))",
            "            else:",
            "                log.debug(\"Found stored session: \" + flask_session.get('_id', \"\"))",
            "        except (exc.OperationalError, exc.InvalidRequestError) as e:",
            "            session.rollback()",
            "            log.exception(e)",
            "    else:",
            "        log.error(\"No user id in session\")",
            "",
            "def delete_user_session(user_id, session_key):",
            "    try:",
            "        log.debug(\"Deleted session_key: \" + session_key)",
            "        session.query(User_Sessions).filter(User_Sessions.user_id==user_id,",
            "                                            User_Sessions.session_key==session_key).delete()",
            "        session.commit()",
            "    except (exc.OperationalError, exc.InvalidRequestError):",
            "        session.rollback()",
            "        log.exception(e)",
            "",
            "",
            "def check_user_session(user_id, session_key):",
            "    try:",
            "        return bool(session.query(User_Sessions).filter(User_Sessions.user_id==user_id,",
            "                                                       User_Sessions.session_key==session_key).one_or_none())",
            "    except (exc.OperationalError, exc.InvalidRequestError):",
            "        session.rollback()",
            "        log.exception(e)",
            "",
            "",
            "user_logged_in.connect(signal_store_user_session)",
            "",
            "def store_ids(result):",
            "    ids = list()",
            "    for element in result:",
            "        ids.append(element.id)",
            "    searched_ids[current_user.id] = ids",
            "",
            "",
            "class UserBase:",
            "",
            "    @property",
            "    def is_authenticated(self):",
            "        return self.is_active",
            "",
            "    def _has_role(self, role_flag):",
            "        return constants.has_flag(self.role, role_flag)",
            "",
            "    def role_admin(self):",
            "        return self._has_role(constants.ROLE_ADMIN)",
            "",
            "    def role_download(self):",
            "        return self._has_role(constants.ROLE_DOWNLOAD)",
            "",
            "    def role_upload(self):",
            "        return self._has_role(constants.ROLE_UPLOAD)",
            "",
            "    def role_edit(self):",
            "        return self._has_role(constants.ROLE_EDIT)",
            "",
            "    def role_passwd(self):",
            "        return self._has_role(constants.ROLE_PASSWD)",
            "",
            "    def role_anonymous(self):",
            "        return self._has_role(constants.ROLE_ANONYMOUS)",
            "",
            "    def role_edit_shelfs(self):",
            "        return self._has_role(constants.ROLE_EDIT_SHELFS)",
            "",
            "    def role_delete_books(self):",
            "        return self._has_role(constants.ROLE_DELETE_BOOKS)",
            "",
            "    def role_viewer(self):",
            "        return self._has_role(constants.ROLE_VIEWER)",
            "",
            "    @property",
            "    def is_active(self):",
            "        return True",
            "",
            "    @property",
            "    def is_anonymous(self):",
            "        return self.role_anonymous()",
            "",
            "    def get_id(self):",
            "        return str(self.id)",
            "",
            "    def filter_language(self):",
            "        return self.default_language",
            "",
            "    def check_visibility(self, value):",
            "        if value == constants.SIDEBAR_RECENT:",
            "            return True",
            "        return constants.has_flag(self.sidebar_view, value)",
            "",
            "    def show_detail_random(self):",
            "        return self.check_visibility(constants.DETAIL_RANDOM)",
            "",
            "    def list_denied_tags(self):",
            "        mct = self.denied_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_tags(self):",
            "        mct = self.allowed_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_denied_column_values(self):",
            "        mct = self.denied_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_column_values(self):",
            "        mct = self.allowed_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def get_view_property(self, page, prop):",
            "        if not self.view_settings.get(page):",
            "            return None",
            "        return self.view_settings[page].get(prop)",
            "",
            "    def set_view_property(self, page, prop, value):",
            "        if not self.view_settings.get(page):",
            "            self.view_settings[page] = dict()",
            "        self.view_settings[page][prop] = value",
            "        try:",
            "            flag_modified(self, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        try:",
            "            session.commit()",
            "        except (exc.OperationalError, exc.InvalidRequestError):",
            "            session.rollback()",
            "            # ToDo: Error message",
            "",
            "    def __repr__(self):",
            "        return '<User %r>' % self.name",
            "",
            "",
            "# Baseclass for Users in Calibre-Web, settings which are depending on certain users are stored here. It is derived from",
            "# User Base (all access methods are declared there)",
            "class User(UserBase, Base):",
            "    __tablename__ = 'user'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    name = Column(String(64), unique=True)",
            "    email = Column(String(120), unique=True, default=\"\")",
            "    role = Column(SmallInteger, default=constants.ROLE_USER)",
            "    password = Column(String)",
            "    kindle_mail = Column(String(120), default=\"\")",
            "    shelf = relationship('Shelf', backref='user', lazy='dynamic', order_by='Shelf.name')",
            "    downloads = relationship('Downloads', backref='user', lazy='dynamic')",
            "    locale = Column(String(2), default=\"en\")",
            "    sidebar_view = Column(Integer, default=1)",
            "    default_language = Column(String(3), default=\"all\")",
            "    denied_tags = Column(String, default=\"\")",
            "    allowed_tags = Column(String, default=\"\")",
            "    denied_column_value = Column(String, default=\"\")",
            "    allowed_column_value = Column(String, default=\"\")",
            "    remote_auth_token = relationship('RemoteAuthToken', backref='user', lazy='dynamic')",
            "    view_settings = Column(JSON, default={})",
            "    kobo_only_shelves_sync = Column(Integer, default=0)",
            "",
            "",
            "if oauth_support:",
            "    class OAuth(OAuthConsumerMixin, Base):",
            "        provider_user_id = Column(String(256))",
            "        user_id = Column(Integer, ForeignKey(User.id))",
            "        user = relationship(User)",
            "",
            "",
            "class OAuthProvider(Base):",
            "    __tablename__ = 'oauthProvider'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    provider_name = Column(String)",
            "    oauth_client_id = Column(String)",
            "    oauth_client_secret = Column(String)",
            "    active = Column(Boolean)",
            "",
            "",
            "# Class for anonymous user is derived from User base and completly overrides methods and properties for the",
            "# anonymous user",
            "class Anonymous(AnonymousUserMixin, UserBase):",
            "    def __init__(self):",
            "        self.loadSettings()",
            "",
            "    def loadSettings(self):",
            "        data = session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS)\\",
            "            .first()  # type: User",
            "        self.name = data.name",
            "        self.role = data.role",
            "        self.id=data.id",
            "        self.sidebar_view = data.sidebar_view",
            "        self.default_language = data.default_language",
            "        self.locale = data.locale",
            "        self.kindle_mail = data.kindle_mail",
            "        self.denied_tags = data.denied_tags",
            "        self.allowed_tags = data.allowed_tags",
            "        self.denied_column_value = data.denied_column_value",
            "        self.allowed_column_value = data.allowed_column_value",
            "        self.view_settings = data.view_settings",
            "        self.kobo_only_shelves_sync = data.kobo_only_shelves_sync",
            "",
            "",
            "    def role_admin(self):",
            "        return False",
            "",
            "    @property",
            "    def is_active(self):",
            "        return False",
            "",
            "    @property",
            "    def is_anonymous(self):",
            "        return True",
            "",
            "    @property",
            "    def is_authenticated(self):",
            "        return False",
            "",
            "    def get_view_property(self, page, prop):",
            "        if 'view' in flask_session:",
            "            if not flask_session['view'].get(page):",
            "                return None",
            "            return flask_session['view'][page].get(prop)",
            "        return None",
            "",
            "    def set_view_property(self, page, prop, value):",
            "        if not 'view' in flask_session:",
            "            flask_session['view'] = dict()",
            "        if not flask_session['view'].get(page):",
            "            flask_session['view'][page] = dict()",
            "        flask_session['view'][page][prop] = value",
            "",
            "class User_Sessions(Base):",
            "    __tablename__ = 'user_session'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    session_key = Column(String, default=\"\")",
            "",
            "    def __init__(self, user_id, session_key):",
            "        self.user_id = user_id",
            "        self.session_key = session_key",
            "",
            "",
            "# Baseclass representing Shelfs in calibre-web in app.db",
            "class Shelf(Base):",
            "    __tablename__ = 'shelf'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    uuid = Column(String, default=lambda: str(uuid.uuid4()))",
            "    name = Column(String)",
            "    is_public = Column(Integer, default=0)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    kobo_sync = Column(Boolean, default=False)",
            "    books = relationship(\"BookShelf\", backref=\"ub_shelf\", cascade=\"all, delete-orphan\", lazy=\"dynamic\")",
            "    created = Column(DateTime, default=datetime.datetime.utcnow)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "",
            "    def __repr__(self):",
            "        return '<Shelf %d:%r>' % (self.id, self.name)",
            "",
            "",
            "# Baseclass representing Relationship between books and Shelfs in Calibre-Web in app.db (N:M)",
            "class BookShelf(Base):",
            "    __tablename__ = 'book_shelf_link'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer)",
            "    order = Column(Integer)",
            "    shelf = Column(Integer, ForeignKey('shelf.id'))",
            "    date_added = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "    def __repr__(self):",
            "        return '<Book %r>' % self.id",
            "",
            "",
            "# This table keeps track of deleted Shelves so that deletes can be propagated to any paired Kobo device.",
            "class ShelfArchive(Base):",
            "    __tablename__ = 'shelf_archive'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    uuid = Column(String)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "",
            "class ReadBook(Base):",
            "    __tablename__ = 'book_read_link'",
            "",
            "    STATUS_UNREAD = 0",
            "    STATUS_FINISHED = 1",
            "    STATUS_IN_PROGRESS = 2",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer, unique=False)",
            "    user_id = Column(Integer, ForeignKey('user.id'), unique=False)",
            "    read_status = Column(Integer, unique=False, default=STATUS_UNREAD, nullable=False)",
            "    kobo_reading_state = relationship(\"KoboReadingState\", uselist=False,",
            "                                      primaryjoin=\"and_(ReadBook.user_id == foreign(KoboReadingState.user_id), \"",
            "                                                  \"ReadBook.book_id == foreign(KoboReadingState.book_id))\",",
            "                                      cascade=\"all\",",
            "                                      backref=backref(\"book_read_link\",",
            "                                                      uselist=False))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    last_time_started_reading = Column(DateTime, nullable=True)",
            "    times_started_reading = Column(Integer, default=0, nullable=False)",
            "",
            "",
            "class Bookmark(Base):",
            "    __tablename__ = 'bookmark'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    format = Column(String(collation='NOCASE'))",
            "    bookmark_key = Column(String)",
            "",
            "",
            "# Baseclass representing books that are archived on the user's Kobo device.",
            "class ArchivedBook(Base):",
            "    __tablename__ = 'archived_book'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    is_archived = Column(Boolean, unique=False)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "",
            "class KoboSyncedBooks(Base):",
            "    __tablename__ = 'kobo_synced_books'",
            "    id = Column(Integer, primary_key=True, autoincrement=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "",
            "# The Kobo ReadingState API keeps track of 4 timestamped entities:",
            "#   ReadingState, StatusInfo, Statistics, CurrentBookmark",
            "# Which we map to the following 4 tables:",
            "#   KoboReadingState, ReadBook, KoboStatistics and KoboBookmark",
            "class KoboReadingState(Base):",
            "    __tablename__ = 'kobo_reading_state'",
            "",
            "    id = Column(Integer, primary_key=True, autoincrement=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    priority_timestamp = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    current_bookmark = relationship(\"KoboBookmark\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all, delete\")",
            "    statistics = relationship(\"KoboStatistics\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all, delete\")",
            "",
            "",
            "class KoboBookmark(Base):",
            "    __tablename__ = 'kobo_bookmark'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    location_source = Column(String)",
            "    location_type = Column(String)",
            "    location_value = Column(String)",
            "    progress_percent = Column(Float)",
            "    content_source_progress_percent = Column(Float)",
            "",
            "",
            "class KoboStatistics(Base):",
            "    __tablename__ = 'kobo_statistics'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    remaining_time_minutes = Column(Integer)",
            "    spent_reading_minutes = Column(Integer)",
            "",
            "",
            "# Updates the last_modified timestamp in the KoboReadingState table if any of its children tables are modified.",
            "@event.listens_for(Session, 'before_flush')",
            "def receive_before_flush(session, flush_context, instances):",
            "    for change in itertools.chain(session.new, session.dirty):",
            "        if isinstance(change, (ReadBook, KoboStatistics, KoboBookmark)):",
            "            if change.kobo_reading_state:",
            "                change.kobo_reading_state.last_modified = datetime.datetime.utcnow()",
            "    # Maintain the last_modified bit for the Shelf table.",
            "    for change in itertools.chain(session.new, session.deleted):",
            "        if isinstance(change, BookShelf):",
            "            change.ub_shelf.last_modified = datetime.datetime.utcnow()",
            "",
            "",
            "# Baseclass representing Downloads from calibre-web in app.db",
            "class Downloads(Base):",
            "    __tablename__ = 'downloads'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "",
            "    def __repr__(self):",
            "        return '<Download %r' % self.book_id",
            "",
            "",
            "# Baseclass representing allowed domains for registration",
            "class Registration(Base):",
            "    __tablename__ = 'registration'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    domain = Column(String)",
            "    allow = Column(Integer)",
            "",
            "    def __repr__(self):",
            "        return u\"<Registration('{0}')>\".format(self.domain)",
            "",
            "",
            "class RemoteAuthToken(Base):",
            "    __tablename__ = 'remote_auth_token'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    auth_token = Column(String, unique=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    verified = Column(Boolean, default=False)",
            "    expiration = Column(DateTime)",
            "    token_type = Column(Integer, default=0)",
            "",
            "    def __init__(self):",
            "        self.auth_token = (hexlify(os.urandom(4))).decode('utf-8')",
            "        self.expiration = datetime.datetime.now() + datetime.timedelta(minutes=10)  # 10 min from now",
            "",
            "    def __repr__(self):",
            "        return '<Token %r>' % self.id",
            "",
            "",
            "# Add missing tables during migration of database",
            "def add_missing_tables(engine, session):",
            "    if not engine.dialect.has_table(engine.connect(), \"book_read_link\"):",
            "        ReadBook.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"bookmark\"):",
            "        Bookmark.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_reading_state\"):",
            "        KoboReadingState.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_bookmark\"):",
            "        KoboBookmark.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_statistics\"):",
            "        KoboStatistics.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"archived_book\"):",
            "        ArchivedBook.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"registration\"):",
            "        Registration.__table__.create(bind=engine)",
            "        with engine.connect() as conn:",
            "            conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")",
            "        session.commit()",
            "",
            "",
            "# migrate all settings missing in registration table",
            "def migrate_registration_table(engine, session):",
            "    try:",
            "        session.query(exists().where(Registration.allow)).scalar()",
            "        session.commit()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE registration ADD column 'allow' INTEGER\")",
            "            conn.execute(\"update registration set 'allow' = 1\")",
            "        session.commit()",
            "    try:",
            "        # Handle table exists, but no content",
            "        cnt = session.query(Registration).count()",
            "        if not cnt:",
            "            with engine.connect() as conn:",
            "                conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")",
            "            session.commit()",
            "    except exc.OperationalError:  # Database is not writeable",
            "        print('Settings database is not writeable. Exiting...')",
            "        sys.exit(2)",
            "",
            "",
            "# Remove login capability of user Guest",
            "def migrate_guest_password(engine):",
            "    try:",
            "        with engine.connect() as conn:",
            "            trans = conn.begin()",
            "            conn.execute(text(\"UPDATE user SET password='' where name = 'Guest' and password !=''\"))",
            "            trans.commit()",
            "    except exc.OperationalError:",
            "        print('Settings database is not writeable. Exiting...')",
            "        sys.exit(2)",
            "",
            "",
            "def migrate_shelfs(engine, session):",
            "    try:",
            "        session.query(exists().where(Shelf.uuid)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'uuid' STRING\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'created' DATETIME\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'last_modified' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'date_added' DATETIME\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")",
            "        for shelf in session.query(Shelf).all():",
            "            shelf.uuid = str(uuid.uuid4())",
            "            shelf.created = datetime.datetime.now()",
            "            shelf.last_modified = datetime.datetime.now()",
            "        for book_shelf in session.query(BookShelf).all():",
            "            book_shelf.date_added = datetime.datetime.now()",
            "        session.commit()",
            "",
            "    try:",
            "        session.query(exists().where(Shelf.kobo_sync)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")",
            "        session.commit()",
            "",
            "    try:",
            "        session.query(exists().where(BookShelf.order)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'order' INTEGER DEFAULT 1\")",
            "        session.commit()",
            "",
            "",
            "def migrate_readBook(engine, session):",
            "    try:",
            "        session.query(exists().where(ReadBook.read_status)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'read_status' INTEGER DEFAULT 0\")",
            "            conn.execute(\"UPDATE book_read_link SET 'read_status' = 1 WHERE is_read\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_modified' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_time_started_reading' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'times_started_reading' INTEGER DEFAULT 0\")",
            "        session.commit()",
            "    test = session.query(ReadBook).filter(ReadBook.last_modified == None).all()",
            "    for book in test:",
            "        book.last_modified = datetime.datetime.utcnow()",
            "    session.commit()",
            "",
            "",
            "def migrate_remoteAuthToken(engine, session):",
            "    try:",
            "        session.query(exists().where(RemoteAuthToken.token_type)).scalar()",
            "        session.commit()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE remote_auth_token ADD column 'token_type' INTEGER DEFAULT 0\")",
            "            conn.execute(\"update remote_auth_token set 'token_type' = 0\")",
            "        session.commit()",
            "",
            "# Migrate database to current version, has to be updated after every database change. Currently migration from",
            "# everywhere to current should work. Migration is done by checking if relevant columns are existing, and than adding",
            "# rows with SQL commands",
            "def migrate_Database(session):",
            "    engine = session.bind",
            "    add_missing_tables(engine, session)",
            "    migrate_registration_table(engine, session)",
            "    migrate_readBook(engine, session)",
            "    migrate_remoteAuthToken(engine, session)",
            "    migrate_shelfs(engine, session)",
            "    try:",
            "        create = False",
            "        session.query(exists().where(User.sidebar_view)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `sidebar_view` Integer DEFAULT 1\")",
            "        session.commit()",
            "        create = True",
            "    try:",
            "        if create:",
            "            with engine.connect() as conn:",
            "                conn.execute(\"SELECT language_books FROM user\")",
            "            session.commit()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"UPDATE user SET 'sidebar_view' = (random_books* :side_random + language_books * :side_lang \"",
            "                     \"+ series_books * :side_series + category_books * :side_category + hot_books * \"",
            "                     \":side_hot + :side_autor + :detail_random)\",",
            "                     {'side_random': constants.SIDEBAR_RANDOM, 'side_lang': constants.SIDEBAR_LANGUAGE,",
            "                      'side_series': constants.SIDEBAR_SERIES, 'side_category': constants.SIDEBAR_CATEGORY,",
            "                      'side_hot': constants.SIDEBAR_HOT, 'side_autor': constants.SIDEBAR_AUTHOR,",
            "                      'detail_random': constants.DETAIL_RANDOM})",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.denied_tags)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `denied_tags` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `allowed_tags` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `denied_column_value` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `allowed_column_value` String DEFAULT ''\")",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.view_settings)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `view_settings` VARCHAR(10) DEFAULT '{}'\")",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.kobo_only_shelves_sync)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `kobo_only_shelves_sync` SMALLINT DEFAULT 0\")",
            "        session.commit()",
            "",
            "    try:",
            "        # check if name is in User table instead of nickname",
            "        session.query(exists().where(User.name)).scalar()",
            "    except exc.OperationalError:",
            "        # Create new table user_id and copy contents of table user into it",
            "        with engine.connect() as conn:",
            "            conn.execute(text(\"CREATE TABLE user_id (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\"",
            "                     \"name VARCHAR(64),\"",
            "                     \"email VARCHAR(120),\"",
            "                     \"role SMALLINT,\"",
            "                     \"password VARCHAR,\"",
            "                     \"kindle_mail VARCHAR(120),\"",
            "                     \"locale VARCHAR(2),\"",
            "                     \"sidebar_view INTEGER,\"",
            "                     \"default_language VARCHAR(3),\"                     ",
            "                     \"denied_tags VARCHAR,\"",
            "                     \"allowed_tags VARCHAR,\"",
            "                     \"denied_column_value VARCHAR,\"",
            "                     \"allowed_column_value VARCHAR,\"",
            "                     \"view_settings JSON,\"",
            "                     \"kobo_only_shelves_sync SMALLINT,\"                              ",
            "                     \"UNIQUE (name),\"",
            "                     \"UNIQUE (email))\"))",
            "            conn.execute(text(\"INSERT INTO user_id(id, name, email, role, password, kindle_mail,locale,\"",
            "                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"",
            "                     \"allowed_column_value, view_settings, kobo_only_shelves_sync)\"",
            "                     \"SELECT id, nickname, email, role, password, kindle_mail, locale,\"",
            "                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"",
            "                     \"allowed_column_value, view_settings, kobo_only_shelves_sync FROM user\"))",
            "            # delete old user table and rename new user_id table to user:",
            "            conn.execute(text(\"DROP TABLE user\"))",
            "            conn.execute(text(\"ALTER TABLE user_id RENAME TO user\"))",
            "        session.commit()",
            "    if session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS).first() \\",
            "       is None:",
            "        create_anonymous_user(session)",
            "",
            "    migrate_guest_password(engine)",
            "",
            "",
            "def clean_database(session):",
            "    # Remove expired remote login tokens",
            "    now = datetime.datetime.now()",
            "    session.query(RemoteAuthToken).filter(now > RemoteAuthToken.expiration).\\",
            "        filter(RemoteAuthToken.token_type != 1).delete()",
            "    session.commit()",
            "",
            "",
            "# Save downloaded books per user in calibre-web's own database",
            "def update_download(book_id, user_id):",
            "    check = session.query(Downloads).filter(Downloads.user_id == user_id).filter(Downloads.book_id == book_id).first()",
            "",
            "    if not check:",
            "        new_download = Downloads(user_id=user_id, book_id=book_id)",
            "        session.add(new_download)",
            "        try:",
            "            session.commit()",
            "        except exc.OperationalError:",
            "            session.rollback()",
            "",
            "",
            "# Delete non exisiting downloaded books in calibre-web's own database",
            "def delete_download(book_id):",
            "    session.query(Downloads).filter(book_id == Downloads.book_id).delete()",
            "    try:",
            "        session.commit()",
            "    except exc.OperationalError:",
            "        session.rollback()",
            "",
            "# Generate user Guest (translated text), as anonymous user, no rights",
            "def create_anonymous_user(session):",
            "    user = User()",
            "    user.name = \"Guest\"",
            "    user.email = 'no@email'",
            "    user.role = constants.ROLE_ANONYMOUS",
            "    user.password = ''",
            "",
            "    session.add(user)",
            "    try:",
            "        session.commit()",
            "    except Exception:",
            "        session.rollback()",
            "",
            "",
            "# Generate User admin with admin123 password, and access to everything",
            "def create_admin_user(session):",
            "    user = User()",
            "    user.name = \"admin\"",
            "    user.role = constants.ADMIN_USER_ROLES",
            "    user.sidebar_view = constants.ADMIN_USER_SIDEBAR",
            "",
            "    user.password = generate_password_hash(constants.DEFAULT_PASSWORD)",
            "",
            "    session.add(user)",
            "    try:",
            "        session.commit()",
            "    except Exception:",
            "        session.rollback()",
            "",
            "",
            "def init_db(app_db_path):",
            "    # Open session for database connection",
            "    global session",
            "    global app_DB_path",
            "",
            "    app_DB_path = app_db_path",
            "    engine = create_engine(u'sqlite:///{0}'.format(app_db_path), echo=False)",
            "",
            "    Session = scoped_session(sessionmaker())",
            "    Session.configure(bind=engine)",
            "    session = Session()",
            "",
            "    if os.path.exists(app_db_path):",
            "        Base.metadata.create_all(engine)",
            "        migrate_Database(session)",
            "        clean_database(session)",
            "    else:",
            "        Base.metadata.create_all(engine)",
            "        create_admin_user(session)",
            "        create_anonymous_user(session)",
            "",
            "    if cli.user_credentials:",
            "        username, password = cli.user_credentials.split(':', 1)",
            "        user = session.query(User).filter(func.lower(User.name) == username.lower()).first()",
            "        if user:",
            "            if not password:",
            "                print(\"Empty password is not allowed\")",
            "                sys.exit(4)",
            "            user.password = generate_password_hash(password)",
            "            if session_commit() == \"\":",
            "                print(\"Password for user '{}' changed\".format(username))",
            "                sys.exit(0)",
            "            else:",
            "                print(\"Failed changing password\")",
            "                sys.exit(3)",
            "        else:",
            "            print(\"Username '{}' not valid, can't change password\".format(username))",
            "            sys.exit(3)",
            "",
            "",
            "def dispose():",
            "    global session",
            "",
            "    old_session = session",
            "    session = None",
            "    if old_session:",
            "        try:",
            "            old_session.close()",
            "        except Exception:",
            "            pass",
            "        if old_session.bind:",
            "            try:",
            "                old_session.bind.dispose()",
            "            except Exception:",
            "                pass",
            "",
            "def session_commit(success=None):",
            "    try:",
            "        session.commit()",
            "        if success:",
            "            log.info(success)",
            "    except (exc.OperationalError, exc.InvalidRequestError) as e:",
            "        session.rollback()",
            "        log.debug_or_exception(e)",
            "    return \"\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2012-2019 mutschler, jkrehm, cervinko, janeczku, OzzieIsaacs, csitko",
            "#                            ok11, issmirnov, idalin",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import sys",
            "import datetime",
            "import itertools",
            "import uuid",
            "from flask import session as flask_session",
            "from binascii import hexlify",
            "",
            "from flask_login import AnonymousUserMixin, current_user",
            "from flask_login import user_logged_in",
            "",
            "try:",
            "    from flask_dance.consumer.backend.sqla import OAuthConsumerMixin",
            "    oauth_support = True",
            "except ImportError as e:",
            "    # fails on flask-dance >1.3, due to renaming",
            "    try:",
            "        from flask_dance.consumer.storage.sqla import OAuthConsumerMixin",
            "        oauth_support = True",
            "    except ImportError as e:",
            "        oauth_support = False",
            "from sqlalchemy import create_engine, exc, exists, event, text",
            "from sqlalchemy import Column, ForeignKey",
            "from sqlalchemy import String, Integer, SmallInteger, Boolean, DateTime, Float, JSON",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.sql.expression import func",
            "try:",
            "    # Compatibility with sqlalchemy 2.0",
            "    from sqlalchemy.orm import declarative_base",
            "except ImportError:",
            "    from sqlalchemy.ext.declarative import declarative_base",
            "from sqlalchemy.orm import backref, relationship, sessionmaker, Session, scoped_session",
            "from werkzeug.security import generate_password_hash",
            "",
            "from . import constants, logger, cli",
            "",
            "log = logger.create()",
            "",
            "session = None",
            "app_DB_path = None",
            "Base = declarative_base()",
            "searched_ids = {}",
            "",
            "logged_in = dict()",
            "",
            "",
            "def signal_store_user_session(object, user):",
            "    store_user_session()",
            "",
            "def store_user_session():",
            "    if flask_session.get('user_id', \"\"):",
            "        flask_session['_user_id'] = flask_session.get('user_id', \"\")",
            "    if flask_session.get('_user_id', \"\"):",
            "        try:",
            "            if not check_user_session(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\")):",
            "                user_session = User_Sessions(flask_session.get('_user_id', \"\"), flask_session.get('_id', \"\"))",
            "                session.add(user_session)",
            "                session.commit()",
            "                log.debug(\"Login and store session : \" + flask_session.get('_id', \"\"))",
            "            else:",
            "                log.debug(\"Found stored session: \" + flask_session.get('_id', \"\"))",
            "        except (exc.OperationalError, exc.InvalidRequestError) as e:",
            "            session.rollback()",
            "            log.exception(e)",
            "    else:",
            "        log.error(\"No user id in session\")",
            "",
            "def delete_user_session(user_id, session_key):",
            "    try:",
            "        log.debug(\"Deleted session_key: \" + session_key)",
            "        session.query(User_Sessions).filter(User_Sessions.user_id==user_id,",
            "                                            User_Sessions.session_key==session_key).delete()",
            "        session.commit()",
            "    except (exc.OperationalError, exc.InvalidRequestError):",
            "        session.rollback()",
            "        log.exception(e)",
            "",
            "",
            "def check_user_session(user_id, session_key):",
            "    try:",
            "        return bool(session.query(User_Sessions).filter(User_Sessions.user_id==user_id,",
            "                                                       User_Sessions.session_key==session_key).one_or_none())",
            "    except (exc.OperationalError, exc.InvalidRequestError):",
            "        session.rollback()",
            "        log.exception(e)",
            "",
            "",
            "user_logged_in.connect(signal_store_user_session)",
            "",
            "def store_ids(result):",
            "    ids = list()",
            "    for element in result:",
            "        ids.append(element.id)",
            "    searched_ids[current_user.id] = ids",
            "",
            "",
            "class UserBase:",
            "",
            "    @property",
            "    def is_authenticated(self):",
            "        return self.is_active",
            "",
            "    def _has_role(self, role_flag):",
            "        return constants.has_flag(self.role, role_flag)",
            "",
            "    def role_admin(self):",
            "        return self._has_role(constants.ROLE_ADMIN)",
            "",
            "    def role_download(self):",
            "        return self._has_role(constants.ROLE_DOWNLOAD)",
            "",
            "    def role_upload(self):",
            "        return self._has_role(constants.ROLE_UPLOAD)",
            "",
            "    def role_edit(self):",
            "        return self._has_role(constants.ROLE_EDIT)",
            "",
            "    def role_passwd(self):",
            "        return self._has_role(constants.ROLE_PASSWD)",
            "",
            "    def role_anonymous(self):",
            "        return self._has_role(constants.ROLE_ANONYMOUS)",
            "",
            "    def role_edit_shelfs(self):",
            "        return self._has_role(constants.ROLE_EDIT_SHELFS)",
            "",
            "    def role_delete_books(self):",
            "        return self._has_role(constants.ROLE_DELETE_BOOKS)",
            "",
            "    def role_viewer(self):",
            "        return self._has_role(constants.ROLE_VIEWER)",
            "",
            "    @property",
            "    def is_active(self):",
            "        return True",
            "",
            "    @property",
            "    def is_anonymous(self):",
            "        return self.role_anonymous()",
            "",
            "    def get_id(self):",
            "        return str(self.id)",
            "",
            "    def filter_language(self):",
            "        return self.default_language",
            "",
            "    def check_visibility(self, value):",
            "        if value == constants.SIDEBAR_RECENT:",
            "            return True",
            "        return constants.has_flag(self.sidebar_view, value)",
            "",
            "    def show_detail_random(self):",
            "        return self.check_visibility(constants.DETAIL_RANDOM)",
            "",
            "    def list_denied_tags(self):",
            "        mct = self.denied_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_tags(self):",
            "        mct = self.allowed_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_denied_column_values(self):",
            "        mct = self.denied_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_column_values(self):",
            "        mct = self.allowed_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def get_view_property(self, page, prop):",
            "        if not self.view_settings.get(page):",
            "            return None",
            "        return self.view_settings[page].get(prop)",
            "",
            "    def set_view_property(self, page, prop, value):",
            "        if not self.view_settings.get(page):",
            "            self.view_settings[page] = dict()",
            "        self.view_settings[page][prop] = value",
            "        try:",
            "            flag_modified(self, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        try:",
            "            session.commit()",
            "        except (exc.OperationalError, exc.InvalidRequestError):",
            "            session.rollback()",
            "            # ToDo: Error message",
            "",
            "    def __repr__(self):",
            "        return '<User %r>' % self.name",
            "",
            "",
            "# Baseclass for Users in Calibre-Web, settings which are depending on certain users are stored here. It is derived from",
            "# User Base (all access methods are declared there)",
            "class User(UserBase, Base):",
            "    __tablename__ = 'user'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    name = Column(String(64), unique=True)",
            "    email = Column(String(120), unique=True, default=\"\")",
            "    role = Column(SmallInteger, default=constants.ROLE_USER)",
            "    password = Column(String)",
            "    kindle_mail = Column(String(120), default=\"\")",
            "    shelf = relationship('Shelf', backref='user', lazy='dynamic', order_by='Shelf.name')",
            "    downloads = relationship('Downloads', backref='user', lazy='dynamic')",
            "    locale = Column(String(2), default=\"en\")",
            "    sidebar_view = Column(Integer, default=1)",
            "    default_language = Column(String(3), default=\"all\")",
            "    denied_tags = Column(String, default=\"\")",
            "    allowed_tags = Column(String, default=\"\")",
            "    denied_column_value = Column(String, default=\"\")",
            "    allowed_column_value = Column(String, default=\"\")",
            "    remote_auth_token = relationship('RemoteAuthToken', backref='user', lazy='dynamic')",
            "    view_settings = Column(JSON, default={})",
            "    kobo_only_shelves_sync = Column(Integer, default=0)",
            "",
            "",
            "if oauth_support:",
            "    class OAuth(OAuthConsumerMixin, Base):",
            "        provider_user_id = Column(String(256))",
            "        user_id = Column(Integer, ForeignKey(User.id))",
            "        user = relationship(User)",
            "",
            "",
            "class OAuthProvider(Base):",
            "    __tablename__ = 'oauthProvider'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    provider_name = Column(String)",
            "    oauth_client_id = Column(String)",
            "    oauth_client_secret = Column(String)",
            "    active = Column(Boolean)",
            "",
            "",
            "# Class for anonymous user is derived from User base and completly overrides methods and properties for the",
            "# anonymous user",
            "class Anonymous(AnonymousUserMixin, UserBase):",
            "    def __init__(self):",
            "        self.loadSettings()",
            "",
            "    def loadSettings(self):",
            "        data = session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS)\\",
            "            .first()  # type: User",
            "        self.name = data.name",
            "        self.role = data.role",
            "        self.id=data.id",
            "        self.sidebar_view = data.sidebar_view",
            "        self.default_language = data.default_language",
            "        self.locale = data.locale",
            "        self.kindle_mail = data.kindle_mail",
            "        self.denied_tags = data.denied_tags",
            "        self.allowed_tags = data.allowed_tags",
            "        self.denied_column_value = data.denied_column_value",
            "        self.allowed_column_value = data.allowed_column_value",
            "        self.view_settings = data.view_settings",
            "        self.kobo_only_shelves_sync = data.kobo_only_shelves_sync",
            "",
            "",
            "    def role_admin(self):",
            "        return False",
            "",
            "    @property",
            "    def is_active(self):",
            "        return False",
            "",
            "    @property",
            "    def is_anonymous(self):",
            "        return True",
            "",
            "    @property",
            "    def is_authenticated(self):",
            "        return False",
            "",
            "    def get_view_property(self, page, prop):",
            "        if 'view' in flask_session:",
            "            if not flask_session['view'].get(page):",
            "                return None",
            "            return flask_session['view'][page].get(prop)",
            "        return None",
            "",
            "    def set_view_property(self, page, prop, value):",
            "        if not 'view' in flask_session:",
            "            flask_session['view'] = dict()",
            "        if not flask_session['view'].get(page):",
            "            flask_session['view'][page] = dict()",
            "        flask_session['view'][page][prop] = value",
            "",
            "class User_Sessions(Base):",
            "    __tablename__ = 'user_session'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    session_key = Column(String, default=\"\")",
            "",
            "    def __init__(self, user_id, session_key):",
            "        self.user_id = user_id",
            "        self.session_key = session_key",
            "",
            "",
            "# Baseclass representing Shelfs in calibre-web in app.db",
            "class Shelf(Base):",
            "    __tablename__ = 'shelf'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    uuid = Column(String, default=lambda: str(uuid.uuid4()))",
            "    name = Column(String)",
            "    is_public = Column(Integer, default=0)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    kobo_sync = Column(Boolean, default=False)",
            "    books = relationship(\"BookShelf\", backref=\"ub_shelf\", cascade=\"all, delete-orphan\", lazy=\"dynamic\")",
            "    created = Column(DateTime, default=datetime.datetime.utcnow)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "",
            "    def __repr__(self):",
            "        return '<Shelf %d:%r>' % (self.id, self.name)",
            "",
            "",
            "# Baseclass representing Relationship between books and Shelfs in Calibre-Web in app.db (N:M)",
            "class BookShelf(Base):",
            "    __tablename__ = 'book_shelf_link'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer)",
            "    order = Column(Integer)",
            "    shelf = Column(Integer, ForeignKey('shelf.id'))",
            "    date_added = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "    def __repr__(self):",
            "        return '<Book %r>' % self.id",
            "",
            "",
            "# This table keeps track of deleted Shelves so that deletes can be propagated to any paired Kobo device.",
            "class ShelfArchive(Base):",
            "    __tablename__ = 'shelf_archive'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    uuid = Column(String)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "",
            "class ReadBook(Base):",
            "    __tablename__ = 'book_read_link'",
            "",
            "    STATUS_UNREAD = 0",
            "    STATUS_FINISHED = 1",
            "    STATUS_IN_PROGRESS = 2",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer, unique=False)",
            "    user_id = Column(Integer, ForeignKey('user.id'), unique=False)",
            "    read_status = Column(Integer, unique=False, default=STATUS_UNREAD, nullable=False)",
            "    kobo_reading_state = relationship(\"KoboReadingState\", uselist=False,",
            "                                      primaryjoin=\"and_(ReadBook.user_id == foreign(KoboReadingState.user_id), \"",
            "                                                  \"ReadBook.book_id == foreign(KoboReadingState.book_id))\",",
            "                                      cascade=\"all\",",
            "                                      backref=backref(\"book_read_link\",",
            "                                                      uselist=False))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    last_time_started_reading = Column(DateTime, nullable=True)",
            "    times_started_reading = Column(Integer, default=0, nullable=False)",
            "",
            "",
            "class Bookmark(Base):",
            "    __tablename__ = 'bookmark'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    format = Column(String(collation='NOCASE'))",
            "    bookmark_key = Column(String)",
            "",
            "",
            "# Baseclass representing books that are archived on the user's Kobo device.",
            "class ArchivedBook(Base):",
            "    __tablename__ = 'archived_book'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    is_archived = Column(Boolean, unique=False)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow)",
            "",
            "",
            "class KoboSyncedBooks(Base):",
            "    __tablename__ = 'kobo_synced_books'",
            "    id = Column(Integer, primary_key=True, autoincrement=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "",
            "# The Kobo ReadingState API keeps track of 4 timestamped entities:",
            "#   ReadingState, StatusInfo, Statistics, CurrentBookmark",
            "# Which we map to the following 4 tables:",
            "#   KoboReadingState, ReadBook, KoboStatistics and KoboBookmark",
            "class KoboReadingState(Base):",
            "    __tablename__ = 'kobo_reading_state'",
            "",
            "    id = Column(Integer, primary_key=True, autoincrement=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    book_id = Column(Integer)",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    priority_timestamp = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    current_bookmark = relationship(\"KoboBookmark\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all, delete\")",
            "    statistics = relationship(\"KoboStatistics\", uselist=False, backref=\"kobo_reading_state\", cascade=\"all, delete\")",
            "",
            "",
            "class KoboBookmark(Base):",
            "    __tablename__ = 'kobo_bookmark'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    location_source = Column(String)",
            "    location_type = Column(String)",
            "    location_value = Column(String)",
            "    progress_percent = Column(Float)",
            "    content_source_progress_percent = Column(Float)",
            "",
            "",
            "class KoboStatistics(Base):",
            "    __tablename__ = 'kobo_statistics'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    kobo_reading_state_id = Column(Integer, ForeignKey('kobo_reading_state.id'))",
            "    last_modified = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)",
            "    remaining_time_minutes = Column(Integer)",
            "    spent_reading_minutes = Column(Integer)",
            "",
            "",
            "# Updates the last_modified timestamp in the KoboReadingState table if any of its children tables are modified.",
            "@event.listens_for(Session, 'before_flush')",
            "def receive_before_flush(session, flush_context, instances):",
            "    for change in itertools.chain(session.new, session.dirty):",
            "        if isinstance(change, (ReadBook, KoboStatistics, KoboBookmark)):",
            "            if change.kobo_reading_state:",
            "                change.kobo_reading_state.last_modified = datetime.datetime.utcnow()",
            "    # Maintain the last_modified bit for the Shelf table.",
            "    for change in itertools.chain(session.new, session.deleted):",
            "        if isinstance(change, BookShelf):",
            "            change.ub_shelf.last_modified = datetime.datetime.utcnow()",
            "",
            "",
            "# Baseclass representing Downloads from calibre-web in app.db",
            "class Downloads(Base):",
            "    __tablename__ = 'downloads'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    book_id = Column(Integer)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "",
            "    def __repr__(self):",
            "        return '<Download %r' % self.book_id",
            "",
            "",
            "# Baseclass representing allowed domains for registration",
            "class Registration(Base):",
            "    __tablename__ = 'registration'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    domain = Column(String)",
            "    allow = Column(Integer)",
            "",
            "    def __repr__(self):",
            "        return u\"<Registration('{0}')>\".format(self.domain)",
            "",
            "",
            "class RemoteAuthToken(Base):",
            "    __tablename__ = 'remote_auth_token'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    auth_token = Column(String, unique=True)",
            "    user_id = Column(Integer, ForeignKey('user.id'))",
            "    verified = Column(Boolean, default=False)",
            "    expiration = Column(DateTime)",
            "    token_type = Column(Integer, default=0)",
            "",
            "    def __init__(self):",
            "        self.auth_token = (hexlify(os.urandom(4))).decode('utf-8')",
            "        self.expiration = datetime.datetime.now() + datetime.timedelta(minutes=10)  # 10 min from now",
            "",
            "    def __repr__(self):",
            "        return '<Token %r>' % self.id",
            "",
            "",
            "# Add missing tables during migration of database",
            "def add_missing_tables(engine, session):",
            "    if not engine.dialect.has_table(engine.connect(), \"book_read_link\"):",
            "        ReadBook.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"bookmark\"):",
            "        Bookmark.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_reading_state\"):",
            "        KoboReadingState.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_bookmark\"):",
            "        KoboBookmark.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"kobo_statistics\"):",
            "        KoboStatistics.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"archived_book\"):",
            "        ArchivedBook.__table__.create(bind=engine)",
            "    if not engine.dialect.has_table(engine.connect(), \"registration\"):",
            "        Registration.__table__.create(bind=engine)",
            "        with engine.connect() as conn:",
            "            conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")",
            "        session.commit()",
            "",
            "",
            "# migrate all settings missing in registration table",
            "def migrate_registration_table(engine, session):",
            "    try:",
            "        session.query(exists().where(Registration.allow)).scalar()",
            "        session.commit()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE registration ADD column 'allow' INTEGER\")",
            "            conn.execute(\"update registration set 'allow' = 1\")",
            "        session.commit()",
            "    try:",
            "        # Handle table exists, but no content",
            "        cnt = session.query(Registration).count()",
            "        if not cnt:",
            "            with engine.connect() as conn:",
            "                conn.execute(\"insert into registration (domain, allow) values('%.%',1)\")",
            "            session.commit()",
            "    except exc.OperationalError:  # Database is not writeable",
            "        print('Settings database is not writeable. Exiting...')",
            "        sys.exit(2)",
            "",
            "",
            "# Remove login capability of user Guest",
            "def migrate_guest_password(engine):",
            "    try:",
            "        with engine.connect() as conn:",
            "            trans = conn.begin()",
            "            conn.execute(text(\"UPDATE user SET password='' where name = 'Guest' and password !=''\"))",
            "            trans.commit()",
            "    except exc.OperationalError:",
            "        print('Settings database is not writeable. Exiting...')",
            "        sys.exit(2)",
            "",
            "",
            "def migrate_shelfs(engine, session):",
            "    try:",
            "        session.query(exists().where(Shelf.uuid)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'uuid' STRING\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'created' DATETIME\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'last_modified' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'date_added' DATETIME\")",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")",
            "        for shelf in session.query(Shelf).all():",
            "            shelf.uuid = str(uuid.uuid4())",
            "            shelf.created = datetime.datetime.now()",
            "            shelf.last_modified = datetime.datetime.now()",
            "        for book_shelf in session.query(BookShelf).all():",
            "            book_shelf.date_added = datetime.datetime.now()",
            "        session.commit()",
            "",
            "    try:",
            "        session.query(exists().where(Shelf.kobo_sync)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "",
            "            conn.execute(\"ALTER TABLE shelf ADD column 'kobo_sync' BOOLEAN DEFAULT false\")",
            "        session.commit()",
            "",
            "    try:",
            "        session.query(exists().where(BookShelf.order)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE book_shelf_link ADD column 'order' INTEGER DEFAULT 1\")",
            "        session.commit()",
            "",
            "",
            "def migrate_readBook(engine, session):",
            "    try:",
            "        session.query(exists().where(ReadBook.read_status)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'read_status' INTEGER DEFAULT 0\")",
            "            conn.execute(\"UPDATE book_read_link SET 'read_status' = 1 WHERE is_read\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_modified' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'last_time_started_reading' DATETIME\")",
            "            conn.execute(\"ALTER TABLE book_read_link ADD column 'times_started_reading' INTEGER DEFAULT 0\")",
            "        session.commit()",
            "    test = session.query(ReadBook).filter(ReadBook.last_modified == None).all()",
            "    for book in test:",
            "        book.last_modified = datetime.datetime.utcnow()",
            "    session.commit()",
            "",
            "",
            "def migrate_remoteAuthToken(engine, session):",
            "    try:",
            "        session.query(exists().where(RemoteAuthToken.token_type)).scalar()",
            "        session.commit()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE remote_auth_token ADD column 'token_type' INTEGER DEFAULT 0\")",
            "            conn.execute(\"update remote_auth_token set 'token_type' = 0\")",
            "        session.commit()",
            "",
            "# Migrate database to current version, has to be updated after every database change. Currently migration from",
            "# everywhere to current should work. Migration is done by checking if relevant columns are existing, and than adding",
            "# rows with SQL commands",
            "def migrate_Database(session):",
            "    engine = session.bind",
            "    add_missing_tables(engine, session)",
            "    migrate_registration_table(engine, session)",
            "    migrate_readBook(engine, session)",
            "    migrate_remoteAuthToken(engine, session)",
            "    migrate_shelfs(engine, session)",
            "    try:",
            "        create = False",
            "        session.query(exists().where(User.sidebar_view)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `sidebar_view` Integer DEFAULT 1\")",
            "        session.commit()",
            "        create = True",
            "    try:",
            "        if create:",
            "            with engine.connect() as conn:",
            "                conn.execute(\"SELECT language_books FROM user\")",
            "            session.commit()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"UPDATE user SET 'sidebar_view' = (random_books* :side_random + language_books * :side_lang \"",
            "                     \"+ series_books * :side_series + category_books * :side_category + hot_books * \"",
            "                     \":side_hot + :side_autor + :detail_random)\",",
            "                     {'side_random': constants.SIDEBAR_RANDOM, 'side_lang': constants.SIDEBAR_LANGUAGE,",
            "                      'side_series': constants.SIDEBAR_SERIES, 'side_category': constants.SIDEBAR_CATEGORY,",
            "                      'side_hot': constants.SIDEBAR_HOT, 'side_autor': constants.SIDEBAR_AUTHOR,",
            "                      'detail_random': constants.DETAIL_RANDOM})",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.denied_tags)).scalar()",
            "    except exc.OperationalError:  # Database is not compatible, some columns are missing",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `denied_tags` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `allowed_tags` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `denied_column_value` String DEFAULT ''\")",
            "            conn.execute(\"ALTER TABLE user ADD column `allowed_column_value` String DEFAULT ''\")",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.view_settings)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `view_settings` VARCHAR(10) DEFAULT '{}'\")",
            "        session.commit()",
            "    try:",
            "        session.query(exists().where(User.kobo_only_shelves_sync)).scalar()",
            "    except exc.OperationalError:",
            "        with engine.connect() as conn:",
            "            conn.execute(\"ALTER TABLE user ADD column `kobo_only_shelves_sync` SMALLINT DEFAULT 0\")",
            "        session.commit()",
            "",
            "    try:",
            "        # check if name is in User table instead of nickname",
            "        session.query(exists().where(User.name)).scalar()",
            "    except exc.OperationalError:",
            "        # Create new table user_id and copy contents of table user into it",
            "        with engine.connect() as conn:",
            "            conn.execute(text(\"CREATE TABLE user_id (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\"",
            "                     \"name VARCHAR(64),\"",
            "                     \"email VARCHAR(120),\"",
            "                     \"role SMALLINT,\"",
            "                     \"password VARCHAR,\"",
            "                     \"kindle_mail VARCHAR(120),\"",
            "                     \"locale VARCHAR(2),\"",
            "                     \"sidebar_view INTEGER,\"",
            "                     \"default_language VARCHAR(3),\"                     ",
            "                     \"denied_tags VARCHAR,\"",
            "                     \"allowed_tags VARCHAR,\"",
            "                     \"denied_column_value VARCHAR,\"",
            "                     \"allowed_column_value VARCHAR,\"",
            "                     \"view_settings JSON,\"",
            "                     \"kobo_only_shelves_sync SMALLINT,\"                              ",
            "                     \"UNIQUE (name),\"",
            "                     \"UNIQUE (email))\"))",
            "            conn.execute(text(\"INSERT INTO user_id(id, name, email, role, password, kindle_mail,locale,\"",
            "                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"",
            "                     \"allowed_column_value, view_settings, kobo_only_shelves_sync)\"",
            "                     \"SELECT id, nickname, email, role, password, kindle_mail, locale,\"",
            "                     \"sidebar_view, default_language, denied_tags, allowed_tags, denied_column_value, \"",
            "                     \"allowed_column_value, view_settings, kobo_only_shelves_sync FROM user\"))",
            "            # delete old user table and rename new user_id table to user:",
            "            conn.execute(text(\"DROP TABLE user\"))",
            "            conn.execute(text(\"ALTER TABLE user_id RENAME TO user\"))",
            "        session.commit()",
            "    if session.query(User).filter(User.role.op('&')(constants.ROLE_ANONYMOUS) == constants.ROLE_ANONYMOUS).first() \\",
            "       is None:",
            "        create_anonymous_user(session)",
            "",
            "    migrate_guest_password(engine)",
            "",
            "",
            "def clean_database(session):",
            "    # Remove expired remote login tokens",
            "    now = datetime.datetime.now()",
            "    session.query(RemoteAuthToken).filter(now > RemoteAuthToken.expiration).\\",
            "        filter(RemoteAuthToken.token_type != 1).delete()",
            "    session.commit()",
            "",
            "",
            "# Save downloaded books per user in calibre-web's own database",
            "def update_download(book_id, user_id):",
            "    check = session.query(Downloads).filter(Downloads.user_id == user_id).filter(Downloads.book_id == book_id).first()",
            "",
            "    if not check:",
            "        new_download = Downloads(user_id=user_id, book_id=book_id)",
            "        session.add(new_download)",
            "        try:",
            "            session.commit()",
            "        except exc.OperationalError:",
            "            session.rollback()",
            "",
            "",
            "# Delete non exisiting downloaded books in calibre-web's own database",
            "def delete_download(book_id):",
            "    session.query(Downloads).filter(book_id == Downloads.book_id).delete()",
            "    try:",
            "        session.commit()",
            "    except exc.OperationalError:",
            "        session.rollback()",
            "",
            "# Generate user Guest (translated text), as anonymous user, no rights",
            "def create_anonymous_user(session):",
            "    user = User()",
            "    user.name = \"Guest\"",
            "    user.email = 'no@email'",
            "    user.role = constants.ROLE_ANONYMOUS",
            "    user.password = ''",
            "",
            "    session.add(user)",
            "    try:",
            "        session.commit()",
            "    except Exception:",
            "        session.rollback()",
            "",
            "",
            "# Generate User admin with admin123 password, and access to everything",
            "def create_admin_user(session):",
            "    user = User()",
            "    user.name = \"admin\"",
            "    user.role = constants.ADMIN_USER_ROLES",
            "    user.sidebar_view = constants.ADMIN_USER_SIDEBAR",
            "",
            "    user.password = generate_password_hash(constants.DEFAULT_PASSWORD)",
            "",
            "    session.add(user)",
            "    try:",
            "        session.commit()",
            "    except Exception:",
            "        session.rollback()",
            "",
            "def ini():",
            "    global app_DB_path",
            "    engine = create_engine(u'sqlite:///{0}'.format(app_DB_path), echo=False)",
            "",
            "    Session = scoped_session(sessionmaker())",
            "    Session.configure(bind=engine)",
            "    return Session()",
            "",
            "",
            "def init_db(app_db_path):",
            "    # Open session for database connection",
            "    global session",
            "    global app_DB_path",
            "",
            "    app_DB_path = app_db_path",
            "    engine = create_engine(u'sqlite:///{0}'.format(app_db_path), echo=False)",
            "",
            "    Session = scoped_session(sessionmaker())",
            "    Session.configure(bind=engine)",
            "    session = Session()",
            "",
            "    if os.path.exists(app_db_path):",
            "        Base.metadata.create_all(engine)",
            "        migrate_Database(session)",
            "        clean_database(session)",
            "    else:",
            "        Base.metadata.create_all(engine)",
            "        create_admin_user(session)",
            "        create_anonymous_user(session)",
            "",
            "    if cli.user_credentials:",
            "        username, password = cli.user_credentials.split(':', 1)",
            "        user = session.query(User).filter(func.lower(User.name) == username.lower()).first()",
            "        if user:",
            "            if not password:",
            "                print(\"Empty password is not allowed\")",
            "                sys.exit(4)",
            "            user.password = generate_password_hash(password)",
            "            if session_commit() == \"\":",
            "                print(\"Password for user '{}' changed\".format(username))",
            "                sys.exit(0)",
            "            else:",
            "                print(\"Failed changing password\")",
            "                sys.exit(3)",
            "        else:",
            "            print(\"Username '{}' not valid, can't change password\".format(username))",
            "            sys.exit(3)",
            "",
            "",
            "def dispose():",
            "    global session",
            "",
            "    old_session = session",
            "    session = None",
            "    if old_session:",
            "        try:",
            "            old_session.close()",
            "        except Exception:",
            "            pass",
            "        if old_session.bind:",
            "            try:",
            "                old_session.bind.dispose()",
            "            except Exception:",
            "                pass",
            "",
            "def session_commit(success=None, sess=None):",
            "    s = sess if sess else session",
            "    try:",
            "        s.commit()",
            "        if success:",
            "            log.info(success)",
            "    except (exc.OperationalError, exc.InvalidRequestError) as e:",
            "        s.rollback()",
            "        log.debug_or_exception(e)",
            "    return \"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "833": [
                "session_commit"
            ],
            "835": [
                "session_commit"
            ],
            "839": [
                "session_commit"
            ]
        },
        "addLocation": [
            "trytond.res.user"
        ]
    }
}