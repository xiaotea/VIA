{
    "flask_appbuilder/security/manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1447,
                "afterPatchRowNumber": 1447,
                "PatchRowcode": "         # If it's not a builtin role check against database store roles"
            },
            "1": {
                "beforePatchRowNumber": 1448,
                "afterPatchRowNumber": 1448,
                "PatchRowcode": "         return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)"
            },
            "2": {
                "beforePatchRowNumber": 1449,
                "afterPatchRowNumber": 1449,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1450,
                "PatchRowcode": "+    def get_oid_identity_url(self, provider_name: str) -> Optional[str]:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1451,
                "PatchRowcode": "+        \"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1452,
                "PatchRowcode": "+        Returns the OIDC identity provider URL"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1453,
                "PatchRowcode": "+        \"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1454,
                "PatchRowcode": "+        for provider in self.openid_providers:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1455,
                "PatchRowcode": "+            if provider.get(\"name\") == provider_name:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1456,
                "PatchRowcode": "+                return provider.get(\"url\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1457,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 1450,
                "afterPatchRowNumber": 1458,
                "PatchRowcode": "     def get_user_roles(self, user) -> List[object]:"
            },
            "12": {
                "beforePatchRowNumber": 1451,
                "afterPatchRowNumber": 1459,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 1452,
                "afterPatchRowNumber": 1460,
                "PatchRowcode": "         Get current user roles, if user is not authenticated returns the public role"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import logging",
            "import re",
            "from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union",
            "",
            "from flask import Flask, g, session, url_for",
            "from flask_appbuilder.exceptions import OAuthProviderUnknown",
            "from flask_babel import lazy_gettext as _",
            "from flask_jwt_extended import current_user as current_user_jwt",
            "from flask_jwt_extended import JWTManager",
            "from flask_limiter import Limiter",
            "from flask_limiter.util import get_remote_address",
            "from flask_login import current_user, LoginManager",
            "import jwt",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from .api import SecurityApi",
            "from .registerviews import (",
            "    RegisterUserDBView,",
            "    RegisterUserOAuthView,",
            "    RegisterUserOIDView,",
            ")",
            "from .views import (",
            "    AuthDBView,",
            "    AuthLDAPView,",
            "    AuthOAuthView,",
            "    AuthOIDView,",
            "    AuthRemoteUserView,",
            "    PermissionModelView,",
            "    PermissionViewModelView,",
            "    RegisterUserModelView,",
            "    ResetMyPasswordView,",
            "    ResetPasswordView,",
            "    RoleModelView,",
            "    UserDBModelView,",
            "    UserInfoEditView,",
            "    UserLDAPModelView,",
            "    UserOAuthModelView,",
            "    UserOIDModelView,",
            "    UserRemoteUserModelView,",
            "    UserStatsChartView,",
            "    ViewMenuModelView,",
            ")",
            "from ..basemanager import BaseManager",
            "from ..const import (",
            "    AUTH_DB,",
            "    AUTH_LDAP,",
            "    AUTH_OAUTH,",
            "    AUTH_OID,",
            "    AUTH_REMOTE_USER,",
            "    LOGMSG_ERR_SEC_ADD_REGISTER_USER,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,",
            "    LOGMSG_WAR_SEC_LOGIN_FAILED,",
            "    LOGMSG_WAR_SEC_NO_USER,",
            "    LOGMSG_WAR_SEC_NOLDAP_OBJ,",
            "    MICROSOFT_KEY_SET_URL,",
            "    PERMISSION_PREFIX,",
            ")",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class AbstractSecurityManager(BaseManager):",
            "    \"\"\"",
            "    Abstract SecurityManager class, declares all methods used by the",
            "    framework. There is no assumptions about security models or auth types.",
            "    \"\"\"",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def register_views(self):",
            "        \"\"\"",
            "        Generic function to create the security views",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def has_access(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        raise NotImplementedError",
            "",
            "    def get_first_user(self):",
            "        raise NotImplementedError",
            "",
            "    def noop_user_update(self, user) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "def _oauth_tokengetter(token=None):",
            "    \"\"\"",
            "    Default function to return the current user oauth token",
            "    from session cookie.",
            "    \"\"\"",
            "    token = session.get(\"oauth\")",
            "    log.debug(\"Token Get: %s\", token)",
            "    return token",
            "",
            "",
            "class BaseSecurityManager(AbstractSecurityManager):",
            "    auth_view = None",
            "    \"\"\" The obj instance for authentication view \"\"\"",
            "    user_view = None",
            "    \"\"\" The obj instance for user view \"\"\"",
            "    registeruser_view = None",
            "    \"\"\" The obj instance for registering user view \"\"\"",
            "    lm = None",
            "    \"\"\" Flask-Login LoginManager \"\"\"",
            "    jwt_manager = None",
            "    \"\"\" Flask-JWT-Extended \"\"\"",
            "    oid = None",
            "    \"\"\" Flask-OpenID OpenID \"\"\"",
            "    oauth = None",
            "    \"\"\" Flask-OAuth \"\"\"",
            "    oauth_remotes = None",
            "    \"\"\" OAuth email whitelists \"\"\"",
            "    oauth_whitelists = {}",
            "    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"",
            "    oauth_tokengetter = _oauth_tokengetter",
            "    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"",
            "    oauth_user_info = None",
            "",
            "    user_model = None",
            "    \"\"\" Override to set your own User Model \"\"\"",
            "    role_model = None",
            "    \"\"\" Override to set your own Role Model \"\"\"",
            "    permission_model = None",
            "    \"\"\" Override to set your own Permission Model \"\"\"",
            "    viewmenu_model = None",
            "    \"\"\" Override to set your own ViewMenu Model \"\"\"",
            "    permissionview_model = None",
            "    \"\"\" Override to set your own PermissionView Model \"\"\"",
            "    registeruser_model = None",
            "    \"\"\" Override to set your own RegisterUser Model \"\"\"",
            "",
            "    userdbmodelview = UserDBModelView",
            "    \"\"\" Override if you want your own user db view \"\"\"",
            "    userldapmodelview = UserLDAPModelView",
            "    \"\"\" Override if you want your own user ldap view \"\"\"",
            "    useroidmodelview = UserOIDModelView",
            "    \"\"\" Override if you want your own user OID view \"\"\"",
            "    useroauthmodelview = UserOAuthModelView",
            "    \"\"\" Override if you want your own user OAuth view \"\"\"",
            "    userremoteusermodelview = UserRemoteUserModelView",
            "    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"",
            "    registerusermodelview = RegisterUserModelView",
            "",
            "    authdbview = AuthDBView",
            "    \"\"\" Override if you want your own Authentication DB view \"\"\"",
            "    authldapview = AuthLDAPView",
            "    \"\"\" Override if you want your own Authentication LDAP view \"\"\"",
            "    authoidview = AuthOIDView",
            "    \"\"\" Override if you want your own Authentication OID view \"\"\"",
            "    authoauthview = AuthOAuthView",
            "    \"\"\" Override if you want your own Authentication OAuth view \"\"\"",
            "    authremoteuserview = AuthRemoteUserView",
            "    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"",
            "",
            "    registeruserdbview = RegisterUserDBView",
            "    \"\"\" Override if you want your own register user db view \"\"\"",
            "    registeruseroidview = RegisterUserOIDView",
            "    \"\"\" Override if you want your own register user OpenID view \"\"\"",
            "    registeruseroauthview = RegisterUserOAuthView",
            "    \"\"\" Override if you want your own register user OAuth view \"\"\"",
            "",
            "    resetmypasswordview = ResetMyPasswordView",
            "    \"\"\" Override if you want your own reset my password view \"\"\"",
            "    resetpasswordview = ResetPasswordView",
            "    \"\"\" Override if you want your own reset password view \"\"\"",
            "    userinfoeditview = UserInfoEditView",
            "    \"\"\" Override if you want your own User information edit view \"\"\"",
            "",
            "    # API",
            "    security_api = SecurityApi",
            "    \"\"\" Override if you want your own Security API login endpoint \"\"\"",
            "",
            "    rolemodelview = RoleModelView",
            "    permissionmodelview = PermissionModelView",
            "    userstatschartview = UserStatsChartView",
            "    viewmenumodelview = ViewMenuModelView",
            "    permissionviewmodelview = PermissionViewModelView",
            "",
            "    def __init__(self, appbuilder):",
            "        super(BaseSecurityManager, self).__init__(appbuilder)",
            "        app = self.appbuilder.get_app",
            "        # Base Security Config",
            "        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")",
            "        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")",
            "        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)",
            "        # Self Registration",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)",
            "        # Role Mapping",
            "        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})",
            "        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)",
            "        app.config.setdefault(\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\", False)",
            "",
            "        # LDAP Config",
            "        if self.auth_type == AUTH_LDAP:",
            "            if \"AUTH_LDAP_SERVER\" not in app.config:",
            "                raise Exception(",
            "                    \"No AUTH_LDAP_SERVER defined on config\"",
            "                    \" with AUTH_LDAP authentication type.\"",
            "                )",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")",
            "            # TLS options",
            "            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")",
            "            # Mapping options",
            "            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")",
            "            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")",
            "            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")",
            "            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")",
            "            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")",
            "",
            "        # Rate limiting",
            "        app.config.setdefault(\"AUTH_RATE_LIMITED\", False)",
            "        app.config.setdefault(\"AUTH_RATE_LIMIT\", \"10 per 20 second\")",
            "",
            "        if self.auth_type == AUTH_OID:",
            "            from flask_openid import OpenID",
            "",
            "            self.oid = OpenID(app)",
            "        if self.auth_type == AUTH_OAUTH:",
            "            from authlib.integrations.flask_client import OAuth",
            "",
            "            self.oauth = OAuth(app)",
            "            self.oauth_remotes = {}",
            "            for _provider in self.oauth_providers:",
            "                provider_name = _provider[\"name\"]",
            "                log.debug(\"OAuth providers init %s\", provider_name)",
            "                obj_provider = self.oauth.register(",
            "                    provider_name, **_provider[\"remote_app\"]",
            "                )",
            "                obj_provider._tokengetter = self.oauth_tokengetter",
            "                if not self.oauth_user_info:",
            "                    self.oauth_user_info = self.get_oauth_user_info",
            "                # Whitelist only users with matching emails",
            "                if \"whitelist\" in _provider:",
            "                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]",
            "                self.oauth_remotes[provider_name] = obj_provider",
            "",
            "        self._builtin_roles = self.create_builtin_roles()",
            "        # Setup Flask-Login",
            "        self.lm = self.create_login_manager(app)",
            "",
            "        # Setup Flask-Jwt-Extended",
            "        self.jwt_manager = self.create_jwt_manager(app)",
            "",
            "        # Setup Flask-Limiter",
            "        self.limiter = self.create_limiter(app)",
            "",
            "    def create_limiter(self, app: Flask) -> Limiter:",
            "        limiter = Limiter(key_func=get_remote_address)",
            "        limiter.init_app(app)",
            "        return limiter",
            "",
            "    def create_login_manager(self, app) -> LoginManager:",
            "        \"\"\"",
            "        Override to implement your custom login manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        lm = LoginManager(app)",
            "        lm.login_view = \"login\"",
            "        lm.user_loader(self.load_user)",
            "        return lm",
            "",
            "    def create_jwt_manager(self, app) -> JWTManager:",
            "        \"\"\"",
            "        Override to implement your custom JWT manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        jwt_manager = JWTManager()",
            "        jwt_manager.init_app(app)",
            "        jwt_manager.user_lookup_loader(self.load_user_jwt)",
            "        return jwt_manager",
            "",
            "    def create_builtin_roles(self):",
            "        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})",
            "",
            "    def get_roles_from_keys(self, role_keys: List[str]) -> Set[role_model]:",
            "        \"\"\"",
            "        Construct a list of FAB role objects, from a list of keys.",
            "",
            "        NOTE:",
            "        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"",
            "        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names",
            "",
            "        :param role_keys: the list of FAB role keys",
            "        :return: a list of RoleModelView",
            "        \"\"\"",
            "        _roles = set()",
            "        _role_keys = set(role_keys)",
            "        for role_key, fab_role_names in self.auth_roles_mapping.items():",
            "            if role_key in _role_keys:",
            "                for fab_role_name in fab_role_names:",
            "                    fab_role = self.find_role(fab_role_name)",
            "                    if fab_role:",
            "                        _roles.add(fab_role)",
            "                    else:",
            "                        log.warning(",
            "                            \"Can't find role specified in AUTH_ROLES_MAPPING: %s\",",
            "                            fab_role_name,",
            "                        )",
            "        return _roles",
            "",
            "    @property",
            "    def auth_type_provider_name(self) -> Optional[str]:",
            "        provider_to_auth_type = {AUTH_DB: \"db\", AUTH_LDAP: \"ldap\"}",
            "        return provider_to_auth_type.get(self.auth_type)",
            "",
            "    @property",
            "    def get_url_for_registeruser(self):",
            "        return url_for(",
            "            \"%s.%s\"",
            "            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_user_datamodel(self):",
            "        return self.user_view.datamodel",
            "",
            "    @property",
            "    def get_register_user_datamodel(self):",
            "        return self.registerusermodelview.datamodel",
            "",
            "    @property",
            "    def builtin_roles(self) -> Dict[str, Any]:",
            "        return self._builtin_roles",
            "",
            "    @property",
            "    def api_login_allow_multiple_providers(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\"]",
            "",
            "    @property",
            "    def auth_type(self) -> int:",
            "        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]",
            "",
            "    @property",
            "    def auth_username_ci(self) -> str:",
            "        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)",
            "",
            "    @property",
            "    def auth_role_admin(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]",
            "",
            "    @property",
            "    def auth_role_public(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]",
            "",
            "    @property",
            "    def auth_ldap_server(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]",
            "",
            "    @property",
            "    def auth_ldap_use_tls(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]",
            "",
            "    @property",
            "    def auth_user_registration(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]",
            "",
            "    @property",
            "    def auth_user_registration_role(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]",
            "",
            "    @property",
            "    def auth_user_registration_role_jmespath(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]",
            "",
            "    @property",
            "    def auth_roles_mapping(self) -> Dict[str, List[str]]:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]",
            "",
            "    @property",
            "    def auth_roles_sync_at_login(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]",
            "",
            "    @property",
            "    def auth_ldap_search(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]",
            "",
            "    @property",
            "    def auth_ldap_search_filter(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_user(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_password(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]",
            "",
            "    @property",
            "    def auth_ldap_append_domain(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]",
            "",
            "    @property",
            "    def auth_ldap_username_format(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]",
            "",
            "    @property",
            "    def auth_ldap_uid_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_group_field(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_firstname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_lastname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_email_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_first(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]",
            "",
            "    @property",
            "    def auth_ldap_allow_self_signed(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_demand(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertdir(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_certfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_keyfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]",
            "",
            "    @property",
            "    def openid_providers(self):",
            "        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]",
            "",
            "    @property",
            "    def oauth_providers(self):",
            "        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]",
            "",
            "    @property",
            "    def is_auth_limited(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMITED\"]",
            "",
            "    @property",
            "    def auth_rate_limit(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMIT\"]",
            "",
            "    @property",
            "    def current_user(self):",
            "        if current_user.is_authenticated:",
            "            return g.user",
            "        elif current_user_jwt:",
            "            return current_user_jwt",
            "",
            "    def oauth_user_info_getter(",
            "        self,",
            "        func: Callable[[\"BaseSecurityManager\", str, Dict[str, Any]], Dict[str, Any]],",
            "    ):",
            "        \"\"\"",
            "        Decorator function to be the OAuth user info getter",
            "        for all the providers, receives provider and response",
            "        return a dict with the information returned from the provider.",
            "        The returned user info dict should have it's keys with the same",
            "        name as the User Model.",
            "",
            "        Use it like this an example for GitHub ::",
            "",
            "            @appbuilder.sm.oauth_user_info_getter",
            "            def my_oauth_user_info(sm, provider, response=None):",
            "                if provider == 'github':",
            "                    me = sm.oauth_remotes[provider].get('user')",
            "                    return {'username': me.data.get('login')}",
            "                return {}",
            "        \"\"\"",
            "",
            "        def wraps(provider: str, response: Dict[str, Any] = None) -> Dict[str, Any]:",
            "            return func(self, provider, response)",
            "",
            "        self.oauth_user_info = wraps",
            "        return wraps",
            "",
            "    def get_oauth_token_key_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_key name for the oauth provider",
            "        if none is configured defaults to oauth_token",
            "        this is configured using OAUTH_PROVIDERS and token_key key.",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_key\", \"oauth_token\")",
            "",
            "    def get_oauth_token_secret_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_secret name for the oauth provider",
            "        if none is configured defaults to oauth_secret",
            "        this is configured using OAUTH_PROVIDERS and token_secret",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_secret\", \"oauth_token_secret\")",
            "",
            "    def set_oauth_session(self, provider, oauth_response):",
            "        \"\"\"",
            "        Set the current session with OAuth user secrets",
            "        \"\"\"",
            "        # Get this provider key names for token_key and token_secret",
            "        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)",
            "        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)",
            "        # Save users token on encrypted session cookie",
            "        session[\"oauth\"] = (",
            "            oauth_response[token_key],",
            "            oauth_response.get(token_secret, \"\"),",
            "        )",
            "        session[\"oauth_provider\"] = provider",
            "",
            "    def get_oauth_user_info(",
            "        self, provider: str, resp: Dict[str, Any]",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Since there are different OAuth APIs with different ways to",
            "        retrieve user info",
            "        \"\"\"",
            "        # for GITHUB",
            "        if provider == \"github\" or provider == \"githublocal\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")",
            "            data = me.json()",
            "            log.debug(\"User info from Github: %s\", data)",
            "            return {\"username\": \"github_\" + data.get(\"login\")}",
            "        # for twitter",
            "        if provider == \"twitter\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")",
            "            data = me.json()",
            "            log.debug(\"User info from Twitter: %s\", data)",
            "            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}",
            "        # for linkedin",
            "        if provider == \"linkedin\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"people/~:(id,email-address,first-name,last-name)?format=json\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from Linkedin: %s\", data)",
            "            return {",
            "                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),",
            "                \"email\": data.get(\"email-address\", \"\"),",
            "                \"first_name\": data.get(\"firstName\", \"\"),",
            "                \"last_name\": data.get(\"lastName\", \"\"),",
            "            }",
            "        # for Google",
            "        if provider == \"google\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Google: %s\", data)",
            "            return {",
            "                \"username\": \"google_\" + data.get(\"id\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        if provider == \"azure\":",
            "            me = self._decode_and_validate_azure_jwt(resp[\"id_token\"])",
            "            log.debug(\"User info from Azure: %s\", me)",
            "            # https://learn.microsoft.com/en-us/azure/active-directory/develop/id-token-claims-reference#payload-claims",
            "            return {",
            "                # To keep backward compatibility with previous versions",
            "                # of FAB, we use upn if available, otherwise we use email",
            "                \"email\": me[\"upn\"] if \"upn\" in me else me[\"email\"],",
            "                \"first_name\": me.get(\"given_name\", \"\"),",
            "                \"last_name\": me.get(\"family_name\", \"\"),",
            "                \"username\": me[\"oid\"],",
            "                \"role_keys\": me.get(\"roles\", []),",
            "            }",
            "        # for OpenShift",
            "        if provider == \"openshift\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"apis/user.openshift.io/v1/users/~\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from OpenShift: %s\", data)",
            "            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}",
            "        # for Okta",
            "        if provider == \"okta\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Okta: %s\", data)",
            "            return {",
            "                \"username\": f\"{provider}_{data['sub']}\",",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data[\"email\"],",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Auth0",
            "        if provider == \"auth0\":",
            "            data = self.appbuilder.sm.oauth_remotes[provider].userinfo()",
            "            log.debug(\"User info from Auth0: %s\", data)",
            "            return {",
            "                \"username\": f\"{provider}_{data['sub']}\",",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data[\"email\"],",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Keycloak",
            "        if provider in [\"keycloak\", \"keycloak_before_17\"]:",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"openid-connect/userinfo\"",
            "            )",
            "            me.raise_for_status()",
            "            data = me.json()",
            "            log.debug(\"User info from Keycloak: %s\", data)",
            "            return {",
            "                \"username\": data.get(\"preferred_username\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        raise OAuthProviderUnknown()",
            "",
            "    def _get_microsoft_jwks(self) -> List[Dict[str, Any]]:",
            "        import requests",
            "",
            "        return requests.get(MICROSOFT_KEY_SET_URL).json()",
            "",
            "    def _decode_and_validate_azure_jwt(self, id_token: str) -> Dict[str, str]:",
            "        verify_signature = self.oauth_remotes[\"azure\"].client_kwargs.get(",
            "            \"verify_signature\", False",
            "        )",
            "        if verify_signature:",
            "            from authlib.jose import JsonWebKey, jwt as authlib_jwt",
            "",
            "            keyset = JsonWebKey.import_key_set(self._get_microsoft_jwks())",
            "            claims = authlib_jwt.decode(id_token, keyset)",
            "            claims.validate()",
            "            return claims",
            "",
            "        return jwt.decode(id_token, options={\"verify_signature\": False})",
            "",
            "    def register_views(self):",
            "        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):",
            "            return",
            "        # Security APIs",
            "        self.appbuilder.add_api(self.security_api)",
            "",
            "        if self.auth_user_registration:",
            "            if self.auth_type == AUTH_DB:",
            "                self.registeruser_view = self.registeruserdbview()",
            "            elif self.auth_type == AUTH_OID:",
            "                self.registeruser_view = self.registeruseroidview()",
            "            elif self.auth_type == AUTH_OAUTH:",
            "                self.registeruser_view = self.registeruseroauthview()",
            "            if self.registeruser_view:",
            "                self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.resetpasswordview())",
            "        self.appbuilder.add_view_no_menu(self.resetmypasswordview())",
            "        self.appbuilder.add_view_no_menu(self.userinfoeditview())",
            "",
            "        if self.auth_type == AUTH_DB:",
            "            self.user_view = self.userdbmodelview",
            "            self.auth_view = self.authdbview()",
            "",
            "        elif self.auth_type == AUTH_LDAP:",
            "            self.user_view = self.userldapmodelview",
            "            self.auth_view = self.authldapview()",
            "        elif self.auth_type == AUTH_OAUTH:",
            "            self.user_view = self.useroauthmodelview",
            "            self.auth_view = self.authoauthview()",
            "        elif self.auth_type == AUTH_REMOTE_USER:",
            "            self.user_view = self.userremoteusermodelview",
            "            self.auth_view = self.authremoteuserview()",
            "        else:",
            "            self.user_view = self.useroidmodelview",
            "            self.auth_view = self.authoidview()",
            "            if self.auth_user_registration:",
            "                pass",
            "                # self.registeruser_view = self.registeruseroidview()",
            "                # self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.auth_view)",
            "",
            "        # this needs to be done after the view is added, otherwise the blueprint",
            "        # is not initialized",
            "        if self.is_auth_limited:",
            "            self.limiter.limit(self.auth_rate_limit, methods=[\"POST\"])(",
            "                self.auth_view.blueprint",
            "            )",
            "",
            "        self.user_view = self.appbuilder.add_view(",
            "            self.user_view,",
            "            \"List Users\",",
            "            icon=\"fa-user\",",
            "            label=_(\"List Users\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "            category_label=_(\"Security\"),",
            "        )",
            "",
            "        role_view = self.appbuilder.add_view(",
            "            self.rolemodelview,",
            "            \"List Roles\",",
            "            icon=\"fa-group\",",
            "            label=_(\"List Roles\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "        )",
            "        role_view.related_views = [self.user_view.__class__]",
            "",
            "        if self.userstatschartview:",
            "            self.appbuilder.add_view(",
            "                self.userstatschartview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-bar-chart-o\",",
            "                label=_(\"User's Statistics\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.auth_user_registration:",
            "            self.appbuilder.add_view(",
            "                self.registerusermodelview,",
            "                \"User Registrations\",",
            "                icon=\"fa-user-plus\",",
            "                label=_(\"User Registrations\"),",
            "                category=\"Security\",",
            "            )",
            "        self.appbuilder.menu.add_separator(\"Security\")",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.permissionmodelview,",
            "                \"Base Permissions\",",
            "                icon=\"fa-lock\",",
            "                label=_(\"Base Permissions\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.viewmenumodelview,",
            "                \"Views/Menus\",",
            "                icon=\"fa-list-alt\",",
            "                label=_(\"Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(",
            "            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True",
            "        ):",
            "            self.appbuilder.add_view(",
            "                self.permissionviewmodelview,",
            "                \"Permission on Views/Menus\",",
            "                icon=\"fa-link\",",
            "                label=_(\"Permission on Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "",
            "    def create_db(self):",
            "        \"\"\"",
            "        Setups the DB, creates admin and public roles if they don't exist.",
            "        \"\"\"",
            "        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})",
            "        for pk, name in roles_mapping.items():",
            "            self.update_role(pk, name)",
            "        for role_name, permission_view_menus in self.builtin_roles.items():",
            "            permission_view_menus = [",
            "                self.add_permission_view_menu(permission_name, view_menu_name)",
            "                for view_menu_name, permission_name in permission_view_menus",
            "            ]",
            "            self.add_role(name=role_name, permissions=permission_view_menus)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            self.add_role(self.auth_role_admin)",
            "        self.add_role(self.auth_role_public)",
            "        if self.count_users() == 0:",
            "            log.warning(LOGMSG_WAR_SEC_NO_USER)",
            "",
            "    def reset_password(self, userid, password):",
            "        \"\"\"",
            "        Change/Reset a user's password for authdb.",
            "        Password will be hashed and saved.",
            "",
            "        :param userid:",
            "            the user.id to reset the password",
            "        :param password:",
            "            The clear text password to reset and save hashed on the db",
            "        \"\"\"",
            "        user = self.get_user_by_id(userid)",
            "        user.password = generate_password_hash(password)",
            "        self.update_user(user)",
            "",
            "    def update_user_auth_stat(self, user, success=True):",
            "        \"\"\"",
            "        Update user authentication stats upon successful/unsuccessful",
            "        authentication attempts.",
            "",
            "        :param user:",
            "            The identified (but possibly not successfully authenticated) user",
            "            model",
            "        :param success:",
            "        :type success: bool or None",
            "            Defaults to true, if true increments login_count, updates",
            "            last_login, and resets fail_login_count to 0, if false increments",
            "            fail_login_count on user model.",
            "        \"\"\"",
            "        if not user.login_count:",
            "            user.login_count = 0",
            "        if not user.fail_login_count:",
            "            user.fail_login_count = 0",
            "        if success:",
            "            user.login_count += 1",
            "            user.last_login = datetime.datetime.now()",
            "            user.fail_login_count = 0",
            "        else:",
            "            user.fail_login_count += 1",
            "        self.update_user(user)",
            "",
            "    def auth_user_db(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user, auth db style",
            "",
            "        :param username:",
            "            The username or registered email address",
            "        :param password:",
            "            The password, will be tested against hashed password on db",
            "        \"\"\"",
            "        if username is None or username == \"\":",
            "            return None",
            "        first_user = self.get_first_user()",
            "        user = self.find_user(username=username)",
            "        if user is None:",
            "            user = self.find_user(email=username)",
            "        else:",
            "            # Balance failure and success",
            "            _ = self.find_user(email=username)",
            "        if user is None or (not user.is_active):",
            "            # Balance failure and success",
            "            check_password_hash(",
            "                \"pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118\"",
            "                \"c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c\",",
            "                \"password\",",
            "            )",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            # Balance failure and success",
            "            if first_user:",
            "                self.noop_user_update(first_user)",
            "            return None",
            "        elif check_password_hash(user.password, password):",
            "            self.update_user_auth_stat(user, True)",
            "            return user",
            "        else:",
            "            self.update_user_auth_stat(user, False)",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            return None",
            "",
            "    def _search_ldap(self, ldap, con, username):",
            "        \"\"\"",
            "        Searches LDAP for user.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        :param username: username to match with AUTH_LDAP_UID_FIELD",
            "        :return: ldap object array",
            "        \"\"\"",
            "        # always check AUTH_LDAP_SEARCH is set before calling this method",
            "        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"",
            "",
            "        # build the filter string for the LDAP search",
            "        if self.auth_ldap_search_filter:",
            "            filter_str = \"(&{0}({1}={2}))\".format(",
            "                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username",
            "            )",
            "        else:",
            "            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)",
            "",
            "        # build what fields to request in the LDAP search",
            "        request_fields = [",
            "            self.auth_ldap_firstname_field,",
            "            self.auth_ldap_lastname_field,",
            "            self.auth_ldap_email_field,",
            "        ]",
            "        if len(self.auth_roles_mapping) > 0:",
            "            request_fields.append(self.auth_ldap_group_field)",
            "",
            "        # perform the LDAP search",
            "        log.debug(",
            "            \"LDAP search for '%s' with fields %s in scope '%s'\",",
            "            filter_str,",
            "            request_fields,",
            "            self.auth_ldap_search,",
            "        )",
            "        raw_search_result = con.search_s(",
            "            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields",
            "        )",
            "        log.debug(\"LDAP search returned: %s\", raw_search_result)",
            "",
            "        # Remove any search referrals from results",
            "        search_result = [",
            "            (dn, attrs)",
            "            for dn, attrs in raw_search_result",
            "            if dn is not None and isinstance(attrs, dict)",
            "        ]",
            "",
            "        # only continue if 0 or 1 results were returned",
            "        if len(search_result) > 1:",
            "            log.error(",
            "                \"LDAP search for '%s' in scope '%s' returned multiple results\",",
            "                filter_str,",
            "                self.auth_ldap_search,",
            "            )",
            "            return None, None",
            "",
            "        try:",
            "            # extract the DN",
            "            user_dn = search_result[0][0]",
            "            # extract the other attributes",
            "            user_info = search_result[0][1]",
            "            # return",
            "            return user_dn, user_info",
            "        except (IndexError, NameError):",
            "            return None, None",
            "",
            "    def _ldap_calculate_user_roles(",
            "        self, user_attributes: Dict[str, bytes]",
            "    ) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = self.ldap_extract_list(",
            "                user_attributes, self.auth_ldap_group_field",
            "            )",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: %s\", registration_role_name",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def _ldap_bind_indirect(self, ldap, con) -> None:",
            "        \"\"\"",
            "        Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        \"\"\"",
            "        # always check AUTH_LDAP_BIND_USER is set before calling this method",
            "        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"",
            "",
            "        try:",
            "            log.debug(",
            "                \"LDAP bind indirect TRY with username: '%s'\", self.auth_ldap_bind_user",
            "            )",
            "            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)",
            "            log.debug(",
            "                \"LDAP bind indirect SUCCESS with username: '%s'\",",
            "                self.auth_ldap_bind_user,",
            "            )",
            "        except ldap.INVALID_CREDENTIALS as ex:",
            "            log.error(",
            "                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"",
            "                \" not valid LDAP bind credentials\"",
            "            )",
            "            raise ex",
            "",
            "    @staticmethod",
            "    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:",
            "        \"\"\"",
            "        Validates/binds the provided dn/password with the LDAP sever.",
            "        \"\"\"",
            "        try:",
            "            log.debug(\"LDAP bind TRY with username: '%s'\", dn)",
            "            con.simple_bind_s(dn, password)",
            "            log.debug(\"LDAP bind SUCCESS with username: '%s'\", dn)",
            "            return True",
            "        except ldap.INVALID_CREDENTIALS:",
            "            return False",
            "",
            "    @staticmethod",
            "    def ldap_extract(",
            "        ldap_dict: Dict[str, bytes], field_name: str, fallback: str",
            "    ) -> str:",
            "        raw_value = ldap_dict.get(field_name, [bytes()])",
            "        # decode - if empty string, default to fallback, otherwise take first element",
            "        return raw_value[0].decode(\"utf-8\") or fallback",
            "",
            "    @staticmethod",
            "    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:",
            "        raw_list = ldap_dict.get(field_name, [])",
            "        # decode - removing empty strings",
            "        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]",
            "",
            "    def auth_user_ldap(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user with LDAP.",
            "",
            "        NOTE: this depends on python-ldap module",
            "",
            "        :param username: the username",
            "        :param password: the password",
            "        \"\"\"",
            "        # If no username is provided, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Ensure python-ldap is installed",
            "        try:",
            "            import ldap",
            "        except ImportError:",
            "            log.error(\"python-ldap library is not installed\")",
            "            return None",
            "",
            "        try:",
            "            # LDAP certificate settings",
            "            if self.auth_ldap_tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)",
            "            if self.auth_ldap_tls_cacertfile:",
            "                ldap.set_option(",
            "                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile",
            "                )",
            "            if self.auth_ldap_tls_certfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)",
            "            if self.auth_ldap_tls_keyfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)",
            "            if self.auth_ldap_allow_self_signed:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "            elif self.auth_ldap_tls_demand:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "",
            "            # Initialise LDAP connection",
            "            con = ldap.initialize(self.auth_ldap_server)",
            "            con.set_option(ldap.OPT_REFERRALS, 0)",
            "            if self.auth_ldap_use_tls:",
            "                try:",
            "                    con.start_tls_s()",
            "                except Exception:",
            "                    log.error(LOGMSG_ERR_SEC_AUTH_LDAP_TLS, self.auth_ldap_server)",
            "                    return None",
            "",
            "            # Define variables, so we can check if they are set in later steps",
            "            user_dn = None",
            "            user_attributes = {}",
            "",
            "            # Flow 1 - (Indirect Search Bind):",
            "            #  - in this flow, special bind credentials are used to perform the",
            "            #    LDAP search",
            "            #  - in this flow, AUTH_LDAP_SEARCH must be set",
            "            if self.auth_ldap_bind_user:",
            "                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD",
            "                # (authorizes for LDAP search)",
            "                self._ldap_bind_indirect(ldap, con)",
            "",
            "                # Search for `username`",
            "                #  - returns the `user_dn` needed for binding to validate credentials",
            "                #  - returns the `user_attributes` needed for",
            "                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "                else:",
            "                    log.error(",
            "                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"",
            "                    )",
            "                    return None",
            "",
            "                # If search failed, go away",
            "                if user_dn is None:",
            "                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ, username)",
            "                    return None",
            "",
            "                # Bind with user_dn/password (validates credentials)",
            "                if not self._ldap_bind(ldap, con, user_dn, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "                    return None",
            "",
            "            # Flow 2 - (Direct Search Bind):",
            "            #  - in this flow, the credentials provided by the end-user are used",
            "            #    to perform the LDAP search",
            "            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set",
            "            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN",
            "            #       will only work if AUTH_LDAP_SEARCH is set",
            "            else:",
            "                # Copy the provided username (so we can apply formatters)",
            "                bind_username = username",
            "",
            "                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN",
            "                #  - for Microsoft AD, which allows binding with userPrincipalName",
            "                if self.auth_ldap_append_domain:",
            "                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain",
            "",
            "                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT",
            "                #  - for transforming the username into a DN,",
            "                #    for example: \"uid=%s,ou=example,o=test\"",
            "                if self.auth_ldap_username_format:",
            "                    bind_username = self.auth_ldap_username_format % bind_username",
            "",
            "                # Bind with bind_username/password",
            "                # (validates credentials & authorizes for LDAP search)",
            "                if not self._ldap_bind(ldap, con, bind_username, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, bind_username)",
            "                    return None",
            "",
            "                # Search for `username` (if AUTH_LDAP_SEARCH is set)",
            "                #  - returns the `user_attributes`",
            "                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                #  - we search on `username` not `bind_username`,",
            "                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT",
            "                #    would result in an invalid search filter",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "",
            "                    # If search failed, go away",
            "                    if user_dn is None:",
            "                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ, username)",
            "                        return None",
            "",
            "            # Sync the user's roles",
            "            if user and user_attributes and self.auth_roles_sync_at_login:",
            "                user.roles = self._ldap_calculate_user_roles(user_attributes)",
            "                log.debug(",
            "                    \"Calculated new roles for user='%s' as: %s\", user_dn, user.roles",
            "                )",
            "",
            "            # If the user is new, register them",
            "            if (not user) and user_attributes and self.auth_user_registration:",
            "                user = self.add_user(",
            "                    username=username,",
            "                    first_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_firstname_field, \"\"",
            "                    ),",
            "                    last_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_lastname_field, \"\"",
            "                    ),",
            "                    email=self.ldap_extract(",
            "                        user_attributes,",
            "                        self.auth_ldap_email_field,",
            "                        f\"{username}@email.notfound\",",
            "                    ),",
            "                    role=self._ldap_calculate_user_roles(user_attributes),",
            "                )",
            "                log.debug(\"New user registered: %s\", user)",
            "",
            "                # If user registration failed, go away",
            "                if not user:",
            "                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER, username)",
            "                    return None",
            "",
            "            # LOGIN SUCCESS (only if user is now registered)",
            "            if user:",
            "                self.update_user_auth_stat(user)",
            "                return user",
            "            else:",
            "                return None",
            "",
            "        except ldap.LDAPError as e:",
            "            msg = None",
            "            if isinstance(e, dict):",
            "                msg = getattr(e, \"message\", None)",
            "            if (msg is not None) and (\"desc\" in msg):",
            "                log.error(LOGMSG_ERR_SEC_AUTH_LDAP, e.message[\"desc\"])",
            "                return None",
            "            else:",
            "                log.error(e)",
            "                return None",
            "",
            "    def auth_user_oid(self, email):",
            "        \"\"\"",
            "        OpenID user Authentication",
            "",
            "        :param email: user's email to authenticate",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(email=email)",
            "        if user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, email)",
            "            return None",
            "        else:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "",
            "    def auth_user_remote_user(self, username):",
            "        \"\"\"",
            "        REMOTE_USER user Authentication",
            "",
            "        :param username: user's username for remote auth",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(username=username)",
            "",
            "        # User does not exist, create one if auto user registration.",
            "        if user is None and self.auth_user_registration:",
            "            user = self.add_user(",
            "                # All we have is REMOTE_USER, so we set",
            "                # the other fields to blank.",
            "                username=username,",
            "                first_name=username,",
            "                last_name=\"-\",",
            "                email=username + \"@email.notfound\",",
            "                role=self.find_role(self.auth_user_registration_role),",
            "            )",
            "",
            "        # If user does not exist on the DB and not auto user registration,",
            "        # or user is inactive, go away.",
            "        elif user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            return None",
            "",
            "        self.update_user_auth_stat(user)",
            "        return user",
            "",
            "    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = userinfo.get(\"role_keys\", [])",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION_ROLE",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,",
            "            # use it for the registration role",
            "            if self.auth_user_registration_role_jmespath:",
            "                import jmespath",
            "",
            "                registration_role_name = jmespath.search(",
            "                    self.auth_user_registration_role_jmespath, userinfo",
            "                )",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: %s\", registration_role_name",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def auth_user_oauth(self, userinfo):",
            "        \"\"\"",
            "        Method for authenticating user with OAuth.",
            "",
            "        :userinfo: dict with user information",
            "                   (keys are the same as User model columns)",
            "        \"\"\"",
            "        # extract the username from `userinfo`",
            "        if \"username\" in userinfo:",
            "            username = userinfo[\"username\"]",
            "        elif \"email\" in userinfo:",
            "            username = userinfo[\"email\"]",
            "        else:",
            "            log.error(\"OAUTH userinfo does not have username or email %s\", userinfo)",
            "            return None",
            "",
            "        # If username is empty, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Sync the user's roles",
            "        if user and self.auth_roles_sync_at_login:",
            "            user.roles = self._oauth_calculate_user_roles(userinfo)",
            "            log.debug(\"Calculated new roles for user='%s' as: %s\", username, user.roles)",
            "",
            "        # If the user is new, register them",
            "        if (not user) and self.auth_user_registration:",
            "            user = self.add_user(",
            "                username=username,",
            "                first_name=userinfo.get(\"first_name\", \"\"),",
            "                last_name=userinfo.get(\"last_name\", \"\"),",
            "                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",",
            "                role=self._oauth_calculate_user_roles(userinfo),",
            "            )",
            "            log.debug(\"New user registered: %s\", user)",
            "",
            "            # If user registration failed, go away",
            "            if not user:",
            "                log.error(\"Error creating a new OAuth user %s\", username)",
            "                return None",
            "",
            "        # LOGIN SUCCESS (only if user is now registered)",
            "        if user:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "        else:",
            "            return None",
            "",
            "    \"\"\"",
            "        ----------------------------------------",
            "            PERMISSION ACCESS CHECK",
            "        ----------------------------------------",
            "    \"\"\"",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        permissions = self.get_public_permissions()",
            "        if permissions:",
            "            for i in permissions:",
            "                if (view_name == i.view_menu.name) and (",
            "                    permission_name == i.permission.name",
            "                ):",
            "                    return True",
            "            return False",
            "        else:",
            "            return False",
            "",
            "    def _has_access_builtin_roles(",
            "        self, role, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        \"\"\"",
            "        Checks permission on builtin role",
            "        \"\"\"",
            "        builtin_pvms = self.builtin_roles.get(role.name, [])",
            "        for pvm in builtin_pvms:",
            "            _view_name = pvm[0]",
            "            _permission_name = pvm[1]",
            "            if re.match(_view_name, view_name) and re.match(",
            "                _permission_name, permission_name",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def _has_view_access(",
            "        self, user: object, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        roles = user.roles",
            "        db_role_ids = list()",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                if self._has_access_builtin_roles(role, permission_name, view_name):",
            "                    return True",
            "            else:",
            "                db_role_ids.append(role.id)",
            "",
            "        # If it's not a builtin role check against database store roles",
            "        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)",
            "",
            "    def get_user_roles(self, user) -> List[object]:",
            "        \"\"\"",
            "        Get current user roles, if user is not authenticated returns the public role",
            "        \"\"\"",
            "        if not user.is_authenticated:",
            "            return [self.get_public_role()]",
            "        return user.roles",
            "",
            "    def get_user_roles_permissions(self, user) -> Dict[str, List[Tuple[str, str]]]:",
            "        \"\"\"",
            "        Utility method just implemented for SQLAlchemy.",
            "        Take a look to: flask_appbuilder.security.sqla.manager",
            "        :param user:",
            "        :return:",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions for a certain role",
            "        \"\"\"",
            "        result = set()",
            "        if role.name in self.builtin_roles:",
            "            for permission in self.builtin_roles[role.name]:",
            "                result.add((permission[1], permission[0]))",
            "        else:",
            "            for permission in self.get_db_role_permissions(role.id):",
            "                result.add((permission.permission.name, permission.view_menu.name))",
            "        return result",
            "",
            "    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions from the current user",
            "        \"\"\"",
            "        roles = self.get_user_roles(user)",
            "        result = set()",
            "        for role in roles:",
            "            result.update(self.get_role_permissions(role))",
            "        return result",
            "",
            "    def _get_user_permission_view_menus(",
            "        self, user: object, permission_name: str, view_menus_name: List[str]",
            "    ) -> Set[str]:",
            "        \"\"\"",
            "        Return a set of view menu names with a certain permission name",
            "        that a user has access to. Mainly used to fetch all menu permissions",
            "        on a single db call, will also check public permissions and builtin roles",
            "        \"\"\"",
            "        db_role_ids = list()",
            "        if user is None:",
            "            # include public role",
            "            roles = [self.get_public_role()]",
            "        else:",
            "            roles = user.roles",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        result = set()",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                for view_menu_name in view_menus_name:",
            "                    if self._has_access_builtin_roles(",
            "                        role, permission_name, view_menu_name",
            "                    ):",
            "                        result.add(view_menu_name)",
            "            else:",
            "                db_role_ids.append(role.id)",
            "        # Then check against database-stored roles",
            "        pvms_names = [",
            "            pvm.view_menu.name",
            "            for pvm in self.find_roles_permission_view_menus(",
            "                permission_name, db_role_ids",
            "            )",
            "        ]",
            "        result.update(pvms_names)",
            "        return result",
            "",
            "    def has_access(self, permission_name: str, view_name: str) -> bool:",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        if current_user.is_authenticated:",
            "            return self._has_view_access(g.user, permission_name, view_name)",
            "        elif current_user_jwt:",
            "            return self._has_view_access(current_user_jwt, permission_name, view_name)",
            "        else:",
            "            return self.is_item_public(permission_name, view_name)",
            "",
            "    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:",
            "        if current_user.is_authenticated:",
            "            return self._get_user_permission_view_menus(",
            "                g.user, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        elif current_user_jwt:",
            "            return self._get_user_permission_view_menus(",
            "                current_user_jwt, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        else:",
            "            return self._get_user_permission_view_menus(",
            "                None, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "",
            "    def add_limit_view(self, baseview):",
            "        if not baseview.limits:",
            "            return",
            "",
            "        for limit in baseview.limits:",
            "            self.limiter.limit(",
            "                limit_value=limit.limit_value,",
            "                key_func=limit.key_func,",
            "                per_method=limit.per_method,",
            "                methods=limit.methods,",
            "                error_message=limit.error_message,",
            "                exempt_when=limit.exempt_when,",
            "                override_defaults=limit.override_defaults,",
            "                deduct_when=limit.deduct_when,",
            "                on_breach=limit.on_breach,",
            "                cost=limit.cost,",
            "            )(baseview.blueprint)",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        view_menu_db = self.add_view_menu(view_menu)",
            "        perm_views = self.find_permissions_view_menu(view_menu_db)",
            "",
            "        if not perm_views:",
            "            # No permissions yet on this view",
            "            for permission in base_permissions:",
            "                pv = self.add_permission_view_menu(permission, view_menu)",
            "                if self.auth_role_admin not in self.builtin_roles:",
            "                    role_admin = self.find_role(self.auth_role_admin)",
            "                    self.add_permission_role(role_admin, pv)",
            "        else:",
            "            # Permissions on this view exist but....",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            for permission in base_permissions:",
            "                # Check if base view permissions exist",
            "                if not self.exist_permission_on_views(perm_views, permission):",
            "                    pv = self.add_permission_view_menu(permission, view_menu)",
            "                    if self.auth_role_admin not in self.builtin_roles:",
            "                        self.add_permission_role(role_admin, pv)",
            "            for perm_view in perm_views:",
            "                if perm_view.permission is None:",
            "                    # Skip this perm_view, it has a null permission",
            "                    continue",
            "                if perm_view.permission.name not in base_permissions:",
            "                    # perm to delete",
            "                    roles = self.get_all_roles()",
            "                    perm = self.find_permission(perm_view.permission.name)",
            "                    # del permission from all roles",
            "                    for role in roles:",
            "                        self.del_permission_role(role, perm)",
            "                    self.del_permission_view_menu(perm_view.permission.name, view_menu)",
            "                elif (",
            "                    self.auth_role_admin not in self.builtin_roles",
            "                    and perm_view not in role_admin.permissions",
            "                ):",
            "                    # Role Admin must have all permissions",
            "                    self.add_permission_role(role_admin, perm_view)",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        self.add_view_menu(view_menu_name)",
            "        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if not pv:",
            "            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            self.add_permission_role(role_admin, pv)",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        \"\"\"",
            "        Will cleanup all unused permissions from the database",
            "",
            "        :param baseviews: A list of BaseViews class",
            "        :param menus: Menu class",
            "        \"\"\"",
            "        viewsmenus = self.get_all_view_menu()",
            "        roles = self.get_all_roles()",
            "        for viewmenu in viewsmenus:",
            "            found = False",
            "            for baseview in baseviews:",
            "                if viewmenu.name == baseview.class_permission_name:",
            "                    found = True",
            "                    break",
            "            if menus.find(viewmenu.name):",
            "                found = True",
            "            if not found:",
            "                permissions = self.find_permissions_view_menu(viewmenu)",
            "                for permission in permissions:",
            "                    for role in roles:",
            "                        self.del_permission_role(role, permission)",
            "                    self.del_permission_view_menu(",
            "                        permission.permission.name, viewmenu.name",
            "                    )",
            "                self.del_view_menu(viewmenu.name)",
            "        self.security_converge(baseviews, menus)",
            "",
            "    @staticmethod",
            "    def _get_new_old_permissions(baseview) -> Dict:",
            "        ret = dict()",
            "        for method_name, permission_name in baseview.method_permission_name.items():",
            "            old_permission_name = baseview.previous_method_permission_name.get(",
            "                method_name",
            "            )",
            "            # Actions do not get prefix when normally defined",
            "            if hasattr(baseview, \"actions\") and baseview.actions.get(",
            "                old_permission_name",
            "            ):",
            "                permission_prefix = \"\"",
            "            else:",
            "                permission_prefix = PERMISSION_PREFIX",
            "            if old_permission_name:",
            "                if PERMISSION_PREFIX + permission_name not in ret:",
            "                    ret[PERMISSION_PREFIX + permission_name] = {",
            "                        permission_prefix + old_permission_name",
            "                    }",
            "                else:",
            "                    ret[PERMISSION_PREFIX + permission_name].add(",
            "                        permission_prefix + old_permission_name",
            "                    )",
            "        return ret",
            "",
            "    @staticmethod",
            "    def _add_state_transition(",
            "        state_transition: Dict,",
            "        old_view_name: str,",
            "        old_perm_name: str,",
            "        view_name: str,",
            "        perm_name: str,",
            "    ) -> None:",
            "        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))",
            "        if old_pvm:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)].add(",
            "                (view_name, perm_name)",
            "            )",
            "        else:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)] = {",
            "                (view_name, perm_name)",
            "            }",
            "        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))",
            "        state_transition[\"del_views\"].add(old_view_name)",
            "        state_transition[\"del_perms\"].add(old_perm_name)",
            "",
            "    @staticmethod",
            "    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:",
            "        \"\"\"",
            "        Mutates state_transitions, loop baseviews and prunes all",
            "        views and permissions that are not to delete because references",
            "        exist.",
            "",
            "        :param baseview:",
            "        :param state_transitions:",
            "        :return:",
            "        \"\"\"",
            "        for baseview in baseviews:",
            "            state_transitions[\"del_views\"].discard(baseview.class_permission_name)",
            "            for permission in baseview.base_permissions:",
            "                state_transitions[\"del_role_pvm\"].discard(",
            "                    (baseview.class_permission_name, permission)",
            "                )",
            "                state_transitions[\"del_perms\"].discard(permission)",
            "",
            "    def create_state_transitions(",
            "        self, baseviews: List, menus: Optional[List[Any]]",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Creates a Dict with all the necessary vm/permission transitions",
            "",
            "        Dict: {",
            "                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}",
            "                \"del_role_pvm\": ((<VM>, <PERM>), ...)",
            "                \"del_views\": (<VM>, ... )",
            "                \"del_perms\": (<PERM>, ... )",
            "              }",
            "",
            "        :param baseviews: List with all the registered BaseView, BaseApi",
            "        :param menus: List with all the menu entries",
            "        :return: Dict with state transitions",
            "        \"\"\"",
            "        state_transitions = {",
            "            \"add\": {},",
            "            \"del_role_pvm\": set(),",
            "            \"del_views\": set(),",
            "            \"del_perms\": set(),",
            "        }",
            "        for baseview in baseviews:",
            "            add_all_flag = False",
            "            new_view_name = baseview.class_permission_name",
            "            permission_mapping = self._get_new_old_permissions(baseview)",
            "            if baseview.previous_class_permission_name:",
            "                old_view_name = baseview.previous_class_permission_name",
            "                add_all_flag = True",
            "            else:",
            "                new_view_name = baseview.class_permission_name",
            "                old_view_name = new_view_name",
            "            for new_perm_name in baseview.base_permissions:",
            "                if add_all_flag:",
            "                    old_perm_names = permission_mapping.get(new_perm_name)",
            "                    old_perm_names = old_perm_names or (new_perm_name,)",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "                else:",
            "                    old_perm_names = permission_mapping.get(new_perm_name) or set()",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "        self._update_del_transitions(state_transitions, baseviews)",
            "        return state_transitions",
            "",
            "    def security_converge(",
            "        self, baseviews: List, menus: Optional[List[Any]], dry=False",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Converges overridden permissions on all registered views/api",
            "        will compute all necessary operations from `class_permissions_name`,",
            "        `previous_class_permission_name`, method_permission_name`,",
            "        `previous_method_permission_name` class attributes.",
            "",
            "        :param baseviews: List of registered views/apis",
            "        :param menus: List of menu items",
            "        :param dry: If True will not change DB",
            "        :return: Dict with the necessary operations (state_transitions)",
            "        \"\"\"",
            "        state_transitions = self.create_state_transitions(baseviews, menus)",
            "        if dry:",
            "            return state_transitions",
            "        if not state_transitions:",
            "            log.info(\"No state transitions found\")",
            "            return dict()",
            "        log.debug(\"State transitions: %s\", state_transitions)",
            "        roles = self.get_all_roles()",
            "        for role in roles:",
            "            permissions = list(role.permissions)",
            "            for pvm in permissions:",
            "                new_pvm_states = state_transitions[\"add\"].get(",
            "                    (pvm.view_menu.name, pvm.permission.name)",
            "                )",
            "                if not new_pvm_states:",
            "                    continue",
            "                for new_pvm_state in new_pvm_states:",
            "                    new_pvm = self.add_permission_view_menu(",
            "                        new_pvm_state[1], new_pvm_state[0]",
            "                    )",
            "                    self.add_permission_role(role, new_pvm)",
            "                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[",
            "                    \"del_role_pvm\"",
            "                ]:",
            "                    self.del_permission_role(role, pvm)",
            "        for pvm in state_transitions[\"del_role_pvm\"]:",
            "            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)",
            "        for view_name in state_transitions[\"del_views\"]:",
            "            self.del_view_menu(view_name)",
            "        for permission_name in state_transitions[\"del_perms\"]:",
            "            self.del_permission(permission_name)",
            "        return state_transitions",
            "",
            "    \"\"\"",
            "     ---------------------------",
            "     INTERFACE ABSTRACT METHODS",
            "     ---------------------------",
            "",
            "     ---------------------",
            "     PRIMITIVES FOR USERS",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_register_user(self, registration_hash):",
            "        \"\"\"",
            "        Generic function to return user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_register_user(",
            "        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"",
            "    ):",
            "        \"\"\"",
            "        Generic function to add user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_register_user(self, register_user):",
            "        \"\"\"",
            "        Generic function to delete user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_user_by_id(self, pk):",
            "        \"\"\"",
            "        Generic function to return user by it's id (pk)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_user(self, username=None, email=None):",
            "        \"\"\"",
            "        Generic function find a user by it's username or email",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_users(self):",
            "        \"\"\"",
            "        Generic function that returns all existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_db_role_permissions(self, role_id: int) -> List[object]:",
            "        \"\"\"",
            "        Get all DB permissions from a role id",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_user(self, username, first_name, last_name, email, role, password=\"\"):",
            "        \"\"\"",
            "        Generic function to create user",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def update_user(self, user):",
            "        \"\"\"",
            "        Generic function to update user",
            "",
            "        :param user: User model to update to database",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def count_users(self):",
            "        \"\"\"",
            "        Generic function to count the existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES FOR ROLES",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_role(self, name):",
            "        raise NotImplementedError",
            "",
            "    def add_role(self, name, permissions=None):",
            "        raise NotImplementedError",
            "",
            "    def update_role(self, pk, name):",
            "        raise NotImplementedError",
            "",
            "    def get_all_roles(self):",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------------",
            "     PRIMITIVES FOR PERMISSIONS",
            "    ----------------------------",
            "    \"\"\"",
            "",
            "    def get_public_role(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_public_permissions(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permission(self, name):",
            "        \"\"\"",
            "        Finds and returns a Permission by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_roles_permission_view_menus(",
            "        self, permission_name: str, role_ids: List[int]",
            "    ):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_roles(",
            "        self, view_name: str, permission_name: str, role_ids: List[int]",
            "    ) -> bool:",
            "        \"\"\"",
            "        Finds and returns permission views for a group of roles",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission(self, name):",
            "        \"\"\"",
            "        Adds a permission to the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission(self, name):",
            "        \"\"\"",
            "        Deletes a permission from the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_view_menu(self, name):",
            "        \"\"\"",
            "        Finds and returns a ViewMenu by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_view_menu(self):",
            "        raise NotImplementedError",
            "",
            "    def add_view_menu(self, name):",
            "        \"\"\"",
            "        Adds a view or menu to the backend, model view_menu",
            "        param name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_view_menu(self, name):",
            "        \"\"\"",
            "        Deletes a ViewMenu from the backend",
            "",
            "        :param name:",
            "            name of the ViewMenu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PERMISSION VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Finds and returns a PermissionView by names",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permissions_view_menu(self, view_menu):",
            "        \"\"\"",
            "        Finds all permissions from ViewMenu, returns list of PermissionView",
            "",
            "        :param view_menu: ViewMenu object",
            "        :return: list of PermissionView objects",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Adds a permission on a view or menu to the backend",
            "",
            "        :param permission_name:",
            "            name of the permission to add: 'can_add','can_edit' etc...",
            "        :param view_menu_name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_views(self, lst, item):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_view(self, lst, permission, view_menu):",
            "        raise NotImplementedError",
            "",
            "    def add_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Add permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Remove permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def export_roles(",
            "        self, path: Optional[str] = None, indent: Optional[Union[int, str]] = None",
            "    ) -> None:",
            "        \"\"\"Exports roles to JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def import_roles(self, path: str) -> None:",
            "        \"\"\"Imports roles from JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_user(self, pk):",
            "        return self.get_user_by_id(int(pk))",
            "",
            "    def load_user_jwt(self, _jwt_header, jwt_data):",
            "        identity = jwt_data[\"sub\"]",
            "        user = self.load_user(identity)",
            "        # Set flask g.user to JWT user, we can't do it on before request",
            "        g.user = user",
            "        return user",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        g.user = current_user"
        ],
        "afterPatchFile": [
            "import datetime",
            "import logging",
            "import re",
            "from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union",
            "",
            "from flask import Flask, g, session, url_for",
            "from flask_appbuilder.exceptions import OAuthProviderUnknown",
            "from flask_babel import lazy_gettext as _",
            "from flask_jwt_extended import current_user as current_user_jwt",
            "from flask_jwt_extended import JWTManager",
            "from flask_limiter import Limiter",
            "from flask_limiter.util import get_remote_address",
            "from flask_login import current_user, LoginManager",
            "import jwt",
            "from werkzeug.security import check_password_hash, generate_password_hash",
            "",
            "from .api import SecurityApi",
            "from .registerviews import (",
            "    RegisterUserDBView,",
            "    RegisterUserOAuthView,",
            "    RegisterUserOIDView,",
            ")",
            "from .views import (",
            "    AuthDBView,",
            "    AuthLDAPView,",
            "    AuthOAuthView,",
            "    AuthOIDView,",
            "    AuthRemoteUserView,",
            "    PermissionModelView,",
            "    PermissionViewModelView,",
            "    RegisterUserModelView,",
            "    ResetMyPasswordView,",
            "    ResetPasswordView,",
            "    RoleModelView,",
            "    UserDBModelView,",
            "    UserInfoEditView,",
            "    UserLDAPModelView,",
            "    UserOAuthModelView,",
            "    UserOIDModelView,",
            "    UserRemoteUserModelView,",
            "    UserStatsChartView,",
            "    ViewMenuModelView,",
            ")",
            "from ..basemanager import BaseManager",
            "from ..const import (",
            "    AUTH_DB,",
            "    AUTH_LDAP,",
            "    AUTH_OAUTH,",
            "    AUTH_OID,",
            "    AUTH_REMOTE_USER,",
            "    LOGMSG_ERR_SEC_ADD_REGISTER_USER,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP,",
            "    LOGMSG_ERR_SEC_AUTH_LDAP_TLS,",
            "    LOGMSG_WAR_SEC_LOGIN_FAILED,",
            "    LOGMSG_WAR_SEC_NO_USER,",
            "    LOGMSG_WAR_SEC_NOLDAP_OBJ,",
            "    MICROSOFT_KEY_SET_URL,",
            "    PERMISSION_PREFIX,",
            ")",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class AbstractSecurityManager(BaseManager):",
            "    \"\"\"",
            "    Abstract SecurityManager class, declares all methods used by the",
            "    framework. There is no assumptions about security models or auth types.",
            "    \"\"\"",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def register_views(self):",
            "        \"\"\"",
            "        Generic function to create the security views",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def has_access(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        raise NotImplementedError",
            "",
            "    def get_first_user(self):",
            "        raise NotImplementedError",
            "",
            "    def noop_user_update(self, user) -> None:",
            "        raise NotImplementedError",
            "",
            "",
            "def _oauth_tokengetter(token=None):",
            "    \"\"\"",
            "    Default function to return the current user oauth token",
            "    from session cookie.",
            "    \"\"\"",
            "    token = session.get(\"oauth\")",
            "    log.debug(\"Token Get: %s\", token)",
            "    return token",
            "",
            "",
            "class BaseSecurityManager(AbstractSecurityManager):",
            "    auth_view = None",
            "    \"\"\" The obj instance for authentication view \"\"\"",
            "    user_view = None",
            "    \"\"\" The obj instance for user view \"\"\"",
            "    registeruser_view = None",
            "    \"\"\" The obj instance for registering user view \"\"\"",
            "    lm = None",
            "    \"\"\" Flask-Login LoginManager \"\"\"",
            "    jwt_manager = None",
            "    \"\"\" Flask-JWT-Extended \"\"\"",
            "    oid = None",
            "    \"\"\" Flask-OpenID OpenID \"\"\"",
            "    oauth = None",
            "    \"\"\" Flask-OAuth \"\"\"",
            "    oauth_remotes = None",
            "    \"\"\" OAuth email whitelists \"\"\"",
            "    oauth_whitelists = {}",
            "    \"\"\" Initialized (remote_app) providers dict {'provider_name', OBJ } \"\"\"",
            "    oauth_tokengetter = _oauth_tokengetter",
            "    \"\"\" OAuth tokengetter function override to implement your own tokengetter method \"\"\"",
            "    oauth_user_info = None",
            "",
            "    user_model = None",
            "    \"\"\" Override to set your own User Model \"\"\"",
            "    role_model = None",
            "    \"\"\" Override to set your own Role Model \"\"\"",
            "    permission_model = None",
            "    \"\"\" Override to set your own Permission Model \"\"\"",
            "    viewmenu_model = None",
            "    \"\"\" Override to set your own ViewMenu Model \"\"\"",
            "    permissionview_model = None",
            "    \"\"\" Override to set your own PermissionView Model \"\"\"",
            "    registeruser_model = None",
            "    \"\"\" Override to set your own RegisterUser Model \"\"\"",
            "",
            "    userdbmodelview = UserDBModelView",
            "    \"\"\" Override if you want your own user db view \"\"\"",
            "    userldapmodelview = UserLDAPModelView",
            "    \"\"\" Override if you want your own user ldap view \"\"\"",
            "    useroidmodelview = UserOIDModelView",
            "    \"\"\" Override if you want your own user OID view \"\"\"",
            "    useroauthmodelview = UserOAuthModelView",
            "    \"\"\" Override if you want your own user OAuth view \"\"\"",
            "    userremoteusermodelview = UserRemoteUserModelView",
            "    \"\"\" Override if you want your own user REMOTE_USER view \"\"\"",
            "    registerusermodelview = RegisterUserModelView",
            "",
            "    authdbview = AuthDBView",
            "    \"\"\" Override if you want your own Authentication DB view \"\"\"",
            "    authldapview = AuthLDAPView",
            "    \"\"\" Override if you want your own Authentication LDAP view \"\"\"",
            "    authoidview = AuthOIDView",
            "    \"\"\" Override if you want your own Authentication OID view \"\"\"",
            "    authoauthview = AuthOAuthView",
            "    \"\"\" Override if you want your own Authentication OAuth view \"\"\"",
            "    authremoteuserview = AuthRemoteUserView",
            "    \"\"\" Override if you want your own Authentication REMOTE_USER view \"\"\"",
            "",
            "    registeruserdbview = RegisterUserDBView",
            "    \"\"\" Override if you want your own register user db view \"\"\"",
            "    registeruseroidview = RegisterUserOIDView",
            "    \"\"\" Override if you want your own register user OpenID view \"\"\"",
            "    registeruseroauthview = RegisterUserOAuthView",
            "    \"\"\" Override if you want your own register user OAuth view \"\"\"",
            "",
            "    resetmypasswordview = ResetMyPasswordView",
            "    \"\"\" Override if you want your own reset my password view \"\"\"",
            "    resetpasswordview = ResetPasswordView",
            "    \"\"\" Override if you want your own reset password view \"\"\"",
            "    userinfoeditview = UserInfoEditView",
            "    \"\"\" Override if you want your own User information edit view \"\"\"",
            "",
            "    # API",
            "    security_api = SecurityApi",
            "    \"\"\" Override if you want your own Security API login endpoint \"\"\"",
            "",
            "    rolemodelview = RoleModelView",
            "    permissionmodelview = PermissionModelView",
            "    userstatschartview = UserStatsChartView",
            "    viewmenumodelview = ViewMenuModelView",
            "    permissionviewmodelview = PermissionViewModelView",
            "",
            "    def __init__(self, appbuilder):",
            "        super(BaseSecurityManager, self).__init__(appbuilder)",
            "        app = self.appbuilder.get_app",
            "        # Base Security Config",
            "        app.config.setdefault(\"AUTH_ROLE_ADMIN\", \"Admin\")",
            "        app.config.setdefault(\"AUTH_ROLE_PUBLIC\", \"Public\")",
            "        app.config.setdefault(\"AUTH_TYPE\", AUTH_DB)",
            "        # Self Registration",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION\", False)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE\", self.auth_role_public)",
            "        app.config.setdefault(\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\", None)",
            "        # Role Mapping",
            "        app.config.setdefault(\"AUTH_ROLES_MAPPING\", {})",
            "        app.config.setdefault(\"AUTH_ROLES_SYNC_AT_LOGIN\", False)",
            "        app.config.setdefault(\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\", False)",
            "",
            "        # LDAP Config",
            "        if self.auth_type == AUTH_LDAP:",
            "            if \"AUTH_LDAP_SERVER\" not in app.config:",
            "                raise Exception(",
            "                    \"No AUTH_LDAP_SERVER defined on config\"",
            "                    \" with AUTH_LDAP authentication type.\"",
            "                )",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_SEARCH_FILTER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_APPEND_DOMAIN\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_USERNAME_FORMAT\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_USER\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_BIND_PASSWORD\", \"\")",
            "            # TLS options",
            "            app.config.setdefault(\"AUTH_LDAP_USE_TLS\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_ALLOW_SELF_SIGNED\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_DEMAND\", False)",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTDIR\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CACERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_CERTFILE\", \"\")",
            "            app.config.setdefault(\"AUTH_LDAP_TLS_KEYFILE\", \"\")",
            "            # Mapping options",
            "            app.config.setdefault(\"AUTH_LDAP_UID_FIELD\", \"uid\")",
            "            app.config.setdefault(\"AUTH_LDAP_GROUP_FIELD\", \"memberOf\")",
            "            app.config.setdefault(\"AUTH_LDAP_FIRSTNAME_FIELD\", \"givenName\")",
            "            app.config.setdefault(\"AUTH_LDAP_LASTNAME_FIELD\", \"sn\")",
            "            app.config.setdefault(\"AUTH_LDAP_EMAIL_FIELD\", \"mail\")",
            "",
            "        # Rate limiting",
            "        app.config.setdefault(\"AUTH_RATE_LIMITED\", False)",
            "        app.config.setdefault(\"AUTH_RATE_LIMIT\", \"10 per 20 second\")",
            "",
            "        if self.auth_type == AUTH_OID:",
            "            from flask_openid import OpenID",
            "",
            "            self.oid = OpenID(app)",
            "        if self.auth_type == AUTH_OAUTH:",
            "            from authlib.integrations.flask_client import OAuth",
            "",
            "            self.oauth = OAuth(app)",
            "            self.oauth_remotes = {}",
            "            for _provider in self.oauth_providers:",
            "                provider_name = _provider[\"name\"]",
            "                log.debug(\"OAuth providers init %s\", provider_name)",
            "                obj_provider = self.oauth.register(",
            "                    provider_name, **_provider[\"remote_app\"]",
            "                )",
            "                obj_provider._tokengetter = self.oauth_tokengetter",
            "                if not self.oauth_user_info:",
            "                    self.oauth_user_info = self.get_oauth_user_info",
            "                # Whitelist only users with matching emails",
            "                if \"whitelist\" in _provider:",
            "                    self.oauth_whitelists[provider_name] = _provider[\"whitelist\"]",
            "                self.oauth_remotes[provider_name] = obj_provider",
            "",
            "        self._builtin_roles = self.create_builtin_roles()",
            "        # Setup Flask-Login",
            "        self.lm = self.create_login_manager(app)",
            "",
            "        # Setup Flask-Jwt-Extended",
            "        self.jwt_manager = self.create_jwt_manager(app)",
            "",
            "        # Setup Flask-Limiter",
            "        self.limiter = self.create_limiter(app)",
            "",
            "    def create_limiter(self, app: Flask) -> Limiter:",
            "        limiter = Limiter(key_func=get_remote_address)",
            "        limiter.init_app(app)",
            "        return limiter",
            "",
            "    def create_login_manager(self, app) -> LoginManager:",
            "        \"\"\"",
            "        Override to implement your custom login manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        lm = LoginManager(app)",
            "        lm.login_view = \"login\"",
            "        lm.user_loader(self.load_user)",
            "        return lm",
            "",
            "    def create_jwt_manager(self, app) -> JWTManager:",
            "        \"\"\"",
            "        Override to implement your custom JWT manager instance",
            "",
            "        :param app: Flask app",
            "        \"\"\"",
            "        jwt_manager = JWTManager()",
            "        jwt_manager.init_app(app)",
            "        jwt_manager.user_lookup_loader(self.load_user_jwt)",
            "        return jwt_manager",
            "",
            "    def create_builtin_roles(self):",
            "        return self.appbuilder.get_app.config.get(\"FAB_ROLES\", {})",
            "",
            "    def get_roles_from_keys(self, role_keys: List[str]) -> Set[role_model]:",
            "        \"\"\"",
            "        Construct a list of FAB role objects, from a list of keys.",
            "",
            "        NOTE:",
            "        - keys are things like: \"LDAP group DNs\" or \"OAUTH group names\"",
            "        - we use AUTH_ROLES_MAPPING to map from keys, to FAB role names",
            "",
            "        :param role_keys: the list of FAB role keys",
            "        :return: a list of RoleModelView",
            "        \"\"\"",
            "        _roles = set()",
            "        _role_keys = set(role_keys)",
            "        for role_key, fab_role_names in self.auth_roles_mapping.items():",
            "            if role_key in _role_keys:",
            "                for fab_role_name in fab_role_names:",
            "                    fab_role = self.find_role(fab_role_name)",
            "                    if fab_role:",
            "                        _roles.add(fab_role)",
            "                    else:",
            "                        log.warning(",
            "                            \"Can't find role specified in AUTH_ROLES_MAPPING: %s\",",
            "                            fab_role_name,",
            "                        )",
            "        return _roles",
            "",
            "    @property",
            "    def auth_type_provider_name(self) -> Optional[str]:",
            "        provider_to_auth_type = {AUTH_DB: \"db\", AUTH_LDAP: \"ldap\"}",
            "        return provider_to_auth_type.get(self.auth_type)",
            "",
            "    @property",
            "    def get_url_for_registeruser(self):",
            "        return url_for(",
            "            \"%s.%s\"",
            "            % (self.registeruser_view.endpoint, self.registeruser_view.default_view)",
            "        )",
            "",
            "    @property",
            "    def get_user_datamodel(self):",
            "        return self.user_view.datamodel",
            "",
            "    @property",
            "    def get_register_user_datamodel(self):",
            "        return self.registerusermodelview.datamodel",
            "",
            "    @property",
            "    def builtin_roles(self) -> Dict[str, Any]:",
            "        return self._builtin_roles",
            "",
            "    @property",
            "    def api_login_allow_multiple_providers(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_API_LOGIN_ALLOW_MULTIPLE_PROVIDERS\"]",
            "",
            "    @property",
            "    def auth_type(self) -> int:",
            "        return self.appbuilder.get_app.config[\"AUTH_TYPE\"]",
            "",
            "    @property",
            "    def auth_username_ci(self) -> str:",
            "        return self.appbuilder.get_app.config.get(\"AUTH_USERNAME_CI\", True)",
            "",
            "    @property",
            "    def auth_role_admin(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_ADMIN\"]",
            "",
            "    @property",
            "    def auth_role_public(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLE_PUBLIC\"]",
            "",
            "    @property",
            "    def auth_ldap_server(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SERVER\"]",
            "",
            "    @property",
            "    def auth_ldap_use_tls(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USE_TLS\"]",
            "",
            "    @property",
            "    def auth_user_registration(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION\"]",
            "",
            "    @property",
            "    def auth_user_registration_role(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE\"]",
            "",
            "    @property",
            "    def auth_user_registration_role_jmespath(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_USER_REGISTRATION_ROLE_JMESPATH\"]",
            "",
            "    @property",
            "    def auth_roles_mapping(self) -> Dict[str, List[str]]:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_MAPPING\"]",
            "",
            "    @property",
            "    def auth_roles_sync_at_login(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_ROLES_SYNC_AT_LOGIN\"]",
            "",
            "    @property",
            "    def auth_ldap_search(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH\"]",
            "",
            "    @property",
            "    def auth_ldap_search_filter(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_SEARCH_FILTER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_user(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_USER\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_password(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_PASSWORD\"]",
            "",
            "    @property",
            "    def auth_ldap_append_domain(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_APPEND_DOMAIN\"]",
            "",
            "    @property",
            "    def auth_ldap_username_format(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_USERNAME_FORMAT\"]",
            "",
            "    @property",
            "    def auth_ldap_uid_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_UID_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_group_field(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_GROUP_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_firstname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_FIRSTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_lastname_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_LASTNAME_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_email_field(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_EMAIL_FIELD\"]",
            "",
            "    @property",
            "    def auth_ldap_bind_first(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_BIND_FIRST\"]",
            "",
            "    @property",
            "    def auth_ldap_allow_self_signed(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_ALLOW_SELF_SIGNED\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_demand(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_DEMAND\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertdir(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTDIR\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_cacertfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CACERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_certfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_CERTFILE\"]",
            "",
            "    @property",
            "    def auth_ldap_tls_keyfile(self):",
            "        return self.appbuilder.get_app.config[\"AUTH_LDAP_TLS_KEYFILE\"]",
            "",
            "    @property",
            "    def openid_providers(self):",
            "        return self.appbuilder.get_app.config[\"OPENID_PROVIDERS\"]",
            "",
            "    @property",
            "    def oauth_providers(self):",
            "        return self.appbuilder.get_app.config[\"OAUTH_PROVIDERS\"]",
            "",
            "    @property",
            "    def is_auth_limited(self) -> bool:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMITED\"]",
            "",
            "    @property",
            "    def auth_rate_limit(self) -> str:",
            "        return self.appbuilder.get_app.config[\"AUTH_RATE_LIMIT\"]",
            "",
            "    @property",
            "    def current_user(self):",
            "        if current_user.is_authenticated:",
            "            return g.user",
            "        elif current_user_jwt:",
            "            return current_user_jwt",
            "",
            "    def oauth_user_info_getter(",
            "        self,",
            "        func: Callable[[\"BaseSecurityManager\", str, Dict[str, Any]], Dict[str, Any]],",
            "    ):",
            "        \"\"\"",
            "        Decorator function to be the OAuth user info getter",
            "        for all the providers, receives provider and response",
            "        return a dict with the information returned from the provider.",
            "        The returned user info dict should have it's keys with the same",
            "        name as the User Model.",
            "",
            "        Use it like this an example for GitHub ::",
            "",
            "            @appbuilder.sm.oauth_user_info_getter",
            "            def my_oauth_user_info(sm, provider, response=None):",
            "                if provider == 'github':",
            "                    me = sm.oauth_remotes[provider].get('user')",
            "                    return {'username': me.data.get('login')}",
            "                return {}",
            "        \"\"\"",
            "",
            "        def wraps(provider: str, response: Dict[str, Any] = None) -> Dict[str, Any]:",
            "            return func(self, provider, response)",
            "",
            "        self.oauth_user_info = wraps",
            "        return wraps",
            "",
            "    def get_oauth_token_key_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_key name for the oauth provider",
            "        if none is configured defaults to oauth_token",
            "        this is configured using OAUTH_PROVIDERS and token_key key.",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_key\", \"oauth_token\")",
            "",
            "    def get_oauth_token_secret_name(self, provider):",
            "        \"\"\"",
            "        Returns the token_secret name for the oauth provider",
            "        if none is configured defaults to oauth_secret",
            "        this is configured using OAUTH_PROVIDERS and token_secret",
            "        \"\"\"",
            "        for _provider in self.oauth_providers:",
            "            if _provider[\"name\"] == provider:",
            "                return _provider.get(\"token_secret\", \"oauth_token_secret\")",
            "",
            "    def set_oauth_session(self, provider, oauth_response):",
            "        \"\"\"",
            "        Set the current session with OAuth user secrets",
            "        \"\"\"",
            "        # Get this provider key names for token_key and token_secret",
            "        token_key = self.appbuilder.sm.get_oauth_token_key_name(provider)",
            "        token_secret = self.appbuilder.sm.get_oauth_token_secret_name(provider)",
            "        # Save users token on encrypted session cookie",
            "        session[\"oauth\"] = (",
            "            oauth_response[token_key],",
            "            oauth_response.get(token_secret, \"\"),",
            "        )",
            "        session[\"oauth_provider\"] = provider",
            "",
            "    def get_oauth_user_info(",
            "        self, provider: str, resp: Dict[str, Any]",
            "    ) -> Dict[str, Any]:",
            "        \"\"\"",
            "        Since there are different OAuth APIs with different ways to",
            "        retrieve user info",
            "        \"\"\"",
            "        # for GITHUB",
            "        if provider == \"github\" or provider == \"githublocal\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"user\")",
            "            data = me.json()",
            "            log.debug(\"User info from Github: %s\", data)",
            "            return {\"username\": \"github_\" + data.get(\"login\")}",
            "        # for twitter",
            "        if provider == \"twitter\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"account/settings.json\")",
            "            data = me.json()",
            "            log.debug(\"User info from Twitter: %s\", data)",
            "            return {\"username\": \"twitter_\" + data.get(\"screen_name\", \"\")}",
            "        # for linkedin",
            "        if provider == \"linkedin\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"people/~:(id,email-address,first-name,last-name)?format=json\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from Linkedin: %s\", data)",
            "            return {",
            "                \"username\": \"linkedin_\" + data.get(\"id\", \"\"),",
            "                \"email\": data.get(\"email-address\", \"\"),",
            "                \"first_name\": data.get(\"firstName\", \"\"),",
            "                \"last_name\": data.get(\"lastName\", \"\"),",
            "            }",
            "        # for Google",
            "        if provider == \"google\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Google: %s\", data)",
            "            return {",
            "                \"username\": \"google_\" + data.get(\"id\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        if provider == \"azure\":",
            "            me = self._decode_and_validate_azure_jwt(resp[\"id_token\"])",
            "            log.debug(\"User info from Azure: %s\", me)",
            "            # https://learn.microsoft.com/en-us/azure/active-directory/develop/id-token-claims-reference#payload-claims",
            "            return {",
            "                # To keep backward compatibility with previous versions",
            "                # of FAB, we use upn if available, otherwise we use email",
            "                \"email\": me[\"upn\"] if \"upn\" in me else me[\"email\"],",
            "                \"first_name\": me.get(\"given_name\", \"\"),",
            "                \"last_name\": me.get(\"family_name\", \"\"),",
            "                \"username\": me[\"oid\"],",
            "                \"role_keys\": me.get(\"roles\", []),",
            "            }",
            "        # for OpenShift",
            "        if provider == \"openshift\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"apis/user.openshift.io/v1/users/~\"",
            "            )",
            "            data = me.json()",
            "            log.debug(\"User info from OpenShift: %s\", data)",
            "            return {\"username\": \"openshift_\" + data.get(\"metadata\").get(\"name\")}",
            "        # for Okta",
            "        if provider == \"okta\":",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(\"userinfo\")",
            "            data = me.json()",
            "            log.debug(\"User info from Okta: %s\", data)",
            "            return {",
            "                \"username\": f\"{provider}_{data['sub']}\",",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data[\"email\"],",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Auth0",
            "        if provider == \"auth0\":",
            "            data = self.appbuilder.sm.oauth_remotes[provider].userinfo()",
            "            log.debug(\"User info from Auth0: %s\", data)",
            "            return {",
            "                \"username\": f\"{provider}_{data['sub']}\",",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data[\"email\"],",
            "                \"role_keys\": data.get(\"groups\", []),",
            "            }",
            "        # for Keycloak",
            "        if provider in [\"keycloak\", \"keycloak_before_17\"]:",
            "            me = self.appbuilder.sm.oauth_remotes[provider].get(",
            "                \"openid-connect/userinfo\"",
            "            )",
            "            me.raise_for_status()",
            "            data = me.json()",
            "            log.debug(\"User info from Keycloak: %s\", data)",
            "            return {",
            "                \"username\": data.get(\"preferred_username\", \"\"),",
            "                \"first_name\": data.get(\"given_name\", \"\"),",
            "                \"last_name\": data.get(\"family_name\", \"\"),",
            "                \"email\": data.get(\"email\", \"\"),",
            "            }",
            "        raise OAuthProviderUnknown()",
            "",
            "    def _get_microsoft_jwks(self) -> List[Dict[str, Any]]:",
            "        import requests",
            "",
            "        return requests.get(MICROSOFT_KEY_SET_URL).json()",
            "",
            "    def _decode_and_validate_azure_jwt(self, id_token: str) -> Dict[str, str]:",
            "        verify_signature = self.oauth_remotes[\"azure\"].client_kwargs.get(",
            "            \"verify_signature\", False",
            "        )",
            "        if verify_signature:",
            "            from authlib.jose import JsonWebKey, jwt as authlib_jwt",
            "",
            "            keyset = JsonWebKey.import_key_set(self._get_microsoft_jwks())",
            "            claims = authlib_jwt.decode(id_token, keyset)",
            "            claims.validate()",
            "            return claims",
            "",
            "        return jwt.decode(id_token, options={\"verify_signature\": False})",
            "",
            "    def register_views(self):",
            "        if not self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEWS\", True):",
            "            return",
            "        # Security APIs",
            "        self.appbuilder.add_api(self.security_api)",
            "",
            "        if self.auth_user_registration:",
            "            if self.auth_type == AUTH_DB:",
            "                self.registeruser_view = self.registeruserdbview()",
            "            elif self.auth_type == AUTH_OID:",
            "                self.registeruser_view = self.registeruseroidview()",
            "            elif self.auth_type == AUTH_OAUTH:",
            "                self.registeruser_view = self.registeruseroauthview()",
            "            if self.registeruser_view:",
            "                self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.resetpasswordview())",
            "        self.appbuilder.add_view_no_menu(self.resetmypasswordview())",
            "        self.appbuilder.add_view_no_menu(self.userinfoeditview())",
            "",
            "        if self.auth_type == AUTH_DB:",
            "            self.user_view = self.userdbmodelview",
            "            self.auth_view = self.authdbview()",
            "",
            "        elif self.auth_type == AUTH_LDAP:",
            "            self.user_view = self.userldapmodelview",
            "            self.auth_view = self.authldapview()",
            "        elif self.auth_type == AUTH_OAUTH:",
            "            self.user_view = self.useroauthmodelview",
            "            self.auth_view = self.authoauthview()",
            "        elif self.auth_type == AUTH_REMOTE_USER:",
            "            self.user_view = self.userremoteusermodelview",
            "            self.auth_view = self.authremoteuserview()",
            "        else:",
            "            self.user_view = self.useroidmodelview",
            "            self.auth_view = self.authoidview()",
            "            if self.auth_user_registration:",
            "                pass",
            "                # self.registeruser_view = self.registeruseroidview()",
            "                # self.appbuilder.add_view_no_menu(self.registeruser_view)",
            "",
            "        self.appbuilder.add_view_no_menu(self.auth_view)",
            "",
            "        # this needs to be done after the view is added, otherwise the blueprint",
            "        # is not initialized",
            "        if self.is_auth_limited:",
            "            self.limiter.limit(self.auth_rate_limit, methods=[\"POST\"])(",
            "                self.auth_view.blueprint",
            "            )",
            "",
            "        self.user_view = self.appbuilder.add_view(",
            "            self.user_view,",
            "            \"List Users\",",
            "            icon=\"fa-user\",",
            "            label=_(\"List Users\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "            category_label=_(\"Security\"),",
            "        )",
            "",
            "        role_view = self.appbuilder.add_view(",
            "            self.rolemodelview,",
            "            \"List Roles\",",
            "            icon=\"fa-group\",",
            "            label=_(\"List Roles\"),",
            "            category=\"Security\",",
            "            category_icon=\"fa-cogs\",",
            "        )",
            "        role_view.related_views = [self.user_view.__class__]",
            "",
            "        if self.userstatschartview:",
            "            self.appbuilder.add_view(",
            "                self.userstatschartview,",
            "                \"User's Statistics\",",
            "                icon=\"fa-bar-chart-o\",",
            "                label=_(\"User's Statistics\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.auth_user_registration:",
            "            self.appbuilder.add_view(",
            "                self.registerusermodelview,",
            "                \"User Registrations\",",
            "                icon=\"fa-user-plus\",",
            "                label=_(\"User Registrations\"),",
            "                category=\"Security\",",
            "            )",
            "        self.appbuilder.menu.add_separator(\"Security\")",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_PERMISSION_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.permissionmodelview,",
            "                \"Base Permissions\",",
            "                icon=\"fa-lock\",",
            "                label=_(\"Base Permissions\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(\"FAB_ADD_SECURITY_VIEW_MENU_VIEW\", True):",
            "            self.appbuilder.add_view(",
            "                self.viewmenumodelview,",
            "                \"Views/Menus\",",
            "                icon=\"fa-list-alt\",",
            "                label=_(\"Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "        if self.appbuilder.app.config.get(",
            "            \"FAB_ADD_SECURITY_PERMISSION_VIEWS_VIEW\", True",
            "        ):",
            "            self.appbuilder.add_view(",
            "                self.permissionviewmodelview,",
            "                \"Permission on Views/Menus\",",
            "                icon=\"fa-link\",",
            "                label=_(\"Permission on Views/Menus\"),",
            "                category=\"Security\",",
            "            )",
            "",
            "    def create_db(self):",
            "        \"\"\"",
            "        Setups the DB, creates admin and public roles if they don't exist.",
            "        \"\"\"",
            "        roles_mapping = self.appbuilder.get_app.config.get(\"FAB_ROLES_MAPPING\", {})",
            "        for pk, name in roles_mapping.items():",
            "            self.update_role(pk, name)",
            "        for role_name, permission_view_menus in self.builtin_roles.items():",
            "            permission_view_menus = [",
            "                self.add_permission_view_menu(permission_name, view_menu_name)",
            "                for view_menu_name, permission_name in permission_view_menus",
            "            ]",
            "            self.add_role(name=role_name, permissions=permission_view_menus)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            self.add_role(self.auth_role_admin)",
            "        self.add_role(self.auth_role_public)",
            "        if self.count_users() == 0:",
            "            log.warning(LOGMSG_WAR_SEC_NO_USER)",
            "",
            "    def reset_password(self, userid, password):",
            "        \"\"\"",
            "        Change/Reset a user's password for authdb.",
            "        Password will be hashed and saved.",
            "",
            "        :param userid:",
            "            the user.id to reset the password",
            "        :param password:",
            "            The clear text password to reset and save hashed on the db",
            "        \"\"\"",
            "        user = self.get_user_by_id(userid)",
            "        user.password = generate_password_hash(password)",
            "        self.update_user(user)",
            "",
            "    def update_user_auth_stat(self, user, success=True):",
            "        \"\"\"",
            "        Update user authentication stats upon successful/unsuccessful",
            "        authentication attempts.",
            "",
            "        :param user:",
            "            The identified (but possibly not successfully authenticated) user",
            "            model",
            "        :param success:",
            "        :type success: bool or None",
            "            Defaults to true, if true increments login_count, updates",
            "            last_login, and resets fail_login_count to 0, if false increments",
            "            fail_login_count on user model.",
            "        \"\"\"",
            "        if not user.login_count:",
            "            user.login_count = 0",
            "        if not user.fail_login_count:",
            "            user.fail_login_count = 0",
            "        if success:",
            "            user.login_count += 1",
            "            user.last_login = datetime.datetime.now()",
            "            user.fail_login_count = 0",
            "        else:",
            "            user.fail_login_count += 1",
            "        self.update_user(user)",
            "",
            "    def auth_user_db(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user, auth db style",
            "",
            "        :param username:",
            "            The username or registered email address",
            "        :param password:",
            "            The password, will be tested against hashed password on db",
            "        \"\"\"",
            "        if username is None or username == \"\":",
            "            return None",
            "        first_user = self.get_first_user()",
            "        user = self.find_user(username=username)",
            "        if user is None:",
            "            user = self.find_user(email=username)",
            "        else:",
            "            # Balance failure and success",
            "            _ = self.find_user(email=username)",
            "        if user is None or (not user.is_active):",
            "            # Balance failure and success",
            "            check_password_hash(",
            "                \"pbkdf2:sha256:150000$Z3t6fmj2$22da622d94a1f8118\"",
            "                \"c0976a03d2f18f680bfff877c9a965db9eedc51bc0be87c\",",
            "                \"password\",",
            "            )",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            # Balance failure and success",
            "            if first_user:",
            "                self.noop_user_update(first_user)",
            "            return None",
            "        elif check_password_hash(user.password, password):",
            "            self.update_user_auth_stat(user, True)",
            "            return user",
            "        else:",
            "            self.update_user_auth_stat(user, False)",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            return None",
            "",
            "    def _search_ldap(self, ldap, con, username):",
            "        \"\"\"",
            "        Searches LDAP for user.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        :param username: username to match with AUTH_LDAP_UID_FIELD",
            "        :return: ldap object array",
            "        \"\"\"",
            "        # always check AUTH_LDAP_SEARCH is set before calling this method",
            "        assert self.auth_ldap_search, \"AUTH_LDAP_SEARCH must be set\"",
            "",
            "        # build the filter string for the LDAP search",
            "        if self.auth_ldap_search_filter:",
            "            filter_str = \"(&{0}({1}={2}))\".format(",
            "                self.auth_ldap_search_filter, self.auth_ldap_uid_field, username",
            "            )",
            "        else:",
            "            filter_str = \"({0}={1})\".format(self.auth_ldap_uid_field, username)",
            "",
            "        # build what fields to request in the LDAP search",
            "        request_fields = [",
            "            self.auth_ldap_firstname_field,",
            "            self.auth_ldap_lastname_field,",
            "            self.auth_ldap_email_field,",
            "        ]",
            "        if len(self.auth_roles_mapping) > 0:",
            "            request_fields.append(self.auth_ldap_group_field)",
            "",
            "        # perform the LDAP search",
            "        log.debug(",
            "            \"LDAP search for '%s' with fields %s in scope '%s'\",",
            "            filter_str,",
            "            request_fields,",
            "            self.auth_ldap_search,",
            "        )",
            "        raw_search_result = con.search_s(",
            "            self.auth_ldap_search, ldap.SCOPE_SUBTREE, filter_str, request_fields",
            "        )",
            "        log.debug(\"LDAP search returned: %s\", raw_search_result)",
            "",
            "        # Remove any search referrals from results",
            "        search_result = [",
            "            (dn, attrs)",
            "            for dn, attrs in raw_search_result",
            "            if dn is not None and isinstance(attrs, dict)",
            "        ]",
            "",
            "        # only continue if 0 or 1 results were returned",
            "        if len(search_result) > 1:",
            "            log.error(",
            "                \"LDAP search for '%s' in scope '%s' returned multiple results\",",
            "                filter_str,",
            "                self.auth_ldap_search,",
            "            )",
            "            return None, None",
            "",
            "        try:",
            "            # extract the DN",
            "            user_dn = search_result[0][0]",
            "            # extract the other attributes",
            "            user_info = search_result[0][1]",
            "            # return",
            "            return user_dn, user_info",
            "        except (IndexError, NameError):",
            "            return None, None",
            "",
            "    def _ldap_calculate_user_roles(",
            "        self, user_attributes: Dict[str, bytes]",
            "    ) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = self.ldap_extract_list(",
            "                user_attributes, self.auth_ldap_group_field",
            "            )",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: %s\", registration_role_name",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def _ldap_bind_indirect(self, ldap, con) -> None:",
            "        \"\"\"",
            "        Attempt to bind to LDAP using the AUTH_LDAP_BIND_USER.",
            "",
            "        :param ldap: The ldap module reference",
            "        :param con: The ldap connection",
            "        \"\"\"",
            "        # always check AUTH_LDAP_BIND_USER is set before calling this method",
            "        assert self.auth_ldap_bind_user, \"AUTH_LDAP_BIND_USER must be set\"",
            "",
            "        try:",
            "            log.debug(",
            "                \"LDAP bind indirect TRY with username: '%s'\", self.auth_ldap_bind_user",
            "            )",
            "            con.simple_bind_s(self.auth_ldap_bind_user, self.auth_ldap_bind_password)",
            "            log.debug(",
            "                \"LDAP bind indirect SUCCESS with username: '%s'\",",
            "                self.auth_ldap_bind_user,",
            "            )",
            "        except ldap.INVALID_CREDENTIALS as ex:",
            "            log.error(",
            "                \"AUTH_LDAP_BIND_USER and AUTH_LDAP_BIND_PASSWORD are\"",
            "                \" not valid LDAP bind credentials\"",
            "            )",
            "            raise ex",
            "",
            "    @staticmethod",
            "    def _ldap_bind(ldap, con, dn: str, password: str) -> bool:",
            "        \"\"\"",
            "        Validates/binds the provided dn/password with the LDAP sever.",
            "        \"\"\"",
            "        try:",
            "            log.debug(\"LDAP bind TRY with username: '%s'\", dn)",
            "            con.simple_bind_s(dn, password)",
            "            log.debug(\"LDAP bind SUCCESS with username: '%s'\", dn)",
            "            return True",
            "        except ldap.INVALID_CREDENTIALS:",
            "            return False",
            "",
            "    @staticmethod",
            "    def ldap_extract(",
            "        ldap_dict: Dict[str, bytes], field_name: str, fallback: str",
            "    ) -> str:",
            "        raw_value = ldap_dict.get(field_name, [bytes()])",
            "        # decode - if empty string, default to fallback, otherwise take first element",
            "        return raw_value[0].decode(\"utf-8\") or fallback",
            "",
            "    @staticmethod",
            "    def ldap_extract_list(ldap_dict: Dict[str, bytes], field_name: str) -> List[str]:",
            "        raw_list = ldap_dict.get(field_name, [])",
            "        # decode - removing empty strings",
            "        return [x.decode(\"utf-8\") for x in raw_list if x.decode(\"utf-8\")]",
            "",
            "    def auth_user_ldap(self, username, password):",
            "        \"\"\"",
            "        Method for authenticating user with LDAP.",
            "",
            "        NOTE: this depends on python-ldap module",
            "",
            "        :param username: the username",
            "        :param password: the password",
            "        \"\"\"",
            "        # If no username is provided, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Ensure python-ldap is installed",
            "        try:",
            "            import ldap",
            "        except ImportError:",
            "            log.error(\"python-ldap library is not installed\")",
            "            return None",
            "",
            "        try:",
            "            # LDAP certificate settings",
            "            if self.auth_ldap_tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, self.auth_ldap_tls_cacertdir)",
            "            if self.auth_ldap_tls_cacertfile:",
            "                ldap.set_option(",
            "                    ldap.OPT_X_TLS_CACERTFILE, self.auth_ldap_tls_cacertfile",
            "                )",
            "            if self.auth_ldap_tls_certfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CERTFILE, self.auth_ldap_tls_certfile)",
            "            if self.auth_ldap_tls_keyfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_KEYFILE, self.auth_ldap_tls_keyfile)",
            "            if self.auth_ldap_allow_self_signed:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_ALLOW)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "            elif self.auth_ldap_tls_demand:",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_DEMAND)",
            "                ldap.set_option(ldap.OPT_X_TLS_NEWCTX, 0)",
            "",
            "            # Initialise LDAP connection",
            "            con = ldap.initialize(self.auth_ldap_server)",
            "            con.set_option(ldap.OPT_REFERRALS, 0)",
            "            if self.auth_ldap_use_tls:",
            "                try:",
            "                    con.start_tls_s()",
            "                except Exception:",
            "                    log.error(LOGMSG_ERR_SEC_AUTH_LDAP_TLS, self.auth_ldap_server)",
            "                    return None",
            "",
            "            # Define variables, so we can check if they are set in later steps",
            "            user_dn = None",
            "            user_attributes = {}",
            "",
            "            # Flow 1 - (Indirect Search Bind):",
            "            #  - in this flow, special bind credentials are used to perform the",
            "            #    LDAP search",
            "            #  - in this flow, AUTH_LDAP_SEARCH must be set",
            "            if self.auth_ldap_bind_user:",
            "                # Bind with AUTH_LDAP_BIND_USER/AUTH_LDAP_BIND_PASSWORD",
            "                # (authorizes for LDAP search)",
            "                self._ldap_bind_indirect(ldap, con)",
            "",
            "                # Search for `username`",
            "                #  - returns the `user_dn` needed for binding to validate credentials",
            "                #  - returns the `user_attributes` needed for",
            "                #    AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "                else:",
            "                    log.error(",
            "                        \"AUTH_LDAP_SEARCH must be set when using AUTH_LDAP_BIND_USER\"",
            "                    )",
            "                    return None",
            "",
            "                # If search failed, go away",
            "                if user_dn is None:",
            "                    log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ, username)",
            "                    return None",
            "",
            "                # Bind with user_dn/password (validates credentials)",
            "                if not self._ldap_bind(ldap, con, user_dn, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "                    return None",
            "",
            "            # Flow 2 - (Direct Search Bind):",
            "            #  - in this flow, the credentials provided by the end-user are used",
            "            #    to perform the LDAP search",
            "            #  - in this flow, we only search LDAP if AUTH_LDAP_SEARCH is set",
            "            #     - features like AUTH_USER_REGISTRATION & AUTH_ROLES_SYNC_AT_LOGIN",
            "            #       will only work if AUTH_LDAP_SEARCH is set",
            "            else:",
            "                # Copy the provided username (so we can apply formatters)",
            "                bind_username = username",
            "",
            "                # update `bind_username` by applying AUTH_LDAP_APPEND_DOMAIN",
            "                #  - for Microsoft AD, which allows binding with userPrincipalName",
            "                if self.auth_ldap_append_domain:",
            "                    bind_username = bind_username + \"@\" + self.auth_ldap_append_domain",
            "",
            "                # Update `bind_username` by applying AUTH_LDAP_USERNAME_FORMAT",
            "                #  - for transforming the username into a DN,",
            "                #    for example: \"uid=%s,ou=example,o=test\"",
            "                if self.auth_ldap_username_format:",
            "                    bind_username = self.auth_ldap_username_format % bind_username",
            "",
            "                # Bind with bind_username/password",
            "                # (validates credentials & authorizes for LDAP search)",
            "                if not self._ldap_bind(ldap, con, bind_username, password):",
            "                    if user:",
            "                        self.update_user_auth_stat(user, False)",
            "",
            "                    # Invalid credentials, go away",
            "                    log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, bind_username)",
            "                    return None",
            "",
            "                # Search for `username` (if AUTH_LDAP_SEARCH is set)",
            "                #  - returns the `user_attributes`",
            "                #    needed for AUTH_USER_REGISTRATION/AUTH_ROLES_SYNC_AT_LOGIN",
            "                #  - we search on `username` not `bind_username`,",
            "                #    because AUTH_LDAP_APPEND_DOMAIN and AUTH_LDAP_USERNAME_FORMAT",
            "                #    would result in an invalid search filter",
            "                if self.auth_ldap_search:",
            "                    user_dn, user_attributes = self._search_ldap(ldap, con, username)",
            "",
            "                    # If search failed, go away",
            "                    if user_dn is None:",
            "                        log.info(LOGMSG_WAR_SEC_NOLDAP_OBJ, username)",
            "                        return None",
            "",
            "            # Sync the user's roles",
            "            if user and user_attributes and self.auth_roles_sync_at_login:",
            "                user.roles = self._ldap_calculate_user_roles(user_attributes)",
            "                log.debug(",
            "                    \"Calculated new roles for user='%s' as: %s\", user_dn, user.roles",
            "                )",
            "",
            "            # If the user is new, register them",
            "            if (not user) and user_attributes and self.auth_user_registration:",
            "                user = self.add_user(",
            "                    username=username,",
            "                    first_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_firstname_field, \"\"",
            "                    ),",
            "                    last_name=self.ldap_extract(",
            "                        user_attributes, self.auth_ldap_lastname_field, \"\"",
            "                    ),",
            "                    email=self.ldap_extract(",
            "                        user_attributes,",
            "                        self.auth_ldap_email_field,",
            "                        f\"{username}@email.notfound\",",
            "                    ),",
            "                    role=self._ldap_calculate_user_roles(user_attributes),",
            "                )",
            "                log.debug(\"New user registered: %s\", user)",
            "",
            "                # If user registration failed, go away",
            "                if not user:",
            "                    log.info(LOGMSG_ERR_SEC_ADD_REGISTER_USER, username)",
            "                    return None",
            "",
            "            # LOGIN SUCCESS (only if user is now registered)",
            "            if user:",
            "                self.update_user_auth_stat(user)",
            "                return user",
            "            else:",
            "                return None",
            "",
            "        except ldap.LDAPError as e:",
            "            msg = None",
            "            if isinstance(e, dict):",
            "                msg = getattr(e, \"message\", None)",
            "            if (msg is not None) and (\"desc\" in msg):",
            "                log.error(LOGMSG_ERR_SEC_AUTH_LDAP, e.message[\"desc\"])",
            "                return None",
            "            else:",
            "                log.error(e)",
            "                return None",
            "",
            "    def auth_user_oid(self, email):",
            "        \"\"\"",
            "        OpenID user Authentication",
            "",
            "        :param email: user's email to authenticate",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(email=email)",
            "        if user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, email)",
            "            return None",
            "        else:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "",
            "    def auth_user_remote_user(self, username):",
            "        \"\"\"",
            "        REMOTE_USER user Authentication",
            "",
            "        :param username: user's username for remote auth",
            "        :type self: User model",
            "        \"\"\"",
            "        user = self.find_user(username=username)",
            "",
            "        # User does not exist, create one if auto user registration.",
            "        if user is None and self.auth_user_registration:",
            "            user = self.add_user(",
            "                # All we have is REMOTE_USER, so we set",
            "                # the other fields to blank.",
            "                username=username,",
            "                first_name=username,",
            "                last_name=\"-\",",
            "                email=username + \"@email.notfound\",",
            "                role=self.find_role(self.auth_user_registration_role),",
            "            )",
            "",
            "        # If user does not exist on the DB and not auto user registration,",
            "        # or user is inactive, go away.",
            "        elif user is None or (not user.is_active):",
            "            log.info(LOGMSG_WAR_SEC_LOGIN_FAILED, username)",
            "            return None",
            "",
            "        self.update_user_auth_stat(user)",
            "        return user",
            "",
            "    def _oauth_calculate_user_roles(self, userinfo) -> List[str]:",
            "        user_role_objects = set()",
            "",
            "        # apply AUTH_ROLES_MAPPING",
            "        if len(self.auth_roles_mapping) > 0:",
            "            user_role_keys = userinfo.get(\"role_keys\", [])",
            "            user_role_objects.update(self.get_roles_from_keys(user_role_keys))",
            "",
            "        # apply AUTH_USER_REGISTRATION_ROLE",
            "        if self.auth_user_registration:",
            "            registration_role_name = self.auth_user_registration_role",
            "",
            "            # if AUTH_USER_REGISTRATION_ROLE_JMESPATH is set,",
            "            # use it for the registration role",
            "            if self.auth_user_registration_role_jmespath:",
            "                import jmespath",
            "",
            "                registration_role_name = jmespath.search(",
            "                    self.auth_user_registration_role_jmespath, userinfo",
            "                )",
            "",
            "            # lookup registration role in flask db",
            "            fab_role = self.find_role(registration_role_name)",
            "            if fab_role:",
            "                user_role_objects.add(fab_role)",
            "            else:",
            "                log.warning(",
            "                    \"Can't find AUTH_USER_REGISTRATION role: %s\", registration_role_name",
            "                )",
            "",
            "        return list(user_role_objects)",
            "",
            "    def auth_user_oauth(self, userinfo):",
            "        \"\"\"",
            "        Method for authenticating user with OAuth.",
            "",
            "        :userinfo: dict with user information",
            "                   (keys are the same as User model columns)",
            "        \"\"\"",
            "        # extract the username from `userinfo`",
            "        if \"username\" in userinfo:",
            "            username = userinfo[\"username\"]",
            "        elif \"email\" in userinfo:",
            "            username = userinfo[\"email\"]",
            "        else:",
            "            log.error(\"OAUTH userinfo does not have username or email %s\", userinfo)",
            "            return None",
            "",
            "        # If username is empty, go away",
            "        if (username is None) or username == \"\":",
            "            return None",
            "",
            "        # Search the DB for this user",
            "        user = self.find_user(username=username)",
            "",
            "        # If user is not active, go away",
            "        if user and (not user.is_active):",
            "            return None",
            "",
            "        # If user is not registered, and not self-registration, go away",
            "        if (not user) and (not self.auth_user_registration):",
            "            return None",
            "",
            "        # Sync the user's roles",
            "        if user and self.auth_roles_sync_at_login:",
            "            user.roles = self._oauth_calculate_user_roles(userinfo)",
            "            log.debug(\"Calculated new roles for user='%s' as: %s\", username, user.roles)",
            "",
            "        # If the user is new, register them",
            "        if (not user) and self.auth_user_registration:",
            "            user = self.add_user(",
            "                username=username,",
            "                first_name=userinfo.get(\"first_name\", \"\"),",
            "                last_name=userinfo.get(\"last_name\", \"\"),",
            "                email=userinfo.get(\"email\", \"\") or f\"{username}@email.notfound\",",
            "                role=self._oauth_calculate_user_roles(userinfo),",
            "            )",
            "            log.debug(\"New user registered: %s\", user)",
            "",
            "            # If user registration failed, go away",
            "            if not user:",
            "                log.error(\"Error creating a new OAuth user %s\", username)",
            "                return None",
            "",
            "        # LOGIN SUCCESS (only if user is now registered)",
            "        if user:",
            "            self.update_user_auth_stat(user)",
            "            return user",
            "        else:",
            "            return None",
            "",
            "    \"\"\"",
            "        ----------------------------------------",
            "            PERMISSION ACCESS CHECK",
            "        ----------------------------------------",
            "    \"\"\"",
            "",
            "    def is_item_public(self, permission_name, view_name):",
            "        \"\"\"",
            "        Check if view has public permissions",
            "",
            "        :param permission_name:",
            "            the permission: can_show, can_edit...",
            "        :param view_name:",
            "            the name of the class view (child of BaseView)",
            "        \"\"\"",
            "        permissions = self.get_public_permissions()",
            "        if permissions:",
            "            for i in permissions:",
            "                if (view_name == i.view_menu.name) and (",
            "                    permission_name == i.permission.name",
            "                ):",
            "                    return True",
            "            return False",
            "        else:",
            "            return False",
            "",
            "    def _has_access_builtin_roles(",
            "        self, role, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        \"\"\"",
            "        Checks permission on builtin role",
            "        \"\"\"",
            "        builtin_pvms = self.builtin_roles.get(role.name, [])",
            "        for pvm in builtin_pvms:",
            "            _view_name = pvm[0]",
            "            _permission_name = pvm[1]",
            "            if re.match(_view_name, view_name) and re.match(",
            "                _permission_name, permission_name",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def _has_view_access(",
            "        self, user: object, permission_name: str, view_name: str",
            "    ) -> bool:",
            "        roles = user.roles",
            "        db_role_ids = list()",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                if self._has_access_builtin_roles(role, permission_name, view_name):",
            "                    return True",
            "            else:",
            "                db_role_ids.append(role.id)",
            "",
            "        # If it's not a builtin role check against database store roles",
            "        return self.exist_permission_on_roles(view_name, permission_name, db_role_ids)",
            "",
            "    def get_oid_identity_url(self, provider_name: str) -> Optional[str]:",
            "        \"\"\"",
            "        Returns the OIDC identity provider URL",
            "        \"\"\"",
            "        for provider in self.openid_providers:",
            "            if provider.get(\"name\") == provider_name:",
            "                return provider.get(\"url\")",
            "",
            "    def get_user_roles(self, user) -> List[object]:",
            "        \"\"\"",
            "        Get current user roles, if user is not authenticated returns the public role",
            "        \"\"\"",
            "        if not user.is_authenticated:",
            "            return [self.get_public_role()]",
            "        return user.roles",
            "",
            "    def get_user_roles_permissions(self, user) -> Dict[str, List[Tuple[str, str]]]:",
            "        \"\"\"",
            "        Utility method just implemented for SQLAlchemy.",
            "        Take a look to: flask_appbuilder.security.sqla.manager",
            "        :param user:",
            "        :return:",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def get_role_permissions(self, role) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions for a certain role",
            "        \"\"\"",
            "        result = set()",
            "        if role.name in self.builtin_roles:",
            "            for permission in self.builtin_roles[role.name]:",
            "                result.add((permission[1], permission[0]))",
            "        else:",
            "            for permission in self.get_db_role_permissions(role.id):",
            "                result.add((permission.permission.name, permission.view_menu.name))",
            "        return result",
            "",
            "    def get_user_permissions(self, user) -> Set[Tuple[str, str]]:",
            "        \"\"\"",
            "        Get all permissions from the current user",
            "        \"\"\"",
            "        roles = self.get_user_roles(user)",
            "        result = set()",
            "        for role in roles:",
            "            result.update(self.get_role_permissions(role))",
            "        return result",
            "",
            "    def _get_user_permission_view_menus(",
            "        self, user: object, permission_name: str, view_menus_name: List[str]",
            "    ) -> Set[str]:",
            "        \"\"\"",
            "        Return a set of view menu names with a certain permission name",
            "        that a user has access to. Mainly used to fetch all menu permissions",
            "        on a single db call, will also check public permissions and builtin roles",
            "        \"\"\"",
            "        db_role_ids = list()",
            "        if user is None:",
            "            # include public role",
            "            roles = [self.get_public_role()]",
            "        else:",
            "            roles = user.roles",
            "        # First check against builtin (statically configured) roles",
            "        # because no database query is needed",
            "        result = set()",
            "        for role in roles:",
            "            if role.name in self.builtin_roles:",
            "                for view_menu_name in view_menus_name:",
            "                    if self._has_access_builtin_roles(",
            "                        role, permission_name, view_menu_name",
            "                    ):",
            "                        result.add(view_menu_name)",
            "            else:",
            "                db_role_ids.append(role.id)",
            "        # Then check against database-stored roles",
            "        pvms_names = [",
            "            pvm.view_menu.name",
            "            for pvm in self.find_roles_permission_view_menus(",
            "                permission_name, db_role_ids",
            "            )",
            "        ]",
            "        result.update(pvms_names)",
            "        return result",
            "",
            "    def has_access(self, permission_name: str, view_name: str) -> bool:",
            "        \"\"\"",
            "        Check if current user or public has access to view or menu",
            "        \"\"\"",
            "        if current_user.is_authenticated:",
            "            return self._has_view_access(g.user, permission_name, view_name)",
            "        elif current_user_jwt:",
            "            return self._has_view_access(current_user_jwt, permission_name, view_name)",
            "        else:",
            "            return self.is_item_public(permission_name, view_name)",
            "",
            "    def get_user_menu_access(self, menu_names: List[str] = None) -> Set[str]:",
            "        if current_user.is_authenticated:",
            "            return self._get_user_permission_view_menus(",
            "                g.user, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        elif current_user_jwt:",
            "            return self._get_user_permission_view_menus(",
            "                current_user_jwt, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "        else:",
            "            return self._get_user_permission_view_menus(",
            "                None, \"menu_access\", view_menus_name=menu_names",
            "            )",
            "",
            "    def add_limit_view(self, baseview):",
            "        if not baseview.limits:",
            "            return",
            "",
            "        for limit in baseview.limits:",
            "            self.limiter.limit(",
            "                limit_value=limit.limit_value,",
            "                key_func=limit.key_func,",
            "                per_method=limit.per_method,",
            "                methods=limit.methods,",
            "                error_message=limit.error_message,",
            "                exempt_when=limit.exempt_when,",
            "                override_defaults=limit.override_defaults,",
            "                deduct_when=limit.deduct_when,",
            "                on_breach=limit.on_breach,",
            "                cost=limit.cost,",
            "            )(baseview.blueprint)",
            "",
            "    def add_permissions_view(self, base_permissions, view_menu):",
            "        \"\"\"",
            "        Adds a permission on a view menu to the backend",
            "",
            "        :param base_permissions:",
            "            list of permissions from view (all exposed methods):",
            "             'can_add','can_edit' etc...",
            "        :param view_menu:",
            "            name of the view or menu to add",
            "        \"\"\"",
            "        view_menu_db = self.add_view_menu(view_menu)",
            "        perm_views = self.find_permissions_view_menu(view_menu_db)",
            "",
            "        if not perm_views:",
            "            # No permissions yet on this view",
            "            for permission in base_permissions:",
            "                pv = self.add_permission_view_menu(permission, view_menu)",
            "                if self.auth_role_admin not in self.builtin_roles:",
            "                    role_admin = self.find_role(self.auth_role_admin)",
            "                    self.add_permission_role(role_admin, pv)",
            "        else:",
            "            # Permissions on this view exist but....",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            for permission in base_permissions:",
            "                # Check if base view permissions exist",
            "                if not self.exist_permission_on_views(perm_views, permission):",
            "                    pv = self.add_permission_view_menu(permission, view_menu)",
            "                    if self.auth_role_admin not in self.builtin_roles:",
            "                        self.add_permission_role(role_admin, pv)",
            "            for perm_view in perm_views:",
            "                if perm_view.permission is None:",
            "                    # Skip this perm_view, it has a null permission",
            "                    continue",
            "                if perm_view.permission.name not in base_permissions:",
            "                    # perm to delete",
            "                    roles = self.get_all_roles()",
            "                    perm = self.find_permission(perm_view.permission.name)",
            "                    # del permission from all roles",
            "                    for role in roles:",
            "                        self.del_permission_role(role, perm)",
            "                    self.del_permission_view_menu(perm_view.permission.name, view_menu)",
            "                elif (",
            "                    self.auth_role_admin not in self.builtin_roles",
            "                    and perm_view not in role_admin.permissions",
            "                ):",
            "                    # Role Admin must have all permissions",
            "                    self.add_permission_role(role_admin, perm_view)",
            "",
            "    def add_permissions_menu(self, view_menu_name):",
            "        \"\"\"",
            "        Adds menu_access to menu on permission_view_menu",
            "",
            "        :param view_menu_name:",
            "            The menu name",
            "        \"\"\"",
            "        self.add_view_menu(view_menu_name)",
            "        pv = self.find_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if not pv:",
            "            pv = self.add_permission_view_menu(\"menu_access\", view_menu_name)",
            "        if self.auth_role_admin not in self.builtin_roles:",
            "            role_admin = self.find_role(self.auth_role_admin)",
            "            self.add_permission_role(role_admin, pv)",
            "",
            "    def security_cleanup(self, baseviews, menus):",
            "        \"\"\"",
            "        Will cleanup all unused permissions from the database",
            "",
            "        :param baseviews: A list of BaseViews class",
            "        :param menus: Menu class",
            "        \"\"\"",
            "        viewsmenus = self.get_all_view_menu()",
            "        roles = self.get_all_roles()",
            "        for viewmenu in viewsmenus:",
            "            found = False",
            "            for baseview in baseviews:",
            "                if viewmenu.name == baseview.class_permission_name:",
            "                    found = True",
            "                    break",
            "            if menus.find(viewmenu.name):",
            "                found = True",
            "            if not found:",
            "                permissions = self.find_permissions_view_menu(viewmenu)",
            "                for permission in permissions:",
            "                    for role in roles:",
            "                        self.del_permission_role(role, permission)",
            "                    self.del_permission_view_menu(",
            "                        permission.permission.name, viewmenu.name",
            "                    )",
            "                self.del_view_menu(viewmenu.name)",
            "        self.security_converge(baseviews, menus)",
            "",
            "    @staticmethod",
            "    def _get_new_old_permissions(baseview) -> Dict:",
            "        ret = dict()",
            "        for method_name, permission_name in baseview.method_permission_name.items():",
            "            old_permission_name = baseview.previous_method_permission_name.get(",
            "                method_name",
            "            )",
            "            # Actions do not get prefix when normally defined",
            "            if hasattr(baseview, \"actions\") and baseview.actions.get(",
            "                old_permission_name",
            "            ):",
            "                permission_prefix = \"\"",
            "            else:",
            "                permission_prefix = PERMISSION_PREFIX",
            "            if old_permission_name:",
            "                if PERMISSION_PREFIX + permission_name not in ret:",
            "                    ret[PERMISSION_PREFIX + permission_name] = {",
            "                        permission_prefix + old_permission_name",
            "                    }",
            "                else:",
            "                    ret[PERMISSION_PREFIX + permission_name].add(",
            "                        permission_prefix + old_permission_name",
            "                    )",
            "        return ret",
            "",
            "    @staticmethod",
            "    def _add_state_transition(",
            "        state_transition: Dict,",
            "        old_view_name: str,",
            "        old_perm_name: str,",
            "        view_name: str,",
            "        perm_name: str,",
            "    ) -> None:",
            "        old_pvm = state_transition[\"add\"].get((old_view_name, old_perm_name))",
            "        if old_pvm:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)].add(",
            "                (view_name, perm_name)",
            "            )",
            "        else:",
            "            state_transition[\"add\"][(old_view_name, old_perm_name)] = {",
            "                (view_name, perm_name)",
            "            }",
            "        state_transition[\"del_role_pvm\"].add((old_view_name, old_perm_name))",
            "        state_transition[\"del_views\"].add(old_view_name)",
            "        state_transition[\"del_perms\"].add(old_perm_name)",
            "",
            "    @staticmethod",
            "    def _update_del_transitions(state_transitions: Dict, baseviews: List) -> None:",
            "        \"\"\"",
            "        Mutates state_transitions, loop baseviews and prunes all",
            "        views and permissions that are not to delete because references",
            "        exist.",
            "",
            "        :param baseview:",
            "        :param state_transitions:",
            "        :return:",
            "        \"\"\"",
            "        for baseview in baseviews:",
            "            state_transitions[\"del_views\"].discard(baseview.class_permission_name)",
            "            for permission in baseview.base_permissions:",
            "                state_transitions[\"del_role_pvm\"].discard(",
            "                    (baseview.class_permission_name, permission)",
            "                )",
            "                state_transitions[\"del_perms\"].discard(permission)",
            "",
            "    def create_state_transitions(",
            "        self, baseviews: List, menus: Optional[List[Any]]",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Creates a Dict with all the necessary vm/permission transitions",
            "",
            "        Dict: {",
            "                \"add\": {(<VM>, <PERM>): ((<VM>, PERM), ... )}",
            "                \"del_role_pvm\": ((<VM>, <PERM>), ...)",
            "                \"del_views\": (<VM>, ... )",
            "                \"del_perms\": (<PERM>, ... )",
            "              }",
            "",
            "        :param baseviews: List with all the registered BaseView, BaseApi",
            "        :param menus: List with all the menu entries",
            "        :return: Dict with state transitions",
            "        \"\"\"",
            "        state_transitions = {",
            "            \"add\": {},",
            "            \"del_role_pvm\": set(),",
            "            \"del_views\": set(),",
            "            \"del_perms\": set(),",
            "        }",
            "        for baseview in baseviews:",
            "            add_all_flag = False",
            "            new_view_name = baseview.class_permission_name",
            "            permission_mapping = self._get_new_old_permissions(baseview)",
            "            if baseview.previous_class_permission_name:",
            "                old_view_name = baseview.previous_class_permission_name",
            "                add_all_flag = True",
            "            else:",
            "                new_view_name = baseview.class_permission_name",
            "                old_view_name = new_view_name",
            "            for new_perm_name in baseview.base_permissions:",
            "                if add_all_flag:",
            "                    old_perm_names = permission_mapping.get(new_perm_name)",
            "                    old_perm_names = old_perm_names or (new_perm_name,)",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "                else:",
            "                    old_perm_names = permission_mapping.get(new_perm_name) or set()",
            "                    for old_perm_name in old_perm_names:",
            "                        self._add_state_transition(",
            "                            state_transitions,",
            "                            old_view_name,",
            "                            old_perm_name,",
            "                            new_view_name,",
            "                            new_perm_name,",
            "                        )",
            "        self._update_del_transitions(state_transitions, baseviews)",
            "        return state_transitions",
            "",
            "    def security_converge(",
            "        self, baseviews: List, menus: Optional[List[Any]], dry=False",
            "    ) -> Dict:",
            "        \"\"\"",
            "        Converges overridden permissions on all registered views/api",
            "        will compute all necessary operations from `class_permissions_name`,",
            "        `previous_class_permission_name`, method_permission_name`,",
            "        `previous_method_permission_name` class attributes.",
            "",
            "        :param baseviews: List of registered views/apis",
            "        :param menus: List of menu items",
            "        :param dry: If True will not change DB",
            "        :return: Dict with the necessary operations (state_transitions)",
            "        \"\"\"",
            "        state_transitions = self.create_state_transitions(baseviews, menus)",
            "        if dry:",
            "            return state_transitions",
            "        if not state_transitions:",
            "            log.info(\"No state transitions found\")",
            "            return dict()",
            "        log.debug(\"State transitions: %s\", state_transitions)",
            "        roles = self.get_all_roles()",
            "        for role in roles:",
            "            permissions = list(role.permissions)",
            "            for pvm in permissions:",
            "                new_pvm_states = state_transitions[\"add\"].get(",
            "                    (pvm.view_menu.name, pvm.permission.name)",
            "                )",
            "                if not new_pvm_states:",
            "                    continue",
            "                for new_pvm_state in new_pvm_states:",
            "                    new_pvm = self.add_permission_view_menu(",
            "                        new_pvm_state[1], new_pvm_state[0]",
            "                    )",
            "                    self.add_permission_role(role, new_pvm)",
            "                if (pvm.view_menu.name, pvm.permission.name) in state_transitions[",
            "                    \"del_role_pvm\"",
            "                ]:",
            "                    self.del_permission_role(role, pvm)",
            "        for pvm in state_transitions[\"del_role_pvm\"]:",
            "            self.del_permission_view_menu(pvm[1], pvm[0], cascade=False)",
            "        for view_name in state_transitions[\"del_views\"]:",
            "            self.del_view_menu(view_name)",
            "        for permission_name in state_transitions[\"del_perms\"]:",
            "            self.del_permission(permission_name)",
            "        return state_transitions",
            "",
            "    \"\"\"",
            "     ---------------------------",
            "     INTERFACE ABSTRACT METHODS",
            "     ---------------------------",
            "",
            "     ---------------------",
            "     PRIMITIVES FOR USERS",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_register_user(self, registration_hash):",
            "        \"\"\"",
            "        Generic function to return user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_register_user(",
            "        self, username, first_name, last_name, email, password=\"\", hashed_password=\"\"",
            "    ):",
            "        \"\"\"",
            "        Generic function to add user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_register_user(self, register_user):",
            "        \"\"\"",
            "        Generic function to delete user registration",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_user_by_id(self, pk):",
            "        \"\"\"",
            "        Generic function to return user by it's id (pk)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_user(self, username=None, email=None):",
            "        \"\"\"",
            "        Generic function find a user by it's username or email",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_users(self):",
            "        \"\"\"",
            "        Generic function that returns all existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_db_role_permissions(self, role_id: int) -> List[object]:",
            "        \"\"\"",
            "        Get all DB permissions from a role id",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_user(self, username, first_name, last_name, email, role, password=\"\"):",
            "        \"\"\"",
            "        Generic function to create user",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def update_user(self, user):",
            "        \"\"\"",
            "        Generic function to update user",
            "",
            "        :param user: User model to update to database",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def count_users(self):",
            "        \"\"\"",
            "        Generic function to count the existing users",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES FOR ROLES",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_role(self, name):",
            "        raise NotImplementedError",
            "",
            "    def add_role(self, name, permissions=None):",
            "        raise NotImplementedError",
            "",
            "    def update_role(self, pk, name):",
            "        raise NotImplementedError",
            "",
            "    def get_all_roles(self):",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------------",
            "     PRIMITIVES FOR PERMISSIONS",
            "    ----------------------------",
            "    \"\"\"",
            "",
            "    def get_public_role(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_public_permissions(self):",
            "        \"\"\"",
            "        returns all permissions from public role",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permission(self, name):",
            "        \"\"\"",
            "        Finds and returns a Permission by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_roles_permission_view_menus(",
            "        self, permission_name: str, role_ids: List[int]",
            "    ):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_roles(",
            "        self, view_name: str, permission_name: str, role_ids: List[int]",
            "    ) -> bool:",
            "        \"\"\"",
            "        Finds and returns permission views for a group of roles",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission(self, name):",
            "        \"\"\"",
            "        Adds a permission to the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission(self, name):",
            "        \"\"\"",
            "        Deletes a permission from the backend, model permission",
            "",
            "        :param name:",
            "            name of the permission: 'can_add','can_edit' etc...",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PRIMITIVES VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_view_menu(self, name):",
            "        \"\"\"",
            "        Finds and returns a ViewMenu by name",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def get_all_view_menu(self):",
            "        raise NotImplementedError",
            "",
            "    def add_view_menu(self, name):",
            "        \"\"\"",
            "        Adds a view or menu to the backend, model view_menu",
            "        param name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_view_menu(self, name):",
            "        \"\"\"",
            "        Deletes a ViewMenu from the backend",
            "",
            "        :param name:",
            "            name of the ViewMenu",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    \"\"\"",
            "    ----------------------",
            "     PERMISSION VIEW MENU",
            "    ----------------------",
            "    \"\"\"",
            "",
            "    def find_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Finds and returns a PermissionView by names",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_permissions_view_menu(self, view_menu):",
            "        \"\"\"",
            "        Finds all permissions from ViewMenu, returns list of PermissionView",
            "",
            "        :param view_menu: ViewMenu object",
            "        :return: list of PermissionView objects",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_permission_view_menu(self, permission_name, view_menu_name):",
            "        \"\"\"",
            "        Adds a permission on a view or menu to the backend",
            "",
            "        :param permission_name:",
            "            name of the permission to add: 'can_add','can_edit' etc...",
            "        :param view_menu_name:",
            "            name of the view menu to add",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_view_menu(self, permission_name, view_menu_name, cascade=True):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_views(self, lst, item):",
            "        raise NotImplementedError",
            "",
            "    def exist_permission_on_view(self, lst, permission, view_menu):",
            "        raise NotImplementedError",
            "",
            "    def add_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Add permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def del_permission_role(self, role, perm_view):",
            "        \"\"\"",
            "        Remove permission-ViewMenu object to Role",
            "",
            "        :param role:",
            "            The role object",
            "        :param perm_view:",
            "            The PermissionViewMenu object",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def export_roles(",
            "        self, path: Optional[str] = None, indent: Optional[Union[int, str]] = None",
            "    ) -> None:",
            "        \"\"\"Exports roles to JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def import_roles(self, path: str) -> None:",
            "        \"\"\"Imports roles from JSON file.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_user(self, pk):",
            "        return self.get_user_by_id(int(pk))",
            "",
            "    def load_user_jwt(self, _jwt_header, jwt_data):",
            "        identity = jwt_data[\"sub\"]",
            "        user = self.load_user(identity)",
            "        # Set flask g.user to JWT user, we can't do it on before request",
            "        g.user = user",
            "        return user",
            "",
            "    @staticmethod",
            "    def before_request():",
            "        g.user = current_user"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "flask_appbuilder/security/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "             form = LoginForm_oid()"
            },
            "1": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "             if form.validate_on_submit():"
            },
            "2": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 567,
                "PatchRowcode": "                 session[\"remember_me\"] = form.remember_me.data"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+                identity_url = self.appbuilder.sm.get_oid_identity_url(form.openid.data)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+                if identity_url is None:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+                    flash(as_unicode(self.invalid_login_message), \"warning\")"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+                    return redirect(self.appbuilder.get_url_for_login)"
            },
            "7": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "                 return self.appbuilder.sm.oid.try_login("
            },
            "8": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    form.openid.data,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 573,
                "PatchRowcode": "+                    identity_url,"
            },
            "10": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "                     ask_for=self.oid_ask_for,"
            },
            "11": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "                     ask_for_optional=self.oid_ask_for_optional,"
            },
            "12": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": 576,
                "PatchRowcode": "                 )"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import logging",
            "import re",
            "from typing import Any, List, Optional",
            "",
            "from flask import abort, current_app, flash, g, redirect, request, session, url_for",
            "from flask_appbuilder._compat import as_unicode",
            "from flask_appbuilder.actions import action",
            "from flask_appbuilder.baseviews import BaseView",
            "from flask_appbuilder.charts.views import DirectByChartView",
            "from flask_appbuilder.fieldwidgets import BS3PasswordFieldWidget",
            "from flask_appbuilder.security.decorators import has_access",
            "from flask_appbuilder.security.forms import (",
            "    DynamicForm,",
            "    LoginForm_db,",
            "    LoginForm_oid,",
            "    ResetPasswordForm,",
            "    SelectDataRequired,",
            "    UserInfoEdit,",
            ")",
            "from flask_appbuilder.security.utils import generate_random_string",
            "from flask_appbuilder.utils.base import get_safe_redirect, lazy_formatter_gettext",
            "from flask_appbuilder.validators import PasswordComplexityValidator",
            "from flask_appbuilder.views import expose, ModelView, SimpleFormView",
            "from flask_appbuilder.widgets import ListWidget, ShowWidget",
            "from flask_babel import lazy_gettext",
            "from flask_login import login_user, logout_user",
            "import jwt",
            "from werkzeug.security import generate_password_hash",
            "from werkzeug.wrappers import Response as WerkzeugResponse",
            "from wtforms import PasswordField, validators",
            "from wtforms.validators import EqualTo",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class PermissionModelView(ModelView):",
            "    route_base = \"/permissions\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List Base Permissions\")",
            "    show_title = lazy_gettext(\"Show Base Permission\")",
            "    add_title = lazy_gettext(\"Add Base Permission\")",
            "    edit_title = lazy_gettext(\"Edit Base Permission\")",
            "",
            "    label_columns = {\"name\": lazy_gettext(\"Name\")}",
            "",
            "",
            "class ViewMenuModelView(ModelView):",
            "    route_base = \"/viewmenus\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List View Menus\")",
            "    show_title = lazy_gettext(\"Show View Menu\")",
            "    add_title = lazy_gettext(\"Add View Menu\")",
            "    edit_title = lazy_gettext(\"Edit View Menu\")",
            "",
            "    label_columns = {\"name\": lazy_gettext(\"Name\")}",
            "",
            "",
            "class PermissionViewModelView(ModelView):",
            "    route_base = \"/permissionviews\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List Permissions on Views/Menus\")",
            "    show_title = lazy_gettext(\"Show Permission on Views/Menus\")",
            "    add_title = lazy_gettext(\"Add Permission on Views/Menus\")",
            "    edit_title = lazy_gettext(\"Edit Permission on Views/Menus\")",
            "",
            "    label_columns = {",
            "        \"permission\": lazy_gettext(\"Permission\"),",
            "        \"view_menu\": lazy_gettext(\"View/Menu\"),",
            "    }",
            "    list_columns = [\"permission\", \"view_menu\"]",
            "",
            "",
            "class ResetMyPasswordView(SimpleFormView):",
            "    \"\"\"",
            "    View for resetting own user password",
            "    \"\"\"",
            "",
            "    route_base = \"/resetmypassword\"",
            "    form = ResetPasswordForm",
            "    form_title = lazy_gettext(\"Reset Password Form\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"Password Changed\")",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        self.appbuilder.sm.reset_password(g.user.id, form.password.data)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "class ResetPasswordView(SimpleFormView):",
            "    \"\"\"",
            "    View for reseting all users password",
            "    \"\"\"",
            "",
            "    route_base = \"/resetpassword\"",
            "    form = ResetPasswordForm",
            "    form_title = lazy_gettext(\"Reset Password Form\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"Password Changed\")",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        pk = request.args.get(\"pk\")",
            "        self.appbuilder.sm.reset_password(pk, form.password.data)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "class UserInfoEditView(SimpleFormView):",
            "    form = UserInfoEdit",
            "    form_title = lazy_gettext(\"Edit User Information\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"User information changed\")",
            "",
            "    def form_get(self, form: DynamicForm) -> None:",
            "        item = self.appbuilder.sm.get_user_by_id(g.user.id)",
            "        # fills the form generic solution",
            "        for key, value in form.data.items():",
            "            if key == \"csrf_token\":",
            "                continue",
            "            form_field = getattr(form, key)",
            "            form_field.data = getattr(item, key)",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        form = self.form.refresh(request.form)",
            "        item = self.appbuilder.sm.get_user_by_id(g.user.id)",
            "        form.populate_obj(item)",
            "        self.appbuilder.sm.update_user(item)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "def _roles_custom_formatter(string: str) -> str:",
            "    if current_app.config.get(\"AUTH_ROLES_SYNC_AT_LOGIN\", False):",
            "        string += (",
            "            \". <div class='alert alert-warning' role='alert'>\"",
            "            \"AUTH_ROLES_SYNC_AT_LOGIN is enabled, changes to this field will \"",
            "            \"not persist between user logins.\"",
            "            \"</div>\"",
            "        )",
            "    return string",
            "",
            "",
            "class UserModelView(ModelView):",
            "    route_base = \"/users\"",
            "",
            "    list_title = lazy_gettext(\"List Users\")",
            "    show_title = lazy_gettext(\"Show User\")",
            "    add_title = lazy_gettext(\"Add User\")",
            "    edit_title = lazy_gettext(\"Edit User\")",
            "",
            "    label_columns = {",
            "        \"get_full_name\": lazy_gettext(\"Full Name\"),",
            "        \"first_name\": lazy_gettext(\"First Name\"),",
            "        \"last_name\": lazy_gettext(\"Last Name\"),",
            "        \"username\": lazy_gettext(\"User Name\"),",
            "        \"password\": lazy_gettext(\"Password\"),",
            "        \"active\": lazy_gettext(\"Is Active?\"),",
            "        \"email\": lazy_gettext(\"Email\"),",
            "        \"roles\": lazy_gettext(\"Role\"),",
            "        \"last_login\": lazy_gettext(\"Last login\"),",
            "        \"login_count\": lazy_gettext(\"Login count\"),",
            "        \"fail_login_count\": lazy_gettext(\"Failed login count\"),",
            "        \"created_on\": lazy_gettext(\"Created on\"),",
            "        \"created_by\": lazy_gettext(\"Created by\"),",
            "        \"changed_on\": lazy_gettext(\"Changed on\"),",
            "        \"changed_by\": lazy_gettext(\"Changed by\"),",
            "    }",
            "",
            "    description_columns = {",
            "        \"first_name\": lazy_gettext(\"Write the user first name or names\"),",
            "        \"last_name\": lazy_gettext(\"Write the user last name\"),",
            "        \"username\": lazy_gettext(",
            "            \"Username valid for authentication on DB or LDAP, unused for OID auth\"",
            "        ),",
            "        \"password\": lazy_gettext(\"The user's password for authentication\"),",
            "        \"active\": lazy_gettext(",
            "            \"It's not a good policy to remove a user, just make it inactive\"",
            "        ),",
            "        \"email\": lazy_gettext(\"The user's email, this will also be used for OID auth\"),",
            "        \"roles\": lazy_formatter_gettext(",
            "            \"The user role on the application,\"",
            "            \" this will associate with a list of permissions\",",
            "            _roles_custom_formatter,",
            "        ),",
            "        \"conf_password\": lazy_gettext(\"Please rewrite the user's password to confirm\"),",
            "    }",
            "",
            "    list_columns = [\"first_name\", \"last_name\", \"username\", \"email\", \"active\", \"roles\"]",
            "",
            "    show_fieldsets = [",
            "        (",
            "            lazy_gettext(\"User info\"),",
            "            {\"fields\": [\"username\", \"active\", \"roles\", \"login_count\"]},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Personal Info\"),",
            "            {\"fields\": [\"first_name\", \"last_name\", \"email\"], \"expanded\": True},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Audit Info\"),",
            "            {",
            "                \"fields\": [",
            "                    \"last_login\",",
            "                    \"fail_login_count\",",
            "                    \"created_on\",",
            "                    \"created_by\",",
            "                    \"changed_on\",",
            "                    \"changed_by\",",
            "                ],",
            "                \"expanded\": False,",
            "            },",
            "        ),",
            "    ]",
            "",
            "    user_show_fieldsets = [",
            "        (",
            "            lazy_gettext(\"User info\"),",
            "            {\"fields\": [\"username\", \"active\", \"roles\", \"login_count\"]},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Personal Info\"),",
            "            {\"fields\": [\"first_name\", \"last_name\", \"email\"], \"expanded\": True},",
            "        ),",
            "    ]",
            "",
            "    search_exclude_columns = [\"password\"]",
            "",
            "    add_columns = [\"first_name\", \"last_name\", \"username\", \"active\", \"email\", \"roles\"]",
            "    edit_columns = [\"first_name\", \"last_name\", \"username\", \"active\", \"email\", \"roles\"]",
            "    user_info_title = lazy_gettext(\"Your user information\")",
            "",
            "    @expose(\"/userinfo/\")",
            "    @has_access",
            "    def userinfo(self) -> WerkzeugResponse:",
            "        item = self.datamodel.get(g.user.id, self._base_filters)",
            "        widgets = self._get_show_widget(",
            "            g.user.id, item, show_fieldsets=self.user_show_fieldsets",
            "        )",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            title=self.user_info_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "        )",
            "",
            "    @action(\"userinfoedit\", lazy_gettext(\"Edit User\"), \"\", \"fa-edit\", multiple=False)",
            "    def userinfoedit(self, item: Any) -> WerkzeugResponse:",
            "        return redirect(",
            "            url_for(self.appbuilder.sm.userinfoeditview.__name__ + \".this_form_get\")",
            "        )",
            "",
            "",
            "class UserOIDModelView(UserModelView):",
            "    \"\"\"",
            "    View that add OID specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override useroidmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserLDAPModelView(UserModelView):",
            "    \"\"\"",
            "    View that add LDAP specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserOAuthModelView(UserModelView):",
            "    \"\"\"",
            "    View that add OAUTH specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserRemoteUserModelView(UserModelView):",
            "    \"\"\"",
            "    View that add REMOTE_USER specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserDBModelView(UserModelView):",
            "    \"\"\"",
            "    View that add DB specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userdbmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    add_form_extra_fields = {",
            "        \"password\": PasswordField(",
            "            lazy_gettext(\"Password\"),",
            "            description=lazy_gettext(\"The user's password for authentication\"),",
            "            validators=[validators.DataRequired(), PasswordComplexityValidator()],",
            "            widget=BS3PasswordFieldWidget(),",
            "        ),",
            "        \"conf_password\": PasswordField(",
            "            lazy_gettext(\"Confirm Password\"),",
            "            description=lazy_gettext(\"Please rewrite the user's password to confirm\"),",
            "            validators=[",
            "                validators.DataRequired(),",
            "                EqualTo(\"password\", message=lazy_gettext(\"Passwords must match\")),",
            "            ],",
            "            widget=BS3PasswordFieldWidget(),",
            "        ),",
            "    }",
            "",
            "    add_columns = [",
            "        \"first_name\",",
            "        \"last_name\",",
            "        \"username\",",
            "        \"active\",",
            "        \"email\",",
            "        \"roles\",",
            "        \"password\",",
            "        \"conf_password\",",
            "    ]",
            "",
            "    validators_columns = {\"roles\": [SelectDataRequired()]}",
            "",
            "    @expose(\"/show/<pk>\", methods=[\"GET\"])",
            "    @has_access",
            "    def show(self, pk: Any) -> WerkzeugResponse:",
            "        actions = dict()",
            "        actions[\"resetpasswords\"] = self.actions.get(\"resetpasswords\")",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        widgets = self._get_show_widget(pk, item, actions=actions)",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            pk=pk,",
            "            title=self.show_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "            related_views=self._related_views,",
            "        )",
            "",
            "    @expose(\"/userinfo/\")",
            "    @has_access",
            "    def userinfo(self) -> WerkzeugResponse:",
            "        actions = dict()",
            "        actions[\"resetmypassword\"] = self.actions.get(\"resetmypassword\")",
            "        actions[\"userinfoedit\"] = self.actions.get(\"userinfoedit\")",
            "",
            "        item = self.datamodel.get(g.user.id, self._base_filters)",
            "        widgets = self._get_show_widget(",
            "            g.user.id, item, actions=actions, show_fieldsets=self.user_show_fieldsets",
            "        )",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            title=self.user_info_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "        )",
            "",
            "    @action(",
            "        \"resetmypassword\",",
            "        lazy_gettext(\"Reset my password\"),",
            "        \"\",",
            "        \"fa-lock\",",
            "        multiple=False,",
            "    )",
            "    def resetmypassword(self, item: Any):",
            "        return redirect(",
            "            url_for(self.appbuilder.sm.resetmypasswordview.__name__ + \".this_form_get\")",
            "        )",
            "",
            "    @action(",
            "        \"resetpasswords\", lazy_gettext(\"Reset Password\"), \"\", \"fa-lock\", multiple=False",
            "    )",
            "    def resetpasswords(self, item: Any) -> WerkzeugResponse:",
            "        return redirect(",
            "            url_for(",
            "                self.appbuilder.sm.resetpasswordview.__name__ + \".this_form_get\",",
            "                pk=item.id,",
            "            )",
            "        )",
            "",
            "    def pre_update(self, item: Any) -> None:",
            "        item.changed_on = datetime.datetime.now()",
            "        item.changed_by_fk = g.user.id",
            "",
            "    def pre_add(self, item: Any) -> None:",
            "        item.password = generate_password_hash(item.password)",
            "",
            "",
            "class UserStatsChartView(DirectByChartView):",
            "    chart_title = lazy_gettext(\"User Statistics\")",
            "    label_columns = {",
            "        \"username\": lazy_gettext(\"User Name\"),",
            "        \"login_count\": lazy_gettext(\"Login count\"),",
            "        \"fail_login_count\": lazy_gettext(\"Failed login count\"),",
            "    }",
            "",
            "    search_exclude_columns = UserModelView.search_exclude_columns",
            "",
            "    definitions = [",
            "        {\"label\": \"Login Count\", \"group\": \"username\", \"series\": [\"login_count\"]},",
            "        {",
            "            \"label\": \"Failed Login Count\",",
            "            \"group\": \"username\",",
            "            \"series\": [\"fail_login_count\"],",
            "        },",
            "    ]",
            "",
            "",
            "class RoleListWidget(ListWidget):",
            "    template = \"appbuilder/general/widgets/roles/list.html\"",
            "",
            "    def __init__(self, **kwargs):",
            "        kwargs[\"appbuilder\"] = current_app.appbuilder",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class RoleShowWidget(ShowWidget):",
            "    template = \"appbuilder/general/widgets/roles/show.html\"",
            "",
            "    def __init__(self, **kwargs):",
            "        kwargs[\"appbuilder\"] = current_app.appbuilder",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class RoleModelView(ModelView):",
            "    route_base = \"/roles\"",
            "",
            "    list_title = lazy_gettext(\"List Roles\")",
            "    show_title = lazy_gettext(\"Show Role\")",
            "    add_title = lazy_gettext(\"Add Role\")",
            "    edit_title = lazy_gettext(\"Edit Role\")",
            "",
            "    list_widget = RoleListWidget",
            "    show_widget = RoleShowWidget",
            "",
            "    label_columns = {",
            "        \"name\": lazy_gettext(\"Name\"),",
            "        \"permissions\": lazy_gettext(\"Permissions\"),",
            "    }",
            "    list_columns = [\"name\", \"permissions\"]",
            "    show_columns = [\"name\", \"permissions\"]",
            "    edit_columns = [\"name\", \"permissions\"]",
            "    add_columns = edit_columns",
            "    order_columns = [\"name\"]",
            "",
            "    @action(",
            "        \"copyrole\",",
            "        lazy_gettext(\"Copy Role\"),",
            "        lazy_gettext(\"Copy the selected roles?\"),",
            "        icon=\"fa-copy\",",
            "        single=False,",
            "    )",
            "    def copy_role(self, items):",
            "        self.update_redirect()",
            "        for item in items:",
            "            new_role = item.__class__()",
            "            new_role.name = item.name",
            "            new_role.permissions = item.permissions",
            "            new_role.name = new_role.name + \" copy\"",
            "            self.datamodel.add(new_role)",
            "        return redirect(self.get_redirect())",
            "",
            "",
            "class RegisterUserModelView(ModelView):",
            "    route_base = \"/registeruser\"",
            "    base_permissions = [\"can_list\", \"can_show\", \"can_delete\"]",
            "    list_title = lazy_gettext(\"List of Registration Requests\")",
            "    show_title = lazy_gettext(\"Show Registration\")",
            "    list_columns = [\"username\", \"registration_date\", \"email\"]",
            "    show_exclude_columns = [\"password\"]",
            "    search_exclude_columns = [\"password\"]",
            "",
            "",
            "class AuthView(BaseView):",
            "    route_base = \"\"",
            "    login_template = \"\"",
            "    invalid_login_message = lazy_gettext(\"Invalid login. Please try again.\")",
            "    title = lazy_gettext(\"Sign In\")",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        pass",
            "",
            "    @expose(\"/logout/\")",
            "    def logout(self):",
            "        logout_user()",
            "        return redirect(",
            "            self.appbuilder.app.config.get(",
            "                \"LOGOUT_REDIRECT_URL\", self.appbuilder.get_url_for_index",
            "            )",
            "        )",
            "",
            "",
            "class AuthDBView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_db.html\"",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        if g.user is not None and g.user.is_authenticated:",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "        form = LoginForm_db()",
            "        if form.validate_on_submit():",
            "            next_url = get_safe_redirect(request.args.get(\"next\", \"\"))",
            "            user = self.appbuilder.sm.auth_user_db(",
            "                form.username.data, form.password.data",
            "            )",
            "            if not user:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login_with(next_url))",
            "            login_user(user, remember=False)",
            "            return redirect(next_url)",
            "        return self.render_template(",
            "            self.login_template, title=self.title, form=form, appbuilder=self.appbuilder",
            "        )",
            "",
            "",
            "class AuthLDAPView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_ldap.html\"",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        if g.user is not None and g.user.is_authenticated:",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "        form = LoginForm_db()",
            "        if form.validate_on_submit():",
            "            next_url = get_safe_redirect(request.args.get(\"next\", \"\"))",
            "            user = self.appbuilder.sm.auth_user_ldap(",
            "                form.username.data, form.password.data",
            "            )",
            "            if not user:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login_with(next_url))",
            "            login_user(user, remember=False)",
            "            return redirect(next_url)",
            "        return self.render_template(",
            "            self.login_template, title=self.title, form=form, appbuilder=self.appbuilder",
            "        )",
            "",
            "",
            "class AuthOIDView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_oid.html\"",
            "    oid_ask_for = [\"email\"]",
            "    oid_ask_for_optional: List[str] = []",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self, flag=True) -> WerkzeugResponse:",
            "        @self.appbuilder.sm.oid.loginhandler",
            "        def login_handler(self):",
            "            if g.user is not None and g.user.is_authenticated:",
            "                return redirect(self.appbuilder.get_url_for_index)",
            "            form = LoginForm_oid()",
            "            if form.validate_on_submit():",
            "                session[\"remember_me\"] = form.remember_me.data",
            "                return self.appbuilder.sm.oid.try_login(",
            "                    form.openid.data,",
            "                    ask_for=self.oid_ask_for,",
            "                    ask_for_optional=self.oid_ask_for_optional,",
            "                )",
            "            return self.render_template(",
            "                self.login_template,",
            "                title=self.title,",
            "                form=form,",
            "                providers=self.appbuilder.sm.openid_providers,",
            "                appbuilder=self.appbuilder,",
            "            )",
            "",
            "        @self.appbuilder.sm.oid.after_login",
            "        def after_login(resp):",
            "            if resp.email is None or resp.email == \"\":",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "            user = self.appbuilder.sm.auth_user_oid(resp.email)",
            "            if user is None:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "            remember_me = False",
            "            if \"remember_me\" in session:",
            "                remember_me = session[\"remember_me\"]",
            "                session.pop(\"remember_me\", None)",
            "",
            "            login_user(user, remember=remember_me)",
            "            next_url = request.args.get(\"next\", \"\")",
            "            return redirect(get_safe_redirect(next_url))",
            "",
            "        return login_handler(self)",
            "",
            "",
            "class AuthOAuthView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_oauth.html\"",
            "",
            "    @expose(\"/login/\")",
            "    @expose(\"/login/<provider>\")",
            "    def login(self, provider: Optional[str] = None) -> WerkzeugResponse:",
            "        log.debug(\"Provider: %s\", provider)",
            "        if g.user is not None and g.user.is_authenticated:",
            "            log.debug(\"Already authenticated %s\", g.user)",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "",
            "        if provider is None:",
            "            return self.render_template(",
            "                self.login_template,",
            "                providers=self.appbuilder.sm.oauth_providers,",
            "                title=self.title,",
            "                appbuilder=self.appbuilder,",
            "            )",
            "",
            "        log.debug(\"Going to call authorize for: %s\", provider)",
            "        random_state = generate_random_string()",
            "        state = jwt.encode(",
            "            request.args.to_dict(flat=False), random_state, algorithm=\"HS256\"",
            "        )",
            "        session[\"oauth_state\"] = random_state",
            "        try:",
            "            if provider == \"twitter\":",
            "                return self.appbuilder.sm.oauth_remotes[provider].authorize_redirect(",
            "                    redirect_uri=url_for(",
            "                        \".oauth_authorized\",",
            "                        provider=provider,",
            "                        _external=True,",
            "                        state=state,",
            "                    )",
            "                )",
            "            else:",
            "                return self.appbuilder.sm.oauth_remotes[provider].authorize_redirect(",
            "                    redirect_uri=url_for(",
            "                        \".oauth_authorized\", provider=provider, _external=True",
            "                    ),",
            "                    state=state.decode(\"ascii\") if isinstance(state, bytes) else state,",
            "                )",
            "        except Exception as e:",
            "            log.error(\"Error on OAuth authorize: %s\", e)",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "",
            "    @expose(\"/oauth-authorized/<provider>\")",
            "    def oauth_authorized(self, provider: str) -> WerkzeugResponse:",
            "        log.debug(\"Authorized init\")",
            "        if provider not in self.appbuilder.sm.oauth_remotes:",
            "            flash(\"Provider not supported.\", \"warning\")",
            "            log.warning(\"OAuth authorized got an unknown provider %s\", provider)",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        try:",
            "            resp = self.appbuilder.sm.oauth_remotes[provider].authorize_access_token()",
            "        except Exception as e:",
            "            log.error(\"Error authorizing OAuth access token: %s\", e)",
            "            flash(\"The request to sign in was denied.\", \"error\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        if resp is None:",
            "            flash(\"You denied the request to sign in.\", \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        log.debug(\"OAUTH Authorized resp: %s\", resp)",
            "        # Retrieves specific user info from the provider",
            "        try:",
            "            self.appbuilder.sm.set_oauth_session(provider, resp)",
            "            userinfo = self.appbuilder.sm.oauth_user_info(provider, resp)",
            "        except Exception as e:",
            "            log.error(\"Error returning OAuth user info: %s\", e)",
            "            user = None",
            "        else:",
            "            log.debug(\"User info retrieved from %s: %s\", provider, userinfo)",
            "            # User email is not whitelisted",
            "            if provider in self.appbuilder.sm.oauth_whitelists:",
            "                whitelist = self.appbuilder.sm.oauth_whitelists[provider]",
            "                allow = False",
            "                for email in whitelist:",
            "                    if \"email\" in userinfo and re.search(email, userinfo[\"email\"]):",
            "                        allow = True",
            "                        break",
            "                if not allow:",
            "                    flash(\"You are not authorized.\", \"warning\")",
            "                    return redirect(self.appbuilder.get_url_for_login)",
            "            else:",
            "                log.debug(\"No whitelist for OAuth provider\")",
            "            user = self.appbuilder.sm.auth_user_oauth(userinfo)",
            "",
            "        if user is None:",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        else:",
            "            try:",
            "                state = jwt.decode(",
            "                    request.args[\"state\"], session[\"oauth_state\"], algorithms=[\"HS256\"]",
            "                )",
            "            except (jwt.InvalidTokenError, KeyError):",
            "                flash(as_unicode(\"Invalid state signature\"), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "",
            "            login_user(user)",
            "            next_url = self.appbuilder.get_url_for_index",
            "            # Check if there is a next url on state",
            "            if \"next\" in state and len(state[\"next\"]) > 0:",
            "                next_url = get_safe_redirect(state[\"next\"][0])",
            "            return redirect(next_url)",
            "",
            "",
            "class AuthRemoteUserView(AuthView):",
            "    login_template = \"\"",
            "",
            "    @expose(\"/login/\")",
            "    def login(self) -> WerkzeugResponse:",
            "        username = request.environ.get(\"REMOTE_USER\")",
            "        if g.user is not None and g.user.is_authenticated:",
            "            next_url = request.args.get(\"next\", \"\")",
            "            return redirect(get_safe_redirect(next_url))",
            "        if username:",
            "            user = self.appbuilder.sm.auth_user_remote_user(username)",
            "            if user is None:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            else:",
            "                login_user(user)",
            "        else:",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "        next_url = request.args.get(\"next\", \"\")",
            "        return redirect(get_safe_redirect(next_url))"
        ],
        "afterPatchFile": [
            "import datetime",
            "import logging",
            "import re",
            "from typing import Any, List, Optional",
            "",
            "from flask import abort, current_app, flash, g, redirect, request, session, url_for",
            "from flask_appbuilder._compat import as_unicode",
            "from flask_appbuilder.actions import action",
            "from flask_appbuilder.baseviews import BaseView",
            "from flask_appbuilder.charts.views import DirectByChartView",
            "from flask_appbuilder.fieldwidgets import BS3PasswordFieldWidget",
            "from flask_appbuilder.security.decorators import has_access",
            "from flask_appbuilder.security.forms import (",
            "    DynamicForm,",
            "    LoginForm_db,",
            "    LoginForm_oid,",
            "    ResetPasswordForm,",
            "    SelectDataRequired,",
            "    UserInfoEdit,",
            ")",
            "from flask_appbuilder.security.utils import generate_random_string",
            "from flask_appbuilder.utils.base import get_safe_redirect, lazy_formatter_gettext",
            "from flask_appbuilder.validators import PasswordComplexityValidator",
            "from flask_appbuilder.views import expose, ModelView, SimpleFormView",
            "from flask_appbuilder.widgets import ListWidget, ShowWidget",
            "from flask_babel import lazy_gettext",
            "from flask_login import login_user, logout_user",
            "import jwt",
            "from werkzeug.security import generate_password_hash",
            "from werkzeug.wrappers import Response as WerkzeugResponse",
            "from wtforms import PasswordField, validators",
            "from wtforms.validators import EqualTo",
            "",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class PermissionModelView(ModelView):",
            "    route_base = \"/permissions\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List Base Permissions\")",
            "    show_title = lazy_gettext(\"Show Base Permission\")",
            "    add_title = lazy_gettext(\"Add Base Permission\")",
            "    edit_title = lazy_gettext(\"Edit Base Permission\")",
            "",
            "    label_columns = {\"name\": lazy_gettext(\"Name\")}",
            "",
            "",
            "class ViewMenuModelView(ModelView):",
            "    route_base = \"/viewmenus\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List View Menus\")",
            "    show_title = lazy_gettext(\"Show View Menu\")",
            "    add_title = lazy_gettext(\"Add View Menu\")",
            "    edit_title = lazy_gettext(\"Edit View Menu\")",
            "",
            "    label_columns = {\"name\": lazy_gettext(\"Name\")}",
            "",
            "",
            "class PermissionViewModelView(ModelView):",
            "    route_base = \"/permissionviews\"",
            "    base_permissions = [\"can_list\"]",
            "",
            "    list_title = lazy_gettext(\"List Permissions on Views/Menus\")",
            "    show_title = lazy_gettext(\"Show Permission on Views/Menus\")",
            "    add_title = lazy_gettext(\"Add Permission on Views/Menus\")",
            "    edit_title = lazy_gettext(\"Edit Permission on Views/Menus\")",
            "",
            "    label_columns = {",
            "        \"permission\": lazy_gettext(\"Permission\"),",
            "        \"view_menu\": lazy_gettext(\"View/Menu\"),",
            "    }",
            "    list_columns = [\"permission\", \"view_menu\"]",
            "",
            "",
            "class ResetMyPasswordView(SimpleFormView):",
            "    \"\"\"",
            "    View for resetting own user password",
            "    \"\"\"",
            "",
            "    route_base = \"/resetmypassword\"",
            "    form = ResetPasswordForm",
            "    form_title = lazy_gettext(\"Reset Password Form\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"Password Changed\")",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        self.appbuilder.sm.reset_password(g.user.id, form.password.data)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "class ResetPasswordView(SimpleFormView):",
            "    \"\"\"",
            "    View for reseting all users password",
            "    \"\"\"",
            "",
            "    route_base = \"/resetpassword\"",
            "    form = ResetPasswordForm",
            "    form_title = lazy_gettext(\"Reset Password Form\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"Password Changed\")",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        pk = request.args.get(\"pk\")",
            "        self.appbuilder.sm.reset_password(pk, form.password.data)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "class UserInfoEditView(SimpleFormView):",
            "    form = UserInfoEdit",
            "    form_title = lazy_gettext(\"Edit User Information\")",
            "    redirect_url = \"/\"",
            "    message = lazy_gettext(\"User information changed\")",
            "",
            "    def form_get(self, form: DynamicForm) -> None:",
            "        item = self.appbuilder.sm.get_user_by_id(g.user.id)",
            "        # fills the form generic solution",
            "        for key, value in form.data.items():",
            "            if key == \"csrf_token\":",
            "                continue",
            "            form_field = getattr(form, key)",
            "            form_field.data = getattr(item, key)",
            "",
            "    def form_post(self, form: DynamicForm) -> None:",
            "        form = self.form.refresh(request.form)",
            "        item = self.appbuilder.sm.get_user_by_id(g.user.id)",
            "        form.populate_obj(item)",
            "        self.appbuilder.sm.update_user(item)",
            "        flash(as_unicode(self.message), \"info\")",
            "",
            "",
            "def _roles_custom_formatter(string: str) -> str:",
            "    if current_app.config.get(\"AUTH_ROLES_SYNC_AT_LOGIN\", False):",
            "        string += (",
            "            \". <div class='alert alert-warning' role='alert'>\"",
            "            \"AUTH_ROLES_SYNC_AT_LOGIN is enabled, changes to this field will \"",
            "            \"not persist between user logins.\"",
            "            \"</div>\"",
            "        )",
            "    return string",
            "",
            "",
            "class UserModelView(ModelView):",
            "    route_base = \"/users\"",
            "",
            "    list_title = lazy_gettext(\"List Users\")",
            "    show_title = lazy_gettext(\"Show User\")",
            "    add_title = lazy_gettext(\"Add User\")",
            "    edit_title = lazy_gettext(\"Edit User\")",
            "",
            "    label_columns = {",
            "        \"get_full_name\": lazy_gettext(\"Full Name\"),",
            "        \"first_name\": lazy_gettext(\"First Name\"),",
            "        \"last_name\": lazy_gettext(\"Last Name\"),",
            "        \"username\": lazy_gettext(\"User Name\"),",
            "        \"password\": lazy_gettext(\"Password\"),",
            "        \"active\": lazy_gettext(\"Is Active?\"),",
            "        \"email\": lazy_gettext(\"Email\"),",
            "        \"roles\": lazy_gettext(\"Role\"),",
            "        \"last_login\": lazy_gettext(\"Last login\"),",
            "        \"login_count\": lazy_gettext(\"Login count\"),",
            "        \"fail_login_count\": lazy_gettext(\"Failed login count\"),",
            "        \"created_on\": lazy_gettext(\"Created on\"),",
            "        \"created_by\": lazy_gettext(\"Created by\"),",
            "        \"changed_on\": lazy_gettext(\"Changed on\"),",
            "        \"changed_by\": lazy_gettext(\"Changed by\"),",
            "    }",
            "",
            "    description_columns = {",
            "        \"first_name\": lazy_gettext(\"Write the user first name or names\"),",
            "        \"last_name\": lazy_gettext(\"Write the user last name\"),",
            "        \"username\": lazy_gettext(",
            "            \"Username valid for authentication on DB or LDAP, unused for OID auth\"",
            "        ),",
            "        \"password\": lazy_gettext(\"The user's password for authentication\"),",
            "        \"active\": lazy_gettext(",
            "            \"It's not a good policy to remove a user, just make it inactive\"",
            "        ),",
            "        \"email\": lazy_gettext(\"The user's email, this will also be used for OID auth\"),",
            "        \"roles\": lazy_formatter_gettext(",
            "            \"The user role on the application,\"",
            "            \" this will associate with a list of permissions\",",
            "            _roles_custom_formatter,",
            "        ),",
            "        \"conf_password\": lazy_gettext(\"Please rewrite the user's password to confirm\"),",
            "    }",
            "",
            "    list_columns = [\"first_name\", \"last_name\", \"username\", \"email\", \"active\", \"roles\"]",
            "",
            "    show_fieldsets = [",
            "        (",
            "            lazy_gettext(\"User info\"),",
            "            {\"fields\": [\"username\", \"active\", \"roles\", \"login_count\"]},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Personal Info\"),",
            "            {\"fields\": [\"first_name\", \"last_name\", \"email\"], \"expanded\": True},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Audit Info\"),",
            "            {",
            "                \"fields\": [",
            "                    \"last_login\",",
            "                    \"fail_login_count\",",
            "                    \"created_on\",",
            "                    \"created_by\",",
            "                    \"changed_on\",",
            "                    \"changed_by\",",
            "                ],",
            "                \"expanded\": False,",
            "            },",
            "        ),",
            "    ]",
            "",
            "    user_show_fieldsets = [",
            "        (",
            "            lazy_gettext(\"User info\"),",
            "            {\"fields\": [\"username\", \"active\", \"roles\", \"login_count\"]},",
            "        ),",
            "        (",
            "            lazy_gettext(\"Personal Info\"),",
            "            {\"fields\": [\"first_name\", \"last_name\", \"email\"], \"expanded\": True},",
            "        ),",
            "    ]",
            "",
            "    search_exclude_columns = [\"password\"]",
            "",
            "    add_columns = [\"first_name\", \"last_name\", \"username\", \"active\", \"email\", \"roles\"]",
            "    edit_columns = [\"first_name\", \"last_name\", \"username\", \"active\", \"email\", \"roles\"]",
            "    user_info_title = lazy_gettext(\"Your user information\")",
            "",
            "    @expose(\"/userinfo/\")",
            "    @has_access",
            "    def userinfo(self) -> WerkzeugResponse:",
            "        item = self.datamodel.get(g.user.id, self._base_filters)",
            "        widgets = self._get_show_widget(",
            "            g.user.id, item, show_fieldsets=self.user_show_fieldsets",
            "        )",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            title=self.user_info_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "        )",
            "",
            "    @action(\"userinfoedit\", lazy_gettext(\"Edit User\"), \"\", \"fa-edit\", multiple=False)",
            "    def userinfoedit(self, item: Any) -> WerkzeugResponse:",
            "        return redirect(",
            "            url_for(self.appbuilder.sm.userinfoeditview.__name__ + \".this_form_get\")",
            "        )",
            "",
            "",
            "class UserOIDModelView(UserModelView):",
            "    \"\"\"",
            "    View that add OID specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override useroidmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserLDAPModelView(UserModelView):",
            "    \"\"\"",
            "    View that add LDAP specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserOAuthModelView(UserModelView):",
            "    \"\"\"",
            "    View that add OAUTH specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserRemoteUserModelView(UserModelView):",
            "    \"\"\"",
            "    View that add REMOTE_USER specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userldapmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserDBModelView(UserModelView):",
            "    \"\"\"",
            "    View that add DB specifics to User view.",
            "    Override to implement your own custom view.",
            "    Then override userdbmodelview property on SecurityManager",
            "    \"\"\"",
            "",
            "    add_form_extra_fields = {",
            "        \"password\": PasswordField(",
            "            lazy_gettext(\"Password\"),",
            "            description=lazy_gettext(\"The user's password for authentication\"),",
            "            validators=[validators.DataRequired(), PasswordComplexityValidator()],",
            "            widget=BS3PasswordFieldWidget(),",
            "        ),",
            "        \"conf_password\": PasswordField(",
            "            lazy_gettext(\"Confirm Password\"),",
            "            description=lazy_gettext(\"Please rewrite the user's password to confirm\"),",
            "            validators=[",
            "                validators.DataRequired(),",
            "                EqualTo(\"password\", message=lazy_gettext(\"Passwords must match\")),",
            "            ],",
            "            widget=BS3PasswordFieldWidget(),",
            "        ),",
            "    }",
            "",
            "    add_columns = [",
            "        \"first_name\",",
            "        \"last_name\",",
            "        \"username\",",
            "        \"active\",",
            "        \"email\",",
            "        \"roles\",",
            "        \"password\",",
            "        \"conf_password\",",
            "    ]",
            "",
            "    validators_columns = {\"roles\": [SelectDataRequired()]}",
            "",
            "    @expose(\"/show/<pk>\", methods=[\"GET\"])",
            "    @has_access",
            "    def show(self, pk: Any) -> WerkzeugResponse:",
            "        actions = dict()",
            "        actions[\"resetpasswords\"] = self.actions.get(\"resetpasswords\")",
            "        item = self.datamodel.get(pk, self._base_filters)",
            "        if not item:",
            "            abort(404)",
            "        widgets = self._get_show_widget(pk, item, actions=actions)",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            pk=pk,",
            "            title=self.show_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "            related_views=self._related_views,",
            "        )",
            "",
            "    @expose(\"/userinfo/\")",
            "    @has_access",
            "    def userinfo(self) -> WerkzeugResponse:",
            "        actions = dict()",
            "        actions[\"resetmypassword\"] = self.actions.get(\"resetmypassword\")",
            "        actions[\"userinfoedit\"] = self.actions.get(\"userinfoedit\")",
            "",
            "        item = self.datamodel.get(g.user.id, self._base_filters)",
            "        widgets = self._get_show_widget(",
            "            g.user.id, item, actions=actions, show_fieldsets=self.user_show_fieldsets",
            "        )",
            "        self.update_redirect()",
            "        return self.render_template(",
            "            self.show_template,",
            "            title=self.user_info_title,",
            "            widgets=widgets,",
            "            appbuilder=self.appbuilder,",
            "        )",
            "",
            "    @action(",
            "        \"resetmypassword\",",
            "        lazy_gettext(\"Reset my password\"),",
            "        \"\",",
            "        \"fa-lock\",",
            "        multiple=False,",
            "    )",
            "    def resetmypassword(self, item: Any):",
            "        return redirect(",
            "            url_for(self.appbuilder.sm.resetmypasswordview.__name__ + \".this_form_get\")",
            "        )",
            "",
            "    @action(",
            "        \"resetpasswords\", lazy_gettext(\"Reset Password\"), \"\", \"fa-lock\", multiple=False",
            "    )",
            "    def resetpasswords(self, item: Any) -> WerkzeugResponse:",
            "        return redirect(",
            "            url_for(",
            "                self.appbuilder.sm.resetpasswordview.__name__ + \".this_form_get\",",
            "                pk=item.id,",
            "            )",
            "        )",
            "",
            "    def pre_update(self, item: Any) -> None:",
            "        item.changed_on = datetime.datetime.now()",
            "        item.changed_by_fk = g.user.id",
            "",
            "    def pre_add(self, item: Any) -> None:",
            "        item.password = generate_password_hash(item.password)",
            "",
            "",
            "class UserStatsChartView(DirectByChartView):",
            "    chart_title = lazy_gettext(\"User Statistics\")",
            "    label_columns = {",
            "        \"username\": lazy_gettext(\"User Name\"),",
            "        \"login_count\": lazy_gettext(\"Login count\"),",
            "        \"fail_login_count\": lazy_gettext(\"Failed login count\"),",
            "    }",
            "",
            "    search_exclude_columns = UserModelView.search_exclude_columns",
            "",
            "    definitions = [",
            "        {\"label\": \"Login Count\", \"group\": \"username\", \"series\": [\"login_count\"]},",
            "        {",
            "            \"label\": \"Failed Login Count\",",
            "            \"group\": \"username\",",
            "            \"series\": [\"fail_login_count\"],",
            "        },",
            "    ]",
            "",
            "",
            "class RoleListWidget(ListWidget):",
            "    template = \"appbuilder/general/widgets/roles/list.html\"",
            "",
            "    def __init__(self, **kwargs):",
            "        kwargs[\"appbuilder\"] = current_app.appbuilder",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class RoleShowWidget(ShowWidget):",
            "    template = \"appbuilder/general/widgets/roles/show.html\"",
            "",
            "    def __init__(self, **kwargs):",
            "        kwargs[\"appbuilder\"] = current_app.appbuilder",
            "        super().__init__(**kwargs)",
            "",
            "",
            "class RoleModelView(ModelView):",
            "    route_base = \"/roles\"",
            "",
            "    list_title = lazy_gettext(\"List Roles\")",
            "    show_title = lazy_gettext(\"Show Role\")",
            "    add_title = lazy_gettext(\"Add Role\")",
            "    edit_title = lazy_gettext(\"Edit Role\")",
            "",
            "    list_widget = RoleListWidget",
            "    show_widget = RoleShowWidget",
            "",
            "    label_columns = {",
            "        \"name\": lazy_gettext(\"Name\"),",
            "        \"permissions\": lazy_gettext(\"Permissions\"),",
            "    }",
            "    list_columns = [\"name\", \"permissions\"]",
            "    show_columns = [\"name\", \"permissions\"]",
            "    edit_columns = [\"name\", \"permissions\"]",
            "    add_columns = edit_columns",
            "    order_columns = [\"name\"]",
            "",
            "    @action(",
            "        \"copyrole\",",
            "        lazy_gettext(\"Copy Role\"),",
            "        lazy_gettext(\"Copy the selected roles?\"),",
            "        icon=\"fa-copy\",",
            "        single=False,",
            "    )",
            "    def copy_role(self, items):",
            "        self.update_redirect()",
            "        for item in items:",
            "            new_role = item.__class__()",
            "            new_role.name = item.name",
            "            new_role.permissions = item.permissions",
            "            new_role.name = new_role.name + \" copy\"",
            "            self.datamodel.add(new_role)",
            "        return redirect(self.get_redirect())",
            "",
            "",
            "class RegisterUserModelView(ModelView):",
            "    route_base = \"/registeruser\"",
            "    base_permissions = [\"can_list\", \"can_show\", \"can_delete\"]",
            "    list_title = lazy_gettext(\"List of Registration Requests\")",
            "    show_title = lazy_gettext(\"Show Registration\")",
            "    list_columns = [\"username\", \"registration_date\", \"email\"]",
            "    show_exclude_columns = [\"password\"]",
            "    search_exclude_columns = [\"password\"]",
            "",
            "",
            "class AuthView(BaseView):",
            "    route_base = \"\"",
            "    login_template = \"\"",
            "    invalid_login_message = lazy_gettext(\"Invalid login. Please try again.\")",
            "    title = lazy_gettext(\"Sign In\")",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        pass",
            "",
            "    @expose(\"/logout/\")",
            "    def logout(self):",
            "        logout_user()",
            "        return redirect(",
            "            self.appbuilder.app.config.get(",
            "                \"LOGOUT_REDIRECT_URL\", self.appbuilder.get_url_for_index",
            "            )",
            "        )",
            "",
            "",
            "class AuthDBView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_db.html\"",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        if g.user is not None and g.user.is_authenticated:",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "        form = LoginForm_db()",
            "        if form.validate_on_submit():",
            "            next_url = get_safe_redirect(request.args.get(\"next\", \"\"))",
            "            user = self.appbuilder.sm.auth_user_db(",
            "                form.username.data, form.password.data",
            "            )",
            "            if not user:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login_with(next_url))",
            "            login_user(user, remember=False)",
            "            return redirect(next_url)",
            "        return self.render_template(",
            "            self.login_template, title=self.title, form=form, appbuilder=self.appbuilder",
            "        )",
            "",
            "",
            "class AuthLDAPView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_ldap.html\"",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self):",
            "        if g.user is not None and g.user.is_authenticated:",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "        form = LoginForm_db()",
            "        if form.validate_on_submit():",
            "            next_url = get_safe_redirect(request.args.get(\"next\", \"\"))",
            "            user = self.appbuilder.sm.auth_user_ldap(",
            "                form.username.data, form.password.data",
            "            )",
            "            if not user:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login_with(next_url))",
            "            login_user(user, remember=False)",
            "            return redirect(next_url)",
            "        return self.render_template(",
            "            self.login_template, title=self.title, form=form, appbuilder=self.appbuilder",
            "        )",
            "",
            "",
            "class AuthOIDView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_oid.html\"",
            "    oid_ask_for = [\"email\"]",
            "    oid_ask_for_optional: List[str] = []",
            "",
            "    @expose(\"/login/\", methods=[\"GET\", \"POST\"])",
            "    def login(self, flag=True) -> WerkzeugResponse:",
            "        @self.appbuilder.sm.oid.loginhandler",
            "        def login_handler(self):",
            "            if g.user is not None and g.user.is_authenticated:",
            "                return redirect(self.appbuilder.get_url_for_index)",
            "            form = LoginForm_oid()",
            "            if form.validate_on_submit():",
            "                session[\"remember_me\"] = form.remember_me.data",
            "                identity_url = self.appbuilder.sm.get_oid_identity_url(form.openid.data)",
            "                if identity_url is None:",
            "                    flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                    return redirect(self.appbuilder.get_url_for_login)",
            "                return self.appbuilder.sm.oid.try_login(",
            "                    identity_url,",
            "                    ask_for=self.oid_ask_for,",
            "                    ask_for_optional=self.oid_ask_for_optional,",
            "                )",
            "            return self.render_template(",
            "                self.login_template,",
            "                title=self.title,",
            "                form=form,",
            "                providers=self.appbuilder.sm.openid_providers,",
            "                appbuilder=self.appbuilder,",
            "            )",
            "",
            "        @self.appbuilder.sm.oid.after_login",
            "        def after_login(resp):",
            "            if resp.email is None or resp.email == \"\":",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "            user = self.appbuilder.sm.auth_user_oid(resp.email)",
            "            if user is None:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "            remember_me = False",
            "            if \"remember_me\" in session:",
            "                remember_me = session[\"remember_me\"]",
            "                session.pop(\"remember_me\", None)",
            "",
            "            login_user(user, remember=remember_me)",
            "            next_url = request.args.get(\"next\", \"\")",
            "            return redirect(get_safe_redirect(next_url))",
            "",
            "        return login_handler(self)",
            "",
            "",
            "class AuthOAuthView(AuthView):",
            "    login_template = \"appbuilder/general/security/login_oauth.html\"",
            "",
            "    @expose(\"/login/\")",
            "    @expose(\"/login/<provider>\")",
            "    def login(self, provider: Optional[str] = None) -> WerkzeugResponse:",
            "        log.debug(\"Provider: %s\", provider)",
            "        if g.user is not None and g.user.is_authenticated:",
            "            log.debug(\"Already authenticated %s\", g.user)",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "",
            "        if provider is None:",
            "            return self.render_template(",
            "                self.login_template,",
            "                providers=self.appbuilder.sm.oauth_providers,",
            "                title=self.title,",
            "                appbuilder=self.appbuilder,",
            "            )",
            "",
            "        log.debug(\"Going to call authorize for: %s\", provider)",
            "        random_state = generate_random_string()",
            "        state = jwt.encode(",
            "            request.args.to_dict(flat=False), random_state, algorithm=\"HS256\"",
            "        )",
            "        session[\"oauth_state\"] = random_state",
            "        try:",
            "            if provider == \"twitter\":",
            "                return self.appbuilder.sm.oauth_remotes[provider].authorize_redirect(",
            "                    redirect_uri=url_for(",
            "                        \".oauth_authorized\",",
            "                        provider=provider,",
            "                        _external=True,",
            "                        state=state,",
            "                    )",
            "                )",
            "            else:",
            "                return self.appbuilder.sm.oauth_remotes[provider].authorize_redirect(",
            "                    redirect_uri=url_for(",
            "                        \".oauth_authorized\", provider=provider, _external=True",
            "                    ),",
            "                    state=state.decode(\"ascii\") if isinstance(state, bytes) else state,",
            "                )",
            "        except Exception as e:",
            "            log.error(\"Error on OAuth authorize: %s\", e)",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_index)",
            "",
            "    @expose(\"/oauth-authorized/<provider>\")",
            "    def oauth_authorized(self, provider: str) -> WerkzeugResponse:",
            "        log.debug(\"Authorized init\")",
            "        if provider not in self.appbuilder.sm.oauth_remotes:",
            "            flash(\"Provider not supported.\", \"warning\")",
            "            log.warning(\"OAuth authorized got an unknown provider %s\", provider)",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        try:",
            "            resp = self.appbuilder.sm.oauth_remotes[provider].authorize_access_token()",
            "        except Exception as e:",
            "            log.error(\"Error authorizing OAuth access token: %s\", e)",
            "            flash(\"The request to sign in was denied.\", \"error\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        if resp is None:",
            "            flash(\"You denied the request to sign in.\", \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        log.debug(\"OAUTH Authorized resp: %s\", resp)",
            "        # Retrieves specific user info from the provider",
            "        try:",
            "            self.appbuilder.sm.set_oauth_session(provider, resp)",
            "            userinfo = self.appbuilder.sm.oauth_user_info(provider, resp)",
            "        except Exception as e:",
            "            log.error(\"Error returning OAuth user info: %s\", e)",
            "            user = None",
            "        else:",
            "            log.debug(\"User info retrieved from %s: %s\", provider, userinfo)",
            "            # User email is not whitelisted",
            "            if provider in self.appbuilder.sm.oauth_whitelists:",
            "                whitelist = self.appbuilder.sm.oauth_whitelists[provider]",
            "                allow = False",
            "                for email in whitelist:",
            "                    if \"email\" in userinfo and re.search(email, userinfo[\"email\"]):",
            "                        allow = True",
            "                        break",
            "                if not allow:",
            "                    flash(\"You are not authorized.\", \"warning\")",
            "                    return redirect(self.appbuilder.get_url_for_login)",
            "            else:",
            "                log.debug(\"No whitelist for OAuth provider\")",
            "            user = self.appbuilder.sm.auth_user_oauth(userinfo)",
            "",
            "        if user is None:",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            return redirect(self.appbuilder.get_url_for_login)",
            "        else:",
            "            try:",
            "                state = jwt.decode(",
            "                    request.args[\"state\"], session[\"oauth_state\"], algorithms=[\"HS256\"]",
            "                )",
            "            except (jwt.InvalidTokenError, KeyError):",
            "                flash(as_unicode(\"Invalid state signature\"), \"warning\")",
            "                return redirect(self.appbuilder.get_url_for_login)",
            "",
            "            login_user(user)",
            "            next_url = self.appbuilder.get_url_for_index",
            "            # Check if there is a next url on state",
            "            if \"next\" in state and len(state[\"next\"]) > 0:",
            "                next_url = get_safe_redirect(state[\"next\"][0])",
            "            return redirect(next_url)",
            "",
            "",
            "class AuthRemoteUserView(AuthView):",
            "    login_template = \"\"",
            "",
            "    @expose(\"/login/\")",
            "    def login(self) -> WerkzeugResponse:",
            "        username = request.environ.get(\"REMOTE_USER\")",
            "        if g.user is not None and g.user.is_authenticated:",
            "            next_url = request.args.get(\"next\", \"\")",
            "            return redirect(get_safe_redirect(next_url))",
            "        if username:",
            "            user = self.appbuilder.sm.auth_user_remote_user(username)",
            "            if user is None:",
            "                flash(as_unicode(self.invalid_login_message), \"warning\")",
            "            else:",
            "                login_user(user)",
            "        else:",
            "            flash(as_unicode(self.invalid_login_message), \"warning\")",
            "        next_url = request.args.get(\"next\", \"\")",
            "        return redirect(get_safe_redirect(next_url))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "569": [
                "AuthOIDView",
                "login",
                "login_handler"
            ]
        },
        "addLocation": [
            "flask_appbuilder.security.views.AuthOIDView.login"
        ]
    }
}