{
    "babel/localedata.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import re"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import sys"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import threading"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from itertools import chain"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " _cache = {}"
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " _cache_lock = threading.RLock()"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " _dirname = os.path.join(os.path.dirname(__file__), 'locale-data')"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+_windows_reserved_name_re = re.compile(\"^(con|prn|aux|nul|com[0-9]|lpt[0-9])$\", re.I)"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " def normalize_locale(name):"
            },
            "15": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "             return locale_id"
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+def resolve_locale_filename(name):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    Resolve a locale identifier to a `.dat` path on disk."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    \"\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    # Clean up any possible relative paths."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    name = os.path.basename(name)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    # Ensure we're not left with one of the Windows reserved names."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    if sys.platform == \"win32\" and _windows_reserved_name_re.match(os.path.splitext(name)[0]):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        raise ValueError(\"Name %s is invalid on Windows\" % name)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    # Build the path."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    return os.path.join(_dirname, '%s.dat' % name)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " def exists(name):"
            },
            "35": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     \"\"\"Check whether locale data is available for the given locale."
            },
            "36": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         return False"
            },
            "38": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     if name in _cache:"
            },
            "39": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         return True"
            },
            "40": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    file_found = os.path.exists(os.path.join(_dirname, '%s.dat' % name))"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    file_found = os.path.exists(resolve_locale_filename(name))"
            },
            "42": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     return True if file_found else bool(normalize_locale(name))"
            },
            "43": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     :raise `IOError`: if no locale data file is found for the given locale"
            },
            "46": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "                       identifer, or one of the locales it inherits from"
            },
            "47": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     \"\"\""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    name = os.path.basename(name)"
            },
            "49": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     _cache_lock.acquire()"
            },
            "50": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     try:"
            },
            "51": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         data = _cache.get(name)"
            },
            "52": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                     else:"
            },
            "53": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "                         parent = '_'.join(parts[:-1])"
            },
            "54": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "                 data = load(parent).copy()"
            },
            "55": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            filename = os.path.join(_dirname, '%s.dat' % name)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+            filename = resolve_locale_filename(name)"
            },
            "57": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             with open(filename, 'rb') as fileobj:"
            },
            "58": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                 if name != 'root' and merge_inherited:"
            },
            "59": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                     merge(data, pickle.load(fileobj))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    babel.localedata",
            "    ~~~~~~~~~~~~~~~~",
            "",
            "    Low-level locale data access.",
            "",
            "    :note: The `Locale` class, which uses this module under the hood, provides a",
            "           more convenient interface for accessing the locale data.",
            "",
            "    :copyright: (c) 2013-2020 by the Babel Team.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "",
            "import os",
            "import threading",
            "from itertools import chain",
            "",
            "from babel._compat import pickle, string_types, abc",
            "",
            "",
            "_cache = {}",
            "_cache_lock = threading.RLock()",
            "_dirname = os.path.join(os.path.dirname(__file__), 'locale-data')",
            "",
            "",
            "def normalize_locale(name):",
            "    \"\"\"Normalize a locale ID by stripping spaces and apply proper casing.",
            "",
            "    Returns the normalized locale ID string or `None` if the ID is not",
            "    recognized.",
            "    \"\"\"",
            "    if not name or not isinstance(name, string_types):",
            "        return None",
            "    name = name.strip().lower()",
            "    for locale_id in chain.from_iterable([_cache, locale_identifiers()]):",
            "        if name == locale_id.lower():",
            "            return locale_id",
            "",
            "",
            "def exists(name):",
            "    \"\"\"Check whether locale data is available for the given locale.",
            "",
            "    Returns `True` if it exists, `False` otherwise.",
            "",
            "    :param name: the locale identifier string",
            "    \"\"\"",
            "    if not name or not isinstance(name, string_types):",
            "        return False",
            "    if name in _cache:",
            "        return True",
            "    file_found = os.path.exists(os.path.join(_dirname, '%s.dat' % name))",
            "    return True if file_found else bool(normalize_locale(name))",
            "",
            "",
            "def locale_identifiers():",
            "    \"\"\"Return a list of all locale identifiers for which locale data is",
            "    available.",
            "",
            "    This data is cached after the first invocation in `locale_identifiers.cache`.",
            "",
            "    Removing the `locale_identifiers.cache` attribute or setting it to `None`",
            "    will cause this function to re-read the list from disk.",
            "",
            "    .. versionadded:: 0.8.1",
            "",
            "    :return: a list of locale identifiers (strings)",
            "    \"\"\"",
            "    data = getattr(locale_identifiers, 'cache', None)",
            "    if data is None:",
            "        locale_identifiers.cache = data = [",
            "            stem",
            "            for stem, extension in",
            "            (os.path.splitext(filename) for filename in os.listdir(_dirname))",
            "            if extension == '.dat' and stem != 'root'",
            "        ]",
            "    return data",
            "",
            "",
            "def load(name, merge_inherited=True):",
            "    \"\"\"Load the locale data for the given locale.",
            "",
            "    The locale data is a dictionary that contains much of the data defined by",
            "    the Common Locale Data Repository (CLDR). This data is stored as a",
            "    collection of pickle files inside the ``babel`` package.",
            "",
            "    >>> d = load('en_US')",
            "    >>> d['languages']['sv']",
            "    u'Swedish'",
            "",
            "    Note that the results are cached, and subsequent requests for the same",
            "    locale return the same dictionary:",
            "",
            "    >>> d1 = load('en_US')",
            "    >>> d2 = load('en_US')",
            "    >>> d1 is d2",
            "    True",
            "",
            "    :param name: the locale identifier string (or \"root\")",
            "    :param merge_inherited: whether the inherited data should be merged into",
            "                            the data of the requested locale",
            "    :raise `IOError`: if no locale data file is found for the given locale",
            "                      identifer, or one of the locales it inherits from",
            "    \"\"\"",
            "    _cache_lock.acquire()",
            "    try:",
            "        data = _cache.get(name)",
            "        if not data:",
            "            # Load inherited data",
            "            if name == 'root' or not merge_inherited:",
            "                data = {}",
            "            else:",
            "                from babel.core import get_global",
            "                parent = get_global('parent_exceptions').get(name)",
            "                if not parent:",
            "                    parts = name.split('_')",
            "                    if len(parts) == 1:",
            "                        parent = 'root'",
            "                    else:",
            "                        parent = '_'.join(parts[:-1])",
            "                data = load(parent).copy()",
            "            filename = os.path.join(_dirname, '%s.dat' % name)",
            "            with open(filename, 'rb') as fileobj:",
            "                if name != 'root' and merge_inherited:",
            "                    merge(data, pickle.load(fileobj))",
            "                else:",
            "                    data = pickle.load(fileobj)",
            "            _cache[name] = data",
            "        return data",
            "    finally:",
            "        _cache_lock.release()",
            "",
            "",
            "def merge(dict1, dict2):",
            "    \"\"\"Merge the data from `dict2` into the `dict1` dictionary, making copies",
            "    of nested dictionaries.",
            "",
            "    >>> d = {1: 'foo', 3: 'baz'}",
            "    >>> merge(d, {1: 'Foo', 2: 'Bar'})",
            "    >>> sorted(d.items())",
            "    [(1, 'Foo'), (2, 'Bar'), (3, 'baz')]",
            "",
            "    :param dict1: the dictionary to merge into",
            "    :param dict2: the dictionary containing the data that should be merged",
            "    \"\"\"",
            "    for key, val2 in dict2.items():",
            "        if val2 is not None:",
            "            val1 = dict1.get(key)",
            "            if isinstance(val2, dict):",
            "                if val1 is None:",
            "                    val1 = {}",
            "                if isinstance(val1, Alias):",
            "                    val1 = (val1, val2)",
            "                elif isinstance(val1, tuple):",
            "                    alias, others = val1",
            "                    others = others.copy()",
            "                    merge(others, val2)",
            "                    val1 = (alias, others)",
            "                else:",
            "                    val1 = val1.copy()",
            "                    merge(val1, val2)",
            "            else:",
            "                val1 = val2",
            "            dict1[key] = val1",
            "",
            "",
            "class Alias(object):",
            "    \"\"\"Representation of an alias in the locale data.",
            "",
            "    An alias is a value that refers to some other part of the locale data,",
            "    as specified by the `keys`.",
            "    \"\"\"",
            "",
            "    def __init__(self, keys):",
            "        self.keys = tuple(keys)",
            "",
            "    def __repr__(self):",
            "        return '<%s %r>' % (type(self).__name__, self.keys)",
            "",
            "    def resolve(self, data):",
            "        \"\"\"Resolve the alias based on the given data.",
            "",
            "        This is done recursively, so if one alias resolves to a second alias,",
            "        that second alias will also be resolved.",
            "",
            "        :param data: the locale data",
            "        :type data: `dict`",
            "        \"\"\"",
            "        base = data",
            "        for key in self.keys:",
            "            data = data[key]",
            "        if isinstance(data, Alias):",
            "            data = data.resolve(base)",
            "        elif isinstance(data, tuple):",
            "            alias, others = data",
            "            data = alias.resolve(base)",
            "        return data",
            "",
            "",
            "class LocaleDataDict(abc.MutableMapping):",
            "    \"\"\"Dictionary wrapper that automatically resolves aliases to the actual",
            "    values.",
            "    \"\"\"",
            "",
            "    def __init__(self, data, base=None):",
            "        self._data = data",
            "        if base is None:",
            "            base = data",
            "        self.base = base",
            "",
            "    def __len__(self):",
            "        return len(self._data)",
            "",
            "    def __iter__(self):",
            "        return iter(self._data)",
            "",
            "    def __getitem__(self, key):",
            "        orig = val = self._data[key]",
            "        if isinstance(val, Alias):  # resolve an alias",
            "            val = val.resolve(self.base)",
            "        if isinstance(val, tuple):  # Merge a partial dict with an alias",
            "            alias, others = val",
            "            val = alias.resolve(self.base).copy()",
            "            merge(val, others)",
            "        if type(val) is dict:  # Return a nested alias-resolving dict",
            "            val = LocaleDataDict(val, base=self.base)",
            "        if val is not orig:",
            "            self._data[key] = val",
            "        return val",
            "",
            "    def __setitem__(self, key, value):",
            "        self._data[key] = value",
            "",
            "    def __delitem__(self, key):",
            "        del self._data[key]",
            "",
            "    def copy(self):",
            "        return LocaleDataDict(self._data.copy(), base=self.base)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    babel.localedata",
            "    ~~~~~~~~~~~~~~~~",
            "",
            "    Low-level locale data access.",
            "",
            "    :note: The `Locale` class, which uses this module under the hood, provides a",
            "           more convenient interface for accessing the locale data.",
            "",
            "    :copyright: (c) 2013-2020 by the Babel Team.",
            "    :license: BSD, see LICENSE for more details.",
            "\"\"\"",
            "",
            "import os",
            "import re",
            "import sys",
            "import threading",
            "from itertools import chain",
            "",
            "from babel._compat import pickle, string_types, abc",
            "",
            "",
            "_cache = {}",
            "_cache_lock = threading.RLock()",
            "_dirname = os.path.join(os.path.dirname(__file__), 'locale-data')",
            "_windows_reserved_name_re = re.compile(\"^(con|prn|aux|nul|com[0-9]|lpt[0-9])$\", re.I)",
            "",
            "",
            "def normalize_locale(name):",
            "    \"\"\"Normalize a locale ID by stripping spaces and apply proper casing.",
            "",
            "    Returns the normalized locale ID string or `None` if the ID is not",
            "    recognized.",
            "    \"\"\"",
            "    if not name or not isinstance(name, string_types):",
            "        return None",
            "    name = name.strip().lower()",
            "    for locale_id in chain.from_iterable([_cache, locale_identifiers()]):",
            "        if name == locale_id.lower():",
            "            return locale_id",
            "",
            "",
            "def resolve_locale_filename(name):",
            "    \"\"\"",
            "    Resolve a locale identifier to a `.dat` path on disk.",
            "    \"\"\"",
            "",
            "    # Clean up any possible relative paths.",
            "    name = os.path.basename(name)",
            "",
            "    # Ensure we're not left with one of the Windows reserved names.",
            "    if sys.platform == \"win32\" and _windows_reserved_name_re.match(os.path.splitext(name)[0]):",
            "        raise ValueError(\"Name %s is invalid on Windows\" % name)",
            "",
            "    # Build the path.",
            "    return os.path.join(_dirname, '%s.dat' % name)",
            "",
            "",
            "def exists(name):",
            "    \"\"\"Check whether locale data is available for the given locale.",
            "",
            "    Returns `True` if it exists, `False` otherwise.",
            "",
            "    :param name: the locale identifier string",
            "    \"\"\"",
            "    if not name or not isinstance(name, string_types):",
            "        return False",
            "    if name in _cache:",
            "        return True",
            "    file_found = os.path.exists(resolve_locale_filename(name))",
            "    return True if file_found else bool(normalize_locale(name))",
            "",
            "",
            "def locale_identifiers():",
            "    \"\"\"Return a list of all locale identifiers for which locale data is",
            "    available.",
            "",
            "    This data is cached after the first invocation in `locale_identifiers.cache`.",
            "",
            "    Removing the `locale_identifiers.cache` attribute or setting it to `None`",
            "    will cause this function to re-read the list from disk.",
            "",
            "    .. versionadded:: 0.8.1",
            "",
            "    :return: a list of locale identifiers (strings)",
            "    \"\"\"",
            "    data = getattr(locale_identifiers, 'cache', None)",
            "    if data is None:",
            "        locale_identifiers.cache = data = [",
            "            stem",
            "            for stem, extension in",
            "            (os.path.splitext(filename) for filename in os.listdir(_dirname))",
            "            if extension == '.dat' and stem != 'root'",
            "        ]",
            "    return data",
            "",
            "",
            "def load(name, merge_inherited=True):",
            "    \"\"\"Load the locale data for the given locale.",
            "",
            "    The locale data is a dictionary that contains much of the data defined by",
            "    the Common Locale Data Repository (CLDR). This data is stored as a",
            "    collection of pickle files inside the ``babel`` package.",
            "",
            "    >>> d = load('en_US')",
            "    >>> d['languages']['sv']",
            "    u'Swedish'",
            "",
            "    Note that the results are cached, and subsequent requests for the same",
            "    locale return the same dictionary:",
            "",
            "    >>> d1 = load('en_US')",
            "    >>> d2 = load('en_US')",
            "    >>> d1 is d2",
            "    True",
            "",
            "    :param name: the locale identifier string (or \"root\")",
            "    :param merge_inherited: whether the inherited data should be merged into",
            "                            the data of the requested locale",
            "    :raise `IOError`: if no locale data file is found for the given locale",
            "                      identifer, or one of the locales it inherits from",
            "    \"\"\"",
            "    name = os.path.basename(name)",
            "    _cache_lock.acquire()",
            "    try:",
            "        data = _cache.get(name)",
            "        if not data:",
            "            # Load inherited data",
            "            if name == 'root' or not merge_inherited:",
            "                data = {}",
            "            else:",
            "                from babel.core import get_global",
            "                parent = get_global('parent_exceptions').get(name)",
            "                if not parent:",
            "                    parts = name.split('_')",
            "                    if len(parts) == 1:",
            "                        parent = 'root'",
            "                    else:",
            "                        parent = '_'.join(parts[:-1])",
            "                data = load(parent).copy()",
            "            filename = resolve_locale_filename(name)",
            "            with open(filename, 'rb') as fileobj:",
            "                if name != 'root' and merge_inherited:",
            "                    merge(data, pickle.load(fileobj))",
            "                else:",
            "                    data = pickle.load(fileobj)",
            "            _cache[name] = data",
            "        return data",
            "    finally:",
            "        _cache_lock.release()",
            "",
            "",
            "def merge(dict1, dict2):",
            "    \"\"\"Merge the data from `dict2` into the `dict1` dictionary, making copies",
            "    of nested dictionaries.",
            "",
            "    >>> d = {1: 'foo', 3: 'baz'}",
            "    >>> merge(d, {1: 'Foo', 2: 'Bar'})",
            "    >>> sorted(d.items())",
            "    [(1, 'Foo'), (2, 'Bar'), (3, 'baz')]",
            "",
            "    :param dict1: the dictionary to merge into",
            "    :param dict2: the dictionary containing the data that should be merged",
            "    \"\"\"",
            "    for key, val2 in dict2.items():",
            "        if val2 is not None:",
            "            val1 = dict1.get(key)",
            "            if isinstance(val2, dict):",
            "                if val1 is None:",
            "                    val1 = {}",
            "                if isinstance(val1, Alias):",
            "                    val1 = (val1, val2)",
            "                elif isinstance(val1, tuple):",
            "                    alias, others = val1",
            "                    others = others.copy()",
            "                    merge(others, val2)",
            "                    val1 = (alias, others)",
            "                else:",
            "                    val1 = val1.copy()",
            "                    merge(val1, val2)",
            "            else:",
            "                val1 = val2",
            "            dict1[key] = val1",
            "",
            "",
            "class Alias(object):",
            "    \"\"\"Representation of an alias in the locale data.",
            "",
            "    An alias is a value that refers to some other part of the locale data,",
            "    as specified by the `keys`.",
            "    \"\"\"",
            "",
            "    def __init__(self, keys):",
            "        self.keys = tuple(keys)",
            "",
            "    def __repr__(self):",
            "        return '<%s %r>' % (type(self).__name__, self.keys)",
            "",
            "    def resolve(self, data):",
            "        \"\"\"Resolve the alias based on the given data.",
            "",
            "        This is done recursively, so if one alias resolves to a second alias,",
            "        that second alias will also be resolved.",
            "",
            "        :param data: the locale data",
            "        :type data: `dict`",
            "        \"\"\"",
            "        base = data",
            "        for key in self.keys:",
            "            data = data[key]",
            "        if isinstance(data, Alias):",
            "            data = data.resolve(base)",
            "        elif isinstance(data, tuple):",
            "            alias, others = data",
            "            data = alias.resolve(base)",
            "        return data",
            "",
            "",
            "class LocaleDataDict(abc.MutableMapping):",
            "    \"\"\"Dictionary wrapper that automatically resolves aliases to the actual",
            "    values.",
            "    \"\"\"",
            "",
            "    def __init__(self, data, base=None):",
            "        self._data = data",
            "        if base is None:",
            "            base = data",
            "        self.base = base",
            "",
            "    def __len__(self):",
            "        return len(self._data)",
            "",
            "    def __iter__(self):",
            "        return iter(self._data)",
            "",
            "    def __getitem__(self, key):",
            "        orig = val = self._data[key]",
            "        if isinstance(val, Alias):  # resolve an alias",
            "            val = val.resolve(self.base)",
            "        if isinstance(val, tuple):  # Merge a partial dict with an alias",
            "            alias, others = val",
            "            val = alias.resolve(self.base).copy()",
            "            merge(val, others)",
            "        if type(val) is dict:  # Return a nested alias-resolving dict",
            "            val = LocaleDataDict(val, base=self.base)",
            "        if val is not orig:",
            "            self._data[key] = val",
            "        return val",
            "",
            "    def __setitem__(self, key, value):",
            "        self._data[key] = value",
            "",
            "    def __delitem__(self, key):",
            "        del self._data[key]",
            "",
            "    def copy(self):",
            "        return LocaleDataDict(self._data.copy(), base=self.base)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "exists"
            ],
            "122": [
                "load"
            ]
        },
        "addLocation": [
            "babel.localedata.exists",
            "babel.localedata.load",
            "litestar.connection.request"
        ]
    }
}