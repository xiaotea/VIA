{
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         \"requests\","
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         \"pyecharts==1.7.1\",  # broken api between 0.x and 1.x"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         \"beautifulsoup4>=4.9.0\","
            },
            "3": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"sqlalchemy\","
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        \"sqlalchemy<2.0\","
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         \"pysocks\",  # sock5 proxy support"
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     ],"
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     tests_require=[\"pytest\"],"
            }
        },
        "frontPatchFile": [
            "import setuptools",
            "import os",
            "import shutil",
            "",
            "with open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:",
            "    long_description = fh.read()",
            "",
            "## super ugly but quick way to exclude .py files in the packages",
            "",
            "excludes = [\"holdings.py\"]",
            "",
            "for f in excludes:",
            "    absf = os.path.join(os.getcwd(), \"xalpha\", f)",
            "    if os.path.exists(absf):",
            "        shutil.move(absf, os.path.join(os.getcwd(), \"xalpha\", f + \".keep\"))",
            "",
            "setuptools.setup(",
            "    name=\"xalpha\",",
            "    version=\"0.11.8\",",
            "    author=\"refraction-ray\",",
            "    author_email=\"znfesnpbh@gmail.com\",",
            "    description=\"all about fund investment\",",
            "    long_description=long_description,",
            "    long_description_content_type=\"text/markdown\",",
            "    url=\"https://github.com/refraction-ray/xalpha\",",
            "    packages=setuptools.find_packages(),",
            "    include_package_data=True,",
            "    install_requires=[",
            "        \"lxml\",",
            "        \"pandas<2.0\",",
            "        \"xlrd>=1.0.0\",  #  read excel support",
            "        \"numpy\",",
            "        \"scipy\",",
            "        \"matplotlib\",",
            "        \"requests\",",
            "        \"pyecharts==1.7.1\",  # broken api between 0.x and 1.x",
            "        \"beautifulsoup4>=4.9.0\",",
            "        \"sqlalchemy\",",
            "        \"pysocks\",  # sock5 proxy support",
            "    ],",
            "    tests_require=[\"pytest\"],",
            "    classifiers=(",
            "        \"Programming Language :: Python :: 3\",",
            "        \"License :: OSI Approved :: MIT License\",",
            "        \"Operating System :: OS Independent\",",
            "    ),",
            ")",
            "",
            "",
            "for f in excludes:",
            "    absf = os.path.join(os.getcwd(), \"xalpha\", f + \".keep\")",
            "    if os.path.exists(absf):",
            "        shutil.move(absf, os.path.join(os.getcwd(), \"xalpha\", f))"
        ],
        "afterPatchFile": [
            "import setuptools",
            "import os",
            "import shutil",
            "",
            "with open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:",
            "    long_description = fh.read()",
            "",
            "## super ugly but quick way to exclude .py files in the packages",
            "",
            "excludes = [\"holdings.py\"]",
            "",
            "for f in excludes:",
            "    absf = os.path.join(os.getcwd(), \"xalpha\", f)",
            "    if os.path.exists(absf):",
            "        shutil.move(absf, os.path.join(os.getcwd(), \"xalpha\", f + \".keep\"))",
            "",
            "setuptools.setup(",
            "    name=\"xalpha\",",
            "    version=\"0.11.8\",",
            "    author=\"refraction-ray\",",
            "    author_email=\"znfesnpbh@gmail.com\",",
            "    description=\"all about fund investment\",",
            "    long_description=long_description,",
            "    long_description_content_type=\"text/markdown\",",
            "    url=\"https://github.com/refraction-ray/xalpha\",",
            "    packages=setuptools.find_packages(),",
            "    include_package_data=True,",
            "    install_requires=[",
            "        \"lxml\",",
            "        \"pandas<2.0\",",
            "        \"xlrd>=1.0.0\",  #  read excel support",
            "        \"numpy\",",
            "        \"scipy\",",
            "        \"matplotlib\",",
            "        \"requests\",",
            "        \"pyecharts==1.7.1\",  # broken api between 0.x and 1.x",
            "        \"beautifulsoup4>=4.9.0\",",
            "        \"sqlalchemy<2.0\",",
            "        \"pysocks\",  # sock5 proxy support",
            "    ],",
            "    tests_require=[\"pytest\"],",
            "    classifiers=(",
            "        \"Programming Language :: Python :: 3\",",
            "        \"License :: OSI Approved :: MIT License\",",
            "        \"Operating System :: OS Independent\",",
            "    ),",
            ")",
            "",
            "",
            "for f in excludes:",
            "    absf = os.path.join(os.getcwd(), \"xalpha\", f + \".keep\")",
            "    if os.path.exists(absf):",
            "        shutil.move(absf, os.path.join(os.getcwd(), \"xalpha\", f))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": []
        },
        "addLocation": []
    },
    "xalpha/info.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 540,
                "afterPatchRowNumber": 540,
                "PatchRowcode": "                 \"This code seems to be a mfund, use ``mfundinfo`` instead\""
            },
            "1": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "             )"
            },
            "2": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "         code = code.zfill(6)  # 1234 is the same as 001234"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+        assert code.isdigit(), \"fund code must be a strin of six digits\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 544,
                "PatchRowcode": "+        assert len(code) == 6, \"fund code must be a strin of six digits\""
            },
            "5": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 545,
                "PatchRowcode": "         self._url = ("
            },
            "6": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "             \"http://fund.eastmoney.com/pingzhongdata/\" + code + \".js\""
            },
            "7": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "         )  # js url api for info of certain fund"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "modules of info class, including cashinfo, indexinfo and fundinfo class",
            "\"\"\"",
            "",
            "import os",
            "import csv",
            "import datetime as dt",
            "import json",
            "import re",
            "import logging",
            "from functools import lru_cache",
            "",
            "import pandas as pd",
            "from bs4 import BeautifulSoup",
            "from sqlalchemy import exc",
            "",
            "import xalpha.remain as rm",
            "from xalpha.cons import (",
            "    convert_date,",
            "    droplist,",
            "    myround,",
            "    opendate,",
            "    yesterday,",
            "    yesterdaydash,",
            "    yesterdayobj,",
            "    today_obj,",
            "    rget,",
            "    rget_json,",
            "    _float,",
            ")",
            "from xalpha.exceptions import FundTypeError, TradeBehaviorError, ParserFailure",
            "from xalpha.indicator import indicator",
            "",
            "_warnmess = \"Something weird on redem fee, please adjust self.segment by hand\"",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _shengoucal(sg, sgf, value, label):",
            "    \"\"\"",
            "    Infer the share of buying fund by money input, the rate of fee in the unit of %,",
            "        and netvalue of fund",
            "",
            "    :param sg: positive float, \u7533\u8d2d\u91d1\u989d",
            "    :param sgf: positive float, \u7533\u8d2d\u8d39\uff0c\u4ee5\uff05\u4e3a\u5355\u4f4d\uff0c\u5982 0.15 \u8868\u793a 0.15%",
            "    :param value: positive float, \u5bf9\u5e94\u4ea7\u54c1\u7684\u5355\u4f4d\u51c0\u503c",
            "    :param label: integer, 1 \u4ee3\u8868\u4efd\u989d\u6b63\u5e38\u8fdb\u884c\u56db\u820d\u4e94\u5165\uff0c 2 \u4ee3\u8868\u4efd\u989d\u76f4\u63a5\u820d\u53bb\u5c0f\u6570\u70b9\u4e24\u4f4d\u4e4b\u540e\u3002\u91d1\u989d\u90e8\u5206\u90fd\u662f\u56db\u820d\u4e94\u5165",
            "    :returns: tuple of two positive float, \u51c0\u7533\u8d2d\u91d1\u989d\u548c\u7533\u8d2d\u4efd\u989d",
            "    \"\"\"",
            "    jsg = myround(sg / (1 + sgf * 1e-2))",
            "    share = myround(jsg / value, label)",
            "    return (jsg, share)",
            "",
            "",
            "def _nfloat(string):",
            "    \"\"\"",
            "    deal with comment column in fundinfo price table,",
            "    positive value for fenhong and negative value for chaifen,",
            "    keep other unrocognized pattern as original string",
            "",
            "    :param string: string of input from original data",
            "    :returns: make fenhong and songpei as float number",
            "    \"\"\"",
            "    result = 0",
            "    if string:",
            "        try:",
            "            result = float(string)",
            "        except ValueError:",
            "            if re.match(r'\"\u5206\u7ea2\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string):",
            "                result = float(re.match(r'\"\u5206\u7ea2\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string).group(1))",
            "            elif re.match(r\".*\u73b0\u91d1(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = float(re.match(r\".*\u73b0\u91d1(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            elif re.match(r\".*\u6298\u7b97(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = -float(re.match(r\".*\u6298\u7b97(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            elif re.match(r'\"\u62c6\u5206\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string):",
            "                result = -float(re.match(r'\"\u62c6\u5206\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string).group(1))",
            "            elif re.match(r\"\\D*\u5206\u62c6(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = -float(re.match(r\"\\D*\u5206\u62c6(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            else:",
            "                logger.warning(\"The comment col cannot be converted: %s\" % string)",
            "                result = string",
            "    return result",
            "",
            "",
            "class FundReport:",
            "    \"\"\"",
            "    \u63d0\u4f9b\u67e5\u770b\u5404\u79cd\u57fa\u91d1\u62a5\u544a\u7684\u63a5\u53e3",
            "    \"\"\"",
            "",
            "    def __init__(self, code):",
            "        self.code = code",
            "        r = rget(",
            "            \"http://api.fund.eastmoney.com/f10/JJGG?callback=&fundcode={code}&pageIndex=1&pageSize=20&type={type_}\".format(",
            "                code=code, type_=\"3\"",
            "            ),",
            "            headers={",
            "                \"Referer\": \"http://fundf10.eastmoney.com/jjgg_{code}_3.html\".format(",
            "                    code=code",
            "                )",
            "            },",
            "        )",
            "        self.report_list = r.json()[\"Data\"]",
            "        self.report_detail = {}",
            "",
            "    def get_report(self, no=0, id_=None):",
            "        \"\"\"",
            "",
            "        :param no: int\u3002\u5728type_=3 \u4e2d\u7684\u7b2cno\u4e2a\u62a5\u544a\u3002",
            "        :param id_: id \u53ef\u7531 :meth:`show_report_list` \u4e2d\u6761\u76ee\u7684\u5bf9\u5e94 ID \u5f97\u5230",
            "        :return:",
            "        \"\"\"",
            "        if id_:",
            "            report_url = \"https://np-cnotice-fund.eastmoney.com/api/content/ann?client_source=web_fund&show_all=1&art_code={id_}\".format(",
            "                id_=id_",
            "            )",
            "",
            "        if not self.report_detail.get(no):",
            "            report_url = \"https://np-cnotice-fund.eastmoney.com/api/content/ann?client_source=web_fund&show_all=1&art_code={id_}\".format(",
            "                id_=self.report_list[no][\"ID\"]",
            "            )",
            "",
            "            # report_url = \"http://fund.eastmoney.com/gonggao/{code},{id_}.html\".format(",
            "            #     code=self.code, id_=self.report_list[no][\"ID\"]",
            "            # )",
            "            # r = rget(report_url)",
            "            # b = BeautifulSoup(r.text, \"lxml\")",
            "            # seasonr = b.find(\"pre\")",
            "            # sr = [s.string.strip() for s in seasonr.findAll(\"p\") if s.string]",
            "        r = rget_json(report_url)",
            "",
            "        sr = r[\"data\"][\"notice_content\"]",
            "        sr = [s.strip() for s in sr.split(\"\\n\") if s.strip()]",
            "        self.report_detail[no] = sr",
            "",
            "        return sr",
            "",
            "    def show_report_list(self, type_=3):",
            "        \"\"\"",
            "",
            "        :param type_: int\u3002\u7b2c0\u680f\uff0c\u7b2c1\u680f\uff0c\u6bcf\u680f\u7684\u542b\u4e49\uff0c\u8bf7\u53c2\u7167\u5929\u5929\u57fa\u91d1\u57fa\u91d1\u62a5\u544a\u7684\u9875\u9762\u3002",
            "        :return:",
            "        \"\"\"",
            "        r = rget(",
            "            \"http://api.fund.eastmoney.com/f10/JJGG?callback=&fundcode={code}&pageIndex=1&pageSize=20&type={type_}\".format(",
            "                code=self.code, type_=str(type_)",
            "            ),",
            "            headers={",
            "                \"Referer\": \"http://fundf10.eastmoney.com/jjgg_{code}_3.html\".format(",
            "                    code=self.code",
            "                )",
            "            },",
            "        )",
            "        return r.json()[\"Data\"]",
            "",
            "    def analyse_report(self, no=0):",
            "        l = self.get_report(no)",
            "        d = {}",
            "        d[\"title\"] = \"\"",
            "        for s in l[:5]:",
            "            if s.startswith(\"\u57fa\u91d1\u7ba1\u7406\"):",
            "                break",
            "            d[\"title\"] += s + \" \"",
            "        for i, s in enumerate(l):",
            "            if s.startswith(\"\u4e1a\u7ee9\u6bd4\u8f83\u57fa\u51c6\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    if l[i + 1][0] != \"\u672c\":",
            "                        d[\"benchmark\"] = ss[-1] + l[i + 1]",
            "                    else:",
            "                        d[\"benchmark\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u7ba1\u7406\u4eba\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"company\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u6258\u7ba1\u4eba\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"bank\"] = ss[-1]",
            "            elif s.startswith(\"\u573a\u5185\u7b80\u79f0\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"shortname\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u4e3b\u4ee3\u7801\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"code\"] = ss[-1]",
            "            elif s.startswith(\"\u62a5\u544a\u671f\u672b\u57fa\u91d1\u4efd\u989d\u603b\u989d\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"share\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u5408\u540c\u751f\u6548\u65e5\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"start_date\"] = ss[-1]",
            "        return d",
            "",
            "",
            "@lru_cache()",
            "def get_fund_holdings(code, year=\"\", season=\"\", month=\"\", category=\"jjcc\"):",
            "    \"\"\"",
            "    \u83b7\u53d6\u57fa\u91d1\u8be6\u7ec6\u7684\u5e95\u5c42\u6301\u4ed3\u4fe1\u606f",
            "",
            "    :param code: str. 6 \u4f4d\u57fa\u91d1\u4ee3\u7801",
            "    :param year:  int. eg. 2019",
            "    :param season: int, 1,2,3,4",
            "    :param month: Optional[int]. \u6307\u5b9a season \u5373\u53ef\uff0c\u4e00\u822c\u4e0d\u9700\u7406\u4f1a",
            "    :param category: str. stock \u80a1\u7968\u6301\u4ed3\uff0c bond \u503a\u5238\u6301\u4ed3\uff0c\u5929\u5929\u57fa\u91d1\u65e0\u6cd5\u81ea\u52a8\u5904\u7406\u6d77\u5916\u57fa\u91d1\u6301\u4ed3\uff0c\u6682\u672a\u517c\u5bb9 FOF \u7684\u56fd\u5185\u57fa\u91d1\u6301\u4ed3",
            "    :return: pd.DataFrame or None. \u6ca1\u6709\u5bf9\u5e94\u6301\u4ed3\u65f6\u8fd4\u56de None\u3002",
            "    \"\"\"",
            "    if not month and season:",
            "        month = 3 * int(season)",
            "    if category in [\"stock\", \"stocks\", \"jjcc\", \"\", \"gp\", \"s\"]:",
            "        category = \"jjcc\"",
            "    elif category in [\"bond\", \"bonds\", \"zq\", \"zqcc\", \"b\"]:",
            "        category = \"zqcc\"",
            "    else:",
            "        raise ParserFailure(\"unrecognized category %s\" % category)",
            "    if code.startswith(\"F\"):",
            "        code = code[1:]",
            "    r = rget(",
            "        \"http://fundf10.eastmoney.com/FundArchivesDatas.aspx?type={category}&code={code}&topline=10&\\",
            "year={year}&month={month}\".format(",
            "            year=str(year), month=str(month), code=code, category=category",
            "        ),",
            "        headers={",
            "            \"Host\": \"fundf10.eastmoney.com\",",
            "            \"Referer\": \"http://fundf10.eastmoney.com/ccmx_{code}.html\".format(",
            "                code=code",
            "            ),",
            "        },",
            "    )",
            "    if len(r.text) < 50:",
            "        return",
            "        # raise ParserFailure(",
            "        #     \"This fund has no holdings on stock or bonds in this period\"",
            "        # )",
            "    s = BeautifulSoup(",
            "        re.match(\"[\\s\\S]*apidata={ content:(.*),arryear:\", r.text).groups()[0], \"lxml\"",
            "    )",
            "    if len(s.text) < 30:",
            "        return",
            "        # raise ParserFailure(",
            "        #     \"This fund has no holdings on stock or bonds in this period\"",
            "        # )",
            "    timeline = [",
            "        i.string for i in s.findAll(\"font\", class_=\"px12\") if i.text.startswith(\"2\")",
            "    ]",
            "    ind = 0",
            "    if month:",
            "        for i, d in enumerate(timeline):",
            "            if d.split(\"-\")[1][-1] == str(month)[-1]:  # avoid 09 compare to 9",
            "                ind = i",
            "                break",
            "        else:",
            "            return  # not update to this month",
            "    t1 = s.findAll(\"table\")[ind]",
            "    main = [[j.text for j in i.contents] for i in t1.findAll(\"tr\")[1:]]",
            "    cols = [j.text for j in t1.findAll(\"tr\")[0].contents if j.text.strip()]",
            "    icode = 1",
            "    iname = 2",
            "    iratio = 4",
            "    ishare = 5",
            "    ivalue = 6",
            "    for j, col in enumerate(cols):",
            "        if col.endswith(\"\u4ee3\u7801\"):",
            "            icode = j",
            "        elif col.endswith(\"\u540d\u79f0\"):",
            "            iname = j",
            "        elif col.endswith(\"\u6bd4\u4f8b\"):",
            "            iratio = j",
            "        elif col.startswith(\"\u6301\u80a1\u6570\"):",
            "            ishare = j",
            "        elif col.startswith(\"\u6301\u4ed3\u5e02\u503c\"):",
            "            ivalue = j",
            "    if category == \"jjcc\":",
            "        result = {\"code\": [], \"name\": [], \"ratio\": [], \"share\": [], \"value\": []}",
            "        for l in main:",
            "            result[\"code\"].append(l[icode])",
            "            result[\"name\"].append(l[iname])",
            "            result[\"ratio\"].append(float(l[iratio][:-1]))",
            "            result[\"share\"].append(_float(l[ishare]))",
            "            result[\"value\"].append(_float(l[ivalue]))",
            "    elif category == \"zqcc\":",
            "        result = {\"code\": [], \"name\": [], \"ratio\": [], \"value\": []}",
            "        for l in main:",
            "            result[\"code\"].append(l[1])",
            "            result[\"name\"].append(l[2])",
            "            result[\"ratio\"].append(float(l[3][:-1]))",
            "            result[\"value\"].append(_float(l[4]))",
            "    return pd.DataFrame(result)",
            "",
            "",
            "class basicinfo(indicator):",
            "    \"\"\"",
            "    Base class for info of fund, index or even cash,",
            "    which cannot be directly instantiate, the basic implementation consider",
            "    redemption fee as zero when shuhui() function is implemented",
            "",
            "    :param code: string of code for specific product",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO. Or in sql case, path is the engine from sqlalchemy.",
            "    :param form: string, the format of IO, options including: 'csv','sql'",
            "    :param round_label: int, default 0 or 1, label to the different round scheme of shares, reserved for fundinfo class. 1 \u4ee3\u8868\u5168\u820d\u800c\u975e\u56db\u820d\u4e94\u5165\u3002",
            "    :param dividend_label: int, default 0 or 1. 0 \u4ee3\u8868\u9ed8\u8ba4\u73b0\u91d1\u5206\u7ea2\uff0c1\u4ee3\u8868\u7ea2\u5229\u518d\u6295\u3002\u4e24\u8005\u5747\u53ef\u901a\u8fc7\u8bb0\u8d26\u5355\u4e0a\u7684 0.05 \u6765\u6539\u53d8\u5355\u6b21\u7684\u9ed8\u8ba4\u3002",
            "    :param value_label: int, default 0 or 1. 1 \u4ee3\u8868\u8bb0\u8d26\u5355\u4e0a\u7684\u8d4e\u56de\u6570\u76ee\u662f\u6309\u91d1\u989d\u800c\u975e\u4efd\u989d\u7684\uff0c\u53ea\u80fd\u5b8c\u7f8e\u652f\u6301\u8d27\u5e01\u57fa\u91d1\u3002\u5176\u4ed6\u51c0\u503c\u578b\u57fa\u91d1\u672c\u8d28\u4e0a\u65e0\u6cd5\u7cbe\u786e\u5230\u5206\u652f\u6301\u8fd9\u4e00\u9009\u9879\uff0c\u56e0\u6b64\u4e0d\u5f00\u653e\u652f\u6301\u3002",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "        round_label=0,",
            "        dividend_label=0,",
            "        value_label=0,",
            "    ):",
            "        # \u589e\u91cf IO \u7684\u903b\u8f91\u90fd\u7531 basicinfo \u7c7b\u6765\u5904\u7406\uff0c\u5bf9\u4e8e\u5177\u4f53\u7684\u5b50\u7c7b\uff0c\u53ea\u9700\u5b9e\u73b0_save_form \u548c _fetch_form \u4ee5\u53ca update \u51fd\u6570\u5373\u53ef",
            "        self.code = code",
            "",
            "        self.round_label = round_label",
            "        self.dividend_label = dividend_label",
            "        self.value_label = value_label",
            "        self.specialdate = []",
            "        self.fenhongdate = []",
            "        self.zhesuandate = []",
            "",
            "        # compatible with new ``xa.set_backend()`` API",
            "        import xalpha.universal as xu",
            "",
            "        if (xu.ioconf[\"backend\"] in [\"csv\", \"sql\"]) and (not path):",
            "            fetch = True",
            "            save = True",
            "            form = xu.ioconf[\"backend\"]",
            "            path = xu.ioconf[\"path\"]",
            "            if xu.ioconf[\"backend\"] == \"csv\":",
            "                path = os.path.join(path, xu.ioconf[\"prefix\"] + \"INFO-\")",
            "        self.format = form",
            "        if fetch is False:",
            "            self._basic_init()  # update self. name rate and price table",
            "        else:",
            "            try:",
            "                self.fetch(path, self.format)",
            "                df = self.update()  # update the price table as well as the file",
            "                if (df is not None) and save is True:",
            "                    self.save(path, self.format, option=\"a\", delta=df)",
            "",
            "            except (FileNotFoundError, exc.ProgrammingError, exc.OperationalError) as e:",
            "                logger.info(\"no saved copy of %s\" % self.code)",
            "                fetch = False",
            "                self._basic_init()",
            "",
            "        if (save is True) and (fetch is False):",
            "            self.save(path, self.format)",
            "",
            "    def _basic_init(self):",
            "        \"\"\"",
            "        set self. name rate and price (dataframe) as well as other necessary attr of info()",
            "        \"\"\"",
            "        # below lines are just showcase, this function must be rewrite by child classes",
            "        # self.name = 'unknown'",
            "        # self.rate = 0",
            "        # self.price = pd.DataFrame(data={'date':[],'netvalue':[],'comment':[]})",
            "        raise NotImplementedError",
            "",
            "    def shengou(self, value, date, fee=None):",
            "        \"\"\"",
            "        give the realdate deltacash deltashare tuple based on purchase date and purchase amount",
            "        if the date is not a trade date, then the purchase would happen on the next trade day, if the date is",
            "        in the furture, then the trade date is taken as yesterday.",
            "",
            "        :param value: the money for purchase",
            "        :param date: string or object of date",
            "        :param fee: the rate for shengou, default None and info.rate will be used, ok for most cases",
            "        :returns: three elements tuple, the first is the actual dateobj of commit",
            "            the second is a negative float for cashin,",
            "            the third is a positive float for share increase",
            "        \"\"\"",
            "        if fee is None:",
            "            fee = self.rate",
            "        row = self.price[self.price[\"date\"] >= date].iloc[0]",
            "        share = _shengoucal(value, fee, row.netvalue, label=self.round_label + 1)[1]",
            "        return (row.date, -myround(value), share)",
            "",
            "    def shuhui(self, share, date, rem, value_label=None, fee=None):",
            "        \"\"\"",
            "        give the cashout considering redemption rates as zero.",
            "        if the date is not a trade date, then the purchase would happen on the next trade day, if the date is",
            "        in the furture, then the trade date is taken as yesterday.",
            "",
            "        :param share: float or int, number of shares to be sold. if value_label=1, its cash to be sold.",
            "        :param date: string or object of date",
            "        :param rem: positions with time list",
            "        :param value_label: default None, value_label will be chosen by info.value_label, determining",
            "                whether shuhui by share 0 or value 1. value_label = 0 will rewrite self.value_label = 1",
            "        :param fee: default None, determined automatically, suggested for most of the cases.",
            "                Otherwise 0.015 means 1.5% in shuhui, this is different than fee in shengou, where 1.5 is for 1.5% fee",
            "        :returns: three elements tuple, the first is dateobj",
            "            the second is a positive float for cashout,",
            "            the third is a negative float for share decrease",
            "        \"\"\"",
            "        if self.value_label == 0 or value_label == 0:",
            "            return self._shuhui_by_share(share, date, rem)",
            "        elif self.value_label == 1:  # \u6309\u91d1\u989d\u8d4e\u56de\uff0c\u4ec5\u652f\u6301\u65e0\u8d4e\u56de\u8d39\u7684\u8d27\u5e01\u57fa\u91d1",
            "            partprice = self.price[self.price[\"date\"] >= date]",
            "            if len(partprice) == 0:",
            "                row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "            else:",
            "                row = partprice.iloc[0]",
            "            share = share / row.netvalue",
            "            return self._shuhui_by_share(share, date, rem, fee=fee)",
            "",
            "    def _shuhui_by_share(self, share, date, rem, fee=None):",
            "        date = convert_date(date)",
            "        tots = sum([remitem[1] for remitem in rem if remitem[0] <= date])",
            "        if share > tots:",
            "            sh = tots",
            "        else:",
            "            sh = share",
            "        partprice = self.price[self.price[\"date\"] >= date]",
            "        if len(partprice) == 0:",
            "            row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "        else:",
            "            row = partprice.iloc[0]",
            "        value = myround(sh * row.netvalue)",
            "        if fee is not None:",
            "            value = (1 - fee) * value",
            "        return (",
            "            row.date,",
            "            value,",
            "            -myround(sh),",
            "        )  # TODO: \u8fd9\u91cc myround \u662f\u5426\u4e5f\u548c round_label \u6709\u5173\uff0c\u6709\u5f85\u8003\u8bc1",
            "",
            "    def info(self):",
            "        \"\"\"",
            "        print basic info on the class",
            "        \"\"\"",
            "        print(\"fund name: %s\" % self.name)",
            "        print(\"fund code: %s\" % self.code)",
            "        print(\"fund purchase fee: %s%%\" % self.rate)",
            "",
            "    def __repr__(self):",
            "        return self.name",
            "",
            "    def save(self, path, form=None, option=\"r\", delta=None):",
            "        \"\"\"",
            "        save info to files, this function is designed to redirect to more specific functions",
            "",
            "        :param path: string of the folder path prefix! or engine obj from sqlalchemy",
            "        :param form: string, option:'csv'",
            "        :param option: string, r for replace and a for append output",
            "        :param delta: if option is a, you have to specify the delta which is the incremental part of price table",
            "        \"\"\"",
            "        if form is None:",
            "            form = self.format",
            "        if form == \"csv\" and option == \"r\":",
            "            self._save_csv(path)",
            "        elif form == \"csv\" and option == \"a\":",
            "            self._save_csv_a(path, delta)",
            "        elif form == \"sql\" and option == \"r\":",
            "            self._save_sql(path)",
            "        elif form == \"sql\" and option == \"a\":",
            "            self._save_sql_a(path, delta)",
            "",
            "    def _save_csv_a(self, path, df):",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\",",
            "            mode=\"a\",",
            "            header=None,",
            "            index=False,",
            "            date_format=\"%Y-%m-%d\",",
            "        )",
            "",
            "    def _save_sql_a(self, path, df):",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, path, if_exists=\"append\", index=False",
            "        )",
            "",
            "    def fetch(self, path, form=None):",
            "        \"\"\"",
            "        fetch info from files",
            "",
            "        :param path: string of the folder path prefix! end with / in csv case;",
            "            engine from sqlalchemy.create_engine() in sql case.",
            "        :param form: string, option:'csv' or 'sql",
            "        \"\"\"",
            "        if form is None:",
            "            form = self.format",
            "        if form == \"csv\":",
            "            self._fetch_csv(path)",
            "        elif form == \"sql\":",
            "            self._fetch_sql(path)",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        \u5bf9\u7c7b\u7684\u4ef7\u683c\u8868\u8fdb\u884c\u589e\u91cf\u66f4\u65b0\uff0c\u5e76\u8fdb\u884c\u589e\u91cf\u5b58\u50a8\uff0c\u9002\u5408 fetch \u6253\u5f00\u7684\u60c5\u5f62",
            "",
            "        :returns: the incremental part of price table or None if no incremental part exsits",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class fundinfo(basicinfo):",
            "    \"\"\"",
            "    class for specific fund with basic info and every day values",
            "    \u6240\u83b7\u5f97\u7684\u57fa\u91d1\u51c0\u503c\u6570\u636e\u4e00\u822c\u622a\u6b62\u5230\u6628\u65e5\u3002\u4f46\u6ce8\u610fQDII\u57fa\u91d1\u7684\u51c0\u503c\u6570\u636e\u4f1a\u622a\u6b62\u7684\u66f4\u65e9\uff0c\u56e0\u6b64\u90e8\u5206\u65f6\u95f4\u9ed8\u8ba4\u6628\u65e5\u7684\u51fd\u6570\u53ef\u80fd\u51fa\u73b0\u95ee\u9898\uff0c",
            "    \u5904\u7406QDII\u57fa\u91d1\u65f6\uff0c\u9700\u8981\u989d\u5916\u6ce8\u610f\u3002",
            "",
            "    :param code: str, \u57fa\u91d1\u516d\u4f4d\u4ee3\u7801\u5b57\u7b26",
            "    :param round_label: integer 0 or 1, \u53d61\u8868\u793a\u57fa\u91d1\u7533\u8d2d\u65f6\u4efd\u989d\u76f4\u63a5\u820d\u6389\u5c0f\u6570\u70b9\u4e24\u4f4d\u4e4b\u540e\u3002\u5f53\u57fa\u91d1\u5904\u4e8e cons.droplist \u540d\u5355\u4e2d\u65f6\uff0c",
            "        label \u603b\u4f1a\u88ab\u81ea\u52a8\u8bbe\u7f6e\u4e3a1\u3002\u975e\u540d\u5355\u5185\u57fa\u91d1\u53ef\u4ee5\u663e\u5f0f\u4ee4 round_label=1.",
            "    :param dividend_label: int, default 0 or 1. 0 \u4ee3\u8868\u9ed8\u8ba4\u73b0\u91d1\u5206\u7ea2\uff0c1\u4ee3\u8868\u7ea2\u5229\u518d\u6295\u3002\u4e24\u8005\u5747\u53ef\u901a\u8fc7\u8bb0\u8d26\u5355\u4e0a\u7684 0.05 \u6765\u6539\u53d8\u5355\u6b21\u7684\u9ed8\u8ba4\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        round_label=0,",
            "        dividend_label=0,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "        priceonly=False,",
            "    ):",
            "        if round_label == 1 or (code in droplist):",
            "            label = 1  # the scheme of round down on share purchase",
            "        else:",
            "            label = 0",
            "        if code.startswith(\"F\") and code[1:].isdigit():",
            "            code = code[1:]",
            "        elif code.startswith(\"M\") and code[1:].isdigit():",
            "            raise FundTypeError(",
            "                \"This code seems to be a mfund, use ``mfundinfo`` instead\"",
            "            )",
            "        code = code.zfill(6)  # 1234 is the same as 001234",
            "        self._url = (",
            "            \"http://fund.eastmoney.com/pingzhongdata/\" + code + \".js\"",
            "        )  # js url api for info of certain fund",
            "        self._feeurl = (",
            "            \"http://fund.eastmoney.com/f10/jjfl_\" + code + \".html\"",
            "        )  # html url for trade fees info of certain fund",
            "        self.priceonly = priceonly",
            "",
            "        super().__init__(",
            "            code,",
            "            fetch=fetch,",
            "            save=save,",
            "            path=path,",
            "            form=form,",
            "            round_label=label,",
            "            dividend_label=dividend_label,",
            "        )",
            "",
            "        self.special = self.price[self.price[\"comment\"] != 0]",
            "        self.specialdate = list(self.special[\"date\"])",
            "        # date with nonvanishing comment, usually fenhong or zhesuan",
            "        try:",
            "            self.fenhongdate = list(self.price[self.price[\"comment\"] > 0][\"date\"])",
            "            self.zhesuandate = list(self.price[self.price[\"comment\"] < 0][\"date\"])",
            "        except TypeError:",
            "            print(\"There are still string comments for the fund!\")",
            "",
            "    def _basic_init(self):",
            "        if self.code.startswith(\"96\"):",
            "            self._hkfund_init()  # \u4e2d\u6e2f\u4e92\u8ba4\u57fa\u91d1\u5904\u7406",
            "            return",
            "        self._page = rget(self._url)",
            "        if self._page.status_code == 404:",
            "            raise ParserFailure(\"Unrecognized fund, please check fund code you input.\")",
            "        if self._page.text[:800].find(\"Data_millionCopiesIncome\") >= 0:",
            "            raise FundTypeError(\"This code seems to be a mfund, use mfundinfo instead\")",
            "",
            "        l = re.match(",
            "            r\"[\\s\\S]*Data_netWorthTrend = ([^;]*);[\\s\\S]*\", self._page.text",
            "        ).groups()[0]",
            "        l = l.replace(\"null\", \"None\")  # \u6682\u672a\u53d1\u73b0\u57fa\u91d1\u51c0\u503c\u6709 null \u7684\u57fa\u91d1\uff0c\u82e5\u6709\uff0c\u5176\u4ed6\u5730\u65b9\u4e5f\u5f88\u53ef\u80fd\u51fa\u95ee\u9898\uff01",
            "        l = eval(l)",
            "        ltot = re.match(",
            "            r\"[\\s\\S]*Data_ACWorthTrend = ([^;]*);[\\s\\S]*\", self._page.text",
            "        ).groups()[",
            "            0",
            "        ]  # .* doesn't match \\n",
            "        ltot = ltot.replace(\"null\", \"None\")  ## 096001 \u603b\u503c\u6570\u636e\u4e2d\u6709 null\uff01",
            "        ltot = eval(ltot)",
            "        ## timestamp transform tzinfo must be taken into consideration",
            "        tz_bj = dt.timezone(dt.timedelta(hours=8))",
            "        infodict = {",
            "            \"date\": [",
            "                dt.datetime.fromtimestamp(int(d[\"x\"]) / 1e3, tz=tz_bj).replace(",
            "                    tzinfo=None",
            "                )",
            "                for d in l",
            "            ],",
            "            \"netvalue\": [float(d[\"y\"]) for d in l],",
            "            \"comment\": [_nfloat(d[\"unitMoney\"]) for d in l],",
            "        }",
            "",
            "        if len(l) == len(ltot):  # \u9632\u6b62\u603b\u503c\u548c\u51c0\u503c\u6570\u636e\u91cf\u4e0d\u5339\u914d\uff0c\u5df2\u77e5\u6709\u8be5\u95ee\u9898\u7684\u57fa\u91d1\uff1a502010",
            "            infodict[\"totvalue\"] = [d[1] for d in ltot]",
            "",
            "        try:",
            "            rate = float(",
            "                eval(",
            "                    re.match(",
            "                        r\"[\\s\\S]*fund_Rate=([^;]*);[\\s\\S]*\", self._page.text",
            "                    ).groups()[0]",
            "                )",
            "            )",
            "        except ValueError:",
            "            rate = 0",
            "            logger.info(\"warning: this fund has no data for rate\")  # know cases: ETF",
            "",
            "        name = eval(",
            "            re.match(r\"[\\s\\S]*fS_name = ([^;]*);[\\s\\S]*\", self._page.text).groups()[0]",
            "        )",
            "",
            "        self.rate = rate",
            "        # shengou rate in tiantianjijin, daeshengou rate discount is not considered",
            "        self.name = name  # the name of the fund",
            "        df = pd.DataFrame(data=infodict)",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        if len(df) == 0:",
            "            raise ParserFailure(\"no price table found for this fund %s\" % self.code)",
            "        self.price = df[df[\"date\"] <= yesterdaydash()]",
            "        # deal with the redemption fee attrs finally",
            "        if not self.priceonly:",
            "            self._feepreprocess()",
            "",
            "    def _feepreprocess(self):",
            "        \"\"\"",
            "        Preprocess to add self.feeinfo and self.segment attr according to redemption fee info",
            "        \"\"\"",
            "        feepage = rget(self._feeurl)",
            "        soup = BeautifulSoup(",
            "            feepage.text, \"lxml\"",
            "        )  # parse the redemption fee html page with beautiful soup",
            "        somethingwrong = False",
            "        if not soup.findAll(\"a\", {\"name\": \"shfl\"}):",
            "            somethingwrong = True",
            "            logger.warning(\"%s \u57fa\u91d1\u8d4e\u56de\u4fe1\u606f\u4e3a\u7a7a\uff0c\u53ef\u80fd\u7531\u4e8e\u8be5\u57fa\u91d1\u5df2\u7ec8\u6b62\u8fd0\u4f5c\" % self.code)",
            "            self.feeinfo = []",
            "        else:",
            "            self.feeinfo = [",
            "                item.string",
            "                for item in soup.findAll(\"a\", {\"name\": \"shfl\"})[",
            "                    0",
            "                ].parent.parent.next_sibling.next_sibling.find_all(\"td\")",
            "                if item.string != \"---\"",
            "            ]",
            "        # this could be [], known case 510030",
            "",
            "        if not self.feeinfo or len(self.feeinfo) % 2 != 0:",
            "            somethingwrong = True",
            "        else:",
            "            for item in self.feeinfo:",
            "                if \"\u5f00\u653e\u671f\" in item or \"\u5c01\u95ed\" in item or \"\u5f00\u653e\u65e5\u671f\" in item or \"\u8fd0\u4f5c\u671f\" in item:",
            "                    # \u6682\u65f6\u6ca1\u6709\u5b8c\u7f8e\u7ef4\u62a4\u5b9a\u5f00\u57fa\u91d1\u8d4e\u56de\u8d39\u5904\u7406\u7684\u8ba1\u5212",
            "                    somethingwrong = True",
            "        if somethingwrong:",
            "            logger.warning(",
            "                \"%s \u8d4e\u56de\u8d39\u4fe1\u606f\u5f02\u5e38\uff0c\u591a\u662f\u56e0\u4e3a\u5b9a\u5f00\u57fa\u91d1\uff0c\u5c01\u95ed\u57fa\u91d1\u6216\u573a\u5185 ETF: %s\" % (self.code, self.feeinfo)",
            "            )",
            "            self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"1.50%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]",
            "        # print(self.feeinfo)",
            "        try:",
            "            self.segment = fundinfo._piecewise(self.feeinfo)",
            "        except (ValueError, IndexError) as e:",
            "            logger.warning(",
            "                \"%s \u8d4e\u56de\u8d39\u4fe1\u606f\u6293\u53d6\u5f02\u5e38\uff0c\u8bf7\u624b\u52a8\u8bbe\u5b9a ``self.segment`` \u548c ``self.feeinfo``: %s\"",
            "                % (self.code, self.feeinfo)",
            "            )",
            "            # below is default one",
            "            self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"1.50%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]",
            "            self.segment = fundinfo._piecewise(self.feeinfo)",
            "",
            "    @staticmethod",
            "    def _piecewise(a):",
            "        \"\"\"",
            "        Transform the words list into a pure number segment list for redemption fee, eg. [[0,7],[7,365],[365]]",
            "        \"\"\"",
            "",
            "        b = [",
            "            (",
            "                a[2 * i]",
            "                .replace(\"\u6301\u6709\u671f\u9650\", \"\")",
            "                .replace(\"\u5f00\u653e\u8fd0\u4f5c\u671f\u65f6\u6301\u6709\", \"\")",
            "                .replace(\"\u4e0d\u5c11\u4e8e\", \"\")",
            "                .replace(\"\u5c0f\u4e8e\", \"\")",
            "                .replace(\"\u5927\u4e8e\", \"\")",
            "                .replace(\"\u7b49\u4e8e\", \"\")",
            "                .replace(\"\u4e2a\", \"\")",
            "                .replace(\"\u6301\u6709\", \"\")",
            "                .replace(\"\u4ee5\u4e0a\", \"\")",
            "                .replace(\"\u4ee5\u5185\", \"\")",
            "                .replace(\"\u7684\", \"\")",
            "                .replace(\"(\u542b7\u5929)\", \"\")",
            "                .replace(\"\u4efd\u989d\u6301\u6709\u65f6\u95f4\", \"\")",
            "            ).split(\"\uff0c\")",
            "            for i in range(int(len(a) / 2))",
            "        ]",
            "        # ['\u8d4e\u56de\u65f6\u4efd\u989d\u6301\u67097\u5929\u4ee5\u5185\u7684', '1.50%', '\u6301\u67097\u5929\u4ee5\u4e0a(\u542b7\u5929),30\u5929\u4ee5\u5185\u7684', '0.10%', '\u8d4e\u56de\u65f6\u4efd\u989d\u6301\u6709\u6ee130\u5929\u4ee5\u4e0a(\u542b30\u5929)\u7684', '0.00%']",
            "        # ['\u7531\u4e8e\u672c\u57fa\u91d1\u6700\u77ed\u6301\u6709\u671f\u9650\u4e3a\u4e09\u5e74,\u8d4e\u56de\u8d39\u7387\u8bbe\u7f6e\u4e3a\u96f6\u3002', '0.00%', '\u5bf9\u6301\u7eed\u6301\u6709\u671f\u5c11\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u6536\u53d6\u4e0d\u4f4e\u4e8e1.5%\u7684\u8d4e\u56de\u8d39\u3002', '1.50%']",
            "        #  ['\u5bf9\u6301\u7eed\u6301\u6709\u671f\u5c11\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u6536\u53d61.5%\u7684\u8d4e\u56de\u8d39\u5e76\u5168\u989d\u8ba1\u5165\u57fa\u91d1\u8d22\u4ea7', '1.50%', '\u5bf9\u4e8e\u6301\u7eed\u6301\u6709\u671f\u5927\u4e8e\u7b49\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u4e0d\u6536\u53d6\u8d4e\u56de\u8d39\u7528\u3002', '0.00%']",
            "        # print(b)",
            "        for j, tem in enumerate(b):",
            "            for i, num in enumerate(tem):",
            "                if num[-1] == \"\u5929\":",
            "                    num = int(num[:-1])",
            "                elif num[-1] == \"\u6708\":",
            "                    num = int(num[:-1]) * 30",
            "                elif num == \".5\u5e74\":",
            "                    num = 183",
            "                else:",
            "                    num = int(float(num[:-1]) * 365)",
            "                b[j][i] = num",
            "        if len(b[0]) == 1:  # \u6709\u65f6\u8d4e\u56de\u8d39\u4f1a\u5199\u5927\u4e8e\u7b49\u4e8e\u4e00\u5929",
            "            b[0].insert(0, 0)",
            "        elif len(b[0]) == 2:",
            "            b[0][0] = 0",
            "        else:",
            "            print(_warnmess)",
            "        for i in range(len(b) - 1):  # \u6709\u65f6\u8d4e\u56de\u8d39\u4e24\u533a\u95f4\u90fd\u662f\u95ed\u533a\u95f4",
            "            if b[i][1] - b[i + 1][0] == -1:",
            "                b[i][1] = b[i + 1][0]",
            "            elif b[i][1] == b[i + 1][0]:",
            "                pass",
            "            else:",
            "                print(_warnmess)",
            "",
            "        return b",
            "",
            "    def feedecision(self, day):",
            "        \"\"\"",
            "        give the redemption rate in percent unit based on the days difference between purchase and redemption",
            "",
            "        :param day: integer\uff0c \u8d4e\u56de\u4e0e\u7533\u8d2d\u65f6\u95f4\u4e4b\u5dee\u7684\u81ea\u7136\u65e5\u6570",
            "        :returns: float\uff0c\u8d4e\u56de\u8d39\u7387\uff0c\u4ee5\uff05\u4e3a\u5355\u4f4d",
            "        \"\"\"",
            "        i = -1",
            "        for seg in self.segment:",
            "            i += 2",
            "            if day - seg[0] >= 0 and (len(seg) == 1 or day - seg[-1] < 0):",
            "                return float(self.feeinfo[i].strip(\"%\"))",
            "        return 0  # error backup, in case there is sth wrong in segment",
            "",
            "    def set_feeinfo(self, feeinfo):",
            "        \"\"\"",
            "        \u8bbe\u7f6e\u6b63\u786e\u7684\u8d4e\u56de\u8d39\u7387\u4fe1\u606f",
            "",
            "        :param feeinfo: List[string]",
            "        \"\"\"",
            "        self.feeinfo = feeinfo",
            "        self.segment = self._piecewise(feeinfo)",
            "",
            "    def set_price(self, col, date, value):",
            "        \"\"\"",
            "        \u8bbe\u7f6e\u4fee\u6b63 price \u8868\u4e2d\u5355\u65e5\u7684 comment \u6216\u4ef7\u683c\u4fe1\u606f",
            "",
            "        :param col: str. \"comment\", \"netvalue\" or \"totvalue\"",
            "        :param date: \u201c%Y%m%d\u201d",
            "        :param value:",
            "        \"\"\"",
            "        self.price.loc[self.price[\"date\"] == date, col] = value",
            "        ## update special in case new comment is added",
            "        self.special = self.price[self.price[\"comment\"] != 0]",
            "        self.specialdate = list(self.special[\"date\"])",
            "",
            "    def shuhui(self, share, date, rem, value_label=None, fee=None):",
            "        \"\"\"",
            "        give the cashout based on rem term considering redemption rates",
            "",
            "        :returns: three elements tuple, the first is dateobj",
            "            the second is a positive float for cashout,",
            "            the third is a negative float for share decrease",
            "        \"\"\"",
            "        # \t\t value = myround(share*self.price[self.price['date']==date].iloc[0].netvalue)",
            "        date = convert_date(date)",
            "        partprice = self.price[self.price[\"date\"] >= date]",
            "        if len(partprice) == 0:",
            "            row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "        else:",
            "            row = partprice.iloc[0]",
            "        soldrem, _ = rm.sell(rem, share, row.date)",
            "        value = 0",
            "        sh = myround(sum([item[1] for item in soldrem]))",
            "        for d, s in soldrem:",
            "            if fee is None:",
            "                tmpfee = self.feedecision((row.date - d).days) * 1e-2",
            "            else:",
            "                tmpfee = fee",
            "            value += myround(",
            "                s * row.netvalue * (1 - tmpfee)",
            "            )  # TODO: round_label whether play a role here?",
            "        return (row.date, value, -sh)",
            "",
            "    def info(self):",
            "        super().info()",
            "        print(\"fund redemption fee info: %s\" % self.feeinfo)",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        s = json.dumps(",
            "            {",
            "                \"feeinfo\": self.feeinfo,",
            "                \"name\": self.name,",
            "                \"rate\": self.rate,",
            "                \"segment\": self.segment,",
            "            }",
            "        )",
            "        df = pd.DataFrame(",
            "            [[s, 0, 0, 0]], columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"]",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_csv(path + self.code + \".csv\")",
            "            pricetable = content.iloc[1:]",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "            saveinfo = json.loads(content.iloc[0].date)",
            "            if not isinstance(saveinfo, dict):",
            "                raise FundTypeError(\"This csv doesn't looks like from fundinfo\")",
            "            self.segment = saveinfo[\"segment\"]",
            "            self.feeinfo = saveinfo[\"feeinfo\"]",
            "            self.name = saveinfo[\"name\"]",
            "            self.rate = saveinfo[\"rate\"]",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of fund %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        s = json.dumps(",
            "            {",
            "                \"feeinfo\": self.feeinfo,",
            "                \"name\": self.name,",
            "                \"rate\": self.rate,",
            "                \"segment\": self.segment,",
            "            }",
            "        )",
            "        df = pd.DataFrame(",
            "            [[pd.Timestamp(\"1990-01-01\"), 0, s, 0]],",
            "            columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"],",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_sql(\"xa\" + self.code, path)",
            "            pricetable = content.iloc[1:]",
            "            commentl = [float(com) for com in pricetable.comment]",
            "            self.price = pricetable[[\"date\", \"netvalue\", \"totvalue\"]]",
            "            self.price[\"comment\"] = commentl",
            "            saveinfo = json.loads(content.iloc[0].comment)",
            "            if not isinstance(saveinfo, dict):",
            "                raise FundTypeError(\"This csv doesn't looks like from fundinfo\")",
            "            self.segment = saveinfo[\"segment\"]",
            "            self.feeinfo = saveinfo[\"feeinfo\"]",
            "            self.name = saveinfo[\"name\"]",
            "            self.rate = saveinfo[\"rate\"]",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _hk_update(self):",
            "        # \u6682\u65f6\u4e0d\u786e\u5b9a\u589e\u91cf\u66f4\u65b0\u903b\u8f91\u65e0 bug\uff0c\u9700\u65f6\u95f4\u9a8c\u8bc1",
            "        # \u6ce8\u610f\u589e\u91cf\u66f4\u65b0\u65f6\u5206\u7ea2\u7684\u540c\u6b65\u66f4\u65b0",
            "        lastdate = self.price.iloc[-1].date",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if diffdays == 0:",
            "            return None",
            "        import xalpha.universal as xu",
            "",
            "        df = xu.get_daily(\"F\" + self.code, start=lastdate.strftime(\"%Y%m%d\"))",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        df = df[df[\"date\"] > lastdate]",
            "",
            "        if len(df) != 0:",
            "            r = self._hk_bonus(start=lastdate.strftime(\"%Y-%m-%d\"))",
            "            df[\"comment\"] = [0 for _ in range(len(df))]",
            "            df[\"netvalue\"] = df[\"close\"]",
            "            df = df.drop(\"close\", axis=1)",
            "            df = df[df[\"date\"].isin(opendate)]  # ? \u662f\u5426\u4f1a\u8fc7\u6ee4\u6389\u5206\u7ea2\u65e5",
            "            for d in r:",
            "                df.loc[df[\"date\"] == d[\"EXDDATE\"], \"comment\"] = d[\"BONUS\"]",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        function to incrementally update the pricetable after fetch the old one",
            "        \"\"\"",
            "        if self.code.startswith(\"96\"):",
            "            return self._hk_update()",
            "        lastdate = self.price.iloc[-1].date",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if (",
            "            diffdays == 0",
            "        ):  ## for some QDII, this value is 1, anyways, trying update is compatible (d+2 update)",
            "            return None",
            "        self._updateurl = (",
            "            \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "            + self.code",
            "            + \"&page=1&per=1\"",
            "        )",
            "        con = rget(self._updateurl)",
            "        soup = BeautifulSoup(con.text, \"lxml\")",
            "        items = soup.findAll(\"td\")",
            "        if dt.datetime.strptime(str(items[0].string), \"%Y-%m-%d\") == today_obj():",
            "            diffdays += 1",
            "        if diffdays <= 10:",
            "            self._updateurl = (",
            "                \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                + self.code",
            "                + \"&page=1&per=\"",
            "                + str(diffdays)",
            "            )",
            "            con = rget(self._updateurl)",
            "            soup = BeautifulSoup(con.text, \"lxml\")",
            "            items = soup.findAll(\"td\")",
            "        elif (",
            "            diffdays > 10",
            "        ):  ## there is a 20 item per page limit in the API, so to be safe, we query each page by 10 items only",
            "            items = []",
            "            for pg in range(1, int(diffdays / 10) + 2):",
            "                self._updateurl = (",
            "                    \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                    + self.code",
            "                    + \"&page=\"",
            "                    + str(pg)",
            "                    + \"&per=10\"",
            "                )",
            "                con = rget(self._updateurl)",
            "                soup = BeautifulSoup(con.text, \"lxml\")",
            "                items.extend(soup.findAll(\"td\"))",
            "        else:",
            "            raise TradeBehaviorError(",
            "                \"Weird incremental update: the saved copy has future records\"",
            "            )",
            "",
            "        date = []",
            "        netvalue = []",
            "        totvalue = []",
            "        comment = []",
            "        for i in range(int(len(items) / 7)):",
            "            ts = pd.Timestamp(str(items[7 * i].string))",
            "            if (ts - lastdate).days > 0:",
            "                date.append(ts)",
            "                netvalue.append(_float(items[7 * i + 1].string))",
            "                totvalue.append(_float(items[7 * i + 2].string))",
            "                comment.append(_nfloat(items[7 * i + 6].string))",
            "            else:",
            "                break",
            "        df = pd.DataFrame(",
            "            {",
            "                \"date\": date,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": totvalue,",
            "                \"comment\": comment,",
            "            }",
            "        )",
            "        df = df.iloc[::-1]  ## reverse the time order",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        if len(df) != 0:",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "    def get_holdings(self, year=\"\", season=\"\", month=\"\", category=\"stock\"):",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=category",
            "        )",
            "",
            "    def get_stock_holdings(self, year=\"\", season=\"\", month=\"\"):",
            "        \"\"\"",
            "        \u6301\u4ed3\u4e2a\u80a1\u7ec6\u8282",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :return: pd.DataFrame",
            "        \"\"\"",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=\"stock\"",
            "        )",
            "",
            "    def get_bond_holdings(self, year=\"\", season=\"\", month=\"\"):",
            "        \"\"\"",
            "        \u6301\u4ed3\u503a\u5238\u7ec6\u8282",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :return: pd.DataFrame",
            "        \"\"\"",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=\"bond\"",
            "        )",
            "",
            "    def get_portfolio_holdings(self, date=None):",
            "        \"\"\"",
            "        \u6301\u4ed3\u80a1\u503a\u73b0\u91d1\u5360\u6bd4",
            "",
            "        :param date:",
            "        :return: Dict",
            "        \"\"\"",
            "        if date is None:",
            "            date = dt.datetime.now().strftime(\"%Y-%m-%d\")",
            "        import xalpha.universal as xu",
            "",
            "        df = xu.get_daily(\"pt-F\" + self.code, end=date)",
            "        if df is not None:",
            "            d = dict(df.iloc[-1])",
            "            del d[\"assets\"], d[\"date\"]",
            "            return d",
            "        else:",
            "            logger.warning(\"no portfolio information before %s\" % date)",
            "            return",
            "",
            "    def get_industry_holdings(self, year=\"\", season=\"\", month=\"\", threhold=0.5):",
            "        \"\"\"",
            "        \u6301\u4ed3\u884c\u4e1a\u5360\u6bd4",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :param threhold: float, \u6301\u4ed3\u5c0f\u4e8e\u8be5\u767e\u5206\u6570\u7684\u4e2a\u80a1\u884c\u4e1a\u4e0d\u518d\u7edf\u8ba1\uff0c\u52a0\u5feb\u901f\u5ea6",
            "        :return:  Dict",
            "        \"\"\"",
            "        # \u6ce8\u610f\u8be5 API \u672a\u76f4\u63a5\u4f7f\u7528\u5929\u5929\u57fa\u91d1\u7684\u884c\u4e1a\u6570\u636e\uff0c\u5176\u6570\u636e\u884c\u4e1a\u5212\u5206\u6bd4\u8f83\u5947\u602a\uff0c\u5927\u91cf\u884c\u4e1a\u90fd\u5212\u5206\u8fdb\u4e86\u7b3c\u7edf\u7684\u5236\u9020\u4e1a\uff0c",
            "        # \u7528\u4e8e\u5206\u6790\u4ee3\u8868\u6027\u4e0d\u5f3a\uff0c\u751a\u81f3\u6ca1\u6709\u6d88\u8d39\uff0c\u533b\u836f\u7b49\u884c\u4e1a\u5212\u5206\u65b9\u5f0f",
            "",
            "        from xalpha.universal import ttjjcode, get_industry_fromxq",
            "",
            "        df = self.get_stock_holdings(year=year, season=season, month=month)",
            "        if df is None:",
            "            logger.warning(",
            "                \"%s has no stock holdings in %s y %s s. (Possible reason: \u94fe\u63a5\u57fa\u91d1\uff0c\u503a\u5238\u57fa\u91d1)\"",
            "                % (self.code, year, season)",
            "            )",
            "            return",
            "        d = {}",
            "        for i, row in df.iterrows():",
            "            if row[\"ratio\"] < threhold:",
            "                continue",
            "            code = ttjjcode(row[\"code\"])",
            "            industry = get_industry_fromxq(code)[\"industryname\"]",
            "            if not industry.strip():",
            "                logger.warning(",
            "                    \"%s has no industry information, cannot be classfied\" % code",
            "                )",
            "            else:",
            "                if industry not in d:",
            "                    d[industry] = 0",
            "                d[industry] += row[\"ratio\"]",
            "        return d",
            "",
            "    def which_industry(self, threhold=1.0):",
            "        \"\"\"",
            "        Experimental API",
            "        \u5f53\u5355\u4e00\u884c\u4e1a\u5360\u6bd4\u8f83\u5176\u4ed6\u884c\u4e1a\u7684 threhold \u500d\u8fd8\u591a\u65f6\uff0c\u81ea\u52a8\u5224\u5b9a\u4e3a\u5bf9\u5e94\u7684\u884c\u4e1a\u57fa\u91d1",
            "        \u6ce8\u610f\u8fd9\u91cc\u7684\u884c\u4e1a\u53ef\u80fd\u6bd4\u8f83\u7ec6\u5206\uff0c\u5bfc\u81f4\u6301\u4ed3\u591a\u4e2a\u884c\u4e1a\u5176\u5b9e\u662f\u540c\u4e00\u5927\u884c\u4e1a\u4ece\u800c\u8bef\u5224\u4e3a\u5bbd\u57fa\u57fa\u91d1\u7684\u53ef\u80fd",
            "",
            "        :param threhold: float",
            "        :return: str",
            "        \"\"\"",
            "        d = self.get_industry_holdings()",
            "        l = sorted([(k, v) for k, v in d.items()], key=lambda s: -s[1])",
            "        s0 = 0",
            "        if l and l[0] and l[0][1]:",
            "            s0 = l[0][1]",
            "        s1 = sum([l[i][1] for i in range(1, len(l))])",
            "        if s0 > threhold * s1:",
            "            return \"\u884c\u4e1a\u57fa\u91d1\uff1a \" + l[0][0]",
            "        else:",
            "            return \"\u5bbd\u57fa\u57fa\u91d1\"",
            "",
            "    def _hkfund_init(self):",
            "        import xalpha.universal as xu",
            "",
            "        # \u4e92\u8ba4\u57fa\u91d1\u56fd\u5185\u4f11\u5e02\u65e5\u4e5f\u6709\u51c0\u503c\uff0c\u6682\u65f6\u8fc7\u6ee4\uff0c\u4e0d\u786e\u5b9a\u662f\u5426\u4f1a\u5f15\u8d77\u517c\u5bb9\u6027\u95ee\u9898",
            "        self.meta = xu.get_rt(\"F\" + self.code)",
            "        self.start = self.meta[\"startdate\"]",
            "        self.name = self.meta[\"name\"]",
            "        self.price = xu.get_daily(\"F\" + self.code, start=self.start)",
            "        self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"0.00%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]  # \u4f3c\u4e4e\u8be5\u7c7b\u578b\u57fa\u91d1\u90fd\u4e0d\u6536\u53d6\u8d4e\u56de\u8d39",
            "        self.segment = fundinfo._piecewise(self.feeinfo)",
            "        r = rget(\"http://overseas.1234567.com.cn/f10/FundSaleInfo/968012#SaleInfo\")",
            "        b = BeautifulSoup(r.text, \"lxml\")",
            "        self.rate = _float(",
            "            [",
            "                c.strip()",
            "                for c in b.select(\".HK_Fund_Table.BigText\")[5].text.split(\"\\n\")",
            "                if c.strip()",
            "            ][-1]",
            "            .split(\"|\")[-1]",
            "            .strip()[:-1]",
            "        )",
            "        r = self._hk_bonus()",
            "        df = self.price",
            "        df[\"comment\"] = [0 for _ in range(len(df))]",
            "        df[\"netvalue\"] = df[\"close\"]",
            "        df[\"date\"] = pd.to_datetime(df[\"date\"])",
            "        df = df[df[\"date\"].isin(opendate)]  # ? \u662f\u5426\u4f1a\u8fc7\u6ee4\u6389\u5206\u7ea2\u65e5",
            "        for d in r:",
            "            df.loc[df[\"date\"] == d[\"EXDDATE\"], \"comment\"] = d[\"BONUS\"]",
            "        df = df.drop(\"close\", axis=1)",
            "        self.price = df",
            "",
            "    def _hk_bonus(self, start=None):",
            "        \"\"\"",
            "        [summary]",
            "",
            "        :param start: \"%Y-%m-%d\", defaults to None",
            "        :type start: [type], optional",
            "        \"\"\"",
            "        import xalpha.universal as xu",
            "",
            "        todaydash = today_obj().strftime(\"%Y-%m-%d\")",
            "        if not start:",
            "            start = self.price.iloc[0][\"date\"].strftime(\"%Y-%m-%d\")",
            "        pagesize = int(",
            "            (today_obj() - dt.datetime.strptime(start, \"%Y-%m-%d\")).days / 5",
            "        )  # \u5982\u679c\u5b58\u5728\u4e00\u5468\u8d85\u8fc7\u4e00\u6b21\u5206\u7ea2\u7684\u57fa\u91d1\uff0c\u7b97\u6211\u6ca1\u8bf4",
            "        self.hkfcode = xu.get_hkfcode(self.code)",
            "        r = rget_json(",
            "            \"http://overseas.1234567.com.cn/overseasapi/OpenApiHander.ashx?\\",
            "api=HKFDApi&m=MethodJZ&hkfcode={hkfcode}&action=3&pageindex=0&pagesize={pagesize}&date1={startdash}&date2={enddash}&callback=\".format(",
            "                hkfcode=self.hkfcode,",
            "                pagesize=pagesize,",
            "                startdash=start,",
            "                enddash=todaydash,",
            "            )",
            "        )",
            "        return r[\"Data\"]",
            "",
            "",
            "class indexinfo(basicinfo):",
            "    \"\"\"",
            "    Get everyday close price of specific index.",
            "    In self.price table, totvalue column is the real index",
            "    while netvalue comlumn is normalized to 1 for the start date.",
            "    In principle, this class can also be used to save stock prices but the price is without adjusted.",
            "",
            "    :param code: string with seven digitals! note the code here has an extra digit at the beginning,",
            "        0 for sh and 1 for sz.",
            "    :param value_label: int, default 0 or 1. If set to 1, \u8bb0\u8d26\u5355\u6570\u5b57\u6309\u91d1\u989d\u8d4e\u56de\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, code, value_label=0, fetch=False, save=False, path=\"\", form=\"csv\"",
            "    ):",
            "        date = yesterday()",
            "        if code.startswith(\"SH\") and code[2:].isdigit():",
            "            code = \"0\" + code[2:]",
            "        elif code.startswith(\"SZ\") and code[2:].isdigit():",
            "            code = \"1\" + code[2:]",
            "        self.rate = 0",
            "        self._url = (",
            "            \"http://quotes.money.163.com/service/chddata.html?code=\"",
            "            + code",
            "            + \"&start=19901219&end=\"",
            "            + date",
            "            + \"&fields=TCLOSE\"",
            "        )",
            "        super().__init__(",
            "            code, value_label=value_label, fetch=fetch, save=save, path=path, form=form",
            "        )",
            "",
            "    def _basic_init(self):",
            "        raw = rget(self._url)",
            "        raw.encoding = \"gbk\"",
            "        cr = csv.reader(raw.text.splitlines(), delimiter=\",\")",
            "        my_list = list(cr)",
            "        factor = float(my_list[-1][3])",
            "        dd = {",
            "            \"date\": [",
            "                dt.datetime.strptime(my_list[i + 1][0], \"%Y-%m-%d\")",
            "                for i in range(len(my_list) - 1)",
            "            ],",
            "            \"netvalue\": [",
            "                float(my_list[i + 1][3]) / factor for i in range(len(my_list) - 1)",
            "            ],",
            "            \"totvalue\": [float(my_list[i + 1][3]) for i in range(len(my_list) - 1)],",
            "            \"comment\": [0 for _ in range(len(my_list) - 1)],",
            "        }",
            "        index = pd.DataFrame(data=dd)",
            "        index = index.iloc[::-1]",
            "        index = index.reset_index(drop=True)",
            "        self.price = index[index[\"date\"].isin(opendate)]",
            "        self.price = self.price[self.price[\"date\"] <= yesterdaydash()]",
            "        self.name = my_list[-1][2]",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        self.price.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            pricetable = pd.read_csv(path + self.code + \".csv\")",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        self.price.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            pricetable = pd.read_sql(\"xa\" + self.code, path)",
            "            self.price = pricetable",
            "",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def update(self):",
            "        lastdate = self.price.iloc[-1].date",
            "        lastdatestr = lastdate.strftime(\"%Y%m%d\")",
            "        weight = self.price.iloc[1].totvalue",
            "        self._updateurl = (",
            "            \"http://quotes.money.163.com/service/chddata.html?code=\"",
            "            + self.code",
            "            + \"&start=\"",
            "            + lastdatestr",
            "            + \"&end=\"",
            "            + yesterday()",
            "            + \"&fields=TCLOSE\"",
            "        )",
            "        try:",
            "            df = pd.read_csv(self._updateurl, encoding=\"gb2312\")",
            "            # 163 source is failing now",
            "        except Exception:",
            "            raise ValueError(",
            "                \"don't use indexinfo currently, see \\",
            "            https://github.com/refraction-ray/xalpha/issues/133#issuecomment-865447292\"",
            "            )",
            "        self.name = df.iloc[0].loc[\"\u540d\u79f0\"]",
            "        if len(df) > 1:",
            "            df = df.rename(columns={\"\u6536\u76d8\u4ef7\": \"totvalue\"})",
            "            df[\"date\"] = pd.to_datetime(df.\u65e5\u671f)",
            "            df = df.drop([\"\u80a1\u7968\u4ee3\u7801\", \"\u540d\u79f0\", \"\u65e5\u671f\"], axis=1)",
            "            df[\"netvalue\"] = df.totvalue / weight",
            "            df[\"comment\"] = [0 for _ in range(len(df))]",
            "            df = df.iloc[::-1].iloc[1:]",
            "            df = df[df[\"date\"].isin(opendate)]",
            "            df = df.reset_index(drop=True)",
            "            df = df[df[\"date\"] <= yesterdayobj()]",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "",
            "class cashinfo(basicinfo):",
            "    \"\"\"",
            "    A virtual class for remaining cash manage: behave like monetary fund",
            "",
            "    :param interest: float, daily rate in the unit of 100%, note this is not a year return rate!",
            "    :param start: str of date or dateobj, the virtual starting date of the cash fund",
            "    :param value_label: int, default 0 or 1. If set to 1, \u8bb0\u8d26\u5355\u6570\u5b57\u6309\u91d1\u989d\u8d4e\u56de\u3002",
            "    \"\"\"",
            "",
            "    def __init__(self, interest=0.0001, start=\"2012-01-01\", value_label=0):",
            "        self.interest = interest",
            "        start = convert_date(start)",
            "        self.start = start",
            "        super().__init__(",
            "            \"mf\", value_label=value_label, fetch=False, save=False, path=\"nobackend\"",
            "        )  # \u6c38\u8fdc\u4e0d\u7f13\u5b58 cashinfo",
            "",
            "    def _basic_init(self):",
            "        self.name = \"\u8d27\u5e01\u57fa\u91d1\"",
            "        self.rate = 0",
            "        datel = list(",
            "            pd.date_range(dt.datetime.strftime(self.start, \"%Y-%m-%d\"), yesterdaydash())",
            "        )",
            "        valuel = []",
            "        for i, date in enumerate(datel):",
            "            valuel.append((1 + self.interest) ** i)",
            "        dfdict = {",
            "            \"date\": datel,",
            "            \"netvalue\": valuel,",
            "            \"totvalue\": valuel,",
            "            \"comment\": [0 for _ in datel],",
            "        }",
            "        df = pd.DataFrame(data=dfdict)",
            "        self.price = df[df[\"date\"].isin(opendate)]",
            "",
            "",
            "class mfundinfo(basicinfo):",
            "    \"\"\"",
            "    \u771f\u5b9e\u7684\u8d27\u5e01\u57fa\u91d1\u7c7b\uff0c\u53ef\u4ee5\u901a\u8fc7\u8d27\u5e01\u57fa\u91d1\u516d\u4f4d\u4ee3\u7801\uff0c\u6765\u83b7\u53d6\u771f\u5b9e\u7684\u8d27\u5e01\u57fa\u91d1\u4e1a\u7ee9\uff0c\u5e76\u8fdb\u884c\u4ea4\u6613\u56de\u6d4b\u7b49",
            "",
            "    :param code: string of six digitals, code of real monetnary fund",
            "    :param round_label: int, default 0 or 1, label to the different round scheme of shares, reserved for fundinfo class. 1 \u4ee3\u8868\u5168\u820d\u800c\u975e\u56db\u820d\u4e94\u5165\u3002",
            "    :param value_label: int, default 0 or 1. 1 \u4ee3\u8868\u8bb0\u8d26\u5355\u4e0a\u7684\u8d4e\u56de\u6570\u76ee\u662f\u6309\u91d1\u989d\u800c\u975e\u4efd\u989d\u7684\uff0c\u53ea\u80fd\u5b8c\u7f8e\u652f\u6301\u8d27\u5e01\u57fa\u91d1\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        round_label=0,",
            "        value_label=0,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "    ):",
            "        if code.startswith(\"M\") and code[1:].isdigit():",
            "            code = code[1:]",
            "        code = code.zfill(6)",
            "        self._url = \"http://fund.eastmoney.com/pingzhongdata/\" + code + \".js\"",
            "        self.rate = 0",
            "        super().__init__(",
            "            code,",
            "            fetch=fetch,",
            "            save=save,",
            "            path=path,",
            "            form=form,",
            "            round_label=round_label,",
            "            value_label=value_label,",
            "        )",
            "",
            "    def _basic_init(self):",
            "        self._page = rget(self._url)",
            "        if self._page.text[:800].find(\"Data_fundSharesPositions\") >= 0:",
            "            raise FundTypeError(\"This code seems to be a fund, use fundinfo instead\")",
            "        l = eval(",
            "            re.match(",
            "                r\"[\\s\\S]*Data_millionCopiesIncome = ([^;]*);[\\s\\S]*\", self._page.text",
            "            ).groups()[0]",
            "        )",
            "        self.name = re.match(",
            "            r\"[\\s\\S]*fS_name = \\\"([^;]*)\\\";[\\s\\S]*\", self._page.text",
            "        ).groups()[0]",
            "        tz_bj = dt.timezone(dt.timedelta(hours=8))",
            "        datel = [",
            "            dt.datetime.fromtimestamp(int(d[0]) / 1e3, tz=tz_bj).replace(tzinfo=None)",
            "            for d in l",
            "        ]",
            "        ratel = [float(d[1]) for d in l]",
            "        netvalue = [1]",
            "        for dailyrate in ratel:",
            "            netvalue.append(netvalue[-1] * (1 + dailyrate * 1e-4))",
            "        netvalue.remove(1)",
            "",
            "        df = pd.DataFrame(",
            "            data={",
            "                \"date\": datel,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": netvalue,",
            "                \"comment\": [0 for _ in datel],",
            "            }",
            "        )",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        if len(df) == 0:",
            "            raise ParserFailure(\"no price table for %s\" % self.code)",
            "        df = df.reset_index(drop=True)",
            "        self.price = df[df[\"date\"] <= yesterdaydash()]",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        df = pd.DataFrame(",
            "            [[0, 0, self.name, 0]], columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"]",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_csv(path + self.code + \".csv\")",
            "            pricetable = content.iloc[1:]",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "            self.name = content.iloc[0].comment",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        s = json.dumps({\"name\": self.name})",
            "        df = pd.DataFrame(",
            "            [[pd.Timestamp(\"1990-01-01\"), 0, s, 0]],",
            "            columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"],",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_sql(\"xa\" + self.code, path)",
            "            pricetable = content.iloc[1:]",
            "            commentl = [float(com) for com in pricetable.comment]",
            "            self.price = pricetable[[\"date\", \"netvalue\", \"totvalue\"]]",
            "            self.price[\"comment\"] = commentl",
            "            self.name = json.loads(content.iloc[0].comment)[\"name\"]",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        function to incrementally update the pricetable after fetch the old one",
            "        \"\"\"",
            "        lastdate = self.price.iloc[-1].date",
            "        startvalue = self.price.iloc[-1].totvalue",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if diffdays == 0:",
            "            return None",
            "        self._updateurl = (",
            "            \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "            + self.code",
            "            + \"&page=1&per=1\"",
            "        )",
            "        con = rget(self._updateurl)",
            "        soup = BeautifulSoup(con.text, \"lxml\")",
            "        items = soup.findAll(\"td\")",
            "        if dt.datetime.strptime(str(items[0].string), \"%Y-%m-%d\") == today_obj():",
            "            diffdays += 1",
            "        if diffdays <= 10:",
            "            # caution: there may be today data!! then a day gap will be in table",
            "            self._updateurl = (",
            "                \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                + self.code",
            "                + \"&page=1&per=\"",
            "                + str(diffdays)",
            "            )",
            "            con = rget(self._updateurl)",
            "            soup = BeautifulSoup(con.text, \"lxml\")",
            "            items = soup.findAll(\"td\")",
            "        elif (",
            "            diffdays > 10",
            "        ):  ## there is a 20 item per page limit in the API, so to be safe, we query each page by 10 items only",
            "            items = []",
            "            for pg in range(1, int(diffdays / 10) + 2):",
            "                self._updateurl = (",
            "                    \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                    + self.code",
            "                    + \"&page=\"",
            "                    + str(pg)",
            "                    + \"&per=10\"",
            "                )",
            "                con = rget(self._updateurl)",
            "                soup = BeautifulSoup(con.text, \"lxml\")",
            "                items.extend(soup.findAll(\"td\"))",
            "        else:",
            "            raise TradeBehaviorError(",
            "                \"Weird incremental update: the saved copy has future records\"",
            "            )",
            "",
            "        date = []",
            "        earnrate = []",
            "        comment = []",
            "        for i in range(int(len(items) / 6)):",
            "            ts = pd.Timestamp(str(items[6 * i].string))",
            "            if (ts - lastdate).days > 0:",
            "                date.append(ts)",
            "                earnrate.append(float(items[6 * i + 1].string) * 1e-4)",
            "                comment.append(_nfloat(items[6 * i + 5].string))",
            "        date = date[::-1]",
            "        earnrate = earnrate[::-1]",
            "        comment = comment[::-1]",
            "        netvalue = [startvalue]",
            "        for earn in earnrate:",
            "            netvalue.append(netvalue[-1] * (1 + earn))",
            "        netvalue.remove(startvalue)",
            "",
            "        df = pd.DataFrame(",
            "            {",
            "                \"date\": date,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": netvalue,",
            "                \"comment\": comment,",
            "            }",
            "        )",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        if len(df) != 0:",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "",
            "FundInfo = fundinfo",
            "MFundInfo = mfundinfo",
            "CashInfo = cashinfo",
            "IndexInfo = indexinfo"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "modules of info class, including cashinfo, indexinfo and fundinfo class",
            "\"\"\"",
            "",
            "import os",
            "import csv",
            "import datetime as dt",
            "import json",
            "import re",
            "import logging",
            "from functools import lru_cache",
            "",
            "import pandas as pd",
            "from bs4 import BeautifulSoup",
            "from sqlalchemy import exc",
            "",
            "import xalpha.remain as rm",
            "from xalpha.cons import (",
            "    convert_date,",
            "    droplist,",
            "    myround,",
            "    opendate,",
            "    yesterday,",
            "    yesterdaydash,",
            "    yesterdayobj,",
            "    today_obj,",
            "    rget,",
            "    rget_json,",
            "    _float,",
            ")",
            "from xalpha.exceptions import FundTypeError, TradeBehaviorError, ParserFailure",
            "from xalpha.indicator import indicator",
            "",
            "_warnmess = \"Something weird on redem fee, please adjust self.segment by hand\"",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _shengoucal(sg, sgf, value, label):",
            "    \"\"\"",
            "    Infer the share of buying fund by money input, the rate of fee in the unit of %,",
            "        and netvalue of fund",
            "",
            "    :param sg: positive float, \u7533\u8d2d\u91d1\u989d",
            "    :param sgf: positive float, \u7533\u8d2d\u8d39\uff0c\u4ee5\uff05\u4e3a\u5355\u4f4d\uff0c\u5982 0.15 \u8868\u793a 0.15%",
            "    :param value: positive float, \u5bf9\u5e94\u4ea7\u54c1\u7684\u5355\u4f4d\u51c0\u503c",
            "    :param label: integer, 1 \u4ee3\u8868\u4efd\u989d\u6b63\u5e38\u8fdb\u884c\u56db\u820d\u4e94\u5165\uff0c 2 \u4ee3\u8868\u4efd\u989d\u76f4\u63a5\u820d\u53bb\u5c0f\u6570\u70b9\u4e24\u4f4d\u4e4b\u540e\u3002\u91d1\u989d\u90e8\u5206\u90fd\u662f\u56db\u820d\u4e94\u5165",
            "    :returns: tuple of two positive float, \u51c0\u7533\u8d2d\u91d1\u989d\u548c\u7533\u8d2d\u4efd\u989d",
            "    \"\"\"",
            "    jsg = myround(sg / (1 + sgf * 1e-2))",
            "    share = myround(jsg / value, label)",
            "    return (jsg, share)",
            "",
            "",
            "def _nfloat(string):",
            "    \"\"\"",
            "    deal with comment column in fundinfo price table,",
            "    positive value for fenhong and negative value for chaifen,",
            "    keep other unrocognized pattern as original string",
            "",
            "    :param string: string of input from original data",
            "    :returns: make fenhong and songpei as float number",
            "    \"\"\"",
            "    result = 0",
            "    if string:",
            "        try:",
            "            result = float(string)",
            "        except ValueError:",
            "            if re.match(r'\"\u5206\u7ea2\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string):",
            "                result = float(re.match(r'\"\u5206\u7ea2\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string).group(1))",
            "            elif re.match(r\".*\u73b0\u91d1(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = float(re.match(r\".*\u73b0\u91d1(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            elif re.match(r\".*\u6298\u7b97(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = -float(re.match(r\".*\u6298\u7b97(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            elif re.match(r'\"\u62c6\u5206\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string):",
            "                result = -float(re.match(r'\"\u62c6\u5206\\D*(\\d*(?:\\.\\d*)?)\\D*\"', string).group(1))",
            "            elif re.match(r\"\\D*\u5206\u62c6(\\d*(?:\\.\\d*)?)\\D*\", string):",
            "                result = -float(re.match(r\"\\D*\u5206\u62c6(\\d*(?:\\.\\d*)?)\\D*\", string).group(1))",
            "            else:",
            "                logger.warning(\"The comment col cannot be converted: %s\" % string)",
            "                result = string",
            "    return result",
            "",
            "",
            "class FundReport:",
            "    \"\"\"",
            "    \u63d0\u4f9b\u67e5\u770b\u5404\u79cd\u57fa\u91d1\u62a5\u544a\u7684\u63a5\u53e3",
            "    \"\"\"",
            "",
            "    def __init__(self, code):",
            "        self.code = code",
            "        r = rget(",
            "            \"http://api.fund.eastmoney.com/f10/JJGG?callback=&fundcode={code}&pageIndex=1&pageSize=20&type={type_}\".format(",
            "                code=code, type_=\"3\"",
            "            ),",
            "            headers={",
            "                \"Referer\": \"http://fundf10.eastmoney.com/jjgg_{code}_3.html\".format(",
            "                    code=code",
            "                )",
            "            },",
            "        )",
            "        self.report_list = r.json()[\"Data\"]",
            "        self.report_detail = {}",
            "",
            "    def get_report(self, no=0, id_=None):",
            "        \"\"\"",
            "",
            "        :param no: int\u3002\u5728type_=3 \u4e2d\u7684\u7b2cno\u4e2a\u62a5\u544a\u3002",
            "        :param id_: id \u53ef\u7531 :meth:`show_report_list` \u4e2d\u6761\u76ee\u7684\u5bf9\u5e94 ID \u5f97\u5230",
            "        :return:",
            "        \"\"\"",
            "        if id_:",
            "            report_url = \"https://np-cnotice-fund.eastmoney.com/api/content/ann?client_source=web_fund&show_all=1&art_code={id_}\".format(",
            "                id_=id_",
            "            )",
            "",
            "        if not self.report_detail.get(no):",
            "            report_url = \"https://np-cnotice-fund.eastmoney.com/api/content/ann?client_source=web_fund&show_all=1&art_code={id_}\".format(",
            "                id_=self.report_list[no][\"ID\"]",
            "            )",
            "",
            "            # report_url = \"http://fund.eastmoney.com/gonggao/{code},{id_}.html\".format(",
            "            #     code=self.code, id_=self.report_list[no][\"ID\"]",
            "            # )",
            "            # r = rget(report_url)",
            "            # b = BeautifulSoup(r.text, \"lxml\")",
            "            # seasonr = b.find(\"pre\")",
            "            # sr = [s.string.strip() for s in seasonr.findAll(\"p\") if s.string]",
            "        r = rget_json(report_url)",
            "",
            "        sr = r[\"data\"][\"notice_content\"]",
            "        sr = [s.strip() for s in sr.split(\"\\n\") if s.strip()]",
            "        self.report_detail[no] = sr",
            "",
            "        return sr",
            "",
            "    def show_report_list(self, type_=3):",
            "        \"\"\"",
            "",
            "        :param type_: int\u3002\u7b2c0\u680f\uff0c\u7b2c1\u680f\uff0c\u6bcf\u680f\u7684\u542b\u4e49\uff0c\u8bf7\u53c2\u7167\u5929\u5929\u57fa\u91d1\u57fa\u91d1\u62a5\u544a\u7684\u9875\u9762\u3002",
            "        :return:",
            "        \"\"\"",
            "        r = rget(",
            "            \"http://api.fund.eastmoney.com/f10/JJGG?callback=&fundcode={code}&pageIndex=1&pageSize=20&type={type_}\".format(",
            "                code=self.code, type_=str(type_)",
            "            ),",
            "            headers={",
            "                \"Referer\": \"http://fundf10.eastmoney.com/jjgg_{code}_3.html\".format(",
            "                    code=self.code",
            "                )",
            "            },",
            "        )",
            "        return r.json()[\"Data\"]",
            "",
            "    def analyse_report(self, no=0):",
            "        l = self.get_report(no)",
            "        d = {}",
            "        d[\"title\"] = \"\"",
            "        for s in l[:5]:",
            "            if s.startswith(\"\u57fa\u91d1\u7ba1\u7406\"):",
            "                break",
            "            d[\"title\"] += s + \" \"",
            "        for i, s in enumerate(l):",
            "            if s.startswith(\"\u4e1a\u7ee9\u6bd4\u8f83\u57fa\u51c6\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    if l[i + 1][0] != \"\u672c\":",
            "                        d[\"benchmark\"] = ss[-1] + l[i + 1]",
            "                    else:",
            "                        d[\"benchmark\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u7ba1\u7406\u4eba\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"company\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u6258\u7ba1\u4eba\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"bank\"] = ss[-1]",
            "            elif s.startswith(\"\u573a\u5185\u7b80\u79f0\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"shortname\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u4e3b\u4ee3\u7801\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"code\"] = ss[-1]",
            "            elif s.startswith(\"\u62a5\u544a\u671f\u672b\u57fa\u91d1\u4efd\u989d\u603b\u989d\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"share\"] = ss[-1]",
            "            elif s.startswith(\"\u57fa\u91d1\u5408\u540c\u751f\u6548\u65e5\"):",
            "                ss = [s for s in s.split(\"  \") if s.strip()]",
            "                if len(ss) == 2:",
            "                    d[\"start_date\"] = ss[-1]",
            "        return d",
            "",
            "",
            "@lru_cache()",
            "def get_fund_holdings(code, year=\"\", season=\"\", month=\"\", category=\"jjcc\"):",
            "    \"\"\"",
            "    \u83b7\u53d6\u57fa\u91d1\u8be6\u7ec6\u7684\u5e95\u5c42\u6301\u4ed3\u4fe1\u606f",
            "",
            "    :param code: str. 6 \u4f4d\u57fa\u91d1\u4ee3\u7801",
            "    :param year:  int. eg. 2019",
            "    :param season: int, 1,2,3,4",
            "    :param month: Optional[int]. \u6307\u5b9a season \u5373\u53ef\uff0c\u4e00\u822c\u4e0d\u9700\u7406\u4f1a",
            "    :param category: str. stock \u80a1\u7968\u6301\u4ed3\uff0c bond \u503a\u5238\u6301\u4ed3\uff0c\u5929\u5929\u57fa\u91d1\u65e0\u6cd5\u81ea\u52a8\u5904\u7406\u6d77\u5916\u57fa\u91d1\u6301\u4ed3\uff0c\u6682\u672a\u517c\u5bb9 FOF \u7684\u56fd\u5185\u57fa\u91d1\u6301\u4ed3",
            "    :return: pd.DataFrame or None. \u6ca1\u6709\u5bf9\u5e94\u6301\u4ed3\u65f6\u8fd4\u56de None\u3002",
            "    \"\"\"",
            "    if not month and season:",
            "        month = 3 * int(season)",
            "    if category in [\"stock\", \"stocks\", \"jjcc\", \"\", \"gp\", \"s\"]:",
            "        category = \"jjcc\"",
            "    elif category in [\"bond\", \"bonds\", \"zq\", \"zqcc\", \"b\"]:",
            "        category = \"zqcc\"",
            "    else:",
            "        raise ParserFailure(\"unrecognized category %s\" % category)",
            "    if code.startswith(\"F\"):",
            "        code = code[1:]",
            "    r = rget(",
            "        \"http://fundf10.eastmoney.com/FundArchivesDatas.aspx?type={category}&code={code}&topline=10&\\",
            "year={year}&month={month}\".format(",
            "            year=str(year), month=str(month), code=code, category=category",
            "        ),",
            "        headers={",
            "            \"Host\": \"fundf10.eastmoney.com\",",
            "            \"Referer\": \"http://fundf10.eastmoney.com/ccmx_{code}.html\".format(",
            "                code=code",
            "            ),",
            "        },",
            "    )",
            "    if len(r.text) < 50:",
            "        return",
            "        # raise ParserFailure(",
            "        #     \"This fund has no holdings on stock or bonds in this period\"",
            "        # )",
            "    s = BeautifulSoup(",
            "        re.match(\"[\\s\\S]*apidata={ content:(.*),arryear:\", r.text).groups()[0], \"lxml\"",
            "    )",
            "    if len(s.text) < 30:",
            "        return",
            "        # raise ParserFailure(",
            "        #     \"This fund has no holdings on stock or bonds in this period\"",
            "        # )",
            "    timeline = [",
            "        i.string for i in s.findAll(\"font\", class_=\"px12\") if i.text.startswith(\"2\")",
            "    ]",
            "    ind = 0",
            "    if month:",
            "        for i, d in enumerate(timeline):",
            "            if d.split(\"-\")[1][-1] == str(month)[-1]:  # avoid 09 compare to 9",
            "                ind = i",
            "                break",
            "        else:",
            "            return  # not update to this month",
            "    t1 = s.findAll(\"table\")[ind]",
            "    main = [[j.text for j in i.contents] for i in t1.findAll(\"tr\")[1:]]",
            "    cols = [j.text for j in t1.findAll(\"tr\")[0].contents if j.text.strip()]",
            "    icode = 1",
            "    iname = 2",
            "    iratio = 4",
            "    ishare = 5",
            "    ivalue = 6",
            "    for j, col in enumerate(cols):",
            "        if col.endswith(\"\u4ee3\u7801\"):",
            "            icode = j",
            "        elif col.endswith(\"\u540d\u79f0\"):",
            "            iname = j",
            "        elif col.endswith(\"\u6bd4\u4f8b\"):",
            "            iratio = j",
            "        elif col.startswith(\"\u6301\u80a1\u6570\"):",
            "            ishare = j",
            "        elif col.startswith(\"\u6301\u4ed3\u5e02\u503c\"):",
            "            ivalue = j",
            "    if category == \"jjcc\":",
            "        result = {\"code\": [], \"name\": [], \"ratio\": [], \"share\": [], \"value\": []}",
            "        for l in main:",
            "            result[\"code\"].append(l[icode])",
            "            result[\"name\"].append(l[iname])",
            "            result[\"ratio\"].append(float(l[iratio][:-1]))",
            "            result[\"share\"].append(_float(l[ishare]))",
            "            result[\"value\"].append(_float(l[ivalue]))",
            "    elif category == \"zqcc\":",
            "        result = {\"code\": [], \"name\": [], \"ratio\": [], \"value\": []}",
            "        for l in main:",
            "            result[\"code\"].append(l[1])",
            "            result[\"name\"].append(l[2])",
            "            result[\"ratio\"].append(float(l[3][:-1]))",
            "            result[\"value\"].append(_float(l[4]))",
            "    return pd.DataFrame(result)",
            "",
            "",
            "class basicinfo(indicator):",
            "    \"\"\"",
            "    Base class for info of fund, index or even cash,",
            "    which cannot be directly instantiate, the basic implementation consider",
            "    redemption fee as zero when shuhui() function is implemented",
            "",
            "    :param code: string of code for specific product",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO. Or in sql case, path is the engine from sqlalchemy.",
            "    :param form: string, the format of IO, options including: 'csv','sql'",
            "    :param round_label: int, default 0 or 1, label to the different round scheme of shares, reserved for fundinfo class. 1 \u4ee3\u8868\u5168\u820d\u800c\u975e\u56db\u820d\u4e94\u5165\u3002",
            "    :param dividend_label: int, default 0 or 1. 0 \u4ee3\u8868\u9ed8\u8ba4\u73b0\u91d1\u5206\u7ea2\uff0c1\u4ee3\u8868\u7ea2\u5229\u518d\u6295\u3002\u4e24\u8005\u5747\u53ef\u901a\u8fc7\u8bb0\u8d26\u5355\u4e0a\u7684 0.05 \u6765\u6539\u53d8\u5355\u6b21\u7684\u9ed8\u8ba4\u3002",
            "    :param value_label: int, default 0 or 1. 1 \u4ee3\u8868\u8bb0\u8d26\u5355\u4e0a\u7684\u8d4e\u56de\u6570\u76ee\u662f\u6309\u91d1\u989d\u800c\u975e\u4efd\u989d\u7684\uff0c\u53ea\u80fd\u5b8c\u7f8e\u652f\u6301\u8d27\u5e01\u57fa\u91d1\u3002\u5176\u4ed6\u51c0\u503c\u578b\u57fa\u91d1\u672c\u8d28\u4e0a\u65e0\u6cd5\u7cbe\u786e\u5230\u5206\u652f\u6301\u8fd9\u4e00\u9009\u9879\uff0c\u56e0\u6b64\u4e0d\u5f00\u653e\u652f\u6301\u3002",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "        round_label=0,",
            "        dividend_label=0,",
            "        value_label=0,",
            "    ):",
            "        # \u589e\u91cf IO \u7684\u903b\u8f91\u90fd\u7531 basicinfo \u7c7b\u6765\u5904\u7406\uff0c\u5bf9\u4e8e\u5177\u4f53\u7684\u5b50\u7c7b\uff0c\u53ea\u9700\u5b9e\u73b0_save_form \u548c _fetch_form \u4ee5\u53ca update \u51fd\u6570\u5373\u53ef",
            "        self.code = code",
            "",
            "        self.round_label = round_label",
            "        self.dividend_label = dividend_label",
            "        self.value_label = value_label",
            "        self.specialdate = []",
            "        self.fenhongdate = []",
            "        self.zhesuandate = []",
            "",
            "        # compatible with new ``xa.set_backend()`` API",
            "        import xalpha.universal as xu",
            "",
            "        if (xu.ioconf[\"backend\"] in [\"csv\", \"sql\"]) and (not path):",
            "            fetch = True",
            "            save = True",
            "            form = xu.ioconf[\"backend\"]",
            "            path = xu.ioconf[\"path\"]",
            "            if xu.ioconf[\"backend\"] == \"csv\":",
            "                path = os.path.join(path, xu.ioconf[\"prefix\"] + \"INFO-\")",
            "        self.format = form",
            "        if fetch is False:",
            "            self._basic_init()  # update self. name rate and price table",
            "        else:",
            "            try:",
            "                self.fetch(path, self.format)",
            "                df = self.update()  # update the price table as well as the file",
            "                if (df is not None) and save is True:",
            "                    self.save(path, self.format, option=\"a\", delta=df)",
            "",
            "            except (FileNotFoundError, exc.ProgrammingError, exc.OperationalError) as e:",
            "                logger.info(\"no saved copy of %s\" % self.code)",
            "                fetch = False",
            "                self._basic_init()",
            "",
            "        if (save is True) and (fetch is False):",
            "            self.save(path, self.format)",
            "",
            "    def _basic_init(self):",
            "        \"\"\"",
            "        set self. name rate and price (dataframe) as well as other necessary attr of info()",
            "        \"\"\"",
            "        # below lines are just showcase, this function must be rewrite by child classes",
            "        # self.name = 'unknown'",
            "        # self.rate = 0",
            "        # self.price = pd.DataFrame(data={'date':[],'netvalue':[],'comment':[]})",
            "        raise NotImplementedError",
            "",
            "    def shengou(self, value, date, fee=None):",
            "        \"\"\"",
            "        give the realdate deltacash deltashare tuple based on purchase date and purchase amount",
            "        if the date is not a trade date, then the purchase would happen on the next trade day, if the date is",
            "        in the furture, then the trade date is taken as yesterday.",
            "",
            "        :param value: the money for purchase",
            "        :param date: string or object of date",
            "        :param fee: the rate for shengou, default None and info.rate will be used, ok for most cases",
            "        :returns: three elements tuple, the first is the actual dateobj of commit",
            "            the second is a negative float for cashin,",
            "            the third is a positive float for share increase",
            "        \"\"\"",
            "        if fee is None:",
            "            fee = self.rate",
            "        row = self.price[self.price[\"date\"] >= date].iloc[0]",
            "        share = _shengoucal(value, fee, row.netvalue, label=self.round_label + 1)[1]",
            "        return (row.date, -myround(value), share)",
            "",
            "    def shuhui(self, share, date, rem, value_label=None, fee=None):",
            "        \"\"\"",
            "        give the cashout considering redemption rates as zero.",
            "        if the date is not a trade date, then the purchase would happen on the next trade day, if the date is",
            "        in the furture, then the trade date is taken as yesterday.",
            "",
            "        :param share: float or int, number of shares to be sold. if value_label=1, its cash to be sold.",
            "        :param date: string or object of date",
            "        :param rem: positions with time list",
            "        :param value_label: default None, value_label will be chosen by info.value_label, determining",
            "                whether shuhui by share 0 or value 1. value_label = 0 will rewrite self.value_label = 1",
            "        :param fee: default None, determined automatically, suggested for most of the cases.",
            "                Otherwise 0.015 means 1.5% in shuhui, this is different than fee in shengou, where 1.5 is for 1.5% fee",
            "        :returns: three elements tuple, the first is dateobj",
            "            the second is a positive float for cashout,",
            "            the third is a negative float for share decrease",
            "        \"\"\"",
            "        if self.value_label == 0 or value_label == 0:",
            "            return self._shuhui_by_share(share, date, rem)",
            "        elif self.value_label == 1:  # \u6309\u91d1\u989d\u8d4e\u56de\uff0c\u4ec5\u652f\u6301\u65e0\u8d4e\u56de\u8d39\u7684\u8d27\u5e01\u57fa\u91d1",
            "            partprice = self.price[self.price[\"date\"] >= date]",
            "            if len(partprice) == 0:",
            "                row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "            else:",
            "                row = partprice.iloc[0]",
            "            share = share / row.netvalue",
            "            return self._shuhui_by_share(share, date, rem, fee=fee)",
            "",
            "    def _shuhui_by_share(self, share, date, rem, fee=None):",
            "        date = convert_date(date)",
            "        tots = sum([remitem[1] for remitem in rem if remitem[0] <= date])",
            "        if share > tots:",
            "            sh = tots",
            "        else:",
            "            sh = share",
            "        partprice = self.price[self.price[\"date\"] >= date]",
            "        if len(partprice) == 0:",
            "            row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "        else:",
            "            row = partprice.iloc[0]",
            "        value = myround(sh * row.netvalue)",
            "        if fee is not None:",
            "            value = (1 - fee) * value",
            "        return (",
            "            row.date,",
            "            value,",
            "            -myround(sh),",
            "        )  # TODO: \u8fd9\u91cc myround \u662f\u5426\u4e5f\u548c round_label \u6709\u5173\uff0c\u6709\u5f85\u8003\u8bc1",
            "",
            "    def info(self):",
            "        \"\"\"",
            "        print basic info on the class",
            "        \"\"\"",
            "        print(\"fund name: %s\" % self.name)",
            "        print(\"fund code: %s\" % self.code)",
            "        print(\"fund purchase fee: %s%%\" % self.rate)",
            "",
            "    def __repr__(self):",
            "        return self.name",
            "",
            "    def save(self, path, form=None, option=\"r\", delta=None):",
            "        \"\"\"",
            "        save info to files, this function is designed to redirect to more specific functions",
            "",
            "        :param path: string of the folder path prefix! or engine obj from sqlalchemy",
            "        :param form: string, option:'csv'",
            "        :param option: string, r for replace and a for append output",
            "        :param delta: if option is a, you have to specify the delta which is the incremental part of price table",
            "        \"\"\"",
            "        if form is None:",
            "            form = self.format",
            "        if form == \"csv\" and option == \"r\":",
            "            self._save_csv(path)",
            "        elif form == \"csv\" and option == \"a\":",
            "            self._save_csv_a(path, delta)",
            "        elif form == \"sql\" and option == \"r\":",
            "            self._save_sql(path)",
            "        elif form == \"sql\" and option == \"a\":",
            "            self._save_sql_a(path, delta)",
            "",
            "    def _save_csv_a(self, path, df):",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\",",
            "            mode=\"a\",",
            "            header=None,",
            "            index=False,",
            "            date_format=\"%Y-%m-%d\",",
            "        )",
            "",
            "    def _save_sql_a(self, path, df):",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, path, if_exists=\"append\", index=False",
            "        )",
            "",
            "    def fetch(self, path, form=None):",
            "        \"\"\"",
            "        fetch info from files",
            "",
            "        :param path: string of the folder path prefix! end with / in csv case;",
            "            engine from sqlalchemy.create_engine() in sql case.",
            "        :param form: string, option:'csv' or 'sql",
            "        \"\"\"",
            "        if form is None:",
            "            form = self.format",
            "        if form == \"csv\":",
            "            self._fetch_csv(path)",
            "        elif form == \"sql\":",
            "            self._fetch_sql(path)",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        \u5bf9\u7c7b\u7684\u4ef7\u683c\u8868\u8fdb\u884c\u589e\u91cf\u66f4\u65b0\uff0c\u5e76\u8fdb\u884c\u589e\u91cf\u5b58\u50a8\uff0c\u9002\u5408 fetch \u6253\u5f00\u7684\u60c5\u5f62",
            "",
            "        :returns: the incremental part of price table or None if no incremental part exsits",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class fundinfo(basicinfo):",
            "    \"\"\"",
            "    class for specific fund with basic info and every day values",
            "    \u6240\u83b7\u5f97\u7684\u57fa\u91d1\u51c0\u503c\u6570\u636e\u4e00\u822c\u622a\u6b62\u5230\u6628\u65e5\u3002\u4f46\u6ce8\u610fQDII\u57fa\u91d1\u7684\u51c0\u503c\u6570\u636e\u4f1a\u622a\u6b62\u7684\u66f4\u65e9\uff0c\u56e0\u6b64\u90e8\u5206\u65f6\u95f4\u9ed8\u8ba4\u6628\u65e5\u7684\u51fd\u6570\u53ef\u80fd\u51fa\u73b0\u95ee\u9898\uff0c",
            "    \u5904\u7406QDII\u57fa\u91d1\u65f6\uff0c\u9700\u8981\u989d\u5916\u6ce8\u610f\u3002",
            "",
            "    :param code: str, \u57fa\u91d1\u516d\u4f4d\u4ee3\u7801\u5b57\u7b26",
            "    :param round_label: integer 0 or 1, \u53d61\u8868\u793a\u57fa\u91d1\u7533\u8d2d\u65f6\u4efd\u989d\u76f4\u63a5\u820d\u6389\u5c0f\u6570\u70b9\u4e24\u4f4d\u4e4b\u540e\u3002\u5f53\u57fa\u91d1\u5904\u4e8e cons.droplist \u540d\u5355\u4e2d\u65f6\uff0c",
            "        label \u603b\u4f1a\u88ab\u81ea\u52a8\u8bbe\u7f6e\u4e3a1\u3002\u975e\u540d\u5355\u5185\u57fa\u91d1\u53ef\u4ee5\u663e\u5f0f\u4ee4 round_label=1.",
            "    :param dividend_label: int, default 0 or 1. 0 \u4ee3\u8868\u9ed8\u8ba4\u73b0\u91d1\u5206\u7ea2\uff0c1\u4ee3\u8868\u7ea2\u5229\u518d\u6295\u3002\u4e24\u8005\u5747\u53ef\u901a\u8fc7\u8bb0\u8d26\u5355\u4e0a\u7684 0.05 \u6765\u6539\u53d8\u5355\u6b21\u7684\u9ed8\u8ba4\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        round_label=0,",
            "        dividend_label=0,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "        priceonly=False,",
            "    ):",
            "        if round_label == 1 or (code in droplist):",
            "            label = 1  # the scheme of round down on share purchase",
            "        else:",
            "            label = 0",
            "        if code.startswith(\"F\") and code[1:].isdigit():",
            "            code = code[1:]",
            "        elif code.startswith(\"M\") and code[1:].isdigit():",
            "            raise FundTypeError(",
            "                \"This code seems to be a mfund, use ``mfundinfo`` instead\"",
            "            )",
            "        code = code.zfill(6)  # 1234 is the same as 001234",
            "        assert code.isdigit(), \"fund code must be a strin of six digits\"",
            "        assert len(code) == 6, \"fund code must be a strin of six digits\"",
            "        self._url = (",
            "            \"http://fund.eastmoney.com/pingzhongdata/\" + code + \".js\"",
            "        )  # js url api for info of certain fund",
            "        self._feeurl = (",
            "            \"http://fund.eastmoney.com/f10/jjfl_\" + code + \".html\"",
            "        )  # html url for trade fees info of certain fund",
            "        self.priceonly = priceonly",
            "",
            "        super().__init__(",
            "            code,",
            "            fetch=fetch,",
            "            save=save,",
            "            path=path,",
            "            form=form,",
            "            round_label=label,",
            "            dividend_label=dividend_label,",
            "        )",
            "",
            "        self.special = self.price[self.price[\"comment\"] != 0]",
            "        self.specialdate = list(self.special[\"date\"])",
            "        # date with nonvanishing comment, usually fenhong or zhesuan",
            "        try:",
            "            self.fenhongdate = list(self.price[self.price[\"comment\"] > 0][\"date\"])",
            "            self.zhesuandate = list(self.price[self.price[\"comment\"] < 0][\"date\"])",
            "        except TypeError:",
            "            print(\"There are still string comments for the fund!\")",
            "",
            "    def _basic_init(self):",
            "        if self.code.startswith(\"96\"):",
            "            self._hkfund_init()  # \u4e2d\u6e2f\u4e92\u8ba4\u57fa\u91d1\u5904\u7406",
            "            return",
            "        self._page = rget(self._url)",
            "        if self._page.status_code == 404:",
            "            raise ParserFailure(\"Unrecognized fund, please check fund code you input.\")",
            "        if self._page.text[:800].find(\"Data_millionCopiesIncome\") >= 0:",
            "            raise FundTypeError(\"This code seems to be a mfund, use mfundinfo instead\")",
            "",
            "        l = re.match(",
            "            r\"[\\s\\S]*Data_netWorthTrend = ([^;]*);[\\s\\S]*\", self._page.text",
            "        ).groups()[0]",
            "        l = l.replace(\"null\", \"None\")  # \u6682\u672a\u53d1\u73b0\u57fa\u91d1\u51c0\u503c\u6709 null \u7684\u57fa\u91d1\uff0c\u82e5\u6709\uff0c\u5176\u4ed6\u5730\u65b9\u4e5f\u5f88\u53ef\u80fd\u51fa\u95ee\u9898\uff01",
            "        l = eval(l)",
            "        ltot = re.match(",
            "            r\"[\\s\\S]*Data_ACWorthTrend = ([^;]*);[\\s\\S]*\", self._page.text",
            "        ).groups()[",
            "            0",
            "        ]  # .* doesn't match \\n",
            "        ltot = ltot.replace(\"null\", \"None\")  ## 096001 \u603b\u503c\u6570\u636e\u4e2d\u6709 null\uff01",
            "        ltot = eval(ltot)",
            "        ## timestamp transform tzinfo must be taken into consideration",
            "        tz_bj = dt.timezone(dt.timedelta(hours=8))",
            "        infodict = {",
            "            \"date\": [",
            "                dt.datetime.fromtimestamp(int(d[\"x\"]) / 1e3, tz=tz_bj).replace(",
            "                    tzinfo=None",
            "                )",
            "                for d in l",
            "            ],",
            "            \"netvalue\": [float(d[\"y\"]) for d in l],",
            "            \"comment\": [_nfloat(d[\"unitMoney\"]) for d in l],",
            "        }",
            "",
            "        if len(l) == len(ltot):  # \u9632\u6b62\u603b\u503c\u548c\u51c0\u503c\u6570\u636e\u91cf\u4e0d\u5339\u914d\uff0c\u5df2\u77e5\u6709\u8be5\u95ee\u9898\u7684\u57fa\u91d1\uff1a502010",
            "            infodict[\"totvalue\"] = [d[1] for d in ltot]",
            "",
            "        try:",
            "            rate = float(",
            "                eval(",
            "                    re.match(",
            "                        r\"[\\s\\S]*fund_Rate=([^;]*);[\\s\\S]*\", self._page.text",
            "                    ).groups()[0]",
            "                )",
            "            )",
            "        except ValueError:",
            "            rate = 0",
            "            logger.info(\"warning: this fund has no data for rate\")  # know cases: ETF",
            "",
            "        name = eval(",
            "            re.match(r\"[\\s\\S]*fS_name = ([^;]*);[\\s\\S]*\", self._page.text).groups()[0]",
            "        )",
            "",
            "        self.rate = rate",
            "        # shengou rate in tiantianjijin, daeshengou rate discount is not considered",
            "        self.name = name  # the name of the fund",
            "        df = pd.DataFrame(data=infodict)",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        if len(df) == 0:",
            "            raise ParserFailure(\"no price table found for this fund %s\" % self.code)",
            "        self.price = df[df[\"date\"] <= yesterdaydash()]",
            "        # deal with the redemption fee attrs finally",
            "        if not self.priceonly:",
            "            self._feepreprocess()",
            "",
            "    def _feepreprocess(self):",
            "        \"\"\"",
            "        Preprocess to add self.feeinfo and self.segment attr according to redemption fee info",
            "        \"\"\"",
            "        feepage = rget(self._feeurl)",
            "        soup = BeautifulSoup(",
            "            feepage.text, \"lxml\"",
            "        )  # parse the redemption fee html page with beautiful soup",
            "        somethingwrong = False",
            "        if not soup.findAll(\"a\", {\"name\": \"shfl\"}):",
            "            somethingwrong = True",
            "            logger.warning(\"%s \u57fa\u91d1\u8d4e\u56de\u4fe1\u606f\u4e3a\u7a7a\uff0c\u53ef\u80fd\u7531\u4e8e\u8be5\u57fa\u91d1\u5df2\u7ec8\u6b62\u8fd0\u4f5c\" % self.code)",
            "            self.feeinfo = []",
            "        else:",
            "            self.feeinfo = [",
            "                item.string",
            "                for item in soup.findAll(\"a\", {\"name\": \"shfl\"})[",
            "                    0",
            "                ].parent.parent.next_sibling.next_sibling.find_all(\"td\")",
            "                if item.string != \"---\"",
            "            ]",
            "        # this could be [], known case 510030",
            "",
            "        if not self.feeinfo or len(self.feeinfo) % 2 != 0:",
            "            somethingwrong = True",
            "        else:",
            "            for item in self.feeinfo:",
            "                if \"\u5f00\u653e\u671f\" in item or \"\u5c01\u95ed\" in item or \"\u5f00\u653e\u65e5\u671f\" in item or \"\u8fd0\u4f5c\u671f\" in item:",
            "                    # \u6682\u65f6\u6ca1\u6709\u5b8c\u7f8e\u7ef4\u62a4\u5b9a\u5f00\u57fa\u91d1\u8d4e\u56de\u8d39\u5904\u7406\u7684\u8ba1\u5212",
            "                    somethingwrong = True",
            "        if somethingwrong:",
            "            logger.warning(",
            "                \"%s \u8d4e\u56de\u8d39\u4fe1\u606f\u5f02\u5e38\uff0c\u591a\u662f\u56e0\u4e3a\u5b9a\u5f00\u57fa\u91d1\uff0c\u5c01\u95ed\u57fa\u91d1\u6216\u573a\u5185 ETF: %s\" % (self.code, self.feeinfo)",
            "            )",
            "            self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"1.50%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]",
            "        # print(self.feeinfo)",
            "        try:",
            "            self.segment = fundinfo._piecewise(self.feeinfo)",
            "        except (ValueError, IndexError) as e:",
            "            logger.warning(",
            "                \"%s \u8d4e\u56de\u8d39\u4fe1\u606f\u6293\u53d6\u5f02\u5e38\uff0c\u8bf7\u624b\u52a8\u8bbe\u5b9a ``self.segment`` \u548c ``self.feeinfo``: %s\"",
            "                % (self.code, self.feeinfo)",
            "            )",
            "            # below is default one",
            "            self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"1.50%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]",
            "            self.segment = fundinfo._piecewise(self.feeinfo)",
            "",
            "    @staticmethod",
            "    def _piecewise(a):",
            "        \"\"\"",
            "        Transform the words list into a pure number segment list for redemption fee, eg. [[0,7],[7,365],[365]]",
            "        \"\"\"",
            "",
            "        b = [",
            "            (",
            "                a[2 * i]",
            "                .replace(\"\u6301\u6709\u671f\u9650\", \"\")",
            "                .replace(\"\u5f00\u653e\u8fd0\u4f5c\u671f\u65f6\u6301\u6709\", \"\")",
            "                .replace(\"\u4e0d\u5c11\u4e8e\", \"\")",
            "                .replace(\"\u5c0f\u4e8e\", \"\")",
            "                .replace(\"\u5927\u4e8e\", \"\")",
            "                .replace(\"\u7b49\u4e8e\", \"\")",
            "                .replace(\"\u4e2a\", \"\")",
            "                .replace(\"\u6301\u6709\", \"\")",
            "                .replace(\"\u4ee5\u4e0a\", \"\")",
            "                .replace(\"\u4ee5\u5185\", \"\")",
            "                .replace(\"\u7684\", \"\")",
            "                .replace(\"(\u542b7\u5929)\", \"\")",
            "                .replace(\"\u4efd\u989d\u6301\u6709\u65f6\u95f4\", \"\")",
            "            ).split(\"\uff0c\")",
            "            for i in range(int(len(a) / 2))",
            "        ]",
            "        # ['\u8d4e\u56de\u65f6\u4efd\u989d\u6301\u67097\u5929\u4ee5\u5185\u7684', '1.50%', '\u6301\u67097\u5929\u4ee5\u4e0a(\u542b7\u5929),30\u5929\u4ee5\u5185\u7684', '0.10%', '\u8d4e\u56de\u65f6\u4efd\u989d\u6301\u6709\u6ee130\u5929\u4ee5\u4e0a(\u542b30\u5929)\u7684', '0.00%']",
            "        # ['\u7531\u4e8e\u672c\u57fa\u91d1\u6700\u77ed\u6301\u6709\u671f\u9650\u4e3a\u4e09\u5e74,\u8d4e\u56de\u8d39\u7387\u8bbe\u7f6e\u4e3a\u96f6\u3002', '0.00%', '\u5bf9\u6301\u7eed\u6301\u6709\u671f\u5c11\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u6536\u53d6\u4e0d\u4f4e\u4e8e1.5%\u7684\u8d4e\u56de\u8d39\u3002', '1.50%']",
            "        #  ['\u5bf9\u6301\u7eed\u6301\u6709\u671f\u5c11\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u6536\u53d61.5%\u7684\u8d4e\u56de\u8d39\u5e76\u5168\u989d\u8ba1\u5165\u57fa\u91d1\u8d22\u4ea7', '1.50%', '\u5bf9\u4e8e\u6301\u7eed\u6301\u6709\u671f\u5927\u4e8e\u7b49\u4e8e7\u65e5\u7684\u6295\u8d44\u8005\u4e0d\u6536\u53d6\u8d4e\u56de\u8d39\u7528\u3002', '0.00%']",
            "        # print(b)",
            "        for j, tem in enumerate(b):",
            "            for i, num in enumerate(tem):",
            "                if num[-1] == \"\u5929\":",
            "                    num = int(num[:-1])",
            "                elif num[-1] == \"\u6708\":",
            "                    num = int(num[:-1]) * 30",
            "                elif num == \".5\u5e74\":",
            "                    num = 183",
            "                else:",
            "                    num = int(float(num[:-1]) * 365)",
            "                b[j][i] = num",
            "        if len(b[0]) == 1:  # \u6709\u65f6\u8d4e\u56de\u8d39\u4f1a\u5199\u5927\u4e8e\u7b49\u4e8e\u4e00\u5929",
            "            b[0].insert(0, 0)",
            "        elif len(b[0]) == 2:",
            "            b[0][0] = 0",
            "        else:",
            "            print(_warnmess)",
            "        for i in range(len(b) - 1):  # \u6709\u65f6\u8d4e\u56de\u8d39\u4e24\u533a\u95f4\u90fd\u662f\u95ed\u533a\u95f4",
            "            if b[i][1] - b[i + 1][0] == -1:",
            "                b[i][1] = b[i + 1][0]",
            "            elif b[i][1] == b[i + 1][0]:",
            "                pass",
            "            else:",
            "                print(_warnmess)",
            "",
            "        return b",
            "",
            "    def feedecision(self, day):",
            "        \"\"\"",
            "        give the redemption rate in percent unit based on the days difference between purchase and redemption",
            "",
            "        :param day: integer\uff0c \u8d4e\u56de\u4e0e\u7533\u8d2d\u65f6\u95f4\u4e4b\u5dee\u7684\u81ea\u7136\u65e5\u6570",
            "        :returns: float\uff0c\u8d4e\u56de\u8d39\u7387\uff0c\u4ee5\uff05\u4e3a\u5355\u4f4d",
            "        \"\"\"",
            "        i = -1",
            "        for seg in self.segment:",
            "            i += 2",
            "            if day - seg[0] >= 0 and (len(seg) == 1 or day - seg[-1] < 0):",
            "                return float(self.feeinfo[i].strip(\"%\"))",
            "        return 0  # error backup, in case there is sth wrong in segment",
            "",
            "    def set_feeinfo(self, feeinfo):",
            "        \"\"\"",
            "        \u8bbe\u7f6e\u6b63\u786e\u7684\u8d4e\u56de\u8d39\u7387\u4fe1\u606f",
            "",
            "        :param feeinfo: List[string]",
            "        \"\"\"",
            "        self.feeinfo = feeinfo",
            "        self.segment = self._piecewise(feeinfo)",
            "",
            "    def set_price(self, col, date, value):",
            "        \"\"\"",
            "        \u8bbe\u7f6e\u4fee\u6b63 price \u8868\u4e2d\u5355\u65e5\u7684 comment \u6216\u4ef7\u683c\u4fe1\u606f",
            "",
            "        :param col: str. \"comment\", \"netvalue\" or \"totvalue\"",
            "        :param date: \u201c%Y%m%d\u201d",
            "        :param value:",
            "        \"\"\"",
            "        self.price.loc[self.price[\"date\"] == date, col] = value",
            "        ## update special in case new comment is added",
            "        self.special = self.price[self.price[\"comment\"] != 0]",
            "        self.specialdate = list(self.special[\"date\"])",
            "",
            "    def shuhui(self, share, date, rem, value_label=None, fee=None):",
            "        \"\"\"",
            "        give the cashout based on rem term considering redemption rates",
            "",
            "        :returns: three elements tuple, the first is dateobj",
            "            the second is a positive float for cashout,",
            "            the third is a negative float for share decrease",
            "        \"\"\"",
            "        # \t\t value = myround(share*self.price[self.price['date']==date].iloc[0].netvalue)",
            "        date = convert_date(date)",
            "        partprice = self.price[self.price[\"date\"] >= date]",
            "        if len(partprice) == 0:",
            "            row = self.price[self.price[\"date\"] < date].iloc[-1]",
            "        else:",
            "            row = partprice.iloc[0]",
            "        soldrem, _ = rm.sell(rem, share, row.date)",
            "        value = 0",
            "        sh = myround(sum([item[1] for item in soldrem]))",
            "        for d, s in soldrem:",
            "            if fee is None:",
            "                tmpfee = self.feedecision((row.date - d).days) * 1e-2",
            "            else:",
            "                tmpfee = fee",
            "            value += myround(",
            "                s * row.netvalue * (1 - tmpfee)",
            "            )  # TODO: round_label whether play a role here?",
            "        return (row.date, value, -sh)",
            "",
            "    def info(self):",
            "        super().info()",
            "        print(\"fund redemption fee info: %s\" % self.feeinfo)",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        s = json.dumps(",
            "            {",
            "                \"feeinfo\": self.feeinfo,",
            "                \"name\": self.name,",
            "                \"rate\": self.rate,",
            "                \"segment\": self.segment,",
            "            }",
            "        )",
            "        df = pd.DataFrame(",
            "            [[s, 0, 0, 0]], columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"]",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_csv(path + self.code + \".csv\")",
            "            pricetable = content.iloc[1:]",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "            saveinfo = json.loads(content.iloc[0].date)",
            "            if not isinstance(saveinfo, dict):",
            "                raise FundTypeError(\"This csv doesn't looks like from fundinfo\")",
            "            self.segment = saveinfo[\"segment\"]",
            "            self.feeinfo = saveinfo[\"feeinfo\"]",
            "            self.name = saveinfo[\"name\"]",
            "            self.rate = saveinfo[\"rate\"]",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of fund %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        s = json.dumps(",
            "            {",
            "                \"feeinfo\": self.feeinfo,",
            "                \"name\": self.name,",
            "                \"rate\": self.rate,",
            "                \"segment\": self.segment,",
            "            }",
            "        )",
            "        df = pd.DataFrame(",
            "            [[pd.Timestamp(\"1990-01-01\"), 0, s, 0]],",
            "            columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"],",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_sql(\"xa\" + self.code, path)",
            "            pricetable = content.iloc[1:]",
            "            commentl = [float(com) for com in pricetable.comment]",
            "            self.price = pricetable[[\"date\", \"netvalue\", \"totvalue\"]]",
            "            self.price[\"comment\"] = commentl",
            "            saveinfo = json.loads(content.iloc[0].comment)",
            "            if not isinstance(saveinfo, dict):",
            "                raise FundTypeError(\"This csv doesn't looks like from fundinfo\")",
            "            self.segment = saveinfo[\"segment\"]",
            "            self.feeinfo = saveinfo[\"feeinfo\"]",
            "            self.name = saveinfo[\"name\"]",
            "            self.rate = saveinfo[\"rate\"]",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _hk_update(self):",
            "        # \u6682\u65f6\u4e0d\u786e\u5b9a\u589e\u91cf\u66f4\u65b0\u903b\u8f91\u65e0 bug\uff0c\u9700\u65f6\u95f4\u9a8c\u8bc1",
            "        # \u6ce8\u610f\u589e\u91cf\u66f4\u65b0\u65f6\u5206\u7ea2\u7684\u540c\u6b65\u66f4\u65b0",
            "        lastdate = self.price.iloc[-1].date",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if diffdays == 0:",
            "            return None",
            "        import xalpha.universal as xu",
            "",
            "        df = xu.get_daily(\"F\" + self.code, start=lastdate.strftime(\"%Y%m%d\"))",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        df = df[df[\"date\"] > lastdate]",
            "",
            "        if len(df) != 0:",
            "            r = self._hk_bonus(start=lastdate.strftime(\"%Y-%m-%d\"))",
            "            df[\"comment\"] = [0 for _ in range(len(df))]",
            "            df[\"netvalue\"] = df[\"close\"]",
            "            df = df.drop(\"close\", axis=1)",
            "            df = df[df[\"date\"].isin(opendate)]  # ? \u662f\u5426\u4f1a\u8fc7\u6ee4\u6389\u5206\u7ea2\u65e5",
            "            for d in r:",
            "                df.loc[df[\"date\"] == d[\"EXDDATE\"], \"comment\"] = d[\"BONUS\"]",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        function to incrementally update the pricetable after fetch the old one",
            "        \"\"\"",
            "        if self.code.startswith(\"96\"):",
            "            return self._hk_update()",
            "        lastdate = self.price.iloc[-1].date",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if (",
            "            diffdays == 0",
            "        ):  ## for some QDII, this value is 1, anyways, trying update is compatible (d+2 update)",
            "            return None",
            "        self._updateurl = (",
            "            \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "            + self.code",
            "            + \"&page=1&per=1\"",
            "        )",
            "        con = rget(self._updateurl)",
            "        soup = BeautifulSoup(con.text, \"lxml\")",
            "        items = soup.findAll(\"td\")",
            "        if dt.datetime.strptime(str(items[0].string), \"%Y-%m-%d\") == today_obj():",
            "            diffdays += 1",
            "        if diffdays <= 10:",
            "            self._updateurl = (",
            "                \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                + self.code",
            "                + \"&page=1&per=\"",
            "                + str(diffdays)",
            "            )",
            "            con = rget(self._updateurl)",
            "            soup = BeautifulSoup(con.text, \"lxml\")",
            "            items = soup.findAll(\"td\")",
            "        elif (",
            "            diffdays > 10",
            "        ):  ## there is a 20 item per page limit in the API, so to be safe, we query each page by 10 items only",
            "            items = []",
            "            for pg in range(1, int(diffdays / 10) + 2):",
            "                self._updateurl = (",
            "                    \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                    + self.code",
            "                    + \"&page=\"",
            "                    + str(pg)",
            "                    + \"&per=10\"",
            "                )",
            "                con = rget(self._updateurl)",
            "                soup = BeautifulSoup(con.text, \"lxml\")",
            "                items.extend(soup.findAll(\"td\"))",
            "        else:",
            "            raise TradeBehaviorError(",
            "                \"Weird incremental update: the saved copy has future records\"",
            "            )",
            "",
            "        date = []",
            "        netvalue = []",
            "        totvalue = []",
            "        comment = []",
            "        for i in range(int(len(items) / 7)):",
            "            ts = pd.Timestamp(str(items[7 * i].string))",
            "            if (ts - lastdate).days > 0:",
            "                date.append(ts)",
            "                netvalue.append(_float(items[7 * i + 1].string))",
            "                totvalue.append(_float(items[7 * i + 2].string))",
            "                comment.append(_nfloat(items[7 * i + 6].string))",
            "            else:",
            "                break",
            "        df = pd.DataFrame(",
            "            {",
            "                \"date\": date,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": totvalue,",
            "                \"comment\": comment,",
            "            }",
            "        )",
            "        df = df.iloc[::-1]  ## reverse the time order",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        if len(df) != 0:",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "    def get_holdings(self, year=\"\", season=\"\", month=\"\", category=\"stock\"):",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=category",
            "        )",
            "",
            "    def get_stock_holdings(self, year=\"\", season=\"\", month=\"\"):",
            "        \"\"\"",
            "        \u6301\u4ed3\u4e2a\u80a1\u7ec6\u8282",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :return: pd.DataFrame",
            "        \"\"\"",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=\"stock\"",
            "        )",
            "",
            "    def get_bond_holdings(self, year=\"\", season=\"\", month=\"\"):",
            "        \"\"\"",
            "        \u6301\u4ed3\u503a\u5238\u7ec6\u8282",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :return: pd.DataFrame",
            "        \"\"\"",
            "        return get_fund_holdings(",
            "            self.code, year, season=season, month=month, category=\"bond\"",
            "        )",
            "",
            "    def get_portfolio_holdings(self, date=None):",
            "        \"\"\"",
            "        \u6301\u4ed3\u80a1\u503a\u73b0\u91d1\u5360\u6bd4",
            "",
            "        :param date:",
            "        :return: Dict",
            "        \"\"\"",
            "        if date is None:",
            "            date = dt.datetime.now().strftime(\"%Y-%m-%d\")",
            "        import xalpha.universal as xu",
            "",
            "        df = xu.get_daily(\"pt-F\" + self.code, end=date)",
            "        if df is not None:",
            "            d = dict(df.iloc[-1])",
            "            del d[\"assets\"], d[\"date\"]",
            "            return d",
            "        else:",
            "            logger.warning(\"no portfolio information before %s\" % date)",
            "            return",
            "",
            "    def get_industry_holdings(self, year=\"\", season=\"\", month=\"\", threhold=0.5):",
            "        \"\"\"",
            "        \u6301\u4ed3\u884c\u4e1a\u5360\u6bd4",
            "",
            "        :param year:",
            "        :param season:",
            "        :param month:",
            "        :param threhold: float, \u6301\u4ed3\u5c0f\u4e8e\u8be5\u767e\u5206\u6570\u7684\u4e2a\u80a1\u884c\u4e1a\u4e0d\u518d\u7edf\u8ba1\uff0c\u52a0\u5feb\u901f\u5ea6",
            "        :return:  Dict",
            "        \"\"\"",
            "        # \u6ce8\u610f\u8be5 API \u672a\u76f4\u63a5\u4f7f\u7528\u5929\u5929\u57fa\u91d1\u7684\u884c\u4e1a\u6570\u636e\uff0c\u5176\u6570\u636e\u884c\u4e1a\u5212\u5206\u6bd4\u8f83\u5947\u602a\uff0c\u5927\u91cf\u884c\u4e1a\u90fd\u5212\u5206\u8fdb\u4e86\u7b3c\u7edf\u7684\u5236\u9020\u4e1a\uff0c",
            "        # \u7528\u4e8e\u5206\u6790\u4ee3\u8868\u6027\u4e0d\u5f3a\uff0c\u751a\u81f3\u6ca1\u6709\u6d88\u8d39\uff0c\u533b\u836f\u7b49\u884c\u4e1a\u5212\u5206\u65b9\u5f0f",
            "",
            "        from xalpha.universal import ttjjcode, get_industry_fromxq",
            "",
            "        df = self.get_stock_holdings(year=year, season=season, month=month)",
            "        if df is None:",
            "            logger.warning(",
            "                \"%s has no stock holdings in %s y %s s. (Possible reason: \u94fe\u63a5\u57fa\u91d1\uff0c\u503a\u5238\u57fa\u91d1)\"",
            "                % (self.code, year, season)",
            "            )",
            "            return",
            "        d = {}",
            "        for i, row in df.iterrows():",
            "            if row[\"ratio\"] < threhold:",
            "                continue",
            "            code = ttjjcode(row[\"code\"])",
            "            industry = get_industry_fromxq(code)[\"industryname\"]",
            "            if not industry.strip():",
            "                logger.warning(",
            "                    \"%s has no industry information, cannot be classfied\" % code",
            "                )",
            "            else:",
            "                if industry not in d:",
            "                    d[industry] = 0",
            "                d[industry] += row[\"ratio\"]",
            "        return d",
            "",
            "    def which_industry(self, threhold=1.0):",
            "        \"\"\"",
            "        Experimental API",
            "        \u5f53\u5355\u4e00\u884c\u4e1a\u5360\u6bd4\u8f83\u5176\u4ed6\u884c\u4e1a\u7684 threhold \u500d\u8fd8\u591a\u65f6\uff0c\u81ea\u52a8\u5224\u5b9a\u4e3a\u5bf9\u5e94\u7684\u884c\u4e1a\u57fa\u91d1",
            "        \u6ce8\u610f\u8fd9\u91cc\u7684\u884c\u4e1a\u53ef\u80fd\u6bd4\u8f83\u7ec6\u5206\uff0c\u5bfc\u81f4\u6301\u4ed3\u591a\u4e2a\u884c\u4e1a\u5176\u5b9e\u662f\u540c\u4e00\u5927\u884c\u4e1a\u4ece\u800c\u8bef\u5224\u4e3a\u5bbd\u57fa\u57fa\u91d1\u7684\u53ef\u80fd",
            "",
            "        :param threhold: float",
            "        :return: str",
            "        \"\"\"",
            "        d = self.get_industry_holdings()",
            "        l = sorted([(k, v) for k, v in d.items()], key=lambda s: -s[1])",
            "        s0 = 0",
            "        if l and l[0] and l[0][1]:",
            "            s0 = l[0][1]",
            "        s1 = sum([l[i][1] for i in range(1, len(l))])",
            "        if s0 > threhold * s1:",
            "            return \"\u884c\u4e1a\u57fa\u91d1\uff1a \" + l[0][0]",
            "        else:",
            "            return \"\u5bbd\u57fa\u57fa\u91d1\"",
            "",
            "    def _hkfund_init(self):",
            "        import xalpha.universal as xu",
            "",
            "        # \u4e92\u8ba4\u57fa\u91d1\u56fd\u5185\u4f11\u5e02\u65e5\u4e5f\u6709\u51c0\u503c\uff0c\u6682\u65f6\u8fc7\u6ee4\uff0c\u4e0d\u786e\u5b9a\u662f\u5426\u4f1a\u5f15\u8d77\u517c\u5bb9\u6027\u95ee\u9898",
            "        self.meta = xu.get_rt(\"F\" + self.code)",
            "        self.start = self.meta[\"startdate\"]",
            "        self.name = self.meta[\"name\"]",
            "        self.price = xu.get_daily(\"F\" + self.code, start=self.start)",
            "        self.feeinfo = [\"\u5c0f\u4e8e7\u5929\", \"0.00%\", \"\u5927\u4e8e\u7b49\u4e8e7\u5929\", \"0.00%\"]  # \u4f3c\u4e4e\u8be5\u7c7b\u578b\u57fa\u91d1\u90fd\u4e0d\u6536\u53d6\u8d4e\u56de\u8d39",
            "        self.segment = fundinfo._piecewise(self.feeinfo)",
            "        r = rget(\"http://overseas.1234567.com.cn/f10/FundSaleInfo/968012#SaleInfo\")",
            "        b = BeautifulSoup(r.text, \"lxml\")",
            "        self.rate = _float(",
            "            [",
            "                c.strip()",
            "                for c in b.select(\".HK_Fund_Table.BigText\")[5].text.split(\"\\n\")",
            "                if c.strip()",
            "            ][-1]",
            "            .split(\"|\")[-1]",
            "            .strip()[:-1]",
            "        )",
            "        r = self._hk_bonus()",
            "        df = self.price",
            "        df[\"comment\"] = [0 for _ in range(len(df))]",
            "        df[\"netvalue\"] = df[\"close\"]",
            "        df[\"date\"] = pd.to_datetime(df[\"date\"])",
            "        df = df[df[\"date\"].isin(opendate)]  # ? \u662f\u5426\u4f1a\u8fc7\u6ee4\u6389\u5206\u7ea2\u65e5",
            "        for d in r:",
            "            df.loc[df[\"date\"] == d[\"EXDDATE\"], \"comment\"] = d[\"BONUS\"]",
            "        df = df.drop(\"close\", axis=1)",
            "        self.price = df",
            "",
            "    def _hk_bonus(self, start=None):",
            "        \"\"\"",
            "        [summary]",
            "",
            "        :param start: \"%Y-%m-%d\", defaults to None",
            "        :type start: [type], optional",
            "        \"\"\"",
            "        import xalpha.universal as xu",
            "",
            "        todaydash = today_obj().strftime(\"%Y-%m-%d\")",
            "        if not start:",
            "            start = self.price.iloc[0][\"date\"].strftime(\"%Y-%m-%d\")",
            "        pagesize = int(",
            "            (today_obj() - dt.datetime.strptime(start, \"%Y-%m-%d\")).days / 5",
            "        )  # \u5982\u679c\u5b58\u5728\u4e00\u5468\u8d85\u8fc7\u4e00\u6b21\u5206\u7ea2\u7684\u57fa\u91d1\uff0c\u7b97\u6211\u6ca1\u8bf4",
            "        self.hkfcode = xu.get_hkfcode(self.code)",
            "        r = rget_json(",
            "            \"http://overseas.1234567.com.cn/overseasapi/OpenApiHander.ashx?\\",
            "api=HKFDApi&m=MethodJZ&hkfcode={hkfcode}&action=3&pageindex=0&pagesize={pagesize}&date1={startdash}&date2={enddash}&callback=\".format(",
            "                hkfcode=self.hkfcode,",
            "                pagesize=pagesize,",
            "                startdash=start,",
            "                enddash=todaydash,",
            "            )",
            "        )",
            "        return r[\"Data\"]",
            "",
            "",
            "class indexinfo(basicinfo):",
            "    \"\"\"",
            "    Get everyday close price of specific index.",
            "    In self.price table, totvalue column is the real index",
            "    while netvalue comlumn is normalized to 1 for the start date.",
            "    In principle, this class can also be used to save stock prices but the price is without adjusted.",
            "",
            "    :param code: string with seven digitals! note the code here has an extra digit at the beginning,",
            "        0 for sh and 1 for sz.",
            "    :param value_label: int, default 0 or 1. If set to 1, \u8bb0\u8d26\u5355\u6570\u5b57\u6309\u91d1\u989d\u8d4e\u56de\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, code, value_label=0, fetch=False, save=False, path=\"\", form=\"csv\"",
            "    ):",
            "        date = yesterday()",
            "        if code.startswith(\"SH\") and code[2:].isdigit():",
            "            code = \"0\" + code[2:]",
            "        elif code.startswith(\"SZ\") and code[2:].isdigit():",
            "            code = \"1\" + code[2:]",
            "        self.rate = 0",
            "        self._url = (",
            "            \"http://quotes.money.163.com/service/chddata.html?code=\"",
            "            + code",
            "            + \"&start=19901219&end=\"",
            "            + date",
            "            + \"&fields=TCLOSE\"",
            "        )",
            "        super().__init__(",
            "            code, value_label=value_label, fetch=fetch, save=save, path=path, form=form",
            "        )",
            "",
            "    def _basic_init(self):",
            "        raw = rget(self._url)",
            "        raw.encoding = \"gbk\"",
            "        cr = csv.reader(raw.text.splitlines(), delimiter=\",\")",
            "        my_list = list(cr)",
            "        factor = float(my_list[-1][3])",
            "        dd = {",
            "            \"date\": [",
            "                dt.datetime.strptime(my_list[i + 1][0], \"%Y-%m-%d\")",
            "                for i in range(len(my_list) - 1)",
            "            ],",
            "            \"netvalue\": [",
            "                float(my_list[i + 1][3]) / factor for i in range(len(my_list) - 1)",
            "            ],",
            "            \"totvalue\": [float(my_list[i + 1][3]) for i in range(len(my_list) - 1)],",
            "            \"comment\": [0 for _ in range(len(my_list) - 1)],",
            "        }",
            "        index = pd.DataFrame(data=dd)",
            "        index = index.iloc[::-1]",
            "        index = index.reset_index(drop=True)",
            "        self.price = index[index[\"date\"].isin(opendate)]",
            "        self.price = self.price[self.price[\"date\"] <= yesterdaydash()]",
            "        self.name = my_list[-1][2]",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        self.price.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            pricetable = pd.read_csv(path + self.code + \".csv\")",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        self.price.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            pricetable = pd.read_sql(\"xa\" + self.code, path)",
            "            self.price = pricetable",
            "",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def update(self):",
            "        lastdate = self.price.iloc[-1].date",
            "        lastdatestr = lastdate.strftime(\"%Y%m%d\")",
            "        weight = self.price.iloc[1].totvalue",
            "        self._updateurl = (",
            "            \"http://quotes.money.163.com/service/chddata.html?code=\"",
            "            + self.code",
            "            + \"&start=\"",
            "            + lastdatestr",
            "            + \"&end=\"",
            "            + yesterday()",
            "            + \"&fields=TCLOSE\"",
            "        )",
            "        try:",
            "            df = pd.read_csv(self._updateurl, encoding=\"gb2312\")",
            "            # 163 source is failing now",
            "        except Exception:",
            "            raise ValueError(",
            "                \"don't use indexinfo currently, see \\",
            "            https://github.com/refraction-ray/xalpha/issues/133#issuecomment-865447292\"",
            "            )",
            "        self.name = df.iloc[0].loc[\"\u540d\u79f0\"]",
            "        if len(df) > 1:",
            "            df = df.rename(columns={\"\u6536\u76d8\u4ef7\": \"totvalue\"})",
            "            df[\"date\"] = pd.to_datetime(df.\u65e5\u671f)",
            "            df = df.drop([\"\u80a1\u7968\u4ee3\u7801\", \"\u540d\u79f0\", \"\u65e5\u671f\"], axis=1)",
            "            df[\"netvalue\"] = df.totvalue / weight",
            "            df[\"comment\"] = [0 for _ in range(len(df))]",
            "            df = df.iloc[::-1].iloc[1:]",
            "            df = df[df[\"date\"].isin(opendate)]",
            "            df = df.reset_index(drop=True)",
            "            df = df[df[\"date\"] <= yesterdayobj()]",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "",
            "class cashinfo(basicinfo):",
            "    \"\"\"",
            "    A virtual class for remaining cash manage: behave like monetary fund",
            "",
            "    :param interest: float, daily rate in the unit of 100%, note this is not a year return rate!",
            "    :param start: str of date or dateobj, the virtual starting date of the cash fund",
            "    :param value_label: int, default 0 or 1. If set to 1, \u8bb0\u8d26\u5355\u6570\u5b57\u6309\u91d1\u989d\u8d4e\u56de\u3002",
            "    \"\"\"",
            "",
            "    def __init__(self, interest=0.0001, start=\"2012-01-01\", value_label=0):",
            "        self.interest = interest",
            "        start = convert_date(start)",
            "        self.start = start",
            "        super().__init__(",
            "            \"mf\", value_label=value_label, fetch=False, save=False, path=\"nobackend\"",
            "        )  # \u6c38\u8fdc\u4e0d\u7f13\u5b58 cashinfo",
            "",
            "    def _basic_init(self):",
            "        self.name = \"\u8d27\u5e01\u57fa\u91d1\"",
            "        self.rate = 0",
            "        datel = list(",
            "            pd.date_range(dt.datetime.strftime(self.start, \"%Y-%m-%d\"), yesterdaydash())",
            "        )",
            "        valuel = []",
            "        for i, date in enumerate(datel):",
            "            valuel.append((1 + self.interest) ** i)",
            "        dfdict = {",
            "            \"date\": datel,",
            "            \"netvalue\": valuel,",
            "            \"totvalue\": valuel,",
            "            \"comment\": [0 for _ in datel],",
            "        }",
            "        df = pd.DataFrame(data=dfdict)",
            "        self.price = df[df[\"date\"].isin(opendate)]",
            "",
            "",
            "class mfundinfo(basicinfo):",
            "    \"\"\"",
            "    \u771f\u5b9e\u7684\u8d27\u5e01\u57fa\u91d1\u7c7b\uff0c\u53ef\u4ee5\u901a\u8fc7\u8d27\u5e01\u57fa\u91d1\u516d\u4f4d\u4ee3\u7801\uff0c\u6765\u83b7\u53d6\u771f\u5b9e\u7684\u8d27\u5e01\u57fa\u91d1\u4e1a\u7ee9\uff0c\u5e76\u8fdb\u884c\u4ea4\u6613\u56de\u6d4b\u7b49",
            "",
            "    :param code: string of six digitals, code of real monetnary fund",
            "    :param round_label: int, default 0 or 1, label to the different round scheme of shares, reserved for fundinfo class. 1 \u4ee3\u8868\u5168\u820d\u800c\u975e\u56db\u820d\u4e94\u5165\u3002",
            "    :param value_label: int, default 0 or 1. 1 \u4ee3\u8868\u8bb0\u8d26\u5355\u4e0a\u7684\u8d4e\u56de\u6570\u76ee\u662f\u6309\u91d1\u989d\u800c\u975e\u4efd\u989d\u7684\uff0c\u53ea\u80fd\u5b8c\u7f8e\u652f\u6301\u8d27\u5e01\u57fa\u91d1\u3002",
            "    :param fetch: boolean, when open the fetch option, the class will try fetching from local files first in the init",
            "    :param save: boolean, when open the save option, automatically save the class to files",
            "    :param path: string, the file path prefix of IO",
            "    :param form: string, the format of IO, options including: 'csv'",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        code,",
            "        round_label=0,",
            "        value_label=0,",
            "        fetch=False,",
            "        save=False,",
            "        path=\"\",",
            "        form=\"csv\",",
            "    ):",
            "        if code.startswith(\"M\") and code[1:].isdigit():",
            "            code = code[1:]",
            "        code = code.zfill(6)",
            "        self._url = \"http://fund.eastmoney.com/pingzhongdata/\" + code + \".js\"",
            "        self.rate = 0",
            "        super().__init__(",
            "            code,",
            "            fetch=fetch,",
            "            save=save,",
            "            path=path,",
            "            form=form,",
            "            round_label=round_label,",
            "            value_label=value_label,",
            "        )",
            "",
            "    def _basic_init(self):",
            "        self._page = rget(self._url)",
            "        if self._page.text[:800].find(\"Data_fundSharesPositions\") >= 0:",
            "            raise FundTypeError(\"This code seems to be a fund, use fundinfo instead\")",
            "        l = eval(",
            "            re.match(",
            "                r\"[\\s\\S]*Data_millionCopiesIncome = ([^;]*);[\\s\\S]*\", self._page.text",
            "            ).groups()[0]",
            "        )",
            "        self.name = re.match(",
            "            r\"[\\s\\S]*fS_name = \\\"([^;]*)\\\";[\\s\\S]*\", self._page.text",
            "        ).groups()[0]",
            "        tz_bj = dt.timezone(dt.timedelta(hours=8))",
            "        datel = [",
            "            dt.datetime.fromtimestamp(int(d[0]) / 1e3, tz=tz_bj).replace(tzinfo=None)",
            "            for d in l",
            "        ]",
            "        ratel = [float(d[1]) for d in l]",
            "        netvalue = [1]",
            "        for dailyrate in ratel:",
            "            netvalue.append(netvalue[-1] * (1 + dailyrate * 1e-4))",
            "        netvalue.remove(1)",
            "",
            "        df = pd.DataFrame(",
            "            data={",
            "                \"date\": datel,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": netvalue,",
            "                \"comment\": [0 for _ in datel],",
            "            }",
            "        )",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        if len(df) == 0:",
            "            raise ParserFailure(\"no price table for %s\" % self.code)",
            "        df = df.reset_index(drop=True)",
            "        self.price = df[df[\"date\"] <= yesterdaydash()]",
            "",
            "    def _save_csv(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into path+code.csv, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        df = pd.DataFrame(",
            "            [[0, 0, self.name, 0]], columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"]",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_csv(",
            "            path + self.code + \".csv\", index=False, date_format=\"%Y-%m-%d\"",
            "        )",
            "",
            "    def _fetch_csv(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from path+code.csv, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  string of folder path",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_csv(path + self.code + \".csv\")",
            "            pricetable = content.iloc[1:]",
            "            datel = list(pd.to_datetime(pricetable.date))",
            "            self.price = pricetable[[\"netvalue\", \"totvalue\", \"comment\"]]",
            "            self.price[\"date\"] = datel",
            "            self.name = content.iloc[0].comment",
            "        except FileNotFoundError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def _save_sql(self, path):",
            "        \"\"\"",
            "        save the information and pricetable into sql, not recommend to use manually,",
            "        just set the save label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        s = json.dumps({\"name\": self.name})",
            "        df = pd.DataFrame(",
            "            [[pd.Timestamp(\"1990-01-01\"), 0, s, 0]],",
            "            columns=[\"date\", \"netvalue\", \"comment\", \"totvalue\"],",
            "        )",
            "        df = df.append(self.price, ignore_index=True, sort=True)",
            "        df.sort_index(axis=1).to_sql(",
            "            \"xa\" + self.code, con=path, if_exists=\"replace\", index=False",
            "        )",
            "",
            "    def _fetch_sql(self, path):",
            "        \"\"\"",
            "        fetch the information and pricetable from sql, not recommend to use manually,",
            "        just set the fetch label to be true when init the object",
            "",
            "        :param path:  engine object from sqlalchemy",
            "        \"\"\"",
            "        try:",
            "            content = pd.read_sql(\"xa\" + self.code, path)",
            "            pricetable = content.iloc[1:]",
            "            commentl = [float(com) for com in pricetable.comment]",
            "            self.price = pricetable[[\"date\", \"netvalue\", \"totvalue\"]]",
            "            self.price[\"comment\"] = commentl",
            "            self.name = json.loads(content.iloc[0].comment)[\"name\"]",
            "        except exc.ProgrammingError as e:",
            "            # print('no saved copy of %s' % self.code)",
            "            raise e",
            "",
            "    def update(self):",
            "        \"\"\"",
            "        function to incrementally update the pricetable after fetch the old one",
            "        \"\"\"",
            "        lastdate = self.price.iloc[-1].date",
            "        startvalue = self.price.iloc[-1].totvalue",
            "        diffdays = (yesterdayobj() - lastdate).days",
            "        if diffdays == 0:",
            "            return None",
            "        self._updateurl = (",
            "            \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "            + self.code",
            "            + \"&page=1&per=1\"",
            "        )",
            "        con = rget(self._updateurl)",
            "        soup = BeautifulSoup(con.text, \"lxml\")",
            "        items = soup.findAll(\"td\")",
            "        if dt.datetime.strptime(str(items[0].string), \"%Y-%m-%d\") == today_obj():",
            "            diffdays += 1",
            "        if diffdays <= 10:",
            "            # caution: there may be today data!! then a day gap will be in table",
            "            self._updateurl = (",
            "                \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                + self.code",
            "                + \"&page=1&per=\"",
            "                + str(diffdays)",
            "            )",
            "            con = rget(self._updateurl)",
            "            soup = BeautifulSoup(con.text, \"lxml\")",
            "            items = soup.findAll(\"td\")",
            "        elif (",
            "            diffdays > 10",
            "        ):  ## there is a 20 item per page limit in the API, so to be safe, we query each page by 10 items only",
            "            items = []",
            "            for pg in range(1, int(diffdays / 10) + 2):",
            "                self._updateurl = (",
            "                    \"http://fund.eastmoney.com/f10/F10DataApi.aspx?type=lsjz&code=\"",
            "                    + self.code",
            "                    + \"&page=\"",
            "                    + str(pg)",
            "                    + \"&per=10\"",
            "                )",
            "                con = rget(self._updateurl)",
            "                soup = BeautifulSoup(con.text, \"lxml\")",
            "                items.extend(soup.findAll(\"td\"))",
            "        else:",
            "            raise TradeBehaviorError(",
            "                \"Weird incremental update: the saved copy has future records\"",
            "            )",
            "",
            "        date = []",
            "        earnrate = []",
            "        comment = []",
            "        for i in range(int(len(items) / 6)):",
            "            ts = pd.Timestamp(str(items[6 * i].string))",
            "            if (ts - lastdate).days > 0:",
            "                date.append(ts)",
            "                earnrate.append(float(items[6 * i + 1].string) * 1e-4)",
            "                comment.append(_nfloat(items[6 * i + 5].string))",
            "        date = date[::-1]",
            "        earnrate = earnrate[::-1]",
            "        comment = comment[::-1]",
            "        netvalue = [startvalue]",
            "        for earn in earnrate:",
            "            netvalue.append(netvalue[-1] * (1 + earn))",
            "        netvalue.remove(startvalue)",
            "",
            "        df = pd.DataFrame(",
            "            {",
            "                \"date\": date,",
            "                \"netvalue\": netvalue,",
            "                \"totvalue\": netvalue,",
            "                \"comment\": comment,",
            "            }",
            "        )",
            "        df = df[df[\"date\"].isin(opendate)]",
            "        df = df.reset_index(drop=True)",
            "        df = df[df[\"date\"] <= yesterdayobj()]",
            "        if len(df) != 0:",
            "            self.price = self.price.append(df, ignore_index=True, sort=True)",
            "            return df",
            "",
            "",
            "FundInfo = fundinfo",
            "MFundInfo = mfundinfo",
            "CashInfo = cashinfo",
            "IndexInfo = indexinfo"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "xalpha.info.fundinfo",
            "PyPDF2.pdf"
        ]
    }
}