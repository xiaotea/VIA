{
    "octavia/cmd/agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         'timeout': CONF.amphora_agent.agent_request_read_timeout,"
            },
            "1": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         'certfile': CONF.amphora_agent.agent_server_cert,"
            },
            "2": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         'ca_certs': CONF.amphora_agent.agent_server_ca,"
            },
            "3": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'cert_reqs': True,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        'cert_reqs': ssl.CERT_REQUIRED,"
            },
            "5": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         'ssl_version': getattr(ssl, \"PROTOCOL_%s\" % proto),"
            },
            "6": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         'preload_app': True,"
            },
            "7": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         'accesslog': '/var/log/amphora-agent.log',"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# make sure PYTHONPATH includes the home directory if you didn't install",
            "",
            "import multiprocessing as multiproc",
            "import ssl",
            "import sys",
            "",
            "import gunicorn.app.base",
            "from oslo_config import cfg",
            "from oslo_reports import guru_meditation_report as gmr",
            "",
            "from octavia.amphorae.backends.agent.api_server import server",
            "from octavia.amphorae.backends.health_daemon import health_daemon",
            "from octavia.common import service",
            "from octavia.common import utils",
            "from octavia import version",
            "",
            "",
            "CONF = cfg.CONF",
            "HM_SENDER_CMD_QUEUE = multiproc.Queue()",
            "",
            "",
            "class AmphoraAgent(gunicorn.app.base.BaseApplication):",
            "    def __init__(self, app, options=None):",
            "        self.options = options or {}",
            "        self.application = app",
            "        super(AmphoraAgent, self).__init__()",
            "",
            "    def load_config(self):",
            "        config = {key: value for key, value in self.options.items()",
            "                  if key in self.cfg.settings and value is not None}",
            "        for key, value in config.items():",
            "            self.cfg.set(key.lower(), value)",
            "",
            "    def load(self):",
            "        return self.application",
            "",
            "",
            "# start api server",
            "def main():",
            "    # comment out to improve logging",
            "    service.prepare_service(sys.argv)",
            "",
            "    gmr.TextGuruMeditation.setup_autorun(version)",
            "",
            "    health_sender_proc = multiproc.Process(name='HM_sender',",
            "                                           target=health_daemon.run_sender,",
            "                                           args=(HM_SENDER_CMD_QUEUE,))",
            "    health_sender_proc.daemon = True",
            "    health_sender_proc.start()",
            "",
            "    # Initiate server class",
            "    server_instance = server.Server()",
            "",
            "    bind_ip_port = utils.ip_port_str(CONF.haproxy_amphora.bind_host,",
            "                                     CONF.haproxy_amphora.bind_port)",
            "    proto = CONF.amphora_agent.agent_tls_protocol.replace('.', '_')",
            "    options = {",
            "        'bind': bind_ip_port,",
            "        'workers': 1,",
            "        'timeout': CONF.amphora_agent.agent_request_read_timeout,",
            "        'certfile': CONF.amphora_agent.agent_server_cert,",
            "        'ca_certs': CONF.amphora_agent.agent_server_ca,",
            "        'cert_reqs': True,",
            "        'ssl_version': getattr(ssl, \"PROTOCOL_%s\" % proto),",
            "        'preload_app': True,",
            "        'accesslog': '/var/log/amphora-agent.log',",
            "        'errorlog': '/var/log/amphora-agent.log',",
            "        'loglevel': 'debug',",
            "        'syslog': True,",
            "        'syslog_facility': 'local{}'.format(",
            "            CONF.amphora_agent.administrative_log_facility),",
            "        'syslog_addr': 'unix://run/rsyslog/octavia/log#dgram',",
            "",
            "    }",
            "    AmphoraAgent(server_instance.app, options).run()"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# make sure PYTHONPATH includes the home directory if you didn't install",
            "",
            "import multiprocessing as multiproc",
            "import ssl",
            "import sys",
            "",
            "import gunicorn.app.base",
            "from oslo_config import cfg",
            "from oslo_reports import guru_meditation_report as gmr",
            "",
            "from octavia.amphorae.backends.agent.api_server import server",
            "from octavia.amphorae.backends.health_daemon import health_daemon",
            "from octavia.common import service",
            "from octavia.common import utils",
            "from octavia import version",
            "",
            "",
            "CONF = cfg.CONF",
            "HM_SENDER_CMD_QUEUE = multiproc.Queue()",
            "",
            "",
            "class AmphoraAgent(gunicorn.app.base.BaseApplication):",
            "    def __init__(self, app, options=None):",
            "        self.options = options or {}",
            "        self.application = app",
            "        super(AmphoraAgent, self).__init__()",
            "",
            "    def load_config(self):",
            "        config = {key: value for key, value in self.options.items()",
            "                  if key in self.cfg.settings and value is not None}",
            "        for key, value in config.items():",
            "            self.cfg.set(key.lower(), value)",
            "",
            "    def load(self):",
            "        return self.application",
            "",
            "",
            "# start api server",
            "def main():",
            "    # comment out to improve logging",
            "    service.prepare_service(sys.argv)",
            "",
            "    gmr.TextGuruMeditation.setup_autorun(version)",
            "",
            "    health_sender_proc = multiproc.Process(name='HM_sender',",
            "                                           target=health_daemon.run_sender,",
            "                                           args=(HM_SENDER_CMD_QUEUE,))",
            "    health_sender_proc.daemon = True",
            "    health_sender_proc.start()",
            "",
            "    # Initiate server class",
            "    server_instance = server.Server()",
            "",
            "    bind_ip_port = utils.ip_port_str(CONF.haproxy_amphora.bind_host,",
            "                                     CONF.haproxy_amphora.bind_port)",
            "    proto = CONF.amphora_agent.agent_tls_protocol.replace('.', '_')",
            "    options = {",
            "        'bind': bind_ip_port,",
            "        'workers': 1,",
            "        'timeout': CONF.amphora_agent.agent_request_read_timeout,",
            "        'certfile': CONF.amphora_agent.agent_server_cert,",
            "        'ca_certs': CONF.amphora_agent.agent_server_ca,",
            "        'cert_reqs': ssl.CERT_REQUIRED,",
            "        'ssl_version': getattr(ssl, \"PROTOCOL_%s\" % proto),",
            "        'preload_app': True,",
            "        'accesslog': '/var/log/amphora-agent.log',",
            "        'errorlog': '/var/log/amphora-agent.log',",
            "        'loglevel': 'debug',",
            "        'syslog': True,",
            "        'syslog_facility': 'local{}'.format(",
            "            CONF.amphora_agent.administrative_log_facility),",
            "        'syslog_addr': 'unix://run/rsyslog/octavia/log#dgram',",
            "",
            "    }",
            "    AmphoraAgent(server_instance.app, options).run()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "77": [
                "main"
            ]
        },
        "addLocation": []
    },
    "octavia/tests/unit/cmd/test_agent.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " #    License for the specific language governing permissions and limitations"
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " #    under the License."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+import ssl"
            },
            "4": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import mock"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         agent.main()"
            },
            "9": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        # Ensure gunicorn is initialized with the correct cert_reqs option."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        # This option is what enforces use of a valid client certificate."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        self.assertEqual("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            ssl.CERT_REQUIRED,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            mock_amp.call_args[0][1]['cert_reqs'])"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         mock_health_proc.start.assert_called_once_with()"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         mock_amp_instance.run.assert_called_once()"
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "",
            "from octavia.cmd import agent",
            "from octavia.tests.unit import base",
            "",
            "",
            "class TestAmphoraAgentCMD(base.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestAmphoraAgentCMD, self).setUp()",
            "",
            "    @mock.patch('octavia.cmd.agent.AmphoraAgent')",
            "    @mock.patch('octavia.amphorae.backends.agent.api_server.server.Server')",
            "    @mock.patch('multiprocessing.Process')",
            "    @mock.patch('octavia.common.service.prepare_service')",
            "    def test_main(self, mock_service, mock_process, mock_server, mock_amp):",
            "        mock_health_proc = mock.MagicMock()",
            "        mock_server_instance = mock.MagicMock()",
            "        mock_amp_instance = mock.MagicMock()",
            "",
            "        mock_process.return_value = mock_health_proc",
            "        mock_server.return_value = mock_server_instance",
            "        mock_amp.return_value = mock_amp_instance",
            "",
            "        agent.main()",
            "",
            "        mock_health_proc.start.assert_called_once_with()",
            "        mock_amp_instance.run.assert_called_once()"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import ssl",
            "",
            "import mock",
            "",
            "from octavia.cmd import agent",
            "from octavia.tests.unit import base",
            "",
            "",
            "class TestAmphoraAgentCMD(base.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestAmphoraAgentCMD, self).setUp()",
            "",
            "    @mock.patch('octavia.cmd.agent.AmphoraAgent')",
            "    @mock.patch('octavia.amphorae.backends.agent.api_server.server.Server')",
            "    @mock.patch('multiprocessing.Process')",
            "    @mock.patch('octavia.common.service.prepare_service')",
            "    def test_main(self, mock_service, mock_process, mock_server, mock_amp):",
            "        mock_health_proc = mock.MagicMock()",
            "        mock_server_instance = mock.MagicMock()",
            "        mock_amp_instance = mock.MagicMock()",
            "",
            "        mock_process.return_value = mock_health_proc",
            "        mock_server.return_value = mock_server_instance",
            "        mock_amp.return_value = mock_amp_instance",
            "",
            "        agent.main()",
            "",
            "        # Ensure gunicorn is initialized with the correct cert_reqs option.",
            "        # This option is what enforces use of a valid client certificate.",
            "        self.assertEqual(",
            "            ssl.CERT_REQUIRED,",
            "            mock_amp.call_args[0][1]['cert_reqs'])",
            "",
            "        mock_health_proc.start.assert_called_once_with()",
            "        mock_amp_instance.run.assert_called_once()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "snapcraft.internal.meta._snap_packaging._SnapPackaging.write_snap_yaml"
        ]
    }
}