{
    "oslo_utils/strutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " # for XML and JSON automatically."
            },
            "1": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " _SANITIZE_PATTERNS_2 = {}"
            },
            "2": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " _SANITIZE_PATTERNS_1 = {}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+_SANITIZE_PATTERNS_WILDCARD = {}"
            },
            "4": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " # NOTE(amrith): Some regular expressions have only one parameter, some"
            },
            "6": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " # have two parameters. Use different lists of patterns here."
            },
            "7": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                       r'([\\'\"][^\\'\"]*%(key)s[0-9]*[\\'\"]\\s*,\\s*\\'--?[A-z]+'"
            },
            "8": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                       r'\\'\\s*,\\s*u?[\\'\"])[^\\\"\\']*([\\'\"])',"
            },
            "9": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                       r'(%(key)s[0-9]*\\s*--?[A-z]+\\s*)\\S+(\\s*)']"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+_FORMAT_PATTERNS_WILDCARD = [r'([\\'\\\"][^\\\"\\']*%(key)s[0-9]*[\\'\\\"]\\s*:\\s*u?[\\'\\\"].*[\\'\\\"])[^\\\"\\']*([\\'\\\"])']  # noqa: E501"
            },
            "11": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " # NOTE(dhellmann): Keep a separate list of patterns by key so we only"
            },
            "13": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " # need to apply the substitutions for keys we find using a quick \"in\""
            },
            "14": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " # test."
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " for key in _SANITIZE_KEYS:"
            },
            "16": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     _SANITIZE_PATTERNS_1[key] = []"
            },
            "17": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     _SANITIZE_PATTERNS_2[key] = []"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    _SANITIZE_PATTERNS_WILDCARD[key] = []"
            },
            "19": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     for pattern in _FORMAT_PATTERNS_2:"
            },
            "21": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)"
            },
            "22": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)"
            },
            "23": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         _SANITIZE_PATTERNS_1[key].append(reg_ex)"
            },
            "24": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    for pattern in _FORMAT_PATTERNS_WILDCARD:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        _SANITIZE_PATTERNS_WILDCARD[key].append(reg_ex)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " def int_from_bool_as_string(subject):"
            },
            "31": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     \"\"\"Interpret a string as a boolean and return either 1 or 0."
            },
            "32": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 338,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     substitute1 = r'\\g<1>' + secret"
            },
            "34": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     substitute2 = r'\\g<1>' + secret + r'\\g<2>'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+    substitute_wildcard = r'\\g<1>'"
            },
            "36": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 342,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "     # NOTE(ldbragst): Check to see if anything in message contains any key"
            },
            "38": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "     # specified in _SANITIZE_KEYS, if not then just return the message since"
            },
            "39": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "                 message = re.sub(pattern, substitute2, message)"
            },
            "40": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "             for pattern in _SANITIZE_PATTERNS_1[key]:"
            },
            "41": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "                 message = re.sub(pattern, substitute1, message)"
            },
            "42": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+            # NOTE(hberaud): Those case are poorly handled by previous"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+            # patterns. They are passwords with quotes or double quotes."
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+            # They also needs a different way to substitute group this is why"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+            # they aren't fix in the pattern 1 or 2."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+            for pattern in _SANITIZE_PATTERNS_WILDCARD[key]:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+                message = re.sub(pattern, substitute_wildcard, message)"
            },
            "49": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "     return message"
            },
            "50": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 359,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "System-level utilities and helper functions.",
            "\"\"\"",
            "",
            "import collections",
            "import math",
            "import re",
            "import unicodedata",
            "import urllib",
            "",
            "import pyparsing as pp",
            "",
            "from oslo_utils._i18n import _",
            "from oslo_utils import encodeutils",
            "",
            "",
            "UNIT_PREFIX_EXPONENT = {",
            "    'k': 1,",
            "    'K': 1,",
            "    'Ki': 1,",
            "    'M': 2,",
            "    'Mi': 2,",
            "    'G': 3,",
            "    'Gi': 3,",
            "    'T': 4,",
            "    'Ti': 4,",
            "}",
            "UNIT_SYSTEM_INFO = {",
            "    'IEC': (1024, re.compile(r'(^[-+]?\\d*\\.?\\d+)([KMGT]i?)?(b|bit|B)$')),",
            "    'SI': (1000, re.compile(r'(^[-+]?\\d*\\.?\\d+)([kMGT])?(b|bit|B)$')),",
            "    'mixed': (None, re.compile(r'(^[-+]?\\d*\\.?\\d+)([kKMGT]i?)?(b|bit|B)$')),",
            "}",
            "",
            "TRUE_STRINGS = ('1', 't', 'true', 'on', 'y', 'yes')",
            "FALSE_STRINGS = ('0', 'f', 'false', 'off', 'n', 'no')",
            "",
            "SLUGIFY_STRIP_RE = re.compile(r\"[^\\w\\s-]\")",
            "SLUGIFY_HYPHENATE_RE = re.compile(r\"[-\\s]+\")",
            "",
            "",
            "# NOTE(flaper87): The following globals are used by `mask_password` and",
            "#                 `mask_dict_password`. They must all be lowercase.",
            "_SANITIZE_KEYS = ['adminpass', 'admin_pass', 'password', 'admin_password',",
            "                  'auth_token', 'new_pass', 'auth_password', 'secret_uuid',",
            "                  'secret', 'sys_pswd', 'token', 'configdrive',",
            "                  'chappassword', 'encrypted_key', 'private_key',",
            "                  'encryption_key_id', 'fernetkey', 'sslkey', 'passphrase',",
            "                  'cephclusterfsid', 'octaviaheartbeatkey', 'rabbitcookie',",
            "                  'cephmanilaclientkey', 'pacemakerremoteauthkey',",
            "                  'designaterndckey', 'cephadminkey', 'heatauthencryptionkey',",
            "                  'cephclientkey', 'keystonecredential',",
            "                  'barbicansimplecryptokek', 'cephrgwkey', 'swifthashsuffix',",
            "                  'migrationsshkey', 'cephmdskey', 'cephmonkey']",
            "",
            "# NOTE(ldbragst): Let's build a list of regex objects using the list of",
            "# _SANITIZE_KEYS we already have. This way, we only have to add the new key",
            "# to the list of _SANITIZE_KEYS and we can generate regular expressions",
            "# for XML and JSON automatically.",
            "_SANITIZE_PATTERNS_2 = {}",
            "_SANITIZE_PATTERNS_1 = {}",
            "",
            "# NOTE(amrith): Some regular expressions have only one parameter, some",
            "# have two parameters. Use different lists of patterns here.",
            "_FORMAT_PATTERNS_1 = [r'(%(key)s[0-9]*\\s*[=]\\s*)[^\\s^\\'^\\\"]+']",
            "_FORMAT_PATTERNS_2 = [r'(%(key)s[0-9]*\\s*[=]\\s*[\\\"\\'])[^\\\"\\']*([\\\"\\'])',",
            "                      r'(%(key)s[0-9]*\\s+[\\\"\\'])[^\\\"\\']*([\\\"\\'])',",
            "                      r'([-]{2}%(key)s[0-9]*\\s+)[^\\'^\\\"^=^\\s]+([\\s]*)',",
            "                      r'(<%(key)s[0-9]*>)[^<]*(</%(key)s[0-9]*>)',",
            "                      r'([\\\"\\']%(key)s[0-9]*[\\\"\\']\\s*:\\s*[\\\"\\'])[^\\\"\\']*'",
            "                      r'([\\\"\\'])',",
            "                      r'([\\'\"][^\"\\']*%(key)s[0-9]*[\\'\"]\\s*:\\s*u?[\\'\"])[^\\\"\\']*'",
            "                      r'([\\'\"])',",
            "                      r'([\\'\"][^\\'\"]*%(key)s[0-9]*[\\'\"]\\s*,\\s*\\'--?[A-z]+'",
            "                      r'\\'\\s*,\\s*u?[\\'\"])[^\\\"\\']*([\\'\"])',",
            "                      r'(%(key)s[0-9]*\\s*--?[A-z]+\\s*)\\S+(\\s*)']",
            "",
            "# NOTE(dhellmann): Keep a separate list of patterns by key so we only",
            "# need to apply the substitutions for keys we find using a quick \"in\"",
            "# test.",
            "for key in _SANITIZE_KEYS:",
            "    _SANITIZE_PATTERNS_1[key] = []",
            "    _SANITIZE_PATTERNS_2[key] = []",
            "",
            "    for pattern in _FORMAT_PATTERNS_2:",
            "        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)",
            "        _SANITIZE_PATTERNS_2[key].append(reg_ex)",
            "",
            "    for pattern in _FORMAT_PATTERNS_1:",
            "        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)",
            "        _SANITIZE_PATTERNS_1[key].append(reg_ex)",
            "",
            "",
            "def int_from_bool_as_string(subject):",
            "    \"\"\"Interpret a string as a boolean and return either 1 or 0.",
            "",
            "    Any string value in:",
            "",
            "        ('True', 'true', 'On', 'on', '1')",
            "",
            "    is interpreted as a boolean True.",
            "",
            "    Useful for JSON-decoded stuff and config file parsing",
            "    \"\"\"",
            "    return int(bool_from_string(subject))",
            "",
            "",
            "def bool_from_string(subject, strict=False, default=False):",
            "    \"\"\"Interpret a subject as a boolean.",
            "",
            "    A subject can be a boolean, a string or an integer. Boolean type value",
            "    will be returned directly, otherwise the subject will be converted to",
            "    a string. A case-insensitive match is performed such that strings",
            "    matching 't','true', 'on', 'y', 'yes', or '1' are considered True and,",
            "    when `strict=False`, anything else returns the value specified by",
            "    'default'.",
            "",
            "    Useful for JSON-decoded stuff and config file parsing.",
            "",
            "    If `strict=True`, unrecognized values, including None, will raise a",
            "    ValueError which is useful when parsing values passed in from an API call.",
            "    Strings yielding False are 'f', 'false', 'off', 'n', 'no', or '0'.",
            "    \"\"\"",
            "    if isinstance(subject, bool):",
            "        return subject",
            "    if not isinstance(subject, str):",
            "        subject = str(subject)",
            "",
            "    lowered = subject.strip().lower()",
            "",
            "    if lowered in TRUE_STRINGS:",
            "        return True",
            "    elif lowered in FALSE_STRINGS:",
            "        return False",
            "    elif strict:",
            "        acceptable = ', '.join(",
            "            \"'%s'\" % s for s in sorted(TRUE_STRINGS + FALSE_STRINGS))",
            "        msg = _(\"Unrecognized value '%(val)s', acceptable values are:\"",
            "                \" %(acceptable)s\") % {'val': subject,",
            "                                      'acceptable': acceptable}",
            "        raise ValueError(msg)",
            "    else:",
            "        return default",
            "",
            "",
            "def is_valid_boolstr(value):",
            "    \"\"\"Check if the provided string is a valid bool string or not.",
            "",
            "    :param value: value to verify",
            "    :type value: string",
            "    :returns: true if value is boolean string, false otherwise",
            "",
            "    .. versionadded:: 3.17",
            "    \"\"\"",
            "    boolstrs = TRUE_STRINGS + FALSE_STRINGS",
            "    return str(value).lower() in boolstrs",
            "",
            "",
            "def string_to_bytes(text, unit_system='IEC', return_int=False):",
            "    \"\"\"Converts a string into an float representation of bytes.",
            "",
            "    The units supported for IEC / mixed::",
            "",
            "        Kb(it), Kib(it), Mb(it), Mib(it), Gb(it), Gib(it), Tb(it), Tib(it)",
            "        KB, KiB, MB, MiB, GB, GiB, TB, TiB",
            "",
            "    The units supported for SI ::",
            "",
            "        kb(it), Mb(it), Gb(it), Tb(it)",
            "        kB, MB, GB, TB",
            "",
            "    SI units are interpreted as power-of-ten (e.g. 1kb = 1000b).  Note",
            "    that the SI unit system does not support capital letter 'K'",
            "",
            "    IEC units are interpreted as power-of-two (e.g. 1MiB = 1MB =",
            "    1024b)",
            "",
            "    Mixed units interpret the \"i\" to mean IEC, and no \"i\" to mean SI",
            "    (e.g. 1kb = 1000b, 1kib == 1024b).  Additionaly, mixed units",
            "    interpret 'K' as power-of-ten.  This mode is not particuarly",
            "    useful for new code, but can help with compatability for parsers",
            "    such as GNU parted.",
            "",
            "    :param text: String input for bytes size conversion.",
            "    :param unit_system: Unit system for byte size conversion.",
            "    :param return_int: If True, returns integer representation of text",
            "                       in bytes. (default: decimal)",
            "    :returns: Numerical representation of text in bytes.",
            "    :raises ValueError: If text has an invalid value.",
            "",
            "    \"\"\"",
            "    try:",
            "        base, reg_ex = UNIT_SYSTEM_INFO[unit_system]",
            "    except KeyError:",
            "        msg = _('Invalid unit system: \"%s\"') % unit_system",
            "        raise ValueError(msg)",
            "    match = reg_ex.match(text)",
            "    if match:",
            "        magnitude = float(match.group(1))",
            "        unit_prefix = match.group(2)",
            "        if match.group(3) in ['b', 'bit']:",
            "            magnitude /= 8",
            "",
            "        # In the mixed matcher, IEC units (with a trailing 'i') are",
            "        # interpreted as power-of-two, others as power-of-ten",
            "        if unit_system == 'mixed':",
            "            if unit_prefix and not unit_prefix.endswith('i'):",
            "                # For maximum compatability in mixed mode, we understand",
            "                # \"K\" (which is not strict SI) as \"k\"",
            "                if unit_prefix.startswith == 'K':",
            "                    unit_prefix = 'k'",
            "                base = 1000",
            "            else:",
            "                base = 1024",
            "    else:",
            "        msg = _('Invalid string format: %s') % text",
            "        raise ValueError(msg)",
            "",
            "    if not unit_prefix:",
            "        res = magnitude",
            "    else:",
            "        res = magnitude * pow(base, UNIT_PREFIX_EXPONENT[unit_prefix])",
            "    if return_int:",
            "        return int(math.ceil(res))",
            "    return res",
            "",
            "",
            "def to_slug(value, incoming=None, errors=\"strict\"):",
            "    \"\"\"Normalize string.",
            "",
            "    Convert to lowercase, remove non-word characters, and convert spaces",
            "    to hyphens.",
            "",
            "    Inspired by Django's `slugify` filter.",
            "",
            "    :param value: Text to slugify",
            "    :param incoming: Text's current encoding",
            "    :param errors: Errors handling policy. See here for valid",
            "        values http://docs.python.org/2/library/codecs.html",
            "    :returns: slugified unicode representation of `value`",
            "    :raises TypeError: If text is not an instance of str",
            "    \"\"\"",
            "    value = encodeutils.safe_decode(value, incoming, errors)",
            "    # NOTE(aababilov): no need to use safe_(encode|decode) here:",
            "    # encodings are always \"ascii\", error handling is always \"ignore\"",
            "    # and types are always known (first: unicode; second: str)",
            "    value = unicodedata.normalize(\"NFKD\", value).encode(",
            "        \"ascii\", \"ignore\").decode(\"ascii\")",
            "    value = SLUGIFY_STRIP_RE.sub(\"\", value).strip().lower()",
            "    return SLUGIFY_HYPHENATE_RE.sub(\"-\", value)",
            "",
            "",
            "# NOTE(dhellmann): Before submitting a patch to add a new argument to",
            "# this function to allow the caller to pass in \"extra\" or \"additional\"",
            "# or \"replacement\" patterns to be masked out, please note that we have",
            "# discussed that feature many times and always rejected it based on",
            "# the desire to have Oslo functions behave consistently across all",
            "# projects and *especially* to have security features work the same",
            "# way no matter where they are used. If every project adopted its own",
            "# set patterns for secret values, it would be very difficult to audit",
            "# the logging to ensure that everything is properly masked. So, please",
            "# either add your pattern to the module-level variables at the top of",
            "# this file or, even better, pick an existing pattern or key to use in",
            "# your application to ensure that the value is masked by this",
            "# function.",
            "def mask_password(message, secret=\"***\"):  # nosec",
            "    \"\"\"Replace password with *secret* in message.",
            "",
            "    :param message: The string which includes security information.",
            "    :param secret: value with which to replace passwords.",
            "    :returns: The unicode value of message with the password fields masked.",
            "",
            "    For example:",
            "",
            "    >>> mask_password(\"'adminPass' : 'aaaaa'\")",
            "    \"'adminPass' : '***'\"",
            "    >>> mask_password(\"'admin_pass' : 'aaaaa'\")",
            "    \"'admin_pass' : '***'\"",
            "    >>> mask_password('\"password\" : \"aaaaa\"')",
            "    '\"password\" : \"***\"'",
            "    >>> mask_password(\"'original_password' : 'aaaaa'\")",
            "    \"'original_password' : '***'\"",
            "    >>> mask_password(\"u'original_password' :   u'aaaaa'\")",
            "    \"u'original_password' :   u'***'\"",
            "",
            "    .. versionadded:: 0.2",
            "",
            "    .. versionchanged:: 1.1",
            "       Replace also ``'auth_token'``, ``'new_pass'`` and ``'auth_password'``",
            "       keys.",
            "",
            "    .. versionchanged:: 1.1.1",
            "       Replace also ``'secret_uuid'`` key.",
            "",
            "    .. versionchanged:: 1.5",
            "       Replace also ``'sys_pswd'`` key.",
            "",
            "    .. versionchanged:: 2.6",
            "       Replace also ``'token'`` key.",
            "",
            "    .. versionchanged:: 2.7",
            "       Replace also ``'secret'`` key.",
            "",
            "    .. versionchanged:: 3.4",
            "       Replace also ``'configdrive'`` key.",
            "",
            "    .. versionchanged:: 3.8",
            "       Replace also ``'CHAPPASSWORD'`` key.",
            "    \"\"\"",
            "",
            "    try:",
            "        message = str(message)",
            "    except UnicodeDecodeError:  # nosec",
            "        # NOTE(jecarey): Temporary fix to handle cases where message is a",
            "        # byte string. A better solution will be provided in Kilo.",
            "        pass",
            "",
            "    substitute1 = r'\\g<1>' + secret",
            "    substitute2 = r'\\g<1>' + secret + r'\\g<2>'",
            "",
            "    # NOTE(ldbragst): Check to see if anything in message contains any key",
            "    # specified in _SANITIZE_KEYS, if not then just return the message since",
            "    # we don't have to mask any passwords.",
            "    for key in _SANITIZE_KEYS:",
            "        if key in message.lower():",
            "            for pattern in _SANITIZE_PATTERNS_2[key]:",
            "                message = re.sub(pattern, substitute2, message)",
            "            for pattern in _SANITIZE_PATTERNS_1[key]:",
            "                message = re.sub(pattern, substitute1, message)",
            "",
            "    return message",
            "",
            "",
            "def mask_dict_password(dictionary, secret=\"***\"):  # nosec",
            "    \"\"\"Replace password with *secret* in a dictionary recursively.",
            "",
            "    :param dictionary: The dictionary which includes secret information.",
            "    :param secret: value with which to replace secret information.",
            "    :returns: The dictionary with string substitutions.",
            "",
            "    A dictionary (which may contain nested dictionaries) contains",
            "    information (such as passwords) which should not be revealed, and",
            "    this function helps detect and replace those with the 'secret'",
            "    provided (or `***` if none is provided).",
            "",
            "    Substitution is performed in one of three situations:",
            "",
            "    If the key is something that is considered to be indicative of a",
            "    secret, then the corresponding value is replaced with the secret",
            "    provided (or `***` if none is provided).",
            "",
            "    If a value in the dictionary is a string, then it is masked",
            "    using the ``mask_password()`` function.",
            "",
            "    Finally, if a value is a dictionary, this function will",
            "    recursively mask that dictionary as well.",
            "",
            "    For example:",
            "",
            "    >>> mask_dict_password({'password': 'd81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home-dir': '/home/admin'},",
            "    >>>                     '???')",
            "    {'password': '???', 'user': 'admin', 'home-dir': '/home/admin'}",
            "",
            "    For example (the value is masked using mask_password())",
            "",
            "    >>> mask_dict_password({'password': '--password d81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home-dir': '/home/admin'},",
            "    >>>                     '???')",
            "    {'password': '--password ???', 'user': 'admin',",
            "     'home-dir': '/home/admin'}",
            "",
            "",
            "    For example (a nested dictionary is masked):",
            "",
            "    >>> mask_dict_password({\"nested\": {'password': 'd81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home': '/home/admin'}},",
            "    >>>                     '???')",
            "    {\"nested\": {'password': '???', 'user': 'admin', 'home': '/home/admin'}}",
            "",
            "    .. versionadded:: 3.4",
            "",
            "    \"\"\"",
            "",
            "    if not isinstance(dictionary, collections.Mapping):",
            "        raise TypeError(\"Expected a Mapping, got %s instead.\"",
            "                        % type(dictionary))",
            "    out = {}",
            "    for k, v in dictionary.items():",
            "        if isinstance(v, collections.Mapping):",
            "            out[k] = mask_dict_password(v, secret=secret)",
            "            continue",
            "        # NOTE(jlvillal): Check to see if anything in the dictionary 'key'",
            "        # contains any key specified in _SANITIZE_KEYS.",
            "        k_matched = False",
            "        if isinstance(k, str):",
            "            for sani_key in _SANITIZE_KEYS:",
            "                if sani_key in k.lower():",
            "                    out[k] = secret",
            "                    k_matched = True",
            "                    break",
            "        if not k_matched:",
            "            # We did not find a match for the key name in the",
            "            # _SANITIZE_KEYS, so we fall through to here",
            "            if isinstance(v, str):",
            "                out[k] = mask_password(v, secret=secret)",
            "            else:",
            "                # Just leave it alone.",
            "                out[k] = v",
            "    return out",
            "",
            "",
            "def is_int_like(val):",
            "    \"\"\"Check if a value looks like an integer with base 10.",
            "",
            "    :param val: Value to verify",
            "    :type val: string",
            "    :returns: bool",
            "",
            "    .. versionadded:: 1.1",
            "    \"\"\"",
            "    try:",
            "        return str(int(val)) == str(val)",
            "    except (TypeError, ValueError):",
            "        return False",
            "",
            "",
            "def check_string_length(value, name=None, min_length=0, max_length=None):",
            "    \"\"\"Check the length of specified string.",
            "",
            "    :param value: the value of the string",
            "    :param name: the name of the string",
            "    :param min_length: the min_length of the string",
            "    :param max_length: the max_length of the string",
            "    :raises TypeError, ValueError: For any invalid input.",
            "",
            "    .. versionadded:: 3.7",
            "    \"\"\"",
            "    if name is None:",
            "        name = value",
            "",
            "    if not isinstance(value, str):",
            "        msg = _(\"%s is not a string or unicode\") % name",
            "        raise TypeError(msg)",
            "",
            "    length = len(value)",
            "    if length < min_length:",
            "        msg = _(\"%(name)s has %(length)s characters, less than \"",
            "                \"%(min_length)s.\") % {'name': name, 'length': length,",
            "                                      'min_length': min_length}",
            "        raise ValueError(msg)",
            "",
            "    if max_length and length > max_length:",
            "        msg = _(\"%(name)s has %(length)s characters, more than \"",
            "                \"%(max_length)s.\") % {'name': name, 'length': length,",
            "                                      'max_length': max_length}",
            "        raise ValueError(msg)",
            "",
            "",
            "def validate_integer(value, name, min_value=None, max_value=None):",
            "    \"\"\"Make sure that value is a valid integer, potentially within range.",
            "",
            "    :param value: value of the integer",
            "    :param name: name of the integer",
            "    :param min_value: min_value of the integer",
            "    :param max_value: max_value of the integer",
            "    :returns: integer",
            "    :raises: ValueError if value is an invalid integer",
            "",
            "    .. versionadded:: 3.33",
            "    \"\"\"",
            "    try:",
            "        value = int(str(value))",
            "    except (ValueError, UnicodeEncodeError):",
            "        msg = _('%(value_name)s must be an integer'",
            "                ) % {'value_name': name}",
            "        raise ValueError(msg)",
            "",
            "    if min_value is not None and value < min_value:",
            "        msg = _('%(value_name)s must be >= %(min_value)d'",
            "                ) % {'value_name': name, 'min_value': min_value}",
            "        raise ValueError(msg)",
            "",
            "    if max_value is not None and value > max_value:",
            "        msg = _('%(value_name)s must be <= %(max_value)d'",
            "                ) % {'value_name': name, 'max_value': max_value}",
            "        raise ValueError(msg)",
            "",
            "    return value",
            "",
            "",
            "def split_path(path, minsegs=1, maxsegs=None, rest_with_last=False):",
            "    \"\"\"Validate and split the given HTTP request path.",
            "",
            "    **Examples**::",
            "",
            "        ['a'] = _split_path('/a')",
            "        ['a', None] = _split_path('/a', 1, 2)",
            "        ['a', 'c'] = _split_path('/a/c', 1, 2)",
            "        ['a', 'c', 'o/r'] = _split_path('/a/c/o/r', 1, 3, True)",
            "",
            "    :param path: HTTP Request path to be split",
            "    :param minsegs: Minimum number of segments to be extracted",
            "    :param maxsegs: Maximum number of segments to be extracted",
            "    :param rest_with_last: If True, trailing data will be returned as part",
            "                           of last segment.  If False, and there is",
            "                           trailing data, raises ValueError.",
            "    :returns: list of segments with a length of maxsegs (non-existent",
            "              segments will return as None)",
            "    :raises: ValueError if given an invalid path",
            "",
            "    .. versionadded:: 3.11",
            "    \"\"\"",
            "    if not maxsegs:",
            "        maxsegs = minsegs",
            "    if minsegs > maxsegs:",
            "        raise ValueError(_('minsegs > maxsegs: %(min)d > %(max)d)') %",
            "                         {'min': minsegs, 'max': maxsegs})",
            "    if rest_with_last:",
            "        segs = path.split('/', maxsegs)",
            "        minsegs += 1",
            "        maxsegs += 1",
            "        count = len(segs)",
            "        if (segs[0] or count < minsegs or count > maxsegs or",
            "                '' in segs[1:minsegs]):",
            "            raise ValueError(_('Invalid path: %s') % urllib.parse.quote(path))",
            "    else:",
            "        minsegs += 1",
            "        maxsegs += 1",
            "        segs = path.split('/', maxsegs)",
            "        count = len(segs)",
            "        if (segs[0] or count < minsegs or count > maxsegs + 1 or",
            "                '' in segs[1:minsegs] or",
            "                (count == maxsegs + 1 and segs[maxsegs])):",
            "            raise ValueError(_('Invalid path: %s') % urllib.parse.quote(path))",
            "    segs = segs[1:maxsegs]",
            "    segs.extend([None] * (maxsegs - 1 - len(segs)))",
            "    return segs",
            "",
            "",
            "def split_by_commas(value):",
            "    \"\"\"Split values by commas and quotes according to api-wg",
            "",
            "    :param value: value to be split",
            "",
            "    .. versionadded:: 3.17",
            "    \"\"\"",
            "    word = (pp.QuotedString(quoteChar='\"', escChar='\\\\') |",
            "            pp.Word(pp.printables, excludeChars='\",'))",
            "    grammar = pp.stringStart + pp.delimitedList(word) + pp.stringEnd",
            "",
            "    try:",
            "        return list(grammar.parseString(value))",
            "    except pp.ParseException:",
            "        raise ValueError(\"Invalid value: %s\" % value)"
        ],
        "afterPatchFile": [
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "System-level utilities and helper functions.",
            "\"\"\"",
            "",
            "import collections",
            "import math",
            "import re",
            "import unicodedata",
            "import urllib",
            "",
            "import pyparsing as pp",
            "",
            "from oslo_utils._i18n import _",
            "from oslo_utils import encodeutils",
            "",
            "",
            "UNIT_PREFIX_EXPONENT = {",
            "    'k': 1,",
            "    'K': 1,",
            "    'Ki': 1,",
            "    'M': 2,",
            "    'Mi': 2,",
            "    'G': 3,",
            "    'Gi': 3,",
            "    'T': 4,",
            "    'Ti': 4,",
            "}",
            "UNIT_SYSTEM_INFO = {",
            "    'IEC': (1024, re.compile(r'(^[-+]?\\d*\\.?\\d+)([KMGT]i?)?(b|bit|B)$')),",
            "    'SI': (1000, re.compile(r'(^[-+]?\\d*\\.?\\d+)([kMGT])?(b|bit|B)$')),",
            "    'mixed': (None, re.compile(r'(^[-+]?\\d*\\.?\\d+)([kKMGT]i?)?(b|bit|B)$')),",
            "}",
            "",
            "TRUE_STRINGS = ('1', 't', 'true', 'on', 'y', 'yes')",
            "FALSE_STRINGS = ('0', 'f', 'false', 'off', 'n', 'no')",
            "",
            "SLUGIFY_STRIP_RE = re.compile(r\"[^\\w\\s-]\")",
            "SLUGIFY_HYPHENATE_RE = re.compile(r\"[-\\s]+\")",
            "",
            "",
            "# NOTE(flaper87): The following globals are used by `mask_password` and",
            "#                 `mask_dict_password`. They must all be lowercase.",
            "_SANITIZE_KEYS = ['adminpass', 'admin_pass', 'password', 'admin_password',",
            "                  'auth_token', 'new_pass', 'auth_password', 'secret_uuid',",
            "                  'secret', 'sys_pswd', 'token', 'configdrive',",
            "                  'chappassword', 'encrypted_key', 'private_key',",
            "                  'encryption_key_id', 'fernetkey', 'sslkey', 'passphrase',",
            "                  'cephclusterfsid', 'octaviaheartbeatkey', 'rabbitcookie',",
            "                  'cephmanilaclientkey', 'pacemakerremoteauthkey',",
            "                  'designaterndckey', 'cephadminkey', 'heatauthencryptionkey',",
            "                  'cephclientkey', 'keystonecredential',",
            "                  'barbicansimplecryptokek', 'cephrgwkey', 'swifthashsuffix',",
            "                  'migrationsshkey', 'cephmdskey', 'cephmonkey']",
            "",
            "# NOTE(ldbragst): Let's build a list of regex objects using the list of",
            "# _SANITIZE_KEYS we already have. This way, we only have to add the new key",
            "# to the list of _SANITIZE_KEYS and we can generate regular expressions",
            "# for XML and JSON automatically.",
            "_SANITIZE_PATTERNS_2 = {}",
            "_SANITIZE_PATTERNS_1 = {}",
            "_SANITIZE_PATTERNS_WILDCARD = {}",
            "",
            "# NOTE(amrith): Some regular expressions have only one parameter, some",
            "# have two parameters. Use different lists of patterns here.",
            "_FORMAT_PATTERNS_1 = [r'(%(key)s[0-9]*\\s*[=]\\s*)[^\\s^\\'^\\\"]+']",
            "_FORMAT_PATTERNS_2 = [r'(%(key)s[0-9]*\\s*[=]\\s*[\\\"\\'])[^\\\"\\']*([\\\"\\'])',",
            "                      r'(%(key)s[0-9]*\\s+[\\\"\\'])[^\\\"\\']*([\\\"\\'])',",
            "                      r'([-]{2}%(key)s[0-9]*\\s+)[^\\'^\\\"^=^\\s]+([\\s]*)',",
            "                      r'(<%(key)s[0-9]*>)[^<]*(</%(key)s[0-9]*>)',",
            "                      r'([\\\"\\']%(key)s[0-9]*[\\\"\\']\\s*:\\s*[\\\"\\'])[^\\\"\\']*'",
            "                      r'([\\\"\\'])',",
            "                      r'([\\'\"][^\"\\']*%(key)s[0-9]*[\\'\"]\\s*:\\s*u?[\\'\"])[^\\\"\\']*'",
            "                      r'([\\'\"])',",
            "                      r'([\\'\"][^\\'\"]*%(key)s[0-9]*[\\'\"]\\s*,\\s*\\'--?[A-z]+'",
            "                      r'\\'\\s*,\\s*u?[\\'\"])[^\\\"\\']*([\\'\"])',",
            "                      r'(%(key)s[0-9]*\\s*--?[A-z]+\\s*)\\S+(\\s*)']",
            "_FORMAT_PATTERNS_WILDCARD = [r'([\\'\\\"][^\\\"\\']*%(key)s[0-9]*[\\'\\\"]\\s*:\\s*u?[\\'\\\"].*[\\'\\\"])[^\\\"\\']*([\\'\\\"])']  # noqa: E501",
            "",
            "# NOTE(dhellmann): Keep a separate list of patterns by key so we only",
            "# need to apply the substitutions for keys we find using a quick \"in\"",
            "# test.",
            "for key in _SANITIZE_KEYS:",
            "    _SANITIZE_PATTERNS_1[key] = []",
            "    _SANITIZE_PATTERNS_2[key] = []",
            "    _SANITIZE_PATTERNS_WILDCARD[key] = []",
            "",
            "    for pattern in _FORMAT_PATTERNS_2:",
            "        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)",
            "        _SANITIZE_PATTERNS_2[key].append(reg_ex)",
            "",
            "    for pattern in _FORMAT_PATTERNS_1:",
            "        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)",
            "        _SANITIZE_PATTERNS_1[key].append(reg_ex)",
            "",
            "    for pattern in _FORMAT_PATTERNS_WILDCARD:",
            "        reg_ex = re.compile(pattern % {'key': key}, re.DOTALL | re.IGNORECASE)",
            "        _SANITIZE_PATTERNS_WILDCARD[key].append(reg_ex)",
            "",
            "",
            "def int_from_bool_as_string(subject):",
            "    \"\"\"Interpret a string as a boolean and return either 1 or 0.",
            "",
            "    Any string value in:",
            "",
            "        ('True', 'true', 'On', 'on', '1')",
            "",
            "    is interpreted as a boolean True.",
            "",
            "    Useful for JSON-decoded stuff and config file parsing",
            "    \"\"\"",
            "    return int(bool_from_string(subject))",
            "",
            "",
            "def bool_from_string(subject, strict=False, default=False):",
            "    \"\"\"Interpret a subject as a boolean.",
            "",
            "    A subject can be a boolean, a string or an integer. Boolean type value",
            "    will be returned directly, otherwise the subject will be converted to",
            "    a string. A case-insensitive match is performed such that strings",
            "    matching 't','true', 'on', 'y', 'yes', or '1' are considered True and,",
            "    when `strict=False`, anything else returns the value specified by",
            "    'default'.",
            "",
            "    Useful for JSON-decoded stuff and config file parsing.",
            "",
            "    If `strict=True`, unrecognized values, including None, will raise a",
            "    ValueError which is useful when parsing values passed in from an API call.",
            "    Strings yielding False are 'f', 'false', 'off', 'n', 'no', or '0'.",
            "    \"\"\"",
            "    if isinstance(subject, bool):",
            "        return subject",
            "    if not isinstance(subject, str):",
            "        subject = str(subject)",
            "",
            "    lowered = subject.strip().lower()",
            "",
            "    if lowered in TRUE_STRINGS:",
            "        return True",
            "    elif lowered in FALSE_STRINGS:",
            "        return False",
            "    elif strict:",
            "        acceptable = ', '.join(",
            "            \"'%s'\" % s for s in sorted(TRUE_STRINGS + FALSE_STRINGS))",
            "        msg = _(\"Unrecognized value '%(val)s', acceptable values are:\"",
            "                \" %(acceptable)s\") % {'val': subject,",
            "                                      'acceptable': acceptable}",
            "        raise ValueError(msg)",
            "    else:",
            "        return default",
            "",
            "",
            "def is_valid_boolstr(value):",
            "    \"\"\"Check if the provided string is a valid bool string or not.",
            "",
            "    :param value: value to verify",
            "    :type value: string",
            "    :returns: true if value is boolean string, false otherwise",
            "",
            "    .. versionadded:: 3.17",
            "    \"\"\"",
            "    boolstrs = TRUE_STRINGS + FALSE_STRINGS",
            "    return str(value).lower() in boolstrs",
            "",
            "",
            "def string_to_bytes(text, unit_system='IEC', return_int=False):",
            "    \"\"\"Converts a string into an float representation of bytes.",
            "",
            "    The units supported for IEC / mixed::",
            "",
            "        Kb(it), Kib(it), Mb(it), Mib(it), Gb(it), Gib(it), Tb(it), Tib(it)",
            "        KB, KiB, MB, MiB, GB, GiB, TB, TiB",
            "",
            "    The units supported for SI ::",
            "",
            "        kb(it), Mb(it), Gb(it), Tb(it)",
            "        kB, MB, GB, TB",
            "",
            "    SI units are interpreted as power-of-ten (e.g. 1kb = 1000b).  Note",
            "    that the SI unit system does not support capital letter 'K'",
            "",
            "    IEC units are interpreted as power-of-two (e.g. 1MiB = 1MB =",
            "    1024b)",
            "",
            "    Mixed units interpret the \"i\" to mean IEC, and no \"i\" to mean SI",
            "    (e.g. 1kb = 1000b, 1kib == 1024b).  Additionaly, mixed units",
            "    interpret 'K' as power-of-ten.  This mode is not particuarly",
            "    useful for new code, but can help with compatability for parsers",
            "    such as GNU parted.",
            "",
            "    :param text: String input for bytes size conversion.",
            "    :param unit_system: Unit system for byte size conversion.",
            "    :param return_int: If True, returns integer representation of text",
            "                       in bytes. (default: decimal)",
            "    :returns: Numerical representation of text in bytes.",
            "    :raises ValueError: If text has an invalid value.",
            "",
            "    \"\"\"",
            "    try:",
            "        base, reg_ex = UNIT_SYSTEM_INFO[unit_system]",
            "    except KeyError:",
            "        msg = _('Invalid unit system: \"%s\"') % unit_system",
            "        raise ValueError(msg)",
            "    match = reg_ex.match(text)",
            "    if match:",
            "        magnitude = float(match.group(1))",
            "        unit_prefix = match.group(2)",
            "        if match.group(3) in ['b', 'bit']:",
            "            magnitude /= 8",
            "",
            "        # In the mixed matcher, IEC units (with a trailing 'i') are",
            "        # interpreted as power-of-two, others as power-of-ten",
            "        if unit_system == 'mixed':",
            "            if unit_prefix and not unit_prefix.endswith('i'):",
            "                # For maximum compatability in mixed mode, we understand",
            "                # \"K\" (which is not strict SI) as \"k\"",
            "                if unit_prefix.startswith == 'K':",
            "                    unit_prefix = 'k'",
            "                base = 1000",
            "            else:",
            "                base = 1024",
            "    else:",
            "        msg = _('Invalid string format: %s') % text",
            "        raise ValueError(msg)",
            "",
            "    if not unit_prefix:",
            "        res = magnitude",
            "    else:",
            "        res = magnitude * pow(base, UNIT_PREFIX_EXPONENT[unit_prefix])",
            "    if return_int:",
            "        return int(math.ceil(res))",
            "    return res",
            "",
            "",
            "def to_slug(value, incoming=None, errors=\"strict\"):",
            "    \"\"\"Normalize string.",
            "",
            "    Convert to lowercase, remove non-word characters, and convert spaces",
            "    to hyphens.",
            "",
            "    Inspired by Django's `slugify` filter.",
            "",
            "    :param value: Text to slugify",
            "    :param incoming: Text's current encoding",
            "    :param errors: Errors handling policy. See here for valid",
            "        values http://docs.python.org/2/library/codecs.html",
            "    :returns: slugified unicode representation of `value`",
            "    :raises TypeError: If text is not an instance of str",
            "    \"\"\"",
            "    value = encodeutils.safe_decode(value, incoming, errors)",
            "    # NOTE(aababilov): no need to use safe_(encode|decode) here:",
            "    # encodings are always \"ascii\", error handling is always \"ignore\"",
            "    # and types are always known (first: unicode; second: str)",
            "    value = unicodedata.normalize(\"NFKD\", value).encode(",
            "        \"ascii\", \"ignore\").decode(\"ascii\")",
            "    value = SLUGIFY_STRIP_RE.sub(\"\", value).strip().lower()",
            "    return SLUGIFY_HYPHENATE_RE.sub(\"-\", value)",
            "",
            "",
            "# NOTE(dhellmann): Before submitting a patch to add a new argument to",
            "# this function to allow the caller to pass in \"extra\" or \"additional\"",
            "# or \"replacement\" patterns to be masked out, please note that we have",
            "# discussed that feature many times and always rejected it based on",
            "# the desire to have Oslo functions behave consistently across all",
            "# projects and *especially* to have security features work the same",
            "# way no matter where they are used. If every project adopted its own",
            "# set patterns for secret values, it would be very difficult to audit",
            "# the logging to ensure that everything is properly masked. So, please",
            "# either add your pattern to the module-level variables at the top of",
            "# this file or, even better, pick an existing pattern or key to use in",
            "# your application to ensure that the value is masked by this",
            "# function.",
            "def mask_password(message, secret=\"***\"):  # nosec",
            "    \"\"\"Replace password with *secret* in message.",
            "",
            "    :param message: The string which includes security information.",
            "    :param secret: value with which to replace passwords.",
            "    :returns: The unicode value of message with the password fields masked.",
            "",
            "    For example:",
            "",
            "    >>> mask_password(\"'adminPass' : 'aaaaa'\")",
            "    \"'adminPass' : '***'\"",
            "    >>> mask_password(\"'admin_pass' : 'aaaaa'\")",
            "    \"'admin_pass' : '***'\"",
            "    >>> mask_password('\"password\" : \"aaaaa\"')",
            "    '\"password\" : \"***\"'",
            "    >>> mask_password(\"'original_password' : 'aaaaa'\")",
            "    \"'original_password' : '***'\"",
            "    >>> mask_password(\"u'original_password' :   u'aaaaa'\")",
            "    \"u'original_password' :   u'***'\"",
            "",
            "    .. versionadded:: 0.2",
            "",
            "    .. versionchanged:: 1.1",
            "       Replace also ``'auth_token'``, ``'new_pass'`` and ``'auth_password'``",
            "       keys.",
            "",
            "    .. versionchanged:: 1.1.1",
            "       Replace also ``'secret_uuid'`` key.",
            "",
            "    .. versionchanged:: 1.5",
            "       Replace also ``'sys_pswd'`` key.",
            "",
            "    .. versionchanged:: 2.6",
            "       Replace also ``'token'`` key.",
            "",
            "    .. versionchanged:: 2.7",
            "       Replace also ``'secret'`` key.",
            "",
            "    .. versionchanged:: 3.4",
            "       Replace also ``'configdrive'`` key.",
            "",
            "    .. versionchanged:: 3.8",
            "       Replace also ``'CHAPPASSWORD'`` key.",
            "    \"\"\"",
            "",
            "    try:",
            "        message = str(message)",
            "    except UnicodeDecodeError:  # nosec",
            "        # NOTE(jecarey): Temporary fix to handle cases where message is a",
            "        # byte string. A better solution will be provided in Kilo.",
            "        pass",
            "",
            "    substitute1 = r'\\g<1>' + secret",
            "    substitute2 = r'\\g<1>' + secret + r'\\g<2>'",
            "    substitute_wildcard = r'\\g<1>'",
            "",
            "    # NOTE(ldbragst): Check to see if anything in message contains any key",
            "    # specified in _SANITIZE_KEYS, if not then just return the message since",
            "    # we don't have to mask any passwords.",
            "    for key in _SANITIZE_KEYS:",
            "        if key in message.lower():",
            "            for pattern in _SANITIZE_PATTERNS_2[key]:",
            "                message = re.sub(pattern, substitute2, message)",
            "            for pattern in _SANITIZE_PATTERNS_1[key]:",
            "                message = re.sub(pattern, substitute1, message)",
            "            # NOTE(hberaud): Those case are poorly handled by previous",
            "            # patterns. They are passwords with quotes or double quotes.",
            "            # They also needs a different way to substitute group this is why",
            "            # they aren't fix in the pattern 1 or 2.",
            "            for pattern in _SANITIZE_PATTERNS_WILDCARD[key]:",
            "                message = re.sub(pattern, substitute_wildcard, message)",
            "    return message",
            "",
            "",
            "def mask_dict_password(dictionary, secret=\"***\"):  # nosec",
            "    \"\"\"Replace password with *secret* in a dictionary recursively.",
            "",
            "    :param dictionary: The dictionary which includes secret information.",
            "    :param secret: value with which to replace secret information.",
            "    :returns: The dictionary with string substitutions.",
            "",
            "    A dictionary (which may contain nested dictionaries) contains",
            "    information (such as passwords) which should not be revealed, and",
            "    this function helps detect and replace those with the 'secret'",
            "    provided (or `***` if none is provided).",
            "",
            "    Substitution is performed in one of three situations:",
            "",
            "    If the key is something that is considered to be indicative of a",
            "    secret, then the corresponding value is replaced with the secret",
            "    provided (or `***` if none is provided).",
            "",
            "    If a value in the dictionary is a string, then it is masked",
            "    using the ``mask_password()`` function.",
            "",
            "    Finally, if a value is a dictionary, this function will",
            "    recursively mask that dictionary as well.",
            "",
            "    For example:",
            "",
            "    >>> mask_dict_password({'password': 'd81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home-dir': '/home/admin'},",
            "    >>>                     '???')",
            "    {'password': '???', 'user': 'admin', 'home-dir': '/home/admin'}",
            "",
            "    For example (the value is masked using mask_password())",
            "",
            "    >>> mask_dict_password({'password': '--password d81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home-dir': '/home/admin'},",
            "    >>>                     '???')",
            "    {'password': '--password ???', 'user': 'admin',",
            "     'home-dir': '/home/admin'}",
            "",
            "",
            "    For example (a nested dictionary is masked):",
            "",
            "    >>> mask_dict_password({\"nested\": {'password': 'd81juxmEW_',",
            "    >>>                     'user': 'admin',",
            "    >>>                     'home': '/home/admin'}},",
            "    >>>                     '???')",
            "    {\"nested\": {'password': '???', 'user': 'admin', 'home': '/home/admin'}}",
            "",
            "    .. versionadded:: 3.4",
            "",
            "    \"\"\"",
            "",
            "    if not isinstance(dictionary, collections.Mapping):",
            "        raise TypeError(\"Expected a Mapping, got %s instead.\"",
            "                        % type(dictionary))",
            "    out = {}",
            "    for k, v in dictionary.items():",
            "        if isinstance(v, collections.Mapping):",
            "            out[k] = mask_dict_password(v, secret=secret)",
            "            continue",
            "        # NOTE(jlvillal): Check to see if anything in the dictionary 'key'",
            "        # contains any key specified in _SANITIZE_KEYS.",
            "        k_matched = False",
            "        if isinstance(k, str):",
            "            for sani_key in _SANITIZE_KEYS:",
            "                if sani_key in k.lower():",
            "                    out[k] = secret",
            "                    k_matched = True",
            "                    break",
            "        if not k_matched:",
            "            # We did not find a match for the key name in the",
            "            # _SANITIZE_KEYS, so we fall through to here",
            "            if isinstance(v, str):",
            "                out[k] = mask_password(v, secret=secret)",
            "            else:",
            "                # Just leave it alone.",
            "                out[k] = v",
            "    return out",
            "",
            "",
            "def is_int_like(val):",
            "    \"\"\"Check if a value looks like an integer with base 10.",
            "",
            "    :param val: Value to verify",
            "    :type val: string",
            "    :returns: bool",
            "",
            "    .. versionadded:: 1.1",
            "    \"\"\"",
            "    try:",
            "        return str(int(val)) == str(val)",
            "    except (TypeError, ValueError):",
            "        return False",
            "",
            "",
            "def check_string_length(value, name=None, min_length=0, max_length=None):",
            "    \"\"\"Check the length of specified string.",
            "",
            "    :param value: the value of the string",
            "    :param name: the name of the string",
            "    :param min_length: the min_length of the string",
            "    :param max_length: the max_length of the string",
            "    :raises TypeError, ValueError: For any invalid input.",
            "",
            "    .. versionadded:: 3.7",
            "    \"\"\"",
            "    if name is None:",
            "        name = value",
            "",
            "    if not isinstance(value, str):",
            "        msg = _(\"%s is not a string or unicode\") % name",
            "        raise TypeError(msg)",
            "",
            "    length = len(value)",
            "    if length < min_length:",
            "        msg = _(\"%(name)s has %(length)s characters, less than \"",
            "                \"%(min_length)s.\") % {'name': name, 'length': length,",
            "                                      'min_length': min_length}",
            "        raise ValueError(msg)",
            "",
            "    if max_length and length > max_length:",
            "        msg = _(\"%(name)s has %(length)s characters, more than \"",
            "                \"%(max_length)s.\") % {'name': name, 'length': length,",
            "                                      'max_length': max_length}",
            "        raise ValueError(msg)",
            "",
            "",
            "def validate_integer(value, name, min_value=None, max_value=None):",
            "    \"\"\"Make sure that value is a valid integer, potentially within range.",
            "",
            "    :param value: value of the integer",
            "    :param name: name of the integer",
            "    :param min_value: min_value of the integer",
            "    :param max_value: max_value of the integer",
            "    :returns: integer",
            "    :raises: ValueError if value is an invalid integer",
            "",
            "    .. versionadded:: 3.33",
            "    \"\"\"",
            "    try:",
            "        value = int(str(value))",
            "    except (ValueError, UnicodeEncodeError):",
            "        msg = _('%(value_name)s must be an integer'",
            "                ) % {'value_name': name}",
            "        raise ValueError(msg)",
            "",
            "    if min_value is not None and value < min_value:",
            "        msg = _('%(value_name)s must be >= %(min_value)d'",
            "                ) % {'value_name': name, 'min_value': min_value}",
            "        raise ValueError(msg)",
            "",
            "    if max_value is not None and value > max_value:",
            "        msg = _('%(value_name)s must be <= %(max_value)d'",
            "                ) % {'value_name': name, 'max_value': max_value}",
            "        raise ValueError(msg)",
            "",
            "    return value",
            "",
            "",
            "def split_path(path, minsegs=1, maxsegs=None, rest_with_last=False):",
            "    \"\"\"Validate and split the given HTTP request path.",
            "",
            "    **Examples**::",
            "",
            "        ['a'] = _split_path('/a')",
            "        ['a', None] = _split_path('/a', 1, 2)",
            "        ['a', 'c'] = _split_path('/a/c', 1, 2)",
            "        ['a', 'c', 'o/r'] = _split_path('/a/c/o/r', 1, 3, True)",
            "",
            "    :param path: HTTP Request path to be split",
            "    :param minsegs: Minimum number of segments to be extracted",
            "    :param maxsegs: Maximum number of segments to be extracted",
            "    :param rest_with_last: If True, trailing data will be returned as part",
            "                           of last segment.  If False, and there is",
            "                           trailing data, raises ValueError.",
            "    :returns: list of segments with a length of maxsegs (non-existent",
            "              segments will return as None)",
            "    :raises: ValueError if given an invalid path",
            "",
            "    .. versionadded:: 3.11",
            "    \"\"\"",
            "    if not maxsegs:",
            "        maxsegs = minsegs",
            "    if minsegs > maxsegs:",
            "        raise ValueError(_('minsegs > maxsegs: %(min)d > %(max)d)') %",
            "                         {'min': minsegs, 'max': maxsegs})",
            "    if rest_with_last:",
            "        segs = path.split('/', maxsegs)",
            "        minsegs += 1",
            "        maxsegs += 1",
            "        count = len(segs)",
            "        if (segs[0] or count < minsegs or count > maxsegs or",
            "                '' in segs[1:minsegs]):",
            "            raise ValueError(_('Invalid path: %s') % urllib.parse.quote(path))",
            "    else:",
            "        minsegs += 1",
            "        maxsegs += 1",
            "        segs = path.split('/', maxsegs)",
            "        count = len(segs)",
            "        if (segs[0] or count < minsegs or count > maxsegs + 1 or",
            "                '' in segs[1:minsegs] or",
            "                (count == maxsegs + 1 and segs[maxsegs])):",
            "            raise ValueError(_('Invalid path: %s') % urllib.parse.quote(path))",
            "    segs = segs[1:maxsegs]",
            "    segs.extend([None] * (maxsegs - 1 - len(segs)))",
            "    return segs",
            "",
            "",
            "def split_by_commas(value):",
            "    \"\"\"Split values by commas and quotes according to api-wg",
            "",
            "    :param value: value to be split",
            "",
            "    .. versionadded:: 3.17",
            "    \"\"\"",
            "    word = (pp.QuotedString(quoteChar='\"', escChar='\\\\') |",
            "            pp.Word(pp.printables, excludeChars='\",'))",
            "    grammar = pp.stringStart + pp.delimitedList(word) + pp.stringEnd",
            "",
            "    try:",
            "        return list(grammar.parseString(value))",
            "    except pp.ParseException:",
            "        raise ValueError(\"Invalid value: %s\" % value)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "344": [
                "mask_password"
            ]
        },
        "addLocation": [
            "pypdf.generic._data_structures",
            "oslo_utils.strutils.mask_dict_password"
        ]
    },
    "oslo_utils/tests/test_strutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": 612,
                "PatchRowcode": "         expected = 'test = \"param1\" : \"value\"'"
            },
            "1": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "         self.assertEqual(expected, strutils.mask_password(payload))"
            },
            "2": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": 614,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        payload = 'test = \"original_password\" : \"aaaaa\"aaaa\"'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+        expected = 'test = \"original_password\" : \"***\"'"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+        self.assertEqual(expected, strutils.mask_password(payload))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "         payload = \"\"\"{'adminPass':'TL0EfN33'}\"\"\""
            },
            "8": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": 620,
                "PatchRowcode": "         payload = str(payload)"
            },
            "9": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "         expected = \"\"\"{'adminPass':'***'}\"\"\""
            },
            "10": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "         self.assertEqual(expected, strutils.mask_password(payload))"
            },
            "11": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 623,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+        payload = \"\"\"{'adminPass':'TL0E'fN33'}\"\"\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+        payload = str(payload)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+        expected = \"\"\"{'adminPass':'***'}\"\"\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+        self.assertEqual(expected, strutils.mask_password(payload))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 629,
                "PatchRowcode": "         payload = \"\"\"{'token':'mytoken'}\"\"\""
            },
            "18": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": 630,
                "PatchRowcode": "         payload = str(payload)"
            },
            "19": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": 631,
                "PatchRowcode": "         expected = \"\"\"{'token':'***'}\"\"\""
            },
            "20": {
                "beforePatchRowNumber": 692,
                "afterPatchRowNumber": 701,
                "PatchRowcode": "         self.assertEqual(expected,"
            },
            "21": {
                "beforePatchRowNumber": 693,
                "afterPatchRowNumber": 702,
                "PatchRowcode": "                          strutils.mask_dict_password(payload))"
            },
            "22": {
                "beforePatchRowNumber": 694,
                "afterPatchRowNumber": 703,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 704,
                "PatchRowcode": "+        payload = {'password': 'TL0Ef\"N33'}"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 705,
                "PatchRowcode": "+        expected = {'password': '***'}"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 706,
                "PatchRowcode": "+        self.assertEqual(expected,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+                         strutils.mask_dict_password(payload))"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 708,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": 695,
                "afterPatchRowNumber": 709,
                "PatchRowcode": "         payload = {'user': 'admin', 'password': 'TL0EfN33'}"
            },
            "29": {
                "beforePatchRowNumber": 696,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "         expected = {'user': 'admin', 'password': '***'}"
            },
            "30": {
                "beforePatchRowNumber": 697,
                "afterPatchRowNumber": 711,
                "PatchRowcode": "         self.assertEqual(expected,"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import math",
            "from unittest import mock",
            "",
            "import ddt",
            "from oslotest import base as test_base",
            "import testscenarios",
            "",
            "from oslo_utils import strutils",
            "from oslo_utils import units",
            "",
            "load_tests = testscenarios.load_tests_apply_scenarios",
            "",
            "",
            "class StrUtilsTest(test_base.BaseTestCase):",
            "",
            "    def test_bool_bool_from_string(self):",
            "        self.assertTrue(strutils.bool_from_string(True))",
            "        self.assertFalse(strutils.bool_from_string(False))",
            "",
            "    def test_bool_bool_from_string_default(self):",
            "        self.assertTrue(strutils.bool_from_string('', default=True))",
            "        self.assertFalse(strutils.bool_from_string('wibble', default=False))",
            "",
            "    def _test_bool_from_string(self, c):",
            "        self.assertTrue(strutils.bool_from_string(c('true')))",
            "        self.assertTrue(strutils.bool_from_string(c('TRUE')))",
            "        self.assertTrue(strutils.bool_from_string(c('on')))",
            "        self.assertTrue(strutils.bool_from_string(c('On')))",
            "        self.assertTrue(strutils.bool_from_string(c('yes')))",
            "        self.assertTrue(strutils.bool_from_string(c('YES')))",
            "        self.assertTrue(strutils.bool_from_string(c('yEs')))",
            "        self.assertTrue(strutils.bool_from_string(c('1')))",
            "        self.assertTrue(strutils.bool_from_string(c('T')))",
            "        self.assertTrue(strutils.bool_from_string(c('t')))",
            "        self.assertTrue(strutils.bool_from_string(c('Y')))",
            "        self.assertTrue(strutils.bool_from_string(c('y')))",
            "",
            "        self.assertFalse(strutils.bool_from_string(c('false')))",
            "        self.assertFalse(strutils.bool_from_string(c('FALSE')))",
            "        self.assertFalse(strutils.bool_from_string(c('off')))",
            "        self.assertFalse(strutils.bool_from_string(c('OFF')))",
            "        self.assertFalse(strutils.bool_from_string(c('no')))",
            "        self.assertFalse(strutils.bool_from_string(c('0')))",
            "        self.assertFalse(strutils.bool_from_string(c('42')))",
            "        self.assertFalse(strutils.bool_from_string(c(",
            "                         'This should not be True')))",
            "        self.assertFalse(strutils.bool_from_string(c('F')))",
            "        self.assertFalse(strutils.bool_from_string(c('f')))",
            "        self.assertFalse(strutils.bool_from_string(c('N')))",
            "        self.assertFalse(strutils.bool_from_string(c('n')))",
            "",
            "        # Whitespace should be stripped",
            "        self.assertTrue(strutils.bool_from_string(c(' 1 ')))",
            "        self.assertTrue(strutils.bool_from_string(c(' true ')))",
            "        self.assertFalse(strutils.bool_from_string(c(' 0 ')))",
            "        self.assertFalse(strutils.bool_from_string(c(' false ')))",
            "",
            "    def test_bool_from_string(self):",
            "        self._test_bool_from_string(lambda s: s)",
            "",
            "    def test_unicode_bool_from_string(self):",
            "        self._test_bool_from_string(str)",
            "        self.assertFalse(strutils.bool_from_string(u'\u4f7f\u7528', strict=False))",
            "",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string,",
            "                                u'\u4f7f\u7528', strict=True)",
            "        expected_msg = (u\"Unrecognized value '\u4f7f\u7528', acceptable values are:\"",
            "                        u\" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        u\" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "    def test_other_bool_from_string(self):",
            "        self.assertFalse(strutils.bool_from_string(None))",
            "        self.assertFalse(strutils.bool_from_string(mock.Mock()))",
            "",
            "    def test_int_bool_from_string(self):",
            "        self.assertTrue(strutils.bool_from_string(1))",
            "",
            "        self.assertFalse(strutils.bool_from_string(-1))",
            "        self.assertFalse(strutils.bool_from_string(0))",
            "        self.assertFalse(strutils.bool_from_string(2))",
            "",
            "    def test_strict_bool_from_string(self):",
            "        # None isn't allowed in strict mode",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, None,",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value 'None', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # Unrecognized strings aren't allowed",
            "        self.assertFalse(strutils.bool_from_string('Other', strict=False))",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, 'Other',",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value 'Other', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # Unrecognized numbers aren't allowed",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, 2,",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value '2', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # False-like values are allowed",
            "        self.assertFalse(strutils.bool_from_string('f', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('false', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('off', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('n', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('no', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('0', strict=True))",
            "",
            "        self.assertTrue(strutils.bool_from_string('1', strict=True))",
            "",
            "        # Avoid font-similarity issues (one looks like lowercase-el, zero like",
            "        # oh, etc...)",
            "        for char in ('O', 'o', 'L', 'l', 'I', 'i'):",
            "            self.assertRaises(ValueError, strutils.bool_from_string, char,",
            "                              strict=True)",
            "",
            "    def test_int_from_bool_as_string(self):",
            "        self.assertEqual(1, strutils.int_from_bool_as_string(True))",
            "        self.assertEqual(0, strutils.int_from_bool_as_string(False))",
            "",
            "    def test_is_valid_boolstr(self):",
            "        self.assertTrue(strutils.is_valid_boolstr('true'))",
            "        self.assertTrue(strutils.is_valid_boolstr('false'))",
            "        self.assertTrue(strutils.is_valid_boolstr('yes'))",
            "        self.assertTrue(strutils.is_valid_boolstr('no'))",
            "        self.assertTrue(strutils.is_valid_boolstr('y'))",
            "        self.assertTrue(strutils.is_valid_boolstr('n'))",
            "        self.assertTrue(strutils.is_valid_boolstr('1'))",
            "        self.assertTrue(strutils.is_valid_boolstr('0'))",
            "        self.assertTrue(strutils.is_valid_boolstr(1))",
            "        self.assertTrue(strutils.is_valid_boolstr(0))",
            "",
            "        self.assertFalse(strutils.is_valid_boolstr('maybe'))",
            "        self.assertFalse(strutils.is_valid_boolstr('only on tuesdays'))",
            "",
            "    def test_slugify(self):",
            "        to_slug = strutils.to_slug",
            "        self.assertRaises(TypeError, to_slug, True)",
            "        self.assertEqual(\"hello\", to_slug(\"hello\"))",
            "        self.assertEqual(\"two-words\", to_slug(\"Two Words\"))",
            "        self.assertEqual(\"ma-any-spa-ce-es\",",
            "                         to_slug(\"Ma-any\\t spa--ce- es\"))",
            "        self.assertEqual(\"excamation\", to_slug(\"exc!amation!\"))",
            "        self.assertEqual(\"ampserand\", to_slug(\"&ampser$and\"))",
            "        self.assertEqual(\"ju5tnum8er\", to_slug(\"ju5tnum8er\"))",
            "        self.assertEqual(\"strip-\", to_slug(\" strip - \"))",
            "        self.assertEqual(\"perche\",",
            "                         to_slug(\"perch\\xc3\\xa9\".encode(\"latin-1\")))",
            "        self.assertEqual(\"strange\",",
            "                         to_slug(\"\\x80strange\", errors=\"ignore\"))",
            "",
            "",
            "class StringToBytesTest(test_base.BaseTestCase):",
            "",
            "    _unit_system = [",
            "        ('si', dict(unit_system='SI')),",
            "        ('iec', dict(unit_system='IEC')),",
            "        ('mixed', dict(unit_system='mixed')),",
            "        ('invalid_unit_system', dict(unit_system='KKK', assert_error=True)),",
            "    ]",
            "",
            "    _sign = [",
            "        ('no_sign', dict(sign='')),",
            "        ('positive', dict(sign='+')),",
            "        ('negative', dict(sign='-')),",
            "        ('invalid_sign', dict(sign='~', assert_error=True)),",
            "    ]",
            "",
            "    _magnitude = [",
            "        ('integer', dict(magnitude='79')),",
            "        ('decimal', dict(magnitude='7.9')),",
            "        ('decimal_point_start', dict(magnitude='.9')),",
            "        ('decimal_point_end', dict(magnitude='79.', assert_error=True)),",
            "        ('invalid_literal', dict(magnitude='7.9.9', assert_error=True)),",
            "        ('garbage_value', dict(magnitude='asdf', assert_error=True)),",
            "    ]",
            "",
            "    _unit_prefix = [",
            "        ('no_unit_prefix', dict(unit_prefix='')),",
            "        ('k', dict(unit_prefix='k')),",
            "        ('K', dict(unit_prefix='K')),",
            "        ('M', dict(unit_prefix='M')),",
            "        ('G', dict(unit_prefix='G')),",
            "        ('T', dict(unit_prefix='T')),",
            "        ('Ki', dict(unit_prefix='Ki')),",
            "        ('Mi', dict(unit_prefix='Mi')),",
            "        ('Gi', dict(unit_prefix='Gi')),",
            "        ('Ti', dict(unit_prefix='Ti')),",
            "        ('invalid_unit_prefix', dict(unit_prefix='B', assert_error=True)),",
            "    ]",
            "",
            "    _unit_suffix = [",
            "        ('b', dict(unit_suffix='b')),",
            "        ('bit', dict(unit_suffix='bit')),",
            "        ('B', dict(unit_suffix='B')),",
            "        ('invalid_unit_suffix', dict(unit_suffix='Kg', assert_error=True)),",
            "    ]",
            "",
            "    _return_int = [",
            "        ('return_dec', dict(return_int=False)),",
            "        ('return_int', dict(return_int=True)),",
            "    ]",
            "",
            "    @classmethod",
            "    def generate_scenarios(cls):",
            "        cls.scenarios = testscenarios.multiply_scenarios(cls._unit_system,",
            "                                                         cls._sign,",
            "                                                         cls._magnitude,",
            "                                                         cls._unit_prefix,",
            "                                                         cls._unit_suffix,",
            "                                                         cls._return_int)",
            "",
            "    def test_string_to_bytes(self):",
            "",
            "        def _get_quantity(sign, magnitude, unit_suffix):",
            "            res = float('%s%s' % (sign, magnitude))",
            "            if unit_suffix in ['b', 'bit']:",
            "                res /= 8",
            "            return res",
            "",
            "        def _get_constant(unit_prefix, unit_system):",
            "            if not unit_prefix:",
            "                return 1",
            "            elif unit_system == 'SI':",
            "                res = getattr(units, unit_prefix)",
            "            elif unit_system == 'IEC':",
            "                if unit_prefix.endswith('i'):",
            "                    res = getattr(units, unit_prefix)",
            "                else:",
            "                    res = getattr(units, '%si' % unit_prefix)",
            "            elif unit_system == 'mixed':",
            "                # Note: this will return 'i' units as power-of-two,",
            "                # and other units as power-of-ten.  Additionally, for",
            "                # compatability a \"K\" is interpreted as \"k\" in mixed",
            "                # mode",
            "                if unit_prefix == 'K':",
            "                    unit_prefix = 'k'",
            "                res = getattr(units, unit_prefix)",
            "            return res",
            "",
            "        text = ''.join([self.sign, self.magnitude, self.unit_prefix,",
            "                        self.unit_suffix])",
            "        err_si = self.unit_system == 'SI' and (self.unit_prefix == 'K' or",
            "                                               self.unit_prefix.endswith('i'))",
            "        err_iec = self.unit_system == 'IEC' and self.unit_prefix == 'k'",
            "        if getattr(self, 'assert_error', False) or err_si or err_iec:",
            "            self.assertRaises(ValueError, strutils.string_to_bytes,",
            "                              text, unit_system=self.unit_system,",
            "                              return_int=self.return_int)",
            "            return",
            "        quantity = _get_quantity(self.sign, self.magnitude, self.unit_suffix)",
            "        constant = _get_constant(self.unit_prefix, self.unit_system)",
            "        expected = quantity * constant",
            "        actual = strutils.string_to_bytes(text, unit_system=self.unit_system,",
            "                                          return_int=self.return_int)",
            "        if self.return_int:",
            "            self.assertEqual(actual, int(math.ceil(expected)))",
            "        else:",
            "            self.assertAlmostEqual(actual, expected)",
            "",
            "",
            "StringToBytesTest.generate_scenarios()",
            "",
            "",
            "class MaskPasswordTestCase(test_base.BaseTestCase):",
            "",
            "    def test_sanitize_keys(self):",
            "",
            "        lowered = [k.lower() for k in strutils._SANITIZE_KEYS]",
            "        message = \"The _SANITIZE_KEYS must all be lowercase.\"",
            "        self.assertEqual(strutils._SANITIZE_KEYS, lowered, message)",
            "",
            "    def test_json(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"{'adminPass':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'adminPass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"{ 'adminPass' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'adminPass' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"{'admin_pass':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'admin_pass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"{ 'admin_pass' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'admin_pass' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"{'admin_password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'admin_password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"{ 'admin_password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'admin_password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"{'password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"{ 'password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'auth_password' w/o spaces",
            "        payload = \"\"\"{'auth_password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'auth_password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'auth_password' with spaces",
            "        payload = \"\"\"{ 'auth_password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'auth_password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'secret_uuid' w/o spaces",
            "        payload = \"\"\"{'secret_uuid':'myuuid'}\"\"\"",
            "        expected = \"\"\"{'secret_uuid':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'secret_uuid' with spaces",
            "        payload = \"\"\"{ 'secret_uuid' : 'myuuid' }\"\"\"",
            "        expected = \"\"\"{ 'secret_uuid' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'token' w/o spaces",
            "        payload = \"\"\"{'token':'token'}\"\"\"",
            "        expected = \"\"\"{'token':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'token' with spaces",
            "        payload = \"\"\"{ 'token' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'token' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'fernetkey'",
            "        payload = \"\"\"{ 'fernetkey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'fernetkey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'FernetKey'",
            "        payload = \"\"\"{ 'FernetKey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'FernetKey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'sslkey'",
            "        payload = \"\"\"{ 'sslkey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'sslkey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'SslKey'",
            "        payload = \"\"\"{ 'SslKey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'SslKey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'passphrase'",
            "        payload = \"\"\"{ 'passphrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'passphrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'PassPhrase'",
            "        payload = \"\"\"{ 'PassPhrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'PassPhrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Some real-life cases",
            "        # Test 'KeystoneFernetKey1'",
            "        payload = \"\"\"{ 'KeystoneFernetKey1' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'KeystoneFernetKey1' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'OctaviaCaKeyPassword'",
            "        payload = \"\"\"{ 'OctaviaCaKeyPassword' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'OctaviaCaKeyPassword' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'OctaviaCaKeyPassphrase'",
            "        payload = \"\"\"{ 'OctaviaCaKeyPassphrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'OctaviaCaKeyPassphrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"<adminPass>TL0EfN33</adminPass>\"\"\"",
            "        expected = \"\"\"<adminPass>***</adminPass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"<adminPass>",
            "                        TL0EfN33",
            "                     </adminPass>\"\"\"",
            "        expected = \"\"\"<adminPass>***</adminPass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"<admin_pass>TL0EfN33</admin_pass>\"\"\"",
            "        expected = \"\"\"<admin_pass>***</admin_pass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"<admin_pass>",
            "                        TL0EfN33",
            "                     </admin_pass>\"\"\"",
            "        expected = \"\"\"<admin_pass>***</admin_pass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"<admin_password>TL0EfN33</admin_password>\"\"\"",
            "        expected = \"\"\"<admin_password>***</admin_password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"<admin_password>",
            "                        TL0EfN33",
            "                     </admin_password>\"\"\"",
            "        expected = \"\"\"<admin_password>***</admin_password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"<password>TL0EfN33</password>\"\"\"",
            "        expected = \"\"\"<password>***</password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"<password>",
            "                        TL0EfN33",
            "                     </password>\"\"\"",
            "        expected = \"\"\"<password>***</password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'Password1' - case-insensitive + number",
            "        payload = \"\"\"<Password1>TL0EfN33</Password1>\"\"\"",
            "        expected = \"\"\"<Password1>***</Password1>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml_attribute(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"adminPass='TL0EfN33'\"\"\"",
            "        expected = \"\"\"adminPass='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"adminPass = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"adminPass = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with double quotes",
            "        payload = \"\"\"adminPass = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"adminPass = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"admin_pass='TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_pass='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"admin_pass = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_pass = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with double quotes",
            "        payload = \"\"\"admin_pass = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"admin_pass = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"admin_password='TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_password='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"admin_password = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_password = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with double quotes",
            "        payload = \"\"\"admin_password = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"admin_password = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"password='TL0EfN33'\"\"\"",
            "        expected = \"\"\"password='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"password = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"password = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with double quotes",
            "        payload = \"\"\"password = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"password = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_json_message(self):",
            "        payload = \"\"\"body: {\"changePassword\": {\"adminPass\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"changePassword\": {\"adminPass\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"admin_pass\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"admin_pass\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"admin_password\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"admin_password\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"password\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"password\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"encryption_key_id\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"encryption_key_id\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml_message(self):",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rebuild",
            "    xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    name=\"foobar\"",
            "    imageRef=\"http://openstack.example.com/v1.1/32278/images/70a599e0-31e7\"",
            "    accessIPv4=\"1.2.3.4\"",
            "    accessIPv6=\"fe80::100\"",
            "    adminPass=\"seekr3t\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</rebuild>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rebuild",
            "    xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    name=\"foobar\"",
            "    imageRef=\"http://openstack.example.com/v1.1/32278/images/70a599e0-31e7\"",
            "    accessIPv4=\"1.2.3.4\"",
            "    accessIPv6=\"fe80::100\"",
            "    adminPass=\"***\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</rebuild>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_pass=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_pass=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_password=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_password=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    password=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    password=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_mask_password(self):",
            "        payload = \"test = 'password'  :   'aaaaaa'\"",
            "        expected = \"test = 'password'  :   '111'\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = 'mysqld --password \"aaaaaa\"'",
            "        expected = 'mysqld --password \"****\"'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = 'mysqld --password aaaaaa'",
            "        expected = 'mysqld --password ???'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='???'))",
            "",
            "        payload = 'mysqld --password = \"aaaaaa\"'",
            "        expected = 'mysqld --password = \"****\"'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"mysqld --password = 'aaaaaa'\"",
            "        expected = \"mysqld --password = '****'\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"mysqld --password = aaaaaa\"",
            "        expected = \"mysqld --password = ****\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"test = password =   aaaaaa\"",
            "        expected = \"test = password =   111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password=   aaaaaa\"",
            "        expected = \"test = password=   111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password =aaaaaa\"",
            "        expected = \"test = password =111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password=aaaaaa\"",
            "        expected = \"test = password=111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = 'test = \"original_password\" : \"aaaaaaaaa\"'",
            "        expected = 'test = \"original_password\" : \"***\"'",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = 'test = \"param1\" : \"value\"'",
            "        expected = 'test = \"param1\" : \"value\"'",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"\"\"{'adminPass':'TL0EfN33'}\"\"\"",
            "        payload = str(payload)",
            "        expected = \"\"\"{'adminPass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"\"\"{'token':'mytoken'}\"\"\"",
            "        payload = str(payload)",
            "        expected = \"\"\"{'token':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password','-v','TL0EfN33',\"",
            "                   \"'nomask'\")",
            "        expected = (\"test = 'node.session.auth.password','-v','***',\"",
            "                    \"'nomask'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password', '--password', \"",
            "                   \"'TL0EfN33', 'nomask'\")",
            "        expected = (\"test = 'node.session.auth.password', '--password', \"",
            "                    \"'***', 'nomask'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password', '--password', \"",
            "                   \"'TL0EfN33'\")",
            "        expected = (\"test = 'node.session.auth.password', '--password', \"",
            "                    \"'***'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"test = node.session.auth.password -v TL0EfN33 nomask\"",
            "        expected = \"test = node.session.auth.password -v *** nomask\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = node.session.auth.password --password TL0EfN33 \"",
            "                   \"nomask\")",
            "        expected = (\"test = node.session.auth.password --password *** \"",
            "                    \"nomask\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = node.session.auth.password --password TL0EfN33\")",
            "        expected = (\"test = node.session.auth.password --password ***\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"test = cmd --password my\\xe9\\x80\\x80pass\"",
            "        expected = (\"test = cmd --password ***\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "",
            "class TestMapping(collections.Mapping):",
            "    \"\"\"Test class for non-dict mappings\"\"\"",
            "    def __init__(self):",
            "        super(TestMapping, self).__init__()",
            "        self.data = {'password': 'shhh',",
            "                     'foo': 'bar',",
            "                     }",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __iter__(self):",
            "        return self.data.__iter__()",
            "",
            "    def __len__(self):",
            "        return len(self.data)",
            "",
            "",
            "class NestedMapping(TestMapping):",
            "    \"\"\"Test class that contains an instance of TestMapping\"\"\"",
            "    def __init__(self):",
            "        super(NestedMapping, self).__init__()",
            "        self.data = {'nested': TestMapping()}",
            "",
            "",
            "class MaskDictionaryPasswordTestCase(test_base.BaseTestCase):",
            "",
            "    def test_dictionary(self):",
            "        payload = {'password': 'TL0EfN33'}",
            "        expected = {'password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'user': 'admin', 'password': 'TL0EfN33'}",
            "        expected = {'user': 'admin', 'password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'strval': 'somestring',",
            "                   'dictval': {'user': 'admin', 'password': 'TL0EfN33'}}",
            "        expected = {'strval': 'somestring',",
            "                    'dictval': {'user': 'admin', 'password': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'strval': '--password abc',",
            "                   'dont_change': 'this is fine',",
            "                   'dictval': {'user': 'admin', 'password': b'TL0EfN33'}}",
            "        expected = {'strval': '--password ***',",
            "                    'dont_change': 'this is fine',",
            "                    'dictval': {'user': 'admin', 'password': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'ipmi_password': 'KeDrahishvowphyecMornEm0or('}",
            "        expected = {'ipmi_password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'passwords': {'KeystoneFernetKey1': 'c5FijjS'}}",
            "        expected = {'passwords': {'KeystoneFernetKey1': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'passwords': {'keystonecredential0': 'c5FijjS'}}",
            "        expected = {'passwords': {'keystonecredential0': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_do_no_harm(self):",
            "        payload = {}",
            "        expected = {}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'somekey': 'somevalue',",
            "                   'anotherkey': 'anothervalue'}",
            "        expected = {'somekey': 'somevalue',",
            "                    'anotherkey': 'anothervalue'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_do_an_int(self):",
            "        payload = {}",
            "        payload[1] = 2",
            "        expected = payload.copy()",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_mask_values(self):",
            "        payload = {'somekey': 'test = cmd --password my\\xe9\\x80\\x80pass'}",
            "        expected = {'somekey': 'test = cmd --password ***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_other_non_str_values(self):",
            "        payload = {'password': 'DK0PK1AK3', 'bool': True,",
            "                   'dict': {'cat': 'meow', 'password': \"*aa38skdjf\"},",
            "                   'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                   'str': 'foo'}",
            "        expected = {'password': '***', 'bool': True,",
            "                    'dict': {'cat': 'meow', 'password': '***'},",
            "                    'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                    'str': 'foo'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_argument_untouched(self):",
            "        \"\"\"Make sure that the argument passed in is not modified\"\"\"",
            "        payload = {'password': 'DK0PK1AK3', 'bool': True,",
            "                   'dict': {'cat': 'meow', 'password': \"*aa38skdjf\"},",
            "                   'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                   'str': 'foo'}",
            "        pristine = copy.deepcopy(payload)",
            "        # Send the payload into the function, to see if it gets modified",
            "        strutils.mask_dict_password(payload)",
            "        self.assertEqual(pristine, payload)",
            "",
            "    def test_non_dict(self):",
            "        expected = {'password': '***',",
            "                    'foo': 'bar',",
            "                    }",
            "        payload = TestMapping()",
            "        self.assertEqual(expected, strutils.mask_dict_password(payload))",
            "",
            "    def test_nested_non_dict(self):",
            "        expected = {'nested': {'password': '***',",
            "                               'foo': 'bar',",
            "                               }",
            "                    }",
            "        payload = NestedMapping()",
            "        self.assertEqual(expected, strutils.mask_dict_password(payload))",
            "",
            "",
            "class IsIntLikeTestCase(test_base.BaseTestCase):",
            "    def test_is_int_like_true(self):",
            "        self.assertTrue(strutils.is_int_like(1))",
            "        self.assertTrue(strutils.is_int_like(\"1\"))",
            "        self.assertTrue(strutils.is_int_like(\"514\"))",
            "        self.assertTrue(strutils.is_int_like(\"0\"))",
            "",
            "    def test_is_int_like_false(self):",
            "        self.assertFalse(strutils.is_int_like(1.1))",
            "        self.assertFalse(strutils.is_int_like(\"1.1\"))",
            "        self.assertFalse(strutils.is_int_like(\"1.1.1\"))",
            "        self.assertFalse(strutils.is_int_like(None))",
            "        self.assertFalse(strutils.is_int_like(\"0.\"))",
            "        self.assertFalse(strutils.is_int_like(\"aaaaaa\"))",
            "        self.assertFalse(strutils.is_int_like(\"....\"))",
            "        self.assertFalse(strutils.is_int_like(\"1g\"))",
            "        self.assertFalse(",
            "            strutils.is_int_like(\"0cc3346e-9fef-4445-abe6-5d2b2690ec64\"))",
            "        self.assertFalse(strutils.is_int_like(\"a1\"))",
            "        # NOTE(viktors): 12e3 - is a float number",
            "        self.assertFalse(strutils.is_int_like(\"12e3\"))",
            "        # NOTE(viktors): Check integer numbers with base not 10",
            "        self.assertFalse(strutils.is_int_like(\"0o51\"))",
            "        self.assertFalse(strutils.is_int_like(\"0xDEADBEEF\"))",
            "",
            "",
            "class StringLengthTestCase(test_base.BaseTestCase):",
            "    def test_check_string_length(self):",
            "        self.assertIsNone(strutils.check_string_length(",
            "                          'test', 'name', max_length=255))",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          '', 'name', min_length=1)",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          'a' * 256, 'name', max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          11, 'name', max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          dict(), 'name', max_length=255)",
            "",
            "    def test_check_string_length_noname(self):",
            "        self.assertIsNone(strutils.check_string_length(",
            "                          'test', max_length=255))",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          '', min_length=1)",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          'a' * 256, max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          11, max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          dict(), max_length=255)",
            "",
            "",
            "class SplitPathTestCase(test_base.BaseTestCase):",
            "    def test_split_path_failed(self):",
            "        self.assertRaises(ValueError, strutils.split_path, '')",
            "        self.assertRaises(ValueError, strutils.split_path, '/')",
            "        self.assertRaises(ValueError, strutils.split_path, '//')",
            "        self.assertRaises(ValueError, strutils.split_path, '//a')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c')",
            "        self.assertRaises(ValueError, strutils.split_path, '//c')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c/')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a//')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2, 3)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2, 3, True)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c/o/r', 3, 3)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 5, 4)",
            "",
            "    def test_split_path_success(self):",
            "        self.assertEqual(strutils.split_path('/a'), ['a'])",
            "        self.assertEqual(strutils.split_path('/a/'), ['a'])",
            "        self.assertEqual(strutils.split_path('/a/c', 2), ['a', 'c'])",
            "        self.assertEqual(strutils.split_path('/a/c/o', 3), ['a', 'c', 'o'])",
            "        self.assertEqual(strutils.split_path('/a/c/o/r', 3, 3, True),",
            "                         ['a', 'c', 'o/r'])",
            "        self.assertEqual(strutils.split_path('/a/c', 2, 3, True),",
            "                         ['a', 'c', None])",
            "        self.assertEqual(strutils.split_path('/a/c/', 2), ['a', 'c'])",
            "        self.assertEqual(strutils.split_path('/a/c/', 2, 3), ['a', 'c', ''])",
            "",
            "    def test_split_path_invalid_path(self):",
            "        try:",
            "            strutils.split_path('o\\nn e', 2)",
            "        except ValueError as err:",
            "            self.assertEqual(str(err), 'Invalid path: o%0An%20e')",
            "        try:",
            "            strutils.split_path('o\\nn e', 2, 3, True)",
            "        except ValueError as err:",
            "            self.assertEqual(str(err), 'Invalid path: o%0An%20e')",
            "",
            "",
            "class SplitByCommas(test_base.BaseTestCase):",
            "    def test_not_closed_quotes(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, '\"ab\",\"b\"\"')",
            "",
            "    def test_no_comma_before_opening_quotes(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, '\"ab\"\"b\"')",
            "",
            "    def test_quote_inside_unquoted(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, 'a\"b,cd')",
            "",
            "    def check(self, expect, input):",
            "        self.assertEqual(expect, strutils.split_by_commas(input))",
            "",
            "    def test_plain(self):",
            "        self.check([\"a,b\", \"ac\"], '\"a,b\",ac')",
            "",
            "    def test_with_backslash_inside_quoted(self):",
            "        self.check(['abc\"', 'de', 'fg,h', 'klm\\\\', '\"nop'],",
            "                   r'\"abc\\\"\",\"de\",\"fg,h\",\"klm\\\\\",\"\\\"nop\"')",
            "",
            "    def test_with_backslash_inside_unquoted(self):",
            "        self.check([r'a\\bc', 'de'], r'a\\bc,de')",
            "",
            "    def test_with_escaped_quotes_in_row_inside_quoted(self):",
            "        self.check(['a\"b\"\"c', 'd'], r'\"a\\\"b\\\"\\\"c\",d')",
            "",
            "",
            "@ddt.ddt",
            "class ValidateIntegerTestCase(test_base.BaseTestCase):",
            "",
            "    @ddt.unpack",
            "    @ddt.data({\"value\": 42, \"name\": \"answer\", \"output\": 42},",
            "              {\"value\": \"42\", \"name\": \"answer\", \"output\": 42},",
            "              {\"value\": \"7\", \"name\": \"lucky\", \"output\": 7,",
            "               \"min_value\": 7, \"max_value\": 8},",
            "              {\"value\": 7, \"name\": \"lucky\", \"output\": 7,",
            "               \"min_value\": 6, \"max_value\": 7},",
            "              {\"value\": 300, \"name\": \"Spartaaa!!!\", \"output\": 300,",
            "               \"min_value\": 300},",
            "              {\"value\": \"300\", \"name\": \"Spartaaa!!!\", \"output\": 300,",
            "               \"max_value\": 300})",
            "    def test_valid_inputs(self, output, value, name, **kwargs):",
            "        self.assertEqual(strutils.validate_integer(value, name,",
            "                                                   **kwargs), output)",
            "",
            "    @ddt.unpack",
            "    @ddt.data({\"value\": \"im-not-an-int\", \"name\": ''},",
            "              {\"value\": 3.14, \"name\": \"Pie\"},",
            "              {\"value\": \"299\", \"name\": \"Sparta no-show\",",
            "               \"min_value\": 300, \"max_value\": 300},",
            "              {\"value\": 55, \"name\": \"doing 55 in a 54\",",
            "               \"max_value\": 54},",
            "              {\"value\": chr(129), \"name\": \"UnicodeError\",",
            "               \"max_value\": 1000})",
            "    def test_invalid_inputs(self, value, name, **kwargs):",
            "        self.assertRaises(ValueError, strutils.validate_integer,",
            "                          value, name, **kwargs)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2011 OpenStack Foundation.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import math",
            "from unittest import mock",
            "",
            "import ddt",
            "from oslotest import base as test_base",
            "import testscenarios",
            "",
            "from oslo_utils import strutils",
            "from oslo_utils import units",
            "",
            "load_tests = testscenarios.load_tests_apply_scenarios",
            "",
            "",
            "class StrUtilsTest(test_base.BaseTestCase):",
            "",
            "    def test_bool_bool_from_string(self):",
            "        self.assertTrue(strutils.bool_from_string(True))",
            "        self.assertFalse(strutils.bool_from_string(False))",
            "",
            "    def test_bool_bool_from_string_default(self):",
            "        self.assertTrue(strutils.bool_from_string('', default=True))",
            "        self.assertFalse(strutils.bool_from_string('wibble', default=False))",
            "",
            "    def _test_bool_from_string(self, c):",
            "        self.assertTrue(strutils.bool_from_string(c('true')))",
            "        self.assertTrue(strutils.bool_from_string(c('TRUE')))",
            "        self.assertTrue(strutils.bool_from_string(c('on')))",
            "        self.assertTrue(strutils.bool_from_string(c('On')))",
            "        self.assertTrue(strutils.bool_from_string(c('yes')))",
            "        self.assertTrue(strutils.bool_from_string(c('YES')))",
            "        self.assertTrue(strutils.bool_from_string(c('yEs')))",
            "        self.assertTrue(strutils.bool_from_string(c('1')))",
            "        self.assertTrue(strutils.bool_from_string(c('T')))",
            "        self.assertTrue(strutils.bool_from_string(c('t')))",
            "        self.assertTrue(strutils.bool_from_string(c('Y')))",
            "        self.assertTrue(strutils.bool_from_string(c('y')))",
            "",
            "        self.assertFalse(strutils.bool_from_string(c('false')))",
            "        self.assertFalse(strutils.bool_from_string(c('FALSE')))",
            "        self.assertFalse(strutils.bool_from_string(c('off')))",
            "        self.assertFalse(strutils.bool_from_string(c('OFF')))",
            "        self.assertFalse(strutils.bool_from_string(c('no')))",
            "        self.assertFalse(strutils.bool_from_string(c('0')))",
            "        self.assertFalse(strutils.bool_from_string(c('42')))",
            "        self.assertFalse(strutils.bool_from_string(c(",
            "                         'This should not be True')))",
            "        self.assertFalse(strutils.bool_from_string(c('F')))",
            "        self.assertFalse(strutils.bool_from_string(c('f')))",
            "        self.assertFalse(strutils.bool_from_string(c('N')))",
            "        self.assertFalse(strutils.bool_from_string(c('n')))",
            "",
            "        # Whitespace should be stripped",
            "        self.assertTrue(strutils.bool_from_string(c(' 1 ')))",
            "        self.assertTrue(strutils.bool_from_string(c(' true ')))",
            "        self.assertFalse(strutils.bool_from_string(c(' 0 ')))",
            "        self.assertFalse(strutils.bool_from_string(c(' false ')))",
            "",
            "    def test_bool_from_string(self):",
            "        self._test_bool_from_string(lambda s: s)",
            "",
            "    def test_unicode_bool_from_string(self):",
            "        self._test_bool_from_string(str)",
            "        self.assertFalse(strutils.bool_from_string(u'\u4f7f\u7528', strict=False))",
            "",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string,",
            "                                u'\u4f7f\u7528', strict=True)",
            "        expected_msg = (u\"Unrecognized value '\u4f7f\u7528', acceptable values are:\"",
            "                        u\" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        u\" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "    def test_other_bool_from_string(self):",
            "        self.assertFalse(strutils.bool_from_string(None))",
            "        self.assertFalse(strutils.bool_from_string(mock.Mock()))",
            "",
            "    def test_int_bool_from_string(self):",
            "        self.assertTrue(strutils.bool_from_string(1))",
            "",
            "        self.assertFalse(strutils.bool_from_string(-1))",
            "        self.assertFalse(strutils.bool_from_string(0))",
            "        self.assertFalse(strutils.bool_from_string(2))",
            "",
            "    def test_strict_bool_from_string(self):",
            "        # None isn't allowed in strict mode",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, None,",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value 'None', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # Unrecognized strings aren't allowed",
            "        self.assertFalse(strutils.bool_from_string('Other', strict=False))",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, 'Other',",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value 'Other', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # Unrecognized numbers aren't allowed",
            "        exc = self.assertRaises(ValueError, strutils.bool_from_string, 2,",
            "                                strict=True)",
            "        expected_msg = (\"Unrecognized value '2', acceptable values are:\"",
            "                        \" '0', '1', 'f', 'false', 'n', 'no', 'off', 'on',\"",
            "                        \" 't', 'true', 'y', 'yes'\")",
            "        self.assertEqual(expected_msg, str(exc))",
            "",
            "        # False-like values are allowed",
            "        self.assertFalse(strutils.bool_from_string('f', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('false', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('off', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('n', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('no', strict=True))",
            "        self.assertFalse(strutils.bool_from_string('0', strict=True))",
            "",
            "        self.assertTrue(strutils.bool_from_string('1', strict=True))",
            "",
            "        # Avoid font-similarity issues (one looks like lowercase-el, zero like",
            "        # oh, etc...)",
            "        for char in ('O', 'o', 'L', 'l', 'I', 'i'):",
            "            self.assertRaises(ValueError, strutils.bool_from_string, char,",
            "                              strict=True)",
            "",
            "    def test_int_from_bool_as_string(self):",
            "        self.assertEqual(1, strutils.int_from_bool_as_string(True))",
            "        self.assertEqual(0, strutils.int_from_bool_as_string(False))",
            "",
            "    def test_is_valid_boolstr(self):",
            "        self.assertTrue(strutils.is_valid_boolstr('true'))",
            "        self.assertTrue(strutils.is_valid_boolstr('false'))",
            "        self.assertTrue(strutils.is_valid_boolstr('yes'))",
            "        self.assertTrue(strutils.is_valid_boolstr('no'))",
            "        self.assertTrue(strutils.is_valid_boolstr('y'))",
            "        self.assertTrue(strutils.is_valid_boolstr('n'))",
            "        self.assertTrue(strutils.is_valid_boolstr('1'))",
            "        self.assertTrue(strutils.is_valid_boolstr('0'))",
            "        self.assertTrue(strutils.is_valid_boolstr(1))",
            "        self.assertTrue(strutils.is_valid_boolstr(0))",
            "",
            "        self.assertFalse(strutils.is_valid_boolstr('maybe'))",
            "        self.assertFalse(strutils.is_valid_boolstr('only on tuesdays'))",
            "",
            "    def test_slugify(self):",
            "        to_slug = strutils.to_slug",
            "        self.assertRaises(TypeError, to_slug, True)",
            "        self.assertEqual(\"hello\", to_slug(\"hello\"))",
            "        self.assertEqual(\"two-words\", to_slug(\"Two Words\"))",
            "        self.assertEqual(\"ma-any-spa-ce-es\",",
            "                         to_slug(\"Ma-any\\t spa--ce- es\"))",
            "        self.assertEqual(\"excamation\", to_slug(\"exc!amation!\"))",
            "        self.assertEqual(\"ampserand\", to_slug(\"&ampser$and\"))",
            "        self.assertEqual(\"ju5tnum8er\", to_slug(\"ju5tnum8er\"))",
            "        self.assertEqual(\"strip-\", to_slug(\" strip - \"))",
            "        self.assertEqual(\"perche\",",
            "                         to_slug(\"perch\\xc3\\xa9\".encode(\"latin-1\")))",
            "        self.assertEqual(\"strange\",",
            "                         to_slug(\"\\x80strange\", errors=\"ignore\"))",
            "",
            "",
            "class StringToBytesTest(test_base.BaseTestCase):",
            "",
            "    _unit_system = [",
            "        ('si', dict(unit_system='SI')),",
            "        ('iec', dict(unit_system='IEC')),",
            "        ('mixed', dict(unit_system='mixed')),",
            "        ('invalid_unit_system', dict(unit_system='KKK', assert_error=True)),",
            "    ]",
            "",
            "    _sign = [",
            "        ('no_sign', dict(sign='')),",
            "        ('positive', dict(sign='+')),",
            "        ('negative', dict(sign='-')),",
            "        ('invalid_sign', dict(sign='~', assert_error=True)),",
            "    ]",
            "",
            "    _magnitude = [",
            "        ('integer', dict(magnitude='79')),",
            "        ('decimal', dict(magnitude='7.9')),",
            "        ('decimal_point_start', dict(magnitude='.9')),",
            "        ('decimal_point_end', dict(magnitude='79.', assert_error=True)),",
            "        ('invalid_literal', dict(magnitude='7.9.9', assert_error=True)),",
            "        ('garbage_value', dict(magnitude='asdf', assert_error=True)),",
            "    ]",
            "",
            "    _unit_prefix = [",
            "        ('no_unit_prefix', dict(unit_prefix='')),",
            "        ('k', dict(unit_prefix='k')),",
            "        ('K', dict(unit_prefix='K')),",
            "        ('M', dict(unit_prefix='M')),",
            "        ('G', dict(unit_prefix='G')),",
            "        ('T', dict(unit_prefix='T')),",
            "        ('Ki', dict(unit_prefix='Ki')),",
            "        ('Mi', dict(unit_prefix='Mi')),",
            "        ('Gi', dict(unit_prefix='Gi')),",
            "        ('Ti', dict(unit_prefix='Ti')),",
            "        ('invalid_unit_prefix', dict(unit_prefix='B', assert_error=True)),",
            "    ]",
            "",
            "    _unit_suffix = [",
            "        ('b', dict(unit_suffix='b')),",
            "        ('bit', dict(unit_suffix='bit')),",
            "        ('B', dict(unit_suffix='B')),",
            "        ('invalid_unit_suffix', dict(unit_suffix='Kg', assert_error=True)),",
            "    ]",
            "",
            "    _return_int = [",
            "        ('return_dec', dict(return_int=False)),",
            "        ('return_int', dict(return_int=True)),",
            "    ]",
            "",
            "    @classmethod",
            "    def generate_scenarios(cls):",
            "        cls.scenarios = testscenarios.multiply_scenarios(cls._unit_system,",
            "                                                         cls._sign,",
            "                                                         cls._magnitude,",
            "                                                         cls._unit_prefix,",
            "                                                         cls._unit_suffix,",
            "                                                         cls._return_int)",
            "",
            "    def test_string_to_bytes(self):",
            "",
            "        def _get_quantity(sign, magnitude, unit_suffix):",
            "            res = float('%s%s' % (sign, magnitude))",
            "            if unit_suffix in ['b', 'bit']:",
            "                res /= 8",
            "            return res",
            "",
            "        def _get_constant(unit_prefix, unit_system):",
            "            if not unit_prefix:",
            "                return 1",
            "            elif unit_system == 'SI':",
            "                res = getattr(units, unit_prefix)",
            "            elif unit_system == 'IEC':",
            "                if unit_prefix.endswith('i'):",
            "                    res = getattr(units, unit_prefix)",
            "                else:",
            "                    res = getattr(units, '%si' % unit_prefix)",
            "            elif unit_system == 'mixed':",
            "                # Note: this will return 'i' units as power-of-two,",
            "                # and other units as power-of-ten.  Additionally, for",
            "                # compatability a \"K\" is interpreted as \"k\" in mixed",
            "                # mode",
            "                if unit_prefix == 'K':",
            "                    unit_prefix = 'k'",
            "                res = getattr(units, unit_prefix)",
            "            return res",
            "",
            "        text = ''.join([self.sign, self.magnitude, self.unit_prefix,",
            "                        self.unit_suffix])",
            "        err_si = self.unit_system == 'SI' and (self.unit_prefix == 'K' or",
            "                                               self.unit_prefix.endswith('i'))",
            "        err_iec = self.unit_system == 'IEC' and self.unit_prefix == 'k'",
            "        if getattr(self, 'assert_error', False) or err_si or err_iec:",
            "            self.assertRaises(ValueError, strutils.string_to_bytes,",
            "                              text, unit_system=self.unit_system,",
            "                              return_int=self.return_int)",
            "            return",
            "        quantity = _get_quantity(self.sign, self.magnitude, self.unit_suffix)",
            "        constant = _get_constant(self.unit_prefix, self.unit_system)",
            "        expected = quantity * constant",
            "        actual = strutils.string_to_bytes(text, unit_system=self.unit_system,",
            "                                          return_int=self.return_int)",
            "        if self.return_int:",
            "            self.assertEqual(actual, int(math.ceil(expected)))",
            "        else:",
            "            self.assertAlmostEqual(actual, expected)",
            "",
            "",
            "StringToBytesTest.generate_scenarios()",
            "",
            "",
            "class MaskPasswordTestCase(test_base.BaseTestCase):",
            "",
            "    def test_sanitize_keys(self):",
            "",
            "        lowered = [k.lower() for k in strutils._SANITIZE_KEYS]",
            "        message = \"The _SANITIZE_KEYS must all be lowercase.\"",
            "        self.assertEqual(strutils._SANITIZE_KEYS, lowered, message)",
            "",
            "    def test_json(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"{'adminPass':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'adminPass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"{ 'adminPass' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'adminPass' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"{'admin_pass':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'admin_pass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"{ 'admin_pass' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'admin_pass' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"{'admin_password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'admin_password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"{ 'admin_password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'admin_password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"{'password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"{ 'password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'auth_password' w/o spaces",
            "        payload = \"\"\"{'auth_password':'TL0EfN33'}\"\"\"",
            "        expected = \"\"\"{'auth_password':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'auth_password' with spaces",
            "        payload = \"\"\"{ 'auth_password' : 'TL0EfN33' }\"\"\"",
            "        expected = \"\"\"{ 'auth_password' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'secret_uuid' w/o spaces",
            "        payload = \"\"\"{'secret_uuid':'myuuid'}\"\"\"",
            "        expected = \"\"\"{'secret_uuid':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'secret_uuid' with spaces",
            "        payload = \"\"\"{ 'secret_uuid' : 'myuuid' }\"\"\"",
            "        expected = \"\"\"{ 'secret_uuid' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'token' w/o spaces",
            "        payload = \"\"\"{'token':'token'}\"\"\"",
            "        expected = \"\"\"{'token':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'token' with spaces",
            "        payload = \"\"\"{ 'token' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'token' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'fernetkey'",
            "        payload = \"\"\"{ 'fernetkey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'fernetkey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'FernetKey'",
            "        payload = \"\"\"{ 'FernetKey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'FernetKey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'sslkey'",
            "        payload = \"\"\"{ 'sslkey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'sslkey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'SslKey'",
            "        payload = \"\"\"{ 'SslKey' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'SslKey' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'passphrase'",
            "        payload = \"\"\"{ 'passphrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'passphrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'PassPhrase'",
            "        payload = \"\"\"{ 'PassPhrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'PassPhrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Some real-life cases",
            "        # Test 'KeystoneFernetKey1'",
            "        payload = \"\"\"{ 'KeystoneFernetKey1' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'KeystoneFernetKey1' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'OctaviaCaKeyPassword'",
            "        payload = \"\"\"{ 'OctaviaCaKeyPassword' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'OctaviaCaKeyPassword' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'OctaviaCaKeyPassphrase'",
            "        payload = \"\"\"{ 'OctaviaCaKeyPassphrase' : 'token' }\"\"\"",
            "        expected = \"\"\"{ 'OctaviaCaKeyPassphrase' : '***' }\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"<adminPass>TL0EfN33</adminPass>\"\"\"",
            "        expected = \"\"\"<adminPass>***</adminPass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"<adminPass>",
            "                        TL0EfN33",
            "                     </adminPass>\"\"\"",
            "        expected = \"\"\"<adminPass>***</adminPass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"<admin_pass>TL0EfN33</admin_pass>\"\"\"",
            "        expected = \"\"\"<admin_pass>***</admin_pass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"<admin_pass>",
            "                        TL0EfN33",
            "                     </admin_pass>\"\"\"",
            "        expected = \"\"\"<admin_pass>***</admin_pass>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"<admin_password>TL0EfN33</admin_password>\"\"\"",
            "        expected = \"\"\"<admin_password>***</admin_password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"<admin_password>",
            "                        TL0EfN33",
            "                     </admin_password>\"\"\"",
            "        expected = \"\"\"<admin_password>***</admin_password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"<password>TL0EfN33</password>\"\"\"",
            "        expected = \"\"\"<password>***</password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"<password>",
            "                        TL0EfN33",
            "                     </password>\"\"\"",
            "        expected = \"\"\"<password>***</password>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'Password1' - case-insensitive + number",
            "        payload = \"\"\"<Password1>TL0EfN33</Password1>\"\"\"",
            "        expected = \"\"\"<Password1>***</Password1>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml_attribute(self):",
            "        # Test 'adminPass' w/o spaces",
            "        payload = \"\"\"adminPass='TL0EfN33'\"\"\"",
            "        expected = \"\"\"adminPass='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with spaces",
            "        payload = \"\"\"adminPass = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"adminPass = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'adminPass' with double quotes",
            "        payload = \"\"\"adminPass = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"adminPass = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' w/o spaces",
            "        payload = \"\"\"admin_pass='TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_pass='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with spaces",
            "        payload = \"\"\"admin_pass = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_pass = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_pass' with double quotes",
            "        payload = \"\"\"admin_pass = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"admin_pass = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' w/o spaces",
            "        payload = \"\"\"admin_password='TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_password='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with spaces",
            "        payload = \"\"\"admin_password = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"admin_password = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'admin_password' with double quotes",
            "        payload = \"\"\"admin_password = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"admin_password = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' w/o spaces",
            "        payload = \"\"\"password='TL0EfN33'\"\"\"",
            "        expected = \"\"\"password='***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with spaces",
            "        payload = \"\"\"password = 'TL0EfN33'\"\"\"",
            "        expected = \"\"\"password = '***'\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        # Test 'password' with double quotes",
            "        payload = \"\"\"password = \"TL0EfN33\\\"\"\"\"",
            "        expected = \"\"\"password = \"***\\\"\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_json_message(self):",
            "        payload = \"\"\"body: {\"changePassword\": {\"adminPass\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"changePassword\": {\"adminPass\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"admin_pass\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"admin_pass\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"admin_password\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"admin_password\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"password\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"password\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"body: {\"rescue\": {\"encryption_key_id\": \"1234567\"}}\"\"\"",
            "        expected = \"\"\"body: {\"rescue\": {\"encryption_key_id\": \"***\"}}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_xml_message(self):",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rebuild",
            "    xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    name=\"foobar\"",
            "    imageRef=\"http://openstack.example.com/v1.1/32278/images/70a599e0-31e7\"",
            "    accessIPv4=\"1.2.3.4\"",
            "    accessIPv6=\"fe80::100\"",
            "    adminPass=\"seekr3t\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</rebuild>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rebuild",
            "    xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    name=\"foobar\"",
            "    imageRef=\"http://openstack.example.com/v1.1/32278/images/70a599e0-31e7\"",
            "    accessIPv4=\"1.2.3.4\"",
            "    accessIPv6=\"fe80::100\"",
            "    adminPass=\"***\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</rebuild>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_pass=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_pass=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_password=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    admin_password=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "        payload = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    password=\"MySecretPass\"/>\"\"\"",
            "        expected = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "<rescue xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "    password=\"***\"/>\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "    def test_mask_password(self):",
            "        payload = \"test = 'password'  :   'aaaaaa'\"",
            "        expected = \"test = 'password'  :   '111'\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = 'mysqld --password \"aaaaaa\"'",
            "        expected = 'mysqld --password \"****\"'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = 'mysqld --password aaaaaa'",
            "        expected = 'mysqld --password ???'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='???'))",
            "",
            "        payload = 'mysqld --password = \"aaaaaa\"'",
            "        expected = 'mysqld --password = \"****\"'",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"mysqld --password = 'aaaaaa'\"",
            "        expected = \"mysqld --password = '****'\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"mysqld --password = aaaaaa\"",
            "        expected = \"mysqld --password = ****\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='****'))",
            "",
            "        payload = \"test = password =   aaaaaa\"",
            "        expected = \"test = password =   111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password=   aaaaaa\"",
            "        expected = \"test = password=   111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password =aaaaaa\"",
            "        expected = \"test = password =111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = \"test = password=aaaaaa\"",
            "        expected = \"test = password=111\"",
            "        self.assertEqual(expected,",
            "                         strutils.mask_password(payload, secret='111'))",
            "",
            "        payload = 'test = \"original_password\" : \"aaaaaaaaa\"'",
            "        expected = 'test = \"original_password\" : \"***\"'",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = 'test = \"param1\" : \"value\"'",
            "        expected = 'test = \"param1\" : \"value\"'",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = 'test = \"original_password\" : \"aaaaa\"aaaa\"'",
            "        expected = 'test = \"original_password\" : \"***\"'",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"\"\"{'adminPass':'TL0EfN33'}\"\"\"",
            "        payload = str(payload)",
            "        expected = \"\"\"{'adminPass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"\"\"{'adminPass':'TL0E'fN33'}\"\"\"",
            "        payload = str(payload)",
            "        expected = \"\"\"{'adminPass':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"\"\"{'token':'mytoken'}\"\"\"",
            "        payload = str(payload)",
            "        expected = \"\"\"{'token':'***'}\"\"\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password','-v','TL0EfN33',\"",
            "                   \"'nomask'\")",
            "        expected = (\"test = 'node.session.auth.password','-v','***',\"",
            "                    \"'nomask'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password', '--password', \"",
            "                   \"'TL0EfN33', 'nomask'\")",
            "        expected = (\"test = 'node.session.auth.password', '--password', \"",
            "                    \"'***', 'nomask'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = 'node.session.auth.password', '--password', \"",
            "                   \"'TL0EfN33'\")",
            "        expected = (\"test = 'node.session.auth.password', '--password', \"",
            "                    \"'***'\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"test = node.session.auth.password -v TL0EfN33 nomask\"",
            "        expected = \"test = node.session.auth.password -v *** nomask\"",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = node.session.auth.password --password TL0EfN33 \"",
            "                   \"nomask\")",
            "        expected = (\"test = node.session.auth.password --password *** \"",
            "                    \"nomask\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = (\"test = node.session.auth.password --password TL0EfN33\")",
            "        expected = (\"test = node.session.auth.password --password ***\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "        payload = \"test = cmd --password my\\xe9\\x80\\x80pass\"",
            "        expected = (\"test = cmd --password ***\")",
            "        self.assertEqual(expected, strutils.mask_password(payload))",
            "",
            "",
            "class TestMapping(collections.Mapping):",
            "    \"\"\"Test class for non-dict mappings\"\"\"",
            "    def __init__(self):",
            "        super(TestMapping, self).__init__()",
            "        self.data = {'password': 'shhh',",
            "                     'foo': 'bar',",
            "                     }",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __iter__(self):",
            "        return self.data.__iter__()",
            "",
            "    def __len__(self):",
            "        return len(self.data)",
            "",
            "",
            "class NestedMapping(TestMapping):",
            "    \"\"\"Test class that contains an instance of TestMapping\"\"\"",
            "    def __init__(self):",
            "        super(NestedMapping, self).__init__()",
            "        self.data = {'nested': TestMapping()}",
            "",
            "",
            "class MaskDictionaryPasswordTestCase(test_base.BaseTestCase):",
            "",
            "    def test_dictionary(self):",
            "        payload = {'password': 'TL0EfN33'}",
            "        expected = {'password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'password': 'TL0Ef\"N33'}",
            "        expected = {'password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'user': 'admin', 'password': 'TL0EfN33'}",
            "        expected = {'user': 'admin', 'password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'strval': 'somestring',",
            "                   'dictval': {'user': 'admin', 'password': 'TL0EfN33'}}",
            "        expected = {'strval': 'somestring',",
            "                    'dictval': {'user': 'admin', 'password': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'strval': '--password abc',",
            "                   'dont_change': 'this is fine',",
            "                   'dictval': {'user': 'admin', 'password': b'TL0EfN33'}}",
            "        expected = {'strval': '--password ***',",
            "                    'dont_change': 'this is fine',",
            "                    'dictval': {'user': 'admin', 'password': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'ipmi_password': 'KeDrahishvowphyecMornEm0or('}",
            "        expected = {'ipmi_password': '***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'passwords': {'KeystoneFernetKey1': 'c5FijjS'}}",
            "        expected = {'passwords': {'KeystoneFernetKey1': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'passwords': {'keystonecredential0': 'c5FijjS'}}",
            "        expected = {'passwords': {'keystonecredential0': '***'}}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_do_no_harm(self):",
            "        payload = {}",
            "        expected = {}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "        payload = {'somekey': 'somevalue',",
            "                   'anotherkey': 'anothervalue'}",
            "        expected = {'somekey': 'somevalue',",
            "                    'anotherkey': 'anothervalue'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_do_an_int(self):",
            "        payload = {}",
            "        payload[1] = 2",
            "        expected = payload.copy()",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_mask_values(self):",
            "        payload = {'somekey': 'test = cmd --password my\\xe9\\x80\\x80pass'}",
            "        expected = {'somekey': 'test = cmd --password ***'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_other_non_str_values(self):",
            "        payload = {'password': 'DK0PK1AK3', 'bool': True,",
            "                   'dict': {'cat': 'meow', 'password': \"*aa38skdjf\"},",
            "                   'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                   'str': 'foo'}",
            "        expected = {'password': '***', 'bool': True,",
            "                    'dict': {'cat': 'meow', 'password': '***'},",
            "                    'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                    'str': 'foo'}",
            "        self.assertEqual(expected,",
            "                         strutils.mask_dict_password(payload))",
            "",
            "    def test_argument_untouched(self):",
            "        \"\"\"Make sure that the argument passed in is not modified\"\"\"",
            "        payload = {'password': 'DK0PK1AK3', 'bool': True,",
            "                   'dict': {'cat': 'meow', 'password': \"*aa38skdjf\"},",
            "                   'float': 0.1, 'int': 123, 'list': [1, 2], 'none': None,",
            "                   'str': 'foo'}",
            "        pristine = copy.deepcopy(payload)",
            "        # Send the payload into the function, to see if it gets modified",
            "        strutils.mask_dict_password(payload)",
            "        self.assertEqual(pristine, payload)",
            "",
            "    def test_non_dict(self):",
            "        expected = {'password': '***',",
            "                    'foo': 'bar',",
            "                    }",
            "        payload = TestMapping()",
            "        self.assertEqual(expected, strutils.mask_dict_password(payload))",
            "",
            "    def test_nested_non_dict(self):",
            "        expected = {'nested': {'password': '***',",
            "                               'foo': 'bar',",
            "                               }",
            "                    }",
            "        payload = NestedMapping()",
            "        self.assertEqual(expected, strutils.mask_dict_password(payload))",
            "",
            "",
            "class IsIntLikeTestCase(test_base.BaseTestCase):",
            "    def test_is_int_like_true(self):",
            "        self.assertTrue(strutils.is_int_like(1))",
            "        self.assertTrue(strutils.is_int_like(\"1\"))",
            "        self.assertTrue(strutils.is_int_like(\"514\"))",
            "        self.assertTrue(strutils.is_int_like(\"0\"))",
            "",
            "    def test_is_int_like_false(self):",
            "        self.assertFalse(strutils.is_int_like(1.1))",
            "        self.assertFalse(strutils.is_int_like(\"1.1\"))",
            "        self.assertFalse(strutils.is_int_like(\"1.1.1\"))",
            "        self.assertFalse(strutils.is_int_like(None))",
            "        self.assertFalse(strutils.is_int_like(\"0.\"))",
            "        self.assertFalse(strutils.is_int_like(\"aaaaaa\"))",
            "        self.assertFalse(strutils.is_int_like(\"....\"))",
            "        self.assertFalse(strutils.is_int_like(\"1g\"))",
            "        self.assertFalse(",
            "            strutils.is_int_like(\"0cc3346e-9fef-4445-abe6-5d2b2690ec64\"))",
            "        self.assertFalse(strutils.is_int_like(\"a1\"))",
            "        # NOTE(viktors): 12e3 - is a float number",
            "        self.assertFalse(strutils.is_int_like(\"12e3\"))",
            "        # NOTE(viktors): Check integer numbers with base not 10",
            "        self.assertFalse(strutils.is_int_like(\"0o51\"))",
            "        self.assertFalse(strutils.is_int_like(\"0xDEADBEEF\"))",
            "",
            "",
            "class StringLengthTestCase(test_base.BaseTestCase):",
            "    def test_check_string_length(self):",
            "        self.assertIsNone(strutils.check_string_length(",
            "                          'test', 'name', max_length=255))",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          '', 'name', min_length=1)",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          'a' * 256, 'name', max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          11, 'name', max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          dict(), 'name', max_length=255)",
            "",
            "    def test_check_string_length_noname(self):",
            "        self.assertIsNone(strutils.check_string_length(",
            "                          'test', max_length=255))",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          '', min_length=1)",
            "        self.assertRaises(ValueError,",
            "                          strutils.check_string_length,",
            "                          'a' * 256, max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          11, max_length=255)",
            "        self.assertRaises(TypeError,",
            "                          strutils.check_string_length,",
            "                          dict(), max_length=255)",
            "",
            "",
            "class SplitPathTestCase(test_base.BaseTestCase):",
            "    def test_split_path_failed(self):",
            "        self.assertRaises(ValueError, strutils.split_path, '')",
            "        self.assertRaises(ValueError, strutils.split_path, '/')",
            "        self.assertRaises(ValueError, strutils.split_path, '//')",
            "        self.assertRaises(ValueError, strutils.split_path, '//a')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c')",
            "        self.assertRaises(ValueError, strutils.split_path, '//c')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c/')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a//')",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2, 3)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 2, 3, True)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a/c/o/r', 3, 3)",
            "        self.assertRaises(ValueError, strutils.split_path, '/a', 5, 4)",
            "",
            "    def test_split_path_success(self):",
            "        self.assertEqual(strutils.split_path('/a'), ['a'])",
            "        self.assertEqual(strutils.split_path('/a/'), ['a'])",
            "        self.assertEqual(strutils.split_path('/a/c', 2), ['a', 'c'])",
            "        self.assertEqual(strutils.split_path('/a/c/o', 3), ['a', 'c', 'o'])",
            "        self.assertEqual(strutils.split_path('/a/c/o/r', 3, 3, True),",
            "                         ['a', 'c', 'o/r'])",
            "        self.assertEqual(strutils.split_path('/a/c', 2, 3, True),",
            "                         ['a', 'c', None])",
            "        self.assertEqual(strutils.split_path('/a/c/', 2), ['a', 'c'])",
            "        self.assertEqual(strutils.split_path('/a/c/', 2, 3), ['a', 'c', ''])",
            "",
            "    def test_split_path_invalid_path(self):",
            "        try:",
            "            strutils.split_path('o\\nn e', 2)",
            "        except ValueError as err:",
            "            self.assertEqual(str(err), 'Invalid path: o%0An%20e')",
            "        try:",
            "            strutils.split_path('o\\nn e', 2, 3, True)",
            "        except ValueError as err:",
            "            self.assertEqual(str(err), 'Invalid path: o%0An%20e')",
            "",
            "",
            "class SplitByCommas(test_base.BaseTestCase):",
            "    def test_not_closed_quotes(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, '\"ab\",\"b\"\"')",
            "",
            "    def test_no_comma_before_opening_quotes(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, '\"ab\"\"b\"')",
            "",
            "    def test_quote_inside_unquoted(self):",
            "        self.assertRaises(ValueError, strutils.split_by_commas, 'a\"b,cd')",
            "",
            "    def check(self, expect, input):",
            "        self.assertEqual(expect, strutils.split_by_commas(input))",
            "",
            "    def test_plain(self):",
            "        self.check([\"a,b\", \"ac\"], '\"a,b\",ac')",
            "",
            "    def test_with_backslash_inside_quoted(self):",
            "        self.check(['abc\"', 'de', 'fg,h', 'klm\\\\', '\"nop'],",
            "                   r'\"abc\\\"\",\"de\",\"fg,h\",\"klm\\\\\",\"\\\"nop\"')",
            "",
            "    def test_with_backslash_inside_unquoted(self):",
            "        self.check([r'a\\bc', 'de'], r'a\\bc,de')",
            "",
            "    def test_with_escaped_quotes_in_row_inside_quoted(self):",
            "        self.check(['a\"b\"\"c', 'd'], r'\"a\\\"b\\\"\\\"c\",d')",
            "",
            "",
            "@ddt.ddt",
            "class ValidateIntegerTestCase(test_base.BaseTestCase):",
            "",
            "    @ddt.unpack",
            "    @ddt.data({\"value\": 42, \"name\": \"answer\", \"output\": 42},",
            "              {\"value\": \"42\", \"name\": \"answer\", \"output\": 42},",
            "              {\"value\": \"7\", \"name\": \"lucky\", \"output\": 7,",
            "               \"min_value\": 7, \"max_value\": 8},",
            "              {\"value\": 7, \"name\": \"lucky\", \"output\": 7,",
            "               \"min_value\": 6, \"max_value\": 7},",
            "              {\"value\": 300, \"name\": \"Spartaaa!!!\", \"output\": 300,",
            "               \"min_value\": 300},",
            "              {\"value\": \"300\", \"name\": \"Spartaaa!!!\", \"output\": 300,",
            "               \"max_value\": 300})",
            "    def test_valid_inputs(self, output, value, name, **kwargs):",
            "        self.assertEqual(strutils.validate_integer(value, name,",
            "                                                   **kwargs), output)",
            "",
            "    @ddt.unpack",
            "    @ddt.data({\"value\": \"im-not-an-int\", \"name\": ''},",
            "              {\"value\": 3.14, \"name\": \"Pie\"},",
            "              {\"value\": \"299\", \"name\": \"Sparta no-show\",",
            "               \"min_value\": 300, \"max_value\": 300},",
            "              {\"value\": 55, \"name\": \"doing 55 in a 54\",",
            "               \"max_value\": 54},",
            "              {\"value\": chr(129), \"name\": \"UnicodeError\",",
            "               \"max_value\": 1000})",
            "    def test_invalid_inputs(self, value, name, **kwargs):",
            "        self.assertRaises(ValueError, strutils.validate_integer,",
            "                          value, name, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "oslo_utils.tests.test_strutils.MaskDictionaryPasswordTestCase.test_dictionary.payload",
            "pypdf.generic._data_structures",
            "oslo_utils.tests.test_strutils.MaskDictionaryPasswordTestCase.test_dictionary.expected"
        ]
    }
}