{
    "airflow/api_connexion/endpoints/dag_source_endpoint.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from __future__ import annotations"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from http import HTTPStatus"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from typing import TYPE_CHECKING"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from flask import Response, current_app, request"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from itsdangerous import BadSignature, URLSafeSerializer"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from airflow.api_connexion import security"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from airflow.api_connexion.exceptions import NotFound"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from airflow.api_connexion.exceptions import NotFound, PermissionDenied"
            },
            "11": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from airflow.api_connexion.schemas.dag_source_schema import dag_source_schema"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from airflow.api_connexion.security import get_readable_dags"
            },
            "13": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from airflow.auth.managers.models.resource_details import DagAccessEntity"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+from airflow.models.dag import DagModel"
            },
            "15": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from airflow.models.dagcode import DagCode"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from airflow.utils.session import NEW_SESSION, provide_session"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+if TYPE_CHECKING:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    from sqlalchemy.orm import Session"
            },
            "20": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " @security.requires_access_dag(\"GET\", DagAccessEntity.CODE)"
            },
            "23": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def get_dag_source(*, file_token: str) -> Response:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+@provide_session"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+def get_dag_source(*, file_token: str, session: Session = NEW_SESSION) -> Response:"
            },
            "26": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     \"\"\"Get source code using file token.\"\"\""
            },
            "27": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     secret_key = current_app.config[\"SECRET_KEY\"]"
            },
            "28": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     auth_s = URLSafeSerializer(secret_key)"
            },
            "29": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     try:"
            },
            "30": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         path = auth_s.loads(file_token)"
            },
            "31": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        dag_source = DagCode.code(path)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        dag_ids = session.query(DagModel.dag_id).filter(DagModel.fileloc == path).all()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        readable_dags = get_readable_dags()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        # Check if user has read access to all the DAGs defined in the file"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        if any(dag_id[0] not in readable_dags for dag_id in dag_ids):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            raise PermissionDenied()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        dag_source = DagCode.code(path, session=session)"
            },
            "38": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     except (BadSignature, FileNotFoundError):"
            },
            "39": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         raise NotFound(\"Dag source not found\")"
            },
            "40": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "",
            "from flask import Response, current_app, request",
            "from itsdangerous import BadSignature, URLSafeSerializer",
            "",
            "from airflow.api_connexion import security",
            "from airflow.api_connexion.exceptions import NotFound",
            "from airflow.api_connexion.schemas.dag_source_schema import dag_source_schema",
            "from airflow.auth.managers.models.resource_details import DagAccessEntity",
            "from airflow.models.dagcode import DagCode",
            "",
            "",
            "@security.requires_access_dag(\"GET\", DagAccessEntity.CODE)",
            "def get_dag_source(*, file_token: str) -> Response:",
            "    \"\"\"Get source code using file token.\"\"\"",
            "    secret_key = current_app.config[\"SECRET_KEY\"]",
            "    auth_s = URLSafeSerializer(secret_key)",
            "    try:",
            "        path = auth_s.loads(file_token)",
            "        dag_source = DagCode.code(path)",
            "    except (BadSignature, FileNotFoundError):",
            "        raise NotFound(\"Dag source not found\")",
            "",
            "    return_type = request.accept_mimetypes.best_match([\"text/plain\", \"application/json\"])",
            "    if return_type == \"text/plain\":",
            "        return Response(dag_source, headers={\"Content-Type\": return_type})",
            "    if return_type == \"application/json\":",
            "        content = dag_source_schema.dumps({\"content\": dag_source})",
            "        return Response(content, headers={\"Content-Type\": return_type})",
            "    return Response(\"Not Allowed Accept Header\", status=HTTPStatus.NOT_ACCEPTABLE)"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "from typing import TYPE_CHECKING",
            "",
            "from flask import Response, current_app, request",
            "from itsdangerous import BadSignature, URLSafeSerializer",
            "",
            "from airflow.api_connexion import security",
            "from airflow.api_connexion.exceptions import NotFound, PermissionDenied",
            "from airflow.api_connexion.schemas.dag_source_schema import dag_source_schema",
            "from airflow.api_connexion.security import get_readable_dags",
            "from airflow.auth.managers.models.resource_details import DagAccessEntity",
            "from airflow.models.dag import DagModel",
            "from airflow.models.dagcode import DagCode",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "",
            "@security.requires_access_dag(\"GET\", DagAccessEntity.CODE)",
            "@provide_session",
            "def get_dag_source(*, file_token: str, session: Session = NEW_SESSION) -> Response:",
            "    \"\"\"Get source code using file token.\"\"\"",
            "    secret_key = current_app.config[\"SECRET_KEY\"]",
            "    auth_s = URLSafeSerializer(secret_key)",
            "    try:",
            "        path = auth_s.loads(file_token)",
            "        dag_ids = session.query(DagModel.dag_id).filter(DagModel.fileloc == path).all()",
            "        readable_dags = get_readable_dags()",
            "        # Check if user has read access to all the DAGs defined in the file",
            "        if any(dag_id[0] not in readable_dags for dag_id in dag_ids):",
            "            raise PermissionDenied()",
            "        dag_source = DagCode.code(path, session=session)",
            "    except (BadSignature, FileNotFoundError):",
            "        raise NotFound(\"Dag source not found\")",
            "",
            "    return_type = request.accept_mimetypes.best_match([\"text/plain\", \"application/json\"])",
            "    if return_type == \"text/plain\":",
            "        return Response(dag_source, headers={\"Content-Type\": return_type})",
            "    if return_type == \"application/json\":",
            "        content = dag_source_schema.dumps({\"content\": dag_source})",
            "        return Response(content, headers={\"Content-Type\": return_type})",
            "    return Response(\"Not Allowed Accept Header\", status=HTTPStatus.NOT_ACCEPTABLE)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [],
            "32": [
                "get_dag_source"
            ],
            "38": [
                "get_dag_source"
            ]
        },
        "addLocation": []
    },
    "airflow/models/dagcode.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         return cls.code(fileloc)"
            },
            "1": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     @classmethod"
            },
            "3": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def code(cls, fileloc) -> str:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+    @provide_session"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    def code(cls, fileloc, session: Session = NEW_SESSION) -> str:"
            },
            "6": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         \"\"\"Return source code for this DagCode object."
            },
            "7": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         :return: source code as string"
            },
            "9": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         \"\"\""
            },
            "10": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return cls._get_code_from_db(fileloc)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        return cls._get_code_from_db(fileloc, session)"
            },
            "12": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     @staticmethod"
            },
            "14": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     def _get_code_from_file(fileloc):"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import logging",
            "import os",
            "import struct",
            "from datetime import datetime",
            "from typing import TYPE_CHECKING, Collection, Iterable",
            "",
            "from sqlalchemy import BigInteger, Column, String, Text, delete, select",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.sql.expression import literal",
            "",
            "from airflow.exceptions import AirflowException, DagCodeNotFound",
            "from airflow.models.base import Base",
            "from airflow.utils import timezone",
            "from airflow.utils.file import correct_maybe_zipped, open_maybe_zipped",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import UtcDateTime",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class DagCode(Base):",
            "    \"\"\"A table for DAGs code.",
            "",
            "    dag_code table contains code of DAG files synchronized by scheduler.",
            "",
            "    For details on dag serialization see SerializedDagModel",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_code\"",
            "",
            "    fileloc_hash = Column(BigInteger, nullable=False, primary_key=True, autoincrement=False)",
            "    fileloc = Column(String(2000), nullable=False)",
            "    # The max length of fileloc exceeds the limit of indexing.",
            "    last_updated = Column(UtcDateTime, nullable=False)",
            "    source_code = Column(Text().with_variant(MEDIUMTEXT(), \"mysql\"), nullable=False)",
            "",
            "    def __init__(self, full_filepath: str, source_code: str | None = None):",
            "        self.fileloc = full_filepath",
            "        self.fileloc_hash = DagCode.dag_fileloc_hash(self.fileloc)",
            "        self.last_updated = timezone.utcnow()",
            "        self.source_code = source_code or DagCode.code(self.fileloc)",
            "",
            "    @provide_session",
            "    def sync_to_db(self, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"Write code into database.",
            "",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        self.bulk_sync_to_db([self.fileloc], session)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_sync_to_db(cls, filelocs: Iterable[str], session: Session = NEW_SESSION) -> None:",
            "        \"\"\"Write code in bulk into database.",
            "",
            "        :param filelocs: file paths of DAGs to sync",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        filelocs = set(filelocs)",
            "        filelocs_to_hashes = {fileloc: DagCode.dag_fileloc_hash(fileloc) for fileloc in filelocs}",
            "        existing_orm_dag_codes = session.scalars(",
            "            select(DagCode)",
            "            .filter(DagCode.fileloc_hash.in_(filelocs_to_hashes.values()))",
            "            .with_for_update(of=DagCode)",
            "        ).all()",
            "",
            "        if existing_orm_dag_codes:",
            "            existing_orm_dag_codes_map = {",
            "                orm_dag_code.fileloc: orm_dag_code for orm_dag_code in existing_orm_dag_codes",
            "            }",
            "        else:",
            "            existing_orm_dag_codes_map = {}",
            "",
            "        existing_orm_dag_codes_by_fileloc_hashes = {orm.fileloc_hash: orm for orm in existing_orm_dag_codes}",
            "        existing_orm_filelocs = {orm.fileloc for orm in existing_orm_dag_codes_by_fileloc_hashes.values()}",
            "        if not existing_orm_filelocs.issubset(filelocs):",
            "            conflicting_filelocs = existing_orm_filelocs.difference(filelocs)",
            "            hashes_to_filelocs = {DagCode.dag_fileloc_hash(fileloc): fileloc for fileloc in filelocs}",
            "            message = \"\"",
            "            for fileloc in conflicting_filelocs:",
            "                filename = hashes_to_filelocs[DagCode.dag_fileloc_hash(fileloc)]",
            "                message += (",
            "                    f\"Filename '{filename}' causes a hash collision in the \"",
            "                    f\"database with '{fileloc}'. Please rename the file.\"",
            "                )",
            "            raise AirflowException(message)",
            "",
            "        existing_filelocs = {dag_code.fileloc for dag_code in existing_orm_dag_codes}",
            "        missing_filelocs = filelocs.difference(existing_filelocs)",
            "",
            "        for fileloc in missing_filelocs:",
            "            orm_dag_code = DagCode(fileloc, cls._get_code_from_file(fileloc))",
            "            session.add(orm_dag_code)",
            "",
            "        for fileloc in existing_filelocs:",
            "            current_version = existing_orm_dag_codes_by_fileloc_hashes[filelocs_to_hashes[fileloc]]",
            "            file_mod_time = datetime.fromtimestamp(",
            "                os.path.getmtime(correct_maybe_zipped(fileloc)), tz=timezone.utc",
            "            )",
            "",
            "            if file_mod_time > current_version.last_updated:",
            "                orm_dag_code = existing_orm_dag_codes_map[fileloc]",
            "                orm_dag_code.last_updated = file_mod_time",
            "                orm_dag_code.source_code = cls._get_code_from_file(orm_dag_code.fileloc)",
            "                session.merge(orm_dag_code)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def remove_deleted_code(",
            "        cls,",
            "        alive_dag_filelocs: Collection[str],",
            "        processor_subdir: str,",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"Delete code not included in alive_dag_filelocs.",
            "",
            "        :param alive_dag_filelocs: file paths of alive DAGs",
            "        :param processor_subdir: dag processor subdir",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        alive_fileloc_hashes = [cls.dag_fileloc_hash(fileloc) for fileloc in alive_dag_filelocs]",
            "",
            "        log.debug(\"Deleting code from %s table \", cls.__tablename__)",
            "",
            "        session.execute(",
            "            delete(cls)",
            "            .where(",
            "                cls.fileloc_hash.notin_(alive_fileloc_hashes),",
            "                cls.fileloc.notin_(alive_dag_filelocs),",
            "                cls.fileloc.contains(processor_subdir),",
            "            )",
            "            .execution_options(synchronize_session=\"fetch\")",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def has_dag(cls, fileloc: str, session: Session = NEW_SESSION) -> bool:",
            "        \"\"\"Check a file exist in dag_code table.",
            "",
            "        :param fileloc: the file to check",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        fileloc_hash = cls.dag_fileloc_hash(fileloc)",
            "        return (",
            "            session.scalars(select(literal(True)).where(cls.fileloc_hash == fileloc_hash)).one_or_none()",
            "            is not None",
            "        )",
            "",
            "    @classmethod",
            "    def get_code_by_fileloc(cls, fileloc: str) -> str:",
            "        \"\"\"Return source code for a given fileloc.",
            "",
            "        :param fileloc: file path of a DAG",
            "        :return: source code as string",
            "        \"\"\"",
            "        return cls.code(fileloc)",
            "",
            "    @classmethod",
            "    def code(cls, fileloc) -> str:",
            "        \"\"\"Return source code for this DagCode object.",
            "",
            "        :return: source code as string",
            "        \"\"\"",
            "        return cls._get_code_from_db(fileloc)",
            "",
            "    @staticmethod",
            "    def _get_code_from_file(fileloc):",
            "        with open_maybe_zipped(fileloc, \"r\") as f:",
            "            code = f.read()",
            "        return code",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def _get_code_from_db(cls, fileloc, session: Session = NEW_SESSION) -> str:",
            "        dag_code = session.scalar(select(cls).where(cls.fileloc_hash == cls.dag_fileloc_hash(fileloc)))",
            "        if not dag_code:",
            "            raise DagCodeNotFound()",
            "        else:",
            "            code = dag_code.source_code",
            "        return code",
            "",
            "    @staticmethod",
            "    def dag_fileloc_hash(full_filepath: str) -> int:",
            "        \"\"\"Hashing file location for indexing.",
            "",
            "        :param full_filepath: full filepath of DAG file",
            "        :return: hashed full_filepath",
            "        \"\"\"",
            "        # Hashing is needed because the length of fileloc is 2000 as an Airflow convention,",
            "        # which is over the limit of indexing.",
            "        import hashlib",
            "",
            "        # Only 7 bytes because MySQL BigInteger can hold only 8 bytes (signed).",
            "        return struct.unpack(\">Q\", hashlib.sha1(full_filepath.encode(\"utf-8\")).digest()[-8:])[0] >> 8"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import annotations",
            "",
            "import logging",
            "import os",
            "import struct",
            "from datetime import datetime",
            "from typing import TYPE_CHECKING, Collection, Iterable",
            "",
            "from sqlalchemy import BigInteger, Column, String, Text, delete, select",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.sql.expression import literal",
            "",
            "from airflow.exceptions import AirflowException, DagCodeNotFound",
            "from airflow.models.base import Base",
            "from airflow.utils import timezone",
            "from airflow.utils.file import correct_maybe_zipped, open_maybe_zipped",
            "from airflow.utils.session import NEW_SESSION, provide_session",
            "from airflow.utils.sqlalchemy import UtcDateTime",
            "",
            "if TYPE_CHECKING:",
            "    from sqlalchemy.orm import Session",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "class DagCode(Base):",
            "    \"\"\"A table for DAGs code.",
            "",
            "    dag_code table contains code of DAG files synchronized by scheduler.",
            "",
            "    For details on dag serialization see SerializedDagModel",
            "    \"\"\"",
            "",
            "    __tablename__ = \"dag_code\"",
            "",
            "    fileloc_hash = Column(BigInteger, nullable=False, primary_key=True, autoincrement=False)",
            "    fileloc = Column(String(2000), nullable=False)",
            "    # The max length of fileloc exceeds the limit of indexing.",
            "    last_updated = Column(UtcDateTime, nullable=False)",
            "    source_code = Column(Text().with_variant(MEDIUMTEXT(), \"mysql\"), nullable=False)",
            "",
            "    def __init__(self, full_filepath: str, source_code: str | None = None):",
            "        self.fileloc = full_filepath",
            "        self.fileloc_hash = DagCode.dag_fileloc_hash(self.fileloc)",
            "        self.last_updated = timezone.utcnow()",
            "        self.source_code = source_code or DagCode.code(self.fileloc)",
            "",
            "    @provide_session",
            "    def sync_to_db(self, session: Session = NEW_SESSION) -> None:",
            "        \"\"\"Write code into database.",
            "",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        self.bulk_sync_to_db([self.fileloc], session)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def bulk_sync_to_db(cls, filelocs: Iterable[str], session: Session = NEW_SESSION) -> None:",
            "        \"\"\"Write code in bulk into database.",
            "",
            "        :param filelocs: file paths of DAGs to sync",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        filelocs = set(filelocs)",
            "        filelocs_to_hashes = {fileloc: DagCode.dag_fileloc_hash(fileloc) for fileloc in filelocs}",
            "        existing_orm_dag_codes = session.scalars(",
            "            select(DagCode)",
            "            .filter(DagCode.fileloc_hash.in_(filelocs_to_hashes.values()))",
            "            .with_for_update(of=DagCode)",
            "        ).all()",
            "",
            "        if existing_orm_dag_codes:",
            "            existing_orm_dag_codes_map = {",
            "                orm_dag_code.fileloc: orm_dag_code for orm_dag_code in existing_orm_dag_codes",
            "            }",
            "        else:",
            "            existing_orm_dag_codes_map = {}",
            "",
            "        existing_orm_dag_codes_by_fileloc_hashes = {orm.fileloc_hash: orm for orm in existing_orm_dag_codes}",
            "        existing_orm_filelocs = {orm.fileloc for orm in existing_orm_dag_codes_by_fileloc_hashes.values()}",
            "        if not existing_orm_filelocs.issubset(filelocs):",
            "            conflicting_filelocs = existing_orm_filelocs.difference(filelocs)",
            "            hashes_to_filelocs = {DagCode.dag_fileloc_hash(fileloc): fileloc for fileloc in filelocs}",
            "            message = \"\"",
            "            for fileloc in conflicting_filelocs:",
            "                filename = hashes_to_filelocs[DagCode.dag_fileloc_hash(fileloc)]",
            "                message += (",
            "                    f\"Filename '{filename}' causes a hash collision in the \"",
            "                    f\"database with '{fileloc}'. Please rename the file.\"",
            "                )",
            "            raise AirflowException(message)",
            "",
            "        existing_filelocs = {dag_code.fileloc for dag_code in existing_orm_dag_codes}",
            "        missing_filelocs = filelocs.difference(existing_filelocs)",
            "",
            "        for fileloc in missing_filelocs:",
            "            orm_dag_code = DagCode(fileloc, cls._get_code_from_file(fileloc))",
            "            session.add(orm_dag_code)",
            "",
            "        for fileloc in existing_filelocs:",
            "            current_version = existing_orm_dag_codes_by_fileloc_hashes[filelocs_to_hashes[fileloc]]",
            "            file_mod_time = datetime.fromtimestamp(",
            "                os.path.getmtime(correct_maybe_zipped(fileloc)), tz=timezone.utc",
            "            )",
            "",
            "            if file_mod_time > current_version.last_updated:",
            "                orm_dag_code = existing_orm_dag_codes_map[fileloc]",
            "                orm_dag_code.last_updated = file_mod_time",
            "                orm_dag_code.source_code = cls._get_code_from_file(orm_dag_code.fileloc)",
            "                session.merge(orm_dag_code)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def remove_deleted_code(",
            "        cls,",
            "        alive_dag_filelocs: Collection[str],",
            "        processor_subdir: str,",
            "        session: Session = NEW_SESSION,",
            "    ) -> None:",
            "        \"\"\"Delete code not included in alive_dag_filelocs.",
            "",
            "        :param alive_dag_filelocs: file paths of alive DAGs",
            "        :param processor_subdir: dag processor subdir",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        alive_fileloc_hashes = [cls.dag_fileloc_hash(fileloc) for fileloc in alive_dag_filelocs]",
            "",
            "        log.debug(\"Deleting code from %s table \", cls.__tablename__)",
            "",
            "        session.execute(",
            "            delete(cls)",
            "            .where(",
            "                cls.fileloc_hash.notin_(alive_fileloc_hashes),",
            "                cls.fileloc.notin_(alive_dag_filelocs),",
            "                cls.fileloc.contains(processor_subdir),",
            "            )",
            "            .execution_options(synchronize_session=\"fetch\")",
            "        )",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def has_dag(cls, fileloc: str, session: Session = NEW_SESSION) -> bool:",
            "        \"\"\"Check a file exist in dag_code table.",
            "",
            "        :param fileloc: the file to check",
            "        :param session: ORM Session",
            "        \"\"\"",
            "        fileloc_hash = cls.dag_fileloc_hash(fileloc)",
            "        return (",
            "            session.scalars(select(literal(True)).where(cls.fileloc_hash == fileloc_hash)).one_or_none()",
            "            is not None",
            "        )",
            "",
            "    @classmethod",
            "    def get_code_by_fileloc(cls, fileloc: str) -> str:",
            "        \"\"\"Return source code for a given fileloc.",
            "",
            "        :param fileloc: file path of a DAG",
            "        :return: source code as string",
            "        \"\"\"",
            "        return cls.code(fileloc)",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def code(cls, fileloc, session: Session = NEW_SESSION) -> str:",
            "        \"\"\"Return source code for this DagCode object.",
            "",
            "        :return: source code as string",
            "        \"\"\"",
            "        return cls._get_code_from_db(fileloc, session)",
            "",
            "    @staticmethod",
            "    def _get_code_from_file(fileloc):",
            "        with open_maybe_zipped(fileloc, \"r\") as f:",
            "            code = f.read()",
            "        return code",
            "",
            "    @classmethod",
            "    @provide_session",
            "    def _get_code_from_db(cls, fileloc, session: Session = NEW_SESSION) -> str:",
            "        dag_code = session.scalar(select(cls).where(cls.fileloc_hash == cls.dag_fileloc_hash(fileloc)))",
            "        if not dag_code:",
            "            raise DagCodeNotFound()",
            "        else:",
            "            code = dag_code.source_code",
            "        return code",
            "",
            "    @staticmethod",
            "    def dag_fileloc_hash(full_filepath: str) -> int:",
            "        \"\"\"Hashing file location for indexing.",
            "",
            "        :param full_filepath: full filepath of DAG file",
            "        :return: hashed full_filepath",
            "        \"\"\"",
            "        # Hashing is needed because the length of fileloc is 2000 as an Airflow convention,",
            "        # which is over the limit of indexing.",
            "        import hashlib",
            "",
            "        # Only 7 bytes because MySQL BigInteger can hold only 8 bytes (signed).",
            "        return struct.unpack(\">Q\", hashlib.sha1(full_filepath.encode(\"utf-8\")).digest()[-8:])[0] >> 8"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "180": [
                "DagCode",
                "code"
            ],
            "185": [
                "DagCode",
                "code"
            ]
        },
        "addLocation": []
    }
}