{
    "qutebrowser/browser/browsertab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 737,
                "afterPatchRowNumber": 737,
                "PatchRowcode": "     renderer_process_terminated = pyqtSignal(TerminationStatus, int)"
            },
            "1": {
                "beforePatchRowNumber": 738,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "     predicted_navigation = pyqtSignal(QUrl)"
            },
            "2": {
                "beforePatchRowNumber": 739,
                "afterPatchRowNumber": 739,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 740,
                "PatchRowcode": "+    # Hosts for which a certificate error happened. Shared between all tabs."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 741,
                "PatchRowcode": "+    #"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 742,
                "PatchRowcode": "+    # Note that we remember hosts here, without scheme/port:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 743,
                "PatchRowcode": "+    # QtWebEngine/Chromium also only remembers hostnames, and certificates are"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 744,
                "PatchRowcode": "+    # for a given hostname anyways."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 745,
                "PatchRowcode": "+    _insecure_hosts = set()  # type: typing.Set[str]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 746,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 740,
                "afterPatchRowNumber": 747,
                "PatchRowcode": "     def __init__(self, *, win_id, mode_manager, private, parent=None):"
            },
            "11": {
                "beforePatchRowNumber": 741,
                "afterPatchRowNumber": 748,
                "PatchRowcode": "         self.private = private"
            },
            "12": {
                "beforePatchRowNumber": 742,
                "afterPatchRowNumber": 749,
                "PatchRowcode": "         self.win_id = win_id"
            },
            "13": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": 760,
                "PatchRowcode": "         self._layout = miscwidgets.WrapperLayout(self)"
            },
            "14": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": 761,
                "PatchRowcode": "         self._widget = None"
            },
            "15": {
                "beforePatchRowNumber": 755,
                "afterPatchRowNumber": 762,
                "PatchRowcode": "         self._progress = 0"
            },
            "16": {
                "beforePatchRowNumber": 756,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._has_ssl_errors = False"
            },
            "17": {
                "beforePatchRowNumber": 757,
                "afterPatchRowNumber": 763,
                "PatchRowcode": "         self._mode_manager = mode_manager"
            },
            "18": {
                "beforePatchRowNumber": 758,
                "afterPatchRowNumber": 764,
                "PatchRowcode": "         self._load_status = usertypes.LoadStatus.none"
            },
            "19": {
                "beforePatchRowNumber": 759,
                "afterPatchRowNumber": 765,
                "PatchRowcode": "         self._mouse_event_filter = mouse.MouseEventFilter("
            },
            "20": {
                "beforePatchRowNumber": 840,
                "afterPatchRowNumber": 846,
                "PatchRowcode": "     @pyqtSlot()"
            },
            "21": {
                "beforePatchRowNumber": 841,
                "afterPatchRowNumber": 847,
                "PatchRowcode": "     def _on_load_started(self):"
            },
            "22": {
                "beforePatchRowNumber": 842,
                "afterPatchRowNumber": 848,
                "PatchRowcode": "         self._progress = 0"
            },
            "23": {
                "beforePatchRowNumber": 843,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._has_ssl_errors = False"
            },
            "24": {
                "beforePatchRowNumber": 844,
                "afterPatchRowNumber": 849,
                "PatchRowcode": "         self.data.viewing_source = False"
            },
            "25": {
                "beforePatchRowNumber": 845,
                "afterPatchRowNumber": 850,
                "PatchRowcode": "         self._set_load_status(usertypes.LoadStatus.loading)"
            },
            "26": {
                "beforePatchRowNumber": 846,
                "afterPatchRowNumber": 851,
                "PatchRowcode": "         self.load_started.emit()"
            },
            "27": {
                "beforePatchRowNumber": 899,
                "afterPatchRowNumber": 904,
                "PatchRowcode": "         sess_manager = objreg.get('session-manager')"
            },
            "28": {
                "beforePatchRowNumber": 900,
                "afterPatchRowNumber": 905,
                "PatchRowcode": "         sess_manager.save_autosave()"
            },
            "29": {
                "beforePatchRowNumber": 901,
                "afterPatchRowNumber": 906,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 902,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if ok and not self._has_ssl_errors:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 907,
                "PatchRowcode": "+        if ok:"
            },
            "32": {
                "beforePatchRowNumber": 903,
                "afterPatchRowNumber": 908,
                "PatchRowcode": "             if self.url().scheme() == 'https':"
            },
            "33": {
                "beforePatchRowNumber": 904,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._set_load_status(usertypes.LoadStatus.success_https)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 909,
                "PatchRowcode": "+                if self.url().host() in self._insecure_hosts:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 910,
                "PatchRowcode": "+                    self._set_load_status(usertypes.LoadStatus.warn)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+                else:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 912,
                "PatchRowcode": "+                    self._set_load_status(usertypes.LoadStatus.success_https)"
            },
            "38": {
                "beforePatchRowNumber": 905,
                "afterPatchRowNumber": 913,
                "PatchRowcode": "             else:"
            },
            "39": {
                "beforePatchRowNumber": 906,
                "afterPatchRowNumber": 914,
                "PatchRowcode": "                 self._set_load_status(usertypes.LoadStatus.success)"
            },
            "40": {
                "beforePatchRowNumber": 907,
                "afterPatchRowNumber": 915,
                "PatchRowcode": "         elif ok:"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Base class for a wrapper over QWebView/QWebEngineView.\"\"\"",
            "",
            "import enum",
            "import itertools",
            "",
            "import attr",
            "from PyQt5.QtCore import pyqtSignal, pyqtSlot, QUrl, QObject, QSizeF, Qt",
            "from PyQt5.QtGui import QIcon",
            "from PyQt5.QtWidgets import QWidget, QApplication, QDialog",
            "from PyQt5.QtPrintSupport import QPrintDialog",
            "",
            "import pygments",
            "import pygments.lexers",
            "import pygments.formatters",
            "",
            "from qutebrowser.keyinput import modeman",
            "from qutebrowser.config import config",
            "from qutebrowser.utils import (utils, objreg, usertypes, log, qtutils,",
            "                               urlutils, message)",
            "from qutebrowser.misc import miscwidgets, objects",
            "from qutebrowser.browser import mouse, hints",
            "from qutebrowser.qt import sip",
            "",
            "",
            "tab_id_gen = itertools.count(0)",
            "",
            "",
            "def create(win_id, private, parent=None):",
            "    \"\"\"Get a QtWebKit/QtWebEngine tab object.",
            "",
            "    Args:",
            "        win_id: The window ID where the tab will be shown.",
            "        private: Whether the tab is a private/off the record tab.",
            "        parent: The Qt parent to set.",
            "    \"\"\"",
            "    # Importing modules here so we don't depend on QtWebEngine without the",
            "    # argument and to avoid circular imports.",
            "    mode_manager = modeman.instance(win_id)",
            "    if objects.backend == usertypes.Backend.QtWebEngine:",
            "        from qutebrowser.browser.webengine import webenginetab",
            "        tab_class = webenginetab.WebEngineTab",
            "    else:",
            "        from qutebrowser.browser.webkit import webkittab",
            "        tab_class = webkittab.WebKitTab",
            "    return tab_class(win_id=win_id, mode_manager=mode_manager, private=private,",
            "                     parent=parent)",
            "",
            "",
            "def init():",
            "    \"\"\"Initialize backend-specific modules.\"\"\"",
            "    if objects.backend == usertypes.Backend.QtWebEngine:",
            "        from qutebrowser.browser.webengine import webenginetab",
            "        webenginetab.init()",
            "",
            "",
            "class WebTabError(Exception):",
            "",
            "    \"\"\"Base class for various errors.\"\"\"",
            "",
            "",
            "class UnsupportedOperationError(WebTabError):",
            "",
            "    \"\"\"Raised when an operation is not supported with the given backend.\"\"\"",
            "",
            "",
            "TerminationStatus = enum.Enum('TerminationStatus', [",
            "    'normal',",
            "    'abnormal',  # non-zero exit status",
            "    'crashed',   # e.g. segfault",
            "    'killed',",
            "    'unknown',",
            "])",
            "",
            "",
            "@attr.s",
            "class TabData:",
            "",
            "    \"\"\"A simple namespace with a fixed set of attributes.",
            "",
            "    Attributes:",
            "        keep_icon: Whether the (e.g. cloned) icon should not be cleared on page",
            "                   load.",
            "        inspector: The QWebInspector used for this webview.",
            "        viewing_source: Set if we're currently showing a source view.",
            "                        Only used when sources are shown via pygments.",
            "        open_target: Where to open the next link.",
            "                     Only used for QtWebKit.",
            "        override_target: Override for open_target for fake clicks (like hints).",
            "                         Only used for QtWebKit.",
            "        pinned: Flag to pin the tab.",
            "        fullscreen: Whether the tab has a video shown fullscreen currently.",
            "        netrc_used: Whether netrc authentication was performed.",
            "        input_mode: current input mode for the tab.",
            "    \"\"\"",
            "",
            "    keep_icon = attr.ib(False)",
            "    viewing_source = attr.ib(False)",
            "    inspector = attr.ib(None)",
            "    open_target = attr.ib(usertypes.ClickTarget.normal)",
            "    override_target = attr.ib(None)",
            "    pinned = attr.ib(False)",
            "    fullscreen = attr.ib(False)",
            "    netrc_used = attr.ib(False)",
            "    input_mode = attr.ib(usertypes.KeyMode.normal)",
            "",
            "    def should_show_icon(self):",
            "        return (config.val.tabs.favicons.show == 'always' or",
            "                config.val.tabs.favicons.show == 'pinned' and self.pinned)",
            "",
            "",
            "class AbstractAction:",
            "",
            "    \"\"\"Attribute of AbstractTab for Qt WebActions.",
            "",
            "    Class attributes (overridden by subclasses):",
            "        action_class: The class actions are defined on (QWeb{Engine,}Page)",
            "        action_base: The type of the actions (QWeb{Engine,}Page.WebAction)",
            "    \"\"\"",
            "",
            "    action_class = None",
            "    action_base = None",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def exit_fullscreen(self):",
            "        \"\"\"Exit the fullscreen mode.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def run_string(self, name):",
            "        \"\"\"Run a webaction based on its name.\"\"\"",
            "        member = getattr(self.action_class, name, None)",
            "        if not isinstance(member, self.action_base):",
            "            raise WebTabError(\"{} is not a valid web action!\".format(name))",
            "        self._widget.triggerPageAction(member)",
            "",
            "    def show_source(self,",
            "                    pygments=False):  # pylint: disable=redefined-outer-name",
            "        \"\"\"Show the source of the current page in a new tab.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def _show_source_pygments(self):",
            "",
            "        def show_source_cb(source):",
            "            \"\"\"Show source as soon as it's ready.\"\"\"",
            "            # WORKAROUND for https://github.com/PyCQA/pylint/issues/491",
            "            # pylint: disable=no-member",
            "            lexer = pygments.lexers.HtmlLexer()",
            "            formatter = pygments.formatters.HtmlFormatter(",
            "                full=True, linenos='table')",
            "            # pylint: enable=no-member",
            "            highlighted = pygments.highlight(source, lexer, formatter)",
            "",
            "            tb = objreg.get('tabbed-browser', scope='window',",
            "                            window=self._tab.win_id)",
            "            new_tab = tb.tabopen(background=False, related=True)",
            "            new_tab.set_html(highlighted, self._tab.url())",
            "            new_tab.data.viewing_source = True",
            "",
            "        self._tab.dump_async(show_source_cb)",
            "",
            "",
            "class AbstractPrinting:",
            "",
            "    \"\"\"Attribute of AbstractTab for printing the page.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def check_pdf_support(self):",
            "        raise NotImplementedError",
            "",
            "    def check_printer_support(self):",
            "        raise NotImplementedError",
            "",
            "    def check_preview_support(self):",
            "        raise NotImplementedError",
            "",
            "    def to_pdf(self, filename):",
            "        raise NotImplementedError",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        \"\"\"Print the tab.",
            "",
            "        Args:",
            "            printer: The QPrinter to print to.",
            "            callback: Called with a boolean",
            "                      (True if printing succeeded, False otherwise)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def show_dialog(self):",
            "        \"\"\"Print with a QPrintDialog.\"\"\"",
            "        self.check_printer_support()",
            "",
            "        def print_callback(ok):",
            "            \"\"\"Called when printing finished.\"\"\"",
            "            if not ok:",
            "                message.error(\"Printing failed!\")",
            "            diag.deleteLater()",
            "",
            "        def do_print():",
            "            \"\"\"Called when the dialog was closed.\"\"\"",
            "            self.to_printer(diag.printer(), print_callback)",
            "",
            "        diag = QPrintDialog(self._tab)",
            "        if utils.is_mac:",
            "            # For some reason we get a segfault when using open() on macOS",
            "            ret = diag.exec_()",
            "            if ret == QDialog.Accepted:",
            "                do_print()",
            "        else:",
            "            diag.open(do_print)",
            "",
            "",
            "class AbstractSearch(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for doing searches.",
            "",
            "    Attributes:",
            "        text: The last thing this view was searched for.",
            "        search_displayed: Whether we're currently displaying search results in",
            "                          this view.",
            "        _flags: The flags of the last search (needs to be set by subclasses).",
            "        _widget: The underlying WebView widget.",
            "    \"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._widget = None",
            "        self.text = None",
            "        self.search_displayed = False",
            "",
            "    def _is_case_sensitive(self, ignore_case):",
            "        \"\"\"Check if case-sensitivity should be used.",
            "",
            "        This assumes self.text is already set properly.",
            "",
            "        Arguments:",
            "            ignore_case: The ignore_case value from the config.",
            "        \"\"\"",
            "        mapping = {",
            "            'smart': not self.text.islower(),",
            "            'never': True,",
            "            'always': False,",
            "        }",
            "        return mapping[ignore_case]",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        \"\"\"Find the given text on the page.",
            "",
            "        Args:",
            "            text: The text to search for.",
            "            ignore_case: Search case-insensitively. ('always'/'never/'smart')",
            "            reverse: Reverse search direction.",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def clear(self):",
            "        \"\"\"Clear the current search.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        \"\"\"Go to the previous result of the current search.",
            "",
            "        Args:",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        \"\"\"Go to the next result of the current search.",
            "",
            "        Args:",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractZoom(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for controlling zoom.",
            "",
            "    Attributes:",
            "        _neighborlist: A NeighborList with the zoom levels.",
            "        _default_zoom_changed: Whether the zoom was changed from the default.",
            "    \"\"\"",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self._default_zoom_changed = False",
            "        self._init_neighborlist()",
            "        config.instance.changed.connect(self._on_config_changed)",
            "        self._zoom_factor = float(config.val.zoom.default) / 100",
            "",
            "        # # FIXME:qtwebengine is this needed?",
            "        # # For some reason, this signal doesn't get disconnected automatically",
            "        # # when the WebView is destroyed on older PyQt versions.",
            "        # # See https://github.com/qutebrowser/qutebrowser/issues/390",
            "        # self.destroyed.connect(functools.partial(",
            "        #     cfg.changed.disconnect, self.init_neighborlist))",
            "",
            "    @pyqtSlot(str)",
            "    def _on_config_changed(self, option):",
            "        if option in ['zoom.levels', 'zoom.default']:",
            "            if not self._default_zoom_changed:",
            "                factor = float(config.val.zoom.default) / 100",
            "                self.set_factor(factor)",
            "            self._init_neighborlist()",
            "",
            "    def _init_neighborlist(self):",
            "        \"\"\"Initialize self._neighborlist.\"\"\"",
            "        levels = config.val.zoom.levels",
            "        self._neighborlist = usertypes.NeighborList(",
            "            levels, mode=usertypes.NeighborList.Modes.edge)",
            "        self._neighborlist.fuzzyval = config.val.zoom.default",
            "",
            "    def offset(self, offset):",
            "        \"\"\"Increase/Decrease the zoom level by the given offset.",
            "",
            "        Args:",
            "            offset: The offset in the zoom level list.",
            "",
            "        Return:",
            "            The new zoom percentage.",
            "        \"\"\"",
            "        level = self._neighborlist.getitem(offset)",
            "        self.set_factor(float(level) / 100, fuzzyval=False)",
            "        return level",
            "",
            "    def _set_factor_internal(self, factor):",
            "        raise NotImplementedError",
            "",
            "    def set_factor(self, factor, *, fuzzyval=True):",
            "        \"\"\"Zoom to a given zoom factor.",
            "",
            "        Args:",
            "            factor: The zoom factor as float.",
            "            fuzzyval: Whether to set the NeighborLists fuzzyval.",
            "        \"\"\"",
            "        if fuzzyval:",
            "            self._neighborlist.fuzzyval = int(factor * 100)",
            "        if factor < 0:",
            "            raise ValueError(\"Can't zoom to factor {}!\".format(factor))",
            "",
            "        default_zoom_factor = float(config.val.zoom.default) / 100",
            "        self._default_zoom_changed = (factor != default_zoom_factor)",
            "",
            "        self._zoom_factor = factor",
            "        self._set_factor_internal(factor)",
            "",
            "    def factor(self):",
            "        return self._zoom_factor",
            "",
            "    def set_default(self):",
            "        self._set_factor_internal(float(config.val.zoom.default) / 100)",
            "",
            "    def set_current(self):",
            "        self._set_factor_internal(self._zoom_factor)",
            "",
            "",
            "class AbstractCaret(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for caret browsing.",
            "",
            "    Signals:",
            "        selection_toggled: Emitted when the selection was toggled.",
            "                           arg: Whether the selection is now active.",
            "    \"\"\"",
            "",
            "    selection_toggled = pyqtSignal(bool)",
            "",
            "    def __init__(self, tab, mode_manager, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self.selection_enabled = False",
            "        mode_manager.entered.connect(self._on_mode_entered)",
            "        mode_manager.left.connect(self._on_mode_left)",
            "",
            "    def _on_mode_entered(self, mode):",
            "        raise NotImplementedError",
            "",
            "    def _on_mode_left(self, mode):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_line(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_char(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_line(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_line(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_document(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_document(self):",
            "        raise NotImplementedError",
            "",
            "    def toggle_selection(self):",
            "        raise NotImplementedError",
            "",
            "    def drop_selection(self):",
            "        raise NotImplementedError",
            "",
            "    def selection(self, callback):",
            "        raise NotImplementedError",
            "",
            "    def _follow_enter(self, tab):",
            "        \"\"\"Follow a link by faking an enter press.\"\"\"",
            "        if tab:",
            "            self._tab.key_press(Qt.Key_Enter, modifier=Qt.ControlModifier)",
            "        else:",
            "            self._tab.key_press(Qt.Key_Enter)",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractScroller(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab to manage scroll position.\"\"\"",
            "",
            "    perc_changed = pyqtSignal(int, int)",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self.perc_changed.connect(self._log_scroll_pos_change)",
            "",
            "    @pyqtSlot()",
            "    def _log_scroll_pos_change(self):",
            "        log.webview.vdebug(\"Scroll position changed to {}\".format(",
            "            self.pos_px()))",
            "",
            "    def _init_widget(self, widget):",
            "        self._widget = widget",
            "",
            "    def pos_px(self):",
            "        raise NotImplementedError",
            "",
            "    def pos_perc(self):",
            "        raise NotImplementedError",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        raise NotImplementedError",
            "",
            "    def to_point(self, point):",
            "        raise NotImplementedError",
            "",
            "    def to_anchor(self, name):",
            "        raise NotImplementedError",
            "",
            "    def delta(self, x=0, y=0):",
            "        raise NotImplementedError",
            "",
            "    def delta_page(self, x=0, y=0):",
            "        raise NotImplementedError",
            "",
            "    def up(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def down(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def left(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def right(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def top(self):",
            "        raise NotImplementedError",
            "",
            "    def bottom(self):",
            "        raise NotImplementedError",
            "",
            "    def page_up(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def page_down(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def at_top(self):",
            "        raise NotImplementedError",
            "",
            "    def at_bottom(self):",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractHistory:",
            "",
            "    \"\"\"The history attribute of a AbstractTab.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._tab = tab",
            "        self._history = None",
            "",
            "    def __len__(self):",
            "        return len(self._history)",
            "",
            "    def __iter__(self):",
            "        return iter(self._history.items())",
            "",
            "    def current_idx(self):",
            "        raise NotImplementedError",
            "",
            "    def back(self, count=1):",
            "        \"\"\"Go back in the tab's history.\"\"\"",
            "        idx = self.current_idx() - count",
            "        if idx >= 0:",
            "            self._go_to_item(self._item_at(idx))",
            "        else:",
            "            self._go_to_item(self._item_at(0))",
            "            raise WebTabError(\"At beginning of history.\")",
            "",
            "    def forward(self, count=1):",
            "        \"\"\"Go forward in the tab's history.\"\"\"",
            "        idx = self.current_idx() + count",
            "        if idx < len(self):",
            "            self._go_to_item(self._item_at(idx))",
            "        else:",
            "            self._go_to_item(self._item_at(len(self) - 1))",
            "            raise WebTabError(\"At end of history.\")",
            "",
            "    def can_go_back(self):",
            "        raise NotImplementedError",
            "",
            "    def can_go_forward(self):",
            "        raise NotImplementedError",
            "",
            "    def _item_at(self, i):",
            "        raise NotImplementedError",
            "",
            "    def _go_to_item(self, item):",
            "        raise NotImplementedError",
            "",
            "    def serialize(self):",
            "        \"\"\"Serialize into an opaque format understood by self.deserialize.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def deserialize(self, data):",
            "        \"\"\"Serialize from a format produced by self.serialize.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_items(self, items):",
            "        \"\"\"Deserialize from a list of WebHistoryItems.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractElements:",
            "",
            "    \"\"\"Finding and handling of elements on the page.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        \"\"\"Find all HTML elements matching a given selector async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "            selector: The CSS selector to search for.",
            "            only_visible: Only show elements which are visible on screen.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_id(self, elem_id, callback):",
            "        \"\"\"Find the HTML element with the given ID async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "            elem_id: The ID to search for.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_focused(self, callback):",
            "        \"\"\"Find the focused element on the page async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "                      Called with a WebEngineElement or None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        \"\"\"Find the element at the given position async.",
            "",
            "        This is also called \"hit test\" elsewhere.",
            "",
            "        Args:",
            "            pos: The QPoint to get the element for.",
            "            callback: The callback to be called when the search finished.",
            "                      Called with a WebEngineElement or None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractAudio(QObject):",
            "",
            "    \"\"\"Handling of audio/muting for this tab.\"\"\"",
            "",
            "    muted_changed = pyqtSignal(bool)",
            "    recently_audible_changed = pyqtSignal(bool)",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._widget = None",
            "",
            "    def set_muted(self, muted: bool):",
            "        \"\"\"Set this tab as muted or not.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_muted(self):",
            "        \"\"\"Whether this tab is muted.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def toggle_muted(self):",
            "        self.set_muted(not self.is_muted())",
            "",
            "    def is_recently_audible(self):",
            "        \"\"\"Whether this tab has had audio playing recently.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractTab(QWidget):",
            "",
            "    \"\"\"A wrapper over the given widget to hide its API and expose another one.",
            "",
            "    We use this to unify QWebView and QWebEngineView.",
            "",
            "    Attributes:",
            "        history: The AbstractHistory for the current tab.",
            "        registry: The ObjectRegistry associated with this tab.",
            "        private: Whether private browsing is turned on for this tab.",
            "",
            "        _load_status: loading status of this page",
            "                      Accessible via load_status() method.",
            "        _has_ssl_errors: Whether SSL errors happened.",
            "                         Needs to be set by subclasses.",
            "",
            "        for properties, see WebView/WebEngineView docs.",
            "",
            "    Signals:",
            "        See related Qt signals.",
            "",
            "        new_tab_requested: Emitted when a new tab should be opened with the",
            "                           given URL.",
            "        load_status_changed: The loading status changed",
            "        fullscreen_requested: Fullscreen display was requested by the page.",
            "                              arg: True if fullscreen should be turned on,",
            "                                   False if it should be turned off.",
            "        renderer_process_terminated: Emitted when the underlying renderer",
            "                                     process terminated.",
            "                                     arg 0: A TerminationStatus member.",
            "                                     arg 1: The exit code.",
            "        predicted_navigation: Emitted before we tell Qt to open a URL.",
            "    \"\"\"",
            "",
            "    window_close_requested = pyqtSignal()",
            "    link_hovered = pyqtSignal(str)",
            "    load_started = pyqtSignal()",
            "    load_progress = pyqtSignal(int)",
            "    load_finished = pyqtSignal(bool)",
            "    icon_changed = pyqtSignal(QIcon)",
            "    title_changed = pyqtSignal(str)",
            "    load_status_changed = pyqtSignal(str)",
            "    new_tab_requested = pyqtSignal(QUrl)",
            "    url_changed = pyqtSignal(QUrl)",
            "    shutting_down = pyqtSignal()",
            "    contents_size_changed = pyqtSignal(QSizeF)",
            "    add_history_item = pyqtSignal(QUrl, QUrl, str)  # url, requested url, title",
            "    fullscreen_requested = pyqtSignal(bool)",
            "    renderer_process_terminated = pyqtSignal(TerminationStatus, int)",
            "    predicted_navigation = pyqtSignal(QUrl)",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        self.private = private",
            "        self.win_id = win_id",
            "        self.tab_id = next(tab_id_gen)",
            "        super().__init__(parent)",
            "",
            "        self.registry = objreg.ObjectRegistry()",
            "        tab_registry = objreg.get('tab-registry', scope='window',",
            "                                  window=win_id)",
            "        tab_registry[self.tab_id] = self",
            "        objreg.register('tab', self, registry=self.registry)",
            "",
            "        self.data = TabData()",
            "        self._layout = miscwidgets.WrapperLayout(self)",
            "        self._widget = None",
            "        self._progress = 0",
            "        self._has_ssl_errors = False",
            "        self._mode_manager = mode_manager",
            "        self._load_status = usertypes.LoadStatus.none",
            "        self._mouse_event_filter = mouse.MouseEventFilter(",
            "            self, parent=self)",
            "        self.backend = None",
            "",
            "        # FIXME:qtwebengine  Should this be public api via self.hints?",
            "        #                    Also, should we get it out of objreg?",
            "        hintmanager = hints.HintManager(win_id, self.tab_id, parent=self)",
            "        objreg.register('hintmanager', hintmanager, scope='tab',",
            "                        window=self.win_id, tab=self.tab_id)",
            "",
            "        self.predicted_navigation.connect(self._on_predicted_navigation)",
            "",
            "    def _set_widget(self, widget):",
            "        # pylint: disable=protected-access",
            "        self._widget = widget",
            "        self._layout.wrap(self, widget)",
            "        self.history._history = widget.history()",
            "        self.scroller._init_widget(widget)",
            "        self.caret._widget = widget",
            "        self.zoom._widget = widget",
            "        self.search._widget = widget",
            "        self.printing._widget = widget",
            "        self.action._widget = widget",
            "        self.elements._widget = widget",
            "        self.audio._widget = widget",
            "        self.settings._settings = widget.settings()",
            "",
            "        self._install_event_filter()",
            "        self.zoom.set_default()",
            "",
            "    def _install_event_filter(self):",
            "        raise NotImplementedError",
            "",
            "    def _set_load_status(self, val):",
            "        \"\"\"Setter for load_status.\"\"\"",
            "        if not isinstance(val, usertypes.LoadStatus):",
            "            raise TypeError(\"Type {} is no LoadStatus member!\".format(val))",
            "        log.webview.debug(\"load status for {}: {}\".format(repr(self), val))",
            "        self._load_status = val",
            "        self.load_status_changed.emit(val.name)",
            "",
            "    def event_target(self):",
            "        \"\"\"Return the widget events should be sent to.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def send_event(self, evt):",
            "        \"\"\"Send the given event to the underlying widget.",
            "",
            "        The event will be sent via QApplication.postEvent.",
            "        Note that a posted event may not be re-used in any way!",
            "        \"\"\"",
            "        # This only gives us some mild protection against re-using events, but",
            "        # it's certainly better than a segfault.",
            "        if getattr(evt, 'posted', False):",
            "            raise utils.Unreachable(\"Can't re-use an event which was already \"",
            "                                    \"posted!\")",
            "",
            "        recipient = self.event_target()",
            "        if recipient is None:",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3888",
            "            log.webview.warning(\"Unable to find event target!\")",
            "            return",
            "",
            "        evt.posted = True",
            "        QApplication.postEvent(recipient, evt)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_predicted_navigation(self, url):",
            "        \"\"\"Adjust the title if we are going to visit an URL soon.\"\"\"",
            "        qtutils.ensure_valid(url)",
            "        url_string = url.toDisplayString()",
            "        log.webview.debug(\"Predicted navigation: {}\".format(url_string))",
            "        self.title_changed.emit(url_string)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_url_changed(self, url):",
            "        \"\"\"Update title when URL has changed and no title is available.\"\"\"",
            "        if url.isValid() and not self.title():",
            "            self.title_changed.emit(url.toDisplayString())",
            "        self.url_changed.emit(url)",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        self._progress = 0",
            "        self._has_ssl_errors = False",
            "        self.data.viewing_source = False",
            "        self._set_load_status(usertypes.LoadStatus.loading)",
            "        self.load_started.emit()",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        \"\"\"Handle common acceptNavigationRequest code.\"\"\"",
            "        url = utils.elide(navigation.url.toDisplayString(), 100)",
            "        log.webview.debug(\"navigation request: url {}, type {}, is_main_frame \"",
            "                          \"{}\".format(url,",
            "                                      navigation.navigation_type,",
            "                                      navigation.is_main_frame))",
            "",
            "        if not navigation.url.isValid():",
            "            # Also a WORKAROUND for missing IDNA 2008 support in QUrl, see",
            "            # https://bugreports.qt.io/browse/QTBUG-60364",
            "",
            "            if navigation.navigation_type == navigation.Type.link_clicked:",
            "                msg = urlutils.get_errstring(navigation.url,",
            "                                             \"Invalid link clicked\")",
            "                message.error(msg)",
            "                self.data.open_target = usertypes.ClickTarget.normal",
            "",
            "            log.webview.debug(\"Ignoring invalid URL {} in \"",
            "                              \"acceptNavigationRequest: {}\".format(",
            "                                  navigation.url.toDisplayString(),",
            "                                  navigation.url.errorString()))",
            "            navigation.accepted = False",
            "",
            "    def handle_auto_insert_mode(self, ok):",
            "        \"\"\"Handle `input.insert_mode.auto_load` after loading finished.\"\"\"",
            "        if not config.val.input.insert_mode.auto_load or not ok:",
            "            return",
            "",
            "        cur_mode = self._mode_manager.mode",
            "        if cur_mode == usertypes.KeyMode.insert:",
            "            return",
            "",
            "        def _auto_insert_mode_cb(elem):",
            "            \"\"\"Called from JS after finding the focused element.\"\"\"",
            "            if elem is None:",
            "                log.webview.debug(\"No focused element!\")",
            "                return",
            "            if elem.is_editable():",
            "                modeman.enter(self.win_id, usertypes.KeyMode.insert,",
            "                              'load finished', only_if_normal=True)",
            "",
            "        self.elements.find_focused(_auto_insert_mode_cb)",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished(self, ok):",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3498",
            "            return",
            "",
            "        sess_manager = objreg.get('session-manager')",
            "        sess_manager.save_autosave()",
            "",
            "        if ok and not self._has_ssl_errors:",
            "            if self.url().scheme() == 'https':",
            "                self._set_load_status(usertypes.LoadStatus.success_https)",
            "            else:",
            "                self._set_load_status(usertypes.LoadStatus.success)",
            "        elif ok:",
            "            self._set_load_status(usertypes.LoadStatus.warn)",
            "        else:",
            "            self._set_load_status(usertypes.LoadStatus.error)",
            "",
            "        self.load_finished.emit(ok)",
            "",
            "        if not self.title():",
            "            self.title_changed.emit(self.url().toDisplayString())",
            "",
            "        self.zoom.set_current()",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        \"\"\"Emit add_history_item when triggered by backend-specific signal.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @pyqtSlot(int)",
            "    def _on_load_progress(self, perc):",
            "        self._progress = perc",
            "        self.load_progress.emit(perc)",
            "",
            "    def url(self, requested=False):",
            "        raise NotImplementedError",
            "",
            "    def progress(self):",
            "        return self._progress",
            "",
            "    def load_status(self):",
            "        return self._load_status",
            "",
            "    def _openurl_prepare(self, url, *, predict=True):",
            "        qtutils.ensure_valid(url)",
            "        if predict:",
            "            self.predicted_navigation.emit(url)",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        raise NotImplementedError",
            "",
            "    def reload(self, *, force=False):",
            "        raise NotImplementedError",
            "",
            "    def stop(self):",
            "        raise NotImplementedError",
            "",
            "    def clear_ssl_errors(self):",
            "        raise NotImplementedError",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        \"\"\"Send a fake key event to this tab.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        \"\"\"Dump the current page's html asynchronously.",
            "",
            "        The given callback will be called with the result when dumping is",
            "        complete.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        \"\"\"Run javascript async.",
            "",
            "        The given callback will be called with the result when running JS is",
            "        complete.",
            "",
            "        Args:",
            "            code: The javascript code to run.",
            "            callback: The callback to call with the result, or None.",
            "            world: A world ID (int or usertypes.JsWorld member) to run the JS",
            "                   in the main world or in another isolated world.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def shutdown(self):",
            "        raise NotImplementedError",
            "",
            "    def title(self):",
            "        raise NotImplementedError",
            "",
            "    def icon(self):",
            "        raise NotImplementedError",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        raise NotImplementedError",
            "",
            "    def networkaccessmanager(self):",
            "        \"\"\"Get the QNetworkAccessManager for this tab.",
            "",
            "        This is only implemented for QtWebKit.",
            "        For QtWebEngine, always returns None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def user_agent(self):",
            "        \"\"\"Get the user agent for this tab.",
            "",
            "        This is only implemented for QtWebKit.",
            "        For QtWebEngine, always returns None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def __repr__(self):",
            "        try:",
            "            url = utils.elide(self.url().toDisplayString(QUrl.EncodeUnicode),",
            "                              100)",
            "        except (AttributeError, RuntimeError) as exc:",
            "            url = '<{}>'.format(exc.__class__.__name__)",
            "        return utils.get_repr(self, tab_id=self.tab_id, url=url)",
            "",
            "    def is_deleted(self):",
            "        return sip.isdeleted(self._widget)"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Base class for a wrapper over QWebView/QWebEngineView.\"\"\"",
            "",
            "import enum",
            "import itertools",
            "",
            "import attr",
            "from PyQt5.QtCore import pyqtSignal, pyqtSlot, QUrl, QObject, QSizeF, Qt",
            "from PyQt5.QtGui import QIcon",
            "from PyQt5.QtWidgets import QWidget, QApplication, QDialog",
            "from PyQt5.QtPrintSupport import QPrintDialog",
            "",
            "import pygments",
            "import pygments.lexers",
            "import pygments.formatters",
            "",
            "from qutebrowser.keyinput import modeman",
            "from qutebrowser.config import config",
            "from qutebrowser.utils import (utils, objreg, usertypes, log, qtutils,",
            "                               urlutils, message)",
            "from qutebrowser.misc import miscwidgets, objects",
            "from qutebrowser.browser import mouse, hints",
            "from qutebrowser.qt import sip",
            "",
            "",
            "tab_id_gen = itertools.count(0)",
            "",
            "",
            "def create(win_id, private, parent=None):",
            "    \"\"\"Get a QtWebKit/QtWebEngine tab object.",
            "",
            "    Args:",
            "        win_id: The window ID where the tab will be shown.",
            "        private: Whether the tab is a private/off the record tab.",
            "        parent: The Qt parent to set.",
            "    \"\"\"",
            "    # Importing modules here so we don't depend on QtWebEngine without the",
            "    # argument and to avoid circular imports.",
            "    mode_manager = modeman.instance(win_id)",
            "    if objects.backend == usertypes.Backend.QtWebEngine:",
            "        from qutebrowser.browser.webengine import webenginetab",
            "        tab_class = webenginetab.WebEngineTab",
            "    else:",
            "        from qutebrowser.browser.webkit import webkittab",
            "        tab_class = webkittab.WebKitTab",
            "    return tab_class(win_id=win_id, mode_manager=mode_manager, private=private,",
            "                     parent=parent)",
            "",
            "",
            "def init():",
            "    \"\"\"Initialize backend-specific modules.\"\"\"",
            "    if objects.backend == usertypes.Backend.QtWebEngine:",
            "        from qutebrowser.browser.webengine import webenginetab",
            "        webenginetab.init()",
            "",
            "",
            "class WebTabError(Exception):",
            "",
            "    \"\"\"Base class for various errors.\"\"\"",
            "",
            "",
            "class UnsupportedOperationError(WebTabError):",
            "",
            "    \"\"\"Raised when an operation is not supported with the given backend.\"\"\"",
            "",
            "",
            "TerminationStatus = enum.Enum('TerminationStatus', [",
            "    'normal',",
            "    'abnormal',  # non-zero exit status",
            "    'crashed',   # e.g. segfault",
            "    'killed',",
            "    'unknown',",
            "])",
            "",
            "",
            "@attr.s",
            "class TabData:",
            "",
            "    \"\"\"A simple namespace with a fixed set of attributes.",
            "",
            "    Attributes:",
            "        keep_icon: Whether the (e.g. cloned) icon should not be cleared on page",
            "                   load.",
            "        inspector: The QWebInspector used for this webview.",
            "        viewing_source: Set if we're currently showing a source view.",
            "                        Only used when sources are shown via pygments.",
            "        open_target: Where to open the next link.",
            "                     Only used for QtWebKit.",
            "        override_target: Override for open_target for fake clicks (like hints).",
            "                         Only used for QtWebKit.",
            "        pinned: Flag to pin the tab.",
            "        fullscreen: Whether the tab has a video shown fullscreen currently.",
            "        netrc_used: Whether netrc authentication was performed.",
            "        input_mode: current input mode for the tab.",
            "    \"\"\"",
            "",
            "    keep_icon = attr.ib(False)",
            "    viewing_source = attr.ib(False)",
            "    inspector = attr.ib(None)",
            "    open_target = attr.ib(usertypes.ClickTarget.normal)",
            "    override_target = attr.ib(None)",
            "    pinned = attr.ib(False)",
            "    fullscreen = attr.ib(False)",
            "    netrc_used = attr.ib(False)",
            "    input_mode = attr.ib(usertypes.KeyMode.normal)",
            "",
            "    def should_show_icon(self):",
            "        return (config.val.tabs.favicons.show == 'always' or",
            "                config.val.tabs.favicons.show == 'pinned' and self.pinned)",
            "",
            "",
            "class AbstractAction:",
            "",
            "    \"\"\"Attribute of AbstractTab for Qt WebActions.",
            "",
            "    Class attributes (overridden by subclasses):",
            "        action_class: The class actions are defined on (QWeb{Engine,}Page)",
            "        action_base: The type of the actions (QWeb{Engine,}Page.WebAction)",
            "    \"\"\"",
            "",
            "    action_class = None",
            "    action_base = None",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def exit_fullscreen(self):",
            "        \"\"\"Exit the fullscreen mode.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def run_string(self, name):",
            "        \"\"\"Run a webaction based on its name.\"\"\"",
            "        member = getattr(self.action_class, name, None)",
            "        if not isinstance(member, self.action_base):",
            "            raise WebTabError(\"{} is not a valid web action!\".format(name))",
            "        self._widget.triggerPageAction(member)",
            "",
            "    def show_source(self,",
            "                    pygments=False):  # pylint: disable=redefined-outer-name",
            "        \"\"\"Show the source of the current page in a new tab.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def _show_source_pygments(self):",
            "",
            "        def show_source_cb(source):",
            "            \"\"\"Show source as soon as it's ready.\"\"\"",
            "            # WORKAROUND for https://github.com/PyCQA/pylint/issues/491",
            "            # pylint: disable=no-member",
            "            lexer = pygments.lexers.HtmlLexer()",
            "            formatter = pygments.formatters.HtmlFormatter(",
            "                full=True, linenos='table')",
            "            # pylint: enable=no-member",
            "            highlighted = pygments.highlight(source, lexer, formatter)",
            "",
            "            tb = objreg.get('tabbed-browser', scope='window',",
            "                            window=self._tab.win_id)",
            "            new_tab = tb.tabopen(background=False, related=True)",
            "            new_tab.set_html(highlighted, self._tab.url())",
            "            new_tab.data.viewing_source = True",
            "",
            "        self._tab.dump_async(show_source_cb)",
            "",
            "",
            "class AbstractPrinting:",
            "",
            "    \"\"\"Attribute of AbstractTab for printing the page.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def check_pdf_support(self):",
            "        raise NotImplementedError",
            "",
            "    def check_printer_support(self):",
            "        raise NotImplementedError",
            "",
            "    def check_preview_support(self):",
            "        raise NotImplementedError",
            "",
            "    def to_pdf(self, filename):",
            "        raise NotImplementedError",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        \"\"\"Print the tab.",
            "",
            "        Args:",
            "            printer: The QPrinter to print to.",
            "            callback: Called with a boolean",
            "                      (True if printing succeeded, False otherwise)",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def show_dialog(self):",
            "        \"\"\"Print with a QPrintDialog.\"\"\"",
            "        self.check_printer_support()",
            "",
            "        def print_callback(ok):",
            "            \"\"\"Called when printing finished.\"\"\"",
            "            if not ok:",
            "                message.error(\"Printing failed!\")",
            "            diag.deleteLater()",
            "",
            "        def do_print():",
            "            \"\"\"Called when the dialog was closed.\"\"\"",
            "            self.to_printer(diag.printer(), print_callback)",
            "",
            "        diag = QPrintDialog(self._tab)",
            "        if utils.is_mac:",
            "            # For some reason we get a segfault when using open() on macOS",
            "            ret = diag.exec_()",
            "            if ret == QDialog.Accepted:",
            "                do_print()",
            "        else:",
            "            diag.open(do_print)",
            "",
            "",
            "class AbstractSearch(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for doing searches.",
            "",
            "    Attributes:",
            "        text: The last thing this view was searched for.",
            "        search_displayed: Whether we're currently displaying search results in",
            "                          this view.",
            "        _flags: The flags of the last search (needs to be set by subclasses).",
            "        _widget: The underlying WebView widget.",
            "    \"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._widget = None",
            "        self.text = None",
            "        self.search_displayed = False",
            "",
            "    def _is_case_sensitive(self, ignore_case):",
            "        \"\"\"Check if case-sensitivity should be used.",
            "",
            "        This assumes self.text is already set properly.",
            "",
            "        Arguments:",
            "            ignore_case: The ignore_case value from the config.",
            "        \"\"\"",
            "        mapping = {",
            "            'smart': not self.text.islower(),",
            "            'never': True,",
            "            'always': False,",
            "        }",
            "        return mapping[ignore_case]",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        \"\"\"Find the given text on the page.",
            "",
            "        Args:",
            "            text: The text to search for.",
            "            ignore_case: Search case-insensitively. ('always'/'never/'smart')",
            "            reverse: Reverse search direction.",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def clear(self):",
            "        \"\"\"Clear the current search.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        \"\"\"Go to the previous result of the current search.",
            "",
            "        Args:",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        \"\"\"Go to the next result of the current search.",
            "",
            "        Args:",
            "            result_cb: Called with a bool indicating whether a match was found.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractZoom(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for controlling zoom.",
            "",
            "    Attributes:",
            "        _neighborlist: A NeighborList with the zoom levels.",
            "        _default_zoom_changed: Whether the zoom was changed from the default.",
            "    \"\"\"",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self._default_zoom_changed = False",
            "        self._init_neighborlist()",
            "        config.instance.changed.connect(self._on_config_changed)",
            "        self._zoom_factor = float(config.val.zoom.default) / 100",
            "",
            "        # # FIXME:qtwebengine is this needed?",
            "        # # For some reason, this signal doesn't get disconnected automatically",
            "        # # when the WebView is destroyed on older PyQt versions.",
            "        # # See https://github.com/qutebrowser/qutebrowser/issues/390",
            "        # self.destroyed.connect(functools.partial(",
            "        #     cfg.changed.disconnect, self.init_neighborlist))",
            "",
            "    @pyqtSlot(str)",
            "    def _on_config_changed(self, option):",
            "        if option in ['zoom.levels', 'zoom.default']:",
            "            if not self._default_zoom_changed:",
            "                factor = float(config.val.zoom.default) / 100",
            "                self.set_factor(factor)",
            "            self._init_neighborlist()",
            "",
            "    def _init_neighborlist(self):",
            "        \"\"\"Initialize self._neighborlist.\"\"\"",
            "        levels = config.val.zoom.levels",
            "        self._neighborlist = usertypes.NeighborList(",
            "            levels, mode=usertypes.NeighborList.Modes.edge)",
            "        self._neighborlist.fuzzyval = config.val.zoom.default",
            "",
            "    def offset(self, offset):",
            "        \"\"\"Increase/Decrease the zoom level by the given offset.",
            "",
            "        Args:",
            "            offset: The offset in the zoom level list.",
            "",
            "        Return:",
            "            The new zoom percentage.",
            "        \"\"\"",
            "        level = self._neighborlist.getitem(offset)",
            "        self.set_factor(float(level) / 100, fuzzyval=False)",
            "        return level",
            "",
            "    def _set_factor_internal(self, factor):",
            "        raise NotImplementedError",
            "",
            "    def set_factor(self, factor, *, fuzzyval=True):",
            "        \"\"\"Zoom to a given zoom factor.",
            "",
            "        Args:",
            "            factor: The zoom factor as float.",
            "            fuzzyval: Whether to set the NeighborLists fuzzyval.",
            "        \"\"\"",
            "        if fuzzyval:",
            "            self._neighborlist.fuzzyval = int(factor * 100)",
            "        if factor < 0:",
            "            raise ValueError(\"Can't zoom to factor {}!\".format(factor))",
            "",
            "        default_zoom_factor = float(config.val.zoom.default) / 100",
            "        self._default_zoom_changed = (factor != default_zoom_factor)",
            "",
            "        self._zoom_factor = factor",
            "        self._set_factor_internal(factor)",
            "",
            "    def factor(self):",
            "        return self._zoom_factor",
            "",
            "    def set_default(self):",
            "        self._set_factor_internal(float(config.val.zoom.default) / 100)",
            "",
            "    def set_current(self):",
            "        self._set_factor_internal(self._zoom_factor)",
            "",
            "",
            "class AbstractCaret(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab for caret browsing.",
            "",
            "    Signals:",
            "        selection_toggled: Emitted when the selection was toggled.",
            "                           arg: Whether the selection is now active.",
            "    \"\"\"",
            "",
            "    selection_toggled = pyqtSignal(bool)",
            "",
            "    def __init__(self, tab, mode_manager, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self.selection_enabled = False",
            "        mode_manager.entered.connect(self._on_mode_entered)",
            "        mode_manager.left.connect(self._on_mode_left)",
            "",
            "    def _on_mode_entered(self, mode):",
            "        raise NotImplementedError",
            "",
            "    def _on_mode_left(self, mode):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_line(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_char(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_next_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_line(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_line(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def move_to_start_of_document(self):",
            "        raise NotImplementedError",
            "",
            "    def move_to_end_of_document(self):",
            "        raise NotImplementedError",
            "",
            "    def toggle_selection(self):",
            "        raise NotImplementedError",
            "",
            "    def drop_selection(self):",
            "        raise NotImplementedError",
            "",
            "    def selection(self, callback):",
            "        raise NotImplementedError",
            "",
            "    def _follow_enter(self, tab):",
            "        \"\"\"Follow a link by faking an enter press.\"\"\"",
            "        if tab:",
            "            self._tab.key_press(Qt.Key_Enter, modifier=Qt.ControlModifier)",
            "        else:",
            "            self._tab.key_press(Qt.Key_Enter)",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractScroller(QObject):",
            "",
            "    \"\"\"Attribute of AbstractTab to manage scroll position.\"\"\"",
            "",
            "    perc_changed = pyqtSignal(int, int)",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self.perc_changed.connect(self._log_scroll_pos_change)",
            "",
            "    @pyqtSlot()",
            "    def _log_scroll_pos_change(self):",
            "        log.webview.vdebug(\"Scroll position changed to {}\".format(",
            "            self.pos_px()))",
            "",
            "    def _init_widget(self, widget):",
            "        self._widget = widget",
            "",
            "    def pos_px(self):",
            "        raise NotImplementedError",
            "",
            "    def pos_perc(self):",
            "        raise NotImplementedError",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        raise NotImplementedError",
            "",
            "    def to_point(self, point):",
            "        raise NotImplementedError",
            "",
            "    def to_anchor(self, name):",
            "        raise NotImplementedError",
            "",
            "    def delta(self, x=0, y=0):",
            "        raise NotImplementedError",
            "",
            "    def delta_page(self, x=0, y=0):",
            "        raise NotImplementedError",
            "",
            "    def up(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def down(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def left(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def right(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def top(self):",
            "        raise NotImplementedError",
            "",
            "    def bottom(self):",
            "        raise NotImplementedError",
            "",
            "    def page_up(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def page_down(self, count=1):",
            "        raise NotImplementedError",
            "",
            "    def at_top(self):",
            "        raise NotImplementedError",
            "",
            "    def at_bottom(self):",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractHistory:",
            "",
            "    \"\"\"The history attribute of a AbstractTab.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._tab = tab",
            "        self._history = None",
            "",
            "    def __len__(self):",
            "        return len(self._history)",
            "",
            "    def __iter__(self):",
            "        return iter(self._history.items())",
            "",
            "    def current_idx(self):",
            "        raise NotImplementedError",
            "",
            "    def back(self, count=1):",
            "        \"\"\"Go back in the tab's history.\"\"\"",
            "        idx = self.current_idx() - count",
            "        if idx >= 0:",
            "            self._go_to_item(self._item_at(idx))",
            "        else:",
            "            self._go_to_item(self._item_at(0))",
            "            raise WebTabError(\"At beginning of history.\")",
            "",
            "    def forward(self, count=1):",
            "        \"\"\"Go forward in the tab's history.\"\"\"",
            "        idx = self.current_idx() + count",
            "        if idx < len(self):",
            "            self._go_to_item(self._item_at(idx))",
            "        else:",
            "            self._go_to_item(self._item_at(len(self) - 1))",
            "            raise WebTabError(\"At end of history.\")",
            "",
            "    def can_go_back(self):",
            "        raise NotImplementedError",
            "",
            "    def can_go_forward(self):",
            "        raise NotImplementedError",
            "",
            "    def _item_at(self, i):",
            "        raise NotImplementedError",
            "",
            "    def _go_to_item(self, item):",
            "        raise NotImplementedError",
            "",
            "    def serialize(self):",
            "        \"\"\"Serialize into an opaque format understood by self.deserialize.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def deserialize(self, data):",
            "        \"\"\"Serialize from a format produced by self.serialize.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def load_items(self, items):",
            "        \"\"\"Deserialize from a list of WebHistoryItems.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractElements:",
            "",
            "    \"\"\"Finding and handling of elements on the page.\"\"\"",
            "",
            "    def __init__(self, tab):",
            "        self._widget = None",
            "        self._tab = tab",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        \"\"\"Find all HTML elements matching a given selector async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "            selector: The CSS selector to search for.",
            "            only_visible: Only show elements which are visible on screen.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_id(self, elem_id, callback):",
            "        \"\"\"Find the HTML element with the given ID async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "            elem_id: The ID to search for.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_focused(self, callback):",
            "        \"\"\"Find the focused element on the page async.",
            "",
            "        Args:",
            "            callback: The callback to be called when the search finished.",
            "                      Called with a WebEngineElement or None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        \"\"\"Find the element at the given position async.",
            "",
            "        This is also called \"hit test\" elsewhere.",
            "",
            "        Args:",
            "            pos: The QPoint to get the element for.",
            "            callback: The callback to be called when the search finished.",
            "                      Called with a WebEngineElement or None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractAudio(QObject):",
            "",
            "    \"\"\"Handling of audio/muting for this tab.\"\"\"",
            "",
            "    muted_changed = pyqtSignal(bool)",
            "    recently_audible_changed = pyqtSignal(bool)",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._widget = None",
            "",
            "    def set_muted(self, muted: bool):",
            "        \"\"\"Set this tab as muted or not.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def is_muted(self):",
            "        \"\"\"Whether this tab is muted.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def toggle_muted(self):",
            "        self.set_muted(not self.is_muted())",
            "",
            "    def is_recently_audible(self):",
            "        \"\"\"Whether this tab has had audio playing recently.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class AbstractTab(QWidget):",
            "",
            "    \"\"\"A wrapper over the given widget to hide its API and expose another one.",
            "",
            "    We use this to unify QWebView and QWebEngineView.",
            "",
            "    Attributes:",
            "        history: The AbstractHistory for the current tab.",
            "        registry: The ObjectRegistry associated with this tab.",
            "        private: Whether private browsing is turned on for this tab.",
            "",
            "        _load_status: loading status of this page",
            "                      Accessible via load_status() method.",
            "        _has_ssl_errors: Whether SSL errors happened.",
            "                         Needs to be set by subclasses.",
            "",
            "        for properties, see WebView/WebEngineView docs.",
            "",
            "    Signals:",
            "        See related Qt signals.",
            "",
            "        new_tab_requested: Emitted when a new tab should be opened with the",
            "                           given URL.",
            "        load_status_changed: The loading status changed",
            "        fullscreen_requested: Fullscreen display was requested by the page.",
            "                              arg: True if fullscreen should be turned on,",
            "                                   False if it should be turned off.",
            "        renderer_process_terminated: Emitted when the underlying renderer",
            "                                     process terminated.",
            "                                     arg 0: A TerminationStatus member.",
            "                                     arg 1: The exit code.",
            "        predicted_navigation: Emitted before we tell Qt to open a URL.",
            "    \"\"\"",
            "",
            "    window_close_requested = pyqtSignal()",
            "    link_hovered = pyqtSignal(str)",
            "    load_started = pyqtSignal()",
            "    load_progress = pyqtSignal(int)",
            "    load_finished = pyqtSignal(bool)",
            "    icon_changed = pyqtSignal(QIcon)",
            "    title_changed = pyqtSignal(str)",
            "    load_status_changed = pyqtSignal(str)",
            "    new_tab_requested = pyqtSignal(QUrl)",
            "    url_changed = pyqtSignal(QUrl)",
            "    shutting_down = pyqtSignal()",
            "    contents_size_changed = pyqtSignal(QSizeF)",
            "    add_history_item = pyqtSignal(QUrl, QUrl, str)  # url, requested url, title",
            "    fullscreen_requested = pyqtSignal(bool)",
            "    renderer_process_terminated = pyqtSignal(TerminationStatus, int)",
            "    predicted_navigation = pyqtSignal(QUrl)",
            "",
            "    # Hosts for which a certificate error happened. Shared between all tabs.",
            "    #",
            "    # Note that we remember hosts here, without scheme/port:",
            "    # QtWebEngine/Chromium also only remembers hostnames, and certificates are",
            "    # for a given hostname anyways.",
            "    _insecure_hosts = set()  # type: typing.Set[str]",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        self.private = private",
            "        self.win_id = win_id",
            "        self.tab_id = next(tab_id_gen)",
            "        super().__init__(parent)",
            "",
            "        self.registry = objreg.ObjectRegistry()",
            "        tab_registry = objreg.get('tab-registry', scope='window',",
            "                                  window=win_id)",
            "        tab_registry[self.tab_id] = self",
            "        objreg.register('tab', self, registry=self.registry)",
            "",
            "        self.data = TabData()",
            "        self._layout = miscwidgets.WrapperLayout(self)",
            "        self._widget = None",
            "        self._progress = 0",
            "        self._mode_manager = mode_manager",
            "        self._load_status = usertypes.LoadStatus.none",
            "        self._mouse_event_filter = mouse.MouseEventFilter(",
            "            self, parent=self)",
            "        self.backend = None",
            "",
            "        # FIXME:qtwebengine  Should this be public api via self.hints?",
            "        #                    Also, should we get it out of objreg?",
            "        hintmanager = hints.HintManager(win_id, self.tab_id, parent=self)",
            "        objreg.register('hintmanager', hintmanager, scope='tab',",
            "                        window=self.win_id, tab=self.tab_id)",
            "",
            "        self.predicted_navigation.connect(self._on_predicted_navigation)",
            "",
            "    def _set_widget(self, widget):",
            "        # pylint: disable=protected-access",
            "        self._widget = widget",
            "        self._layout.wrap(self, widget)",
            "        self.history._history = widget.history()",
            "        self.scroller._init_widget(widget)",
            "        self.caret._widget = widget",
            "        self.zoom._widget = widget",
            "        self.search._widget = widget",
            "        self.printing._widget = widget",
            "        self.action._widget = widget",
            "        self.elements._widget = widget",
            "        self.audio._widget = widget",
            "        self.settings._settings = widget.settings()",
            "",
            "        self._install_event_filter()",
            "        self.zoom.set_default()",
            "",
            "    def _install_event_filter(self):",
            "        raise NotImplementedError",
            "",
            "    def _set_load_status(self, val):",
            "        \"\"\"Setter for load_status.\"\"\"",
            "        if not isinstance(val, usertypes.LoadStatus):",
            "            raise TypeError(\"Type {} is no LoadStatus member!\".format(val))",
            "        log.webview.debug(\"load status for {}: {}\".format(repr(self), val))",
            "        self._load_status = val",
            "        self.load_status_changed.emit(val.name)",
            "",
            "    def event_target(self):",
            "        \"\"\"Return the widget events should be sent to.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def send_event(self, evt):",
            "        \"\"\"Send the given event to the underlying widget.",
            "",
            "        The event will be sent via QApplication.postEvent.",
            "        Note that a posted event may not be re-used in any way!",
            "        \"\"\"",
            "        # This only gives us some mild protection against re-using events, but",
            "        # it's certainly better than a segfault.",
            "        if getattr(evt, 'posted', False):",
            "            raise utils.Unreachable(\"Can't re-use an event which was already \"",
            "                                    \"posted!\")",
            "",
            "        recipient = self.event_target()",
            "        if recipient is None:",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3888",
            "            log.webview.warning(\"Unable to find event target!\")",
            "            return",
            "",
            "        evt.posted = True",
            "        QApplication.postEvent(recipient, evt)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_predicted_navigation(self, url):",
            "        \"\"\"Adjust the title if we are going to visit an URL soon.\"\"\"",
            "        qtutils.ensure_valid(url)",
            "        url_string = url.toDisplayString()",
            "        log.webview.debug(\"Predicted navigation: {}\".format(url_string))",
            "        self.title_changed.emit(url_string)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_url_changed(self, url):",
            "        \"\"\"Update title when URL has changed and no title is available.\"\"\"",
            "        if url.isValid() and not self.title():",
            "            self.title_changed.emit(url.toDisplayString())",
            "        self.url_changed.emit(url)",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        self._progress = 0",
            "        self.data.viewing_source = False",
            "        self._set_load_status(usertypes.LoadStatus.loading)",
            "        self.load_started.emit()",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        \"\"\"Handle common acceptNavigationRequest code.\"\"\"",
            "        url = utils.elide(navigation.url.toDisplayString(), 100)",
            "        log.webview.debug(\"navigation request: url {}, type {}, is_main_frame \"",
            "                          \"{}\".format(url,",
            "                                      navigation.navigation_type,",
            "                                      navigation.is_main_frame))",
            "",
            "        if not navigation.url.isValid():",
            "            # Also a WORKAROUND for missing IDNA 2008 support in QUrl, see",
            "            # https://bugreports.qt.io/browse/QTBUG-60364",
            "",
            "            if navigation.navigation_type == navigation.Type.link_clicked:",
            "                msg = urlutils.get_errstring(navigation.url,",
            "                                             \"Invalid link clicked\")",
            "                message.error(msg)",
            "                self.data.open_target = usertypes.ClickTarget.normal",
            "",
            "            log.webview.debug(\"Ignoring invalid URL {} in \"",
            "                              \"acceptNavigationRequest: {}\".format(",
            "                                  navigation.url.toDisplayString(),",
            "                                  navigation.url.errorString()))",
            "            navigation.accepted = False",
            "",
            "    def handle_auto_insert_mode(self, ok):",
            "        \"\"\"Handle `input.insert_mode.auto_load` after loading finished.\"\"\"",
            "        if not config.val.input.insert_mode.auto_load or not ok:",
            "            return",
            "",
            "        cur_mode = self._mode_manager.mode",
            "        if cur_mode == usertypes.KeyMode.insert:",
            "            return",
            "",
            "        def _auto_insert_mode_cb(elem):",
            "            \"\"\"Called from JS after finding the focused element.\"\"\"",
            "            if elem is None:",
            "                log.webview.debug(\"No focused element!\")",
            "                return",
            "            if elem.is_editable():",
            "                modeman.enter(self.win_id, usertypes.KeyMode.insert,",
            "                              'load finished', only_if_normal=True)",
            "",
            "        self.elements.find_focused(_auto_insert_mode_cb)",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished(self, ok):",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3498",
            "            return",
            "",
            "        sess_manager = objreg.get('session-manager')",
            "        sess_manager.save_autosave()",
            "",
            "        if ok:",
            "            if self.url().scheme() == 'https':",
            "                if self.url().host() in self._insecure_hosts:",
            "                    self._set_load_status(usertypes.LoadStatus.warn)",
            "                else:",
            "                    self._set_load_status(usertypes.LoadStatus.success_https)",
            "            else:",
            "                self._set_load_status(usertypes.LoadStatus.success)",
            "        elif ok:",
            "            self._set_load_status(usertypes.LoadStatus.warn)",
            "        else:",
            "            self._set_load_status(usertypes.LoadStatus.error)",
            "",
            "        self.load_finished.emit(ok)",
            "",
            "        if not self.title():",
            "            self.title_changed.emit(self.url().toDisplayString())",
            "",
            "        self.zoom.set_current()",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        \"\"\"Emit add_history_item when triggered by backend-specific signal.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @pyqtSlot(int)",
            "    def _on_load_progress(self, perc):",
            "        self._progress = perc",
            "        self.load_progress.emit(perc)",
            "",
            "    def url(self, requested=False):",
            "        raise NotImplementedError",
            "",
            "    def progress(self):",
            "        return self._progress",
            "",
            "    def load_status(self):",
            "        return self._load_status",
            "",
            "    def _openurl_prepare(self, url, *, predict=True):",
            "        qtutils.ensure_valid(url)",
            "        if predict:",
            "            self.predicted_navigation.emit(url)",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        raise NotImplementedError",
            "",
            "    def reload(self, *, force=False):",
            "        raise NotImplementedError",
            "",
            "    def stop(self):",
            "        raise NotImplementedError",
            "",
            "    def clear_ssl_errors(self):",
            "        raise NotImplementedError",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        \"\"\"Send a fake key event to this tab.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        \"\"\"Dump the current page's html asynchronously.",
            "",
            "        The given callback will be called with the result when dumping is",
            "        complete.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        \"\"\"Run javascript async.",
            "",
            "        The given callback will be called with the result when running JS is",
            "        complete.",
            "",
            "        Args:",
            "            code: The javascript code to run.",
            "            callback: The callback to call with the result, or None.",
            "            world: A world ID (int or usertypes.JsWorld member) to run the JS",
            "                   in the main world or in another isolated world.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def shutdown(self):",
            "        raise NotImplementedError",
            "",
            "    def title(self):",
            "        raise NotImplementedError",
            "",
            "    def icon(self):",
            "        raise NotImplementedError",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        raise NotImplementedError",
            "",
            "    def networkaccessmanager(self):",
            "        \"\"\"Get the QNetworkAccessManager for this tab.",
            "",
            "        This is only implemented for QtWebKit.",
            "        For QtWebEngine, always returns None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def user_agent(self):",
            "        \"\"\"Get the user agent for this tab.",
            "",
            "        This is only implemented for QtWebKit.",
            "        For QtWebEngine, always returns None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def __repr__(self):",
            "        try:",
            "            url = utils.elide(self.url().toDisplayString(QUrl.EncodeUnicode),",
            "                              100)",
            "        except (AttributeError, RuntimeError) as exc:",
            "            url = '<{}>'.format(exc.__class__.__name__)",
            "        return utils.get_repr(self, tab_id=self.tab_id, url=url)",
            "",
            "    def is_deleted(self):",
            "        return sip.isdeleted(self._widget)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "756": [
                "AbstractTab",
                "__init__"
            ],
            "843": [
                "AbstractTab",
                "_on_load_started"
            ],
            "902": [
                "AbstractTab",
                "_on_load_finished"
            ],
            "904": [
                "AbstractTab",
                "_on_load_finished"
            ]
        },
        "addLocation": [
            "qutebrowser.browser.browsertab.AbstractTab.self"
        ]
    },
    "qutebrowser/browser/webengine/webenginetab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1278,
                "afterPatchRowNumber": 1278,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1279,
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "     @pyqtSlot(certificateerror.CertificateErrorWrapper)"
            },
            "2": {
                "beforePatchRowNumber": 1280,
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "     def _on_ssl_errors(self, error):"
            },
            "3": {
                "beforePatchRowNumber": 1281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._has_ssl_errors = True"
            },
            "4": {
                "beforePatchRowNumber": 1282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 1283,
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "         url = error.url()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "+        self._insecure_hosts.add(url.host())"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 1284,
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "         log.webview.debug(\"Certificate error: {}\".format(error))"
            },
            "9": {
                "beforePatchRowNumber": 1285,
                "afterPatchRowNumber": 1285,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 1286,
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "         if error.is_overridable():"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Wrapper over a QWebEngineView.\"\"\"",
            "",
            "import math",
            "import functools",
            "import sys",
            "import re",
            "import html as html_utils",
            "",
            "from PyQt5.QtCore import (pyqtSignal, pyqtSlot, Qt, QEvent, QPoint, QPointF,",
            "                          QUrl, QTimer, QObject, qVersion)",
            "from PyQt5.QtGui import QKeyEvent, QIcon",
            "from PyQt5.QtNetwork import QAuthenticator",
            "from PyQt5.QtWidgets import QApplication",
            "from PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineScript",
            "",
            "from qutebrowser.config import configdata, config",
            "from qutebrowser.browser import browsertab, mouse, shared, webelem",
            "from qutebrowser.browser.webengine import (webview, webengineelem, tabhistory,",
            "                                           interceptor, webenginequtescheme,",
            "                                           cookies, webenginedownloads,",
            "                                           webenginesettings, certificateerror)",
            "from qutebrowser.misc import miscwidgets",
            "from qutebrowser.utils import (usertypes, qtutils, log, javascript, utils,",
            "                               message, objreg, jinja, debug)",
            "from qutebrowser.qt import sip",
            "",
            "",
            "_qute_scheme_handler = None",
            "",
            "",
            "def init():",
            "    \"\"\"Initialize QtWebEngine-specific modules.\"\"\"",
            "    # For some reason we need to keep a reference, otherwise the scheme handler",
            "    # won't work...",
            "    # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html",
            "    global _qute_scheme_handler",
            "",
            "    app = QApplication.instance()",
            "    log.init.debug(\"Initializing qute://* handler...\")",
            "    _qute_scheme_handler = webenginequtescheme.QuteSchemeHandler(parent=app)",
            "    _qute_scheme_handler.install(webenginesettings.default_profile)",
            "    _qute_scheme_handler.install(webenginesettings.private_profile)",
            "",
            "    log.init.debug(\"Initializing request interceptor...\")",
            "    host_blocker = objreg.get('host-blocker')",
            "    args = objreg.get('args')",
            "    req_interceptor = interceptor.RequestInterceptor(",
            "        host_blocker, args=args, parent=app)",
            "    req_interceptor.install(webenginesettings.default_profile)",
            "    req_interceptor.install(webenginesettings.private_profile)",
            "",
            "    log.init.debug(\"Initializing QtWebEngine downloads...\")",
            "    download_manager = webenginedownloads.DownloadManager(parent=app)",
            "    download_manager.install(webenginesettings.default_profile)",
            "    download_manager.install(webenginesettings.private_profile)",
            "    objreg.register('webengine-download-manager', download_manager)",
            "",
            "    log.init.debug(\"Initializing cookie filter...\")",
            "    cookies.install_filter(webenginesettings.default_profile)",
            "    cookies.install_filter(webenginesettings.private_profile)",
            "",
            "    # Clear visited links on web history clear",
            "    hist = objreg.get('web-history')",
            "    for p in [webenginesettings.default_profile,",
            "              webenginesettings.private_profile]:",
            "        hist.history_cleared.connect(p.clearAllVisitedLinks)",
            "        hist.url_cleared.connect(lambda url, profile=p:",
            "                                 profile.clearVisitedLinks([url]))",
            "",
            "",
            "# Mapping worlds from usertypes.JsWorld to QWebEngineScript world IDs.",
            "_JS_WORLD_MAP = {",
            "    usertypes.JsWorld.main: QWebEngineScript.MainWorld,",
            "    usertypes.JsWorld.application: QWebEngineScript.ApplicationWorld,",
            "    usertypes.JsWorld.user: QWebEngineScript.UserWorld,",
            "    usertypes.JsWorld.jseval: QWebEngineScript.UserWorld + 1,",
            "}",
            "",
            "",
            "class WebEngineAction(browsertab.AbstractAction):",
            "",
            "    \"\"\"QtWebEngine implementations related to web actions.\"\"\"",
            "",
            "    action_class = QWebEnginePage",
            "    action_base = QWebEnginePage.WebAction",
            "",
            "    def exit_fullscreen(self):",
            "        self._widget.triggerPageAction(QWebEnginePage.ExitFullScreen)",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        self._widget.triggerPageAction(QWebEnginePage.SavePage)",
            "",
            "    def show_source(self, pygments=False):",
            "        if pygments:",
            "            self._show_source_pygments()",
            "            return",
            "",
            "        try:",
            "            self._widget.triggerPageAction(QWebEnginePage.ViewSource)",
            "        except AttributeError:",
            "            # Qt < 5.8",
            "            tb = objreg.get('tabbed-browser', scope='window',",
            "                            window=self._tab.win_id)",
            "            urlstr = self._tab.url().toString(QUrl.RemoveUserInfo)",
            "            # The original URL becomes the path of a view-source: URL",
            "            # (without a host), but query/fragment should stay.",
            "            url = QUrl('view-source:' + urlstr)",
            "            tb.tabopen(url, background=False, related=True)",
            "",
            "",
            "class WebEnginePrinting(browsertab.AbstractPrinting):",
            "",
            "    \"\"\"QtWebEngine implementations related to printing.\"\"\"",
            "",
            "    def check_pdf_support(self):",
            "        return True",
            "",
            "    def check_printer_support(self):",
            "        if not hasattr(self._widget.page(), 'print'):",
            "            raise browsertab.WebTabError(",
            "                \"Printing is unsupported with QtWebEngine on Qt < 5.8\")",
            "",
            "    def check_preview_support(self):",
            "        raise browsertab.WebTabError(",
            "            \"Print previews are unsupported with QtWebEngine\")",
            "",
            "    def to_pdf(self, filename):",
            "        self._widget.page().printToPdf(filename)",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        if callback is None:",
            "            callback = lambda _ok: None",
            "        self._widget.page().print(printer, callback)",
            "",
            "",
            "class WebEngineSearch(browsertab.AbstractSearch):",
            "",
            "    \"\"\"QtWebEngine implementations related to searching on the page.",
            "",
            "    Attributes:",
            "        _flags: The QWebEnginePage.FindFlags of the last search.",
            "        _pending_searches: How many searches have been started but not called",
            "                           back yet.",
            "    \"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._flags = QWebEnginePage.FindFlags(0)",
            "        self._pending_searches = 0",
            "",
            "    def _find(self, text, flags, callback, caller):",
            "        \"\"\"Call findText on the widget.\"\"\"",
            "        self.search_displayed = True",
            "        self._pending_searches += 1",
            "",
            "        def wrapped_callback(found):",
            "            \"\"\"Wrap the callback to do debug logging.\"\"\"",
            "            self._pending_searches -= 1",
            "            if self._pending_searches > 0:",
            "                # See https://github.com/qutebrowser/qutebrowser/issues/2442",
            "                # and https://github.com/qt/qtwebengine/blob/5.10/src/core/web_contents_adapter.cpp#L924-L934",
            "                log.webview.debug(\"Ignoring cancelled search callback with \"",
            "                                  \"{} pending searches\".format(",
            "                                      self._pending_searches))",
            "                return",
            "",
            "            found_text = 'found' if found else \"didn't find\"",
            "            if flags:",
            "                flag_text = 'with flags {}'.format(debug.qflags_key(",
            "                    QWebEnginePage, flags, klass=QWebEnginePage.FindFlag))",
            "            else:",
            "                flag_text = ''",
            "            log.webview.debug(' '.join([caller, found_text, text, flag_text])",
            "                              .strip())",
            "            if callback is not None:",
            "                callback(found)",
            "        self._widget.findText(text, flags, wrapped_callback)",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        # Don't go to next entry on duplicate search",
            "        if self.text == text and self.search_displayed:",
            "            log.webview.debug(\"Ignoring duplicate search request\"",
            "                              \" for {}\".format(text))",
            "            return",
            "",
            "        self.text = text",
            "        self._flags = QWebEnginePage.FindFlags(0)",
            "        if self._is_case_sensitive(ignore_case):",
            "            self._flags |= QWebEnginePage.FindCaseSensitively",
            "        if reverse:",
            "            self._flags |= QWebEnginePage.FindBackward",
            "",
            "        self._find(text, self._flags, result_cb, 'search')",
            "",
            "    def clear(self):",
            "        self.search_displayed = False",
            "        self._widget.findText('')",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        # The int() here makes sure we get a copy of the flags.",
            "        flags = QWebEnginePage.FindFlags(int(self._flags))",
            "        if flags & QWebEnginePage.FindBackward:",
            "            flags &= ~QWebEnginePage.FindBackward",
            "        else:",
            "            flags |= QWebEnginePage.FindBackward",
            "        self._find(self.text, flags, result_cb, 'prev_result')",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        self._find(self.text, self._flags, result_cb, 'next_result')",
            "",
            "",
            "class WebEngineCaret(browsertab.AbstractCaret):",
            "",
            "    \"\"\"QtWebEngine implementations related to moving the cursor/selection.\"\"\"",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_entered(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        if self._tab.search.search_displayed:",
            "            # We are currently in search mode.",
            "            # convert the search to a blue selection so we can operate on it",
            "            # https://bugreports.qt.io/browse/QTBUG-60673",
            "            self._tab.search.clear()",
            "",
            "        self._tab.run_js_async(",
            "            javascript.assemble('caret',",
            "                                'setPlatform', sys.platform, qVersion()))",
            "        self._js_call('setInitialCursor', self._selection_cb)",
            "",
            "    def _selection_cb(self, enabled):",
            "        \"\"\"Emit selection_toggled based on setInitialCursor.\"\"\"",
            "        if enabled is None:",
            "            log.webview.debug(\"Ignoring selection status None\")",
            "            return",
            "        self.selection_toggled.emit(enabled)",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_left(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        self.drop_selection()",
            "        self._js_call('disableCaret')",
            "",
            "    def move_to_next_line(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveDown')",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveUp')",
            "",
            "    def move_to_next_char(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveRight')",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveLeft')",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfWord')",
            "",
            "    def move_to_next_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToNextWord')",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToPreviousWord')",
            "",
            "    def move_to_start_of_line(self):",
            "        self._js_call('moveToStartOfLine')",
            "",
            "    def move_to_end_of_line(self):",
            "        self._js_call('moveToEndOfLine')",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToStartOfNextBlock')",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToStartOfPrevBlock')",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfNextBlock')",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfPrevBlock')",
            "",
            "    def move_to_start_of_document(self):",
            "        self._js_call('moveToStartOfDocument')",
            "",
            "    def move_to_end_of_document(self):",
            "        self._js_call('moveToEndOfDocument')",
            "",
            "    def toggle_selection(self):",
            "        self._js_call('toggleSelection', self.selection_toggled.emit)",
            "",
            "    def drop_selection(self):",
            "        self._js_call('dropSelection')",
            "",
            "    def selection(self, callback):",
            "        # Not using selectedText() as WORKAROUND for",
            "        # https://bugreports.qt.io/browse/QTBUG-53134",
            "        # Even on Qt 5.10 selectedText() seems to work poorly, see",
            "        # https://github.com/qutebrowser/qutebrowser/issues/3523",
            "        self._tab.run_js_async(javascript.assemble('caret', 'getSelection'),",
            "                               callback)",
            "",
            "    def _follow_selected_cb(self, js_elem, tab=False):",
            "        \"\"\"Callback for javascript which clicks the selected element.",
            "",
            "        Args:",
            "            js_elem: The element serialized from javascript.",
            "            tab: Open in a new tab.",
            "        \"\"\"",
            "        if js_elem is None:",
            "            return",
            "        if js_elem == \"focused\":",
            "            # we had a focused element, not a selected one. Just send <enter>",
            "            self._follow_enter(tab)",
            "            return",
            "",
            "        assert isinstance(js_elem, dict), js_elem",
            "        elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "        if tab:",
            "            click_type = usertypes.ClickTarget.tab",
            "        else:",
            "            click_type = usertypes.ClickTarget.normal",
            "",
            "        # Only click if we see a link",
            "        if elem.is_link():",
            "            log.webview.debug(\"Found link in selection, clicking. ClickTarget \"",
            "                              \"{}, elem {}\".format(click_type, elem))",
            "            try:",
            "                elem.click(click_type)",
            "            except webelem.Error as e:",
            "                message.error(str(e))",
            "                return",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        if self._tab.search.search_displayed:",
            "            # We are currently in search mode.",
            "            # let's click the link via a fake-click",
            "            # https://bugreports.qt.io/browse/QTBUG-60673",
            "            self._tab.search.clear()",
            "",
            "            log.webview.debug(\"Clicking a searched link via fake key press.\")",
            "            # send a fake enter, clicking the orange selection box",
            "            self._follow_enter(tab)",
            "        else:",
            "            # click an existing blue selection",
            "            js_code = javascript.assemble('webelem',",
            "                                          'find_selected_focused_link')",
            "            self._tab.run_js_async(js_code, lambda jsret:",
            "                                   self._follow_selected_cb(jsret, tab))",
            "",
            "    def _js_call(self, command, callback=None):",
            "        self._tab.run_js_async(javascript.assemble('caret', command), callback)",
            "",
            "",
            "class WebEngineScroller(browsertab.AbstractScroller):",
            "",
            "    \"\"\"QtWebEngine implementations related to scrolling.\"\"\"",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(tab, parent)",
            "        self._args = objreg.get('args')",
            "        self._pos_perc = (0, 0)",
            "        self._pos_px = QPoint()",
            "        self._at_bottom = False",
            "",
            "    def _init_widget(self, widget):",
            "        super()._init_widget(widget)",
            "        page = widget.page()",
            "        page.scrollPositionChanged.connect(self._update_pos)",
            "",
            "    def _repeated_key_press(self, key, count=1, modifier=Qt.NoModifier):",
            "        \"\"\"Send count fake key presses to this scroller's WebEngineTab.\"\"\"",
            "        for _ in range(min(count, 1000)):",
            "            self._tab.key_press(key, modifier)",
            "",
            "    @pyqtSlot(QPointF)",
            "    def _update_pos(self, pos):",
            "        \"\"\"Update the scroll position attributes when it changed.\"\"\"",
            "        self._pos_px = pos.toPoint()",
            "        contents_size = self._widget.page().contentsSize()",
            "",
            "        scrollable_x = contents_size.width() - self._widget.width()",
            "        if scrollable_x == 0:",
            "            perc_x = 0",
            "        else:",
            "            try:",
            "                perc_x = min(100, round(100 / scrollable_x * pos.x()))",
            "            except ValueError:",
            "                # https://github.com/qutebrowser/qutebrowser/issues/3219",
            "                log.misc.debug(\"Got ValueError!\")",
            "                log.misc.debug(\"contents_size.width(): {}\".format(",
            "                    contents_size.width()))",
            "                log.misc.debug(\"self._widget.width(): {}\".format(",
            "                    self._widget.width()))",
            "                log.misc.debug(\"scrollable_x: {}\".format(scrollable_x))",
            "                log.misc.debug(\"pos.x(): {}\".format(pos.x()))",
            "                raise",
            "",
            "        scrollable_y = contents_size.height() - self._widget.height()",
            "        if scrollable_y == 0:",
            "            perc_y = 0",
            "        else:",
            "            perc_y = min(100, round(100 / scrollable_y * pos.y()))",
            "",
            "        self._at_bottom = math.ceil(pos.y()) >= scrollable_y",
            "",
            "        if (self._pos_perc != (perc_x, perc_y) or",
            "                'no-scroll-filtering' in self._args.debug_flags):",
            "            self._pos_perc = perc_x, perc_y",
            "            self.perc_changed.emit(*self._pos_perc)",
            "",
            "    def pos_px(self):",
            "        return self._pos_px",
            "",
            "    def pos_perc(self):",
            "        return self._pos_perc",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        js_code = javascript.assemble('scroll', 'to_perc', x, y)",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def to_point(self, point):",
            "        js_code = javascript.assemble('window', 'scroll', point.x(), point.y())",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def to_anchor(self, name):",
            "        url = self._tab.url()",
            "        url.setFragment(name)",
            "        self._tab.openurl(url)",
            "",
            "    def delta(self, x=0, y=0):",
            "        self._tab.run_js_async(javascript.assemble('window', 'scrollBy', x, y))",
            "",
            "    def delta_page(self, x=0, y=0):",
            "        js_code = javascript.assemble('scroll', 'delta_page', x, y)",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def up(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Up, count)",
            "",
            "    def down(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Down, count)",
            "",
            "    def left(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Left, count)",
            "",
            "    def right(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Right, count)",
            "",
            "    def top(self):",
            "        self._tab.key_press(Qt.Key_Home)",
            "",
            "    def bottom(self):",
            "        self._tab.key_press(Qt.Key_End)",
            "",
            "    def page_up(self, count=1):",
            "        self._repeated_key_press(Qt.Key_PageUp, count)",
            "",
            "    def page_down(self, count=1):",
            "        self._repeated_key_press(Qt.Key_PageDown, count)",
            "",
            "    def at_top(self):",
            "        return self.pos_px().y() == 0",
            "",
            "    def at_bottom(self):",
            "        return self._at_bottom",
            "",
            "",
            "class WebEngineHistory(browsertab.AbstractHistory):",
            "",
            "    \"\"\"QtWebEngine implementations related to page history.\"\"\"",
            "",
            "    def current_idx(self):",
            "        return self._history.currentItemIndex()",
            "",
            "    def can_go_back(self):",
            "        return self._history.canGoBack()",
            "",
            "    def can_go_forward(self):",
            "        return self._history.canGoForward()",
            "",
            "    def _item_at(self, i):",
            "        return self._history.itemAt(i)",
            "",
            "    def _go_to_item(self, item):",
            "        self._tab.predicted_navigation.emit(item.url())",
            "        self._history.goToItem(item)",
            "",
            "    def serialize(self):",
            "        if not qtutils.version_check('5.9', compiled=False):",
            "            # WORKAROUND for",
            "            # https://github.com/qutebrowser/qutebrowser/issues/2289",
            "            # Don't use the history's currentItem here, because of",
            "            # https://bugreports.qt.io/browse/QTBUG-59599 and because it doesn't",
            "            # contain view-source.",
            "            scheme = self._tab.url().scheme()",
            "            if scheme in ['view-source', 'chrome']:",
            "                raise browsertab.WebTabError(\"Can't serialize special URL!\")",
            "        return qtutils.serialize(self._history)",
            "",
            "    def deserialize(self, data):",
            "        return qtutils.deserialize(data, self._history)",
            "",
            "    def load_items(self, items):",
            "        if items:",
            "            self._tab.predicted_navigation.emit(items[-1].url)",
            "",
            "        stream, _data, cur_data = tabhistory.serialize(items)",
            "        qtutils.deserialize_stream(stream, self._history)",
            "",
            "        @pyqtSlot()",
            "        def _on_load_finished():",
            "            self._tab.scroller.to_point(cur_data['scroll-pos'])",
            "            self._tab.load_finished.disconnect(_on_load_finished)",
            "",
            "        if cur_data is not None:",
            "            if 'zoom' in cur_data:",
            "                self._tab.zoom.set_factor(cur_data['zoom'])",
            "            if ('scroll-pos' in cur_data and",
            "                    self._tab.scroller.pos_px() == QPoint(0, 0)):",
            "                self._tab.load_finished.connect(_on_load_finished)",
            "",
            "",
            "class WebEngineZoom(browsertab.AbstractZoom):",
            "",
            "    \"\"\"QtWebEngine implementations related to zooming.\"\"\"",
            "",
            "    def _set_factor_internal(self, factor):",
            "        self._widget.setZoomFactor(factor)",
            "",
            "",
            "class WebEngineElements(browsertab.AbstractElements):",
            "",
            "    \"\"\"QtWebEngine implemementations related to elements on the page.\"\"\"",
            "",
            "    def _js_cb_multiple(self, callback, js_elems):",
            "        \"\"\"Handle found elements coming from JS and call the real callback.",
            "",
            "        Args:",
            "            callback: The callback to call with the found elements.",
            "                      Called with None if there was an error.",
            "            js_elems: The elements serialized from javascript.",
            "        \"\"\"",
            "        if js_elems is None:",
            "            callback(None)",
            "            return",
            "",
            "        elems = []",
            "        for js_elem in js_elems:",
            "            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "            elems.append(elem)",
            "        callback(elems)",
            "",
            "    def _js_cb_single(self, callback, js_elem):",
            "        \"\"\"Handle a found focus elem coming from JS and call the real callback.",
            "",
            "        Args:",
            "            callback: The callback to call with the found element.",
            "                      Called with a WebEngineElement or None.",
            "            js_elem: The element serialized from javascript.",
            "        \"\"\"",
            "        debug_str = ('None' if js_elem is None",
            "                     else utils.elide(repr(js_elem), 1000))",
            "        log.webview.debug(\"Got element from JS: {}\".format(debug_str))",
            "",
            "        if js_elem is None:",
            "            callback(None)",
            "        else:",
            "            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "            callback(elem)",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        js_code = javascript.assemble('webelem', 'find_css', selector,",
            "                                      only_visible)",
            "        js_cb = functools.partial(self._js_cb_multiple, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_id(self, elem_id, callback):",
            "        js_code = javascript.assemble('webelem', 'find_id', elem_id)",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_focused(self, callback):",
            "        js_code = javascript.assemble('webelem', 'find_focused')",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        assert pos.x() >= 0",
            "        assert pos.y() >= 0",
            "        pos /= self._tab.zoom.factor()",
            "        js_code = javascript.assemble('webelem', 'find_at_pos',",
            "                                      pos.x(), pos.y())",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "",
            "class WebEngineAudio(browsertab.AbstractAudio):",
            "",
            "    \"\"\"QtWebEngine implemementations related to audio/muting.\"\"\"",
            "",
            "    def _connect_signals(self):",
            "        page = self._widget.page()",
            "        page.audioMutedChanged.connect(self.muted_changed)",
            "        page.recentlyAudibleChanged.connect(self.recently_audible_changed)",
            "",
            "    def set_muted(self, muted: bool):",
            "        page = self._widget.page()",
            "        page.setAudioMuted(muted)",
            "",
            "    def is_muted(self):",
            "        page = self._widget.page()",
            "        return page.isAudioMuted()",
            "",
            "    def is_recently_audible(self):",
            "        page = self._widget.page()",
            "        return page.recentlyAudible()",
            "",
            "",
            "class _WebEnginePermissions(QObject):",
            "",
            "    \"\"\"Handling of various permission-related signals.\"\"\"",
            "",
            "    _abort_questions = pyqtSignal()",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "",
            "    def connect_signals(self):",
            "        \"\"\"Connect related signals from the QWebEnginePage.\"\"\"",
            "        page = self._widget.page()",
            "        page.fullScreenRequested.connect(",
            "            self._on_fullscreen_requested)",
            "        page.featurePermissionRequested.connect(",
            "            self._on_feature_permission_requested)",
            "",
            "        if qtutils.version_check('5.11'):",
            "            page.quotaRequested.connect(",
            "                self._on_quota_requested)",
            "            page.registerProtocolHandlerRequested.connect(",
            "                self._on_register_protocol_handler_requested)",
            "",
            "        self._tab.shutting_down.connect(self._abort_questions)",
            "        self._tab.load_started.connect(self._abort_questions)",
            "",
            "    @pyqtSlot('QWebEngineFullScreenRequest')",
            "    def _on_fullscreen_requested(self, request):",
            "        request.accept()",
            "        on = request.toggleOn()",
            "",
            "        self._tab.data.fullscreen = on",
            "        self._tab.fullscreen_requested.emit(on)",
            "        if on:",
            "            notification = miscwidgets.FullscreenNotification(self._widget)",
            "            notification.show()",
            "            notification.set_timeout(3000)",
            "",
            "    @pyqtSlot(QUrl, 'QWebEnginePage::Feature')",
            "    def _on_feature_permission_requested(self, url, feature):",
            "        \"\"\"Ask the user for approval for geolocation/media/etc..\"\"\"",
            "        options = {",
            "            QWebEnginePage.Geolocation: 'content.geolocation',",
            "            QWebEnginePage.MediaAudioCapture: 'content.media_capture',",
            "            QWebEnginePage.MediaVideoCapture: 'content.media_capture',",
            "            QWebEnginePage.MediaAudioVideoCapture: 'content.media_capture',",
            "        }",
            "        messages = {",
            "            QWebEnginePage.Geolocation: 'access your location',",
            "            QWebEnginePage.MediaAudioCapture: 'record audio',",
            "            QWebEnginePage.MediaVideoCapture: 'record video',",
            "            QWebEnginePage.MediaAudioVideoCapture: 'record audio/video',",
            "        }",
            "        try:",
            "            options.update({",
            "                QWebEnginePage.DesktopVideoCapture:",
            "                    'content.desktop_capture',",
            "                QWebEnginePage.DesktopAudioVideoCapture:",
            "                    'content.desktop_capture',",
            "            })",
            "            messages.update({",
            "                QWebEnginePage.DesktopVideoCapture:",
            "                    'capture your desktop',",
            "                QWebEnginePage.DesktopAudioVideoCapture:",
            "                    'capture your desktop and audio',",
            "            })",
            "        except AttributeError:",
            "            # Added in Qt 5.10",
            "            pass",
            "",
            "        assert options.keys() == messages.keys()",
            "",
            "        page = self._widget.page()",
            "",
            "        if feature not in options:",
            "            log.webview.error(\"Unhandled feature permission {}\".format(",
            "                debug.qenum_key(QWebEnginePage, feature)))",
            "            page.setFeaturePermission(url, feature,",
            "                                      QWebEnginePage.PermissionDeniedByUser)",
            "            return",
            "",
            "        yes_action = functools.partial(",
            "            page.setFeaturePermission, url, feature,",
            "            QWebEnginePage.PermissionGrantedByUser)",
            "        no_action = functools.partial(",
            "            page.setFeaturePermission, url, feature,",
            "            QWebEnginePage.PermissionDeniedByUser)",
            "",
            "        question = shared.feature_permission(",
            "            url=url, option=options[feature], msg=messages[feature],",
            "            yes_action=yes_action, no_action=no_action,",
            "            abort_on=[self._abort_questions])",
            "",
            "        if question is not None:",
            "            page.featurePermissionRequestCanceled.connect(",
            "                functools.partial(self._on_feature_permission_cancelled,",
            "                                  question, url, feature))",
            "",
            "    def _on_feature_permission_cancelled(self, question, url, feature,",
            "                                         cancelled_url, cancelled_feature):",
            "        \"\"\"Slot invoked when a feature permission request was cancelled.",
            "",
            "        To be used with functools.partial.",
            "        \"\"\"",
            "        if url == cancelled_url and feature == cancelled_feature:",
            "            try:",
            "                question.abort()",
            "            except RuntimeError:",
            "                # The question could already be deleted, e.g. because it was",
            "                # aborted after a loadStarted signal.",
            "                pass",
            "",
            "    def _on_quota_requested(self, request):",
            "        size = utils.format_size(request.requestedSize())",
            "        shared.feature_permission(",
            "            url=request.origin(),",
            "            option='content.persistent_storage',",
            "            msg='use {} of persistent storage'.format(size),",
            "            yes_action=request.accept, no_action=request.reject,",
            "            abort_on=[self._abort_questions],",
            "            blocking=True)",
            "",
            "    def _on_register_protocol_handler_requested(self, request):",
            "        shared.feature_permission(",
            "            url=request.origin(),",
            "            option='content.register_protocol_handler',",
            "            msg='open all {} links'.format(request.scheme()),",
            "            yes_action=request.accept, no_action=request.reject,",
            "            abort_on=[self._abort_questions],",
            "            blocking=True)",
            "",
            "",
            "class _WebEngineScripts(QObject):",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self._greasemonkey = objreg.get('greasemonkey')",
            "",
            "    def connect_signals(self):",
            "        config.instance.changed.connect(self._on_config_changed)",
            "",
            "    @pyqtSlot(str)",
            "    def _on_config_changed(self, option):",
            "        if option in ['scrolling.bar', 'content.user_stylesheets']:",
            "            self._init_stylesheet()",
            "            self._update_stylesheet()",
            "",
            "    def _update_stylesheet(self):",
            "        \"\"\"Update the custom stylesheet in existing tabs.\"\"\"",
            "        css = shared.get_user_stylesheet()",
            "        code = javascript.assemble('stylesheet', 'set_css', css)",
            "        self._tab.run_js_async(code)",
            "",
            "    def _inject_early_js(self, name, js_code, *,",
            "                         world=QWebEngineScript.ApplicationWorld,",
            "                         subframes=False):",
            "        \"\"\"Inject the given script to run early on a page load.",
            "",
            "        This runs the script both on DocumentCreation and DocumentReady as on",
            "        some internal pages, DocumentCreation will not work.",
            "",
            "        That is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66011",
            "        \"\"\"",
            "        scripts = self._widget.page().scripts()",
            "        for injection in ['creation', 'ready']:",
            "            injection_points = {",
            "                'creation': QWebEngineScript.DocumentCreation,",
            "                'ready': QWebEngineScript.DocumentReady,",
            "            }",
            "            script = QWebEngineScript()",
            "            script.setInjectionPoint(injection_points[injection])",
            "            script.setSourceCode(js_code)",
            "            script.setWorldId(world)",
            "            script.setRunsOnSubFrames(subframes)",
            "            script.setName('_qute_{}_{}'.format(name, injection))",
            "            scripts.insert(script)",
            "",
            "    def _remove_early_js(self, name):",
            "        \"\"\"Remove an early QWebEngineScript.\"\"\"",
            "        scripts = self._widget.page().scripts()",
            "        for injection in ['creation', 'ready']:",
            "            full_name = '_qute_{}_{}'.format(name, injection)",
            "            script = scripts.findScript(full_name)",
            "            if not script.isNull():",
            "                scripts.remove(script)",
            "",
            "    def init(self):",
            "        \"\"\"Initialize global qutebrowser JavaScript.\"\"\"",
            "        js_code = javascript.wrap_global(",
            "            'scripts',",
            "            utils.read_file('javascript/scroll.js'),",
            "            utils.read_file('javascript/webelem.js'),",
            "            utils.read_file('javascript/caret.js'),",
            "        )",
            "        self._inject_early_js('js',",
            "                              utils.read_file('javascript/print.js'),",
            "                              subframes=True,",
            "                              world=QWebEngineScript.MainWorld)",
            "        # FIXME:qtwebengine what about subframes=True?",
            "        self._inject_early_js('js', js_code, subframes=True)",
            "        self._init_stylesheet()",
            "",
            "        # The Greasemonkey metadata block support in QtWebEngine only starts at",
            "        # Qt 5.8. With 5.7.1, we need to inject the scripts ourselves in",
            "        # response to urlChanged.",
            "        if not qtutils.version_check('5.8'):",
            "            self._tab.url_changed.connect(",
            "                self._inject_greasemonkey_scripts_for_url)",
            "        else:",
            "            self._greasemonkey.scripts_reloaded.connect(",
            "                self._inject_all_greasemonkey_scripts)",
            "            self._inject_all_greasemonkey_scripts()",
            "",
            "    def _init_stylesheet(self):",
            "        \"\"\"Initialize custom stylesheets.",
            "",
            "        Partially inspired by QupZilla:",
            "        https://github.com/QupZilla/qupzilla/blob/v2.0/src/lib/app/mainapplication.cpp#L1063-L1101",
            "        \"\"\"",
            "        self._remove_early_js('stylesheet')",
            "        css = shared.get_user_stylesheet()",
            "        js_code = javascript.wrap_global(",
            "            'stylesheet',",
            "            utils.read_file('javascript/stylesheet.js'),",
            "            javascript.assemble('stylesheet', 'set_css', css),",
            "        )",
            "        self._inject_early_js('stylesheet', js_code, subframes=True)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _inject_greasemonkey_scripts_for_url(self, url):",
            "        matching_scripts = self._greasemonkey.scripts_for(url)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.start, QWebEngineScript.DocumentCreation, True)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.end, QWebEngineScript.DocumentReady, False)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.idle, QWebEngineScript.Deferred, False)",
            "",
            "    @pyqtSlot()",
            "    def _inject_all_greasemonkey_scripts(self):",
            "        scripts = self._greasemonkey.all_scripts()",
            "        self._inject_greasemonkey_scripts(scripts)",
            "",
            "    def _inject_greasemonkey_scripts(self, scripts=None, injection_point=None,",
            "                                     remove_first=True):",
            "        \"\"\"Register user JavaScript files with the current tab.",
            "",
            "        Args:",
            "            scripts: A list of GreasemonkeyScripts, or None to add all",
            "                     known by the Greasemonkey subsystem.",
            "            injection_point: The QWebEngineScript::InjectionPoint stage",
            "                             to inject the script into, None to use",
            "                             auto-detection.",
            "            remove_first: Whether to remove all previously injected",
            "                          scripts before adding these ones.",
            "        \"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            return",
            "",
            "        # Since we are inserting scripts into a per-tab collection,",
            "        # rather than just injecting scripts on page load, we need to",
            "        # make sure we replace existing scripts, not just add new ones.",
            "        # While, taking care not to remove any other scripts that might",
            "        # have been added elsewhere, like the one for stylesheets.",
            "        page_scripts = self._widget.page().scripts()",
            "        if remove_first:",
            "            for script in page_scripts.toList():",
            "                if script.name().startswith(\"GM-\"):",
            "                    log.greasemonkey.debug('Removing script: {}'",
            "                                           .format(script.name()))",
            "                    removed = page_scripts.remove(script)",
            "                    assert removed, script.name()",
            "",
            "        if not scripts:",
            "            return",
            "",
            "        for script in scripts:",
            "            new_script = QWebEngineScript()",
            "            try:",
            "                world = int(script.jsworld)",
            "            except ValueError:",
            "                try:",
            "                    world = _JS_WORLD_MAP[usertypes.JsWorld[",
            "                        script.jsworld.lower()]]",
            "                except KeyError:",
            "                    log.greasemonkey.error(",
            "                        \"script {} has invalid value for '@qute-js-world'\"",
            "                        \": {}\".format(script.name, script.jsworld))",
            "                    continue",
            "            new_script.setWorldId(world)",
            "            new_script.setSourceCode(script.code())",
            "            new_script.setName(\"GM-{}\".format(script.name))",
            "            new_script.setRunsOnSubFrames(script.runs_on_sub_frames)",
            "            # Override the @run-at value parsed by QWebEngineScript if desired.",
            "            if injection_point:",
            "                new_script.setInjectionPoint(injection_point)",
            "            log.greasemonkey.debug('adding script: {}'",
            "                                   .format(new_script.name()))",
            "            page_scripts.insert(new_script)",
            "",
            "",
            "class WebEngineTab(browsertab.AbstractTab):",
            "",
            "    \"\"\"A QtWebEngine tab in the browser.",
            "",
            "    Signals:",
            "        _load_finished_fake:",
            "            Used in place of unreliable loadFinished",
            "    \"\"\"",
            "",
            "    # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223",
            "    _load_finished_fake = pyqtSignal(bool)",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        super().__init__(win_id=win_id, mode_manager=mode_manager,",
            "                         private=private, parent=parent)",
            "        widget = webview.WebEngineView(tabdata=self.data, win_id=win_id,",
            "                                       private=private)",
            "        self.history = WebEngineHistory(self)",
            "        self.scroller = WebEngineScroller(self, parent=self)",
            "        self.caret = WebEngineCaret(mode_manager=mode_manager,",
            "                                    tab=self, parent=self)",
            "        self.zoom = WebEngineZoom(tab=self, parent=self)",
            "        self.search = WebEngineSearch(parent=self)",
            "        self.printing = WebEnginePrinting(tab=self)",
            "        self.elements = WebEngineElements(tab=self)",
            "        self.action = WebEngineAction(tab=self)",
            "        self.audio = WebEngineAudio(parent=self)",
            "        self._permissions = _WebEnginePermissions(tab=self, parent=self)",
            "        self._scripts = _WebEngineScripts(tab=self, parent=self)",
            "        # We're assigning settings in _set_widget",
            "        self.settings = webenginesettings.WebEngineSettings(settings=None)",
            "        self._set_widget(widget)",
            "        self._connect_signals()",
            "        self.backend = usertypes.Backend.QtWebEngine",
            "        self._child_event_filter = None",
            "        self._saved_zoom = None",
            "        self._reload_url = None",
            "        self._scripts.init()",
            "",
            "    def _set_widget(self, widget):",
            "        # pylint: disable=protected-access",
            "        super()._set_widget(widget)",
            "        self._permissions._widget = widget",
            "        self._scripts._widget = widget",
            "",
            "    def _install_event_filter(self):",
            "        fp = self._widget.focusProxy()",
            "        if fp is not None:",
            "            fp.installEventFilter(self._mouse_event_filter)",
            "        self._child_event_filter = mouse.ChildEventFilter(",
            "            eventfilter=self._mouse_event_filter, widget=self._widget,",
            "            win_id=self.win_id, parent=self)",
            "        self._widget.installEventFilter(self._child_event_filter)",
            "",
            "    @pyqtSlot()",
            "    def _restore_zoom(self):",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3498",
            "            return",
            "        if self._saved_zoom is None:",
            "            return",
            "        self.zoom.set_factor(self._saved_zoom)",
            "        self._saved_zoom = None",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        \"\"\"Open the given URL in this tab.",
            "",
            "        Arguments:",
            "            url: The QUrl to open.",
            "            predict: If set to False, predicted_navigation is not emitted.",
            "        \"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3896",
            "            return",
            "        self._saved_zoom = self.zoom.factor()",
            "        self._openurl_prepare(url, predict=predict)",
            "        self._widget.load(url)",
            "",
            "    def url(self, requested=False):",
            "        page = self._widget.page()",
            "        if requested:",
            "            return page.requestedUrl()",
            "        else:",
            "            return page.url()",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        if plain:",
            "            self._widget.page().toPlainText(callback)",
            "        else:",
            "            self._widget.page().toHtml(callback)",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        if world is None:",
            "            world_id = QWebEngineScript.ApplicationWorld",
            "        elif isinstance(world, int):",
            "            world_id = world",
            "        else:",
            "            world_id = _JS_WORLD_MAP[world]",
            "",
            "        if callback is None:",
            "            self._widget.page().runJavaScript(code, world_id)",
            "        else:",
            "            self._widget.page().runJavaScript(code, world_id, callback)",
            "",
            "    def shutdown(self):",
            "        self.shutting_down.emit()",
            "        self.action.exit_fullscreen()",
            "        self._widget.shutdown()",
            "",
            "    def reload(self, *, force=False):",
            "        if force:",
            "            action = QWebEnginePage.ReloadAndBypassCache",
            "        else:",
            "            action = QWebEnginePage.Reload",
            "        self._widget.triggerPageAction(action)",
            "",
            "    def stop(self):",
            "        self._widget.stop()",
            "",
            "    def title(self):",
            "        return self._widget.title()",
            "",
            "    def icon(self):",
            "        return self._widget.icon()",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        # FIXME:qtwebengine",
            "        # check this and raise an exception if too big:",
            "        # Warning: The content will be percent encoded before being sent to the",
            "        # renderer via IPC. This may increase its size. The maximum size of the",
            "        # percent encoded content is 2 megabytes minus 30 bytes.",
            "        self._widget.setHtml(html, base_url)",
            "",
            "    def networkaccessmanager(self):",
            "        return None",
            "",
            "    def user_agent(self):",
            "        return None",
            "",
            "    def clear_ssl_errors(self):",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)",
            "        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,",
            "                                0, 0, 0)",
            "        self.send_event(press_evt)",
            "        self.send_event(release_evt)",
            "",
            "    def _show_error_page(self, url, error):",
            "        \"\"\"Show an error page in the tab.\"\"\"",
            "        log.misc.debug(\"Showing error page for {}\".format(error))",
            "        url_string = url.toDisplayString()",
            "        error_page = jinja.render(",
            "            'error.html',",
            "            title=\"Error loading page: {}\".format(url_string),",
            "            url=url_string, error=error)",
            "        self.set_html(error_page)",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        try:",
            "            self._widget.page()",
            "        except RuntimeError:",
            "            # Looks like this slot can be triggered on destroyed tabs:",
            "            # https://crashes.qutebrowser.org/view/3abffbed (Qt 5.9.1)",
            "            # wrapped C/C++ object of type WebEngineView has been deleted",
            "            log.misc.debug(\"Ignoring history trigger for destroyed tab\")",
            "            return",
            "",
            "        url = self.url()",
            "        requested_url = self.url(requested=True)",
            "",
            "        # Don't save the title if it's generated from the URL",
            "        title = self.title()",
            "        title_url = QUrl(url)",
            "        title_url.setScheme('')",
            "        if title == title_url.toDisplayString(QUrl.RemoveScheme).strip('/'):",
            "            title = \"\"",
            "",
            "        # Don't add history entry if the URL is invalid anyways",
            "        if not url.isValid():",
            "            log.misc.debug(\"Ignoring invalid URL being added to history\")",
            "            return",
            "",
            "        self.add_history_item.emit(url, requested_url, title)",
            "",
            "    @pyqtSlot(QUrl, 'QAuthenticator*', 'QString')",
            "    def _on_proxy_authentication_required(self, url, authenticator,",
            "                                          proxy_host):",
            "        \"\"\"Called when a proxy needs authentication.\"\"\"",
            "        msg = \"<b>{}</b> requires a username and password.\".format(",
            "            html_utils.escape(proxy_host))",
            "        urlstr = url.toString(QUrl.RemovePassword | QUrl.FullyEncoded)",
            "        answer = message.ask(",
            "            title=\"Proxy authentication required\", text=msg,",
            "            mode=usertypes.PromptMode.user_pwd,",
            "            abort_on=[self.shutting_down, self.load_started], url=urlstr)",
            "        if answer is not None:",
            "            authenticator.setUser(answer.user)",
            "            authenticator.setPassword(answer.password)",
            "        else:",
            "            try:",
            "                # pylint: disable=no-member, useless-suppression",
            "                sip.assign(authenticator, QAuthenticator())",
            "                # pylint: enable=no-member, useless-suppression",
            "            except AttributeError:",
            "                self._show_error_page(url, \"Proxy authentication required\")",
            "",
            "    @pyqtSlot(QUrl, 'QAuthenticator*')",
            "    def _on_authentication_required(self, url, authenticator):",
            "        netrc_success = False",
            "        if not self.data.netrc_used:",
            "            self.data.netrc_used = True",
            "            netrc_success = shared.netrc_authentication(url, authenticator)",
            "        if not netrc_success:",
            "            abort_on = [self.shutting_down, self.load_started]",
            "            answer = shared.authentication_required(url, authenticator,",
            "                                                    abort_on)",
            "        if not netrc_success and answer is None:",
            "            try:",
            "                # pylint: disable=no-member, useless-suppression",
            "                sip.assign(authenticator, QAuthenticator())",
            "                # pylint: enable=no-member, useless-suppression",
            "            except AttributeError:",
            "                # WORKAROUND for",
            "                # https://www.riverbankcomputing.com/pipermail/pyqt/2016-December/038400.html",
            "                self._show_error_page(url, \"Authentication required\")",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        \"\"\"Clear search when a new load is started if needed.\"\"\"",
            "        # WORKAROUND for",
            "        # https://bugreports.qt.io/browse/QTBUG-61506",
            "        # (seems to be back in later Qt versions as well)",
            "        self.search.clear()",
            "        super()._on_load_started()",
            "        self.data.netrc_used = False",
            "",
            "    @pyqtSlot(QWebEnginePage.RenderProcessTerminationStatus, int)",
            "    def _on_render_process_terminated(self, status, exitcode):",
            "        \"\"\"Show an error when the renderer process terminated.\"\"\"",
            "        if (status == QWebEnginePage.AbnormalTerminationStatus and",
            "                exitcode == 256):",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-58697",
            "            status = QWebEnginePage.CrashedTerminationStatus",
            "",
            "        status_map = {",
            "            QWebEnginePage.NormalTerminationStatus:",
            "                browsertab.TerminationStatus.normal,",
            "            QWebEnginePage.AbnormalTerminationStatus:",
            "                browsertab.TerminationStatus.abnormal,",
            "            QWebEnginePage.CrashedTerminationStatus:",
            "                browsertab.TerminationStatus.crashed,",
            "            QWebEnginePage.KilledTerminationStatus:",
            "                browsertab.TerminationStatus.killed,",
            "            -1:",
            "                browsertab.TerminationStatus.unknown,",
            "        }",
            "        self.renderer_process_terminated.emit(status_map[status], exitcode)",
            "",
            "    @pyqtSlot(int)",
            "    def _on_load_progress_workaround(self, perc):",
            "        \"\"\"Use loadProgress(100) to emit loadFinished(True).",
            "",
            "        See https://bugreports.qt.io/browse/QTBUG-65223",
            "        \"\"\"",
            "        if perc == 100 and self.load_status() != usertypes.LoadStatus.error:",
            "            self._load_finished_fake.emit(True)",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished_workaround(self, ok):",
            "        \"\"\"Use only loadFinished(False).",
            "",
            "        See https://bugreports.qt.io/browse/QTBUG-65223",
            "        \"\"\"",
            "        if not ok:",
            "            self._load_finished_fake.emit(False)",
            "",
            "    def _error_page_workaround(self, html):",
            "        \"\"\"Check if we're displaying a Chromium error page.",
            "",
            "        This gets only called if we got loadFinished(False) without JavaScript,",
            "        so we can display at least some error page.",
            "",
            "        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66643",
            "        Needs to check the page content as a WORKAROUND for",
            "        https://bugreports.qt.io/browse/QTBUG-66661",
            "        \"\"\"",
            "        match = re.search(r'\"errorCode\":\"([^\"]*)\"', html)",
            "        if match is None:",
            "            return",
            "        self._show_error_page(self.url(), error=match.group(1))",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished(self, ok):",
            "        \"\"\"Display a static error page if JavaScript is disabled.\"\"\"",
            "        super()._on_load_finished(ok)",
            "        js_enabled = self.settings.test_attribute('content.javascript.enabled')",
            "        if not ok and not js_enabled:",
            "            self.dump_async(self._error_page_workaround)",
            "",
            "        if ok and self._reload_url is not None:",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "            log.config.debug(",
            "                \"Loading {} again because of config change\".format(",
            "                    self._reload_url.toDisplayString()))",
            "            QTimer.singleShot(100, functools.partial(self.openurl,",
            "                                                     self._reload_url,",
            "                                                     predict=False))",
            "            self._reload_url = None",
            "",
            "        if not qtutils.version_check('5.10', compiled=False):",
            "            # We can't do this when we have the loadFinished workaround as that",
            "            # sometimes clears icons without loading a new page.",
            "            # In general, this is handled by Qt, but when loading takes long,",
            "            # the old icon is still displayed.",
            "            self.icon_changed.emit(QIcon())",
            "",
            "    @pyqtSlot(certificateerror.CertificateErrorWrapper)",
            "    def _on_ssl_errors(self, error):",
            "        self._has_ssl_errors = True",
            "",
            "        url = error.url()",
            "        log.webview.debug(\"Certificate error: {}\".format(error))",
            "",
            "        if error.is_overridable():",
            "            error.ignore = shared.ignore_certificate_errors(",
            "                url, [error], abort_on=[self.shutting_down, self.load_started])",
            "        else:",
            "            log.webview.error(\"Non-overridable certificate error: \"",
            "                              \"{}\".format(error))",
            "",
            "        log.webview.debug(\"ignore {}, URL {}, requested {}\".format(",
            "            error.ignore, url, self.url(requested=True)))",
            "",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-56207",
            "        # We can't really know when to show an error page, as the error might",
            "        # have happened when loading some resource.",
            "        # However, self.url() is not available yet and the requested URL",
            "        # might not match the URL we get from the error - so we just apply a",
            "        # heuristic here.",
            "        if (not qtutils.version_check('5.9') and",
            "                not error.ignore and",
            "                url.matches(self.url(requested=True), QUrl.RemoveScheme)):",
            "            self._show_error_page(url, str(error))",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_predicted_navigation(self, url):",
            "        \"\"\"If we know we're going to visit an URL soon, change the settings.",
            "",
            "        This is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "        \"\"\"",
            "        super()._on_predicted_navigation(url)",
            "        if not qtutils.version_check('5.11.1', compiled=False):",
            "            self.settings.update_for_url(url)",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        super()._on_navigation_request(navigation)",
            "",
            "        if navigation.url == QUrl('qute://print'):",
            "            try:",
            "                self.printing.show_dialog()",
            "            except browsertab.WebTabError as e:",
            "                message.error(str(e))",
            "            navigation.accepted = False",
            "",
            "        if not navigation.accepted or not navigation.is_main_frame:",
            "            return",
            "",
            "        settings_needing_reload = {",
            "            'content.plugins',",
            "            'content.javascript.enabled',",
            "            'content.javascript.can_access_clipboard',",
            "            'content.print_element_backgrounds',",
            "            'input.spatial_navigation',",
            "        }",
            "        assert settings_needing_reload.issubset(configdata.DATA)",
            "",
            "        changed = self.settings.update_for_url(navigation.url)",
            "        reload_needed = changed & settings_needing_reload",
            "",
            "        # On Qt < 5.11, we don't don't need a reload when type == link_clicked.",
            "        # On Qt 5.11.0, we always need a reload.",
            "        # On Qt > 5.11.0, we never need a reload:",
            "        # https://codereview.qt-project.org/#/c/229525/1",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "        if qtutils.version_check('5.11.1', compiled=False):",
            "            reload_needed = False",
            "        elif not qtutils.version_check('5.11.0', exact=True, compiled=False):",
            "            if navigation.navigation_type == navigation.Type.link_clicked:",
            "                reload_needed = False",
            "",
            "        if reload_needed:",
            "            self._reload_url = navigation.url",
            "",
            "    def _connect_signals(self):",
            "        view = self._widget",
            "        page = view.page()",
            "",
            "        page.windowCloseRequested.connect(self.window_close_requested)",
            "        page.linkHovered.connect(self.link_hovered)",
            "        page.loadProgress.connect(self._on_load_progress)",
            "        page.loadStarted.connect(self._on_load_started)",
            "        page.certificate_error.connect(self._on_ssl_errors)",
            "        page.authenticationRequired.connect(self._on_authentication_required)",
            "        page.proxyAuthenticationRequired.connect(",
            "            self._on_proxy_authentication_required)",
            "        page.contentsSizeChanged.connect(self.contents_size_changed)",
            "        page.navigation_request.connect(self._on_navigation_request)",
            "",
            "        view.titleChanged.connect(self.title_changed)",
            "        view.urlChanged.connect(self._on_url_changed)",
            "        view.renderProcessTerminated.connect(",
            "            self._on_render_process_terminated)",
            "        view.iconChanged.connect(self.icon_changed)",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223",
            "        if qtutils.version_check('5.10', compiled=False):",
            "            page.loadProgress.connect(self._on_load_progress_workaround)",
            "            self._load_finished_fake.connect(self._on_history_trigger)",
            "            self._load_finished_fake.connect(self._restore_zoom)",
            "            self._load_finished_fake.connect(self._on_load_finished)",
            "            page.loadFinished.connect(self._on_load_finished_workaround)",
            "        else:",
            "            # for older Qt versions which break with the above",
            "            page.loadProgress.connect(self._on_load_progress)",
            "            page.loadFinished.connect(self._on_history_trigger)",
            "            page.loadFinished.connect(self._restore_zoom)",
            "            page.loadFinished.connect(self._on_load_finished)",
            "",
            "        self.predicted_navigation.connect(self._on_predicted_navigation)",
            "",
            "        # pylint: disable=protected-access",
            "        self.audio._connect_signals()",
            "        self._permissions.connect_signals()",
            "        self._scripts.connect_signals()",
            "",
            "    def event_target(self):",
            "        return self._widget.render_widget()"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Wrapper over a QWebEngineView.\"\"\"",
            "",
            "import math",
            "import functools",
            "import sys",
            "import re",
            "import html as html_utils",
            "",
            "from PyQt5.QtCore import (pyqtSignal, pyqtSlot, Qt, QEvent, QPoint, QPointF,",
            "                          QUrl, QTimer, QObject, qVersion)",
            "from PyQt5.QtGui import QKeyEvent, QIcon",
            "from PyQt5.QtNetwork import QAuthenticator",
            "from PyQt5.QtWidgets import QApplication",
            "from PyQt5.QtWebEngineWidgets import QWebEnginePage, QWebEngineScript",
            "",
            "from qutebrowser.config import configdata, config",
            "from qutebrowser.browser import browsertab, mouse, shared, webelem",
            "from qutebrowser.browser.webengine import (webview, webengineelem, tabhistory,",
            "                                           interceptor, webenginequtescheme,",
            "                                           cookies, webenginedownloads,",
            "                                           webenginesettings, certificateerror)",
            "from qutebrowser.misc import miscwidgets",
            "from qutebrowser.utils import (usertypes, qtutils, log, javascript, utils,",
            "                               message, objreg, jinja, debug)",
            "from qutebrowser.qt import sip",
            "",
            "",
            "_qute_scheme_handler = None",
            "",
            "",
            "def init():",
            "    \"\"\"Initialize QtWebEngine-specific modules.\"\"\"",
            "    # For some reason we need to keep a reference, otherwise the scheme handler",
            "    # won't work...",
            "    # https://www.riverbankcomputing.com/pipermail/pyqt/2016-September/038075.html",
            "    global _qute_scheme_handler",
            "",
            "    app = QApplication.instance()",
            "    log.init.debug(\"Initializing qute://* handler...\")",
            "    _qute_scheme_handler = webenginequtescheme.QuteSchemeHandler(parent=app)",
            "    _qute_scheme_handler.install(webenginesettings.default_profile)",
            "    _qute_scheme_handler.install(webenginesettings.private_profile)",
            "",
            "    log.init.debug(\"Initializing request interceptor...\")",
            "    host_blocker = objreg.get('host-blocker')",
            "    args = objreg.get('args')",
            "    req_interceptor = interceptor.RequestInterceptor(",
            "        host_blocker, args=args, parent=app)",
            "    req_interceptor.install(webenginesettings.default_profile)",
            "    req_interceptor.install(webenginesettings.private_profile)",
            "",
            "    log.init.debug(\"Initializing QtWebEngine downloads...\")",
            "    download_manager = webenginedownloads.DownloadManager(parent=app)",
            "    download_manager.install(webenginesettings.default_profile)",
            "    download_manager.install(webenginesettings.private_profile)",
            "    objreg.register('webengine-download-manager', download_manager)",
            "",
            "    log.init.debug(\"Initializing cookie filter...\")",
            "    cookies.install_filter(webenginesettings.default_profile)",
            "    cookies.install_filter(webenginesettings.private_profile)",
            "",
            "    # Clear visited links on web history clear",
            "    hist = objreg.get('web-history')",
            "    for p in [webenginesettings.default_profile,",
            "              webenginesettings.private_profile]:",
            "        hist.history_cleared.connect(p.clearAllVisitedLinks)",
            "        hist.url_cleared.connect(lambda url, profile=p:",
            "                                 profile.clearVisitedLinks([url]))",
            "",
            "",
            "# Mapping worlds from usertypes.JsWorld to QWebEngineScript world IDs.",
            "_JS_WORLD_MAP = {",
            "    usertypes.JsWorld.main: QWebEngineScript.MainWorld,",
            "    usertypes.JsWorld.application: QWebEngineScript.ApplicationWorld,",
            "    usertypes.JsWorld.user: QWebEngineScript.UserWorld,",
            "    usertypes.JsWorld.jseval: QWebEngineScript.UserWorld + 1,",
            "}",
            "",
            "",
            "class WebEngineAction(browsertab.AbstractAction):",
            "",
            "    \"\"\"QtWebEngine implementations related to web actions.\"\"\"",
            "",
            "    action_class = QWebEnginePage",
            "    action_base = QWebEnginePage.WebAction",
            "",
            "    def exit_fullscreen(self):",
            "        self._widget.triggerPageAction(QWebEnginePage.ExitFullScreen)",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        self._widget.triggerPageAction(QWebEnginePage.SavePage)",
            "",
            "    def show_source(self, pygments=False):",
            "        if pygments:",
            "            self._show_source_pygments()",
            "            return",
            "",
            "        try:",
            "            self._widget.triggerPageAction(QWebEnginePage.ViewSource)",
            "        except AttributeError:",
            "            # Qt < 5.8",
            "            tb = objreg.get('tabbed-browser', scope='window',",
            "                            window=self._tab.win_id)",
            "            urlstr = self._tab.url().toString(QUrl.RemoveUserInfo)",
            "            # The original URL becomes the path of a view-source: URL",
            "            # (without a host), but query/fragment should stay.",
            "            url = QUrl('view-source:' + urlstr)",
            "            tb.tabopen(url, background=False, related=True)",
            "",
            "",
            "class WebEnginePrinting(browsertab.AbstractPrinting):",
            "",
            "    \"\"\"QtWebEngine implementations related to printing.\"\"\"",
            "",
            "    def check_pdf_support(self):",
            "        return True",
            "",
            "    def check_printer_support(self):",
            "        if not hasattr(self._widget.page(), 'print'):",
            "            raise browsertab.WebTabError(",
            "                \"Printing is unsupported with QtWebEngine on Qt < 5.8\")",
            "",
            "    def check_preview_support(self):",
            "        raise browsertab.WebTabError(",
            "            \"Print previews are unsupported with QtWebEngine\")",
            "",
            "    def to_pdf(self, filename):",
            "        self._widget.page().printToPdf(filename)",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        if callback is None:",
            "            callback = lambda _ok: None",
            "        self._widget.page().print(printer, callback)",
            "",
            "",
            "class WebEngineSearch(browsertab.AbstractSearch):",
            "",
            "    \"\"\"QtWebEngine implementations related to searching on the page.",
            "",
            "    Attributes:",
            "        _flags: The QWebEnginePage.FindFlags of the last search.",
            "        _pending_searches: How many searches have been started but not called",
            "                           back yet.",
            "    \"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._flags = QWebEnginePage.FindFlags(0)",
            "        self._pending_searches = 0",
            "",
            "    def _find(self, text, flags, callback, caller):",
            "        \"\"\"Call findText on the widget.\"\"\"",
            "        self.search_displayed = True",
            "        self._pending_searches += 1",
            "",
            "        def wrapped_callback(found):",
            "            \"\"\"Wrap the callback to do debug logging.\"\"\"",
            "            self._pending_searches -= 1",
            "            if self._pending_searches > 0:",
            "                # See https://github.com/qutebrowser/qutebrowser/issues/2442",
            "                # and https://github.com/qt/qtwebengine/blob/5.10/src/core/web_contents_adapter.cpp#L924-L934",
            "                log.webview.debug(\"Ignoring cancelled search callback with \"",
            "                                  \"{} pending searches\".format(",
            "                                      self._pending_searches))",
            "                return",
            "",
            "            found_text = 'found' if found else \"didn't find\"",
            "            if flags:",
            "                flag_text = 'with flags {}'.format(debug.qflags_key(",
            "                    QWebEnginePage, flags, klass=QWebEnginePage.FindFlag))",
            "            else:",
            "                flag_text = ''",
            "            log.webview.debug(' '.join([caller, found_text, text, flag_text])",
            "                              .strip())",
            "            if callback is not None:",
            "                callback(found)",
            "        self._widget.findText(text, flags, wrapped_callback)",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        # Don't go to next entry on duplicate search",
            "        if self.text == text and self.search_displayed:",
            "            log.webview.debug(\"Ignoring duplicate search request\"",
            "                              \" for {}\".format(text))",
            "            return",
            "",
            "        self.text = text",
            "        self._flags = QWebEnginePage.FindFlags(0)",
            "        if self._is_case_sensitive(ignore_case):",
            "            self._flags |= QWebEnginePage.FindCaseSensitively",
            "        if reverse:",
            "            self._flags |= QWebEnginePage.FindBackward",
            "",
            "        self._find(text, self._flags, result_cb, 'search')",
            "",
            "    def clear(self):",
            "        self.search_displayed = False",
            "        self._widget.findText('')",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        # The int() here makes sure we get a copy of the flags.",
            "        flags = QWebEnginePage.FindFlags(int(self._flags))",
            "        if flags & QWebEnginePage.FindBackward:",
            "            flags &= ~QWebEnginePage.FindBackward",
            "        else:",
            "            flags |= QWebEnginePage.FindBackward",
            "        self._find(self.text, flags, result_cb, 'prev_result')",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        self._find(self.text, self._flags, result_cb, 'next_result')",
            "",
            "",
            "class WebEngineCaret(browsertab.AbstractCaret):",
            "",
            "    \"\"\"QtWebEngine implementations related to moving the cursor/selection.\"\"\"",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_entered(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        if self._tab.search.search_displayed:",
            "            # We are currently in search mode.",
            "            # convert the search to a blue selection so we can operate on it",
            "            # https://bugreports.qt.io/browse/QTBUG-60673",
            "            self._tab.search.clear()",
            "",
            "        self._tab.run_js_async(",
            "            javascript.assemble('caret',",
            "                                'setPlatform', sys.platform, qVersion()))",
            "        self._js_call('setInitialCursor', self._selection_cb)",
            "",
            "    def _selection_cb(self, enabled):",
            "        \"\"\"Emit selection_toggled based on setInitialCursor.\"\"\"",
            "        if enabled is None:",
            "            log.webview.debug(\"Ignoring selection status None\")",
            "            return",
            "        self.selection_toggled.emit(enabled)",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_left(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        self.drop_selection()",
            "        self._js_call('disableCaret')",
            "",
            "    def move_to_next_line(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveDown')",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveUp')",
            "",
            "    def move_to_next_char(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveRight')",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveLeft')",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfWord')",
            "",
            "    def move_to_next_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToNextWord')",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToPreviousWord')",
            "",
            "    def move_to_start_of_line(self):",
            "        self._js_call('moveToStartOfLine')",
            "",
            "    def move_to_end_of_line(self):",
            "        self._js_call('moveToEndOfLine')",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToStartOfNextBlock')",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToStartOfPrevBlock')",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfNextBlock')",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        for _ in range(count):",
            "            self._js_call('moveToEndOfPrevBlock')",
            "",
            "    def move_to_start_of_document(self):",
            "        self._js_call('moveToStartOfDocument')",
            "",
            "    def move_to_end_of_document(self):",
            "        self._js_call('moveToEndOfDocument')",
            "",
            "    def toggle_selection(self):",
            "        self._js_call('toggleSelection', self.selection_toggled.emit)",
            "",
            "    def drop_selection(self):",
            "        self._js_call('dropSelection')",
            "",
            "    def selection(self, callback):",
            "        # Not using selectedText() as WORKAROUND for",
            "        # https://bugreports.qt.io/browse/QTBUG-53134",
            "        # Even on Qt 5.10 selectedText() seems to work poorly, see",
            "        # https://github.com/qutebrowser/qutebrowser/issues/3523",
            "        self._tab.run_js_async(javascript.assemble('caret', 'getSelection'),",
            "                               callback)",
            "",
            "    def _follow_selected_cb(self, js_elem, tab=False):",
            "        \"\"\"Callback for javascript which clicks the selected element.",
            "",
            "        Args:",
            "            js_elem: The element serialized from javascript.",
            "            tab: Open in a new tab.",
            "        \"\"\"",
            "        if js_elem is None:",
            "            return",
            "        if js_elem == \"focused\":",
            "            # we had a focused element, not a selected one. Just send <enter>",
            "            self._follow_enter(tab)",
            "            return",
            "",
            "        assert isinstance(js_elem, dict), js_elem",
            "        elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "        if tab:",
            "            click_type = usertypes.ClickTarget.tab",
            "        else:",
            "            click_type = usertypes.ClickTarget.normal",
            "",
            "        # Only click if we see a link",
            "        if elem.is_link():",
            "            log.webview.debug(\"Found link in selection, clicking. ClickTarget \"",
            "                              \"{}, elem {}\".format(click_type, elem))",
            "            try:",
            "                elem.click(click_type)",
            "            except webelem.Error as e:",
            "                message.error(str(e))",
            "                return",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        if self._tab.search.search_displayed:",
            "            # We are currently in search mode.",
            "            # let's click the link via a fake-click",
            "            # https://bugreports.qt.io/browse/QTBUG-60673",
            "            self._tab.search.clear()",
            "",
            "            log.webview.debug(\"Clicking a searched link via fake key press.\")",
            "            # send a fake enter, clicking the orange selection box",
            "            self._follow_enter(tab)",
            "        else:",
            "            # click an existing blue selection",
            "            js_code = javascript.assemble('webelem',",
            "                                          'find_selected_focused_link')",
            "            self._tab.run_js_async(js_code, lambda jsret:",
            "                                   self._follow_selected_cb(jsret, tab))",
            "",
            "    def _js_call(self, command, callback=None):",
            "        self._tab.run_js_async(javascript.assemble('caret', command), callback)",
            "",
            "",
            "class WebEngineScroller(browsertab.AbstractScroller):",
            "",
            "    \"\"\"QtWebEngine implementations related to scrolling.\"\"\"",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(tab, parent)",
            "        self._args = objreg.get('args')",
            "        self._pos_perc = (0, 0)",
            "        self._pos_px = QPoint()",
            "        self._at_bottom = False",
            "",
            "    def _init_widget(self, widget):",
            "        super()._init_widget(widget)",
            "        page = widget.page()",
            "        page.scrollPositionChanged.connect(self._update_pos)",
            "",
            "    def _repeated_key_press(self, key, count=1, modifier=Qt.NoModifier):",
            "        \"\"\"Send count fake key presses to this scroller's WebEngineTab.\"\"\"",
            "        for _ in range(min(count, 1000)):",
            "            self._tab.key_press(key, modifier)",
            "",
            "    @pyqtSlot(QPointF)",
            "    def _update_pos(self, pos):",
            "        \"\"\"Update the scroll position attributes when it changed.\"\"\"",
            "        self._pos_px = pos.toPoint()",
            "        contents_size = self._widget.page().contentsSize()",
            "",
            "        scrollable_x = contents_size.width() - self._widget.width()",
            "        if scrollable_x == 0:",
            "            perc_x = 0",
            "        else:",
            "            try:",
            "                perc_x = min(100, round(100 / scrollable_x * pos.x()))",
            "            except ValueError:",
            "                # https://github.com/qutebrowser/qutebrowser/issues/3219",
            "                log.misc.debug(\"Got ValueError!\")",
            "                log.misc.debug(\"contents_size.width(): {}\".format(",
            "                    contents_size.width()))",
            "                log.misc.debug(\"self._widget.width(): {}\".format(",
            "                    self._widget.width()))",
            "                log.misc.debug(\"scrollable_x: {}\".format(scrollable_x))",
            "                log.misc.debug(\"pos.x(): {}\".format(pos.x()))",
            "                raise",
            "",
            "        scrollable_y = contents_size.height() - self._widget.height()",
            "        if scrollable_y == 0:",
            "            perc_y = 0",
            "        else:",
            "            perc_y = min(100, round(100 / scrollable_y * pos.y()))",
            "",
            "        self._at_bottom = math.ceil(pos.y()) >= scrollable_y",
            "",
            "        if (self._pos_perc != (perc_x, perc_y) or",
            "                'no-scroll-filtering' in self._args.debug_flags):",
            "            self._pos_perc = perc_x, perc_y",
            "            self.perc_changed.emit(*self._pos_perc)",
            "",
            "    def pos_px(self):",
            "        return self._pos_px",
            "",
            "    def pos_perc(self):",
            "        return self._pos_perc",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        js_code = javascript.assemble('scroll', 'to_perc', x, y)",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def to_point(self, point):",
            "        js_code = javascript.assemble('window', 'scroll', point.x(), point.y())",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def to_anchor(self, name):",
            "        url = self._tab.url()",
            "        url.setFragment(name)",
            "        self._tab.openurl(url)",
            "",
            "    def delta(self, x=0, y=0):",
            "        self._tab.run_js_async(javascript.assemble('window', 'scrollBy', x, y))",
            "",
            "    def delta_page(self, x=0, y=0):",
            "        js_code = javascript.assemble('scroll', 'delta_page', x, y)",
            "        self._tab.run_js_async(js_code)",
            "",
            "    def up(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Up, count)",
            "",
            "    def down(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Down, count)",
            "",
            "    def left(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Left, count)",
            "",
            "    def right(self, count=1):",
            "        self._repeated_key_press(Qt.Key_Right, count)",
            "",
            "    def top(self):",
            "        self._tab.key_press(Qt.Key_Home)",
            "",
            "    def bottom(self):",
            "        self._tab.key_press(Qt.Key_End)",
            "",
            "    def page_up(self, count=1):",
            "        self._repeated_key_press(Qt.Key_PageUp, count)",
            "",
            "    def page_down(self, count=1):",
            "        self._repeated_key_press(Qt.Key_PageDown, count)",
            "",
            "    def at_top(self):",
            "        return self.pos_px().y() == 0",
            "",
            "    def at_bottom(self):",
            "        return self._at_bottom",
            "",
            "",
            "class WebEngineHistory(browsertab.AbstractHistory):",
            "",
            "    \"\"\"QtWebEngine implementations related to page history.\"\"\"",
            "",
            "    def current_idx(self):",
            "        return self._history.currentItemIndex()",
            "",
            "    def can_go_back(self):",
            "        return self._history.canGoBack()",
            "",
            "    def can_go_forward(self):",
            "        return self._history.canGoForward()",
            "",
            "    def _item_at(self, i):",
            "        return self._history.itemAt(i)",
            "",
            "    def _go_to_item(self, item):",
            "        self._tab.predicted_navigation.emit(item.url())",
            "        self._history.goToItem(item)",
            "",
            "    def serialize(self):",
            "        if not qtutils.version_check('5.9', compiled=False):",
            "            # WORKAROUND for",
            "            # https://github.com/qutebrowser/qutebrowser/issues/2289",
            "            # Don't use the history's currentItem here, because of",
            "            # https://bugreports.qt.io/browse/QTBUG-59599 and because it doesn't",
            "            # contain view-source.",
            "            scheme = self._tab.url().scheme()",
            "            if scheme in ['view-source', 'chrome']:",
            "                raise browsertab.WebTabError(\"Can't serialize special URL!\")",
            "        return qtutils.serialize(self._history)",
            "",
            "    def deserialize(self, data):",
            "        return qtutils.deserialize(data, self._history)",
            "",
            "    def load_items(self, items):",
            "        if items:",
            "            self._tab.predicted_navigation.emit(items[-1].url)",
            "",
            "        stream, _data, cur_data = tabhistory.serialize(items)",
            "        qtutils.deserialize_stream(stream, self._history)",
            "",
            "        @pyqtSlot()",
            "        def _on_load_finished():",
            "            self._tab.scroller.to_point(cur_data['scroll-pos'])",
            "            self._tab.load_finished.disconnect(_on_load_finished)",
            "",
            "        if cur_data is not None:",
            "            if 'zoom' in cur_data:",
            "                self._tab.zoom.set_factor(cur_data['zoom'])",
            "            if ('scroll-pos' in cur_data and",
            "                    self._tab.scroller.pos_px() == QPoint(0, 0)):",
            "                self._tab.load_finished.connect(_on_load_finished)",
            "",
            "",
            "class WebEngineZoom(browsertab.AbstractZoom):",
            "",
            "    \"\"\"QtWebEngine implementations related to zooming.\"\"\"",
            "",
            "    def _set_factor_internal(self, factor):",
            "        self._widget.setZoomFactor(factor)",
            "",
            "",
            "class WebEngineElements(browsertab.AbstractElements):",
            "",
            "    \"\"\"QtWebEngine implemementations related to elements on the page.\"\"\"",
            "",
            "    def _js_cb_multiple(self, callback, js_elems):",
            "        \"\"\"Handle found elements coming from JS and call the real callback.",
            "",
            "        Args:",
            "            callback: The callback to call with the found elements.",
            "                      Called with None if there was an error.",
            "            js_elems: The elements serialized from javascript.",
            "        \"\"\"",
            "        if js_elems is None:",
            "            callback(None)",
            "            return",
            "",
            "        elems = []",
            "        for js_elem in js_elems:",
            "            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "            elems.append(elem)",
            "        callback(elems)",
            "",
            "    def _js_cb_single(self, callback, js_elem):",
            "        \"\"\"Handle a found focus elem coming from JS and call the real callback.",
            "",
            "        Args:",
            "            callback: The callback to call with the found element.",
            "                      Called with a WebEngineElement or None.",
            "            js_elem: The element serialized from javascript.",
            "        \"\"\"",
            "        debug_str = ('None' if js_elem is None",
            "                     else utils.elide(repr(js_elem), 1000))",
            "        log.webview.debug(\"Got element from JS: {}\".format(debug_str))",
            "",
            "        if js_elem is None:",
            "            callback(None)",
            "        else:",
            "            elem = webengineelem.WebEngineElement(js_elem, tab=self._tab)",
            "            callback(elem)",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        js_code = javascript.assemble('webelem', 'find_css', selector,",
            "                                      only_visible)",
            "        js_cb = functools.partial(self._js_cb_multiple, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_id(self, elem_id, callback):",
            "        js_code = javascript.assemble('webelem', 'find_id', elem_id)",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_focused(self, callback):",
            "        js_code = javascript.assemble('webelem', 'find_focused')",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        assert pos.x() >= 0",
            "        assert pos.y() >= 0",
            "        pos /= self._tab.zoom.factor()",
            "        js_code = javascript.assemble('webelem', 'find_at_pos',",
            "                                      pos.x(), pos.y())",
            "        js_cb = functools.partial(self._js_cb_single, callback)",
            "        self._tab.run_js_async(js_code, js_cb)",
            "",
            "",
            "class WebEngineAudio(browsertab.AbstractAudio):",
            "",
            "    \"\"\"QtWebEngine implemementations related to audio/muting.\"\"\"",
            "",
            "    def _connect_signals(self):",
            "        page = self._widget.page()",
            "        page.audioMutedChanged.connect(self.muted_changed)",
            "        page.recentlyAudibleChanged.connect(self.recently_audible_changed)",
            "",
            "    def set_muted(self, muted: bool):",
            "        page = self._widget.page()",
            "        page.setAudioMuted(muted)",
            "",
            "    def is_muted(self):",
            "        page = self._widget.page()",
            "        return page.isAudioMuted()",
            "",
            "    def is_recently_audible(self):",
            "        page = self._widget.page()",
            "        return page.recentlyAudible()",
            "",
            "",
            "class _WebEnginePermissions(QObject):",
            "",
            "    \"\"\"Handling of various permission-related signals.\"\"\"",
            "",
            "    _abort_questions = pyqtSignal()",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "",
            "    def connect_signals(self):",
            "        \"\"\"Connect related signals from the QWebEnginePage.\"\"\"",
            "        page = self._widget.page()",
            "        page.fullScreenRequested.connect(",
            "            self._on_fullscreen_requested)",
            "        page.featurePermissionRequested.connect(",
            "            self._on_feature_permission_requested)",
            "",
            "        if qtutils.version_check('5.11'):",
            "            page.quotaRequested.connect(",
            "                self._on_quota_requested)",
            "            page.registerProtocolHandlerRequested.connect(",
            "                self._on_register_protocol_handler_requested)",
            "",
            "        self._tab.shutting_down.connect(self._abort_questions)",
            "        self._tab.load_started.connect(self._abort_questions)",
            "",
            "    @pyqtSlot('QWebEngineFullScreenRequest')",
            "    def _on_fullscreen_requested(self, request):",
            "        request.accept()",
            "        on = request.toggleOn()",
            "",
            "        self._tab.data.fullscreen = on",
            "        self._tab.fullscreen_requested.emit(on)",
            "        if on:",
            "            notification = miscwidgets.FullscreenNotification(self._widget)",
            "            notification.show()",
            "            notification.set_timeout(3000)",
            "",
            "    @pyqtSlot(QUrl, 'QWebEnginePage::Feature')",
            "    def _on_feature_permission_requested(self, url, feature):",
            "        \"\"\"Ask the user for approval for geolocation/media/etc..\"\"\"",
            "        options = {",
            "            QWebEnginePage.Geolocation: 'content.geolocation',",
            "            QWebEnginePage.MediaAudioCapture: 'content.media_capture',",
            "            QWebEnginePage.MediaVideoCapture: 'content.media_capture',",
            "            QWebEnginePage.MediaAudioVideoCapture: 'content.media_capture',",
            "        }",
            "        messages = {",
            "            QWebEnginePage.Geolocation: 'access your location',",
            "            QWebEnginePage.MediaAudioCapture: 'record audio',",
            "            QWebEnginePage.MediaVideoCapture: 'record video',",
            "            QWebEnginePage.MediaAudioVideoCapture: 'record audio/video',",
            "        }",
            "        try:",
            "            options.update({",
            "                QWebEnginePage.DesktopVideoCapture:",
            "                    'content.desktop_capture',",
            "                QWebEnginePage.DesktopAudioVideoCapture:",
            "                    'content.desktop_capture',",
            "            })",
            "            messages.update({",
            "                QWebEnginePage.DesktopVideoCapture:",
            "                    'capture your desktop',",
            "                QWebEnginePage.DesktopAudioVideoCapture:",
            "                    'capture your desktop and audio',",
            "            })",
            "        except AttributeError:",
            "            # Added in Qt 5.10",
            "            pass",
            "",
            "        assert options.keys() == messages.keys()",
            "",
            "        page = self._widget.page()",
            "",
            "        if feature not in options:",
            "            log.webview.error(\"Unhandled feature permission {}\".format(",
            "                debug.qenum_key(QWebEnginePage, feature)))",
            "            page.setFeaturePermission(url, feature,",
            "                                      QWebEnginePage.PermissionDeniedByUser)",
            "            return",
            "",
            "        yes_action = functools.partial(",
            "            page.setFeaturePermission, url, feature,",
            "            QWebEnginePage.PermissionGrantedByUser)",
            "        no_action = functools.partial(",
            "            page.setFeaturePermission, url, feature,",
            "            QWebEnginePage.PermissionDeniedByUser)",
            "",
            "        question = shared.feature_permission(",
            "            url=url, option=options[feature], msg=messages[feature],",
            "            yes_action=yes_action, no_action=no_action,",
            "            abort_on=[self._abort_questions])",
            "",
            "        if question is not None:",
            "            page.featurePermissionRequestCanceled.connect(",
            "                functools.partial(self._on_feature_permission_cancelled,",
            "                                  question, url, feature))",
            "",
            "    def _on_feature_permission_cancelled(self, question, url, feature,",
            "                                         cancelled_url, cancelled_feature):",
            "        \"\"\"Slot invoked when a feature permission request was cancelled.",
            "",
            "        To be used with functools.partial.",
            "        \"\"\"",
            "        if url == cancelled_url and feature == cancelled_feature:",
            "            try:",
            "                question.abort()",
            "            except RuntimeError:",
            "                # The question could already be deleted, e.g. because it was",
            "                # aborted after a loadStarted signal.",
            "                pass",
            "",
            "    def _on_quota_requested(self, request):",
            "        size = utils.format_size(request.requestedSize())",
            "        shared.feature_permission(",
            "            url=request.origin(),",
            "            option='content.persistent_storage',",
            "            msg='use {} of persistent storage'.format(size),",
            "            yes_action=request.accept, no_action=request.reject,",
            "            abort_on=[self._abort_questions],",
            "            blocking=True)",
            "",
            "    def _on_register_protocol_handler_requested(self, request):",
            "        shared.feature_permission(",
            "            url=request.origin(),",
            "            option='content.register_protocol_handler',",
            "            msg='open all {} links'.format(request.scheme()),",
            "            yes_action=request.accept, no_action=request.reject,",
            "            abort_on=[self._abort_questions],",
            "            blocking=True)",
            "",
            "",
            "class _WebEngineScripts(QObject):",
            "",
            "    def __init__(self, tab, parent=None):",
            "        super().__init__(parent)",
            "        self._tab = tab",
            "        self._widget = None",
            "        self._greasemonkey = objreg.get('greasemonkey')",
            "",
            "    def connect_signals(self):",
            "        config.instance.changed.connect(self._on_config_changed)",
            "",
            "    @pyqtSlot(str)",
            "    def _on_config_changed(self, option):",
            "        if option in ['scrolling.bar', 'content.user_stylesheets']:",
            "            self._init_stylesheet()",
            "            self._update_stylesheet()",
            "",
            "    def _update_stylesheet(self):",
            "        \"\"\"Update the custom stylesheet in existing tabs.\"\"\"",
            "        css = shared.get_user_stylesheet()",
            "        code = javascript.assemble('stylesheet', 'set_css', css)",
            "        self._tab.run_js_async(code)",
            "",
            "    def _inject_early_js(self, name, js_code, *,",
            "                         world=QWebEngineScript.ApplicationWorld,",
            "                         subframes=False):",
            "        \"\"\"Inject the given script to run early on a page load.",
            "",
            "        This runs the script both on DocumentCreation and DocumentReady as on",
            "        some internal pages, DocumentCreation will not work.",
            "",
            "        That is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66011",
            "        \"\"\"",
            "        scripts = self._widget.page().scripts()",
            "        for injection in ['creation', 'ready']:",
            "            injection_points = {",
            "                'creation': QWebEngineScript.DocumentCreation,",
            "                'ready': QWebEngineScript.DocumentReady,",
            "            }",
            "            script = QWebEngineScript()",
            "            script.setInjectionPoint(injection_points[injection])",
            "            script.setSourceCode(js_code)",
            "            script.setWorldId(world)",
            "            script.setRunsOnSubFrames(subframes)",
            "            script.setName('_qute_{}_{}'.format(name, injection))",
            "            scripts.insert(script)",
            "",
            "    def _remove_early_js(self, name):",
            "        \"\"\"Remove an early QWebEngineScript.\"\"\"",
            "        scripts = self._widget.page().scripts()",
            "        for injection in ['creation', 'ready']:",
            "            full_name = '_qute_{}_{}'.format(name, injection)",
            "            script = scripts.findScript(full_name)",
            "            if not script.isNull():",
            "                scripts.remove(script)",
            "",
            "    def init(self):",
            "        \"\"\"Initialize global qutebrowser JavaScript.\"\"\"",
            "        js_code = javascript.wrap_global(",
            "            'scripts',",
            "            utils.read_file('javascript/scroll.js'),",
            "            utils.read_file('javascript/webelem.js'),",
            "            utils.read_file('javascript/caret.js'),",
            "        )",
            "        self._inject_early_js('js',",
            "                              utils.read_file('javascript/print.js'),",
            "                              subframes=True,",
            "                              world=QWebEngineScript.MainWorld)",
            "        # FIXME:qtwebengine what about subframes=True?",
            "        self._inject_early_js('js', js_code, subframes=True)",
            "        self._init_stylesheet()",
            "",
            "        # The Greasemonkey metadata block support in QtWebEngine only starts at",
            "        # Qt 5.8. With 5.7.1, we need to inject the scripts ourselves in",
            "        # response to urlChanged.",
            "        if not qtutils.version_check('5.8'):",
            "            self._tab.url_changed.connect(",
            "                self._inject_greasemonkey_scripts_for_url)",
            "        else:",
            "            self._greasemonkey.scripts_reloaded.connect(",
            "                self._inject_all_greasemonkey_scripts)",
            "            self._inject_all_greasemonkey_scripts()",
            "",
            "    def _init_stylesheet(self):",
            "        \"\"\"Initialize custom stylesheets.",
            "",
            "        Partially inspired by QupZilla:",
            "        https://github.com/QupZilla/qupzilla/blob/v2.0/src/lib/app/mainapplication.cpp#L1063-L1101",
            "        \"\"\"",
            "        self._remove_early_js('stylesheet')",
            "        css = shared.get_user_stylesheet()",
            "        js_code = javascript.wrap_global(",
            "            'stylesheet',",
            "            utils.read_file('javascript/stylesheet.js'),",
            "            javascript.assemble('stylesheet', 'set_css', css),",
            "        )",
            "        self._inject_early_js('stylesheet', js_code, subframes=True)",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _inject_greasemonkey_scripts_for_url(self, url):",
            "        matching_scripts = self._greasemonkey.scripts_for(url)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.start, QWebEngineScript.DocumentCreation, True)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.end, QWebEngineScript.DocumentReady, False)",
            "        self._inject_greasemonkey_scripts(",
            "            matching_scripts.idle, QWebEngineScript.Deferred, False)",
            "",
            "    @pyqtSlot()",
            "    def _inject_all_greasemonkey_scripts(self):",
            "        scripts = self._greasemonkey.all_scripts()",
            "        self._inject_greasemonkey_scripts(scripts)",
            "",
            "    def _inject_greasemonkey_scripts(self, scripts=None, injection_point=None,",
            "                                     remove_first=True):",
            "        \"\"\"Register user JavaScript files with the current tab.",
            "",
            "        Args:",
            "            scripts: A list of GreasemonkeyScripts, or None to add all",
            "                     known by the Greasemonkey subsystem.",
            "            injection_point: The QWebEngineScript::InjectionPoint stage",
            "                             to inject the script into, None to use",
            "                             auto-detection.",
            "            remove_first: Whether to remove all previously injected",
            "                          scripts before adding these ones.",
            "        \"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            return",
            "",
            "        # Since we are inserting scripts into a per-tab collection,",
            "        # rather than just injecting scripts on page load, we need to",
            "        # make sure we replace existing scripts, not just add new ones.",
            "        # While, taking care not to remove any other scripts that might",
            "        # have been added elsewhere, like the one for stylesheets.",
            "        page_scripts = self._widget.page().scripts()",
            "        if remove_first:",
            "            for script in page_scripts.toList():",
            "                if script.name().startswith(\"GM-\"):",
            "                    log.greasemonkey.debug('Removing script: {}'",
            "                                           .format(script.name()))",
            "                    removed = page_scripts.remove(script)",
            "                    assert removed, script.name()",
            "",
            "        if not scripts:",
            "            return",
            "",
            "        for script in scripts:",
            "            new_script = QWebEngineScript()",
            "            try:",
            "                world = int(script.jsworld)",
            "            except ValueError:",
            "                try:",
            "                    world = _JS_WORLD_MAP[usertypes.JsWorld[",
            "                        script.jsworld.lower()]]",
            "                except KeyError:",
            "                    log.greasemonkey.error(",
            "                        \"script {} has invalid value for '@qute-js-world'\"",
            "                        \": {}\".format(script.name, script.jsworld))",
            "                    continue",
            "            new_script.setWorldId(world)",
            "            new_script.setSourceCode(script.code())",
            "            new_script.setName(\"GM-{}\".format(script.name))",
            "            new_script.setRunsOnSubFrames(script.runs_on_sub_frames)",
            "            # Override the @run-at value parsed by QWebEngineScript if desired.",
            "            if injection_point:",
            "                new_script.setInjectionPoint(injection_point)",
            "            log.greasemonkey.debug('adding script: {}'",
            "                                   .format(new_script.name()))",
            "            page_scripts.insert(new_script)",
            "",
            "",
            "class WebEngineTab(browsertab.AbstractTab):",
            "",
            "    \"\"\"A QtWebEngine tab in the browser.",
            "",
            "    Signals:",
            "        _load_finished_fake:",
            "            Used in place of unreliable loadFinished",
            "    \"\"\"",
            "",
            "    # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223",
            "    _load_finished_fake = pyqtSignal(bool)",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        super().__init__(win_id=win_id, mode_manager=mode_manager,",
            "                         private=private, parent=parent)",
            "        widget = webview.WebEngineView(tabdata=self.data, win_id=win_id,",
            "                                       private=private)",
            "        self.history = WebEngineHistory(self)",
            "        self.scroller = WebEngineScroller(self, parent=self)",
            "        self.caret = WebEngineCaret(mode_manager=mode_manager,",
            "                                    tab=self, parent=self)",
            "        self.zoom = WebEngineZoom(tab=self, parent=self)",
            "        self.search = WebEngineSearch(parent=self)",
            "        self.printing = WebEnginePrinting(tab=self)",
            "        self.elements = WebEngineElements(tab=self)",
            "        self.action = WebEngineAction(tab=self)",
            "        self.audio = WebEngineAudio(parent=self)",
            "        self._permissions = _WebEnginePermissions(tab=self, parent=self)",
            "        self._scripts = _WebEngineScripts(tab=self, parent=self)",
            "        # We're assigning settings in _set_widget",
            "        self.settings = webenginesettings.WebEngineSettings(settings=None)",
            "        self._set_widget(widget)",
            "        self._connect_signals()",
            "        self.backend = usertypes.Backend.QtWebEngine",
            "        self._child_event_filter = None",
            "        self._saved_zoom = None",
            "        self._reload_url = None",
            "        self._scripts.init()",
            "",
            "    def _set_widget(self, widget):",
            "        # pylint: disable=protected-access",
            "        super()._set_widget(widget)",
            "        self._permissions._widget = widget",
            "        self._scripts._widget = widget",
            "",
            "    def _install_event_filter(self):",
            "        fp = self._widget.focusProxy()",
            "        if fp is not None:",
            "            fp.installEventFilter(self._mouse_event_filter)",
            "        self._child_event_filter = mouse.ChildEventFilter(",
            "            eventfilter=self._mouse_event_filter, widget=self._widget,",
            "            win_id=self.win_id, parent=self)",
            "        self._widget.installEventFilter(self._child_event_filter)",
            "",
            "    @pyqtSlot()",
            "    def _restore_zoom(self):",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3498",
            "            return",
            "        if self._saved_zoom is None:",
            "            return",
            "        self.zoom.set_factor(self._saved_zoom)",
            "        self._saved_zoom = None",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        \"\"\"Open the given URL in this tab.",
            "",
            "        Arguments:",
            "            url: The QUrl to open.",
            "            predict: If set to False, predicted_navigation is not emitted.",
            "        \"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            # https://github.com/qutebrowser/qutebrowser/issues/3896",
            "            return",
            "        self._saved_zoom = self.zoom.factor()",
            "        self._openurl_prepare(url, predict=predict)",
            "        self._widget.load(url)",
            "",
            "    def url(self, requested=False):",
            "        page = self._widget.page()",
            "        if requested:",
            "            return page.requestedUrl()",
            "        else:",
            "            return page.url()",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        if plain:",
            "            self._widget.page().toPlainText(callback)",
            "        else:",
            "            self._widget.page().toHtml(callback)",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        if world is None:",
            "            world_id = QWebEngineScript.ApplicationWorld",
            "        elif isinstance(world, int):",
            "            world_id = world",
            "        else:",
            "            world_id = _JS_WORLD_MAP[world]",
            "",
            "        if callback is None:",
            "            self._widget.page().runJavaScript(code, world_id)",
            "        else:",
            "            self._widget.page().runJavaScript(code, world_id, callback)",
            "",
            "    def shutdown(self):",
            "        self.shutting_down.emit()",
            "        self.action.exit_fullscreen()",
            "        self._widget.shutdown()",
            "",
            "    def reload(self, *, force=False):",
            "        if force:",
            "            action = QWebEnginePage.ReloadAndBypassCache",
            "        else:",
            "            action = QWebEnginePage.Reload",
            "        self._widget.triggerPageAction(action)",
            "",
            "    def stop(self):",
            "        self._widget.stop()",
            "",
            "    def title(self):",
            "        return self._widget.title()",
            "",
            "    def icon(self):",
            "        return self._widget.icon()",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        # FIXME:qtwebengine",
            "        # check this and raise an exception if too big:",
            "        # Warning: The content will be percent encoded before being sent to the",
            "        # renderer via IPC. This may increase its size. The maximum size of the",
            "        # percent encoded content is 2 megabytes minus 30 bytes.",
            "        self._widget.setHtml(html, base_url)",
            "",
            "    def networkaccessmanager(self):",
            "        return None",
            "",
            "    def user_agent(self):",
            "        return None",
            "",
            "    def clear_ssl_errors(self):",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)",
            "        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,",
            "                                0, 0, 0)",
            "        self.send_event(press_evt)",
            "        self.send_event(release_evt)",
            "",
            "    def _show_error_page(self, url, error):",
            "        \"\"\"Show an error page in the tab.\"\"\"",
            "        log.misc.debug(\"Showing error page for {}\".format(error))",
            "        url_string = url.toDisplayString()",
            "        error_page = jinja.render(",
            "            'error.html',",
            "            title=\"Error loading page: {}\".format(url_string),",
            "            url=url_string, error=error)",
            "        self.set_html(error_page)",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        try:",
            "            self._widget.page()",
            "        except RuntimeError:",
            "            # Looks like this slot can be triggered on destroyed tabs:",
            "            # https://crashes.qutebrowser.org/view/3abffbed (Qt 5.9.1)",
            "            # wrapped C/C++ object of type WebEngineView has been deleted",
            "            log.misc.debug(\"Ignoring history trigger for destroyed tab\")",
            "            return",
            "",
            "        url = self.url()",
            "        requested_url = self.url(requested=True)",
            "",
            "        # Don't save the title if it's generated from the URL",
            "        title = self.title()",
            "        title_url = QUrl(url)",
            "        title_url.setScheme('')",
            "        if title == title_url.toDisplayString(QUrl.RemoveScheme).strip('/'):",
            "            title = \"\"",
            "",
            "        # Don't add history entry if the URL is invalid anyways",
            "        if not url.isValid():",
            "            log.misc.debug(\"Ignoring invalid URL being added to history\")",
            "            return",
            "",
            "        self.add_history_item.emit(url, requested_url, title)",
            "",
            "    @pyqtSlot(QUrl, 'QAuthenticator*', 'QString')",
            "    def _on_proxy_authentication_required(self, url, authenticator,",
            "                                          proxy_host):",
            "        \"\"\"Called when a proxy needs authentication.\"\"\"",
            "        msg = \"<b>{}</b> requires a username and password.\".format(",
            "            html_utils.escape(proxy_host))",
            "        urlstr = url.toString(QUrl.RemovePassword | QUrl.FullyEncoded)",
            "        answer = message.ask(",
            "            title=\"Proxy authentication required\", text=msg,",
            "            mode=usertypes.PromptMode.user_pwd,",
            "            abort_on=[self.shutting_down, self.load_started], url=urlstr)",
            "        if answer is not None:",
            "            authenticator.setUser(answer.user)",
            "            authenticator.setPassword(answer.password)",
            "        else:",
            "            try:",
            "                # pylint: disable=no-member, useless-suppression",
            "                sip.assign(authenticator, QAuthenticator())",
            "                # pylint: enable=no-member, useless-suppression",
            "            except AttributeError:",
            "                self._show_error_page(url, \"Proxy authentication required\")",
            "",
            "    @pyqtSlot(QUrl, 'QAuthenticator*')",
            "    def _on_authentication_required(self, url, authenticator):",
            "        netrc_success = False",
            "        if not self.data.netrc_used:",
            "            self.data.netrc_used = True",
            "            netrc_success = shared.netrc_authentication(url, authenticator)",
            "        if not netrc_success:",
            "            abort_on = [self.shutting_down, self.load_started]",
            "            answer = shared.authentication_required(url, authenticator,",
            "                                                    abort_on)",
            "        if not netrc_success and answer is None:",
            "            try:",
            "                # pylint: disable=no-member, useless-suppression",
            "                sip.assign(authenticator, QAuthenticator())",
            "                # pylint: enable=no-member, useless-suppression",
            "            except AttributeError:",
            "                # WORKAROUND for",
            "                # https://www.riverbankcomputing.com/pipermail/pyqt/2016-December/038400.html",
            "                self._show_error_page(url, \"Authentication required\")",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        \"\"\"Clear search when a new load is started if needed.\"\"\"",
            "        # WORKAROUND for",
            "        # https://bugreports.qt.io/browse/QTBUG-61506",
            "        # (seems to be back in later Qt versions as well)",
            "        self.search.clear()",
            "        super()._on_load_started()",
            "        self.data.netrc_used = False",
            "",
            "    @pyqtSlot(QWebEnginePage.RenderProcessTerminationStatus, int)",
            "    def _on_render_process_terminated(self, status, exitcode):",
            "        \"\"\"Show an error when the renderer process terminated.\"\"\"",
            "        if (status == QWebEnginePage.AbnormalTerminationStatus and",
            "                exitcode == 256):",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-58697",
            "            status = QWebEnginePage.CrashedTerminationStatus",
            "",
            "        status_map = {",
            "            QWebEnginePage.NormalTerminationStatus:",
            "                browsertab.TerminationStatus.normal,",
            "            QWebEnginePage.AbnormalTerminationStatus:",
            "                browsertab.TerminationStatus.abnormal,",
            "            QWebEnginePage.CrashedTerminationStatus:",
            "                browsertab.TerminationStatus.crashed,",
            "            QWebEnginePage.KilledTerminationStatus:",
            "                browsertab.TerminationStatus.killed,",
            "            -1:",
            "                browsertab.TerminationStatus.unknown,",
            "        }",
            "        self.renderer_process_terminated.emit(status_map[status], exitcode)",
            "",
            "    @pyqtSlot(int)",
            "    def _on_load_progress_workaround(self, perc):",
            "        \"\"\"Use loadProgress(100) to emit loadFinished(True).",
            "",
            "        See https://bugreports.qt.io/browse/QTBUG-65223",
            "        \"\"\"",
            "        if perc == 100 and self.load_status() != usertypes.LoadStatus.error:",
            "            self._load_finished_fake.emit(True)",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished_workaround(self, ok):",
            "        \"\"\"Use only loadFinished(False).",
            "",
            "        See https://bugreports.qt.io/browse/QTBUG-65223",
            "        \"\"\"",
            "        if not ok:",
            "            self._load_finished_fake.emit(False)",
            "",
            "    def _error_page_workaround(self, html):",
            "        \"\"\"Check if we're displaying a Chromium error page.",
            "",
            "        This gets only called if we got loadFinished(False) without JavaScript,",
            "        so we can display at least some error page.",
            "",
            "        WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66643",
            "        Needs to check the page content as a WORKAROUND for",
            "        https://bugreports.qt.io/browse/QTBUG-66661",
            "        \"\"\"",
            "        match = re.search(r'\"errorCode\":\"([^\"]*)\"', html)",
            "        if match is None:",
            "            return",
            "        self._show_error_page(self.url(), error=match.group(1))",
            "",
            "    @pyqtSlot(bool)",
            "    def _on_load_finished(self, ok):",
            "        \"\"\"Display a static error page if JavaScript is disabled.\"\"\"",
            "        super()._on_load_finished(ok)",
            "        js_enabled = self.settings.test_attribute('content.javascript.enabled')",
            "        if not ok and not js_enabled:",
            "            self.dump_async(self._error_page_workaround)",
            "",
            "        if ok and self._reload_url is not None:",
            "            # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "            log.config.debug(",
            "                \"Loading {} again because of config change\".format(",
            "                    self._reload_url.toDisplayString()))",
            "            QTimer.singleShot(100, functools.partial(self.openurl,",
            "                                                     self._reload_url,",
            "                                                     predict=False))",
            "            self._reload_url = None",
            "",
            "        if not qtutils.version_check('5.10', compiled=False):",
            "            # We can't do this when we have the loadFinished workaround as that",
            "            # sometimes clears icons without loading a new page.",
            "            # In general, this is handled by Qt, but when loading takes long,",
            "            # the old icon is still displayed.",
            "            self.icon_changed.emit(QIcon())",
            "",
            "    @pyqtSlot(certificateerror.CertificateErrorWrapper)",
            "    def _on_ssl_errors(self, error):",
            "        url = error.url()",
            "        self._insecure_hosts.add(url.host())",
            "",
            "        log.webview.debug(\"Certificate error: {}\".format(error))",
            "",
            "        if error.is_overridable():",
            "            error.ignore = shared.ignore_certificate_errors(",
            "                url, [error], abort_on=[self.shutting_down, self.load_started])",
            "        else:",
            "            log.webview.error(\"Non-overridable certificate error: \"",
            "                              \"{}\".format(error))",
            "",
            "        log.webview.debug(\"ignore {}, URL {}, requested {}\".format(",
            "            error.ignore, url, self.url(requested=True)))",
            "",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-56207",
            "        # We can't really know when to show an error page, as the error might",
            "        # have happened when loading some resource.",
            "        # However, self.url() is not available yet and the requested URL",
            "        # might not match the URL we get from the error - so we just apply a",
            "        # heuristic here.",
            "        if (not qtutils.version_check('5.9') and",
            "                not error.ignore and",
            "                url.matches(self.url(requested=True), QUrl.RemoveScheme)):",
            "            self._show_error_page(url, str(error))",
            "",
            "    @pyqtSlot(QUrl)",
            "    def _on_predicted_navigation(self, url):",
            "        \"\"\"If we know we're going to visit an URL soon, change the settings.",
            "",
            "        This is a WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "        \"\"\"",
            "        super()._on_predicted_navigation(url)",
            "        if not qtutils.version_check('5.11.1', compiled=False):",
            "            self.settings.update_for_url(url)",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        super()._on_navigation_request(navigation)",
            "",
            "        if navigation.url == QUrl('qute://print'):",
            "            try:",
            "                self.printing.show_dialog()",
            "            except browsertab.WebTabError as e:",
            "                message.error(str(e))",
            "            navigation.accepted = False",
            "",
            "        if not navigation.accepted or not navigation.is_main_frame:",
            "            return",
            "",
            "        settings_needing_reload = {",
            "            'content.plugins',",
            "            'content.javascript.enabled',",
            "            'content.javascript.can_access_clipboard',",
            "            'content.print_element_backgrounds',",
            "            'input.spatial_navigation',",
            "        }",
            "        assert settings_needing_reload.issubset(configdata.DATA)",
            "",
            "        changed = self.settings.update_for_url(navigation.url)",
            "        reload_needed = changed & settings_needing_reload",
            "",
            "        # On Qt < 5.11, we don't don't need a reload when type == link_clicked.",
            "        # On Qt 5.11.0, we always need a reload.",
            "        # On Qt > 5.11.0, we never need a reload:",
            "        # https://codereview.qt-project.org/#/c/229525/1",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-66656",
            "        if qtutils.version_check('5.11.1', compiled=False):",
            "            reload_needed = False",
            "        elif not qtutils.version_check('5.11.0', exact=True, compiled=False):",
            "            if navigation.navigation_type == navigation.Type.link_clicked:",
            "                reload_needed = False",
            "",
            "        if reload_needed:",
            "            self._reload_url = navigation.url",
            "",
            "    def _connect_signals(self):",
            "        view = self._widget",
            "        page = view.page()",
            "",
            "        page.windowCloseRequested.connect(self.window_close_requested)",
            "        page.linkHovered.connect(self.link_hovered)",
            "        page.loadProgress.connect(self._on_load_progress)",
            "        page.loadStarted.connect(self._on_load_started)",
            "        page.certificate_error.connect(self._on_ssl_errors)",
            "        page.authenticationRequired.connect(self._on_authentication_required)",
            "        page.proxyAuthenticationRequired.connect(",
            "            self._on_proxy_authentication_required)",
            "        page.contentsSizeChanged.connect(self.contents_size_changed)",
            "        page.navigation_request.connect(self._on_navigation_request)",
            "",
            "        view.titleChanged.connect(self.title_changed)",
            "        view.urlChanged.connect(self._on_url_changed)",
            "        view.renderProcessTerminated.connect(",
            "            self._on_render_process_terminated)",
            "        view.iconChanged.connect(self.icon_changed)",
            "        # WORKAROUND for https://bugreports.qt.io/browse/QTBUG-65223",
            "        if qtutils.version_check('5.10', compiled=False):",
            "            page.loadProgress.connect(self._on_load_progress_workaround)",
            "            self._load_finished_fake.connect(self._on_history_trigger)",
            "            self._load_finished_fake.connect(self._restore_zoom)",
            "            self._load_finished_fake.connect(self._on_load_finished)",
            "            page.loadFinished.connect(self._on_load_finished_workaround)",
            "        else:",
            "            # for older Qt versions which break with the above",
            "            page.loadProgress.connect(self._on_load_progress)",
            "            page.loadFinished.connect(self._on_history_trigger)",
            "            page.loadFinished.connect(self._restore_zoom)",
            "            page.loadFinished.connect(self._on_load_finished)",
            "",
            "        self.predicted_navigation.connect(self._on_predicted_navigation)",
            "",
            "        # pylint: disable=protected-access",
            "        self.audio._connect_signals()",
            "        self._permissions.connect_signals()",
            "        self._scripts.connect_signals()",
            "",
            "    def event_target(self):",
            "        return self._widget.render_widget()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1281": [
                "WebEngineTab",
                "_on_ssl_errors"
            ],
            "1282": [
                "WebEngineTab",
                "_on_ssl_errors"
            ]
        },
        "addLocation": []
    },
    "qutebrowser/browser/webkit/webkittab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 808,
                "afterPatchRowNumber": 808,
                "PatchRowcode": "         if navigation.is_main_frame:"
            },
            "1": {
                "beforePatchRowNumber": 809,
                "afterPatchRowNumber": 809,
                "PatchRowcode": "             self.settings.update_for_url(navigation.url)"
            },
            "2": {
                "beforePatchRowNumber": 810,
                "afterPatchRowNumber": 810,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 811,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @pyqtSlot()"
            },
            "4": {
                "beforePatchRowNumber": 812,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _on_ssl_errors(self):"
            },
            "5": {
                "beforePatchRowNumber": 813,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._has_ssl_errors = True"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 811,
                "PatchRowcode": "+    @pyqtSlot('QNetworkReply*')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 812,
                "PatchRowcode": "+    def _on_ssl_errors(self, reply):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+        self._insecure_hosts.add(reply.url().host())"
            },
            "9": {
                "beforePatchRowNumber": 814,
                "afterPatchRowNumber": 814,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": 815,
                "PatchRowcode": "     def _connect_signals(self):"
            },
            "11": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 816,
                "PatchRowcode": "         view = self._widget"
            }
        },
        "frontPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Wrapper over our (QtWebKit) WebView.\"\"\"",
            "",
            "import re",
            "import functools",
            "import xml.etree.ElementTree",
            "",
            "from PyQt5.QtCore import (pyqtSlot, Qt, QEvent, QUrl, QPoint, QTimer, QSizeF,",
            "                          QSize)",
            "from PyQt5.QtGui import QKeyEvent, QIcon",
            "from PyQt5.QtWebKitWidgets import QWebPage, QWebFrame",
            "from PyQt5.QtWebKit import QWebSettings",
            "from PyQt5.QtPrintSupport import QPrinter",
            "",
            "from qutebrowser.browser import browsertab, shared",
            "from qutebrowser.browser.webkit import (webview, tabhistory, webkitelem,",
            "                                        webkitsettings)",
            "from qutebrowser.utils import qtutils, usertypes, utils, log, debug",
            "from qutebrowser.qt import sip",
            "",
            "",
            "class WebKitAction(browsertab.AbstractAction):",
            "",
            "    \"\"\"QtWebKit implementations related to web actions.\"\"\"",
            "",
            "    action_class = QWebPage",
            "    action_base = QWebPage.WebAction",
            "",
            "    def exit_fullscreen(self):",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def show_source(self, pygments=False):",
            "        self._show_source_pygments()",
            "",
            "",
            "class WebKitPrinting(browsertab.AbstractPrinting):",
            "",
            "    \"\"\"QtWebKit implementations related to printing.\"\"\"",
            "",
            "    def check_pdf_support(self):",
            "        pass",
            "",
            "    def check_printer_support(self):",
            "        pass",
            "",
            "    def check_preview_support(self):",
            "        pass",
            "",
            "    def to_pdf(self, filename):",
            "        printer = QPrinter()",
            "        printer.setOutputFileName(filename)",
            "        self.to_printer(printer)",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        self._widget.print(printer)",
            "        # Can't find out whether there was an error...",
            "        if callback is not None:",
            "            callback(True)",
            "",
            "",
            "class WebKitSearch(browsertab.AbstractSearch):",
            "",
            "    \"\"\"QtWebKit implementations related to searching on the page.\"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._flags = QWebPage.FindFlags(0)",
            "",
            "    def _call_cb(self, callback, found, text, flags, caller):",
            "        \"\"\"Call the given callback if it's non-None.",
            "",
            "        Delays the call via a QTimer so the website is re-rendered in between.",
            "",
            "        Args:",
            "            callback: What to call",
            "            found: If the text was found",
            "            text: The text searched for",
            "            flags: The flags searched with",
            "            caller: Name of the caller.",
            "        \"\"\"",
            "        found_text = 'found' if found else \"didn't find\"",
            "        # Removing FindWrapsAroundDocument to get the same logging as with",
            "        # QtWebEngine",
            "        debug_flags = debug.qflags_key(",
            "            QWebPage, flags & ~QWebPage.FindWrapsAroundDocument,",
            "            klass=QWebPage.FindFlag)",
            "        if debug_flags != '0x0000':",
            "            flag_text = 'with flags {}'.format(debug_flags)",
            "        else:",
            "            flag_text = ''",
            "        log.webview.debug(' '.join([caller, found_text, text, flag_text])",
            "                          .strip())",
            "        if callback is not None:",
            "            QTimer.singleShot(0, functools.partial(callback, found))",
            "",
            "    def clear(self):",
            "        self.search_displayed = False",
            "        # We first clear the marked text, then the highlights",
            "        self._widget.findText('')",
            "        self._widget.findText('', QWebPage.HighlightAllOccurrences)",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        # Don't go to next entry on duplicate search",
            "        if self.text == text and self.search_displayed:",
            "            log.webview.debug(\"Ignoring duplicate search request\"",
            "                              \" for {}\".format(text))",
            "            return",
            "",
            "        # Clear old search results, this is done automatically on QtWebEngine.",
            "        self.clear()",
            "",
            "        self.text = text",
            "        self.search_displayed = True",
            "        self._flags = QWebPage.FindWrapsAroundDocument",
            "        if self._is_case_sensitive(ignore_case):",
            "            self._flags |= QWebPage.FindCaseSensitively",
            "        if reverse:",
            "            self._flags |= QWebPage.FindBackward",
            "        # We actually search *twice* - once to highlight everything, then again",
            "        # to get a mark so we can navigate.",
            "        found = self._widget.findText(text, self._flags)",
            "        self._widget.findText(text,",
            "                              self._flags | QWebPage.HighlightAllOccurrences)",
            "        self._call_cb(result_cb, found, text, self._flags, 'search')",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        self.search_displayed = True",
            "        found = self._widget.findText(self.text, self._flags)",
            "        self._call_cb(result_cb, found, self.text, self._flags, 'next_result')",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        self.search_displayed = True",
            "        # The int() here makes sure we get a copy of the flags.",
            "        flags = QWebPage.FindFlags(int(self._flags))",
            "        if flags & QWebPage.FindBackward:",
            "            flags &= ~QWebPage.FindBackward",
            "        else:",
            "            flags |= QWebPage.FindBackward",
            "        found = self._widget.findText(self.text, flags)",
            "        self._call_cb(result_cb, found, self.text, flags, 'prev_result')",
            "",
            "",
            "class WebKitCaret(browsertab.AbstractCaret):",
            "",
            "    \"\"\"QtWebKit implementations related to moving the cursor/selection.\"\"\"",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_entered(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        self.selection_enabled = self._widget.hasSelection()",
            "        self.selection_toggled.emit(self.selection_enabled)",
            "        settings = self._widget.settings()",
            "        settings.setAttribute(QWebSettings.CaretBrowsingEnabled, True)",
            "",
            "        if self._widget.isVisible():",
            "            # Sometimes the caret isn't immediately visible, but unfocusing",
            "            # and refocusing it fixes that.",
            "            self._widget.clearFocus()",
            "            self._widget.setFocus(Qt.OtherFocusReason)",
            "",
            "            # Move the caret to the first element in the viewport if there",
            "            # isn't any text which is already selected.",
            "            #",
            "            # Note: We can't use hasSelection() here, as that's always",
            "            # true in caret mode.",
            "            if not self.selection_enabled:",
            "                self._widget.page().currentFrame().evaluateJavaScript(",
            "                    utils.read_file('javascript/position_caret.js'))",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_left(self, _mode):",
            "        settings = self._widget.settings()",
            "        if settings.testAttribute(QWebSettings.CaretBrowsingEnabled):",
            "            if self.selection_enabled and self._widget.hasSelection():",
            "                # Remove selection if it exists",
            "                self._widget.triggerPageAction(QWebPage.MoveToNextChar)",
            "            settings.setAttribute(QWebSettings.CaretBrowsingEnabled, False)",
            "            self.selection_enabled = False",
            "",
            "    def move_to_next_line(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToNextLine",
            "        else:",
            "            act = QWebPage.SelectNextLine",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousLine",
            "        else:",
            "            act = QWebPage.SelectPreviousLine",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_next_char(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToNextChar",
            "        else:",
            "            act = QWebPage.SelectNextChar",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousChar",
            "        else:",
            "            act = QWebPage.SelectPreviousChar",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextWord]",
            "            if utils.is_windows:  # pragma: no cover",
            "                act.append(QWebPage.MoveToPreviousChar)",
            "        else:",
            "            act = [QWebPage.SelectNextWord]",
            "            if utils.is_windows:  # pragma: no cover",
            "                act.append(QWebPage.SelectPreviousChar)",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_next_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextWord]",
            "            if not utils.is_windows:  # pragma: no branch",
            "                act.append(QWebPage.MoveToNextChar)",
            "        else:",
            "            act = [QWebPage.SelectNextWord]",
            "            if not utils.is_windows:  # pragma: no branch",
            "                act.append(QWebPage.SelectNextChar)",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousWord",
            "        else:",
            "            act = QWebPage.SelectPreviousWord",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_start_of_line(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToStartOfLine",
            "        else:",
            "            act = QWebPage.SelectStartOfLine",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_line(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToEndOfLine",
            "        else:",
            "            act = QWebPage.SelectEndOfLine",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextLine,",
            "                   QWebPage.MoveToStartOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectNextLine,",
            "                   QWebPage.SelectStartOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToPreviousLine,",
            "                   QWebPage.MoveToStartOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectPreviousLine,",
            "                   QWebPage.SelectStartOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextLine,",
            "                   QWebPage.MoveToEndOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectNextLine,",
            "                   QWebPage.SelectEndOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToPreviousLine, QWebPage.MoveToEndOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectPreviousLine, QWebPage.SelectEndOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_start_of_document(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToStartOfDocument",
            "        else:",
            "            act = QWebPage.SelectStartOfDocument",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_document(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToEndOfDocument",
            "        else:",
            "            act = QWebPage.SelectEndOfDocument",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def toggle_selection(self):",
            "        self.selection_enabled = not self.selection_enabled",
            "        self.selection_toggled.emit(self.selection_enabled)",
            "",
            "    def drop_selection(self):",
            "        self._widget.triggerPageAction(QWebPage.MoveToNextChar)",
            "",
            "    def selection(self, callback):",
            "        callback(self._widget.selectedText())",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        if QWebSettings.globalSettings().testAttribute(",
            "                QWebSettings.JavascriptEnabled):",
            "            if tab:",
            "                self._tab.data.override_target = usertypes.ClickTarget.tab",
            "            self._tab.run_js_async(\"\"\"",
            "                const aElm = document.activeElement;",
            "                if (window.getSelection().anchorNode) {",
            "                    window.getSelection().anchorNode.parentNode.click();",
            "                } else if (aElm && aElm !== document.body) {",
            "                    aElm.click();",
            "                }",
            "            \"\"\")",
            "        else:",
            "            selection = self._widget.selectedHtml()",
            "            if not selection:",
            "                # Getting here may mean we crashed, but we can't do anything",
            "                # about that until this commit is released:",
            "                # https://github.com/annulen/webkit/commit/0e75f3272d149bc64899c161f150eb341a2417af",
            "                # TODO find a way to check if something is focused",
            "                self._follow_enter(tab)",
            "                return",
            "            try:",
            "                selected_element = xml.etree.ElementTree.fromstring(",
            "                    '<html>{}</html>'.format(selection)).find('a')",
            "            except xml.etree.ElementTree.ParseError:",
            "                raise browsertab.WebTabError('Could not parse selected '",
            "                                             'element!')",
            "",
            "            if selected_element is not None:",
            "                try:",
            "                    url = selected_element.attrib['href']",
            "                except KeyError:",
            "                    raise browsertab.WebTabError('Anchor element without '",
            "                                                 'href!')",
            "                url = self._tab.url().resolved(QUrl(url))",
            "                if tab:",
            "                    self._tab.new_tab_requested.emit(url)",
            "                else:",
            "                    self._tab.openurl(url)",
            "",
            "",
            "class WebKitZoom(browsertab.AbstractZoom):",
            "",
            "    \"\"\"QtWebKit implementations related to zooming.\"\"\"",
            "",
            "    def _set_factor_internal(self, factor):",
            "        self._widget.setZoomFactor(factor)",
            "",
            "",
            "class WebKitScroller(browsertab.AbstractScroller):",
            "",
            "    \"\"\"QtWebKit implementations related to scrolling.\"\"\"",
            "",
            "    # FIXME:qtwebengine When to use the main frame, when the current one?",
            "",
            "    def pos_px(self):",
            "        return self._widget.page().mainFrame().scrollPosition()",
            "",
            "    def pos_perc(self):",
            "        return self._widget.scroll_pos",
            "",
            "    def to_point(self, point):",
            "        self._widget.page().mainFrame().setScrollPosition(point)",
            "",
            "    def to_anchor(self, name):",
            "        self._widget.page().mainFrame().scrollToAnchor(name)",
            "",
            "    def delta(self, x=0, y=0):",
            "        qtutils.check_overflow(x, 'int')",
            "        qtutils.check_overflow(y, 'int')",
            "        self._widget.page().mainFrame().scroll(x, y)",
            "",
            "    def delta_page(self, x=0.0, y=0.0):",
            "        if y.is_integer():",
            "            y = int(y)",
            "            if y == 0:",
            "                pass",
            "            elif y < 0:",
            "                self.page_up(count=-y)",
            "            elif y > 0:",
            "                self.page_down(count=y)",
            "            y = 0",
            "        if x == 0 and y == 0:",
            "            return",
            "        size = self._widget.page().mainFrame().geometry()",
            "        self.delta(x * size.width(), y * size.height())",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        if x is None and y == 0:",
            "            self.top()",
            "        elif x is None and y == 100:",
            "            self.bottom()",
            "        else:",
            "            for val, orientation in [(x, Qt.Horizontal), (y, Qt.Vertical)]:",
            "                if val is not None:",
            "                    frame = self._widget.page().mainFrame()",
            "                    maximum = frame.scrollBarMaximum(orientation)",
            "                    if maximum == 0:",
            "                        continue",
            "                    pos = int(maximum * val / 100)",
            "                    pos = qtutils.check_overflow(pos, 'int', fatal=False)",
            "                    frame.setScrollBarValue(orientation, pos)",
            "",
            "    def _key_press(self, key, count=1, getter_name=None, direction=None):",
            "        frame = self._widget.page().mainFrame()",
            "        getter = None if getter_name is None else getattr(frame, getter_name)",
            "",
            "        # FIXME:qtwebengine needed?",
            "        # self._widget.setFocus()",
            "",
            "        for _ in range(min(count, 5000)):",
            "            # Abort scrolling if the minimum/maximum was reached.",
            "            if (getter is not None and",
            "                    frame.scrollBarValue(direction) == getter(direction)):",
            "                return",
            "            self._tab.key_press(key)",
            "",
            "    def up(self, count=1):",
            "        self._key_press(Qt.Key_Up, count, 'scrollBarMinimum', Qt.Vertical)",
            "",
            "    def down(self, count=1):",
            "        self._key_press(Qt.Key_Down, count, 'scrollBarMaximum', Qt.Vertical)",
            "",
            "    def left(self, count=1):",
            "        self._key_press(Qt.Key_Left, count, 'scrollBarMinimum', Qt.Horizontal)",
            "",
            "    def right(self, count=1):",
            "        self._key_press(Qt.Key_Right, count, 'scrollBarMaximum', Qt.Horizontal)",
            "",
            "    def top(self):",
            "        self._key_press(Qt.Key_Home)",
            "",
            "    def bottom(self):",
            "        self._key_press(Qt.Key_End)",
            "",
            "    def page_up(self, count=1):",
            "        self._key_press(Qt.Key_PageUp, count, 'scrollBarMinimum', Qt.Vertical)",
            "",
            "    def page_down(self, count=1):",
            "        self._key_press(Qt.Key_PageDown, count, 'scrollBarMaximum',",
            "                        Qt.Vertical)",
            "",
            "    def at_top(self):",
            "        return self.pos_px().y() == 0",
            "",
            "    def at_bottom(self):",
            "        frame = self._widget.page().currentFrame()",
            "        return self.pos_px().y() >= frame.scrollBarMaximum(Qt.Vertical)",
            "",
            "",
            "class WebKitHistory(browsertab.AbstractHistory):",
            "",
            "    \"\"\"QtWebKit implementations related to page history.\"\"\"",
            "",
            "    def current_idx(self):",
            "        return self._history.currentItemIndex()",
            "",
            "    def can_go_back(self):",
            "        return self._history.canGoBack()",
            "",
            "    def can_go_forward(self):",
            "        return self._history.canGoForward()",
            "",
            "    def _item_at(self, i):",
            "        return self._history.itemAt(i)",
            "",
            "    def _go_to_item(self, item):",
            "        self._tab.predicted_navigation.emit(item.url())",
            "        self._history.goToItem(item)",
            "",
            "    def serialize(self):",
            "        return qtutils.serialize(self._history)",
            "",
            "    def deserialize(self, data):",
            "        return qtutils.deserialize(data, self._history)",
            "",
            "    def load_items(self, items):",
            "        if items:",
            "            self._tab.predicted_navigation.emit(items[-1].url)",
            "",
            "        stream, _data, user_data = tabhistory.serialize(items)",
            "        qtutils.deserialize_stream(stream, self._history)",
            "        for i, data in enumerate(user_data):",
            "            self._history.itemAt(i).setUserData(data)",
            "        cur_data = self._history.currentItem().userData()",
            "        if cur_data is not None:",
            "            if 'zoom' in cur_data:",
            "                self._tab.zoom.set_factor(cur_data['zoom'])",
            "            if ('scroll-pos' in cur_data and",
            "                    self._tab.scroller.pos_px() == QPoint(0, 0)):",
            "                QTimer.singleShot(0, functools.partial(",
            "                    self._tab.scroller.to_point, cur_data['scroll-pos']))",
            "",
            "",
            "class WebKitElements(browsertab.AbstractElements):",
            "",
            "    \"\"\"QtWebKit implemementations related to elements on the page.\"\"\"",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        mainframe = self._widget.page().mainFrame()",
            "        if mainframe is None:",
            "            raise browsertab.WebTabError(\"No frame focused!\")",
            "",
            "        elems = []",
            "        frames = webkitelem.get_child_frames(mainframe)",
            "        for f in frames:",
            "            for elem in f.findAllElements(selector):",
            "                elems.append(webkitelem.WebKitElement(elem, tab=self._tab))",
            "",
            "        if only_visible:",
            "            # pylint: disable=protected-access",
            "            elems = [e for e in elems if e._is_visible(mainframe)]",
            "            # pylint: enable=protected-access",
            "",
            "        callback(elems)",
            "",
            "    def find_id(self, elem_id, callback):",
            "        def find_id_cb(elems):",
            "            \"\"\"Call the real callback with the found elements.\"\"\"",
            "            if not elems:",
            "                callback(None)",
            "            else:",
            "                callback(elems[0])",
            "",
            "        # Escape non-alphanumeric characters in the selector",
            "        # https://www.w3.org/TR/CSS2/syndata.html#value-def-identifier",
            "        elem_id = re.sub(r'[^a-zA-Z0-9_-]', r'\\\\\\g<0>', elem_id)",
            "        self.find_css('#' + elem_id, find_id_cb)",
            "",
            "    def find_focused(self, callback):",
            "        frame = self._widget.page().currentFrame()",
            "        if frame is None:",
            "            callback(None)",
            "            return",
            "",
            "        elem = frame.findFirstElement('*:focus')",
            "        if elem.isNull():",
            "            callback(None)",
            "        else:",
            "            callback(webkitelem.WebKitElement(elem, tab=self._tab))",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        assert pos.x() >= 0",
            "        assert pos.y() >= 0",
            "        frame = self._widget.page().frameAt(pos)",
            "        if frame is None:",
            "            # This happens when we click inside the webview, but not actually",
            "            # on the QWebPage - for example when clicking the scrollbar",
            "            # sometimes.",
            "            log.webview.debug(\"Hit test at {} but frame is None!\".format(pos))",
            "            callback(None)",
            "            return",
            "",
            "        # You'd think we have to subtract frame.geometry().topLeft() from the",
            "        # position, but it seems QWebFrame::hitTestContent wants a position",
            "        # relative to the QWebView, not to the frame. This makes no sense to",
            "        # me, but it works this way.",
            "        hitresult = frame.hitTestContent(pos)",
            "        if hitresult.isNull():",
            "            # For some reason, the whole hit result can be null sometimes (e.g.",
            "            # on doodle menu links).",
            "            log.webview.debug(\"Hit test result is null!\")",
            "            callback(None)",
            "            return",
            "",
            "        try:",
            "            elem = webkitelem.WebKitElement(hitresult.element(), tab=self._tab)",
            "        except webkitelem.IsNullError:",
            "            # For some reason, the hit result element can be a null element",
            "            # sometimes (e.g. when clicking the timetable fields on",
            "            # http://www.sbb.ch/ ).",
            "            log.webview.debug(\"Hit test result element is null!\")",
            "            callback(None)",
            "            return",
            "",
            "        callback(elem)",
            "",
            "",
            "class WebKitAudio(browsertab.AbstractAudio):",
            "",
            "    \"\"\"Dummy handling of audio status for QtWebKit.\"\"\"",
            "",
            "    def set_muted(self, muted: bool):",
            "        raise browsertab.WebTabError('Muting is not supported on QtWebKit!')",
            "",
            "    def is_muted(self):",
            "        return False",
            "",
            "    def is_recently_audible(self):",
            "        return False",
            "",
            "",
            "class WebKitTab(browsertab.AbstractTab):",
            "",
            "    \"\"\"A QtWebKit tab in the browser.\"\"\"",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        super().__init__(win_id=win_id, mode_manager=mode_manager,",
            "                         private=private, parent=parent)",
            "        widget = webview.WebView(win_id=win_id, tab_id=self.tab_id,",
            "                                 private=private, tab=self)",
            "        if private:",
            "            self._make_private(widget)",
            "        self.history = WebKitHistory(self)",
            "        self.scroller = WebKitScroller(self, parent=self)",
            "        self.caret = WebKitCaret(mode_manager=mode_manager,",
            "                                 tab=self, parent=self)",
            "        self.zoom = WebKitZoom(tab=self, parent=self)",
            "        self.search = WebKitSearch(parent=self)",
            "        self.printing = WebKitPrinting(tab=self)",
            "        self.elements = WebKitElements(tab=self)",
            "        self.action = WebKitAction(tab=self)",
            "        self.audio = WebKitAudio(parent=self)",
            "        # We're assigning settings in _set_widget",
            "        self.settings = webkitsettings.WebKitSettings(settings=None)",
            "        self._set_widget(widget)",
            "        self._connect_signals()",
            "        self.backend = usertypes.Backend.QtWebKit",
            "",
            "    def _install_event_filter(self):",
            "        self._widget.installEventFilter(self._mouse_event_filter)",
            "",
            "    def _make_private(self, widget):",
            "        settings = widget.settings()",
            "        settings.setAttribute(QWebSettings.PrivateBrowsingEnabled, True)",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        self._openurl_prepare(url, predict=predict)",
            "        self._widget.openurl(url)",
            "",
            "    def url(self, requested=False):",
            "        frame = self._widget.page().mainFrame()",
            "        if requested:",
            "            return frame.requestedUrl()",
            "        else:",
            "            return frame.url()",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        frame = self._widget.page().mainFrame()",
            "        if plain:",
            "            callback(frame.toPlainText())",
            "        else:",
            "            callback(frame.toHtml())",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        if world is not None and world != usertypes.JsWorld.jseval:",
            "            log.webview.warning(\"Ignoring world ID {}\".format(world))",
            "        document_element = self._widget.page().mainFrame().documentElement()",
            "        result = document_element.evaluateJavaScript(code)",
            "        if callback is not None:",
            "            callback(result)",
            "",
            "    def icon(self):",
            "        return self._widget.icon()",
            "",
            "    def shutdown(self):",
            "        self._widget.shutdown()",
            "",
            "    def reload(self, *, force=False):",
            "        if force:",
            "            action = QWebPage.ReloadAndBypassCache",
            "        else:",
            "            action = QWebPage.Reload",
            "        self._widget.triggerPageAction(action)",
            "",
            "    def stop(self):",
            "        self._widget.stop()",
            "",
            "    def title(self):",
            "        return self._widget.title()",
            "",
            "    def clear_ssl_errors(self):",
            "        self.networkaccessmanager().clear_all_ssl_errors()",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)",
            "        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,",
            "                                0, 0, 0)",
            "        self.send_event(press_evt)",
            "        self.send_event(release_evt)",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        url = self.url()",
            "        requested_url = self.url(requested=True)",
            "        self.add_history_item.emit(url, requested_url, self.title())",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        self._widget.setHtml(html, base_url)",
            "",
            "    def networkaccessmanager(self):",
            "        return self._widget.page().networkAccessManager()",
            "",
            "    def user_agent(self):",
            "        page = self._widget.page()",
            "        return page.userAgentForUrl(self.url())",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        super()._on_load_started()",
            "        self.networkaccessmanager().netrc_used = False",
            "        # Make sure the icon is cleared when navigating to a page without one.",
            "        self.icon_changed.emit(QIcon())",
            "",
            "    @pyqtSlot()",
            "    def _on_frame_load_finished(self):",
            "        \"\"\"Make sure we emit an appropriate status when loading finished.",
            "",
            "        While Qt has a bool \"ok\" attribute for loadFinished, it always is True",
            "        when using error pages... See",
            "        https://github.com/qutebrowser/qutebrowser/issues/84",
            "        \"\"\"",
            "        self._on_load_finished(not self._widget.page().error_occurred)",
            "",
            "    @pyqtSlot()",
            "    def _on_webkit_icon_changed(self):",
            "        \"\"\"Emit iconChanged with a QIcon like QWebEngineView does.\"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            log.webview.debug(\"Got _on_webkit_icon_changed for deleted view!\")",
            "            return",
            "        self.icon_changed.emit(self._widget.icon())",
            "",
            "    @pyqtSlot(QWebFrame)",
            "    def _on_frame_created(self, frame):",
            "        \"\"\"Connect the contentsSizeChanged signal of each frame.\"\"\"",
            "        # FIXME:qtwebengine those could theoretically regress:",
            "        # https://github.com/qutebrowser/qutebrowser/issues/152",
            "        # https://github.com/qutebrowser/qutebrowser/issues/263",
            "        frame.contentsSizeChanged.connect(self._on_contents_size_changed)",
            "",
            "    @pyqtSlot(QSize)",
            "    def _on_contents_size_changed(self, size):",
            "        self.contents_size_changed.emit(QSizeF(size))",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        super()._on_navigation_request(navigation)",
            "        if not navigation.accepted:",
            "            return",
            "",
            "        log.webview.debug(\"target {} override {}\".format(",
            "            self.data.open_target, self.data.override_target))",
            "",
            "        if self.data.override_target is not None:",
            "            target = self.data.override_target",
            "            self.data.override_target = None",
            "        else:",
            "            target = self.data.open_target",
            "",
            "        if (navigation.navigation_type == navigation.Type.link_clicked and",
            "                target != usertypes.ClickTarget.normal):",
            "            tab = shared.get_tab(self.win_id, target)",
            "            tab.openurl(navigation.url)",
            "            self.data.open_target = usertypes.ClickTarget.normal",
            "            navigation.accepted = False",
            "",
            "        if navigation.is_main_frame:",
            "            self.settings.update_for_url(navigation.url)",
            "",
            "    @pyqtSlot()",
            "    def _on_ssl_errors(self):",
            "        self._has_ssl_errors = True",
            "",
            "    def _connect_signals(self):",
            "        view = self._widget",
            "        page = view.page()",
            "        frame = page.mainFrame()",
            "        page.windowCloseRequested.connect(self.window_close_requested)",
            "        page.linkHovered.connect(self.link_hovered)",
            "        page.loadProgress.connect(self._on_load_progress)",
            "        frame.loadStarted.connect(self._on_load_started)",
            "        view.scroll_pos_changed.connect(self.scroller.perc_changed)",
            "        view.titleChanged.connect(self.title_changed)",
            "        view.urlChanged.connect(self._on_url_changed)",
            "        view.shutting_down.connect(self.shutting_down)",
            "        page.networkAccessManager().sslErrors.connect(self._on_ssl_errors)",
            "        frame.loadFinished.connect(self._on_frame_load_finished)",
            "        view.iconChanged.connect(self._on_webkit_icon_changed)",
            "        page.frameCreated.connect(self._on_frame_created)",
            "        frame.contentsSizeChanged.connect(self._on_contents_size_changed)",
            "        frame.initialLayoutCompleted.connect(self._on_history_trigger)",
            "        page.navigation_request.connect(self._on_navigation_request)",
            "",
            "    def event_target(self):",
            "        return self._widget"
        ],
        "afterPatchFile": [
            "# vim: ft=python fileencoding=utf-8 sts=4 sw=4 et:",
            "",
            "# Copyright 2016-2018 Florian Bruhin (The Compiler) <mail@qutebrowser.org>",
            "#",
            "# This file is part of qutebrowser.",
            "#",
            "# qutebrowser is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# qutebrowser is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with qutebrowser.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"Wrapper over our (QtWebKit) WebView.\"\"\"",
            "",
            "import re",
            "import functools",
            "import xml.etree.ElementTree",
            "",
            "from PyQt5.QtCore import (pyqtSlot, Qt, QEvent, QUrl, QPoint, QTimer, QSizeF,",
            "                          QSize)",
            "from PyQt5.QtGui import QKeyEvent, QIcon",
            "from PyQt5.QtWebKitWidgets import QWebPage, QWebFrame",
            "from PyQt5.QtWebKit import QWebSettings",
            "from PyQt5.QtPrintSupport import QPrinter",
            "",
            "from qutebrowser.browser import browsertab, shared",
            "from qutebrowser.browser.webkit import (webview, tabhistory, webkitelem,",
            "                                        webkitsettings)",
            "from qutebrowser.utils import qtutils, usertypes, utils, log, debug",
            "from qutebrowser.qt import sip",
            "",
            "",
            "class WebKitAction(browsertab.AbstractAction):",
            "",
            "    \"\"\"QtWebKit implementations related to web actions.\"\"\"",
            "",
            "    action_class = QWebPage",
            "    action_base = QWebPage.WebAction",
            "",
            "    def exit_fullscreen(self):",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def save_page(self):",
            "        \"\"\"Save the current page.\"\"\"",
            "        raise browsertab.UnsupportedOperationError",
            "",
            "    def show_source(self, pygments=False):",
            "        self._show_source_pygments()",
            "",
            "",
            "class WebKitPrinting(browsertab.AbstractPrinting):",
            "",
            "    \"\"\"QtWebKit implementations related to printing.\"\"\"",
            "",
            "    def check_pdf_support(self):",
            "        pass",
            "",
            "    def check_printer_support(self):",
            "        pass",
            "",
            "    def check_preview_support(self):",
            "        pass",
            "",
            "    def to_pdf(self, filename):",
            "        printer = QPrinter()",
            "        printer.setOutputFileName(filename)",
            "        self.to_printer(printer)",
            "",
            "    def to_printer(self, printer, callback=None):",
            "        self._widget.print(printer)",
            "        # Can't find out whether there was an error...",
            "        if callback is not None:",
            "            callback(True)",
            "",
            "",
            "class WebKitSearch(browsertab.AbstractSearch):",
            "",
            "    \"\"\"QtWebKit implementations related to searching on the page.\"\"\"",
            "",
            "    def __init__(self, parent=None):",
            "        super().__init__(parent)",
            "        self._flags = QWebPage.FindFlags(0)",
            "",
            "    def _call_cb(self, callback, found, text, flags, caller):",
            "        \"\"\"Call the given callback if it's non-None.",
            "",
            "        Delays the call via a QTimer so the website is re-rendered in between.",
            "",
            "        Args:",
            "            callback: What to call",
            "            found: If the text was found",
            "            text: The text searched for",
            "            flags: The flags searched with",
            "            caller: Name of the caller.",
            "        \"\"\"",
            "        found_text = 'found' if found else \"didn't find\"",
            "        # Removing FindWrapsAroundDocument to get the same logging as with",
            "        # QtWebEngine",
            "        debug_flags = debug.qflags_key(",
            "            QWebPage, flags & ~QWebPage.FindWrapsAroundDocument,",
            "            klass=QWebPage.FindFlag)",
            "        if debug_flags != '0x0000':",
            "            flag_text = 'with flags {}'.format(debug_flags)",
            "        else:",
            "            flag_text = ''",
            "        log.webview.debug(' '.join([caller, found_text, text, flag_text])",
            "                          .strip())",
            "        if callback is not None:",
            "            QTimer.singleShot(0, functools.partial(callback, found))",
            "",
            "    def clear(self):",
            "        self.search_displayed = False",
            "        # We first clear the marked text, then the highlights",
            "        self._widget.findText('')",
            "        self._widget.findText('', QWebPage.HighlightAllOccurrences)",
            "",
            "    def search(self, text, *, ignore_case='never', reverse=False,",
            "               result_cb=None):",
            "        # Don't go to next entry on duplicate search",
            "        if self.text == text and self.search_displayed:",
            "            log.webview.debug(\"Ignoring duplicate search request\"",
            "                              \" for {}\".format(text))",
            "            return",
            "",
            "        # Clear old search results, this is done automatically on QtWebEngine.",
            "        self.clear()",
            "",
            "        self.text = text",
            "        self.search_displayed = True",
            "        self._flags = QWebPage.FindWrapsAroundDocument",
            "        if self._is_case_sensitive(ignore_case):",
            "            self._flags |= QWebPage.FindCaseSensitively",
            "        if reverse:",
            "            self._flags |= QWebPage.FindBackward",
            "        # We actually search *twice* - once to highlight everything, then again",
            "        # to get a mark so we can navigate.",
            "        found = self._widget.findText(text, self._flags)",
            "        self._widget.findText(text,",
            "                              self._flags | QWebPage.HighlightAllOccurrences)",
            "        self._call_cb(result_cb, found, text, self._flags, 'search')",
            "",
            "    def next_result(self, *, result_cb=None):",
            "        self.search_displayed = True",
            "        found = self._widget.findText(self.text, self._flags)",
            "        self._call_cb(result_cb, found, self.text, self._flags, 'next_result')",
            "",
            "    def prev_result(self, *, result_cb=None):",
            "        self.search_displayed = True",
            "        # The int() here makes sure we get a copy of the flags.",
            "        flags = QWebPage.FindFlags(int(self._flags))",
            "        if flags & QWebPage.FindBackward:",
            "            flags &= ~QWebPage.FindBackward",
            "        else:",
            "            flags |= QWebPage.FindBackward",
            "        found = self._widget.findText(self.text, flags)",
            "        self._call_cb(result_cb, found, self.text, flags, 'prev_result')",
            "",
            "",
            "class WebKitCaret(browsertab.AbstractCaret):",
            "",
            "    \"\"\"QtWebKit implementations related to moving the cursor/selection.\"\"\"",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_entered(self, mode):",
            "        if mode != usertypes.KeyMode.caret:",
            "            return",
            "",
            "        self.selection_enabled = self._widget.hasSelection()",
            "        self.selection_toggled.emit(self.selection_enabled)",
            "        settings = self._widget.settings()",
            "        settings.setAttribute(QWebSettings.CaretBrowsingEnabled, True)",
            "",
            "        if self._widget.isVisible():",
            "            # Sometimes the caret isn't immediately visible, but unfocusing",
            "            # and refocusing it fixes that.",
            "            self._widget.clearFocus()",
            "            self._widget.setFocus(Qt.OtherFocusReason)",
            "",
            "            # Move the caret to the first element in the viewport if there",
            "            # isn't any text which is already selected.",
            "            #",
            "            # Note: We can't use hasSelection() here, as that's always",
            "            # true in caret mode.",
            "            if not self.selection_enabled:",
            "                self._widget.page().currentFrame().evaluateJavaScript(",
            "                    utils.read_file('javascript/position_caret.js'))",
            "",
            "    @pyqtSlot(usertypes.KeyMode)",
            "    def _on_mode_left(self, _mode):",
            "        settings = self._widget.settings()",
            "        if settings.testAttribute(QWebSettings.CaretBrowsingEnabled):",
            "            if self.selection_enabled and self._widget.hasSelection():",
            "                # Remove selection if it exists",
            "                self._widget.triggerPageAction(QWebPage.MoveToNextChar)",
            "            settings.setAttribute(QWebSettings.CaretBrowsingEnabled, False)",
            "            self.selection_enabled = False",
            "",
            "    def move_to_next_line(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToNextLine",
            "        else:",
            "            act = QWebPage.SelectNextLine",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_prev_line(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousLine",
            "        else:",
            "            act = QWebPage.SelectPreviousLine",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_next_char(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToNextChar",
            "        else:",
            "            act = QWebPage.SelectNextChar",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_prev_char(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousChar",
            "        else:",
            "            act = QWebPage.SelectPreviousChar",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextWord]",
            "            if utils.is_windows:  # pragma: no cover",
            "                act.append(QWebPage.MoveToPreviousChar)",
            "        else:",
            "            act = [QWebPage.SelectNextWord]",
            "            if utils.is_windows:  # pragma: no cover",
            "                act.append(QWebPage.SelectPreviousChar)",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_next_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextWord]",
            "            if not utils.is_windows:  # pragma: no branch",
            "                act.append(QWebPage.MoveToNextChar)",
            "        else:",
            "            act = [QWebPage.SelectNextWord]",
            "            if not utils.is_windows:  # pragma: no branch",
            "                act.append(QWebPage.SelectNextChar)",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_prev_word(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToPreviousWord",
            "        else:",
            "            act = QWebPage.SelectPreviousWord",
            "        for _ in range(count):",
            "            self._widget.triggerPageAction(act)",
            "",
            "    def move_to_start_of_line(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToStartOfLine",
            "        else:",
            "            act = QWebPage.SelectStartOfLine",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_line(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToEndOfLine",
            "        else:",
            "            act = QWebPage.SelectEndOfLine",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_start_of_next_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextLine,",
            "                   QWebPage.MoveToStartOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectNextLine,",
            "                   QWebPage.SelectStartOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_start_of_prev_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToPreviousLine,",
            "                   QWebPage.MoveToStartOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectPreviousLine,",
            "                   QWebPage.SelectStartOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_end_of_next_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToNextLine,",
            "                   QWebPage.MoveToEndOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectNextLine,",
            "                   QWebPage.SelectEndOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_end_of_prev_block(self, count=1):",
            "        if not self.selection_enabled:",
            "            act = [QWebPage.MoveToPreviousLine, QWebPage.MoveToEndOfBlock]",
            "        else:",
            "            act = [QWebPage.SelectPreviousLine, QWebPage.SelectEndOfBlock]",
            "        for _ in range(count):",
            "            for a in act:",
            "                self._widget.triggerPageAction(a)",
            "",
            "    def move_to_start_of_document(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToStartOfDocument",
            "        else:",
            "            act = QWebPage.SelectStartOfDocument",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def move_to_end_of_document(self):",
            "        if not self.selection_enabled:",
            "            act = QWebPage.MoveToEndOfDocument",
            "        else:",
            "            act = QWebPage.SelectEndOfDocument",
            "        self._widget.triggerPageAction(act)",
            "",
            "    def toggle_selection(self):",
            "        self.selection_enabled = not self.selection_enabled",
            "        self.selection_toggled.emit(self.selection_enabled)",
            "",
            "    def drop_selection(self):",
            "        self._widget.triggerPageAction(QWebPage.MoveToNextChar)",
            "",
            "    def selection(self, callback):",
            "        callback(self._widget.selectedText())",
            "",
            "    def follow_selected(self, *, tab=False):",
            "        if QWebSettings.globalSettings().testAttribute(",
            "                QWebSettings.JavascriptEnabled):",
            "            if tab:",
            "                self._tab.data.override_target = usertypes.ClickTarget.tab",
            "            self._tab.run_js_async(\"\"\"",
            "                const aElm = document.activeElement;",
            "                if (window.getSelection().anchorNode) {",
            "                    window.getSelection().anchorNode.parentNode.click();",
            "                } else if (aElm && aElm !== document.body) {",
            "                    aElm.click();",
            "                }",
            "            \"\"\")",
            "        else:",
            "            selection = self._widget.selectedHtml()",
            "            if not selection:",
            "                # Getting here may mean we crashed, but we can't do anything",
            "                # about that until this commit is released:",
            "                # https://github.com/annulen/webkit/commit/0e75f3272d149bc64899c161f150eb341a2417af",
            "                # TODO find a way to check if something is focused",
            "                self._follow_enter(tab)",
            "                return",
            "            try:",
            "                selected_element = xml.etree.ElementTree.fromstring(",
            "                    '<html>{}</html>'.format(selection)).find('a')",
            "            except xml.etree.ElementTree.ParseError:",
            "                raise browsertab.WebTabError('Could not parse selected '",
            "                                             'element!')",
            "",
            "            if selected_element is not None:",
            "                try:",
            "                    url = selected_element.attrib['href']",
            "                except KeyError:",
            "                    raise browsertab.WebTabError('Anchor element without '",
            "                                                 'href!')",
            "                url = self._tab.url().resolved(QUrl(url))",
            "                if tab:",
            "                    self._tab.new_tab_requested.emit(url)",
            "                else:",
            "                    self._tab.openurl(url)",
            "",
            "",
            "class WebKitZoom(browsertab.AbstractZoom):",
            "",
            "    \"\"\"QtWebKit implementations related to zooming.\"\"\"",
            "",
            "    def _set_factor_internal(self, factor):",
            "        self._widget.setZoomFactor(factor)",
            "",
            "",
            "class WebKitScroller(browsertab.AbstractScroller):",
            "",
            "    \"\"\"QtWebKit implementations related to scrolling.\"\"\"",
            "",
            "    # FIXME:qtwebengine When to use the main frame, when the current one?",
            "",
            "    def pos_px(self):",
            "        return self._widget.page().mainFrame().scrollPosition()",
            "",
            "    def pos_perc(self):",
            "        return self._widget.scroll_pos",
            "",
            "    def to_point(self, point):",
            "        self._widget.page().mainFrame().setScrollPosition(point)",
            "",
            "    def to_anchor(self, name):",
            "        self._widget.page().mainFrame().scrollToAnchor(name)",
            "",
            "    def delta(self, x=0, y=0):",
            "        qtutils.check_overflow(x, 'int')",
            "        qtutils.check_overflow(y, 'int')",
            "        self._widget.page().mainFrame().scroll(x, y)",
            "",
            "    def delta_page(self, x=0.0, y=0.0):",
            "        if y.is_integer():",
            "            y = int(y)",
            "            if y == 0:",
            "                pass",
            "            elif y < 0:",
            "                self.page_up(count=-y)",
            "            elif y > 0:",
            "                self.page_down(count=y)",
            "            y = 0",
            "        if x == 0 and y == 0:",
            "            return",
            "        size = self._widget.page().mainFrame().geometry()",
            "        self.delta(x * size.width(), y * size.height())",
            "",
            "    def to_perc(self, x=None, y=None):",
            "        if x is None and y == 0:",
            "            self.top()",
            "        elif x is None and y == 100:",
            "            self.bottom()",
            "        else:",
            "            for val, orientation in [(x, Qt.Horizontal), (y, Qt.Vertical)]:",
            "                if val is not None:",
            "                    frame = self._widget.page().mainFrame()",
            "                    maximum = frame.scrollBarMaximum(orientation)",
            "                    if maximum == 0:",
            "                        continue",
            "                    pos = int(maximum * val / 100)",
            "                    pos = qtutils.check_overflow(pos, 'int', fatal=False)",
            "                    frame.setScrollBarValue(orientation, pos)",
            "",
            "    def _key_press(self, key, count=1, getter_name=None, direction=None):",
            "        frame = self._widget.page().mainFrame()",
            "        getter = None if getter_name is None else getattr(frame, getter_name)",
            "",
            "        # FIXME:qtwebengine needed?",
            "        # self._widget.setFocus()",
            "",
            "        for _ in range(min(count, 5000)):",
            "            # Abort scrolling if the minimum/maximum was reached.",
            "            if (getter is not None and",
            "                    frame.scrollBarValue(direction) == getter(direction)):",
            "                return",
            "            self._tab.key_press(key)",
            "",
            "    def up(self, count=1):",
            "        self._key_press(Qt.Key_Up, count, 'scrollBarMinimum', Qt.Vertical)",
            "",
            "    def down(self, count=1):",
            "        self._key_press(Qt.Key_Down, count, 'scrollBarMaximum', Qt.Vertical)",
            "",
            "    def left(self, count=1):",
            "        self._key_press(Qt.Key_Left, count, 'scrollBarMinimum', Qt.Horizontal)",
            "",
            "    def right(self, count=1):",
            "        self._key_press(Qt.Key_Right, count, 'scrollBarMaximum', Qt.Horizontal)",
            "",
            "    def top(self):",
            "        self._key_press(Qt.Key_Home)",
            "",
            "    def bottom(self):",
            "        self._key_press(Qt.Key_End)",
            "",
            "    def page_up(self, count=1):",
            "        self._key_press(Qt.Key_PageUp, count, 'scrollBarMinimum', Qt.Vertical)",
            "",
            "    def page_down(self, count=1):",
            "        self._key_press(Qt.Key_PageDown, count, 'scrollBarMaximum',",
            "                        Qt.Vertical)",
            "",
            "    def at_top(self):",
            "        return self.pos_px().y() == 0",
            "",
            "    def at_bottom(self):",
            "        frame = self._widget.page().currentFrame()",
            "        return self.pos_px().y() >= frame.scrollBarMaximum(Qt.Vertical)",
            "",
            "",
            "class WebKitHistory(browsertab.AbstractHistory):",
            "",
            "    \"\"\"QtWebKit implementations related to page history.\"\"\"",
            "",
            "    def current_idx(self):",
            "        return self._history.currentItemIndex()",
            "",
            "    def can_go_back(self):",
            "        return self._history.canGoBack()",
            "",
            "    def can_go_forward(self):",
            "        return self._history.canGoForward()",
            "",
            "    def _item_at(self, i):",
            "        return self._history.itemAt(i)",
            "",
            "    def _go_to_item(self, item):",
            "        self._tab.predicted_navigation.emit(item.url())",
            "        self._history.goToItem(item)",
            "",
            "    def serialize(self):",
            "        return qtutils.serialize(self._history)",
            "",
            "    def deserialize(self, data):",
            "        return qtutils.deserialize(data, self._history)",
            "",
            "    def load_items(self, items):",
            "        if items:",
            "            self._tab.predicted_navigation.emit(items[-1].url)",
            "",
            "        stream, _data, user_data = tabhistory.serialize(items)",
            "        qtutils.deserialize_stream(stream, self._history)",
            "        for i, data in enumerate(user_data):",
            "            self._history.itemAt(i).setUserData(data)",
            "        cur_data = self._history.currentItem().userData()",
            "        if cur_data is not None:",
            "            if 'zoom' in cur_data:",
            "                self._tab.zoom.set_factor(cur_data['zoom'])",
            "            if ('scroll-pos' in cur_data and",
            "                    self._tab.scroller.pos_px() == QPoint(0, 0)):",
            "                QTimer.singleShot(0, functools.partial(",
            "                    self._tab.scroller.to_point, cur_data['scroll-pos']))",
            "",
            "",
            "class WebKitElements(browsertab.AbstractElements):",
            "",
            "    \"\"\"QtWebKit implemementations related to elements on the page.\"\"\"",
            "",
            "    def find_css(self, selector, callback, *, only_visible=False):",
            "        mainframe = self._widget.page().mainFrame()",
            "        if mainframe is None:",
            "            raise browsertab.WebTabError(\"No frame focused!\")",
            "",
            "        elems = []",
            "        frames = webkitelem.get_child_frames(mainframe)",
            "        for f in frames:",
            "            for elem in f.findAllElements(selector):",
            "                elems.append(webkitelem.WebKitElement(elem, tab=self._tab))",
            "",
            "        if only_visible:",
            "            # pylint: disable=protected-access",
            "            elems = [e for e in elems if e._is_visible(mainframe)]",
            "            # pylint: enable=protected-access",
            "",
            "        callback(elems)",
            "",
            "    def find_id(self, elem_id, callback):",
            "        def find_id_cb(elems):",
            "            \"\"\"Call the real callback with the found elements.\"\"\"",
            "            if not elems:",
            "                callback(None)",
            "            else:",
            "                callback(elems[0])",
            "",
            "        # Escape non-alphanumeric characters in the selector",
            "        # https://www.w3.org/TR/CSS2/syndata.html#value-def-identifier",
            "        elem_id = re.sub(r'[^a-zA-Z0-9_-]', r'\\\\\\g<0>', elem_id)",
            "        self.find_css('#' + elem_id, find_id_cb)",
            "",
            "    def find_focused(self, callback):",
            "        frame = self._widget.page().currentFrame()",
            "        if frame is None:",
            "            callback(None)",
            "            return",
            "",
            "        elem = frame.findFirstElement('*:focus')",
            "        if elem.isNull():",
            "            callback(None)",
            "        else:",
            "            callback(webkitelem.WebKitElement(elem, tab=self._tab))",
            "",
            "    def find_at_pos(self, pos, callback):",
            "        assert pos.x() >= 0",
            "        assert pos.y() >= 0",
            "        frame = self._widget.page().frameAt(pos)",
            "        if frame is None:",
            "            # This happens when we click inside the webview, but not actually",
            "            # on the QWebPage - for example when clicking the scrollbar",
            "            # sometimes.",
            "            log.webview.debug(\"Hit test at {} but frame is None!\".format(pos))",
            "            callback(None)",
            "            return",
            "",
            "        # You'd think we have to subtract frame.geometry().topLeft() from the",
            "        # position, but it seems QWebFrame::hitTestContent wants a position",
            "        # relative to the QWebView, not to the frame. This makes no sense to",
            "        # me, but it works this way.",
            "        hitresult = frame.hitTestContent(pos)",
            "        if hitresult.isNull():",
            "            # For some reason, the whole hit result can be null sometimes (e.g.",
            "            # on doodle menu links).",
            "            log.webview.debug(\"Hit test result is null!\")",
            "            callback(None)",
            "            return",
            "",
            "        try:",
            "            elem = webkitelem.WebKitElement(hitresult.element(), tab=self._tab)",
            "        except webkitelem.IsNullError:",
            "            # For some reason, the hit result element can be a null element",
            "            # sometimes (e.g. when clicking the timetable fields on",
            "            # http://www.sbb.ch/ ).",
            "            log.webview.debug(\"Hit test result element is null!\")",
            "            callback(None)",
            "            return",
            "",
            "        callback(elem)",
            "",
            "",
            "class WebKitAudio(browsertab.AbstractAudio):",
            "",
            "    \"\"\"Dummy handling of audio status for QtWebKit.\"\"\"",
            "",
            "    def set_muted(self, muted: bool):",
            "        raise browsertab.WebTabError('Muting is not supported on QtWebKit!')",
            "",
            "    def is_muted(self):",
            "        return False",
            "",
            "    def is_recently_audible(self):",
            "        return False",
            "",
            "",
            "class WebKitTab(browsertab.AbstractTab):",
            "",
            "    \"\"\"A QtWebKit tab in the browser.\"\"\"",
            "",
            "    def __init__(self, *, win_id, mode_manager, private, parent=None):",
            "        super().__init__(win_id=win_id, mode_manager=mode_manager,",
            "                         private=private, parent=parent)",
            "        widget = webview.WebView(win_id=win_id, tab_id=self.tab_id,",
            "                                 private=private, tab=self)",
            "        if private:",
            "            self._make_private(widget)",
            "        self.history = WebKitHistory(self)",
            "        self.scroller = WebKitScroller(self, parent=self)",
            "        self.caret = WebKitCaret(mode_manager=mode_manager,",
            "                                 tab=self, parent=self)",
            "        self.zoom = WebKitZoom(tab=self, parent=self)",
            "        self.search = WebKitSearch(parent=self)",
            "        self.printing = WebKitPrinting(tab=self)",
            "        self.elements = WebKitElements(tab=self)",
            "        self.action = WebKitAction(tab=self)",
            "        self.audio = WebKitAudio(parent=self)",
            "        # We're assigning settings in _set_widget",
            "        self.settings = webkitsettings.WebKitSettings(settings=None)",
            "        self._set_widget(widget)",
            "        self._connect_signals()",
            "        self.backend = usertypes.Backend.QtWebKit",
            "",
            "    def _install_event_filter(self):",
            "        self._widget.installEventFilter(self._mouse_event_filter)",
            "",
            "    def _make_private(self, widget):",
            "        settings = widget.settings()",
            "        settings.setAttribute(QWebSettings.PrivateBrowsingEnabled, True)",
            "",
            "    def openurl(self, url, *, predict=True):",
            "        self._openurl_prepare(url, predict=predict)",
            "        self._widget.openurl(url)",
            "",
            "    def url(self, requested=False):",
            "        frame = self._widget.page().mainFrame()",
            "        if requested:",
            "            return frame.requestedUrl()",
            "        else:",
            "            return frame.url()",
            "",
            "    def dump_async(self, callback, *, plain=False):",
            "        frame = self._widget.page().mainFrame()",
            "        if plain:",
            "            callback(frame.toPlainText())",
            "        else:",
            "            callback(frame.toHtml())",
            "",
            "    def run_js_async(self, code, callback=None, *, world=None):",
            "        if world is not None and world != usertypes.JsWorld.jseval:",
            "            log.webview.warning(\"Ignoring world ID {}\".format(world))",
            "        document_element = self._widget.page().mainFrame().documentElement()",
            "        result = document_element.evaluateJavaScript(code)",
            "        if callback is not None:",
            "            callback(result)",
            "",
            "    def icon(self):",
            "        return self._widget.icon()",
            "",
            "    def shutdown(self):",
            "        self._widget.shutdown()",
            "",
            "    def reload(self, *, force=False):",
            "        if force:",
            "            action = QWebPage.ReloadAndBypassCache",
            "        else:",
            "            action = QWebPage.Reload",
            "        self._widget.triggerPageAction(action)",
            "",
            "    def stop(self):",
            "        self._widget.stop()",
            "",
            "    def title(self):",
            "        return self._widget.title()",
            "",
            "    def clear_ssl_errors(self):",
            "        self.networkaccessmanager().clear_all_ssl_errors()",
            "",
            "    def key_press(self, key, modifier=Qt.NoModifier):",
            "        press_evt = QKeyEvent(QEvent.KeyPress, key, modifier, 0, 0, 0)",
            "        release_evt = QKeyEvent(QEvent.KeyRelease, key, modifier,",
            "                                0, 0, 0)",
            "        self.send_event(press_evt)",
            "        self.send_event(release_evt)",
            "",
            "    @pyqtSlot()",
            "    def _on_history_trigger(self):",
            "        url = self.url()",
            "        requested_url = self.url(requested=True)",
            "        self.add_history_item.emit(url, requested_url, self.title())",
            "",
            "    def set_html(self, html, base_url=QUrl()):",
            "        self._widget.setHtml(html, base_url)",
            "",
            "    def networkaccessmanager(self):",
            "        return self._widget.page().networkAccessManager()",
            "",
            "    def user_agent(self):",
            "        page = self._widget.page()",
            "        return page.userAgentForUrl(self.url())",
            "",
            "    @pyqtSlot()",
            "    def _on_load_started(self):",
            "        super()._on_load_started()",
            "        self.networkaccessmanager().netrc_used = False",
            "        # Make sure the icon is cleared when navigating to a page without one.",
            "        self.icon_changed.emit(QIcon())",
            "",
            "    @pyqtSlot()",
            "    def _on_frame_load_finished(self):",
            "        \"\"\"Make sure we emit an appropriate status when loading finished.",
            "",
            "        While Qt has a bool \"ok\" attribute for loadFinished, it always is True",
            "        when using error pages... See",
            "        https://github.com/qutebrowser/qutebrowser/issues/84",
            "        \"\"\"",
            "        self._on_load_finished(not self._widget.page().error_occurred)",
            "",
            "    @pyqtSlot()",
            "    def _on_webkit_icon_changed(self):",
            "        \"\"\"Emit iconChanged with a QIcon like QWebEngineView does.\"\"\"",
            "        if sip.isdeleted(self._widget):",
            "            log.webview.debug(\"Got _on_webkit_icon_changed for deleted view!\")",
            "            return",
            "        self.icon_changed.emit(self._widget.icon())",
            "",
            "    @pyqtSlot(QWebFrame)",
            "    def _on_frame_created(self, frame):",
            "        \"\"\"Connect the contentsSizeChanged signal of each frame.\"\"\"",
            "        # FIXME:qtwebengine those could theoretically regress:",
            "        # https://github.com/qutebrowser/qutebrowser/issues/152",
            "        # https://github.com/qutebrowser/qutebrowser/issues/263",
            "        frame.contentsSizeChanged.connect(self._on_contents_size_changed)",
            "",
            "    @pyqtSlot(QSize)",
            "    def _on_contents_size_changed(self, size):",
            "        self.contents_size_changed.emit(QSizeF(size))",
            "",
            "    @pyqtSlot(usertypes.NavigationRequest)",
            "    def _on_navigation_request(self, navigation):",
            "        super()._on_navigation_request(navigation)",
            "        if not navigation.accepted:",
            "            return",
            "",
            "        log.webview.debug(\"target {} override {}\".format(",
            "            self.data.open_target, self.data.override_target))",
            "",
            "        if self.data.override_target is not None:",
            "            target = self.data.override_target",
            "            self.data.override_target = None",
            "        else:",
            "            target = self.data.open_target",
            "",
            "        if (navigation.navigation_type == navigation.Type.link_clicked and",
            "                target != usertypes.ClickTarget.normal):",
            "            tab = shared.get_tab(self.win_id, target)",
            "            tab.openurl(navigation.url)",
            "            self.data.open_target = usertypes.ClickTarget.normal",
            "            navigation.accepted = False",
            "",
            "        if navigation.is_main_frame:",
            "            self.settings.update_for_url(navigation.url)",
            "",
            "    @pyqtSlot('QNetworkReply*')",
            "    def _on_ssl_errors(self, reply):",
            "        self._insecure_hosts.add(reply.url().host())",
            "",
            "    def _connect_signals(self):",
            "        view = self._widget",
            "        page = view.page()",
            "        frame = page.mainFrame()",
            "        page.windowCloseRequested.connect(self.window_close_requested)",
            "        page.linkHovered.connect(self.link_hovered)",
            "        page.loadProgress.connect(self._on_load_progress)",
            "        frame.loadStarted.connect(self._on_load_started)",
            "        view.scroll_pos_changed.connect(self.scroller.perc_changed)",
            "        view.titleChanged.connect(self.title_changed)",
            "        view.urlChanged.connect(self._on_url_changed)",
            "        view.shutting_down.connect(self.shutting_down)",
            "        page.networkAccessManager().sslErrors.connect(self._on_ssl_errors)",
            "        frame.loadFinished.connect(self._on_frame_load_finished)",
            "        view.iconChanged.connect(self._on_webkit_icon_changed)",
            "        page.frameCreated.connect(self._on_frame_created)",
            "        frame.contentsSizeChanged.connect(self._on_contents_size_changed)",
            "        frame.initialLayoutCompleted.connect(self._on_history_trigger)",
            "        page.navigation_request.connect(self._on_navigation_request)",
            "",
            "    def event_target(self):",
            "        return self._widget"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "811": [
                "WebKitTab"
            ],
            "812": [
                "WebKitTab",
                "_on_ssl_errors"
            ],
            "813": [
                "WebKitTab",
                "_on_ssl_errors"
            ]
        },
        "addLocation": []
    }
}