{
    "transmute_core/contenttype_serializers/json_serializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " class JsonSerializer(ContentTypeSerializer):"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     content_type = [\"application/json\"]"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     @staticmethod"
            }
        },
        "frontPatchFile": [
            "import json",
            "from .interface import ContentTypeSerializer",
            "from ..exceptions import SerializationException",
            "from ..compat import string_type",
            "",
            "",
            "class JsonSerializer(ContentTypeSerializer):",
            "",
            "    content_type = [\"application/json\"]",
            "",
            "    @staticmethod",
            "    def dump(data):",
            "        \"\"\"",
            "        should return back a bytes (or string in python 2),",
            "        representation of your object, to be used in e.g. response",
            "        bodies.",
            "        \"\"\"",
            "        return json.dumps(data).encode(\"UTF-8\")",
            "",
            "    @property",
            "    def main_type(self):",
            "        return self.content_type[0]",
            "",
            "    @staticmethod",
            "    def load(raw_bytes):",
            "        \"\"\"",
            "        given a bytes object, should return a base python data",
            "        structure that represents the object.",
            "        \"\"\"",
            "        try:",
            "            if not isinstance(raw_bytes, string_type):",
            "                raw_bytes = raw_bytes.decode()",
            "            return json.loads(raw_bytes)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def can_handle(content_type_name):",
            "        \"\"\"",
            "        given a content type, returns true if this serializer",
            "        can convert bodies of the given type.",
            "        \"\"\"",
            "        return \"json\" in content_type_name"
        ],
        "afterPatchFile": [
            "import json",
            "from .interface import ContentTypeSerializer",
            "from ..exceptions import SerializationException",
            "from ..compat import string_type",
            "",
            "",
            "class JsonSerializer(ContentTypeSerializer):",
            "    content_type = [\"application/json\"]",
            "",
            "    @staticmethod",
            "    def dump(data):",
            "        \"\"\"",
            "        should return back a bytes (or string in python 2),",
            "        representation of your object, to be used in e.g. response",
            "        bodies.",
            "        \"\"\"",
            "        return json.dumps(data).encode(\"UTF-8\")",
            "",
            "    @property",
            "    def main_type(self):",
            "        return self.content_type[0]",
            "",
            "    @staticmethod",
            "    def load(raw_bytes):",
            "        \"\"\"",
            "        given a bytes object, should return a base python data",
            "        structure that represents the object.",
            "        \"\"\"",
            "        try:",
            "            if not isinstance(raw_bytes, string_type):",
            "                raw_bytes = raw_bytes.decode()",
            "            return json.loads(raw_bytes)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def can_handle(content_type_name):",
            "        \"\"\"",
            "        given a content type, returns true if this serializer",
            "        can convert bodies of the given type.",
            "        \"\"\"",
            "        return \"json\" in content_type_name"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [
                "JsonSerializer"
            ]
        },
        "addLocation": []
    },
    "transmute_core/contenttype_serializers/yaml_serializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " class YamlSerializer(ContentTypeSerializer):"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "     content_type = [\"application/x-yaml\"]"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     @staticmethod"
            },
            "7": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         structure that represents the object."
            },
            "8": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         try:"
            },
            "10": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return yaml.load(raw_bytes, Loader=yaml.Loader)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            return yaml.load(raw_bytes, Loader=yaml.SafeLoader)"
            },
            "12": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         except yaml.scanner.ScannerError as e:"
            },
            "13": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "             raise SerializationException(str(e))"
            },
            "14": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import yaml",
            "from .interface import ContentTypeSerializer",
            "from ..exceptions import SerializationException",
            "",
            "",
            "class YamlSerializer(ContentTypeSerializer):",
            "",
            "    content_type = [\"application/x-yaml\"]",
            "",
            "    @staticmethod",
            "    def dump(data):",
            "        \"\"\"",
            "        should return back a bytes (or string in python 2),",
            "        representation of your object, to be used in e.g. response",
            "        bodies.",
            "        \"\"\"",
            "        return yaml.dump(data, default_flow_style=False).encode(\"UTF-8\")",
            "",
            "    @classmethod",
            "    def main_type(cls):",
            "        return cls.content_type[0]",
            "",
            "    @staticmethod",
            "    def load(raw_bytes):",
            "        \"\"\"",
            "        given a bytes object, should return a base python data",
            "        structure that represents the object.",
            "        \"\"\"",
            "        try:",
            "            return yaml.load(raw_bytes, Loader=yaml.Loader)",
            "        except yaml.scanner.ScannerError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def can_handle(content_type_name):",
            "        \"\"\"",
            "        given a content type, returns true if this serializer",
            "        can convert bodies of the given type.",
            "        \"\"\"",
            "        return \"yaml\" in content_type_name"
        ],
        "afterPatchFile": [
            "import yaml",
            "from .interface import ContentTypeSerializer",
            "from ..exceptions import SerializationException",
            "",
            "",
            "class YamlSerializer(ContentTypeSerializer):",
            "    content_type = [\"application/x-yaml\"]",
            "",
            "    @staticmethod",
            "    def dump(data):",
            "        \"\"\"",
            "        should return back a bytes (or string in python 2),",
            "        representation of your object, to be used in e.g. response",
            "        bodies.",
            "        \"\"\"",
            "        return yaml.dump(data, default_flow_style=False).encode(\"UTF-8\")",
            "",
            "    @classmethod",
            "    def main_type(cls):",
            "        return cls.content_type[0]",
            "",
            "    @staticmethod",
            "    def load(raw_bytes):",
            "        \"\"\"",
            "        given a bytes object, should return a base python data",
            "        structure that represents the object.",
            "        \"\"\"",
            "        try:",
            "            return yaml.load(raw_bytes, Loader=yaml.SafeLoader)",
            "        except yaml.scanner.ScannerError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def can_handle(content_type_name):",
            "        \"\"\"",
            "        given a content type, returns true if this serializer",
            "        can convert bodies of the given type.",
            "        \"\"\"",
            "        return \"yaml\" in content_type_name"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [
                "YamlSerializer"
            ],
            "30": [
                "YamlSerializer",
                "load"
            ]
        },
        "addLocation": []
    },
    "transmute_core/frameworks/tornado/swagger.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " def generate_swagger_json_handler(app, context, **kwargs):"
            },
            "3": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     swagger_json = _generate_swagger_json(app, context, **kwargs)"
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     class SwaggerSpecHandler(tornado.web.RequestHandler):"
            }
        },
        "frontPatchFile": [
            "from transmute_core.swagger import (",
            "    generate_swagger_html,",
            "    get_swagger_static_root,",
            "    SwaggerSpec,",
            ")",
            "from transmute_core import default_context",
            "import tornado",
            "import tornado.web",
            "",
            "USE_ROUTER = tornado.version_info >= (4, 5)",
            "METHODS = [\"get\", \"post\", \"delete\", \"put\"]",
            "STATIC_ROOT = \"/_swagger/static\"",
            "",
            "",
            "def add_swagger(app, json_route, html_route, context=default_context):",
            "    app.add_handlers(",
            "        \".*\",",
            "        [",
            "            (json_route, generate_swagger_json_handler(app, context)),",
            "        ]",
            "        + add_swagger_api_route(html_route, json_route),",
            "    )",
            "",
            "",
            "def generate_swagger_json_handler(app, context, **kwargs):",
            "",
            "    swagger_json = _generate_swagger_json(app, context, **kwargs)",
            "",
            "    class SwaggerSpecHandler(tornado.web.RequestHandler):",
            "        def get(self):",
            "            self.write(swagger_json)",
            "            self.finish()",
            "",
            "    return SwaggerSpecHandler",
            "",
            "",
            "def _get_handlers(app):",
            "    if USE_ROUTER:",
            "        for rule in app.wildcard_router.rules:",
            "            yield rule.target",
            "    else:",
            "        for domain, specs in app.handlers:",
            "            for s in specs:",
            "                yield s.handler_class",
            "",
            "",
            "def _generate_swagger_json(app, context, **kwargs):",
            "    spec = SwaggerSpec()",
            "    for handler in _get_handlers(app):",
            "        for m in METHODS:",
            "            method = getattr(handler, m)",
            "            if hasattr(method, \"transmute_func\"):",
            "                spec.add_func(method.transmute_func, context)",
            "    return spec.swagger_definition(**kwargs)",
            "",
            "",
            "def add_swagger_api_route(target_route, swagger_json_route):",
            "    static_root = get_swagger_static_root()",
            "    swagger_body = generate_swagger_html(STATIC_ROOT, swagger_json_route)",
            "",
            "    class SwaggerBodyHandler(tornado.web.RequestHandler):",
            "        def get(self):",
            "            self.write(swagger_body)",
            "            self.finish()",
            "",
            "    return [",
            "        (target_route, SwaggerBodyHandler),",
            "        (STATIC_ROOT + \"/(.*)\", tornado.web.StaticFileHandler, {\"path\": static_root}),",
            "    ]"
        ],
        "afterPatchFile": [
            "from transmute_core.swagger import (",
            "    generate_swagger_html,",
            "    get_swagger_static_root,",
            "    SwaggerSpec,",
            ")",
            "from transmute_core import default_context",
            "import tornado",
            "import tornado.web",
            "",
            "USE_ROUTER = tornado.version_info >= (4, 5)",
            "METHODS = [\"get\", \"post\", \"delete\", \"put\"]",
            "STATIC_ROOT = \"/_swagger/static\"",
            "",
            "",
            "def add_swagger(app, json_route, html_route, context=default_context):",
            "    app.add_handlers(",
            "        \".*\",",
            "        [",
            "            (json_route, generate_swagger_json_handler(app, context)),",
            "        ]",
            "        + add_swagger_api_route(html_route, json_route),",
            "    )",
            "",
            "",
            "def generate_swagger_json_handler(app, context, **kwargs):",
            "    swagger_json = _generate_swagger_json(app, context, **kwargs)",
            "",
            "    class SwaggerSpecHandler(tornado.web.RequestHandler):",
            "        def get(self):",
            "            self.write(swagger_json)",
            "            self.finish()",
            "",
            "    return SwaggerSpecHandler",
            "",
            "",
            "def _get_handlers(app):",
            "    if USE_ROUTER:",
            "        for rule in app.wildcard_router.rules:",
            "            yield rule.target",
            "    else:",
            "        for domain, specs in app.handlers:",
            "            for s in specs:",
            "                yield s.handler_class",
            "",
            "",
            "def _generate_swagger_json(app, context, **kwargs):",
            "    spec = SwaggerSpec()",
            "    for handler in _get_handlers(app):",
            "        for m in METHODS:",
            "            method = getattr(handler, m)",
            "            if hasattr(method, \"transmute_func\"):",
            "                spec.add_func(method.transmute_func, context)",
            "    return spec.swagger_definition(**kwargs)",
            "",
            "",
            "def add_swagger_api_route(target_route, swagger_json_route):",
            "    static_root = get_swagger_static_root()",
            "    swagger_body = generate_swagger_html(STATIC_ROOT, swagger_json_route)",
            "",
            "    class SwaggerBodyHandler(tornado.web.RequestHandler):",
            "        def get(self):",
            "            self.write(swagger_body)",
            "            self.finish()",
            "",
            "    return [",
            "        (target_route, SwaggerBodyHandler),",
            "        (STATIC_ROOT + \"/(.*)\", tornado.web.StaticFileHandler, {\"path\": static_root}),",
            "    ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [
                "generate_swagger_json_handler"
            ]
        },
        "addLocation": []
    },
    "transmute_core/function/signature.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " class FunctionSignature(object):"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     NoDefault = NoDefault"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     def __init__(self, args, kwargs):"
            }
        },
        "frontPatchFile": [
            "import attr",
            "",
            "",
            "class NoDefault(object):",
            "    def __str__(self):",
            "        return \"NoDefault\"",
            "",
            "    def __repr__(self):",
            "        return \"NoDefault\"",
            "",
            "",
            "NoDefault = NoDefault()",
            "",
            "",
            "@attr.s",
            "class Argument(object):",
            "    name = attr.ib()",
            "    default = attr.ib()",
            "    type = attr.ib()",
            "",
            "",
            "class FunctionSignature(object):",
            "",
            "    NoDefault = NoDefault",
            "",
            "    def __init__(self, args, kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "    def get_argument(self, key):",
            "        if key in self.kwargs:",
            "            return self.kwargs[key]",
            "        for arg in self.args:",
            "            if arg.name == key:",
            "                return arg",
            "",
            "    @staticmethod",
            "    def from_argspec(argspec):",
            "        \"\"\"",
            "        retrieve a FunctionSignature object",
            "        from the argspec and the annotations passed.",
            "        \"\"\"",
            "        attributes = getattr(argspec, \"args\", []) + getattr(argspec, \"keywords\", [])",
            "        defaults = argspec.defaults or []",
            "",
            "        arguments, keywords = [], {}",
            "",
            "        attribute_list = (",
            "            attributes[: -len(defaults)] if len(defaults) != 0 else attributes[:]",
            "        )",
            "        for name in attribute_list:",
            "            if name == \"self\":",
            "                continue",
            "            typ = argspec.annotations.get(name)",
            "            arguments.append(Argument(name, NoDefault, typ))",
            "",
            "        if len(defaults) != 0:",
            "            for name, default in zip(attributes[-len(defaults) :], defaults):",
            "                typ = argspec.annotations.get(name)",
            "                keywords[name] = Argument(name, default, typ)",
            "",
            "        return FunctionSignature(arguments, keywords)",
            "",
            "    def __iter__(self):",
            "        for arg in self.args:",
            "            yield arg",
            "        for kwarg in self.kwargs.values():",
            "            yield kwarg",
            "",
            "    def split_args(self, arg_dict):",
            "        \"\"\"",
            "        given a dictionary of arguments, split them into",
            "        args and kwargs",
            "",
            "        note: this destroys the arg_dict passed. if you need it,",
            "        create a copy first.",
            "        \"\"\"",
            "        pos_args = []",
            "        for arg in self.args:",
            "            pos_args.append(arg_dict[arg.name])",
            "            del arg_dict[arg.name]",
            "        return pos_args, arg_dict"
        ],
        "afterPatchFile": [
            "import attr",
            "",
            "",
            "class NoDefault(object):",
            "    def __str__(self):",
            "        return \"NoDefault\"",
            "",
            "    def __repr__(self):",
            "        return \"NoDefault\"",
            "",
            "",
            "NoDefault = NoDefault()",
            "",
            "",
            "@attr.s",
            "class Argument(object):",
            "    name = attr.ib()",
            "    default = attr.ib()",
            "    type = attr.ib()",
            "",
            "",
            "class FunctionSignature(object):",
            "    NoDefault = NoDefault",
            "",
            "    def __init__(self, args, kwargs):",
            "        self.args = args",
            "        self.kwargs = kwargs",
            "",
            "    def get_argument(self, key):",
            "        if key in self.kwargs:",
            "            return self.kwargs[key]",
            "        for arg in self.args:",
            "            if arg.name == key:",
            "                return arg",
            "",
            "    @staticmethod",
            "    def from_argspec(argspec):",
            "        \"\"\"",
            "        retrieve a FunctionSignature object",
            "        from the argspec and the annotations passed.",
            "        \"\"\"",
            "        attributes = getattr(argspec, \"args\", []) + getattr(argspec, \"keywords\", [])",
            "        defaults = argspec.defaults or []",
            "",
            "        arguments, keywords = [], {}",
            "",
            "        attribute_list = (",
            "            attributes[: -len(defaults)] if len(defaults) != 0 else attributes[:]",
            "        )",
            "        for name in attribute_list:",
            "            if name == \"self\":",
            "                continue",
            "            typ = argspec.annotations.get(name)",
            "            arguments.append(Argument(name, NoDefault, typ))",
            "",
            "        if len(defaults) != 0:",
            "            for name, default in zip(attributes[-len(defaults) :], defaults):",
            "                typ = argspec.annotations.get(name)",
            "                keywords[name] = Argument(name, default, typ)",
            "",
            "        return FunctionSignature(arguments, keywords)",
            "",
            "    def __iter__(self):",
            "        for arg in self.args:",
            "            yield arg",
            "        for kwarg in self.kwargs.values():",
            "            yield kwarg",
            "",
            "    def split_args(self, arg_dict):",
            "        \"\"\"",
            "        given a dictionary of arguments, split them into",
            "        args and kwargs",
            "",
            "        note: this destroys the arg_dict passed. if you need it,",
            "        create a copy first.",
            "        \"\"\"",
            "        pos_args = []",
            "        for arg in self.args:",
            "            pos_args.append(arg_dict[arg.name])",
            "            del arg_dict[arg.name]",
            "        return pos_args, arg_dict"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [
                "FunctionSignature"
            ]
        },
        "addLocation": []
    },
    "transmute_core/object_serializers/cattrs_serializer/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from jsonschema_extractor import init_default_extractor"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from .converter import create_cattrs_converter"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from ...exceptions import SerializationException"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from cattrs.errors import ClassValidationError"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " class CattrsSerializer(ObjectSerializer):"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         try:"
            },
            "9": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "             return self._cattrs_converter.structure(value, model)"
            },
            "10": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except (ValueError, TypeError) as e:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        except (ValueError, TypeError, ClassValidationError) as e:"
            },
            "12": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "             raise SerializationException(str(e))"
            },
            "13": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     def dump(self, model, value):"
            }
        },
        "frontPatchFile": [
            "from ..interface import ObjectSerializer",
            "from jsonschema_extractor import init_default_extractor",
            "from .converter import create_cattrs_converter",
            "from ...exceptions import SerializationException",
            "",
            "",
            "class CattrsSerializer(ObjectSerializer):",
            "    \"\"\"",
            "    A serializer that's intended to become",
            "    the pattern for 2.0",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._schema_extractor = init_default_extractor()",
            "        self._cattrs_converter = create_cattrs_converter()",
            "        # to be compatible with older versions of cattrs,",
            "        # attempt to discover the version of structure_error to use.",
            "        if hasattr(self._cattrs_converter, \"_structure_error\"):",
            "            self._structure_error = self._cattrs_converter._structure_error",
            "        else:",
            "            self._structure_error = self._cattrs_converter._structure_default",
            "",
            "    def can_handle(self, cls):",
            "        \"\"\"",
            "        this will theoretically be compatible with everything,",
            "        as cattrs can handle many basic types as well.",
            "        \"\"\"",
            "        # cattrs uses a Singledispatch like function",
            "        # under the hood.",
            "        f = self._cattrs_converter._structure_func.dispatch(cls)",
            "        return f != self._structure_error",
            "",
            "    def load(self, model, value):",
            "        \"\"\"",
            "        Converts unstructured data into structured data, recursively.",
            "        \"\"\"",
            "        try:",
            "            return self._cattrs_converter.structure(value, model)",
            "        except (ValueError, TypeError) as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, model, value):",
            "        \"\"\"",
            "        Convert attrs data into unstructured data with basic types, recursively:",
            "",
            "        - attrs classes => dictionaries",
            "        - Enumeration => values",
            "        - Other types are let through without conversion,",
            "          such as, int, boolean, dict, other classes.",
            "        \"\"\"",
            "        try:",
            "            return self._cattrs_converter.unstructure(value)",
            "        except (ValueError, TypeError) as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def to_json_schema(self, model):",
            "        return self._schema_extractor.extract(model)"
        ],
        "afterPatchFile": [
            "from ..interface import ObjectSerializer",
            "from jsonschema_extractor import init_default_extractor",
            "from .converter import create_cattrs_converter",
            "from ...exceptions import SerializationException",
            "from cattrs.errors import ClassValidationError",
            "",
            "",
            "class CattrsSerializer(ObjectSerializer):",
            "    \"\"\"",
            "    A serializer that's intended to become",
            "    the pattern for 2.0",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._schema_extractor = init_default_extractor()",
            "        self._cattrs_converter = create_cattrs_converter()",
            "        # to be compatible with older versions of cattrs,",
            "        # attempt to discover the version of structure_error to use.",
            "        if hasattr(self._cattrs_converter, \"_structure_error\"):",
            "            self._structure_error = self._cattrs_converter._structure_error",
            "        else:",
            "            self._structure_error = self._cattrs_converter._structure_default",
            "",
            "    def can_handle(self, cls):",
            "        \"\"\"",
            "        this will theoretically be compatible with everything,",
            "        as cattrs can handle many basic types as well.",
            "        \"\"\"",
            "        # cattrs uses a Singledispatch like function",
            "        # under the hood.",
            "        f = self._cattrs_converter._structure_func.dispatch(cls)",
            "        return f != self._structure_error",
            "",
            "    def load(self, model, value):",
            "        \"\"\"",
            "        Converts unstructured data into structured data, recursively.",
            "        \"\"\"",
            "        try:",
            "            return self._cattrs_converter.structure(value, model)",
            "        except (ValueError, TypeError, ClassValidationError) as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, model, value):",
            "        \"\"\"",
            "        Convert attrs data into unstructured data with basic types, recursively:",
            "",
            "        - attrs classes => dictionaries",
            "        - Enumeration => values",
            "        - Other types are let through without conversion,",
            "          such as, int, boolean, dict, other classes.",
            "        \"\"\"",
            "        try:",
            "            return self._cattrs_converter.unstructure(value)",
            "        except (ValueError, TypeError) as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def to_json_schema(self, model):",
            "        return self._schema_extractor.extract(model)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "39": [
                "CattrsSerializer",
                "load"
            ]
        },
        "addLocation": []
    },
    "transmute_core/object_serializers/cattrs_serializer/converter.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # from .cattrs_extended_converter import ExtendedConverter"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from cattr import Converter"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from cattrs import Converter"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from datetime import datetime"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from ...compat import string_type"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from schematics.models import Model"
            }
        },
        "frontPatchFile": [
            "# from .cattrs_extended_converter import ExtendedConverter",
            "from cattr import Converter",
            "from datetime import datetime",
            "from ...compat import string_type",
            "from schematics.models import Model",
            "from schematics.types import DateTimeType, BaseType",
            "from schematics.exceptions import BaseError",
            "",
            "",
            "def create_cattrs_converter():",
            "    converter = Converter()",
            "    converter.register_structure_hook(bool, _structure_bool)",
            "    converter.register_structure_hook(string_type, _structure_string)",
            "    converter.register_structure_hook(Model, _structure_schematics)",
            "    converter.register_structure_hook(BaseType, _structure_basetype)",
            "    converter.register_structure_hook(datetime, _structure_datetime)",
            "    converter.register_unstructure_hook(Model, _unstructure_schematics)",
            "    converter.register_unstructure_hook(datetime, _unstructure_datetime)",
            "    converter.register_unstructure_hook(BaseType, _unstructure_basetype)",
            "    return converter",
            "",
            "",
            "def _structure_bool(data, cls):",
            "    if isinstance(data, bool):",
            "        return data",
            "    return str(data).lower().startswith(\"t\")",
            "",
            "",
            "def _structure_string(data, cls):",
            "    return str(data)",
            "",
            "",
            "def _structure_schematics(data, cls):",
            "    value = cls(data)",
            "    try:",
            "        value.validate()",
            "        return value",
            "    except BaseError as de:",
            "        raise ValueError(str(de))",
            "",
            "",
            "def _unstructure_schematics(data):",
            "    return data.to_primitive()",
            "",
            "",
            "datetime_type = DateTimeType()",
            "",
            "",
            "def _structure_datetime(data, cls):",
            "    if not data:",
            "        raise ValueError(\"datetime is empty\")",
            "    return datetime_type.to_native(data)",
            "",
            "",
            "def _unstructure_datetime(data):",
            "    return data.isoformat()",
            "",
            "",
            "def _structure_basetype(data, cls):",
            "    return data",
            "",
            "",
            "def _unstructure_basetype(data, cls):",
            "    return cls().to_primitive(data)"
        ],
        "afterPatchFile": [
            "# from .cattrs_extended_converter import ExtendedConverter",
            "from cattrs import Converter",
            "from datetime import datetime",
            "from ...compat import string_type",
            "from schematics.models import Model",
            "from schematics.types import DateTimeType, BaseType",
            "from schematics.exceptions import BaseError",
            "",
            "",
            "def create_cattrs_converter():",
            "    converter = Converter()",
            "    converter.register_structure_hook(bool, _structure_bool)",
            "    converter.register_structure_hook(string_type, _structure_string)",
            "    converter.register_structure_hook(Model, _structure_schematics)",
            "    converter.register_structure_hook(BaseType, _structure_basetype)",
            "    converter.register_structure_hook(datetime, _structure_datetime)",
            "    converter.register_unstructure_hook(Model, _unstructure_schematics)",
            "    converter.register_unstructure_hook(datetime, _unstructure_datetime)",
            "    converter.register_unstructure_hook(BaseType, _unstructure_basetype)",
            "    return converter",
            "",
            "",
            "def _structure_bool(data, cls):",
            "    if isinstance(data, bool):",
            "        return data",
            "    return str(data).lower().startswith(\"t\")",
            "",
            "",
            "def _structure_string(data, cls):",
            "    return str(data)",
            "",
            "",
            "def _structure_schematics(data, cls):",
            "    value = cls(data)",
            "    try:",
            "        value.validate()",
            "        return value",
            "    except BaseError as de:",
            "        raise ValueError(str(de))",
            "",
            "",
            "def _unstructure_schematics(data):",
            "    return data.to_primitive()",
            "",
            "",
            "datetime_type = DateTimeType()",
            "",
            "",
            "def _structure_datetime(data, cls):",
            "    if not data:",
            "        raise ValueError(\"datetime is empty\")",
            "    return datetime_type.to_native(data)",
            "",
            "",
            "def _unstructure_datetime(data):",
            "    return data.isoformat()",
            "",
            "",
            "def _structure_basetype(data, cls):",
            "    return data",
            "",
            "",
            "def _unstructure_basetype(data, cls):",
            "    return cls().to_primitive(data)"
        ],
        "action": [
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": []
        },
        "addLocation": []
    },
    "transmute_core/object_serializers/primitive_serializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " class DecimalSerializer(object):"
            },
            "3": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     SERIALIZER = DecimalType()"
            },
            "5": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     def can_handle(self, cls):"
            },
            "7": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " class DateTimeSerializer(object):"
            },
            "10": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     SERIALIZER = DateTimeType()"
            },
            "12": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     def can_handle(self, cls):"
            }
        },
        "frontPatchFile": [
            "from ..compat import all_string_types, string_type",
            "from ..exceptions import SerializationException",
            "from schematics.exceptions import BaseError",
            "from schematics.types import DecimalType, DateTimeType",
            "from decimal import Decimal",
            "from datetime import datetime",
            "",
            "",
            "class IntSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, int)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"integer\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        try:",
            "            return int(obj)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class FloatSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, float)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"number\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        try:",
            "            return float(obj)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class StringSerializer:",
            "    def can_handle(self, cls):",
            "        return any(issubclass(cls, t) for t in all_string_types)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"string\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        return obj",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class BoolSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, bool)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"boolean\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        if isinstance(obj, string_type):",
            "            return obj.lower().startswith(\"t\")",
            "        return bool(obj)",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class NoneSerializer(object):",
            "    def can_handle(self, cls):",
            "        return cls is None",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"object\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        return obj",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class DecimalSerializer(object):",
            "",
            "    SERIALIZER = DecimalType()",
            "",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, Decimal)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"number\"}",
            "",
            "    def load(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_native(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_primitive(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "",
            "class DateTimeSerializer(object):",
            "",
            "    SERIALIZER = DateTimeType()",
            "",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, datetime)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"string\", \"format\": \"date-time\"}",
            "",
            "    def load(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_native(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_primitive(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))"
        ],
        "afterPatchFile": [
            "from ..compat import all_string_types, string_type",
            "from ..exceptions import SerializationException",
            "from schematics.exceptions import BaseError",
            "from schematics.types import DecimalType, DateTimeType",
            "from decimal import Decimal",
            "from datetime import datetime",
            "",
            "",
            "class IntSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, int)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"integer\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        try:",
            "            return int(obj)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class FloatSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, float)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"number\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        try:",
            "            return float(obj)",
            "        except ValueError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class StringSerializer:",
            "    def can_handle(self, cls):",
            "        return any(issubclass(cls, t) for t in all_string_types)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"string\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        return obj",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class BoolSerializer:",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, bool)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"boolean\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        if isinstance(obj, string_type):",
            "            return obj.lower().startswith(\"t\")",
            "        return bool(obj)",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class NoneSerializer(object):",
            "    def can_handle(self, cls):",
            "        return cls is None",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"object\"}",
            "",
            "    @staticmethod",
            "    def load(cls, obj):",
            "        return obj",
            "",
            "    @staticmethod",
            "    def dump(cls, obj):",
            "        return obj",
            "",
            "",
            "class DecimalSerializer(object):",
            "    SERIALIZER = DecimalType()",
            "",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, Decimal)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"number\"}",
            "",
            "    def load(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_native(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_primitive(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "",
            "class DateTimeSerializer(object):",
            "    SERIALIZER = DateTimeType()",
            "",
            "    def can_handle(self, cls):",
            "        return issubclass(cls, datetime)",
            "",
            "    @staticmethod",
            "    def to_json_schema(cls):",
            "        return {\"type\": \"string\", \"format\": \"date-time\"}",
            "",
            "    def load(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_native(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))",
            "",
            "    def dump(self, cls, obj):",
            "        try:",
            "            return self.SERIALIZER.to_primitive(obj)",
            "        except BaseError as e:",
            "            raise SerializationException(str(e))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "103": [
                "DecimalSerializer"
            ],
            "127": [
                "DateTimeSerializer"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/conftest.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " class Pet(Model):"
            },
            "3": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     kind = StringType(required=True)"
            },
            "5": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     age = IntType()"
            },
            "6": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import pytest",
            "from transmute_core import (",
            "    annotate,",
            "    describe,",
            "    default_context,",
            "    get_default_serializer_set,",
            "    get_default_object_serializer_set,",
            "    Response,",
            "    SchematicsSerializer,",
            "    TransmuteFunction,",
            ")",
            "from schematics.models import Model",
            "from schematics.types import StringType, IntType",
            "",
            "",
            "@pytest.fixture",
            "def context():",
            "    return default_context",
            "",
            "",
            "@pytest.fixture",
            "def serializer_set():",
            "    return get_default_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def object_serializers():",
            "    return get_default_object_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def object_serializer_set():",
            "    return get_default_object_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def serializer():",
            "    return SchematicsSerializer()",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func():",
            "    @describe(paths=\"/api/v1/multiply\")",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func_custom_code():",
            "    @describe(paths=\"/api/v1/multiply\", success_code=201)",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func_post():",
            "    @describe(paths=\"/api/v1/multiply\", methods=[\"POST\"])",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "class Pet(Model):",
            "",
            "    kind = StringType(required=True)",
            "    age = IntType()",
            "",
            "",
            "@pytest.fixture",
            "def single_body_transmute_func():",
            "    @describe(paths=\"/\", body_parameters=\"body\")",
            "    @annotate({\"body\": Pet})",
            "    def body_param_func():",
            "        return None",
            "",
            "    return TransmuteFunction(body_param_func)",
            "",
            "",
            "@pytest.fixture",
            "def complex_transmute_func():",
            "    @describe(paths=\"/api/v1/adopt\")",
            "    @annotate({\"return\": Pet})",
            "    def adopt():",
            "        return Pet({\"kind\": \"dog\", \"age\": 5})",
            "",
            "    return TransmuteFunction(adopt)",
            "",
            "",
            "@pytest.fixture",
            "def response_transmute_func():",
            "    @describe(",
            "        paths=\"/api/v1/create_if_authorized/\",",
            "        response_types={",
            "            401: {\"type\": str, \"description\": \"unauthorized\"},",
            "            201: {\"type\": bool, \"headers\": {\"location\": {\"type\": str}}},",
            "        },",
            "    )",
            "    @annotate({\"username\": str})",
            "    def create_if_authorized(username):",
            "        if username != \"im the boss\":",
            "            return Response(\"this is unauthorized!\", 201)",
            "        else:",
            "            return Response(True, 401)",
            "",
            "    return TransmuteFunction(create_if_authorized)"
        ],
        "afterPatchFile": [
            "import pytest",
            "from transmute_core import (",
            "    annotate,",
            "    describe,",
            "    default_context,",
            "    get_default_serializer_set,",
            "    get_default_object_serializer_set,",
            "    Response,",
            "    SchematicsSerializer,",
            "    TransmuteFunction,",
            ")",
            "from schematics.models import Model",
            "from schematics.types import StringType, IntType",
            "",
            "",
            "@pytest.fixture",
            "def context():",
            "    return default_context",
            "",
            "",
            "@pytest.fixture",
            "def serializer_set():",
            "    return get_default_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def object_serializers():",
            "    return get_default_object_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def object_serializer_set():",
            "    return get_default_object_serializer_set()",
            "",
            "",
            "@pytest.fixture",
            "def serializer():",
            "    return SchematicsSerializer()",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func():",
            "    @describe(paths=\"/api/v1/multiply\")",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func_custom_code():",
            "    @describe(paths=\"/api/v1/multiply\", success_code=201)",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "@pytest.fixture",
            "def transmute_func_post():",
            "    @describe(paths=\"/api/v1/multiply\", methods=[\"POST\"])",
            "    @annotate({\"left\": int, \"right\": int, \"return\": int})",
            "    def multiply(left, right):",
            "        return left * right",
            "",
            "    return TransmuteFunction(multiply)",
            "",
            "",
            "class Pet(Model):",
            "    kind = StringType(required=True)",
            "    age = IntType()",
            "",
            "",
            "@pytest.fixture",
            "def single_body_transmute_func():",
            "    @describe(paths=\"/\", body_parameters=\"body\")",
            "    @annotate({\"body\": Pet})",
            "    def body_param_func():",
            "        return None",
            "",
            "    return TransmuteFunction(body_param_func)",
            "",
            "",
            "@pytest.fixture",
            "def complex_transmute_func():",
            "    @describe(paths=\"/api/v1/adopt\")",
            "    @annotate({\"return\": Pet})",
            "    def adopt():",
            "        return Pet({\"kind\": \"dog\", \"age\": 5})",
            "",
            "    return TransmuteFunction(adopt)",
            "",
            "",
            "@pytest.fixture",
            "def response_transmute_func():",
            "    @describe(",
            "        paths=\"/api/v1/create_if_authorized/\",",
            "        response_types={",
            "            401: {\"type\": str, \"description\": \"unauthorized\"},",
            "            201: {\"type\": bool, \"headers\": {\"location\": {\"type\": str}}},",
            "        },",
            "    )",
            "    @annotate({\"username\": str})",
            "    def create_if_authorized(username):",
            "        if username != \"im the boss\":",
            "            return Response(\"this is unauthorized!\", 201)",
            "        else:",
            "            return Response(True, 401)",
            "",
            "    return TransmuteFunction(create_if_authorized)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [
                "Pet"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/frameworks/test_aiohttp/conftest.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " @pytest.fixture"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def cli(app, loop, test_client):"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return loop.run_until_complete(test_client(app))"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+def cli(app, loop, aiohttp_client):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    return loop.run_until_complete(aiohttp_client(app))"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "import sys",
            "",
            "",
            "def pytest_ignore_collect(*args, **kwargs):",
            "    if sys.version_info < (3, 5):",
            "        return True",
            "    return False",
            "",
            "",
            "@pytest.fixture",
            "def app(loop):",
            "    from .example import create_app",
            "",
            "    return create_app()",
            "",
            "",
            "@pytest.fixture",
            "def cli(app, loop, test_client):",
            "    return loop.run_until_complete(test_client(app))"
        ],
        "afterPatchFile": [
            "import pytest",
            "import sys",
            "",
            "",
            "def pytest_ignore_collect(*args, **kwargs):",
            "    if sys.version_info < (3, 5):",
            "        return True",
            "    return False",
            "",
            "",
            "@pytest.fixture",
            "def app(loop):",
            "    from .example import create_app",
            "",
            "    return create_app()",
            "",
            "",
            "@pytest.fixture",
            "def cli(app, loop, aiohttp_client):",
            "    return loop.run_until_complete(aiohttp_client(app))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "19": [
                "cli"
            ],
            "20": [
                "cli"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/test_benchmark.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " def test_simple_benchmark(benchmark, context):"
            },
            "3": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     simple_func = TransmuteFunction(simple_body_method)"
            },
            "5": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     simple_json = json.dumps(1)"
            },
            "6": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import attr",
            "import cProfile",
            "import attr",
            "import json",
            "import pytest",
            "import sys",
            "from attr.validators import instance_of",
            "from transmute_core import (",
            "    TransmuteFunction,",
            "    describe,",
            "    annotate,",
            "    ParamExtractor,",
            "    NoArgument,",
            ")",
            "from schematics.models import Model",
            "from schematics.types import StringType, BooleanType, IntType",
            "from schematics.types.compound import ModelType",
            "from .utils import execute",
            "",
            "",
            "class User(Model):",
            "    name = StringType()",
            "    age = IntType()",
            "",
            "",
            "class ComplexModel(Model):",
            "    user = ModelType(User)",
            "    description = StringType()",
            "    is_allowed = BooleanType()",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": ComplexModel, \"return\": ComplexModel})",
            "def complex_body_method(body):",
            "    return body",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": int, \"return\": int})",
            "def simple_body_method(body):",
            "    return body",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": str, \"return\": str})",
            "def body_string(body):",
            "    return body",
            "",
            "",
            "def test_large_str_benchmark(benchmark, context):",
            "    \"\"\"",
            "    a benchmark of a fake full execution flow of a transmute function.",
            "    \"\"\"",
            "    s = \"a\" * 100000",
            "",
            "    func = TransmuteFunction(body_string)",
            "    obj_json = json.dumps(s)",
            "",
            "    benchmark(lambda: execute(context, func, obj_json))",
            "",
            "",
            "def test_complex_benchmark(benchmark, context):",
            "    \"\"\"",
            "    a benchmark of a fake full execution flow of a transmute function.",
            "    \"\"\"",
            "    obj = ComplexModel(",
            "        {",
            "            \"user\": {\"name\": \"Richard Stallman\", \"age\": 104},",
            "            \"description\": \"this is a test\",",
            "            \"is_allowed\": True,",
            "        }",
            "    )",
            "",
            "    complex_func = TransmuteFunction(complex_body_method)",
            "    complex_json = json.dumps(context.serializers.dump(type(obj), obj))",
            "",
            "    benchmark(lambda: execute(context, complex_func, complex_json))",
            "",
            "",
            "def test_simple_benchmark(benchmark, context):",
            "",
            "    simple_func = TransmuteFunction(simple_body_method)",
            "    simple_json = json.dumps(1)",
            "",
            "    benchmark(lambda: execute(context, simple_func, simple_json))"
        ],
        "afterPatchFile": [
            "import attr",
            "import cProfile",
            "import attr",
            "import json",
            "import pytest",
            "import sys",
            "from attr.validators import instance_of",
            "from transmute_core import (",
            "    TransmuteFunction,",
            "    describe,",
            "    annotate,",
            "    ParamExtractor,",
            "    NoArgument,",
            ")",
            "from schematics.models import Model",
            "from schematics.types import StringType, BooleanType, IntType",
            "from schematics.types.compound import ModelType",
            "from .utils import execute",
            "",
            "",
            "class User(Model):",
            "    name = StringType()",
            "    age = IntType()",
            "",
            "",
            "class ComplexModel(Model):",
            "    user = ModelType(User)",
            "    description = StringType()",
            "    is_allowed = BooleanType()",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": ComplexModel, \"return\": ComplexModel})",
            "def complex_body_method(body):",
            "    return body",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": int, \"return\": int})",
            "def simple_body_method(body):",
            "    return body",
            "",
            "",
            "@describe(paths=\"/foo\", body_parameters=\"body\")",
            "@annotate({\"body\": str, \"return\": str})",
            "def body_string(body):",
            "    return body",
            "",
            "",
            "def test_large_str_benchmark(benchmark, context):",
            "    \"\"\"",
            "    a benchmark of a fake full execution flow of a transmute function.",
            "    \"\"\"",
            "    s = \"a\" * 100000",
            "",
            "    func = TransmuteFunction(body_string)",
            "    obj_json = json.dumps(s)",
            "",
            "    benchmark(lambda: execute(context, func, obj_json))",
            "",
            "",
            "def test_complex_benchmark(benchmark, context):",
            "    \"\"\"",
            "    a benchmark of a fake full execution flow of a transmute function.",
            "    \"\"\"",
            "    obj = ComplexModel(",
            "        {",
            "            \"user\": {\"name\": \"Richard Stallman\", \"age\": 104},",
            "            \"description\": \"this is a test\",",
            "            \"is_allowed\": True,",
            "        }",
            "    )",
            "",
            "    complex_func = TransmuteFunction(complex_body_method)",
            "    complex_json = json.dumps(context.serializers.dump(type(obj), obj))",
            "",
            "    benchmark(lambda: execute(context, complex_func, complex_json))",
            "",
            "",
            "def test_simple_benchmark(benchmark, context):",
            "    simple_func = TransmuteFunction(simple_body_method)",
            "    simple_json = json.dumps(1)",
            "",
            "    benchmark(lambda: execute(context, simple_func, simple_json))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "81": [
                "test_simple_benchmark"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/test_decorators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " def test_annotate():"
            },
            "3": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     annotations = {\"return\": str, \"arg\": int}"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     @annotate(annotations)"
            }
        },
        "frontPatchFile": [
            "import pytest",
            "",
            "from transmute_core.decorators import describe, annotate",
            "",
            "",
            "@pytest.mark.parametrize(\"method\", [\"PUT\", \"POST\", \"DELETE\"])",
            "def test_describe(method):",
            "    @describe(methods=method)",
            "    def test():",
            "        pass",
            "",
            "    assert test.transmute.methods == set([method])",
            "",
            "",
            "def test_describe_join():",
            "    \"\"\"two describe annotations should merge the descriptions\"\"\"",
            "",
            "    @describe(methods=[\"GET\"])",
            "    @describe(methods=[\"PUT\"])",
            "    def test():",
            "        pass",
            "",
            "    assert test.transmute.methods == set([\"GET\", \"PUT\"])",
            "",
            "",
            "def test_annotate():",
            "",
            "    annotations = {\"return\": str, \"arg\": int}",
            "",
            "    @annotate(annotations)",
            "    def delete_test(arg):",
            "        pass",
            "",
            "    assert delete_test.__annotations__ == annotations"
        ],
        "afterPatchFile": [
            "import pytest",
            "",
            "from transmute_core.decorators import describe, annotate",
            "",
            "",
            "@pytest.mark.parametrize(\"method\", [\"PUT\", \"POST\", \"DELETE\"])",
            "def test_describe(method):",
            "    @describe(methods=method)",
            "    def test():",
            "        pass",
            "",
            "    assert test.transmute.methods == set([method])",
            "",
            "",
            "def test_describe_join():",
            "    \"\"\"two describe annotations should merge the descriptions\"\"\"",
            "",
            "    @describe(methods=[\"GET\"])",
            "    @describe(methods=[\"PUT\"])",
            "    def test():",
            "        pass",
            "",
            "    assert test.transmute.methods == set([\"GET\", \"PUT\"])",
            "",
            "",
            "def test_annotate():",
            "    annotations = {\"return\": str, \"arg\": int}",
            "",
            "    @annotate(annotations)",
            "    def delete_test(arg):",
            "        pass",
            "",
            "    assert delete_test.__annotations__ == annotations"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "27": [
                "test_annotate"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/test_param_extractor.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " class ParamExtractorMock(ParamExtractor):"
            },
            "3": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     body = json.dumps({\"body\": \"body\"})"
            },
            "5": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     def _get_framework_args(self):"
            },
            "7": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " def test_extract_params(all_param_type_transmute_func):"
            },
            "10": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     extractor = ParamExtractorMock()"
            },
            "12": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     args, kwargs = extractor.extract_params("
            },
            "13": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         default_context, all_param_type_transmute_func, \"application/json\""
            }
        },
        "frontPatchFile": [
            "import pytest",
            "import json",
            "from transmute_core import (",
            "    ParamExtractor,",
            "    NoArgument,",
            "    describe,",
            "    annotate,",
            "    default_context,",
            "    APIException,",
            ")",
            "from transmute_core.function import TransmuteFunction",
            "from typing import List",
            "from schematics.types import ListType, StringType",
            "",
            "",
            "@describe(paths=[\"/\"], query_parameters=[\"pos\"])",
            "@annotate({\"pos\": str})",
            "def pos_type(pos):",
            "    pass",
            "",
            "",
            "@describe(paths=[\"/\"])",
            "@annotate({\"framework_arg\": str})",
            "def with_framework_arg(framework_arg):",
            "    pass",
            "",
            "",
            "@describe(",
            "    paths=[\"/\"],",
            "    query_parameters=[\"query\"],",
            "    header_parameters=[\"header\"],",
            "    path_parameters=[\"path\"],",
            "    body_parameters=[\"body\"],",
            ")",
            "@annotate({\"query\": str, \"header\": str, \"path\": str, \"body\": str})",
            "def all_param_type(query=1, header=2, path=3, body=4):",
            "    pass",
            "",
            "",
            "class ParamExtractorMock(ParamExtractor):",
            "",
            "    body = json.dumps({\"body\": \"body\"})",
            "",
            "    def _get_framework_args(self):",
            "        return {\"framework_arg\": \"framework_arg\"}",
            "",
            "    def _query_argument(self, key, is_list):",
            "        if is_list:",
            "            if key == \"query_list\":",
            "                return [\"query1,query2,query3\"]",
            "            return [\"query\"]",
            "        else:",
            "            return \"query\"",
            "",
            "    def _header_argument(self, key):",
            "        return \"header\"",
            "",
            "    def _path_argument(self, key):",
            "        return \"path\"",
            "",
            "",
            "@pytest.fixture",
            "def all_param_type_transmute_func():",
            "    \"\"\"ensure retrieval of all parameter types is honored.\"\"\"",
            "    return TransmuteFunction(all_param_type)",
            "",
            "",
            "def test_extract_params(all_param_type_transmute_func):",
            "",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {",
            "        \"query\": \"query\",",
            "        \"header\": \"header\",",
            "        \"path\": \"path\",",
            "        \"body\": \"body\",",
            "    }",
            "",
            "",
            "def test_extract_params_no_arguments(all_param_type_transmute_func):",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    extractor._query_argument = lambda *args: NoArgument",
            "    extractor._header_argument = lambda *args: NoArgument",
            "    extractor._path_argument = lambda *args: NoArgument",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {\"query\": 1, \"header\": 2, \"path\": 3, \"body\": \"body\"}",
            "",
            "",
            "def test_body_with_only_default_args_can_be_empty(all_param_type_transmute_func):",
            "    \"\"\"if no body is passed, and all body args have defaults, it is still a valid request.\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    extractor.body = \"\"",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {\"query\": \"query\", \"header\": \"header\", \"path\": \"path\", \"body\": 4}",
            "",
            "",
            "def test_extract_params_bad_body_content_type(all_param_type_transmute_func):",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    with pytest.raises(APIException):",
            "        extractor.extract_params(",
            "            default_context, all_param_type_transmute_func, \"application/myson\"",
            "        )",
            "",
            "",
            "def test_extract_params_positional_args():",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "    tf = TransmuteFunction(pos_type)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, \"application/json\")",
            "    assert args == [\"query\"]",
            "    assert kwargs == {}",
            "",
            "",
            "def test_with_framework_arg():",
            "    \"\"\" \"\"\"",
            "    tf = TransmuteFunction(with_framework_arg)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, \"application/json\")",
            "    assert args == [\"framework_arg\"]",
            "    assert kwargs == {}",
            "",
            "",
            "def test_extract_params_no_content_type(all_param_type_transmute_func):",
            "    \"\"\"if no content type is provided, expect json.\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, None",
            "    )",
            "    assert args == []",
            "    assert kwargs[\"body\"] == \"body\"",
            "",
            "",
            "@pytest.mark.parametrize(\"typ\", [List[str], [str], ListType(StringType)])",
            "def test_extract_params_honor_as_list(typ):",
            "    @describe(paths=[\"/\"], query_parameters=[\"query\", \"query_list\"])",
            "    @annotate({\"query\": typ, \"query_list\": typ})",
            "    def f(query=[1], query_list=[1, 2, 3]):",
            "        pass",
            "",
            "    tf = TransmuteFunction(f)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, None)",
            "    assert kwargs[\"query\"] == [\"query\"]",
            "    assert kwargs[\"query_list\"] == [\"query1\", \"query2\", \"query3\"]",
            "",
            "",
            "@pytest.mark.parametrize(\"typ\", [str])",
            "def test_extract_params_honor_as_non_list(typ):",
            "    @describe(paths=[\"/\"], query_parameters=[\"query\"])",
            "    @annotate({\"query\": typ})",
            "    def f(query=1):",
            "        pass",
            "",
            "    tf = TransmuteFunction(f)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, None)",
            "    assert kwargs[\"query\"] == \"query\""
        ],
        "afterPatchFile": [
            "import pytest",
            "import json",
            "from transmute_core import (",
            "    ParamExtractor,",
            "    NoArgument,",
            "    describe,",
            "    annotate,",
            "    default_context,",
            "    APIException,",
            ")",
            "from transmute_core.function import TransmuteFunction",
            "from typing import List",
            "from schematics.types import ListType, StringType",
            "",
            "",
            "@describe(paths=[\"/\"], query_parameters=[\"pos\"])",
            "@annotate({\"pos\": str})",
            "def pos_type(pos):",
            "    pass",
            "",
            "",
            "@describe(paths=[\"/\"])",
            "@annotate({\"framework_arg\": str})",
            "def with_framework_arg(framework_arg):",
            "    pass",
            "",
            "",
            "@describe(",
            "    paths=[\"/\"],",
            "    query_parameters=[\"query\"],",
            "    header_parameters=[\"header\"],",
            "    path_parameters=[\"path\"],",
            "    body_parameters=[\"body\"],",
            ")",
            "@annotate({\"query\": str, \"header\": str, \"path\": str, \"body\": str})",
            "def all_param_type(query=1, header=2, path=3, body=4):",
            "    pass",
            "",
            "",
            "class ParamExtractorMock(ParamExtractor):",
            "    body = json.dumps({\"body\": \"body\"})",
            "",
            "    def _get_framework_args(self):",
            "        return {\"framework_arg\": \"framework_arg\"}",
            "",
            "    def _query_argument(self, key, is_list):",
            "        if is_list:",
            "            if key == \"query_list\":",
            "                return [\"query1,query2,query3\"]",
            "            return [\"query\"]",
            "        else:",
            "            return \"query\"",
            "",
            "    def _header_argument(self, key):",
            "        return \"header\"",
            "",
            "    def _path_argument(self, key):",
            "        return \"path\"",
            "",
            "",
            "@pytest.fixture",
            "def all_param_type_transmute_func():",
            "    \"\"\"ensure retrieval of all parameter types is honored.\"\"\"",
            "    return TransmuteFunction(all_param_type)",
            "",
            "",
            "def test_extract_params(all_param_type_transmute_func):",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {",
            "        \"query\": \"query\",",
            "        \"header\": \"header\",",
            "        \"path\": \"path\",",
            "        \"body\": \"body\",",
            "    }",
            "",
            "",
            "def test_extract_params_no_arguments(all_param_type_transmute_func):",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    extractor._query_argument = lambda *args: NoArgument",
            "    extractor._header_argument = lambda *args: NoArgument",
            "    extractor._path_argument = lambda *args: NoArgument",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {\"query\": 1, \"header\": 2, \"path\": 3, \"body\": \"body\"}",
            "",
            "",
            "def test_body_with_only_default_args_can_be_empty(all_param_type_transmute_func):",
            "    \"\"\"if no body is passed, and all body args have defaults, it is still a valid request.\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    extractor.body = \"\"",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, \"application/json\"",
            "    )",
            "    assert args == []",
            "    assert kwargs == {\"query\": \"query\", \"header\": \"header\", \"path\": \"path\", \"body\": 4}",
            "",
            "",
            "def test_extract_params_bad_body_content_type(all_param_type_transmute_func):",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    with pytest.raises(APIException):",
            "        extractor.extract_params(",
            "            default_context, all_param_type_transmute_func, \"application/myson\"",
            "        )",
            "",
            "",
            "def test_extract_params_positional_args():",
            "    \"\"\"if no arguments are passed, use the defaults\"\"\"",
            "    tf = TransmuteFunction(pos_type)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, \"application/json\")",
            "    assert args == [\"query\"]",
            "    assert kwargs == {}",
            "",
            "",
            "def test_with_framework_arg():",
            "    \"\"\" \"\"\"",
            "    tf = TransmuteFunction(with_framework_arg)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, \"application/json\")",
            "    assert args == [\"framework_arg\"]",
            "    assert kwargs == {}",
            "",
            "",
            "def test_extract_params_no_content_type(all_param_type_transmute_func):",
            "    \"\"\"if no content type is provided, expect json.\"\"\"",
            "",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(",
            "        default_context, all_param_type_transmute_func, None",
            "    )",
            "    assert args == []",
            "    assert kwargs[\"body\"] == \"body\"",
            "",
            "",
            "@pytest.mark.parametrize(\"typ\", [List[str], [str], ListType(StringType)])",
            "def test_extract_params_honor_as_list(typ):",
            "    @describe(paths=[\"/\"], query_parameters=[\"query\", \"query_list\"])",
            "    @annotate({\"query\": typ, \"query_list\": typ})",
            "    def f(query=[1], query_list=[1, 2, 3]):",
            "        pass",
            "",
            "    tf = TransmuteFunction(f)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, None)",
            "    assert kwargs[\"query\"] == [\"query\"]",
            "    assert kwargs[\"query_list\"] == [\"query1\", \"query2\", \"query3\"]",
            "",
            "",
            "@pytest.mark.parametrize(\"typ\", [str])",
            "def test_extract_params_honor_as_non_list(typ):",
            "    @describe(paths=[\"/\"], query_parameters=[\"query\"])",
            "    @annotate({\"query\": typ})",
            "    def f(query=1):",
            "        pass",
            "",
            "    tf = TransmuteFunction(f)",
            "    extractor = ParamExtractorMock()",
            "    args, kwargs = extractor.extract_params(default_context, tf, None)",
            "    assert kwargs[\"query\"] == \"query\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "41": [
                "ParamExtractorMock"
            ],
            "69": [
                "test_extract_params"
            ]
        },
        "addLocation": []
    },
    "transmute_core/tests/test_schematics.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     use of the instantiated model as a key was causing memory leaks."
            },
            "1": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "     serializer = SchematicsSerializer()"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     # A nested schema type is required as primitives have"
            },
            "5": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     # hard-coded dictionaries representing the json."
            },
            "6": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     class SchematicsBody(Model):"
            }
        },
        "frontPatchFile": [
            "import uuid",
            "import pytest",
            "from datetime import datetime",
            "from schematics.models import Model",
            "from schematics.types import (",
            "    StringType,",
            "    IntType,",
            "    BaseType,",
            "    UUIDType,",
            "    URLType,",
            "    Serializable,",
            "    UTCDateTimeType,",
            ")",
            "from schematics.types.compound import DictType, ModelType",
            "from schematics.exceptions import ValidationError",
            "from transmute_core.exceptions import SerializationException, NoSerializerFound",
            "from transmute_core.object_serializers.schematics_serializer import SchematicsSerializer",
            "",
            "",
            "class Card(Model):",
            "    name = StringType()",
            "    price = IntType()",
            "",
            "",
            "def greater_than_zero(value):",
            "    if value < 0:",
            "        raise ValidationError(\"must be greater than zero\")",
            "    return value",
            "",
            "",
            "class Person(Model):",
            "    age = IntType(required=True, validators=[greater_than_zero])",
            "    bio = StringType(max_length=5)",
            "",
            "",
            "card_dict = {\"name\": \"foo\", \"price\": 10}",
            "card = Card(card_dict)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ,inp,out\", [(Card, card, card_dict), ([Card], [card], [card_dict])]",
            ")",
            "def test_schematics_integration_dump(object_serializer_set, typ, inp, out):",
            "    assert object_serializer_set.dump(typ, inp) == out",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ, bad_data\",",
            "    [",
            "        (Person, {\"age\": -1, \"bio\": \"foo\"}),",
            "        (Person, {\"age\": 20, \"bio\": \"fooooooooo\"}),",
            "        (StringType(max_length=4), \"foooooo\"),",
            "    ],",
            ")",
            "def test_schematics_validate_is_called(object_serializer_set, typ, bad_data):",
            "    with pytest.raises(SerializationException):",
            "        object_serializer_set.load(typ, bad_data)",
            "",
            "",
            "now = datetime.now()",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ,inp,out\",",
            "    [(Card, card_dict, card), ([Card], [card_dict], [card]), (datetime, now, now)],",
            ")",
            "def test_schematics_integration_load(object_serializer_set, typ, inp, out):",
            "    assert object_serializer_set.load(typ, inp) == out",
            "",
            "",
            "def test_schematics_to_json_schema(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema(Card) == {",
            "        \"properties\": {\"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"integer\"}},",
            "        \"title\": \"Card\",",
            "        \"type\": \"object\",",
            "    }",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"inp, expected\",",
            "    [",
            "        (UUIDType, {\"type\": \"string\", \"format\": \"uuid\"}),",
            "        (URLType, {\"type\": \"string\", \"format\": \"url\"}),",
            "        (StringType, {\"type\": \"string\"}),",
            "        (BaseType, {\"type\": \"object\"}),",
            "        (IntType, {\"type\": \"integer\"}),",
            "        (datetime, {\"type\": \"string\", \"format\": \"date-time\"}),",
            "        (UTCDateTimeType, {\"type\": \"string\", \"format\": \"date-time\"}),",
            "        (Serializable(fget=lambda: None, type=StringType()), {\"type\": \"string\"}),",
            "    ],",
            ")",
            "def test_to_json_schema(object_serializer_set, inp, expected):",
            "    assert object_serializer_set.to_json_schema(inp) == expected",
            "",
            "",
            "def test_schematics_to_json_schema_required_value(object_serializer_set):",
            "    class CardNameRequired(Model):",
            "        name = StringType(required=True)",
            "        price = IntType()",
            "",
            "    assert object_serializer_set.to_json_schema(CardNameRequired) == {",
            "        \"properties\": {\"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"integer\"}},",
            "        \"title\": \"CardNameRequired\",",
            "        \"required\": [\"name\"],",
            "        \"type\": \"object\",",
            "    }",
            "",
            "",
            "def test_type_not_found_defaults_to_object(object_serializer_set):",
            "    class MyType(BaseType):",
            "        pass",
            "",
            "    assert object_serializer_set.to_json_schema(MyType()) == {\"type\": \"object\"}",
            "",
            "",
            "def test_non_model_or_primitive_raises_exception(object_serializer_set):",
            "    class MyType(object):",
            "        pass",
            "",
            "    with pytest.raises(NoSerializerFound):",
            "        object_serializer_set.to_json_schema(MyType)",
            "",
            "",
            "def test_to_json_list(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema([int]) == {",
            "        \"type\": \"array\",",
            "        \"items\": {\"type\": \"integer\"},",
            "    }",
            "",
            "",
            "def test_to_json_dict(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema(DictType(IntType())) == {",
            "        \"type\": \"object\",",
            "        \"additionalProperties\": {\"type\": \"integer\"},",
            "    }",
            "",
            "",
            "def test_serialize_type(object_serializer_set):",
            "    \"\"\"object_serializer_set should be able to serialize a raw type.\"\"\"",
            "    assert object_serializer_set.dump(DictType(StringType()), {\"key\": \"foo\"}) == {",
            "        \"key\": \"foo\"",
            "    }",
            "",
            "",
            "def test_dict_type_object_serializer_set(object_serializer_set):",
            "    \"\"\"serializer should be able to serialize a raw type.\"\"\"",
            "    assert object_serializer_set.dump(DictType(StringType()), {\"key\": \"foo\"}) == {",
            "        \"key\": \"foo\"",
            "    }",
            "",
            "",
            "def test_uuid_serializer(object_serializer_set):",
            "    i = uuid.uuid4()",
            "    dumped = object_serializer_set.dump(UUIDType, i)",
            "    assert dumped == str(i)",
            "    assert object_serializer_set.load(UUIDType, dumped) == i",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"cls, should_handle\",",
            "    [(int, True), (float, True), (datetime, True), (ModelType(Card), True)],",
            ")",
            "def test_can_handle(object_serializer_set, cls, should_handle):",
            "    \"\"\"",
            "    the object serializer set should not raise an exception if it can handle these types.",
            "    \"\"\"",
            "    object_serializer_set[cls]",
            "",
            "",
            "def test_schematics_uses_cached_entries():",
            "    \"\"\"",
            "    Regression test. Validating that SchematicsSerializer uses the",
            "    same json schema it used previously, as before erroneous",
            "    use of the instantiated model as a key was causing memory leaks.",
            "    \"\"\"",
            "    serializer = SchematicsSerializer()",
            "    # A nested schema type is required as primitives have",
            "    # hard-coded dictionaries representing the json.",
            "    class SchematicsBody(Model):",
            "        name = StringType(max_length=5)",
            "",
            "    # ensure that instances have the same key as well.",
            "    instance = ModelType(SchematicsBody)",
            "    original_payload = serializer.to_json_schema(instance)",
            "    second_payload = serializer.to_json_schema(instance)",
            "    assert original_payload is second_payload",
            "",
            "    # classes are also valid output to recieve that the json schema",
            "    original_payload = serializer.to_json_schema(SchematicsBody)",
            "    second_payload = serializer.to_json_schema(SchematicsBody)",
            "    assert original_payload is second_payload"
        ],
        "afterPatchFile": [
            "import uuid",
            "import pytest",
            "from datetime import datetime",
            "from schematics.models import Model",
            "from schematics.types import (",
            "    StringType,",
            "    IntType,",
            "    BaseType,",
            "    UUIDType,",
            "    URLType,",
            "    Serializable,",
            "    UTCDateTimeType,",
            ")",
            "from schematics.types.compound import DictType, ModelType",
            "from schematics.exceptions import ValidationError",
            "from transmute_core.exceptions import SerializationException, NoSerializerFound",
            "from transmute_core.object_serializers.schematics_serializer import SchematicsSerializer",
            "",
            "",
            "class Card(Model):",
            "    name = StringType()",
            "    price = IntType()",
            "",
            "",
            "def greater_than_zero(value):",
            "    if value < 0:",
            "        raise ValidationError(\"must be greater than zero\")",
            "    return value",
            "",
            "",
            "class Person(Model):",
            "    age = IntType(required=True, validators=[greater_than_zero])",
            "    bio = StringType(max_length=5)",
            "",
            "",
            "card_dict = {\"name\": \"foo\", \"price\": 10}",
            "card = Card(card_dict)",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ,inp,out\", [(Card, card, card_dict), ([Card], [card], [card_dict])]",
            ")",
            "def test_schematics_integration_dump(object_serializer_set, typ, inp, out):",
            "    assert object_serializer_set.dump(typ, inp) == out",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ, bad_data\",",
            "    [",
            "        (Person, {\"age\": -1, \"bio\": \"foo\"}),",
            "        (Person, {\"age\": 20, \"bio\": \"fooooooooo\"}),",
            "        (StringType(max_length=4), \"foooooo\"),",
            "    ],",
            ")",
            "def test_schematics_validate_is_called(object_serializer_set, typ, bad_data):",
            "    with pytest.raises(SerializationException):",
            "        object_serializer_set.load(typ, bad_data)",
            "",
            "",
            "now = datetime.now()",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"typ,inp,out\",",
            "    [(Card, card_dict, card), ([Card], [card_dict], [card]), (datetime, now, now)],",
            ")",
            "def test_schematics_integration_load(object_serializer_set, typ, inp, out):",
            "    assert object_serializer_set.load(typ, inp) == out",
            "",
            "",
            "def test_schematics_to_json_schema(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema(Card) == {",
            "        \"properties\": {\"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"integer\"}},",
            "        \"title\": \"Card\",",
            "        \"type\": \"object\",",
            "    }",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"inp, expected\",",
            "    [",
            "        (UUIDType, {\"type\": \"string\", \"format\": \"uuid\"}),",
            "        (URLType, {\"type\": \"string\", \"format\": \"url\"}),",
            "        (StringType, {\"type\": \"string\"}),",
            "        (BaseType, {\"type\": \"object\"}),",
            "        (IntType, {\"type\": \"integer\"}),",
            "        (datetime, {\"type\": \"string\", \"format\": \"date-time\"}),",
            "        (UTCDateTimeType, {\"type\": \"string\", \"format\": \"date-time\"}),",
            "        (Serializable(fget=lambda: None, type=StringType()), {\"type\": \"string\"}),",
            "    ],",
            ")",
            "def test_to_json_schema(object_serializer_set, inp, expected):",
            "    assert object_serializer_set.to_json_schema(inp) == expected",
            "",
            "",
            "def test_schematics_to_json_schema_required_value(object_serializer_set):",
            "    class CardNameRequired(Model):",
            "        name = StringType(required=True)",
            "        price = IntType()",
            "",
            "    assert object_serializer_set.to_json_schema(CardNameRequired) == {",
            "        \"properties\": {\"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"integer\"}},",
            "        \"title\": \"CardNameRequired\",",
            "        \"required\": [\"name\"],",
            "        \"type\": \"object\",",
            "    }",
            "",
            "",
            "def test_type_not_found_defaults_to_object(object_serializer_set):",
            "    class MyType(BaseType):",
            "        pass",
            "",
            "    assert object_serializer_set.to_json_schema(MyType()) == {\"type\": \"object\"}",
            "",
            "",
            "def test_non_model_or_primitive_raises_exception(object_serializer_set):",
            "    class MyType(object):",
            "        pass",
            "",
            "    with pytest.raises(NoSerializerFound):",
            "        object_serializer_set.to_json_schema(MyType)",
            "",
            "",
            "def test_to_json_list(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema([int]) == {",
            "        \"type\": \"array\",",
            "        \"items\": {\"type\": \"integer\"},",
            "    }",
            "",
            "",
            "def test_to_json_dict(object_serializer_set):",
            "    assert object_serializer_set.to_json_schema(DictType(IntType())) == {",
            "        \"type\": \"object\",",
            "        \"additionalProperties\": {\"type\": \"integer\"},",
            "    }",
            "",
            "",
            "def test_serialize_type(object_serializer_set):",
            "    \"\"\"object_serializer_set should be able to serialize a raw type.\"\"\"",
            "    assert object_serializer_set.dump(DictType(StringType()), {\"key\": \"foo\"}) == {",
            "        \"key\": \"foo\"",
            "    }",
            "",
            "",
            "def test_dict_type_object_serializer_set(object_serializer_set):",
            "    \"\"\"serializer should be able to serialize a raw type.\"\"\"",
            "    assert object_serializer_set.dump(DictType(StringType()), {\"key\": \"foo\"}) == {",
            "        \"key\": \"foo\"",
            "    }",
            "",
            "",
            "def test_uuid_serializer(object_serializer_set):",
            "    i = uuid.uuid4()",
            "    dumped = object_serializer_set.dump(UUIDType, i)",
            "    assert dumped == str(i)",
            "    assert object_serializer_set.load(UUIDType, dumped) == i",
            "",
            "",
            "@pytest.mark.parametrize(",
            "    \"cls, should_handle\",",
            "    [(int, True), (float, True), (datetime, True), (ModelType(Card), True)],",
            ")",
            "def test_can_handle(object_serializer_set, cls, should_handle):",
            "    \"\"\"",
            "    the object serializer set should not raise an exception if it can handle these types.",
            "    \"\"\"",
            "    object_serializer_set[cls]",
            "",
            "",
            "def test_schematics_uses_cached_entries():",
            "    \"\"\"",
            "    Regression test. Validating that SchematicsSerializer uses the",
            "    same json schema it used previously, as before erroneous",
            "    use of the instantiated model as a key was causing memory leaks.",
            "    \"\"\"",
            "    serializer = SchematicsSerializer()",
            "",
            "    # A nested schema type is required as primitives have",
            "    # hard-coded dictionaries representing the json.",
            "    class SchematicsBody(Model):",
            "        name = StringType(max_length=5)",
            "",
            "    # ensure that instances have the same key as well.",
            "    instance = ModelType(SchematicsBody)",
            "    original_payload = serializer.to_json_schema(instance)",
            "    second_payload = serializer.to_json_schema(instance)",
            "    assert original_payload is second_payload",
            "",
            "    # classes are also valid output to recieve that the json schema",
            "    original_payload = serializer.to_json_schema(SchematicsBody)",
            "    second_payload = serializer.to_json_schema(SchematicsBody)",
            "    assert original_payload is second_payload"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    }
}