{
    "numexpr/necompiler.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import numpy"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import threading"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import re"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " is_cpu_amd_intel = False # DEPRECATION WARNING: WILL BE REMOVED IN FUTURE RELEASE"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from numexpr import interpreter, expressions, use_vml"
            },
            "7": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     def __str__(self):"
            },
            "8": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         return 'Immediate(%d)' % (self.node.value,)"
            },
            "9": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+_forbidden_re = re.compile('[\\;[\\:]|__')"
            },
            "12": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 264,
                "PatchRowcode": " def stringToExpression(s, types, context):"
            },
            "13": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "     \"\"\"Given a string, convert it to a tree of ExpressionNode's."
            },
            "14": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    # sanitize the string for obvious attack vectors that NumExpr cannot "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+    # parse into its homebrew AST. This is to protect the call to `eval` below."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+    # We forbid `;`, `:`. `[` and `__`"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+    # We would like to forbid `.` but it is both a reference and decimal point."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    if _forbidden_re.search(s) is not None:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        raise ValueError(f'Expression {s} has forbidden control characters.')"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    "
            },
            "22": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "     old_ctx = expressions._context.get_current_context()"
            },
            "23": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "     try:"
            },
            "24": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         expressions._context.set_new_context(context)"
            },
            "25": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "                 t = types.get(name, default_type)"
            },
            "26": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "                 names[name] = expressions.VariableNode(name, type_to_kind[t])"
            },
            "27": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         names.update(expressions.functions)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         # now build the expression"
            },
            "30": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         ex = eval(c, names)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        "
            },
            "32": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         if expressions.isConstant(ex):"
            },
            "33": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             ex = expressions.ConstantNode(ex, expressions.getKind(ex))"
            },
            "34": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         elif not isinstance(ex, expressions.ExpressionNode):"
            },
            "35": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": 621,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "     Returns a `NumExpr` object containing the compiled function."
            },
            "37": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "     \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # NumExpr can be called either directly by the end-user, in which case"
            },
            "39": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # kwargs need to be sanitized by getContext, or by evaluate,"
            },
            "40": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # in which case kwargs are in already sanitized."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "     # In that case _frame_depth is wrong (it should be 2) but it doesn't matter"
            },
            "43": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "     # since it will not be used (because truediv='auto' has already been"
            },
            "44": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "     # translated to either True or False)."
            },
            "45": {
                "beforePatchRowNumber": 758,
                "afterPatchRowNumber": 766,
                "PatchRowcode": " _names_cache = CacheDict(256)"
            },
            "46": {
                "beforePatchRowNumber": 759,
                "afterPatchRowNumber": 767,
                "PatchRowcode": " _numexpr_cache = CacheDict(256)"
            },
            "47": {
                "beforePatchRowNumber": 760,
                "afterPatchRowNumber": 768,
                "PatchRowcode": " _numexpr_last = {}"
            },
            "48": {
                "beforePatchRowNumber": 761,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 769,
                "PatchRowcode": "+_numexpr_sanity = set()"
            },
            "50": {
                "beforePatchRowNumber": 762,
                "afterPatchRowNumber": 770,
                "PatchRowcode": " evaluate_lock = threading.Lock()"
            },
            "51": {
                "beforePatchRowNumber": 763,
                "afterPatchRowNumber": 771,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 764,
                "afterPatchRowNumber": 772,
                "PatchRowcode": " # MAYBE: decorate this function to add attributes instead of having the "
            },
            "53": {
                "beforePatchRowNumber": 861,
                "afterPatchRowNumber": 869,
                "PatchRowcode": "              out: numpy.ndarray = None, "
            },
            "54": {
                "beforePatchRowNumber": 862,
                "afterPatchRowNumber": 870,
                "PatchRowcode": "              order: str = 'K', "
            },
            "55": {
                "beforePatchRowNumber": 863,
                "afterPatchRowNumber": 871,
                "PatchRowcode": "              casting: str = 'safe', "
            },
            "56": {
                "beforePatchRowNumber": 864,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-             _frame_depth: int=3,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 872,
                "PatchRowcode": "+             _frame_depth: int = 3,"
            },
            "58": {
                "beforePatchRowNumber": 865,
                "afterPatchRowNumber": 873,
                "PatchRowcode": "              **kwargs) -> numpy.ndarray:"
            },
            "59": {
                "beforePatchRowNumber": 866,
                "afterPatchRowNumber": 874,
                "PatchRowcode": "     \"\"\""
            },
            "60": {
                "beforePatchRowNumber": 867,
                "afterPatchRowNumber": 875,
                "PatchRowcode": "     Evaluate a simple array expression element-wise using the virtual machine."
            },
            "61": {
                "beforePatchRowNumber": 909,
                "afterPatchRowNumber": 917,
                "PatchRowcode": "     _frame_depth: int"
            },
            "62": {
                "beforePatchRowNumber": 910,
                "afterPatchRowNumber": 918,
                "PatchRowcode": "         The calling frame depth. Unless you are a NumExpr developer you should "
            },
            "63": {
                "beforePatchRowNumber": 911,
                "afterPatchRowNumber": 919,
                "PatchRowcode": "         not set this value."
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 920,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 921,
                "PatchRowcode": "+    "
            },
            "66": {
                "beforePatchRowNumber": 912,
                "afterPatchRowNumber": 922,
                "PatchRowcode": "     \"\"\""
            },
            "67": {
                "beforePatchRowNumber": 913,
                "afterPatchRowNumber": 923,
                "PatchRowcode": "     # We could avoid code duplication if we called validate and then re_evaluate "
            },
            "68": {
                "beforePatchRowNumber": 914,
                "afterPatchRowNumber": 924,
                "PatchRowcode": "     # here, but they we have difficulties with the `sys.getframe(2)` call in"
            },
            "69": {
                "beforePatchRowNumber": 921,
                "afterPatchRowNumber": 931,
                "PatchRowcode": "     else:"
            },
            "70": {
                "beforePatchRowNumber": 922,
                "afterPatchRowNumber": 932,
                "PatchRowcode": "         raise e"
            },
            "71": {
                "beforePatchRowNumber": 923,
                "afterPatchRowNumber": 933,
                "PatchRowcode": "     "
            },
            "72": {
                "beforePatchRowNumber": 924,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "73": {
                "beforePatchRowNumber": 925,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  "
            },
            "74": {
                "beforePatchRowNumber": 926,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "75": {
                "beforePatchRowNumber": 927,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "76": {
                "beforePatchRowNumber": 928,
                "afterPatchRowNumber": 934,
                "PatchRowcode": " def re_evaluate(local_dict: Optional[Dict] = None, "
            },
            "77": {
                "beforePatchRowNumber": 929,
                "afterPatchRowNumber": 935,
                "PatchRowcode": "                 _frame_depth: int=2) -> numpy.ndarray:"
            },
            "78": {
                "beforePatchRowNumber": 930,
                "afterPatchRowNumber": 936,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "###################################################################",
            "#  Numexpr - Fast numerical array expression evaluator for NumPy.",
            "#",
            "#      License: MIT",
            "#      Author:  See AUTHORS.txt",
            "#",
            "#  See LICENSE.txt and LICENSES/*.txt for details about copyright and",
            "#  rights to use.",
            "####################################################################",
            "",
            "from typing import Optional, Dict",
            "import __future__",
            "import sys",
            "import numpy",
            "import threading",
            "",
            "is_cpu_amd_intel = False # DEPRECATION WARNING: WILL BE REMOVED IN FUTURE RELEASE",
            "from numexpr import interpreter, expressions, use_vml",
            "from numexpr.utils import CacheDict",
            "",
            "# Declare a double type that does not exist in Python space",
            "double = numpy.double",
            "double = numpy.double",
            "",
            "int_ = numpy.int32",
            "long_ = numpy.int64",
            "",
            "typecode_to_kind = {'b': 'bool', 'i': 'int', 'l': 'long', 'f': 'float', 'd': 'double', ",
            "                    'c': 'complex', 'n': 'none', 's': 'str'}",
            "kind_to_typecode = {'bool': 'b', 'int': 'i', 'long': 'l', 'float': 'f', 'double': 'd',",
            "                    'complex': 'c', 'bytes': 's', 'str': 's', 'none': 'n'}",
            "type_to_typecode = {bool: 'b', int_: 'i', long_: 'l', float: 'f',",
            "                    double: 'd', complex: 'c', bytes: 's', str: 's'}",
            "type_to_kind = expressions.type_to_kind",
            "kind_to_type = expressions.kind_to_type",
            "default_type = kind_to_type[expressions.default_kind]",
            "scalar_constant_kinds = list(kind_to_typecode.keys())",
            "",
            "# VML functions that are implemented in numexpr",
            "vml_functions = [",
            "    \"div\",  # interp_body.cpp",
            "    \"inv\",  # interp_body.cpp",
            "    \"pow\",  # interp_body.cpp",
            "    # Keep the rest of this list in sync with the ones listed in functions.hpp",
            "    \"sqrt\",",
            "    \"sin\",",
            "    \"cos\",",
            "    \"tan\",",
            "    \"arcsin\",",
            "    \"arccos\",",
            "    \"arctan\",",
            "    \"sinh\",",
            "    \"cosh\",",
            "    \"tanh\",",
            "    \"arcsinh\",",
            "    \"arccosh\",",
            "    \"arctanh\",",
            "    \"log\",",
            "    \"log1p\",",
            "    \"log10\",",
            "    \"exp\",",
            "    \"expm1\",",
            "    \"absolute\",",
            "    \"conjugate\",",
            "    \"arctan2\",",
            "    \"fmod\",",
            "    \"ceil\",",
            "    \"floor\"",
            "    ]",
            "",
            "",
            "class ASTNode():",
            "    \"\"\"Abstract Syntax Tree node.",
            "",
            "    Members:",
            "",
            "    astType      -- type of node (op, constant, variable, raw, or alias)",
            "    astKind      -- the type of the result (bool, float, etc.)",
            "    value        -- value associated with this node.",
            "                    An opcode, numerical value, a variable name, etc.",
            "    children     -- the children below this node",
            "    reg          -- the register assigned to the result for this node.",
            "    \"\"\"",
            "    cmpnames = ['astType', 'astKind', 'value', 'children']",
            "",
            "    def __init__(self, astType='generic', astKind='unknown', value=None, children=()):",
            "        self.astType = astType",
            "        self.astKind = astKind",
            "        self.value = value",
            "        self.children = tuple(children)",
            "        self.reg = None",
            "",
            "    def __eq__(self, other):",
            "        if self.astType == 'alias':",
            "            self = self.value",
            "        if other.astType == 'alias':",
            "            other = other.value",
            "        if not isinstance(other, ASTNode):",
            "            return False",
            "        for name in self.cmpnames:",
            "            if getattr(self, name) != getattr(other, name):",
            "                return False",
            "        return True",
            "    ",
            "    def __lt__(self,other):",
            "        # RAM: this is a fix for issue #88 whereby sorting on constants ",
            "        # that may be of astKind == 'complex' but type(self.value) == int or float",
            "        # Here we let NumPy sort as it will cast data properly for comparison ",
            "        # when the Python built-ins will raise an error.",
            "        if self.astType == 'constant':",
            "            if self.astKind == other.astKind:",
            "                return numpy.array(self.value) < numpy.array(other.value)",
            "            return self.astKind < other.astKind",
            "        else:",
            "            raise TypeError('Sorting not implemented for astType: %s'%self.astType)",
            "",
            "    def __hash__(self):",
            "        if self.astType == 'alias':",
            "            self = self.value",
            "        return hash((self.astType, self.astKind, self.value, self.children))",
            "",
            "    def __str__(self):",
            "        return 'AST(%s, %s, %s, %s, %s)' % (self.astType, self.astKind,",
            "                                            self.value, self.children, self.reg)",
            "",
            "    def __repr__(self):",
            "        return '<AST object at %s>' % id(self)",
            "",
            "    def key(self):",
            "        return (self.astType, self.astKind, self.value, self.children)",
            "",
            "    def typecode(self):",
            "        return kind_to_typecode[self.astKind]",
            "",
            "    def postorderWalk(self):",
            "        for c in self.children:",
            "            for w in c.postorderWalk():",
            "                yield w",
            "        yield self",
            "",
            "    def allOf(self, *astTypes):",
            "        astTypes = set(astTypes)",
            "        for w in self.postorderWalk():",
            "            if w.astType in astTypes:",
            "                yield w",
            "",
            "",
            "def expressionToAST(ex):",
            "    \"\"\"Take an expression tree made out of expressions.ExpressionNode,",
            "    and convert to an AST tree.",
            "",
            "    This is necessary as ExpressionNode overrides many methods to act",
            "    like a number.",
            "    \"\"\"",
            "    return ASTNode(ex.astType, ex.astKind, ex.value,",
            "                   [expressionToAST(c) for c in ex.children])",
            "",
            "",
            "def sigPerms(s):",
            "    \"\"\"Generate all possible signatures derived by upcasting the given",
            "    signature.",
            "    \"\"\"",
            "    codes = 'bilfdc'",
            "    if not s:",
            "        yield ''",
            "    elif s[0] in codes:",
            "        start = codes.index(s[0])",
            "        for x in codes[start:]:",
            "            for y in sigPerms(s[1:]):",
            "                yield x + y",
            "    elif s[0] == 's':  # numbers shall not be cast to strings",
            "        for y in sigPerms(s[1:]):",
            "            yield 's' + y",
            "    else:",
            "        yield s",
            "",
            "",
            "def typeCompileAst(ast):",
            "    \"\"\"Assign appropriate types to each node in the AST.",
            "",
            "    Will convert opcodes and functions to appropriate upcast version,",
            "    and add \"cast\" ops if needed.",
            "    \"\"\"",
            "    children = list(ast.children)",
            "    if ast.astType == 'op':",
            "        retsig = ast.typecode()",
            "        basesig = ''.join(x.typecode() for x in list(ast.children))",
            "        # Find some operation that will work on an acceptable casting of args.",
            "        for sig in sigPerms(basesig):",
            "            value = (ast.value + '_' + retsig + sig).encode('ascii')",
            "            if value in interpreter.opcodes:",
            "                break",
            "        else:",
            "            for sig in sigPerms(basesig):",
            "                funcname = (ast.value + '_' + retsig + sig).encode('ascii')",
            "                if funcname in interpreter.funccodes:",
            "                    value = ('func_%sn' % (retsig + sig)).encode('ascii')",
            "                    children += [ASTNode('raw', 'none',",
            "                                         interpreter.funccodes[funcname])]",
            "                    break",
            "            else:",
            "                raise NotImplementedError(",
            "                    \"couldn't find matching opcode for '%s'\"",
            "                    % (ast.value + '_' + retsig + basesig))",
            "        # First just cast constants, then cast variables if necessary:",
            "        for i, (have, want) in enumerate(zip(basesig, sig)):",
            "            if have != want:",
            "                kind = typecode_to_kind[want]",
            "                if children[i].astType == 'constant':",
            "                    children[i] = ASTNode('constant', kind, children[i].value)",
            "                else:",
            "                    opname = \"cast\"",
            "                    children[i] = ASTNode('op', kind, opname, [children[i]])",
            "    else:",
            "        value = ast.value",
            "        children = ast.children",
            "    return ASTNode(ast.astType, ast.astKind, value,",
            "                   [typeCompileAst(c) for c in children])",
            "",
            "",
            "class Register():",
            "    \"\"\"Abstraction for a register in the VM.",
            "",
            "    Members:",
            "    node          -- the AST node this corresponds to",
            "    temporary     -- True if this isn't an input or output",
            "    immediate     -- not a register, but an immediate value",
            "    n             -- the physical register number.",
            "                     None if no number assigned yet.",
            "    \"\"\"",
            "",
            "    def __init__(self, astnode, temporary=False):",
            "        self.node = astnode",
            "        self.temporary = temporary",
            "        self.immediate = False",
            "        self.n = None",
            "",
            "    def __str__(self):",
            "        if self.temporary:",
            "            name = 'Temporary'",
            "        else:",
            "            name = 'Register'",
            "        return '%s(%s, %s, %s)' % (name, self.node.astType,",
            "                                   self.node.astKind, self.n,)",
            "",
            "    def __repr__(self):",
            "        return self.__str__()",
            "",
            "",
            "class Immediate(Register):",
            "    \"\"\"Representation of an immediate (integer) operand, instead of",
            "    a register.",
            "    \"\"\"",
            "",
            "    def __init__(self, astnode):",
            "        Register.__init__(self, astnode)",
            "        self.immediate = True",
            "",
            "    def __str__(self):",
            "        return 'Immediate(%d)' % (self.node.value,)",
            "",
            "",
            "def stringToExpression(s, types, context):",
            "    \"\"\"Given a string, convert it to a tree of ExpressionNode's.",
            "    \"\"\"",
            "    old_ctx = expressions._context.get_current_context()",
            "    try:",
            "        expressions._context.set_new_context(context)",
            "        # first compile to a code object to determine the names",
            "        if context.get('truediv', False):",
            "            flags = __future__.division.compiler_flag",
            "        else:",
            "            flags = 0",
            "        c = compile(s, '<expr>', 'eval', flags)",
            "        # make VariableNode's for the names",
            "        names = {}",
            "        for name in c.co_names:",
            "            if name == \"None\":",
            "                names[name] = None",
            "            elif name == \"True\":",
            "                names[name] = True",
            "            elif name == \"False\":",
            "                names[name] = False",
            "            else:",
            "                t = types.get(name, default_type)",
            "                names[name] = expressions.VariableNode(name, type_to_kind[t])",
            "        names.update(expressions.functions)",
            "        # now build the expression",
            "        ex = eval(c, names)",
            "        if expressions.isConstant(ex):",
            "            ex = expressions.ConstantNode(ex, expressions.getKind(ex))",
            "        elif not isinstance(ex, expressions.ExpressionNode):",
            "            raise TypeError(\"unsupported expression type: %s\" % type(ex))",
            "    finally:",
            "        expressions._context.set_new_context(old_ctx)",
            "    return ex",
            "",
            "",
            "def isReduction(ast):",
            "    prefixes = (b'sum_', b'prod_', b'min_', b'max_')",
            "    return any(ast.value.startswith(p) for p in prefixes)",
            "",
            "",
            "def getInputOrder(ast, input_order=None):",
            "    \"\"\"",
            "    Derive the input order of the variables in an expression.",
            "    \"\"\"",
            "    variables = {}",
            "    for a in ast.allOf('variable'):",
            "        variables[a.value] = a",
            "    variable_names = set(variables.keys())",
            "",
            "    if input_order:",
            "        if variable_names != set(input_order):",
            "            raise ValueError(",
            "                \"input names (%s) don't match those found in expression (%s)\"",
            "                % (input_order, variable_names))",
            "",
            "        ordered_names = input_order",
            "    else:",
            "        ordered_names = list(variable_names)",
            "        ordered_names.sort()",
            "    ordered_variables = [variables[v] for v in ordered_names]",
            "    return ordered_variables",
            "",
            "",
            "def convertConstantToKind(x, kind):",
            "    # Exception for 'float' types that will return the NumPy float32 type",
            "    if kind == 'float':",
            "        return numpy.float32(x)",
            "    elif isinstance(x,str):",
            "        return x.encode('ascii')",
            "    return kind_to_type[kind](x)",
            "",
            "",
            "def getConstants(ast):",
            "    \"\"\"",
            "    RAM: implemented magic method __lt__ for ASTNode to fix issues",
            "    #88 and #209. The following test code works now, as does the test suite.",
            "",
            "        import numexpr as ne",
            "        a = 1 + 3j; b = 5.0",
            "        ne.evaluate('a*2 + 15j - b')",
            "    \"\"\"",
            "    constant_registers = set([node.reg for node in ast.allOf(\"constant\")]) ",
            "    constants_order = sorted([r.node for r in constant_registers])",
            "    constants = [convertConstantToKind(a.value, a.astKind)",
            "                 for a in constants_order]",
            "    return constants_order, constants",
            "",
            "",
            "def sortNodesByOrder(nodes, order):",
            "    order_map = {}",
            "    for i, (_, v, _) in enumerate(order):",
            "        order_map[v] = i",
            "    dec_nodes = [(order_map[n.value], n) for n in nodes]",
            "    dec_nodes.sort()",
            "    return [a[1] for a in dec_nodes]",
            "",
            "",
            "def assignLeafRegisters(inodes, registerMaker):",
            "    \"\"\"",
            "    Assign new registers to each of the leaf nodes.",
            "    \"\"\"",
            "    leafRegisters = {}",
            "    for node in inodes:",
            "        key = node.key()",
            "        if key in leafRegisters:",
            "            node.reg = leafRegisters[key]",
            "        else:",
            "            node.reg = leafRegisters[key] = registerMaker(node)",
            "",
            "",
            "def assignBranchRegisters(inodes, registerMaker):",
            "    \"\"\"",
            "    Assign temporary registers to each of the branch nodes.",
            "    \"\"\"",
            "    for node in inodes:",
            "        node.reg = registerMaker(node, temporary=True)",
            "",
            "",
            "def collapseDuplicateSubtrees(ast):",
            "    \"\"\"",
            "    Common subexpression elimination.",
            "    \"\"\"",
            "    seen = {}",
            "    aliases = []",
            "    for a in ast.allOf('op'):",
            "        if a in seen:",
            "            target = seen[a]",
            "            a.astType = 'alias'",
            "            a.value = target",
            "            a.children = ()",
            "            aliases.append(a)",
            "        else:",
            "            seen[a] = a",
            "    # Set values and registers so optimizeTemporariesAllocation",
            "    # doesn't get confused",
            "    for a in aliases:",
            "        while a.value.astType == 'alias':",
            "            a.value = a.value.value",
            "    return aliases",
            "",
            "",
            "def optimizeTemporariesAllocation(ast):",
            "    \"\"\"",
            "    Attempt to minimize the number of temporaries needed, by reusing old ones.",
            "    \"\"\"",
            "    nodes = [n for n in ast.postorderWalk() if n.reg.temporary]",
            "    users_of = dict((n.reg, set()) for n in nodes)",
            "",
            "    node_regs = dict((n, set(c.reg for c in n.children if c.reg.temporary))",
            "                     for n in nodes)",
            "    if nodes and nodes[-1] is not ast:",
            "        nodes_to_check = nodes + [ast]",
            "    else:",
            "        nodes_to_check = nodes",
            "    for n in nodes_to_check:",
            "        for c in n.children:",
            "            if c.reg.temporary:",
            "                users_of[c.reg].add(n)",
            "",
            "    unused = dict([(tc, set()) for tc in scalar_constant_kinds])",
            "    for n in nodes:",
            "        for c in n.children:",
            "            reg = c.reg",
            "            if reg.temporary:",
            "                users = users_of[reg]",
            "                users.discard(n)",
            "                if not users:",
            "                    unused[reg.node.astKind].add(reg)",
            "        if unused[n.astKind]:",
            "            reg = unused[n.astKind].pop()",
            "            users_of[reg] = users_of[n.reg]",
            "            n.reg = reg",
            "",
            "",
            "def setOrderedRegisterNumbers(order, start):",
            "    \"\"\"",
            "    Given an order of nodes, assign register numbers.",
            "    \"\"\"",
            "    for i, node in enumerate(order):",
            "        node.reg.n = start + i",
            "    return start + len(order)",
            "",
            "",
            "def setRegisterNumbersForTemporaries(ast, start):",
            "    \"\"\"",
            "    Assign register numbers for temporary registers, keeping track of",
            "    aliases and handling immediate operands.",
            "    \"\"\"",
            "    seen = 0",
            "    signature = ''",
            "    aliases = []",
            "    for node in ast.postorderWalk():",
            "        if node.astType == 'alias':",
            "            aliases.append(node)",
            "            node = node.value",
            "        if node.reg.immediate:",
            "            node.reg.n = node.value",
            "            continue",
            "        reg = node.reg",
            "        if reg.n is None:",
            "            reg.n = start + seen",
            "            seen += 1",
            "            signature += reg.node.typecode()",
            "    for node in aliases:",
            "        node.reg = node.value.reg",
            "    return start + seen, signature",
            "",
            "",
            "def convertASTtoThreeAddrForm(ast):",
            "    \"\"\"",
            "    Convert an AST to a three address form.",
            "",
            "    Three address form is (op, reg1, reg2, reg3), where reg1 is the",
            "    destination of the result of the instruction.",
            "",
            "    I suppose this should be called three register form, but three",
            "    address form is found in compiler theory.",
            "    \"\"\"",
            "    return [(node.value, node.reg) + tuple([c.reg for c in node.children])",
            "            for node in ast.allOf('op')]",
            "",
            "",
            "def compileThreeAddrForm(program):",
            "    \"\"\"",
            "    Given a three address form of the program, compile it a string that",
            "    the VM understands.",
            "    \"\"\"",
            "",
            "    def nToChr(reg):",
            "        if reg is None:",
            "            return b'\\xff'",
            "        elif reg.n < 0:",
            "            raise ValueError(\"negative value for register number %s\" % reg.n)",
            "        else:",
            "            return bytes([reg.n])",
            "",
            "    def quadrupleToString(opcode, store, a1=None, a2=None):",
            "        cop = chr(interpreter.opcodes[opcode]).encode('ascii')",
            "        cs = nToChr(store)",
            "        ca1 = nToChr(a1)",
            "        ca2 = nToChr(a2)",
            "        return cop + cs + ca1 + ca2",
            "",
            "    def toString(args):",
            "        while len(args) < 4:",
            "            args += (None,)",
            "        opcode, store, a1, a2 = args[:4]",
            "        s = quadrupleToString(opcode, store, a1, a2)",
            "        l = [s]",
            "        args = args[4:]",
            "        while args:",
            "            s = quadrupleToString(b'noop', *args[:3])",
            "            l.append(s)",
            "            args = args[3:]",
            "        return b''.join(l)",
            "",
            "    prog_str = b''.join([toString(t) for t in program])",
            "    return prog_str",
            "",
            "",
            "context_info = [",
            "    ('optimization', ('none', 'moderate', 'aggressive'), 'aggressive'),",
            "    ('truediv', (False, True, 'auto'), 'auto')",
            "]",
            "",
            "",
            "def getContext(kwargs, _frame_depth=1):",
            "    d = kwargs.copy()",
            "    context = {}",
            "    for name, allowed, default in context_info:",
            "        value = d.pop(name, default)",
            "        if value in allowed:",
            "            context[name] = value",
            "        else:",
            "            raise ValueError(\"'%s' must be one of %s\" % (name, allowed))",
            "    ",
            "    if d:",
            "        raise ValueError(\"Unknown keyword argument '%s'\" % d.popitem()[0])",
            "    if context['truediv'] == 'auto':",
            "        caller_globals = sys._getframe(_frame_depth + 1).f_globals",
            "        context['truediv'] = caller_globals.get('division', None) == __future__.division",
            "",
            "    return context",
            "",
            "",
            "def precompile(ex, signature=(), context={}):",
            "    \"\"\"",
            "    Compile the expression to an intermediate form.",
            "    \"\"\"",
            "    types = dict(signature)",
            "    input_order = [name for (name, type_) in signature]",
            "",
            "    if isinstance(ex, str):",
            "        ex = stringToExpression(ex, types, context)",
            "",
            "    # the AST is like the expression, but the node objects don't have",
            "    # any odd interpretations",
            "",
            "    ast = expressionToAST(ex)",
            "",
            "    if ex.astType != 'op':",
            "        ast = ASTNode('op', value='copy', astKind=ex.astKind, children=(ast,))",
            "",
            "    ast = typeCompileAst(ast)",
            "",
            "    aliases = collapseDuplicateSubtrees(ast)",
            "",
            "    assignLeafRegisters(ast.allOf('raw'), Immediate)",
            "    assignLeafRegisters(ast.allOf('variable', 'constant'), Register)",
            "    assignBranchRegisters(ast.allOf('op'), Register)",
            "",
            "    # assign registers for aliases",
            "    for a in aliases:",
            "        a.reg = a.value.reg",
            "",
            "    input_order = getInputOrder(ast, input_order)",
            "    constants_order, constants = getConstants(ast)",
            "",
            "    if isReduction(ast):",
            "        ast.reg.temporary = False",
            "",
            "    optimizeTemporariesAllocation(ast)",
            "",
            "    ast.reg.temporary = False",
            "    r_output = 0",
            "    ast.reg.n = 0",
            "",
            "    r_inputs = r_output + 1",
            "    r_constants = setOrderedRegisterNumbers(input_order, r_inputs)",
            "    r_temps = setOrderedRegisterNumbers(constants_order, r_constants)",
            "    r_end, tempsig = setRegisterNumbersForTemporaries(ast, r_temps)",
            "",
            "    threeAddrProgram = convertASTtoThreeAddrForm(ast)",
            "    input_names = tuple([a.value for a in input_order])",
            "    signature = ''.join(type_to_typecode[types.get(x, default_type)]",
            "                        for x in input_names)",
            "    return threeAddrProgram, signature, tempsig, constants, input_names",
            "",
            "",
            "def NumExpr(ex, signature=(), **kwargs):",
            "    \"\"\"",
            "    Compile an expression built using E.<variable> variables to a function.",
            "",
            "    ex can also be specified as a string \"2*a+3*b\".",
            "",
            "    The order of the input variables and their types can be specified using the",
            "    signature parameter, which is a list of (name, type) pairs.",
            "",
            "    Returns a `NumExpr` object containing the compiled function.",
            "    \"\"\"",
            "    # NumExpr can be called either directly by the end-user, in which case",
            "    # kwargs need to be sanitized by getContext, or by evaluate,",
            "    # in which case kwargs are in already sanitized.",
            "    # In that case _frame_depth is wrong (it should be 2) but it doesn't matter",
            "    # since it will not be used (because truediv='auto' has already been",
            "    # translated to either True or False).",
            "    _frame_depth = 1",
            "    context = getContext(kwargs, _frame_depth=_frame_depth)",
            "    threeAddrProgram, inputsig, tempsig, constants, input_names = precompile(ex, signature, context)",
            "    program = compileThreeAddrForm(threeAddrProgram)",
            "    return interpreter.NumExpr(inputsig.encode('ascii'),",
            "                               tempsig.encode('ascii'),",
            "                               program, constants, input_names)",
            "",
            "",
            "def disassemble(nex):",
            "    \"\"\"",
            "    Given a NumExpr object, return a list which is the program disassembled.",
            "    \"\"\"",
            "    rev_opcodes = {}",
            "    for op in interpreter.opcodes:",
            "        rev_opcodes[interpreter.opcodes[op]] = op",
            "    r_constants = 1 + len(nex.signature)",
            "    r_temps = r_constants + len(nex.constants)",
            "",
            "    def parseOp(op):",
            "        name, sig = [*op.rsplit(b'_', 1), ''][:2]",
            "        return name, sig ",
            "",
            "    def getArg(pc, offset):",
            "        arg = nex.program[pc + (offset if offset < 4 else offset+1)]",
            "        _, sig = parseOp(rev_opcodes.get(nex.program[pc]))",
            "        try:",
            "            code = sig[offset - 1]",
            "        except IndexError:",
            "            return None",
            "",
            "        code = bytes([code])",
            "",
            "        if arg == 255:",
            "            return None",
            "        if code != b'n':",
            "            if arg == 0:",
            "                return b'r0'",
            "            elif arg < r_constants:",
            "                return ('r%d[%s]' % (arg, nex.input_names[arg - 1])).encode('ascii')",
            "            elif arg < r_temps:",
            "                return ('c%d[%s]' % (arg, nex.constants[arg - r_constants])).encode('ascii')",
            "            else:",
            "                return ('t%d' % (arg,)).encode('ascii')",
            "        else:",
            "            return arg",
            "",
            "    source = []",
            "    for pc in range(0, len(nex.program), 4):",
            "        op = rev_opcodes.get(nex.program[pc])",
            "        _, sig = parseOp(op)",
            "        parsed = [op]",
            "        for i in range(len(sig)):",
            "            parsed.append(getArg(pc, 1 + i))",
            "        while len(parsed) < 4:",
            "            parsed.append(None)",
            "        source.append(parsed)",
            "    return source",
            "",
            "",
            "def getType(a):",
            "    kind = a.dtype.kind",
            "    if kind == 'b':",
            "        return bool",
            "    if kind in 'iu':",
            "        if a.dtype.itemsize > 4:",
            "            return long_  # ``long`` is for integers of more than 32 bits",
            "        if kind == 'u' and a.dtype.itemsize == 4:",
            "            return long_  # use ``long`` here as an ``int`` is not enough",
            "        return int_",
            "    if kind == 'f':",
            "        if a.dtype.itemsize > 4:",
            "            return double  # ``double`` is for floats of more than 32 bits",
            "        return float",
            "    if kind == 'c':",
            "        return complex",
            "    if kind == 'S':",
            "        return bytes",
            "    if kind == 'U':",
            "        raise ValueError('NumExpr 2 does not support Unicode as a dtype.')",
            "    raise ValueError(\"unknown type %s\" % a.dtype.name)",
            "",
            "",
            "def getExprNames(text, context):",
            "    ex = stringToExpression(text, {}, context)",
            "    ast = expressionToAST(ex)",
            "    input_order = getInputOrder(ast, None)",
            "    #try to figure out if vml operations are used by expression",
            "    if not use_vml:",
            "        ex_uses_vml = False",
            "    else:",
            "        for node in ast.postorderWalk():",
            "            if node.astType == 'op' and node.value in vml_functions:",
            "                ex_uses_vml = True",
            "                break",
            "        else:",
            "            ex_uses_vml = False",
            "",
            "    return [a.value for a in input_order], ex_uses_vml",
            "",
            "",
            "def getArguments(names, local_dict=None, global_dict=None, _frame_depth: int=2):",
            "    \"\"\"",
            "    Get the arguments based on the names.",
            "    \"\"\"",
            "    call_frame = sys._getframe(_frame_depth)",
            "",
            "    clear_local_dict = False",
            "    if local_dict is None:",
            "        local_dict = call_frame.f_locals",
            "        clear_local_dict = True",
            "    try:",
            "        frame_globals = call_frame.f_globals",
            "        if global_dict is None:",
            "            global_dict = frame_globals",
            "",
            "        # If `call_frame` is the top frame of the interpreter we can't clear its ",
            "        # `local_dict`, because it is actually the `global_dict`.",
            "        clear_local_dict = clear_local_dict and not frame_globals is local_dict",
            "",
            "        arguments = []",
            "        for name in names:",
            "            try:",
            "                a = local_dict[name]",
            "            except KeyError:",
            "                a = global_dict[name]",
            "            arguments.append(numpy.asarray(a))",
            "    finally:",
            "        # If we generated local_dict via an explicit reference to f_locals,",
            "        # clear the dict to prevent creating extra ref counts in the caller's scope",
            "        # See https://github.com/pydata/numexpr/issues/310",
            "        if clear_local_dict:",
            "            local_dict.clear()",
            "",
            "    return arguments",
            "",
            "",
            "# Dictionaries for caching variable names and compiled expressions",
            "_names_cache = CacheDict(256)",
            "_numexpr_cache = CacheDict(256)",
            "_numexpr_last = {}",
            "",
            "evaluate_lock = threading.Lock()",
            "",
            "# MAYBE: decorate this function to add attributes instead of having the ",
            "# _numexpr_last dictionary?",
            "def validate(ex: str, ",
            "             local_dict: Optional[Dict] = None, ",
            "             global_dict: Optional[Dict] = None,",
            "             out: numpy.ndarray = None, ",
            "             order: str = 'K', ",
            "             casting: str = 'safe', ",
            "             _frame_depth: int = 2,",
            "             **kwargs) -> Optional[Exception]:",
            "    \"\"\"",
            "    Validate a NumExpr expression with the given `local_dict` or `locals()`.",
            "    Returns `None` on success and the Exception object if one occurs. Note that ",
            "    you can proceed directly to call `re_evaluate()` if you use `validate()`",
            "    to sanitize your expressions and variables in advance.",
            "",
            "    Parameters",
            "    ----------",
            "    ex: str",
            "        a string forming an expression, like \"2*a+3*b\". The values for \"a\"",
            "        and \"b\" will by default be taken from the calling function's frame",
            "        (through use of sys._getframe()). Alternatively, they can be specified",
            "        using the 'local_dict' or 'global_dict' arguments.",
            "",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "",
            "    global_dict: dictionary, optional",
            "        A dictionary that replaces the global operands in current frame.",
            "",
            "    out: NumPy array, optional",
            "        An existing array where the outcome is going to be stored.  Care is",
            "        required so that this array has the same shape and type than the",
            "        actual outcome of the computation.  Useful for avoiding unnecessary",
            "        new array allocations.",
            "",
            "    order: {'C', 'F', 'A', or 'K'}, optional",
            "        Controls the iteration order for operands. 'C' means C order, 'F'",
            "        means Fortran order, 'A' means 'F' order if all the arrays are",
            "        Fortran contiguous, 'C' order otherwise, and 'K' means as close to",
            "        the order the array elements appear in memory as possible.  For",
            "        efficient computations, typically 'K'eep order (the default) is",
            "        desired.",
            "",
            "    casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "        Controls what kind of data casting may occur when making a copy or",
            "        buffering.  Setting this to 'unsafe' is not recommended, as it can",
            "        adversely affect accumulations.",
            "",
            "          * 'no' means the data types should not be cast at all.",
            "          * 'equiv' means only byte-order changes are allowed.",
            "          * 'safe' means only casts which can preserve values are allowed.",
            "          * 'same_kind' means only safe casts or casts within a kind,",
            "            like float64 to float32, are allowed.",
            "          * 'unsafe' means any data conversions may be done.",
            "",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "    \"\"\"",
            "    global _numexpr_last",
            "",
            "    try:",
            "        ",
            "        if not isinstance(ex, str):",
            "            raise ValueError(\"must specify expression as a string\")",
            "",
            "        # Get the names for this expression",
            "        context = getContext(kwargs)",
            "        expr_key = (ex, tuple(sorted(context.items())))",
            "        if expr_key not in _names_cache:",
            "            _names_cache[expr_key] = getExprNames(ex, context)",
            "        names, ex_uses_vml = _names_cache[expr_key]",
            "        arguments = getArguments(names, local_dict, global_dict, _frame_depth=_frame_depth)",
            "",
            "        # Create a signature",
            "        signature = [(name, getType(arg)) for (name, arg) in",
            "                    zip(names, arguments)]",
            "",
            "        # Look up numexpr if possible.",
            "        numexpr_key = expr_key + (tuple(signature),)",
            "        try:",
            "            compiled_ex = _numexpr_cache[numexpr_key]",
            "        except KeyError:",
            "            compiled_ex = _numexpr_cache[numexpr_key] = NumExpr(ex, signature, **context)",
            "        kwargs = {'out': out, 'order': order, 'casting': casting,",
            "                'ex_uses_vml': ex_uses_vml}",
            "        _numexpr_last = dict(ex=compiled_ex, argnames=names, kwargs=kwargs)",
            "        # with evaluate_lock:",
            "        #     return compiled_ex(*arguments, **kwargs)",
            "    except Exception as e:",
            "        return e",
            "    return None",
            "",
            "def evaluate(ex: str, ",
            "             local_dict: Optional[Dict] = None, ",
            "             global_dict: Optional[Dict] = None,",
            "             out: numpy.ndarray = None, ",
            "             order: str = 'K', ",
            "             casting: str = 'safe', ",
            "             _frame_depth: int=3,",
            "             **kwargs) -> numpy.ndarray:",
            "    \"\"\"",
            "    Evaluate a simple array expression element-wise using the virtual machine.",
            "",
            "    Parameters",
            "    ----------",
            "    ex: str",
            "        a string forming an expression, like \"2*a+3*b\". The values for \"a\"",
            "        and \"b\" will by default be taken from the calling function's frame",
            "        (through use of sys._getframe()). Alternatively, they can be specified",
            "        using the 'local_dict' or 'global_dict' arguments.",
            "",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "",
            "    global_dict: dictionary, optional",
            "        A dictionary that replaces the global operands in current frame.",
            "",
            "    out: NumPy array, optional",
            "        An existing array where the outcome is going to be stored.  Care is",
            "        required so that this array has the same shape and type than the",
            "        actual outcome of the computation.  Useful for avoiding unnecessary",
            "        new array allocations.",
            "",
            "    order: {'C', 'F', 'A', or 'K'}, optional",
            "        Controls the iteration order for operands. 'C' means C order, 'F'",
            "        means Fortran order, 'A' means 'F' order if all the arrays are",
            "        Fortran contiguous, 'C' order otherwise, and 'K' means as close to",
            "        the order the array elements appear in memory as possible.  For",
            "        efficient computations, typically 'K'eep order (the default) is",
            "        desired.",
            "",
            "    casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "        Controls what kind of data casting may occur when making a copy or",
            "        buffering.  Setting this to 'unsafe' is not recommended, as it can",
            "        adversely affect accumulations.",
            "",
            "          * 'no' means the data types should not be cast at all.",
            "          * 'equiv' means only byte-order changes are allowed.",
            "          * 'safe' means only casts which can preserve values are allowed.",
            "          * 'same_kind' means only safe casts or casts within a kind,",
            "            like float64 to float32, are allowed.",
            "          * 'unsafe' means any data conversions may be done.",
            "",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "    \"\"\"",
            "    # We could avoid code duplication if we called validate and then re_evaluate ",
            "    # here, but they we have difficulties with the `sys.getframe(2)` call in",
            "    # `getArguments`",
            "    e = validate(ex, local_dict=local_dict, global_dict=global_dict, ",
            "                 out=out, order=order, casting=casting, ",
            "                 _frame_depth=_frame_depth, **kwargs)",
            "    if e is None:",
            "        return re_evaluate(local_dict=local_dict, _frame_depth=_frame_depth)",
            "    else:",
            "        raise e",
            "    ",
            "",
            "  ",
            "",
            "",
            "def re_evaluate(local_dict: Optional[Dict] = None, ",
            "                _frame_depth: int=2) -> numpy.ndarray:",
            "    \"\"\"",
            "    Re-evaluate the previous executed array expression without any check.",
            "",
            "    This is meant for accelerating loops that are re-evaluating the same",
            "    expression repeatedly without changing anything else than the operands.",
            "    If unsure, use evaluate() which is safer.",
            "",
            "    Parameters",
            "    ----------",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "    \"\"\"",
            "    global _numexpr_last",
            "",
            "    try:",
            "        compiled_ex = _numexpr_last['ex']",
            "    except KeyError:",
            "        raise RuntimeError(\"A previous evaluate() execution was not found, please call `validate` or `evaluate` once before `re_evaluate`\")",
            "    argnames = _numexpr_last['argnames']",
            "    args = getArguments(argnames, local_dict, _frame_depth=_frame_depth)",
            "    kwargs = _numexpr_last['kwargs']",
            "    with evaluate_lock:",
            "        return compiled_ex(*args, **kwargs)"
        ],
        "afterPatchFile": [
            "###################################################################",
            "#  Numexpr - Fast numerical array expression evaluator for NumPy.",
            "#",
            "#      License: MIT",
            "#      Author:  See AUTHORS.txt",
            "#",
            "#  See LICENSE.txt and LICENSES/*.txt for details about copyright and",
            "#  rights to use.",
            "####################################################################",
            "",
            "from typing import Optional, Dict",
            "import __future__",
            "import sys",
            "import numpy",
            "import threading",
            "import re",
            "",
            "is_cpu_amd_intel = False # DEPRECATION WARNING: WILL BE REMOVED IN FUTURE RELEASE",
            "from numexpr import interpreter, expressions, use_vml",
            "from numexpr.utils import CacheDict",
            "",
            "# Declare a double type that does not exist in Python space",
            "double = numpy.double",
            "double = numpy.double",
            "",
            "int_ = numpy.int32",
            "long_ = numpy.int64",
            "",
            "typecode_to_kind = {'b': 'bool', 'i': 'int', 'l': 'long', 'f': 'float', 'd': 'double', ",
            "                    'c': 'complex', 'n': 'none', 's': 'str'}",
            "kind_to_typecode = {'bool': 'b', 'int': 'i', 'long': 'l', 'float': 'f', 'double': 'd',",
            "                    'complex': 'c', 'bytes': 's', 'str': 's', 'none': 'n'}",
            "type_to_typecode = {bool: 'b', int_: 'i', long_: 'l', float: 'f',",
            "                    double: 'd', complex: 'c', bytes: 's', str: 's'}",
            "type_to_kind = expressions.type_to_kind",
            "kind_to_type = expressions.kind_to_type",
            "default_type = kind_to_type[expressions.default_kind]",
            "scalar_constant_kinds = list(kind_to_typecode.keys())",
            "",
            "# VML functions that are implemented in numexpr",
            "vml_functions = [",
            "    \"div\",  # interp_body.cpp",
            "    \"inv\",  # interp_body.cpp",
            "    \"pow\",  # interp_body.cpp",
            "    # Keep the rest of this list in sync with the ones listed in functions.hpp",
            "    \"sqrt\",",
            "    \"sin\",",
            "    \"cos\",",
            "    \"tan\",",
            "    \"arcsin\",",
            "    \"arccos\",",
            "    \"arctan\",",
            "    \"sinh\",",
            "    \"cosh\",",
            "    \"tanh\",",
            "    \"arcsinh\",",
            "    \"arccosh\",",
            "    \"arctanh\",",
            "    \"log\",",
            "    \"log1p\",",
            "    \"log10\",",
            "    \"exp\",",
            "    \"expm1\",",
            "    \"absolute\",",
            "    \"conjugate\",",
            "    \"arctan2\",",
            "    \"fmod\",",
            "    \"ceil\",",
            "    \"floor\"",
            "    ]",
            "",
            "",
            "class ASTNode():",
            "    \"\"\"Abstract Syntax Tree node.",
            "",
            "    Members:",
            "",
            "    astType      -- type of node (op, constant, variable, raw, or alias)",
            "    astKind      -- the type of the result (bool, float, etc.)",
            "    value        -- value associated with this node.",
            "                    An opcode, numerical value, a variable name, etc.",
            "    children     -- the children below this node",
            "    reg          -- the register assigned to the result for this node.",
            "    \"\"\"",
            "    cmpnames = ['astType', 'astKind', 'value', 'children']",
            "",
            "    def __init__(self, astType='generic', astKind='unknown', value=None, children=()):",
            "        self.astType = astType",
            "        self.astKind = astKind",
            "        self.value = value",
            "        self.children = tuple(children)",
            "        self.reg = None",
            "",
            "    def __eq__(self, other):",
            "        if self.astType == 'alias':",
            "            self = self.value",
            "        if other.astType == 'alias':",
            "            other = other.value",
            "        if not isinstance(other, ASTNode):",
            "            return False",
            "        for name in self.cmpnames:",
            "            if getattr(self, name) != getattr(other, name):",
            "                return False",
            "        return True",
            "    ",
            "    def __lt__(self,other):",
            "        # RAM: this is a fix for issue #88 whereby sorting on constants ",
            "        # that may be of astKind == 'complex' but type(self.value) == int or float",
            "        # Here we let NumPy sort as it will cast data properly for comparison ",
            "        # when the Python built-ins will raise an error.",
            "        if self.astType == 'constant':",
            "            if self.astKind == other.astKind:",
            "                return numpy.array(self.value) < numpy.array(other.value)",
            "            return self.astKind < other.astKind",
            "        else:",
            "            raise TypeError('Sorting not implemented for astType: %s'%self.astType)",
            "",
            "    def __hash__(self):",
            "        if self.astType == 'alias':",
            "            self = self.value",
            "        return hash((self.astType, self.astKind, self.value, self.children))",
            "",
            "    def __str__(self):",
            "        return 'AST(%s, %s, %s, %s, %s)' % (self.astType, self.astKind,",
            "                                            self.value, self.children, self.reg)",
            "",
            "    def __repr__(self):",
            "        return '<AST object at %s>' % id(self)",
            "",
            "    def key(self):",
            "        return (self.astType, self.astKind, self.value, self.children)",
            "",
            "    def typecode(self):",
            "        return kind_to_typecode[self.astKind]",
            "",
            "    def postorderWalk(self):",
            "        for c in self.children:",
            "            for w in c.postorderWalk():",
            "                yield w",
            "        yield self",
            "",
            "    def allOf(self, *astTypes):",
            "        astTypes = set(astTypes)",
            "        for w in self.postorderWalk():",
            "            if w.astType in astTypes:",
            "                yield w",
            "",
            "",
            "def expressionToAST(ex):",
            "    \"\"\"Take an expression tree made out of expressions.ExpressionNode,",
            "    and convert to an AST tree.",
            "",
            "    This is necessary as ExpressionNode overrides many methods to act",
            "    like a number.",
            "    \"\"\"",
            "    return ASTNode(ex.astType, ex.astKind, ex.value,",
            "                   [expressionToAST(c) for c in ex.children])",
            "",
            "",
            "def sigPerms(s):",
            "    \"\"\"Generate all possible signatures derived by upcasting the given",
            "    signature.",
            "    \"\"\"",
            "    codes = 'bilfdc'",
            "    if not s:",
            "        yield ''",
            "    elif s[0] in codes:",
            "        start = codes.index(s[0])",
            "        for x in codes[start:]:",
            "            for y in sigPerms(s[1:]):",
            "                yield x + y",
            "    elif s[0] == 's':  # numbers shall not be cast to strings",
            "        for y in sigPerms(s[1:]):",
            "            yield 's' + y",
            "    else:",
            "        yield s",
            "",
            "",
            "def typeCompileAst(ast):",
            "    \"\"\"Assign appropriate types to each node in the AST.",
            "",
            "    Will convert opcodes and functions to appropriate upcast version,",
            "    and add \"cast\" ops if needed.",
            "    \"\"\"",
            "    children = list(ast.children)",
            "    if ast.astType == 'op':",
            "        retsig = ast.typecode()",
            "        basesig = ''.join(x.typecode() for x in list(ast.children))",
            "        # Find some operation that will work on an acceptable casting of args.",
            "        for sig in sigPerms(basesig):",
            "            value = (ast.value + '_' + retsig + sig).encode('ascii')",
            "            if value in interpreter.opcodes:",
            "                break",
            "        else:",
            "            for sig in sigPerms(basesig):",
            "                funcname = (ast.value + '_' + retsig + sig).encode('ascii')",
            "                if funcname in interpreter.funccodes:",
            "                    value = ('func_%sn' % (retsig + sig)).encode('ascii')",
            "                    children += [ASTNode('raw', 'none',",
            "                                         interpreter.funccodes[funcname])]",
            "                    break",
            "            else:",
            "                raise NotImplementedError(",
            "                    \"couldn't find matching opcode for '%s'\"",
            "                    % (ast.value + '_' + retsig + basesig))",
            "        # First just cast constants, then cast variables if necessary:",
            "        for i, (have, want) in enumerate(zip(basesig, sig)):",
            "            if have != want:",
            "                kind = typecode_to_kind[want]",
            "                if children[i].astType == 'constant':",
            "                    children[i] = ASTNode('constant', kind, children[i].value)",
            "                else:",
            "                    opname = \"cast\"",
            "                    children[i] = ASTNode('op', kind, opname, [children[i]])",
            "    else:",
            "        value = ast.value",
            "        children = ast.children",
            "    return ASTNode(ast.astType, ast.astKind, value,",
            "                   [typeCompileAst(c) for c in children])",
            "",
            "",
            "class Register():",
            "    \"\"\"Abstraction for a register in the VM.",
            "",
            "    Members:",
            "    node          -- the AST node this corresponds to",
            "    temporary     -- True if this isn't an input or output",
            "    immediate     -- not a register, but an immediate value",
            "    n             -- the physical register number.",
            "                     None if no number assigned yet.",
            "    \"\"\"",
            "",
            "    def __init__(self, astnode, temporary=False):",
            "        self.node = astnode",
            "        self.temporary = temporary",
            "        self.immediate = False",
            "        self.n = None",
            "",
            "    def __str__(self):",
            "        if self.temporary:",
            "            name = 'Temporary'",
            "        else:",
            "            name = 'Register'",
            "        return '%s(%s, %s, %s)' % (name, self.node.astType,",
            "                                   self.node.astKind, self.n,)",
            "",
            "    def __repr__(self):",
            "        return self.__str__()",
            "",
            "",
            "class Immediate(Register):",
            "    \"\"\"Representation of an immediate (integer) operand, instead of",
            "    a register.",
            "    \"\"\"",
            "",
            "    def __init__(self, astnode):",
            "        Register.__init__(self, astnode)",
            "        self.immediate = True",
            "",
            "    def __str__(self):",
            "        return 'Immediate(%d)' % (self.node.value,)",
            "",
            "_forbidden_re = re.compile('[\\;[\\:]|__')",
            "def stringToExpression(s, types, context):",
            "    \"\"\"Given a string, convert it to a tree of ExpressionNode's.",
            "    \"\"\"",
            "    # sanitize the string for obvious attack vectors that NumExpr cannot ",
            "    # parse into its homebrew AST. This is to protect the call to `eval` below.",
            "    # We forbid `;`, `:`. `[` and `__`",
            "    # We would like to forbid `.` but it is both a reference and decimal point.",
            "    if _forbidden_re.search(s) is not None:",
            "        raise ValueError(f'Expression {s} has forbidden control characters.')",
            "    ",
            "    old_ctx = expressions._context.get_current_context()",
            "    try:",
            "        expressions._context.set_new_context(context)",
            "        # first compile to a code object to determine the names",
            "        if context.get('truediv', False):",
            "            flags = __future__.division.compiler_flag",
            "        else:",
            "            flags = 0",
            "        c = compile(s, '<expr>', 'eval', flags)",
            "        # make VariableNode's for the names",
            "        names = {}",
            "        for name in c.co_names:",
            "            if name == \"None\":",
            "                names[name] = None",
            "            elif name == \"True\":",
            "                names[name] = True",
            "            elif name == \"False\":",
            "                names[name] = False",
            "            else:",
            "                t = types.get(name, default_type)",
            "                names[name] = expressions.VariableNode(name, type_to_kind[t])",
            "        names.update(expressions.functions)",
            "",
            "        # now build the expression",
            "        ex = eval(c, names)",
            "        ",
            "        if expressions.isConstant(ex):",
            "            ex = expressions.ConstantNode(ex, expressions.getKind(ex))",
            "        elif not isinstance(ex, expressions.ExpressionNode):",
            "            raise TypeError(\"unsupported expression type: %s\" % type(ex))",
            "    finally:",
            "        expressions._context.set_new_context(old_ctx)",
            "    return ex",
            "",
            "",
            "def isReduction(ast):",
            "    prefixes = (b'sum_', b'prod_', b'min_', b'max_')",
            "    return any(ast.value.startswith(p) for p in prefixes)",
            "",
            "",
            "def getInputOrder(ast, input_order=None):",
            "    \"\"\"",
            "    Derive the input order of the variables in an expression.",
            "    \"\"\"",
            "    variables = {}",
            "    for a in ast.allOf('variable'):",
            "        variables[a.value] = a",
            "    variable_names = set(variables.keys())",
            "",
            "    if input_order:",
            "        if variable_names != set(input_order):",
            "            raise ValueError(",
            "                \"input names (%s) don't match those found in expression (%s)\"",
            "                % (input_order, variable_names))",
            "",
            "        ordered_names = input_order",
            "    else:",
            "        ordered_names = list(variable_names)",
            "        ordered_names.sort()",
            "    ordered_variables = [variables[v] for v in ordered_names]",
            "    return ordered_variables",
            "",
            "",
            "def convertConstantToKind(x, kind):",
            "    # Exception for 'float' types that will return the NumPy float32 type",
            "    if kind == 'float':",
            "        return numpy.float32(x)",
            "    elif isinstance(x,str):",
            "        return x.encode('ascii')",
            "    return kind_to_type[kind](x)",
            "",
            "",
            "def getConstants(ast):",
            "    \"\"\"",
            "    RAM: implemented magic method __lt__ for ASTNode to fix issues",
            "    #88 and #209. The following test code works now, as does the test suite.",
            "",
            "        import numexpr as ne",
            "        a = 1 + 3j; b = 5.0",
            "        ne.evaluate('a*2 + 15j - b')",
            "    \"\"\"",
            "    constant_registers = set([node.reg for node in ast.allOf(\"constant\")]) ",
            "    constants_order = sorted([r.node for r in constant_registers])",
            "    constants = [convertConstantToKind(a.value, a.astKind)",
            "                 for a in constants_order]",
            "    return constants_order, constants",
            "",
            "",
            "def sortNodesByOrder(nodes, order):",
            "    order_map = {}",
            "    for i, (_, v, _) in enumerate(order):",
            "        order_map[v] = i",
            "    dec_nodes = [(order_map[n.value], n) for n in nodes]",
            "    dec_nodes.sort()",
            "    return [a[1] for a in dec_nodes]",
            "",
            "",
            "def assignLeafRegisters(inodes, registerMaker):",
            "    \"\"\"",
            "    Assign new registers to each of the leaf nodes.",
            "    \"\"\"",
            "    leafRegisters = {}",
            "    for node in inodes:",
            "        key = node.key()",
            "        if key in leafRegisters:",
            "            node.reg = leafRegisters[key]",
            "        else:",
            "            node.reg = leafRegisters[key] = registerMaker(node)",
            "",
            "",
            "def assignBranchRegisters(inodes, registerMaker):",
            "    \"\"\"",
            "    Assign temporary registers to each of the branch nodes.",
            "    \"\"\"",
            "    for node in inodes:",
            "        node.reg = registerMaker(node, temporary=True)",
            "",
            "",
            "def collapseDuplicateSubtrees(ast):",
            "    \"\"\"",
            "    Common subexpression elimination.",
            "    \"\"\"",
            "    seen = {}",
            "    aliases = []",
            "    for a in ast.allOf('op'):",
            "        if a in seen:",
            "            target = seen[a]",
            "            a.astType = 'alias'",
            "            a.value = target",
            "            a.children = ()",
            "            aliases.append(a)",
            "        else:",
            "            seen[a] = a",
            "    # Set values and registers so optimizeTemporariesAllocation",
            "    # doesn't get confused",
            "    for a in aliases:",
            "        while a.value.astType == 'alias':",
            "            a.value = a.value.value",
            "    return aliases",
            "",
            "",
            "def optimizeTemporariesAllocation(ast):",
            "    \"\"\"",
            "    Attempt to minimize the number of temporaries needed, by reusing old ones.",
            "    \"\"\"",
            "    nodes = [n for n in ast.postorderWalk() if n.reg.temporary]",
            "    users_of = dict((n.reg, set()) for n in nodes)",
            "",
            "    node_regs = dict((n, set(c.reg for c in n.children if c.reg.temporary))",
            "                     for n in nodes)",
            "    if nodes and nodes[-1] is not ast:",
            "        nodes_to_check = nodes + [ast]",
            "    else:",
            "        nodes_to_check = nodes",
            "    for n in nodes_to_check:",
            "        for c in n.children:",
            "            if c.reg.temporary:",
            "                users_of[c.reg].add(n)",
            "",
            "    unused = dict([(tc, set()) for tc in scalar_constant_kinds])",
            "    for n in nodes:",
            "        for c in n.children:",
            "            reg = c.reg",
            "            if reg.temporary:",
            "                users = users_of[reg]",
            "                users.discard(n)",
            "                if not users:",
            "                    unused[reg.node.astKind].add(reg)",
            "        if unused[n.astKind]:",
            "            reg = unused[n.astKind].pop()",
            "            users_of[reg] = users_of[n.reg]",
            "            n.reg = reg",
            "",
            "",
            "def setOrderedRegisterNumbers(order, start):",
            "    \"\"\"",
            "    Given an order of nodes, assign register numbers.",
            "    \"\"\"",
            "    for i, node in enumerate(order):",
            "        node.reg.n = start + i",
            "    return start + len(order)",
            "",
            "",
            "def setRegisterNumbersForTemporaries(ast, start):",
            "    \"\"\"",
            "    Assign register numbers for temporary registers, keeping track of",
            "    aliases and handling immediate operands.",
            "    \"\"\"",
            "    seen = 0",
            "    signature = ''",
            "    aliases = []",
            "    for node in ast.postorderWalk():",
            "        if node.astType == 'alias':",
            "            aliases.append(node)",
            "            node = node.value",
            "        if node.reg.immediate:",
            "            node.reg.n = node.value",
            "            continue",
            "        reg = node.reg",
            "        if reg.n is None:",
            "            reg.n = start + seen",
            "            seen += 1",
            "            signature += reg.node.typecode()",
            "    for node in aliases:",
            "        node.reg = node.value.reg",
            "    return start + seen, signature",
            "",
            "",
            "def convertASTtoThreeAddrForm(ast):",
            "    \"\"\"",
            "    Convert an AST to a three address form.",
            "",
            "    Three address form is (op, reg1, reg2, reg3), where reg1 is the",
            "    destination of the result of the instruction.",
            "",
            "    I suppose this should be called three register form, but three",
            "    address form is found in compiler theory.",
            "    \"\"\"",
            "    return [(node.value, node.reg) + tuple([c.reg for c in node.children])",
            "            for node in ast.allOf('op')]",
            "",
            "",
            "def compileThreeAddrForm(program):",
            "    \"\"\"",
            "    Given a three address form of the program, compile it a string that",
            "    the VM understands.",
            "    \"\"\"",
            "",
            "    def nToChr(reg):",
            "        if reg is None:",
            "            return b'\\xff'",
            "        elif reg.n < 0:",
            "            raise ValueError(\"negative value for register number %s\" % reg.n)",
            "        else:",
            "            return bytes([reg.n])",
            "",
            "    def quadrupleToString(opcode, store, a1=None, a2=None):",
            "        cop = chr(interpreter.opcodes[opcode]).encode('ascii')",
            "        cs = nToChr(store)",
            "        ca1 = nToChr(a1)",
            "        ca2 = nToChr(a2)",
            "        return cop + cs + ca1 + ca2",
            "",
            "    def toString(args):",
            "        while len(args) < 4:",
            "            args += (None,)",
            "        opcode, store, a1, a2 = args[:4]",
            "        s = quadrupleToString(opcode, store, a1, a2)",
            "        l = [s]",
            "        args = args[4:]",
            "        while args:",
            "            s = quadrupleToString(b'noop', *args[:3])",
            "            l.append(s)",
            "            args = args[3:]",
            "        return b''.join(l)",
            "",
            "    prog_str = b''.join([toString(t) for t in program])",
            "    return prog_str",
            "",
            "",
            "context_info = [",
            "    ('optimization', ('none', 'moderate', 'aggressive'), 'aggressive'),",
            "    ('truediv', (False, True, 'auto'), 'auto')",
            "]",
            "",
            "",
            "def getContext(kwargs, _frame_depth=1):",
            "    d = kwargs.copy()",
            "    context = {}",
            "    for name, allowed, default in context_info:",
            "        value = d.pop(name, default)",
            "        if value in allowed:",
            "            context[name] = value",
            "        else:",
            "            raise ValueError(\"'%s' must be one of %s\" % (name, allowed))",
            "    ",
            "    if d:",
            "        raise ValueError(\"Unknown keyword argument '%s'\" % d.popitem()[0])",
            "    if context['truediv'] == 'auto':",
            "        caller_globals = sys._getframe(_frame_depth + 1).f_globals",
            "        context['truediv'] = caller_globals.get('division', None) == __future__.division",
            "",
            "    return context",
            "",
            "",
            "def precompile(ex, signature=(), context={}):",
            "    \"\"\"",
            "    Compile the expression to an intermediate form.",
            "    \"\"\"",
            "    types = dict(signature)",
            "    input_order = [name for (name, type_) in signature]",
            "",
            "    if isinstance(ex, str):",
            "        ex = stringToExpression(ex, types, context)",
            "",
            "    # the AST is like the expression, but the node objects don't have",
            "    # any odd interpretations",
            "",
            "    ast = expressionToAST(ex)",
            "",
            "    if ex.astType != 'op':",
            "        ast = ASTNode('op', value='copy', astKind=ex.astKind, children=(ast,))",
            "",
            "    ast = typeCompileAst(ast)",
            "",
            "    aliases = collapseDuplicateSubtrees(ast)",
            "",
            "    assignLeafRegisters(ast.allOf('raw'), Immediate)",
            "    assignLeafRegisters(ast.allOf('variable', 'constant'), Register)",
            "    assignBranchRegisters(ast.allOf('op'), Register)",
            "",
            "    # assign registers for aliases",
            "    for a in aliases:",
            "        a.reg = a.value.reg",
            "",
            "    input_order = getInputOrder(ast, input_order)",
            "    constants_order, constants = getConstants(ast)",
            "",
            "    if isReduction(ast):",
            "        ast.reg.temporary = False",
            "",
            "    optimizeTemporariesAllocation(ast)",
            "",
            "    ast.reg.temporary = False",
            "    r_output = 0",
            "    ast.reg.n = 0",
            "",
            "    r_inputs = r_output + 1",
            "    r_constants = setOrderedRegisterNumbers(input_order, r_inputs)",
            "    r_temps = setOrderedRegisterNumbers(constants_order, r_constants)",
            "    r_end, tempsig = setRegisterNumbersForTemporaries(ast, r_temps)",
            "",
            "    threeAddrProgram = convertASTtoThreeAddrForm(ast)",
            "    input_names = tuple([a.value for a in input_order])",
            "    signature = ''.join(type_to_typecode[types.get(x, default_type)]",
            "                        for x in input_names)",
            "    return threeAddrProgram, signature, tempsig, constants, input_names",
            "",
            "",
            "def NumExpr(ex, signature=(), **kwargs):",
            "    \"\"\"",
            "    Compile an expression built using E.<variable> variables to a function.",
            "",
            "    ex can also be specified as a string \"2*a+3*b\".",
            "",
            "    The order of the input variables and their types can be specified using the",
            "    signature parameter, which is a list of (name, type) pairs.",
            "",
            "    Returns a `NumExpr` object containing the compiled function.",
            "    \"\"\"",
            "",
            "    # In that case _frame_depth is wrong (it should be 2) but it doesn't matter",
            "    # since it will not be used (because truediv='auto' has already been",
            "    # translated to either True or False).",
            "    _frame_depth = 1",
            "    context = getContext(kwargs, _frame_depth=_frame_depth)",
            "    threeAddrProgram, inputsig, tempsig, constants, input_names = precompile(ex, signature, context)",
            "    program = compileThreeAddrForm(threeAddrProgram)",
            "    return interpreter.NumExpr(inputsig.encode('ascii'),",
            "                               tempsig.encode('ascii'),",
            "                               program, constants, input_names)",
            "",
            "",
            "def disassemble(nex):",
            "    \"\"\"",
            "    Given a NumExpr object, return a list which is the program disassembled.",
            "    \"\"\"",
            "    rev_opcodes = {}",
            "    for op in interpreter.opcodes:",
            "        rev_opcodes[interpreter.opcodes[op]] = op",
            "    r_constants = 1 + len(nex.signature)",
            "    r_temps = r_constants + len(nex.constants)",
            "",
            "    def parseOp(op):",
            "        name, sig = [*op.rsplit(b'_', 1), ''][:2]",
            "        return name, sig ",
            "",
            "    def getArg(pc, offset):",
            "        arg = nex.program[pc + (offset if offset < 4 else offset+1)]",
            "        _, sig = parseOp(rev_opcodes.get(nex.program[pc]))",
            "        try:",
            "            code = sig[offset - 1]",
            "        except IndexError:",
            "            return None",
            "",
            "        code = bytes([code])",
            "",
            "        if arg == 255:",
            "            return None",
            "        if code != b'n':",
            "            if arg == 0:",
            "                return b'r0'",
            "            elif arg < r_constants:",
            "                return ('r%d[%s]' % (arg, nex.input_names[arg - 1])).encode('ascii')",
            "            elif arg < r_temps:",
            "                return ('c%d[%s]' % (arg, nex.constants[arg - r_constants])).encode('ascii')",
            "            else:",
            "                return ('t%d' % (arg,)).encode('ascii')",
            "        else:",
            "            return arg",
            "",
            "    source = []",
            "    for pc in range(0, len(nex.program), 4):",
            "        op = rev_opcodes.get(nex.program[pc])",
            "        _, sig = parseOp(op)",
            "        parsed = [op]",
            "        for i in range(len(sig)):",
            "            parsed.append(getArg(pc, 1 + i))",
            "        while len(parsed) < 4:",
            "            parsed.append(None)",
            "        source.append(parsed)",
            "    return source",
            "",
            "",
            "def getType(a):",
            "    kind = a.dtype.kind",
            "    if kind == 'b':",
            "        return bool",
            "    if kind in 'iu':",
            "        if a.dtype.itemsize > 4:",
            "            return long_  # ``long`` is for integers of more than 32 bits",
            "        if kind == 'u' and a.dtype.itemsize == 4:",
            "            return long_  # use ``long`` here as an ``int`` is not enough",
            "        return int_",
            "    if kind == 'f':",
            "        if a.dtype.itemsize > 4:",
            "            return double  # ``double`` is for floats of more than 32 bits",
            "        return float",
            "    if kind == 'c':",
            "        return complex",
            "    if kind == 'S':",
            "        return bytes",
            "    if kind == 'U':",
            "        raise ValueError('NumExpr 2 does not support Unicode as a dtype.')",
            "    raise ValueError(\"unknown type %s\" % a.dtype.name)",
            "",
            "",
            "def getExprNames(text, context):",
            "    ex = stringToExpression(text, {}, context)",
            "    ast = expressionToAST(ex)",
            "    input_order = getInputOrder(ast, None)",
            "    #try to figure out if vml operations are used by expression",
            "    if not use_vml:",
            "        ex_uses_vml = False",
            "    else:",
            "        for node in ast.postorderWalk():",
            "            if node.astType == 'op' and node.value in vml_functions:",
            "                ex_uses_vml = True",
            "                break",
            "        else:",
            "            ex_uses_vml = False",
            "",
            "    return [a.value for a in input_order], ex_uses_vml",
            "",
            "",
            "def getArguments(names, local_dict=None, global_dict=None, _frame_depth: int=2):",
            "    \"\"\"",
            "    Get the arguments based on the names.",
            "    \"\"\"",
            "    call_frame = sys._getframe(_frame_depth)",
            "",
            "    clear_local_dict = False",
            "    if local_dict is None:",
            "        local_dict = call_frame.f_locals",
            "        clear_local_dict = True",
            "    try:",
            "        frame_globals = call_frame.f_globals",
            "        if global_dict is None:",
            "            global_dict = frame_globals",
            "",
            "        # If `call_frame` is the top frame of the interpreter we can't clear its ",
            "        # `local_dict`, because it is actually the `global_dict`.",
            "        clear_local_dict = clear_local_dict and not frame_globals is local_dict",
            "",
            "        arguments = []",
            "        for name in names:",
            "            try:",
            "                a = local_dict[name]",
            "            except KeyError:",
            "                a = global_dict[name]",
            "            arguments.append(numpy.asarray(a))",
            "    finally:",
            "        # If we generated local_dict via an explicit reference to f_locals,",
            "        # clear the dict to prevent creating extra ref counts in the caller's scope",
            "        # See https://github.com/pydata/numexpr/issues/310",
            "        if clear_local_dict:",
            "            local_dict.clear()",
            "",
            "    return arguments",
            "",
            "",
            "# Dictionaries for caching variable names and compiled expressions",
            "_names_cache = CacheDict(256)",
            "_numexpr_cache = CacheDict(256)",
            "_numexpr_last = {}",
            "_numexpr_sanity = set()",
            "evaluate_lock = threading.Lock()",
            "",
            "# MAYBE: decorate this function to add attributes instead of having the ",
            "# _numexpr_last dictionary?",
            "def validate(ex: str, ",
            "             local_dict: Optional[Dict] = None, ",
            "             global_dict: Optional[Dict] = None,",
            "             out: numpy.ndarray = None, ",
            "             order: str = 'K', ",
            "             casting: str = 'safe', ",
            "             _frame_depth: int = 2,",
            "             **kwargs) -> Optional[Exception]:",
            "    \"\"\"",
            "    Validate a NumExpr expression with the given `local_dict` or `locals()`.",
            "    Returns `None` on success and the Exception object if one occurs. Note that ",
            "    you can proceed directly to call `re_evaluate()` if you use `validate()`",
            "    to sanitize your expressions and variables in advance.",
            "",
            "    Parameters",
            "    ----------",
            "    ex: str",
            "        a string forming an expression, like \"2*a+3*b\". The values for \"a\"",
            "        and \"b\" will by default be taken from the calling function's frame",
            "        (through use of sys._getframe()). Alternatively, they can be specified",
            "        using the 'local_dict' or 'global_dict' arguments.",
            "",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "",
            "    global_dict: dictionary, optional",
            "        A dictionary that replaces the global operands in current frame.",
            "",
            "    out: NumPy array, optional",
            "        An existing array where the outcome is going to be stored.  Care is",
            "        required so that this array has the same shape and type than the",
            "        actual outcome of the computation.  Useful for avoiding unnecessary",
            "        new array allocations.",
            "",
            "    order: {'C', 'F', 'A', or 'K'}, optional",
            "        Controls the iteration order for operands. 'C' means C order, 'F'",
            "        means Fortran order, 'A' means 'F' order if all the arrays are",
            "        Fortran contiguous, 'C' order otherwise, and 'K' means as close to",
            "        the order the array elements appear in memory as possible.  For",
            "        efficient computations, typically 'K'eep order (the default) is",
            "        desired.",
            "",
            "    casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "        Controls what kind of data casting may occur when making a copy or",
            "        buffering.  Setting this to 'unsafe' is not recommended, as it can",
            "        adversely affect accumulations.",
            "",
            "          * 'no' means the data types should not be cast at all.",
            "          * 'equiv' means only byte-order changes are allowed.",
            "          * 'safe' means only casts which can preserve values are allowed.",
            "          * 'same_kind' means only safe casts or casts within a kind,",
            "            like float64 to float32, are allowed.",
            "          * 'unsafe' means any data conversions may be done.",
            "",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "    \"\"\"",
            "    global _numexpr_last",
            "",
            "    try:",
            "        ",
            "        if not isinstance(ex, str):",
            "            raise ValueError(\"must specify expression as a string\")",
            "",
            "        # Get the names for this expression",
            "        context = getContext(kwargs)",
            "        expr_key = (ex, tuple(sorted(context.items())))",
            "        if expr_key not in _names_cache:",
            "            _names_cache[expr_key] = getExprNames(ex, context)",
            "        names, ex_uses_vml = _names_cache[expr_key]",
            "        arguments = getArguments(names, local_dict, global_dict, _frame_depth=_frame_depth)",
            "",
            "        # Create a signature",
            "        signature = [(name, getType(arg)) for (name, arg) in",
            "                    zip(names, arguments)]",
            "",
            "        # Look up numexpr if possible.",
            "        numexpr_key = expr_key + (tuple(signature),)",
            "        try:",
            "            compiled_ex = _numexpr_cache[numexpr_key]",
            "        except KeyError:",
            "            compiled_ex = _numexpr_cache[numexpr_key] = NumExpr(ex, signature, **context)",
            "        kwargs = {'out': out, 'order': order, 'casting': casting,",
            "                'ex_uses_vml': ex_uses_vml}",
            "        _numexpr_last = dict(ex=compiled_ex, argnames=names, kwargs=kwargs)",
            "        # with evaluate_lock:",
            "        #     return compiled_ex(*arguments, **kwargs)",
            "    except Exception as e:",
            "        return e",
            "    return None",
            "",
            "def evaluate(ex: str, ",
            "             local_dict: Optional[Dict] = None, ",
            "             global_dict: Optional[Dict] = None,",
            "             out: numpy.ndarray = None, ",
            "             order: str = 'K', ",
            "             casting: str = 'safe', ",
            "             _frame_depth: int = 3,",
            "             **kwargs) -> numpy.ndarray:",
            "    \"\"\"",
            "    Evaluate a simple array expression element-wise using the virtual machine.",
            "",
            "    Parameters",
            "    ----------",
            "    ex: str",
            "        a string forming an expression, like \"2*a+3*b\". The values for \"a\"",
            "        and \"b\" will by default be taken from the calling function's frame",
            "        (through use of sys._getframe()). Alternatively, they can be specified",
            "        using the 'local_dict' or 'global_dict' arguments.",
            "",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "",
            "    global_dict: dictionary, optional",
            "        A dictionary that replaces the global operands in current frame.",
            "",
            "    out: NumPy array, optional",
            "        An existing array where the outcome is going to be stored.  Care is",
            "        required so that this array has the same shape and type than the",
            "        actual outcome of the computation.  Useful for avoiding unnecessary",
            "        new array allocations.",
            "",
            "    order: {'C', 'F', 'A', or 'K'}, optional",
            "        Controls the iteration order for operands. 'C' means C order, 'F'",
            "        means Fortran order, 'A' means 'F' order if all the arrays are",
            "        Fortran contiguous, 'C' order otherwise, and 'K' means as close to",
            "        the order the array elements appear in memory as possible.  For",
            "        efficient computations, typically 'K'eep order (the default) is",
            "        desired.",
            "",
            "    casting: {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
            "        Controls what kind of data casting may occur when making a copy or",
            "        buffering.  Setting this to 'unsafe' is not recommended, as it can",
            "        adversely affect accumulations.",
            "",
            "          * 'no' means the data types should not be cast at all.",
            "          * 'equiv' means only byte-order changes are allowed.",
            "          * 'safe' means only casts which can preserve values are allowed.",
            "          * 'same_kind' means only safe casts or casts within a kind,",
            "            like float64 to float32, are allowed.",
            "          * 'unsafe' means any data conversions may be done.",
            "",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "",
            "    ",
            "    \"\"\"",
            "    # We could avoid code duplication if we called validate and then re_evaluate ",
            "    # here, but they we have difficulties with the `sys.getframe(2)` call in",
            "    # `getArguments`",
            "    e = validate(ex, local_dict=local_dict, global_dict=global_dict, ",
            "                 out=out, order=order, casting=casting, ",
            "                 _frame_depth=_frame_depth, **kwargs)",
            "    if e is None:",
            "        return re_evaluate(local_dict=local_dict, _frame_depth=_frame_depth)",
            "    else:",
            "        raise e",
            "    ",
            "def re_evaluate(local_dict: Optional[Dict] = None, ",
            "                _frame_depth: int=2) -> numpy.ndarray:",
            "    \"\"\"",
            "    Re-evaluate the previous executed array expression without any check.",
            "",
            "    This is meant for accelerating loops that are re-evaluating the same",
            "    expression repeatedly without changing anything else than the operands.",
            "    If unsure, use evaluate() which is safer.",
            "",
            "    Parameters",
            "    ----------",
            "    local_dict: dictionary, optional",
            "        A dictionary that replaces the local operands in current frame.",
            "    _frame_depth: int",
            "        The calling frame depth. Unless you are a NumExpr developer you should ",
            "        not set this value.",
            "    \"\"\"",
            "    global _numexpr_last",
            "",
            "    try:",
            "        compiled_ex = _numexpr_last['ex']",
            "    except KeyError:",
            "        raise RuntimeError(\"A previous evaluate() execution was not found, please call `validate` or `evaluate` once before `re_evaluate`\")",
            "    argnames = _numexpr_last['argnames']",
            "    args = getArguments(argnames, local_dict, _frame_depth=_frame_depth)",
            "    kwargs = _numexpr_last['kwargs']",
            "    with evaluate_lock:",
            "        return compiled_ex(*args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "262": [],
            "614": [
                "NumExpr"
            ],
            "615": [
                "NumExpr"
            ],
            "616": [
                "NumExpr"
            ],
            "761": [],
            "864": [
                "evaluate"
            ],
            "924": [],
            "925": [],
            "926": [],
            "927": []
        },
        "addLocation": []
    },
    "numexpr/tests/test_numexpr.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         a1 = array([1., 2., 3.])"
            },
            "1": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         b1 = array([4., 5., 6.])"
            },
            "2": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "         c1 = array([7., 8., 9.])"
            },
            "3": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        x = evaluate(\"2*a + 3*b*c\", local_dict={'a': a1, 'b': b1, 'c': c1})"
            },
            "4": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        x = re_evaluate()"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        local_dict={'a': a1, 'b': b1, 'c': c1}"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        x = evaluate(\"2*a + 3*b*c\", local_dict=local_dict)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        x = re_evaluate(local_dict=local_dict)"
            },
            "8": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "         assert_array_equal(x, array([86., 124., 168.]))"
            },
            "9": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 380,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "     def test_validate(self):"
            },
            "11": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         a1 = array([1., 2., 3.])"
            },
            "12": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         b1 = array([4., 5., 6.])"
            },
            "13": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         c1 = array([7., 8., 9.])"
            },
            "14": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        retval = validate(\"2*a + 3*b*c\", local_dict={'a': a1, 'b': b1, 'c': c1})"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+        local_dict={'a': a1, 'b': b1, 'c': c1}"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+        retval = validate(\"2*a + 3*b*c\", local_dict=local_dict)"
            },
            "17": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "         assert(retval is None)"
            },
            "18": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        x = re_evaluate()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+        x = re_evaluate(local_dict=local_dict)"
            },
            "20": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         assert_array_equal(x, array([86., 124., 168.]))"
            },
            "21": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 409,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "     # Test for issue #22"
            },
            "23": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         a = arange(3)"
            },
            "24": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "         try:"
            },
            "25": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "             evaluate(\"a < [0, 0, 0]\")"
            },
            "26": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except TypeError:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+        except (ValueError, TypeError):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+            pass"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+        else:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+            self.fail()"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+    def test_forbidden_tokens(self):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+        # Forbid dunder"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+        try:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 515,
                "PatchRowcode": "+            evaluate('__builtins__')"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+        except ValueError:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 517,
                "PatchRowcode": "+            pass"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+        else:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+            self.fail()"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 521,
                "PatchRowcode": "+        # Forbid colon for lambda funcs"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 522,
                "PatchRowcode": "+        try: "
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+            evaluate('lambda x: x')"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 524,
                "PatchRowcode": "+        except ValueError:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+            pass"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+        else:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+            self.fail()"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 529,
                "PatchRowcode": "+        # Forbid indexing"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 530,
                "PatchRowcode": "+        try:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 531,
                "PatchRowcode": "+            evaluate('locals()[]')"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 532,
                "PatchRowcode": "+        except ValueError:"
            },
            "53": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 533,
                "PatchRowcode": "             pass"
            },
            "54": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": 534,
                "PatchRowcode": "         else:"
            },
            "55": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": 535,
                "PatchRowcode": "             self.fail()"
            },
            "56": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": 536,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 537,
                "PatchRowcode": "+        # Forbid semicolon"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 538,
                "PatchRowcode": "+        try:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+            evaluate('import os; os.cpu_count()')"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 540,
                "PatchRowcode": "+        except ValueError:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+            pass"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 542,
                "PatchRowcode": "+        else:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+            self.fail()"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 544,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 545,
                "PatchRowcode": "+        # I struggle to come up with cases for our ban on `'` and `\"`"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 546,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "     def test_disassemble(self):"
            },
            "71": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "         assert_equal(disassemble(NumExpr("
            },
            "72": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "             \"where(m, a, -1)\", [('m', bool), ('a', float)])),"
            }
        },
        "frontPatchFile": [
            "",
            "###################################################################",
            "#  Numexpr - Fast numerical array expression evaluator for NumPy.",
            "#",
            "#      License: MIT",
            "#      Author:  See AUTHORS.txt",
            "#",
            "#  See LICENSE.txt and LICENSES/*.txt for details about copyright and",
            "#  rights to use.",
            "####################################################################",
            "",
            "",
            "import os",
            "import sys",
            "import platform",
            "import warnings",
            "from contextlib import contextmanager",
            "import subprocess",
            "",
            "import numpy as np",
            "from numpy import (",
            "    array, arange, empty, zeros, int32, int64, uint16, complex_, float64, rec,",
            "    copy, ones_like, where, alltrue, linspace,",
            "    sum, prod, sqrt, fmod, floor, ceil,",
            "    sin, cos, tan, arcsin, arccos, arctan, arctan2,",
            "    sinh, cosh, tanh, arcsinh, arccosh, arctanh,",
            "    log, log1p, log10, exp, expm1, conj)",
            "import numpy",
            "from numpy.testing import (assert_equal, assert_array_equal,",
            "                           assert_array_almost_equal, assert_allclose)",
            "from numpy import shape, allclose, array_equal, ravel, isnan, isinf",
            "",
            "import numexpr",
            "from numexpr import E, NumExpr, evaluate, re_evaluate, validate, disassemble, use_vml",
            "from numexpr.expressions import ConstantNode",
            "",
            "import unittest",
            "",
            "TestCase = unittest.TestCase",
            "",
            "double = np.double",
            "long = int",
            "",
            "",
            "class test_numexpr(TestCase):",
            "    \"\"\"Testing with 1 thread\"\"\"",
            "    nthreads = 1",
            "",
            "    def setUp(self):",
            "        numexpr.set_num_threads(self.nthreads)",
            "",
            "    def test_simple(self):",
            "        ex = 2.0 * E.a + 3.0 * E.b * E.c",
            "        sig = [('a', double), ('b', double), ('c', double)]",
            "        func = NumExpr(ex, signature=sig)",
            "        x = func(array([1., 2, 3]), array([4., 5, 6]), array([7., 8, 9]))",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_simple_expr_small_array(self):",
            "        func = NumExpr(E.a)",
            "        x = arange(100.0)",
            "        y = func(x)",
            "        assert_array_equal(x, y)",
            "",
            "    def test_simple_expr(self):",
            "        func = NumExpr(E.a)",
            "        x = arange(1e6)",
            "        y = func(x)",
            "        assert_array_equal(x, y)",
            "",
            "    def test_rational_expr(self):",
            "        func = NumExpr((E.a + 2.0 * E.b) / (1 + E.a + 4 * E.b * E.b))",
            "        a = arange(1e6)",
            "        b = arange(1e6) * 0.1",
            "        x = (a + 2 * b) / (1 + a + 4 * b * b)",
            "        y = func(a, b)",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_reductions(self):",
            "        # Check that they compile OK.",
            "        assert_equal(disassemble(",
            "            NumExpr(\"sum(x**2+2, axis=None)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'sum_ddn', b'r0', b't3', None)])",
            "        assert_equal(disassemble(",
            "            NumExpr(\"sum(x**2+2, axis=1)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'sum_ddn', b'r0', b't3', 1)])",
            "        assert_equal(disassemble(",
            "            NumExpr(\"prod(x**2+2, axis=2)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'prod_ddn', b'r0', b't3', 2)])",
            "        # Check that full reductions work.",
            "        x = zeros(100000) + .01  # checks issue #41",
            "        assert_allclose(evaluate(\"sum(x+2,axis=None)\"), sum(x + 2, axis=None))",
            "        assert_allclose(evaluate(\"sum(x+2,axis=0)\"), sum(x + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x,axis=0)\"), prod(x, axis=0))",
            "        assert_allclose(evaluate(\"min(x)\"), np.min(x))",
            "        assert_allclose(evaluate(\"max(x,axis=0)\"), np.max(x, axis=0))",
            "",
            "        # Fix for #277, array with leading singleton dimension",
            "        x = np.arange(10).reshape(1,10)",
            "        assert_allclose(evaluate(\"sum(x,axis=None)\"), sum(x, axis=None) )",
            "        assert_allclose(evaluate(\"sum(x,axis=0)\"), sum(x, axis=0) )",
            "        assert_allclose(evaluate(\"sum(x,axis=1)\"), sum(x, axis=1) )",
            "",
            "        x = arange(10.0)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "",
            "        x = arange(100.0)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"min(x-1,axis=0)\"), np.min(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"max(x-1,axis=0)\"), np.max(x - 1, axis=0))",
            "        x = linspace(0.1, 1.0, 2000)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"min(x-1,axis=0)\"), np.min(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"max(x-1,axis=0)\"), np.max(x - 1, axis=0))",
            "",
            "        # Check that reductions along an axis work",
            "        y = arange(9.0).reshape(3, 3)",
            "        assert_allclose(evaluate(\"sum(y**2, axis=1)\"), sum(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"sum(y**2, axis=0)\"), sum(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"sum(y**2, axis=None)\"), sum(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=1)\"), prod(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=0)\"), prod(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=None)\"), prod(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"min(y**2, axis=1)\"), np.min(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"min(y**2, axis=0)\"), np.min(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"min(y**2, axis=None)\"), np.min(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"max(y**2, axis=1)\"), np.max(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"max(y**2, axis=0)\"), np.max(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"max(y**2, axis=None)\"), np.max(y ** 2, axis=None))",
            "        # Check integers",
            "        x = arange(10.)",
            "        x = x.astype(int)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "        # Check longs",
            "        x = x.astype(int)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "        # Check complex",
            "        x = x + .1j",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "",
            "    def test_in_place(self):",
            "        x = arange(10000.).reshape(1000, 10)",
            "        evaluate(\"x + 3\", out=x)",
            "        assert_equal(x, arange(10000.).reshape(1000, 10) + 3)",
            "        y = arange(10)",
            "        evaluate(\"(x - 3) * y + (x - 3)\", out=x)",
            "        assert_equal(x, arange(10000.).reshape(1000, 10) * (arange(10) + 1))",
            "",
            "    def test_axis(self):",
            "        y = arange(9.0).reshape(3, 3)",
            "        try:",
            "            evaluate(\"sum(y, axis=2)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "        try:",
            "            evaluate(\"sum(y, axis=-3)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "        try:",
            "            # Negative axis are not supported",
            "            evaluate(\"sum(y, axis=-1)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "",
            "    def test_r0_reuse(self):",
            "        assert_equal(disassemble(NumExpr(\"x * x + 2\", [('x', double)])),",
            "                     [(b'mul_ddd', b'r0', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b'r0', b'r0', b'c2[2.0]')])",
            "",
            "    def test_str_contains_basic0(self):",
            "        res = evaluate('contains(b\"abc\", b\"ab\")')",
            "        assert_equal(res, True)",
            "",
            "    def test_str_contains_basic1(self):",
            "        haystack = array([b'abc', b'def', b'xyz', b'x11', b'za'])",
            "        res = evaluate('contains(haystack, b\"ab\")')",
            "        assert_equal(res, [True, False, False, False, False])",
            "",
            "    def test_str_contains_basic2(self):",
            "        haystack = array([b'abc', b'def', b'xyz', b'x11', b'za'])",
            "        res = evaluate('contains(b\"abcd\", haystack)')",
            "        assert_equal(res, [True, False, False, False, False])",
            "",
            "    def test_str_contains_basic3(self):",
            "        haystacks = array(",
            "            [b'abckkk', b'adef', b'xyz', b'x11abcp', b'za', b'abc'])",
            "        needles = array(",
            "            [b'abc', b'def', b'aterr', b'oot', b'zu', b'ab'])",
            "        res = evaluate('contains(haystacks, needles)')",
            "        assert_equal(res, [True, True, False, False, False, True])",
            "",
            "    def test_str_contains_basic4(self):",
            "        needles = array(",
            "            [b'abc', b'def', b'aterr', b'oot', b'zu', b'ab c', b' abc',",
            "             b'abc '])",
            "        res = evaluate('contains(b\"test abc here\", needles)')",
            "        assert_equal(res, [True, False, False, False, False, False, True, True])",
            "",
            "    def test_str_contains_basic5(self):",
            "        needles = array(",
            "            [b'abc', b'ab c', b' abc', b' abc ', b'\\tabc', b'c h'])",
            "        res = evaluate('contains(b\"test abc here\", needles)')",
            "        assert_equal(res, [True, False, True, True, False, True])",
            "",
            "        # Compare operation of Python 'in' operator with 'contains' using a",
            "        # product of two lists of strings.",
            "",
            "    def test_str_contains_listproduct(self):",
            "        from itertools import product",
            "",
            "        small = [",
            "            'It w', 'as th', 'e Whit', 'e Rab', 'bit,', ' tro', 'tting',",
            "            ' sl', 'owly', ' back ', 'again,', ' and', ' lo', 'okin', 'g a',",
            "            'nxious', 'ly a', 'bou', 't a', 's it w', 'ent,', ' as i', 'f it',",
            "            ' had l', 'ost', ' some', 'thi', 'ng; a', 'nd ', 'she ', 'heard ',",
            "            'it mut', 'terin', 'g to ', 'its', 'elf ', \"'The\",",
            "            ' Duch', 'ess! T', 'he ', 'Duches', 's! Oh ', 'my dea', 'r paws',",
            "            '! Oh ', 'my f', 'ur ', 'and ', 'whiske', 'rs! ', 'She', \"'ll g\",",
            "            'et me', ' ex', 'ecu', 'ted, ', 'as su', 're a', 's f', 'errets',",
            "            ' are f', 'errets', '! Wh', 'ere ', 'CAN', ' I hav', 'e d',",
            "            'roppe', 'd t', 'hem,', ' I wo', 'nder?', \"' A\", 'lice',",
            "            ' gu', 'essed', ' in a', ' mom', 'ent ', 'tha', 't it w', 'as ',",
            "            'looki', 'ng f', 'or ', 'the fa', 'n and ', 'the', ' pai',",
            "            'r of w', 'hit', 'e kid', ' glo', 'ves', ', and ', 'she ',",
            "            'very g', 'ood', '-na', 'turedl', 'y be', 'gan h', 'unt', 'ing',",
            "            ' about', ' for t', 'hem', ', but', ' they ', 'wer', 'e nowh',",
            "            'ere to', ' be', ' se', 'en--', 'ever', 'ythin', 'g seem', 'ed ',",
            "            'to ', 'have c', 'hang', 'ed ', 'since', ' he', 'r swim', ' in',",
            "            ' the', ' pool,', ' and', ' the g', 'reat ', 'hal', 'l, w', 'ith',",
            "            ' th', 'e gl', 'ass t', 'abl', 'e and ', 'the', ' li', 'ttle',",
            "            ' doo', 'r, ha', 'd v', 'ani', 'shed c', 'omp', 'lete', 'ly.']",
            "        big = [",
            "            'It wa', 's the', ' W', 'hit', 'e ', 'Ra', 'bb', 'it, t', 'ro',",
            "            'tting s', 'lowly', ' back ', 'agai', 'n, and', ' l', 'ookin',",
            "            'g ', 'an', 'xiously', ' about ', 'as it w', 'ent, as', ' if ',",
            "            'it had', ' los', 't ', 'so', 'mething', '; and', ' she h',",
            "            'eard ', 'it ', 'mutteri', 'ng to', ' itself', \" 'The \",",
            "            'Duchess', '! ', 'Th', 'e ', 'Duchess', '! Oh m', 'y de',",
            "            'ar paws', '! ', 'Oh my ', 'fu', 'r and w', 'hiskers', \"! She'\",",
            "            'll ', 'get', ' me ', 'execute', 'd,', ' a', 's ', 'su', 're as ',",
            "            'fe', 'rrets', ' are f', 'errets!', ' Wher', 'e CAN', ' I ha',",
            "            've dro', 'pped t', 'hem', ', I ', 'won', \"der?' A\",",
            "            'lice g', 'uess', 'ed ', 'in a m', 'omen', 't that', ' i',",
            "            't was l', 'ook', 'ing f', 'or th', 'e ', 'fan and', ' th', 'e p',",
            "            'air o', 'f whit', 'e ki', 'd glove', 's, and ', 'she v', 'ery ',",
            "            'good-na', 'tu', 'redl', 'y be', 'gan hun', 'ti', 'ng abou',",
            "            't for t', 'he', 'm, bu', 't t', 'hey ', 'were n', 'owhere',",
            "            ' to b', 'e s', 'een-', '-eve', 'rythi', 'ng see', 'me', 'd ',",
            "            'to ha', 've', ' c', 'hanged', ' sinc', 'e her s', 'wim ',",
            "            'in the ', 'pool,', ' an', 'd the g', 'rea', 't h', 'all, wi',",
            "            'th the ', 'glas', 's t', 'able an', 'd th', 'e littl', 'e door,',",
            "            ' had va', 'ni', 'shed co', 'mpletel', 'y.']",
            "        p = list(product(small, big))",
            "        python_in = [x[0] in x[1] for x in p]",
            "        a = [x[0].encode() for x in p]",
            "        b = [x[1].encode() for x in p]",
            "        res = [bool(x) for x in evaluate('contains(b, a)')]",
            "        assert_equal(res, python_in)",
            "",
            "    def test_str_contains_withemptystr1(self):",
            "        withemptystr = array([b'abc', b'def', b''])",
            "        res = evaluate('contains(b\"abcd\", withemptystr)')",
            "        assert_equal(res, [True, False, True])",
            "",
            "    def test_str_contains_withemptystr2(self):",
            "        withemptystr = array([b'abc', b'def', b''])",
            "        res = evaluate('contains(withemptystr, b\"\")')",
            "        assert_equal(res, [True, True, True])",
            "",
            "    def test_str_contains_long_needle(self):",
            "        a = b'1' + b'a' * 40",
            "        b = b'a' * 40",
            "        res = evaluate('contains(a, b)')",
            "        assert_equal(res, True)",
            "        ",
            "    def test_where_scalar_bool(self):",
            "        a = True",
            "        b = array([1, 2])",
            "        c = array([3, 4])",
            "        res = evaluate('where(a, b, c)')",
            "        assert_array_equal(res, b)",
            "        a = False",
            "        res = evaluate('where(a, b, c)')",
            "        assert_array_equal(res, c)",
            "",
            "    ",
            "    def test_refcount(self):",
            "        # Regression test for issue #310",
            "        a = array([1])",
            "        assert sys.getrefcount(a) == 2",
            "        evaluate('1')",
            "        assert sys.getrefcount(a) == 2",
            "",
            "    def test_locals_clears_globals(self):",
            "        # Check for issue #313, whereby clearing f_locals also clear f_globals",
            "        # if in the top-frame. This cannot be done inside `unittest` as it is always ",
            "        # executing code in a child frame.",
            "        script = r';'.join([",
            "                r\"import numexpr as ne\",",
            "                r\"a=10\",",
            "                r\"ne.evaluate('1')\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('2', local_dict={})\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('3', global_dict={})\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('4', local_dict={}, global_dict={})\",",
            "                r\"a += 1\",",
            "            ])",
            "        # Raises CalledProcessError on a non-normal exit",
            "        check = subprocess.check_call([sys.executable, '-c', script])",
            "        # Ideally this test should also be done against ipython but it's not ",
            "        # a requirement.",
            "",
            "",
            "",
            "class test_numexpr2(test_numexpr):",
            "    \"\"\"Testing with 2 threads\"\"\"",
            "    nthreads = 2",
            "",
            "",
            "class test_evaluate(TestCase):",
            "    def test_simple(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        x = evaluate(\"2*a + 3*b*c\")",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_simple_expr_small_array(self):",
            "        x = arange(100.0)",
            "        y = evaluate(\"x\")",
            "        assert_array_equal(x, y)",
            "",
            "    def test_simple_expr(self):",
            "        x = arange(1e6)",
            "        y = evaluate(\"x\")",
            "        assert_array_equal(x, y)",
            "",
            "    def test_re_evaluate(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        x = evaluate(\"2*a + 3*b*c\")",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_re_evaluate_dict(self):",
            "        a1 = array([1., 2., 3.])",
            "        b1 = array([4., 5., 6.])",
            "        c1 = array([7., 8., 9.])",
            "        x = evaluate(\"2*a + 3*b*c\", local_dict={'a': a1, 'b': b1, 'c': c1})",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_validate(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        retval = validate(\"2*a + 3*b*c\")",
            "        assert(retval is None)",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_validate_missing_var(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        retval = validate(\"2*a + 3*b*c\")",
            "        assert(isinstance(retval, KeyError))",
            "",
            "    def test_validate_syntax(self):",
            "        retval = validate(\"2+\")",
            "        assert(isinstance(retval, SyntaxError))",
            "",
            "    def test_validate_dict(self):",
            "        a1 = array([1., 2., 3.])",
            "        b1 = array([4., 5., 6.])",
            "        c1 = array([7., 8., 9.])",
            "        retval = validate(\"2*a + 3*b*c\", local_dict={'a': a1, 'b': b1, 'c': c1})",
            "        assert(retval is None)",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    # Test for issue #22",
            "    def test_true_div(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x/2\"), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv=False), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv='auto'), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv=True), x / 2.0)",
            "",
            "    def test_left_shift(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x<<2\"), x << 2)",
            "",
            "    def test_right_shift(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x>>2\"), x >> 2)",
            "",
            "    # PyTables uses __nonzero__ among ExpressionNode objects internally",
            "    # so this should be commented out for the moment.  See #24.",
            "    def test_boolean_operator(self):",
            "        x = arange(10, dtype='i4')",
            "        try:",
            "            evaluate(\"(x > 1) and (x < 9)\")",
            "        except TypeError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "",
            "    def test_rational_expr(self):",
            "        a = arange(1e6)",
            "        b = arange(1e6) * 0.1",
            "        x = (a + 2 * b) / (1 + a + 4 * b * b)",
            "        y = evaluate(\"(a + 2*b) / (1 + a + 4*b*b)\")",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_complex_expr(self):",
            "        def complex(a, b):",
            "            c = zeros(a.shape, dtype=complex_)",
            "            c.real = a",
            "            c.imag = b",
            "            return c",
            "",
            "        a = arange(1e4)",
            "        b = arange(1e4) ** 1e-5",
            "        z = a + 1j * b",
            "        x = z.imag",
            "        x = sin(complex(a, b)).real + z.imag",
            "        y = evaluate(\"sin(complex(a, b)).real + z.imag\")",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_complex_strides(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        b = arange(50).reshape(5, 10)",
            "        assert_array_equal(evaluate(\"a+b\"), a + b)",
            "        c = empty([10], dtype=[('c1', int32), ('c2', uint16)])",
            "        c['c1'] = arange(10)",
            "        c['c2'].fill(0xaaaa)",
            "        c1 = c['c1']",
            "        a0 = a[0]",
            "        assert_array_equal(evaluate(\"c1\"), c1)",
            "        assert_array_equal(evaluate(\"a0+c1\"), a0 + c1)",
            "",
            "    def test_recarray_strides(self):",
            "        a = arange(100)",
            "        b = arange(100,200)",
            "        recarr = np.rec.array(None, formats='f4,f4', shape=(100,))",
            "        recarr['f0'] = a",
            "        recarr['f1'] = b",
            "        c = recarr['f1']",
            "        assert_array_almost_equal(evaluate(\"sqrt(c) > 1.\"), sqrt(c) > 1.)",
            "        assert_array_almost_equal(evaluate(\"log10(c)\"), log10(c))",
            "",
            "    def test_broadcasting(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        c = arange(10)",
            "        d = arange(5).reshape(5, 1)",
            "        assert_array_equal(evaluate(\"a+c\"), a + c)",
            "        assert_array_equal(evaluate(\"a+d\"), a + d)",
            "        expr = NumExpr(\"2.0*a+3.0*c\", [('a', double), ('c', double)])",
            "        assert_array_equal(expr(a, c), 2.0 * a + 3.0 * c)",
            "",
            "    def test_all_scalar(self):",
            "        a = 3.",
            "        b = 4.",
            "        assert_allclose(evaluate(\"a+b\"), a + b)",
            "        expr = NumExpr(\"2*a+3*b\", [('a', double), ('b', double)])",
            "        assert_equal(expr(a, b), 2 * a + 3 * b)",
            "",
            "    def test_run(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        b = arange(10)",
            "        expr = NumExpr(\"2*a+3*b\", [('a', double), ('b', double)])",
            "        assert_array_equal(expr(a, b), expr.run(a, b))",
            "",
            "    def test_illegal_value(self):",
            "        a = arange(3)",
            "        try:",
            "            evaluate(\"a < [0, 0, 0]\")",
            "        except TypeError:",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "    def test_disassemble(self):",
            "        assert_equal(disassemble(NumExpr(",
            "            \"where(m, a, -1)\", [('m', bool), ('a', float)])),",
            "            [[b'where_fbff', b'r0', b'r1[m]', b'r2[a]', b'c3[-1.0]'], ",
            "             [b'noop', None, None, None]])",
            "",
            "    def test_constant_deduplication(self):",
            "        assert_equal(NumExpr(\"(a + 1)*(a - 1)\", [('a', np.int32)]).constants, (1,))",
            "",
            "    def test_nan_constant(self):",
            "        assert_equal(str(ConstantNode(float(\"nan\")).value), 'nan')",
            "",
            "        # check de-duplication works for nan",
            "        _nan = ConstantNode(float(\"nan\"))",
            "        expr = (E.a + _nan)*(E.b + _nan)",
            "        assert_equal(NumExpr(expr, [('a', double), ('b', double)]).constants, (float(\"nan\"),))",
            "",
            "",
            "    def test_f32_constant(self):",
            "        assert_equal(ConstantNode(numpy.float32(1)).astKind, \"float\")",
            "        assert_equal(ConstantNode(numpy.float32(\"nan\")).astKind, \"float\")",
            "        assert_equal(ConstantNode(numpy.float32(3)).value.dtype, numpy.dtype(\"float32\"))",
            "        assert_array_equal(NumExpr(ConstantNode(numpy.float32(1))).run(), ",
            "                           numpy.array(1, dtype=\"float32\"))",
            "",
            "    def test_unaligned_singleton(self):",
            "        # Test for issue #397 whether singletons outputs assigned to consts must be ",
            "        # aligned or not.",
            "        a = np.empty(5, dtype=np.uint8)[1:].view(np.int32)",
            "        evaluate('3', out=a)",
            "        assert_equal(a, 3)",
            "",
            "    def test_negative_mod(self):",
            "        # Test for issue #413, modulus of negative integers. C modulus is ",
            "        # actually remainder op, and hence different from Python modulus.",
            "        a = np.array([-500, -135, 0, 0, 135, 500], dtype=np.int32)",
            "        n = np.array([-360, -360, -360, 360, 360, 360], dtype=np.int32)",
            "        out_i = evaluate('a % n')",
            "        assert_equal(out_i, np.mod(a, n))",
            "",
            "        b = a.astype(np.int64)",
            "        m = n.astype(np.int64)",
            "        out_l = evaluate('b % m')",
            "        assert_equal(out_l, np.mod(b, m))",
            "",
            "    def test_negative_power_scalar(self):",
            "        # Test for issue #428, where the power is negative and the base is an",
            "        # integer. This was running afoul in the precomputation in `expressions.py:pow_op()`",
            "        base = np.array([-2, -1, 0, 1, 2, 3], dtype=np.int32)",
            "        out_i = evaluate('base ** -1.0')",
            "        assert_equal(out_i, np.power(base, -1.0))",
            "",
            "        base = np.array([-2, -1, 0, 1, 2, 3], dtype=np.int64)",
            "        out_l = evaluate('base ** -1.0')",
            "        assert_equal(out_l, np.power(base, -1.0))",
            "",
            "",
            "    def test_ex_uses_vml(self):",
            "        vml_funcs = [ \"sin\", \"cos\", \"tan\", \"arcsin\", \"arccos\", \"arctan\",",
            "                      \"sinh\", \"cosh\", \"tanh\", \"arcsinh\", \"arccosh\", \"arctanh\",",
            "                      \"log\", \"log1p\",\"log10\", \"exp\", \"expm1\", \"abs\", \"conj\",",
            "                      \"arctan2\", \"fmod\"]",
            "        for func in vml_funcs:",
            "            strexpr = func+'(a)'",
            "            _, ex_uses_vml = numexpr.necompiler.getExprNames(strexpr, {})",
            "            assert_equal(ex_uses_vml, use_vml, strexpr)",
            "",
            "    if 'sparc' not in platform.machine():",
            "        # Execution order set here so as to not use too many threads",
            "        # during the rest of the execution.  See #33 for details.",
            "        def test_changing_nthreads_00_inc(self):",
            "            a = linspace(-1, 1, 1000000)",
            "            b = ((.25 * a + .75) * a - 1.5) * a - 2",
            "            for nthreads in range(1, 7):",
            "                numexpr.set_num_threads(nthreads)",
            "                c = evaluate(\"((.25*a + .75)*a - 1.5)*a - 2\")",
            "                assert_array_almost_equal(b, c)",
            "",
            "        def test_changing_nthreads_01_dec(self):",
            "            a = linspace(-1, 1, 1000000)",
            "            b = ((.25 * a + .75) * a - 1.5) * a - 2",
            "            for nthreads in range(6, 1, -1):",
            "                numexpr.set_num_threads(nthreads)",
            "                c = evaluate(\"((.25*a + .75)*a - 1.5)*a - 2\")",
            "                assert_array_almost_equal(b, c)",
            "",
            "",
            "tests = [",
            "    ('MISC', ['b*c+d*e',",
            "              '2*a+3*b',",
            "              '-a',",
            "              'sinh(a)',",
            "              '2*a + (cos(3)+5)*sinh(cos(b))',",
            "              '2*a + arctan2(a, b)',",
            "              'arcsin(0.5)',",
            "              'where(a != 0.0, 2, a)',",
            "              'where(a > 10, b < a, b > a)',",
            "              'where((a-10).real != 0.0, a, 2)',",
            "              '0.25 * (a < 5) + 0.33 * (a >= 5)',",
            "              'cos(1+1)',",
            "              '1+1',",
            "              '1',",
            "              'cos(a2)',",
            "    ])]",
            "",
            "optests = []",
            "for op in list('+-*/%') + ['**']:",
            "    optests.append(\"(a+1) %s (b+3)\" % op)",
            "    optests.append(\"3 %s (b+3)\" % op)",
            "    optests.append(\"(a+1) %s 4\" % op)",
            "    optests.append(\"2 %s (b+3)\" % op)",
            "    optests.append(\"(a+1) %s 2\" % op)",
            "    optests.append(\"(a+1) %s -1\" % op)",
            "    optests.append(\"(a+1) %s 0.5\" % op)",
            "    # Check divisions and modulus by zero (see ticket #107)",
            "    optests.append(\"(a+1) %s 0\" % op)",
            "tests.append(('OPERATIONS', optests))",
            "",
            "cmptests = []",
            "for op in ['<', '<=', '==', '>=', '>', '!=']:",
            "    cmptests.append(\"a/2+5 %s b\" % op)",
            "    cmptests.append(\"a/2+5 %s 7\" % op)",
            "    cmptests.append(\"7 %s b\" % op)",
            "    cmptests.append(\"7.0 %s 5\" % op)",
            "tests.append(('COMPARISONS', cmptests))",
            "",
            "func1tests = []",
            "for func in ['copy', 'ones_like', 'sqrt',",
            "             'sin', 'cos', 'tan', 'arcsin', 'arccos', 'arctan',",
            "             'sinh', 'cosh', 'tanh', 'arcsinh', 'arccosh', 'arctanh',",
            "             'log', 'log1p', 'log10', 'exp', 'expm1', 'abs', 'conj',",
            "             'ceil', 'floor']:",
            "    func1tests.append(\"a + %s(b+c)\" % func)",
            "tests.append(('1_ARG_FUNCS', func1tests))",
            "",
            "func2tests = []",
            "for func in ['arctan2', 'fmod']:",
            "    func2tests.append(\"a + %s(b+c, d+1)\" % func)",
            "    func2tests.append(\"a + %s(b+c, 1)\" % func)",
            "    func2tests.append(\"a + %s(1, d+1)\" % func)",
            "tests.append(('2_ARG_FUNCS', func2tests))",
            "",
            "powtests = []",
            "# n = -1, 0.5, 2, 4 already handled in section \"OPERATIONS\"",
            "for n in (-7, -2.5, -1.5, -1.3, -.5, 0, 0.0, 1, 2.3, 2.5, 3):",
            "    powtests.append(\"(a+1)**%s\" % n)",
            "tests.append(('POW_TESTS', powtests))",
            "",
            "",
            "def equal(a, b, exact):",
            "    if array_equal(a, b):",
            "        return True",
            "",
            "    if hasattr(a, 'dtype') and a.dtype in ['f4', 'f8']:",
            "        nnans = isnan(a).sum()",
            "        if nnans > 0:",
            "            # For results containing NaNs, just check that the number",
            "            # of NaNs is the same in both arrays.  This check could be",
            "            # made more exhaustive, but checking element by element in",
            "            # python space is very expensive in general.",
            "            return nnans == isnan(b).sum()",
            "        ninfs = isinf(a).sum()",
            "        if ninfs > 0:",
            "            # Ditto for Inf's",
            "            return ninfs == isinf(b).sum()",
            "    if exact:",
            "        return (shape(a) == shape(b)) and alltrue(ravel(a) == ravel(b), axis=0)",
            "    else:",
            "        if hasattr(a, 'dtype') and a.dtype == 'f4':",
            "            atol = 1e-5  # Relax precision for special opcodes, like fmod",
            "        else:",
            "            atol = 1e-8",
            "        return (shape(a) == shape(b) and",
            "                allclose(ravel(a), ravel(b), atol=atol))",
            "",
            "",
            "class Skip(Exception): pass",
            "",
            "",
            "def test_expressions():",
            "    test_no = [0]",
            "",
            "    def make_test_method(a, a2, b, c, d, e, x, expr,",
            "                         test_scalar, dtype, optimization, exact, section):",
            "        this_locals = locals()",
            "",
            "        def method():",
            "            try:",
            "                # We don't want to listen at RuntimeWarnings like",
            "                # \"overflows\" or \"divide by zero\" in plain eval().",
            "                warnings.simplefilter(\"ignore\")",
            "                npval = eval(expr, globals(), this_locals)",
            "                warnings.simplefilter(\"always\")",
            "                npval = eval(expr, globals(), this_locals)",
            "            except Exception as ex:",
            "                # just store the exception in a variable",
            "                # compatibility with numpy v1.12",
            "                # see also https://github.com/pydata/numexpr/issues/239",
            "                np_exception = ex",
            "                npval = None",
            "            else:",
            "                np_exception = None",
            "",
            "            try:",
            "                neval = evaluate(expr, local_dict=this_locals,",
            "                                 optimization=optimization)",
            "            except AssertionError:",
            "                raise",
            "            except NotImplementedError:",
            "                print('%r not implemented for %s (scalar=%d, opt=%s)'",
            "                      % (expr, dtype.__name__, test_scalar, optimization))",
            "            except Exception as ne_exception:",
            "                same_exc_type = issubclass(type(ne_exception),",
            "                                           type(np_exception))",
            "                if np_exception is None or not same_exc_type:",
            "                    print('numexpr error for expression %r' % (expr,))",
            "                    raise",
            "            except:",
            "                print('numexpr error for expression %r' % (expr,))",
            "                raise",
            "            else:",
            "                msg = ('expected numexpr error not raised for expression '",
            "                       '%r' % (expr,))",
            "                assert np_exception is None, msg",
            "",
            "                assert equal(npval, neval, exact), \"\"\"%r",
            "(test_scalar=%r, dtype=%r, optimization=%r, exact=%r,",
            " npval=%r (%r - %r)\\n neval=%r (%r - %r))\"\"\" % (expr, test_scalar, dtype.__name__,",
            "                                                optimization, exact,",
            "                                                npval, type(npval), shape(npval),",
            "                                                neval, type(neval), shape(neval))",
            "",
            "        method.description = ('test_expressions(%s, test_scalar=%r, '",
            "                              'dtype=%r, optimization=%r, exact=%r)') % (expr, test_scalar, dtype.__name__, optimization, exact)",
            "        test_no[0] += 1",
            "        method.__name__ = 'test_scalar%d_%s_%s_%s_%04d' % (test_scalar,",
            "                                                           dtype.__name__,",
            "                                                           optimization.encode('ascii'),",
            "                                                           section.encode('ascii'),",
            "                                                           test_no[0])",
            "        return method",
            "",
            "    x = None",
            "    for test_scalar in (0, 1, 2):",
            "        for dtype in (int, int, np.float32, double, complex):",
            "            array_size = 100",
            "            a = arange(2 * array_size, dtype=dtype)[::2]",
            "            a2 = zeros([array_size, array_size], dtype=dtype)",
            "            b = arange(array_size, dtype=dtype) / array_size",
            "            c = arange(array_size, dtype=dtype)",
            "            d = arange(array_size, dtype=dtype)",
            "            e = arange(array_size, dtype=dtype)",
            "            if dtype == complex:",
            "                a = a.real",
            "                for x in [a2, b, c, d, e]:",
            "                    x += 1j",
            "                    x *= 1 + 1j",
            "            if test_scalar == 1:",
            "                a = a[array_size // 2]",
            "            if test_scalar == 2:",
            "                b = b[array_size // 2]",
            "            for optimization, exact in [",
            "                ('none', False), ('moderate', False), ('aggressive', False)]:",
            "                for section_name, section_tests in tests:",
            "                    for expr in section_tests:",
            "                        if (dtype == complex and",
            "                            ('<' in expr or '>' in expr or '%' in expr",
            "                             or \"arctan2\" in expr or \"fmod\" in expr",
            "                             or \"floor\" in expr or \"ceil\" in expr)):",
            "                            # skip complex comparisons or functions not",
            "                            # defined in complex domain.",
            "                            continue",
            "                        if (dtype in (int, int) and test_scalar and",
            "                                    expr == '(a+1) ** -1'):",
            "                            continue",
            "",
            "                        m = make_test_method(a, a2, b, c, d, e, x,",
            "                                             expr, test_scalar, dtype,",
            "                                             optimization, exact,",
            "                                             section_name)",
            "                        yield m",
            "",
            "",
            "class test_int64(TestCase):",
            "    def test_neg(self):",
            "        a = array([2 ** 31 - 1, 2 ** 31, 2 ** 32, 2 ** 63 - 1], dtype=int64)",
            "        res = evaluate('-a')",
            "        assert_array_equal(res, [1 - 2 ** 31, -(2 ** 31), -(2 ** 32), 1 - 2 ** 63])",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "",
            "class test_int32_int64(TestCase):",
            "",
            "    def test_small_int(self):",
            "        # Small ints (32-bit ones) should not be promoted to longs.",
            "        res = evaluate('2')",
            "        assert_array_equal(res, 2)",
            "        self.assertEqual(res.dtype.name, 'int32')",
            "",
            "    def test_big_int(self):",
            "        # Big ints should be promoted to longs.",
            "        res = evaluate('2**40')",
            "        assert_array_equal(res, 2 ** 40)",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "    def test_long_constant_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        itwo = np.int32(2)",
            "        ltwo = np.int64(2)",
            "        res = int32array * 2",
            "        res32 = evaluate('int32array * itwo')",
            "        res64 = evaluate('int32array * ltwo')",
            "        assert_array_equal(res, res32)",
            "        assert_array_equal(res, res64)",
            "        self.assertEqual(res32.dtype.name, 'int32')",
            "        self.assertEqual(res64.dtype.name, 'int64')",
            "",
            "    def test_int64_array_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        int64array = arange(100, dtype='int64')",
            "        respy = int32array * int64array",
            "        resnx = evaluate('int32array * int64array')",
            "        assert_array_equal(respy, resnx)",
            "        self.assertEqual(resnx.dtype.name, 'int64')",
            "",
            "",
            "class test_uint32_int64(TestCase):",
            "    def test_small_uint32(self):",
            "        # Small uint32 should not be downgraded to ints.",
            "        a = np.uint32(42)",
            "        res = evaluate('a')",
            "        assert_array_equal(res, 42)",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "    def test_uint32_constant_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        stwo = np.int32(2)",
            "        utwo = np.uint32(2)",
            "        res = int32array * utwo",
            "        res32 = evaluate('int32array * stwo')",
            "        res64 = evaluate('int32array * utwo')",
            "        assert_array_equal(res, res32)",
            "        assert_array_equal(res, res64)",
            "        self.assertEqual(res32.dtype.name, 'int32')",
            "        self.assertEqual(res64.dtype.name, 'int64')",
            "",
            "    def test_int64_array_promotion(self):",
            "        uint32array = arange(100, dtype='uint32')",
            "        int64array = arange(100, dtype='int64')",
            "        respy = uint32array * int64array",
            "        resnx = evaluate('uint32array * int64array')",
            "        assert_array_equal(respy, resnx)",
            "        self.assertEqual(resnx.dtype.name, 'int64')",
            "",
            "",
            "class test_strings(TestCase):",
            "    BLOCK_SIZE1 = 128",
            "    BLOCK_SIZE2 = 8",
            "    str_list1 = [b'foo', b'bar', b'', b'  ']",
            "    str_list2 = [b'foo', b'', b'x', b' ']",
            "    str_nloops = len(str_list1) * (BLOCK_SIZE1 + BLOCK_SIZE2 + 1)",
            "    str_array1 = array(str_list1 * str_nloops)",
            "    str_array2 = array(str_list2 * str_nloops)",
            "    str_constant = b'doodoo'",
            "",
            "    def test_null_chars(self):",
            "        str_list = [",
            "            b'\\0\\0\\0', b'\\0\\0foo\\0', b'\\0\\0foo\\0b', b'\\0\\0foo\\0b\\0',",
            "            b'foo\\0', b'foo\\0b', b'foo\\0b\\0', b'foo\\0bar\\0baz\\0\\0']",
            "        for s in str_list:",
            "            r = evaluate('s')",
            "            self.assertEqual(s, r.tobytes())  # check *all* stored data",
            "",
            "    def test_compare_copy(self):",
            "        sarr = self.str_array1",
            "        expr = 'sarr'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_array(self):",
            "        sarr1 = self.str_array1",
            "        sarr2 = self.str_array2",
            "        expr = 'sarr1 >= sarr2'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_variable(self):",
            "        sarr = self.str_array1",
            "        svar = self.str_constant",
            "        expr = 'sarr >= svar'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_constant(self):",
            "        sarr = self.str_array1",
            "        expr = 'sarr >= %r' % self.str_constant",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_add_string_array(self):",
            "        sarr1 = self.str_array1",
            "        sarr2 = self.str_array2",
            "        expr = 'sarr1 + sarr2'",
            "        self.assert_missing_op('add_sss', expr, locals())",
            "",
            "    def test_empty_string1(self):",
            "        a = np.array([b\"\", b\"pepe\"])",
            "        b = np.array([b\"pepe2\", b\"\"])",
            "        res = evaluate(\"(a == b'') & (b == b'pepe2')\")",
            "        assert_array_equal(res, np.array([True, False]))",
            "        res2 = evaluate(\"(a == b'pepe') & (b == b'')\")",
            "        assert_array_equal(res2, np.array([False, True]))",
            "",
            "    def test_empty_string2(self):",
            "        a = np.array([b\"p\", b\"pepe\"])",
            "        b = np.array([b\"pepe2\", b\"\"])",
            "        res = evaluate(\"(a == b'') & (b == b'pepe2')\")",
            "        assert_array_equal(res, np.array([False, False]))",
            "        res2 = evaluate(\"(a == b'pepe') & (b == b'')\")",
            "        assert_array_equal(res, np.array([False, False]))",
            "",
            "    def test_add_numeric_array(self):",
            "        sarr = self.str_array1",
            "        narr = arange(len(sarr), dtype='int32')",
            "        expr = 'sarr >= narr'",
            "        self.assert_missing_op('ge_bsi', expr, locals())",
            "",
            "    def assert_missing_op(self, op, expr, local_dict):",
            "        msg = \"expected NotImplementedError regarding '%s'\" % op",
            "        try:",
            "            evaluate(expr, local_dict)",
            "        except NotImplementedError as nie:",
            "            if \"'%s'\" % op not in nie.args[0]:",
            "                self.fail(msg)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def test_compare_prefix(self):",
            "        # Check comparing two strings where one is a prefix of the",
            "        # other.",
            "        for s1, s2 in [(b'foo', b'foobar'), (b'foo', b'foo\\0bar'),",
            "                       (b'foo\\0a', b'foo\\0bar')]:",
            "            self.assertTrue(evaluate('s1 < s2'))",
            "            self.assertTrue(evaluate('s1 <= s2'))",
            "            self.assertTrue(evaluate('~(s1 == s2)'))",
            "            self.assertTrue(evaluate('~(s1 >= s2)'))",
            "            self.assertTrue(evaluate('~(s1 > s2)'))",
            "",
            "        # Check for NumPy array-style semantics in string equality.",
            "        s1, s2 = b'foo', b'foo\\0\\0'",
            "        self.assertTrue(evaluate('s1 == s2'))",
            "",
            "",
            "# Case for testing selections in fields which are aligned but whose",
            "# data length is not an exact multiple of the length of the record.",
            "# The following test exposes the problem only in 32-bit machines,",
            "# because in 64-bit machines 'c2' is unaligned.  However, this should",
            "# check most platforms where, while not unaligned, 'len(datatype) >",
            "# boundary_alignment' is fullfilled.",
            "class test_irregular_stride(TestCase):",
            "    def test_select(self):",
            "        f0 = arange(10, dtype=int32)",
            "        f1 = arange(10, dtype=float64)",
            "",
            "        irregular = rec.fromarrays([f0, f1])",
            "",
            "        f0 = irregular['f0']",
            "        f1 = irregular['f1']",
            "",
            "        i0 = evaluate('f0 < 5')",
            "        i1 = evaluate('f1 < 5')",
            "",
            "        assert_array_equal(f0[i0], arange(5, dtype=int32))",
            "        assert_array_equal(f1[i1], arange(5, dtype=float64))",
            "",
            "",
            "# Cases for testing arrays with dimensions that can be zero.",
            "class test_zerodim(TestCase):",
            "    def test_zerodim1d(self):",
            "        a0 = array([], dtype=int32)",
            "        a1 = array([], dtype=float64)",
            "",
            "        r0 = evaluate('a0 + a1')",
            "        r1 = evaluate('a0 * a1')",
            "",
            "        assert_array_equal(r0, a1)",
            "        assert_array_equal(r1, a1)",
            "",
            "    def test_zerodim3d(self):",
            "        a0 = array([], dtype=int32).reshape(0, 2, 4)",
            "        a1 = array([], dtype=float64).reshape(0, 2, 4)",
            "",
            "        r0 = evaluate('a0 + a1')",
            "        r1 = evaluate('a0 * a1')",
            "",
            "        assert_array_equal(r0, a1)",
            "        assert_array_equal(r1, a1)",
            "",
            "",
            "@contextmanager",
            "def _environment(key, value):",
            "    old = os.environ.get(key)",
            "    os.environ[key] = value",
            "    try:",
            "        yield",
            "    finally:",
            "        if old:",
            "            os.environ[key] = old",
            "        else:",
            "            del os.environ[key]",
            "",
            "# Test cases for the threading configuration",
            "class test_threading_config(TestCase):",
            "    def test_max_threads_unset(self):",
            "        # Has to be done in a subprocess as `importlib.reload` doesn't let us ",
            "        # re-initialize the threadpool",
            "        script = '\\n'.join([",
            "                \"import os\",",
            "                \"if 'NUMEXPR_MAX_THREADS' in os.environ: os.environ.pop('NUMEXPR_MAX_THREADS')\",",
            "                \"if 'OMP_NUM_THREADS' in os.environ: os.environ.pop('OMP_NUM_THREADS')\",",
            "                \"import numexpr\",",
            "                \"assert(numexpr.nthreads <= 8)\",",
            "                \"exit(0)\"])",
            "        subprocess.check_call([sys.executable, '-c', script])",
            "",
            "    def test_max_threads_set(self):",
            "        # Has to be done in a subprocess as `importlib.reload` doesn't let us ",
            "        # re-initialize the threadpool",
            "        script = '\\n'.join([",
            "                \"import os\",",
            "                \"os.environ['NUMEXPR_MAX_THREADS'] = '4'\",",
            "                \"import numexpr\",",
            "                \"assert(numexpr.MAX_THREADS == 4)\",",
            "                \"exit(0)\"])",
            "        subprocess.check_call([sys.executable, '-c', script])",
            "",
            "    def test_numexpr_num_threads(self):",
            "        with _environment('OMP_NUM_THREADS', '5'):",
            "            # NUMEXPR_NUM_THREADS has priority",
            "            with _environment('NUMEXPR_NUM_THREADS', '3'):",
            "                 if 'sparc' in platform.machine():",
            "                     self.assertEqual(1, numexpr._init_num_threads())",
            "                 else:",
            "                     self.assertEqual(3, numexpr._init_num_threads())",
            "",
            "    def test_omp_num_threads(self):",
            "        with _environment('OMP_NUM_THREADS', '5'):",
            "            if 'sparc' in platform.machine():",
            "                self.assertEqual(1, numexpr._init_num_threads())",
            "            else:",
            "                self.assertEqual(5, numexpr._init_num_threads())",
            "",
            "    def test_vml_threads_round_trip(self):",
            "        n_threads = 3",
            "        if use_vml:",
            "            numexpr.utils.set_vml_num_threads(n_threads)",
            "            set_threads = numexpr.utils.get_vml_num_threads()",
            "            self.assertEqual(n_threads, set_threads)",
            "        else:",
            "            self.assertIsNone(numexpr.utils.set_vml_num_threads(n_threads))",
            "            self.assertIsNone(numexpr.utils.get_vml_num_threads())",
            "",
            "",
            "# Case test for threads",
            "class test_threading(TestCase):",
            "",
            "    def test_thread(self):",
            "        import threading",
            "",
            "        class ThreadTest(threading.Thread):",
            "            def run(self):",
            "                a = arange(3)",
            "                assert_array_equal(evaluate('a**3'), array([0, 1, 8]))",
            "",
            "        test = ThreadTest()",
            "        test.start()",
            "        test.join()",
            "",
            "    def test_multithread(self):",
            "        import threading",
            "",
            "        # Running evaluate() from multiple threads shouldn't crash",
            "        def work(n):",
            "            a = arange(n)",
            "            evaluate('a+a')",
            "",
            "        work(10)  # warm compilation cache",
            "",
            "        nthreads = 30",
            "        threads = [threading.Thread(target=work, args=(1e5,))",
            "                   for i in range(nthreads)]",
            "        for t in threads:",
            "            t.start()",
            "        for t in threads:",
            "            t.join()",
            "",
            "",
            "# The worker function for the subprocess (needs to be here because Windows",
            "# has problems pickling nested functions with the multiprocess module :-/)",
            "def _worker(qout=None):",
            "    ra = np.arange(1e3)",
            "    rows = evaluate('ra > 0')",
            "    #print \"Succeeded in evaluation!\\n\"",
            "    if qout is not None:",
            "        qout.put(\"Done\")",
            "",
            "",
            "# Case test for subprocesses (via multiprocessing module)",
            "class test_subprocess(TestCase):",
            "    def test_multiprocess(self):",
            "        try:",
            "            import multiprocessing as mp",
            "        except ImportError:",
            "            return",
            "        # Check for two threads at least",
            "        numexpr.set_num_threads(2)",
            "        #print \"**** Running from main process:\"",
            "        _worker()",
            "        #print \"**** Running from subprocess:\"",
            "        qout = mp.Queue()",
            "        ps = mp.Process(target=_worker, args=(qout,))",
            "        ps.daemon = True",
            "        ps.start()",
            "",
            "        result = qout.get()",
            "        #print result",
            "",
            "",
            "def print_versions():",
            "    \"\"\"Print the versions of software that numexpr relies on.\"\"\"",
            "    # from pkg_resources import parse_version",
            "    from numexpr.cpuinfo import cpu",
            "    import platform",
            "",
            "    print('-=' * 38)",
            "    print('Numexpr version:   %s' % numexpr.__version__)",
            "    print('NumPy version:     %s' % np.__version__)",
            "    print('Python version:    %s' % sys.version)",
            "    (sysname, nodename, release, os_version, machine, processor) = platform.uname()",
            "    print('Platform:          %s-%s-%s' % (sys.platform, machine, os_version))",
            "    try:",
            "        # cpuinfo doesn't work on OSX well it seems, so protect these outputs ",
            "        # with a try block",
            "        cpu_info = cpu.info[0]",
            "        print('CPU vendor:        %s' % cpu_info.get('VendorIdentifier', ''))",
            "        print('CPU model:         %s' % cpu_info.get('ProcessorNameString', ''))",
            "        print('CPU clock speed:   %s MHz' % cpu_info.get('~MHz',''))",
            "    except KeyError:",
            "        pass",
            "    print('VML available?     %s' % use_vml)",
            "    if use_vml:",
            "        print('VML/MKL version:   %s' % numexpr.get_vml_version())",
            "    print('Number of threads used by default: %d '",
            "          '(out of %d detected cores)' % (numexpr.nthreads, numexpr.ncores))",
            "    print('Maximum number of threads: %s' % numexpr.MAX_THREADS)",
            "    print('-=' * 38)",
            "",
            "",
            "def test(verbosity=1):",
            "    \"\"\"",
            "    Run all the tests in the test suite.",
            "    \"\"\"",
            "    print_versions()",
            "    # For some reason, NumPy issues all kinds of warnings when using Python3.",
            "    # Ignoring them in tests should be ok, as all results are checked out.",
            "    # See https://github.com/pydata/numexpr/issues/183 for details.",
            "    np.seterr(divide='ignore', invalid='ignore', over='ignore', under='ignore')",
            "    return unittest.TextTestRunner(verbosity=verbosity).run(suite())",
            "",
            "",
            "test.__test__ = False",
            "",
            "",
            "def suite():",
            "    import unittest",
            "    import platform as pl",
            "",
            "    theSuite = unittest.TestSuite()",
            "    niter = 1",
            "",
            "    class TestExpressions(TestCase):",
            "        pass",
            "",
            "    def add_method(func):",
            "        def method(self):",
            "            return func()",
            "",
            "        setattr(TestExpressions, func.__name__,",
            "                method.__get__(None, TestExpressions))",
            "",
            "    for func in test_expressions():",
            "        add_method(func)",
            "",
            "    for n in range(niter):",
            "        theSuite.addTest(unittest.makeSuite(test_numexpr))",
            "        if 'sparc' not in platform.machine():",
            "            theSuite.addTest(unittest.makeSuite(test_numexpr2))",
            "        theSuite.addTest(unittest.makeSuite(test_evaluate))",
            "        theSuite.addTest(unittest.makeSuite(TestExpressions))",
            "        theSuite.addTest(unittest.makeSuite(test_int32_int64))",
            "        theSuite.addTest(unittest.makeSuite(test_uint32_int64))",
            "        theSuite.addTest(unittest.makeSuite(test_strings))",
            "        theSuite.addTest(",
            "            unittest.makeSuite(test_irregular_stride))",
            "        theSuite.addTest(unittest.makeSuite(test_zerodim))",
            "        theSuite.addTest(unittest.makeSuite(test_threading_config))",
            "",
            "        # multiprocessing module is not supported on Hurd/kFreeBSD",
            "        if (pl.system().lower() not in ('gnu', 'gnu/kfreebsd')):",
            "            theSuite.addTest(unittest.makeSuite(test_subprocess))",
            "",
            "        # I need to put this test after test_subprocess because",
            "        # if not, the test suite locks immediately before test_subproces.",
            "        # This only happens with Windows, so I suspect of a subtle bad",
            "        # interaction with threads and subprocess :-/",
            "        theSuite.addTest(unittest.makeSuite(test_threading))",
            "",
            "    return theSuite",
            "",
            "",
            "if __name__ == '__main__':",
            "    print_versions()",
            "    unittest.main(defaultTest='suite')",
            "#    suite = suite()",
            "#    unittest.TextTestRunner(verbosity=2).run(suite)"
        ],
        "afterPatchFile": [
            "",
            "###################################################################",
            "#  Numexpr - Fast numerical array expression evaluator for NumPy.",
            "#",
            "#      License: MIT",
            "#      Author:  See AUTHORS.txt",
            "#",
            "#  See LICENSE.txt and LICENSES/*.txt for details about copyright and",
            "#  rights to use.",
            "####################################################################",
            "",
            "",
            "import os",
            "import sys",
            "import platform",
            "import warnings",
            "from contextlib import contextmanager",
            "import subprocess",
            "",
            "import numpy as np",
            "from numpy import (",
            "    array, arange, empty, zeros, int32, int64, uint16, complex_, float64, rec,",
            "    copy, ones_like, where, alltrue, linspace,",
            "    sum, prod, sqrt, fmod, floor, ceil,",
            "    sin, cos, tan, arcsin, arccos, arctan, arctan2,",
            "    sinh, cosh, tanh, arcsinh, arccosh, arctanh,",
            "    log, log1p, log10, exp, expm1, conj)",
            "import numpy",
            "from numpy.testing import (assert_equal, assert_array_equal,",
            "                           assert_array_almost_equal, assert_allclose)",
            "from numpy import shape, allclose, array_equal, ravel, isnan, isinf",
            "",
            "import numexpr",
            "from numexpr import E, NumExpr, evaluate, re_evaluate, validate, disassemble, use_vml",
            "from numexpr.expressions import ConstantNode",
            "",
            "import unittest",
            "",
            "TestCase = unittest.TestCase",
            "",
            "double = np.double",
            "long = int",
            "",
            "",
            "class test_numexpr(TestCase):",
            "    \"\"\"Testing with 1 thread\"\"\"",
            "    nthreads = 1",
            "",
            "    def setUp(self):",
            "        numexpr.set_num_threads(self.nthreads)",
            "",
            "    def test_simple(self):",
            "        ex = 2.0 * E.a + 3.0 * E.b * E.c",
            "        sig = [('a', double), ('b', double), ('c', double)]",
            "        func = NumExpr(ex, signature=sig)",
            "        x = func(array([1., 2, 3]), array([4., 5, 6]), array([7., 8, 9]))",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_simple_expr_small_array(self):",
            "        func = NumExpr(E.a)",
            "        x = arange(100.0)",
            "        y = func(x)",
            "        assert_array_equal(x, y)",
            "",
            "    def test_simple_expr(self):",
            "        func = NumExpr(E.a)",
            "        x = arange(1e6)",
            "        y = func(x)",
            "        assert_array_equal(x, y)",
            "",
            "    def test_rational_expr(self):",
            "        func = NumExpr((E.a + 2.0 * E.b) / (1 + E.a + 4 * E.b * E.b))",
            "        a = arange(1e6)",
            "        b = arange(1e6) * 0.1",
            "        x = (a + 2 * b) / (1 + a + 4 * b * b)",
            "        y = func(a, b)",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_reductions(self):",
            "        # Check that they compile OK.",
            "        assert_equal(disassemble(",
            "            NumExpr(\"sum(x**2+2, axis=None)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'sum_ddn', b'r0', b't3', None)])",
            "        assert_equal(disassemble(",
            "            NumExpr(\"sum(x**2+2, axis=1)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'sum_ddn', b'r0', b't3', 1)])",
            "        assert_equal(disassemble(",
            "            NumExpr(\"prod(x**2+2, axis=2)\", [('x', double)])),",
            "                     [(b'mul_ddd', b't3', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b't3', b't3', b'c2[2.0]'),",
            "                      (b'prod_ddn', b'r0', b't3', 2)])",
            "        # Check that full reductions work.",
            "        x = zeros(100000) + .01  # checks issue #41",
            "        assert_allclose(evaluate(\"sum(x+2,axis=None)\"), sum(x + 2, axis=None))",
            "        assert_allclose(evaluate(\"sum(x+2,axis=0)\"), sum(x + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x,axis=0)\"), prod(x, axis=0))",
            "        assert_allclose(evaluate(\"min(x)\"), np.min(x))",
            "        assert_allclose(evaluate(\"max(x,axis=0)\"), np.max(x, axis=0))",
            "",
            "        # Fix for #277, array with leading singleton dimension",
            "        x = np.arange(10).reshape(1,10)",
            "        assert_allclose(evaluate(\"sum(x,axis=None)\"), sum(x, axis=None) )",
            "        assert_allclose(evaluate(\"sum(x,axis=0)\"), sum(x, axis=0) )",
            "        assert_allclose(evaluate(\"sum(x,axis=1)\"), sum(x, axis=1) )",
            "",
            "        x = arange(10.0)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "",
            "        x = arange(100.0)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"min(x-1,axis=0)\"), np.min(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"max(x-1,axis=0)\"), np.max(x - 1, axis=0))",
            "        x = linspace(0.1, 1.0, 2000)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"min(x-1,axis=0)\"), np.min(x - 1, axis=0))",
            "        assert_allclose(evaluate(\"max(x-1,axis=0)\"), np.max(x - 1, axis=0))",
            "",
            "        # Check that reductions along an axis work",
            "        y = arange(9.0).reshape(3, 3)",
            "        assert_allclose(evaluate(\"sum(y**2, axis=1)\"), sum(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"sum(y**2, axis=0)\"), sum(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"sum(y**2, axis=None)\"), sum(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=1)\"), prod(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=0)\"), prod(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(y**2, axis=None)\"), prod(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"min(y**2, axis=1)\"), np.min(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"min(y**2, axis=0)\"), np.min(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"min(y**2, axis=None)\"), np.min(y ** 2, axis=None))",
            "        assert_allclose(evaluate(\"max(y**2, axis=1)\"), np.max(y ** 2, axis=1))",
            "        assert_allclose(evaluate(\"max(y**2, axis=0)\"), np.max(y ** 2, axis=0))",
            "        assert_allclose(evaluate(\"max(y**2, axis=None)\"), np.max(y ** 2, axis=None))",
            "        # Check integers",
            "        x = arange(10.)",
            "        x = x.astype(int)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "        # Check longs",
            "        x = x.astype(int)",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x**2+2,axis=0)\"), prod(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"min(x**2+2,axis=0)\"), np.min(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"max(x**2+2,axis=0)\"), np.max(x ** 2 + 2, axis=0))",
            "        # Check complex",
            "        x = x + .1j",
            "        assert_allclose(evaluate(\"sum(x**2+2,axis=0)\"), sum(x ** 2 + 2, axis=0))",
            "        assert_allclose(evaluate(\"prod(x-1,axis=0)\"), prod(x - 1, axis=0))",
            "",
            "    def test_in_place(self):",
            "        x = arange(10000.).reshape(1000, 10)",
            "        evaluate(\"x + 3\", out=x)",
            "        assert_equal(x, arange(10000.).reshape(1000, 10) + 3)",
            "        y = arange(10)",
            "        evaluate(\"(x - 3) * y + (x - 3)\", out=x)",
            "        assert_equal(x, arange(10000.).reshape(1000, 10) * (arange(10) + 1))",
            "",
            "    def test_axis(self):",
            "        y = arange(9.0).reshape(3, 3)",
            "        try:",
            "            evaluate(\"sum(y, axis=2)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "        try:",
            "            evaluate(\"sum(y, axis=-3)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "        try:",
            "            # Negative axis are not supported",
            "            evaluate(\"sum(y, axis=-1)\")",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "",
            "    def test_r0_reuse(self):",
            "        assert_equal(disassemble(NumExpr(\"x * x + 2\", [('x', double)])),",
            "                     [(b'mul_ddd', b'r0', b'r1[x]', b'r1[x]'),",
            "                      (b'add_ddd', b'r0', b'r0', b'c2[2.0]')])",
            "",
            "    def test_str_contains_basic0(self):",
            "        res = evaluate('contains(b\"abc\", b\"ab\")')",
            "        assert_equal(res, True)",
            "",
            "    def test_str_contains_basic1(self):",
            "        haystack = array([b'abc', b'def', b'xyz', b'x11', b'za'])",
            "        res = evaluate('contains(haystack, b\"ab\")')",
            "        assert_equal(res, [True, False, False, False, False])",
            "",
            "    def test_str_contains_basic2(self):",
            "        haystack = array([b'abc', b'def', b'xyz', b'x11', b'za'])",
            "        res = evaluate('contains(b\"abcd\", haystack)')",
            "        assert_equal(res, [True, False, False, False, False])",
            "",
            "    def test_str_contains_basic3(self):",
            "        haystacks = array(",
            "            [b'abckkk', b'adef', b'xyz', b'x11abcp', b'za', b'abc'])",
            "        needles = array(",
            "            [b'abc', b'def', b'aterr', b'oot', b'zu', b'ab'])",
            "        res = evaluate('contains(haystacks, needles)')",
            "        assert_equal(res, [True, True, False, False, False, True])",
            "",
            "    def test_str_contains_basic4(self):",
            "        needles = array(",
            "            [b'abc', b'def', b'aterr', b'oot', b'zu', b'ab c', b' abc',",
            "             b'abc '])",
            "        res = evaluate('contains(b\"test abc here\", needles)')",
            "        assert_equal(res, [True, False, False, False, False, False, True, True])",
            "",
            "    def test_str_contains_basic5(self):",
            "        needles = array(",
            "            [b'abc', b'ab c', b' abc', b' abc ', b'\\tabc', b'c h'])",
            "        res = evaluate('contains(b\"test abc here\", needles)')",
            "        assert_equal(res, [True, False, True, True, False, True])",
            "",
            "        # Compare operation of Python 'in' operator with 'contains' using a",
            "        # product of two lists of strings.",
            "",
            "    def test_str_contains_listproduct(self):",
            "        from itertools import product",
            "",
            "        small = [",
            "            'It w', 'as th', 'e Whit', 'e Rab', 'bit,', ' tro', 'tting',",
            "            ' sl', 'owly', ' back ', 'again,', ' and', ' lo', 'okin', 'g a',",
            "            'nxious', 'ly a', 'bou', 't a', 's it w', 'ent,', ' as i', 'f it',",
            "            ' had l', 'ost', ' some', 'thi', 'ng; a', 'nd ', 'she ', 'heard ',",
            "            'it mut', 'terin', 'g to ', 'its', 'elf ', \"'The\",",
            "            ' Duch', 'ess! T', 'he ', 'Duches', 's! Oh ', 'my dea', 'r paws',",
            "            '! Oh ', 'my f', 'ur ', 'and ', 'whiske', 'rs! ', 'She', \"'ll g\",",
            "            'et me', ' ex', 'ecu', 'ted, ', 'as su', 're a', 's f', 'errets',",
            "            ' are f', 'errets', '! Wh', 'ere ', 'CAN', ' I hav', 'e d',",
            "            'roppe', 'd t', 'hem,', ' I wo', 'nder?', \"' A\", 'lice',",
            "            ' gu', 'essed', ' in a', ' mom', 'ent ', 'tha', 't it w', 'as ',",
            "            'looki', 'ng f', 'or ', 'the fa', 'n and ', 'the', ' pai',",
            "            'r of w', 'hit', 'e kid', ' glo', 'ves', ', and ', 'she ',",
            "            'very g', 'ood', '-na', 'turedl', 'y be', 'gan h', 'unt', 'ing',",
            "            ' about', ' for t', 'hem', ', but', ' they ', 'wer', 'e nowh',",
            "            'ere to', ' be', ' se', 'en--', 'ever', 'ythin', 'g seem', 'ed ',",
            "            'to ', 'have c', 'hang', 'ed ', 'since', ' he', 'r swim', ' in',",
            "            ' the', ' pool,', ' and', ' the g', 'reat ', 'hal', 'l, w', 'ith',",
            "            ' th', 'e gl', 'ass t', 'abl', 'e and ', 'the', ' li', 'ttle',",
            "            ' doo', 'r, ha', 'd v', 'ani', 'shed c', 'omp', 'lete', 'ly.']",
            "        big = [",
            "            'It wa', 's the', ' W', 'hit', 'e ', 'Ra', 'bb', 'it, t', 'ro',",
            "            'tting s', 'lowly', ' back ', 'agai', 'n, and', ' l', 'ookin',",
            "            'g ', 'an', 'xiously', ' about ', 'as it w', 'ent, as', ' if ',",
            "            'it had', ' los', 't ', 'so', 'mething', '; and', ' she h',",
            "            'eard ', 'it ', 'mutteri', 'ng to', ' itself', \" 'The \",",
            "            'Duchess', '! ', 'Th', 'e ', 'Duchess', '! Oh m', 'y de',",
            "            'ar paws', '! ', 'Oh my ', 'fu', 'r and w', 'hiskers', \"! She'\",",
            "            'll ', 'get', ' me ', 'execute', 'd,', ' a', 's ', 'su', 're as ',",
            "            'fe', 'rrets', ' are f', 'errets!', ' Wher', 'e CAN', ' I ha',",
            "            've dro', 'pped t', 'hem', ', I ', 'won', \"der?' A\",",
            "            'lice g', 'uess', 'ed ', 'in a m', 'omen', 't that', ' i',",
            "            't was l', 'ook', 'ing f', 'or th', 'e ', 'fan and', ' th', 'e p',",
            "            'air o', 'f whit', 'e ki', 'd glove', 's, and ', 'she v', 'ery ',",
            "            'good-na', 'tu', 'redl', 'y be', 'gan hun', 'ti', 'ng abou',",
            "            't for t', 'he', 'm, bu', 't t', 'hey ', 'were n', 'owhere',",
            "            ' to b', 'e s', 'een-', '-eve', 'rythi', 'ng see', 'me', 'd ',",
            "            'to ha', 've', ' c', 'hanged', ' sinc', 'e her s', 'wim ',",
            "            'in the ', 'pool,', ' an', 'd the g', 'rea', 't h', 'all, wi',",
            "            'th the ', 'glas', 's t', 'able an', 'd th', 'e littl', 'e door,',",
            "            ' had va', 'ni', 'shed co', 'mpletel', 'y.']",
            "        p = list(product(small, big))",
            "        python_in = [x[0] in x[1] for x in p]",
            "        a = [x[0].encode() for x in p]",
            "        b = [x[1].encode() for x in p]",
            "        res = [bool(x) for x in evaluate('contains(b, a)')]",
            "        assert_equal(res, python_in)",
            "",
            "    def test_str_contains_withemptystr1(self):",
            "        withemptystr = array([b'abc', b'def', b''])",
            "        res = evaluate('contains(b\"abcd\", withemptystr)')",
            "        assert_equal(res, [True, False, True])",
            "",
            "    def test_str_contains_withemptystr2(self):",
            "        withemptystr = array([b'abc', b'def', b''])",
            "        res = evaluate('contains(withemptystr, b\"\")')",
            "        assert_equal(res, [True, True, True])",
            "",
            "    def test_str_contains_long_needle(self):",
            "        a = b'1' + b'a' * 40",
            "        b = b'a' * 40",
            "        res = evaluate('contains(a, b)')",
            "        assert_equal(res, True)",
            "        ",
            "    def test_where_scalar_bool(self):",
            "        a = True",
            "        b = array([1, 2])",
            "        c = array([3, 4])",
            "        res = evaluate('where(a, b, c)')",
            "        assert_array_equal(res, b)",
            "        a = False",
            "        res = evaluate('where(a, b, c)')",
            "        assert_array_equal(res, c)",
            "",
            "    ",
            "    def test_refcount(self):",
            "        # Regression test for issue #310",
            "        a = array([1])",
            "        assert sys.getrefcount(a) == 2",
            "        evaluate('1')",
            "        assert sys.getrefcount(a) == 2",
            "",
            "    def test_locals_clears_globals(self):",
            "        # Check for issue #313, whereby clearing f_locals also clear f_globals",
            "        # if in the top-frame. This cannot be done inside `unittest` as it is always ",
            "        # executing code in a child frame.",
            "        script = r';'.join([",
            "                r\"import numexpr as ne\",",
            "                r\"a=10\",",
            "                r\"ne.evaluate('1')\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('2', local_dict={})\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('3', global_dict={})\",",
            "                r\"a += 1\",",
            "                r\"ne.evaluate('4', local_dict={}, global_dict={})\",",
            "                r\"a += 1\",",
            "            ])",
            "        # Raises CalledProcessError on a non-normal exit",
            "        check = subprocess.check_call([sys.executable, '-c', script])",
            "        # Ideally this test should also be done against ipython but it's not ",
            "        # a requirement.",
            "",
            "",
            "",
            "class test_numexpr2(test_numexpr):",
            "    \"\"\"Testing with 2 threads\"\"\"",
            "    nthreads = 2",
            "",
            "",
            "class test_evaluate(TestCase):",
            "    def test_simple(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        x = evaluate(\"2*a + 3*b*c\")",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_simple_expr_small_array(self):",
            "        x = arange(100.0)",
            "        y = evaluate(\"x\")",
            "        assert_array_equal(x, y)",
            "",
            "    def test_simple_expr(self):",
            "        x = arange(1e6)",
            "        y = evaluate(\"x\")",
            "        assert_array_equal(x, y)",
            "",
            "    def test_re_evaluate(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        x = evaluate(\"2*a + 3*b*c\")",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_re_evaluate_dict(self):",
            "        a1 = array([1., 2., 3.])",
            "        b1 = array([4., 5., 6.])",
            "        c1 = array([7., 8., 9.])",
            "        local_dict={'a': a1, 'b': b1, 'c': c1}",
            "        x = evaluate(\"2*a + 3*b*c\", local_dict=local_dict)",
            "        x = re_evaluate(local_dict=local_dict)",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_validate(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        c = array([7., 8., 9.])",
            "        retval = validate(\"2*a + 3*b*c\")",
            "        assert(retval is None)",
            "        x = re_evaluate()",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    def test_validate_missing_var(self):",
            "        a = array([1., 2., 3.])",
            "        b = array([4., 5., 6.])",
            "        retval = validate(\"2*a + 3*b*c\")",
            "        assert(isinstance(retval, KeyError))",
            "",
            "    def test_validate_syntax(self):",
            "        retval = validate(\"2+\")",
            "        assert(isinstance(retval, SyntaxError))",
            "",
            "    def test_validate_dict(self):",
            "        a1 = array([1., 2., 3.])",
            "        b1 = array([4., 5., 6.])",
            "        c1 = array([7., 8., 9.])",
            "        local_dict={'a': a1, 'b': b1, 'c': c1}",
            "        retval = validate(\"2*a + 3*b*c\", local_dict=local_dict)",
            "        assert(retval is None)",
            "        x = re_evaluate(local_dict=local_dict)",
            "        assert_array_equal(x, array([86., 124., 168.]))",
            "",
            "    # Test for issue #22",
            "    def test_true_div(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x/2\"), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv=False), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv='auto'), x / 2)",
            "        assert_array_equal(evaluate(\"x/2\", truediv=True), x / 2.0)",
            "",
            "    def test_left_shift(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x<<2\"), x << 2)",
            "",
            "    def test_right_shift(self):",
            "        x = arange(10, dtype='i4')",
            "        assert_array_equal(evaluate(\"x>>2\"), x >> 2)",
            "",
            "    # PyTables uses __nonzero__ among ExpressionNode objects internally",
            "    # so this should be commented out for the moment.  See #24.",
            "    def test_boolean_operator(self):",
            "        x = arange(10, dtype='i4')",
            "        try:",
            "            evaluate(\"(x > 1) and (x < 9)\")",
            "        except TypeError:",
            "            pass",
            "        else:",
            "            raise ValueError(\"should raise exception!\")",
            "",
            "    def test_rational_expr(self):",
            "        a = arange(1e6)",
            "        b = arange(1e6) * 0.1",
            "        x = (a + 2 * b) / (1 + a + 4 * b * b)",
            "        y = evaluate(\"(a + 2*b) / (1 + a + 4*b*b)\")",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_complex_expr(self):",
            "        def complex(a, b):",
            "            c = zeros(a.shape, dtype=complex_)",
            "            c.real = a",
            "            c.imag = b",
            "            return c",
            "",
            "        a = arange(1e4)",
            "        b = arange(1e4) ** 1e-5",
            "        z = a + 1j * b",
            "        x = z.imag",
            "        x = sin(complex(a, b)).real + z.imag",
            "        y = evaluate(\"sin(complex(a, b)).real + z.imag\")",
            "        assert_array_almost_equal(x, y)",
            "",
            "    def test_complex_strides(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        b = arange(50).reshape(5, 10)",
            "        assert_array_equal(evaluate(\"a+b\"), a + b)",
            "        c = empty([10], dtype=[('c1', int32), ('c2', uint16)])",
            "        c['c1'] = arange(10)",
            "        c['c2'].fill(0xaaaa)",
            "        c1 = c['c1']",
            "        a0 = a[0]",
            "        assert_array_equal(evaluate(\"c1\"), c1)",
            "        assert_array_equal(evaluate(\"a0+c1\"), a0 + c1)",
            "",
            "    def test_recarray_strides(self):",
            "        a = arange(100)",
            "        b = arange(100,200)",
            "        recarr = np.rec.array(None, formats='f4,f4', shape=(100,))",
            "        recarr['f0'] = a",
            "        recarr['f1'] = b",
            "        c = recarr['f1']",
            "        assert_array_almost_equal(evaluate(\"sqrt(c) > 1.\"), sqrt(c) > 1.)",
            "        assert_array_almost_equal(evaluate(\"log10(c)\"), log10(c))",
            "",
            "    def test_broadcasting(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        c = arange(10)",
            "        d = arange(5).reshape(5, 1)",
            "        assert_array_equal(evaluate(\"a+c\"), a + c)",
            "        assert_array_equal(evaluate(\"a+d\"), a + d)",
            "        expr = NumExpr(\"2.0*a+3.0*c\", [('a', double), ('c', double)])",
            "        assert_array_equal(expr(a, c), 2.0 * a + 3.0 * c)",
            "",
            "    def test_all_scalar(self):",
            "        a = 3.",
            "        b = 4.",
            "        assert_allclose(evaluate(\"a+b\"), a + b)",
            "        expr = NumExpr(\"2*a+3*b\", [('a', double), ('b', double)])",
            "        assert_equal(expr(a, b), 2 * a + 3 * b)",
            "",
            "    def test_run(self):",
            "        a = arange(100).reshape(10, 10)[::2]",
            "        b = arange(10)",
            "        expr = NumExpr(\"2*a+3*b\", [('a', double), ('b', double)])",
            "        assert_array_equal(expr(a, b), expr.run(a, b))",
            "",
            "    def test_illegal_value(self):",
            "        a = arange(3)",
            "        try:",
            "            evaluate(\"a < [0, 0, 0]\")",
            "        except (ValueError, TypeError):",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "    def test_forbidden_tokens(self):",
            "        # Forbid dunder",
            "        try:",
            "            evaluate('__builtins__')",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "        # Forbid colon for lambda funcs",
            "        try: ",
            "            evaluate('lambda x: x')",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "        # Forbid indexing",
            "        try:",
            "            evaluate('locals()[]')",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "        # Forbid semicolon",
            "        try:",
            "            evaluate('import os; os.cpu_count()')",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            self.fail()",
            "",
            "        # I struggle to come up with cases for our ban on `'` and `\"`",
            "",
            "",
            "",
            "",
            "    def test_disassemble(self):",
            "        assert_equal(disassemble(NumExpr(",
            "            \"where(m, a, -1)\", [('m', bool), ('a', float)])),",
            "            [[b'where_fbff', b'r0', b'r1[m]', b'r2[a]', b'c3[-1.0]'], ",
            "             [b'noop', None, None, None]])",
            "",
            "    def test_constant_deduplication(self):",
            "        assert_equal(NumExpr(\"(a + 1)*(a - 1)\", [('a', np.int32)]).constants, (1,))",
            "",
            "    def test_nan_constant(self):",
            "        assert_equal(str(ConstantNode(float(\"nan\")).value), 'nan')",
            "",
            "        # check de-duplication works for nan",
            "        _nan = ConstantNode(float(\"nan\"))",
            "        expr = (E.a + _nan)*(E.b + _nan)",
            "        assert_equal(NumExpr(expr, [('a', double), ('b', double)]).constants, (float(\"nan\"),))",
            "",
            "",
            "    def test_f32_constant(self):",
            "        assert_equal(ConstantNode(numpy.float32(1)).astKind, \"float\")",
            "        assert_equal(ConstantNode(numpy.float32(\"nan\")).astKind, \"float\")",
            "        assert_equal(ConstantNode(numpy.float32(3)).value.dtype, numpy.dtype(\"float32\"))",
            "        assert_array_equal(NumExpr(ConstantNode(numpy.float32(1))).run(), ",
            "                           numpy.array(1, dtype=\"float32\"))",
            "",
            "    def test_unaligned_singleton(self):",
            "        # Test for issue #397 whether singletons outputs assigned to consts must be ",
            "        # aligned or not.",
            "        a = np.empty(5, dtype=np.uint8)[1:].view(np.int32)",
            "        evaluate('3', out=a)",
            "        assert_equal(a, 3)",
            "",
            "    def test_negative_mod(self):",
            "        # Test for issue #413, modulus of negative integers. C modulus is ",
            "        # actually remainder op, and hence different from Python modulus.",
            "        a = np.array([-500, -135, 0, 0, 135, 500], dtype=np.int32)",
            "        n = np.array([-360, -360, -360, 360, 360, 360], dtype=np.int32)",
            "        out_i = evaluate('a % n')",
            "        assert_equal(out_i, np.mod(a, n))",
            "",
            "        b = a.astype(np.int64)",
            "        m = n.astype(np.int64)",
            "        out_l = evaluate('b % m')",
            "        assert_equal(out_l, np.mod(b, m))",
            "",
            "    def test_negative_power_scalar(self):",
            "        # Test for issue #428, where the power is negative and the base is an",
            "        # integer. This was running afoul in the precomputation in `expressions.py:pow_op()`",
            "        base = np.array([-2, -1, 0, 1, 2, 3], dtype=np.int32)",
            "        out_i = evaluate('base ** -1.0')",
            "        assert_equal(out_i, np.power(base, -1.0))",
            "",
            "        base = np.array([-2, -1, 0, 1, 2, 3], dtype=np.int64)",
            "        out_l = evaluate('base ** -1.0')",
            "        assert_equal(out_l, np.power(base, -1.0))",
            "",
            "",
            "    def test_ex_uses_vml(self):",
            "        vml_funcs = [ \"sin\", \"cos\", \"tan\", \"arcsin\", \"arccos\", \"arctan\",",
            "                      \"sinh\", \"cosh\", \"tanh\", \"arcsinh\", \"arccosh\", \"arctanh\",",
            "                      \"log\", \"log1p\",\"log10\", \"exp\", \"expm1\", \"abs\", \"conj\",",
            "                      \"arctan2\", \"fmod\"]",
            "        for func in vml_funcs:",
            "            strexpr = func+'(a)'",
            "            _, ex_uses_vml = numexpr.necompiler.getExprNames(strexpr, {})",
            "            assert_equal(ex_uses_vml, use_vml, strexpr)",
            "",
            "    if 'sparc' not in platform.machine():",
            "        # Execution order set here so as to not use too many threads",
            "        # during the rest of the execution.  See #33 for details.",
            "        def test_changing_nthreads_00_inc(self):",
            "            a = linspace(-1, 1, 1000000)",
            "            b = ((.25 * a + .75) * a - 1.5) * a - 2",
            "            for nthreads in range(1, 7):",
            "                numexpr.set_num_threads(nthreads)",
            "                c = evaluate(\"((.25*a + .75)*a - 1.5)*a - 2\")",
            "                assert_array_almost_equal(b, c)",
            "",
            "        def test_changing_nthreads_01_dec(self):",
            "            a = linspace(-1, 1, 1000000)",
            "            b = ((.25 * a + .75) * a - 1.5) * a - 2",
            "            for nthreads in range(6, 1, -1):",
            "                numexpr.set_num_threads(nthreads)",
            "                c = evaluate(\"((.25*a + .75)*a - 1.5)*a - 2\")",
            "                assert_array_almost_equal(b, c)",
            "",
            "",
            "tests = [",
            "    ('MISC', ['b*c+d*e',",
            "              '2*a+3*b',",
            "              '-a',",
            "              'sinh(a)',",
            "              '2*a + (cos(3)+5)*sinh(cos(b))',",
            "              '2*a + arctan2(a, b)',",
            "              'arcsin(0.5)',",
            "              'where(a != 0.0, 2, a)',",
            "              'where(a > 10, b < a, b > a)',",
            "              'where((a-10).real != 0.0, a, 2)',",
            "              '0.25 * (a < 5) + 0.33 * (a >= 5)',",
            "              'cos(1+1)',",
            "              '1+1',",
            "              '1',",
            "              'cos(a2)',",
            "    ])]",
            "",
            "optests = []",
            "for op in list('+-*/%') + ['**']:",
            "    optests.append(\"(a+1) %s (b+3)\" % op)",
            "    optests.append(\"3 %s (b+3)\" % op)",
            "    optests.append(\"(a+1) %s 4\" % op)",
            "    optests.append(\"2 %s (b+3)\" % op)",
            "    optests.append(\"(a+1) %s 2\" % op)",
            "    optests.append(\"(a+1) %s -1\" % op)",
            "    optests.append(\"(a+1) %s 0.5\" % op)",
            "    # Check divisions and modulus by zero (see ticket #107)",
            "    optests.append(\"(a+1) %s 0\" % op)",
            "tests.append(('OPERATIONS', optests))",
            "",
            "cmptests = []",
            "for op in ['<', '<=', '==', '>=', '>', '!=']:",
            "    cmptests.append(\"a/2+5 %s b\" % op)",
            "    cmptests.append(\"a/2+5 %s 7\" % op)",
            "    cmptests.append(\"7 %s b\" % op)",
            "    cmptests.append(\"7.0 %s 5\" % op)",
            "tests.append(('COMPARISONS', cmptests))",
            "",
            "func1tests = []",
            "for func in ['copy', 'ones_like', 'sqrt',",
            "             'sin', 'cos', 'tan', 'arcsin', 'arccos', 'arctan',",
            "             'sinh', 'cosh', 'tanh', 'arcsinh', 'arccosh', 'arctanh',",
            "             'log', 'log1p', 'log10', 'exp', 'expm1', 'abs', 'conj',",
            "             'ceil', 'floor']:",
            "    func1tests.append(\"a + %s(b+c)\" % func)",
            "tests.append(('1_ARG_FUNCS', func1tests))",
            "",
            "func2tests = []",
            "for func in ['arctan2', 'fmod']:",
            "    func2tests.append(\"a + %s(b+c, d+1)\" % func)",
            "    func2tests.append(\"a + %s(b+c, 1)\" % func)",
            "    func2tests.append(\"a + %s(1, d+1)\" % func)",
            "tests.append(('2_ARG_FUNCS', func2tests))",
            "",
            "powtests = []",
            "# n = -1, 0.5, 2, 4 already handled in section \"OPERATIONS\"",
            "for n in (-7, -2.5, -1.5, -1.3, -.5, 0, 0.0, 1, 2.3, 2.5, 3):",
            "    powtests.append(\"(a+1)**%s\" % n)",
            "tests.append(('POW_TESTS', powtests))",
            "",
            "",
            "def equal(a, b, exact):",
            "    if array_equal(a, b):",
            "        return True",
            "",
            "    if hasattr(a, 'dtype') and a.dtype in ['f4', 'f8']:",
            "        nnans = isnan(a).sum()",
            "        if nnans > 0:",
            "            # For results containing NaNs, just check that the number",
            "            # of NaNs is the same in both arrays.  This check could be",
            "            # made more exhaustive, but checking element by element in",
            "            # python space is very expensive in general.",
            "            return nnans == isnan(b).sum()",
            "        ninfs = isinf(a).sum()",
            "        if ninfs > 0:",
            "            # Ditto for Inf's",
            "            return ninfs == isinf(b).sum()",
            "    if exact:",
            "        return (shape(a) == shape(b)) and alltrue(ravel(a) == ravel(b), axis=0)",
            "    else:",
            "        if hasattr(a, 'dtype') and a.dtype == 'f4':",
            "            atol = 1e-5  # Relax precision for special opcodes, like fmod",
            "        else:",
            "            atol = 1e-8",
            "        return (shape(a) == shape(b) and",
            "                allclose(ravel(a), ravel(b), atol=atol))",
            "",
            "",
            "class Skip(Exception): pass",
            "",
            "",
            "def test_expressions():",
            "    test_no = [0]",
            "",
            "    def make_test_method(a, a2, b, c, d, e, x, expr,",
            "                         test_scalar, dtype, optimization, exact, section):",
            "        this_locals = locals()",
            "",
            "        def method():",
            "            try:",
            "                # We don't want to listen at RuntimeWarnings like",
            "                # \"overflows\" or \"divide by zero\" in plain eval().",
            "                warnings.simplefilter(\"ignore\")",
            "                npval = eval(expr, globals(), this_locals)",
            "                warnings.simplefilter(\"always\")",
            "                npval = eval(expr, globals(), this_locals)",
            "            except Exception as ex:",
            "                # just store the exception in a variable",
            "                # compatibility with numpy v1.12",
            "                # see also https://github.com/pydata/numexpr/issues/239",
            "                np_exception = ex",
            "                npval = None",
            "            else:",
            "                np_exception = None",
            "",
            "            try:",
            "                neval = evaluate(expr, local_dict=this_locals,",
            "                                 optimization=optimization)",
            "            except AssertionError:",
            "                raise",
            "            except NotImplementedError:",
            "                print('%r not implemented for %s (scalar=%d, opt=%s)'",
            "                      % (expr, dtype.__name__, test_scalar, optimization))",
            "            except Exception as ne_exception:",
            "                same_exc_type = issubclass(type(ne_exception),",
            "                                           type(np_exception))",
            "                if np_exception is None or not same_exc_type:",
            "                    print('numexpr error for expression %r' % (expr,))",
            "                    raise",
            "            except:",
            "                print('numexpr error for expression %r' % (expr,))",
            "                raise",
            "            else:",
            "                msg = ('expected numexpr error not raised for expression '",
            "                       '%r' % (expr,))",
            "                assert np_exception is None, msg",
            "",
            "                assert equal(npval, neval, exact), \"\"\"%r",
            "(test_scalar=%r, dtype=%r, optimization=%r, exact=%r,",
            " npval=%r (%r - %r)\\n neval=%r (%r - %r))\"\"\" % (expr, test_scalar, dtype.__name__,",
            "                                                optimization, exact,",
            "                                                npval, type(npval), shape(npval),",
            "                                                neval, type(neval), shape(neval))",
            "",
            "        method.description = ('test_expressions(%s, test_scalar=%r, '",
            "                              'dtype=%r, optimization=%r, exact=%r)') % (expr, test_scalar, dtype.__name__, optimization, exact)",
            "        test_no[0] += 1",
            "        method.__name__ = 'test_scalar%d_%s_%s_%s_%04d' % (test_scalar,",
            "                                                           dtype.__name__,",
            "                                                           optimization.encode('ascii'),",
            "                                                           section.encode('ascii'),",
            "                                                           test_no[0])",
            "        return method",
            "",
            "    x = None",
            "    for test_scalar in (0, 1, 2):",
            "        for dtype in (int, int, np.float32, double, complex):",
            "            array_size = 100",
            "            a = arange(2 * array_size, dtype=dtype)[::2]",
            "            a2 = zeros([array_size, array_size], dtype=dtype)",
            "            b = arange(array_size, dtype=dtype) / array_size",
            "            c = arange(array_size, dtype=dtype)",
            "            d = arange(array_size, dtype=dtype)",
            "            e = arange(array_size, dtype=dtype)",
            "            if dtype == complex:",
            "                a = a.real",
            "                for x in [a2, b, c, d, e]:",
            "                    x += 1j",
            "                    x *= 1 + 1j",
            "            if test_scalar == 1:",
            "                a = a[array_size // 2]",
            "            if test_scalar == 2:",
            "                b = b[array_size // 2]",
            "            for optimization, exact in [",
            "                ('none', False), ('moderate', False), ('aggressive', False)]:",
            "                for section_name, section_tests in tests:",
            "                    for expr in section_tests:",
            "                        if (dtype == complex and",
            "                            ('<' in expr or '>' in expr or '%' in expr",
            "                             or \"arctan2\" in expr or \"fmod\" in expr",
            "                             or \"floor\" in expr or \"ceil\" in expr)):",
            "                            # skip complex comparisons or functions not",
            "                            # defined in complex domain.",
            "                            continue",
            "                        if (dtype in (int, int) and test_scalar and",
            "                                    expr == '(a+1) ** -1'):",
            "                            continue",
            "",
            "                        m = make_test_method(a, a2, b, c, d, e, x,",
            "                                             expr, test_scalar, dtype,",
            "                                             optimization, exact,",
            "                                             section_name)",
            "                        yield m",
            "",
            "",
            "class test_int64(TestCase):",
            "    def test_neg(self):",
            "        a = array([2 ** 31 - 1, 2 ** 31, 2 ** 32, 2 ** 63 - 1], dtype=int64)",
            "        res = evaluate('-a')",
            "        assert_array_equal(res, [1 - 2 ** 31, -(2 ** 31), -(2 ** 32), 1 - 2 ** 63])",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "",
            "class test_int32_int64(TestCase):",
            "",
            "    def test_small_int(self):",
            "        # Small ints (32-bit ones) should not be promoted to longs.",
            "        res = evaluate('2')",
            "        assert_array_equal(res, 2)",
            "        self.assertEqual(res.dtype.name, 'int32')",
            "",
            "    def test_big_int(self):",
            "        # Big ints should be promoted to longs.",
            "        res = evaluate('2**40')",
            "        assert_array_equal(res, 2 ** 40)",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "    def test_long_constant_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        itwo = np.int32(2)",
            "        ltwo = np.int64(2)",
            "        res = int32array * 2",
            "        res32 = evaluate('int32array * itwo')",
            "        res64 = evaluate('int32array * ltwo')",
            "        assert_array_equal(res, res32)",
            "        assert_array_equal(res, res64)",
            "        self.assertEqual(res32.dtype.name, 'int32')",
            "        self.assertEqual(res64.dtype.name, 'int64')",
            "",
            "    def test_int64_array_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        int64array = arange(100, dtype='int64')",
            "        respy = int32array * int64array",
            "        resnx = evaluate('int32array * int64array')",
            "        assert_array_equal(respy, resnx)",
            "        self.assertEqual(resnx.dtype.name, 'int64')",
            "",
            "",
            "class test_uint32_int64(TestCase):",
            "    def test_small_uint32(self):",
            "        # Small uint32 should not be downgraded to ints.",
            "        a = np.uint32(42)",
            "        res = evaluate('a')",
            "        assert_array_equal(res, 42)",
            "        self.assertEqual(res.dtype.name, 'int64')",
            "",
            "    def test_uint32_constant_promotion(self):",
            "        int32array = arange(100, dtype='int32')",
            "        stwo = np.int32(2)",
            "        utwo = np.uint32(2)",
            "        res = int32array * utwo",
            "        res32 = evaluate('int32array * stwo')",
            "        res64 = evaluate('int32array * utwo')",
            "        assert_array_equal(res, res32)",
            "        assert_array_equal(res, res64)",
            "        self.assertEqual(res32.dtype.name, 'int32')",
            "        self.assertEqual(res64.dtype.name, 'int64')",
            "",
            "    def test_int64_array_promotion(self):",
            "        uint32array = arange(100, dtype='uint32')",
            "        int64array = arange(100, dtype='int64')",
            "        respy = uint32array * int64array",
            "        resnx = evaluate('uint32array * int64array')",
            "        assert_array_equal(respy, resnx)",
            "        self.assertEqual(resnx.dtype.name, 'int64')",
            "",
            "",
            "class test_strings(TestCase):",
            "    BLOCK_SIZE1 = 128",
            "    BLOCK_SIZE2 = 8",
            "    str_list1 = [b'foo', b'bar', b'', b'  ']",
            "    str_list2 = [b'foo', b'', b'x', b' ']",
            "    str_nloops = len(str_list1) * (BLOCK_SIZE1 + BLOCK_SIZE2 + 1)",
            "    str_array1 = array(str_list1 * str_nloops)",
            "    str_array2 = array(str_list2 * str_nloops)",
            "    str_constant = b'doodoo'",
            "",
            "    def test_null_chars(self):",
            "        str_list = [",
            "            b'\\0\\0\\0', b'\\0\\0foo\\0', b'\\0\\0foo\\0b', b'\\0\\0foo\\0b\\0',",
            "            b'foo\\0', b'foo\\0b', b'foo\\0b\\0', b'foo\\0bar\\0baz\\0\\0']",
            "        for s in str_list:",
            "            r = evaluate('s')",
            "            self.assertEqual(s, r.tobytes())  # check *all* stored data",
            "",
            "    def test_compare_copy(self):",
            "        sarr = self.str_array1",
            "        expr = 'sarr'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_array(self):",
            "        sarr1 = self.str_array1",
            "        sarr2 = self.str_array2",
            "        expr = 'sarr1 >= sarr2'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_variable(self):",
            "        sarr = self.str_array1",
            "        svar = self.str_constant",
            "        expr = 'sarr >= svar'",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_compare_constant(self):",
            "        sarr = self.str_array1",
            "        expr = 'sarr >= %r' % self.str_constant",
            "        res1 = eval(expr)",
            "        res2 = evaluate(expr)",
            "        assert_array_equal(res1, res2)",
            "",
            "    def test_add_string_array(self):",
            "        sarr1 = self.str_array1",
            "        sarr2 = self.str_array2",
            "        expr = 'sarr1 + sarr2'",
            "        self.assert_missing_op('add_sss', expr, locals())",
            "",
            "    def test_empty_string1(self):",
            "        a = np.array([b\"\", b\"pepe\"])",
            "        b = np.array([b\"pepe2\", b\"\"])",
            "        res = evaluate(\"(a == b'') & (b == b'pepe2')\")",
            "        assert_array_equal(res, np.array([True, False]))",
            "        res2 = evaluate(\"(a == b'pepe') & (b == b'')\")",
            "        assert_array_equal(res2, np.array([False, True]))",
            "",
            "    def test_empty_string2(self):",
            "        a = np.array([b\"p\", b\"pepe\"])",
            "        b = np.array([b\"pepe2\", b\"\"])",
            "        res = evaluate(\"(a == b'') & (b == b'pepe2')\")",
            "        assert_array_equal(res, np.array([False, False]))",
            "        res2 = evaluate(\"(a == b'pepe') & (b == b'')\")",
            "        assert_array_equal(res, np.array([False, False]))",
            "",
            "    def test_add_numeric_array(self):",
            "        sarr = self.str_array1",
            "        narr = arange(len(sarr), dtype='int32')",
            "        expr = 'sarr >= narr'",
            "        self.assert_missing_op('ge_bsi', expr, locals())",
            "",
            "    def assert_missing_op(self, op, expr, local_dict):",
            "        msg = \"expected NotImplementedError regarding '%s'\" % op",
            "        try:",
            "            evaluate(expr, local_dict)",
            "        except NotImplementedError as nie:",
            "            if \"'%s'\" % op not in nie.args[0]:",
            "                self.fail(msg)",
            "        else:",
            "            self.fail(msg)",
            "",
            "    def test_compare_prefix(self):",
            "        # Check comparing two strings where one is a prefix of the",
            "        # other.",
            "        for s1, s2 in [(b'foo', b'foobar'), (b'foo', b'foo\\0bar'),",
            "                       (b'foo\\0a', b'foo\\0bar')]:",
            "            self.assertTrue(evaluate('s1 < s2'))",
            "            self.assertTrue(evaluate('s1 <= s2'))",
            "            self.assertTrue(evaluate('~(s1 == s2)'))",
            "            self.assertTrue(evaluate('~(s1 >= s2)'))",
            "            self.assertTrue(evaluate('~(s1 > s2)'))",
            "",
            "        # Check for NumPy array-style semantics in string equality.",
            "        s1, s2 = b'foo', b'foo\\0\\0'",
            "        self.assertTrue(evaluate('s1 == s2'))",
            "",
            "",
            "# Case for testing selections in fields which are aligned but whose",
            "# data length is not an exact multiple of the length of the record.",
            "# The following test exposes the problem only in 32-bit machines,",
            "# because in 64-bit machines 'c2' is unaligned.  However, this should",
            "# check most platforms where, while not unaligned, 'len(datatype) >",
            "# boundary_alignment' is fullfilled.",
            "class test_irregular_stride(TestCase):",
            "    def test_select(self):",
            "        f0 = arange(10, dtype=int32)",
            "        f1 = arange(10, dtype=float64)",
            "",
            "        irregular = rec.fromarrays([f0, f1])",
            "",
            "        f0 = irregular['f0']",
            "        f1 = irregular['f1']",
            "",
            "        i0 = evaluate('f0 < 5')",
            "        i1 = evaluate('f1 < 5')",
            "",
            "        assert_array_equal(f0[i0], arange(5, dtype=int32))",
            "        assert_array_equal(f1[i1], arange(5, dtype=float64))",
            "",
            "",
            "# Cases for testing arrays with dimensions that can be zero.",
            "class test_zerodim(TestCase):",
            "    def test_zerodim1d(self):",
            "        a0 = array([], dtype=int32)",
            "        a1 = array([], dtype=float64)",
            "",
            "        r0 = evaluate('a0 + a1')",
            "        r1 = evaluate('a0 * a1')",
            "",
            "        assert_array_equal(r0, a1)",
            "        assert_array_equal(r1, a1)",
            "",
            "    def test_zerodim3d(self):",
            "        a0 = array([], dtype=int32).reshape(0, 2, 4)",
            "        a1 = array([], dtype=float64).reshape(0, 2, 4)",
            "",
            "        r0 = evaluate('a0 + a1')",
            "        r1 = evaluate('a0 * a1')",
            "",
            "        assert_array_equal(r0, a1)",
            "        assert_array_equal(r1, a1)",
            "",
            "",
            "@contextmanager",
            "def _environment(key, value):",
            "    old = os.environ.get(key)",
            "    os.environ[key] = value",
            "    try:",
            "        yield",
            "    finally:",
            "        if old:",
            "            os.environ[key] = old",
            "        else:",
            "            del os.environ[key]",
            "",
            "# Test cases for the threading configuration",
            "class test_threading_config(TestCase):",
            "    def test_max_threads_unset(self):",
            "        # Has to be done in a subprocess as `importlib.reload` doesn't let us ",
            "        # re-initialize the threadpool",
            "        script = '\\n'.join([",
            "                \"import os\",",
            "                \"if 'NUMEXPR_MAX_THREADS' in os.environ: os.environ.pop('NUMEXPR_MAX_THREADS')\",",
            "                \"if 'OMP_NUM_THREADS' in os.environ: os.environ.pop('OMP_NUM_THREADS')\",",
            "                \"import numexpr\",",
            "                \"assert(numexpr.nthreads <= 8)\",",
            "                \"exit(0)\"])",
            "        subprocess.check_call([sys.executable, '-c', script])",
            "",
            "    def test_max_threads_set(self):",
            "        # Has to be done in a subprocess as `importlib.reload` doesn't let us ",
            "        # re-initialize the threadpool",
            "        script = '\\n'.join([",
            "                \"import os\",",
            "                \"os.environ['NUMEXPR_MAX_THREADS'] = '4'\",",
            "                \"import numexpr\",",
            "                \"assert(numexpr.MAX_THREADS == 4)\",",
            "                \"exit(0)\"])",
            "        subprocess.check_call([sys.executable, '-c', script])",
            "",
            "    def test_numexpr_num_threads(self):",
            "        with _environment('OMP_NUM_THREADS', '5'):",
            "            # NUMEXPR_NUM_THREADS has priority",
            "            with _environment('NUMEXPR_NUM_THREADS', '3'):",
            "                 if 'sparc' in platform.machine():",
            "                     self.assertEqual(1, numexpr._init_num_threads())",
            "                 else:",
            "                     self.assertEqual(3, numexpr._init_num_threads())",
            "",
            "    def test_omp_num_threads(self):",
            "        with _environment('OMP_NUM_THREADS', '5'):",
            "            if 'sparc' in platform.machine():",
            "                self.assertEqual(1, numexpr._init_num_threads())",
            "            else:",
            "                self.assertEqual(5, numexpr._init_num_threads())",
            "",
            "    def test_vml_threads_round_trip(self):",
            "        n_threads = 3",
            "        if use_vml:",
            "            numexpr.utils.set_vml_num_threads(n_threads)",
            "            set_threads = numexpr.utils.get_vml_num_threads()",
            "            self.assertEqual(n_threads, set_threads)",
            "        else:",
            "            self.assertIsNone(numexpr.utils.set_vml_num_threads(n_threads))",
            "            self.assertIsNone(numexpr.utils.get_vml_num_threads())",
            "",
            "",
            "# Case test for threads",
            "class test_threading(TestCase):",
            "",
            "    def test_thread(self):",
            "        import threading",
            "",
            "        class ThreadTest(threading.Thread):",
            "            def run(self):",
            "                a = arange(3)",
            "                assert_array_equal(evaluate('a**3'), array([0, 1, 8]))",
            "",
            "        test = ThreadTest()",
            "        test.start()",
            "        test.join()",
            "",
            "    def test_multithread(self):",
            "        import threading",
            "",
            "        # Running evaluate() from multiple threads shouldn't crash",
            "        def work(n):",
            "            a = arange(n)",
            "            evaluate('a+a')",
            "",
            "        work(10)  # warm compilation cache",
            "",
            "        nthreads = 30",
            "        threads = [threading.Thread(target=work, args=(1e5,))",
            "                   for i in range(nthreads)]",
            "        for t in threads:",
            "            t.start()",
            "        for t in threads:",
            "            t.join()",
            "",
            "",
            "# The worker function for the subprocess (needs to be here because Windows",
            "# has problems pickling nested functions with the multiprocess module :-/)",
            "def _worker(qout=None):",
            "    ra = np.arange(1e3)",
            "    rows = evaluate('ra > 0')",
            "    #print \"Succeeded in evaluation!\\n\"",
            "    if qout is not None:",
            "        qout.put(\"Done\")",
            "",
            "",
            "# Case test for subprocesses (via multiprocessing module)",
            "class test_subprocess(TestCase):",
            "    def test_multiprocess(self):",
            "        try:",
            "            import multiprocessing as mp",
            "        except ImportError:",
            "            return",
            "        # Check for two threads at least",
            "        numexpr.set_num_threads(2)",
            "        #print \"**** Running from main process:\"",
            "        _worker()",
            "        #print \"**** Running from subprocess:\"",
            "        qout = mp.Queue()",
            "        ps = mp.Process(target=_worker, args=(qout,))",
            "        ps.daemon = True",
            "        ps.start()",
            "",
            "        result = qout.get()",
            "        #print result",
            "",
            "",
            "def print_versions():",
            "    \"\"\"Print the versions of software that numexpr relies on.\"\"\"",
            "    # from pkg_resources import parse_version",
            "    from numexpr.cpuinfo import cpu",
            "    import platform",
            "",
            "    print('-=' * 38)",
            "    print('Numexpr version:   %s' % numexpr.__version__)",
            "    print('NumPy version:     %s' % np.__version__)",
            "    print('Python version:    %s' % sys.version)",
            "    (sysname, nodename, release, os_version, machine, processor) = platform.uname()",
            "    print('Platform:          %s-%s-%s' % (sys.platform, machine, os_version))",
            "    try:",
            "        # cpuinfo doesn't work on OSX well it seems, so protect these outputs ",
            "        # with a try block",
            "        cpu_info = cpu.info[0]",
            "        print('CPU vendor:        %s' % cpu_info.get('VendorIdentifier', ''))",
            "        print('CPU model:         %s' % cpu_info.get('ProcessorNameString', ''))",
            "        print('CPU clock speed:   %s MHz' % cpu_info.get('~MHz',''))",
            "    except KeyError:",
            "        pass",
            "    print('VML available?     %s' % use_vml)",
            "    if use_vml:",
            "        print('VML/MKL version:   %s' % numexpr.get_vml_version())",
            "    print('Number of threads used by default: %d '",
            "          '(out of %d detected cores)' % (numexpr.nthreads, numexpr.ncores))",
            "    print('Maximum number of threads: %s' % numexpr.MAX_THREADS)",
            "    print('-=' * 38)",
            "",
            "",
            "def test(verbosity=1):",
            "    \"\"\"",
            "    Run all the tests in the test suite.",
            "    \"\"\"",
            "    print_versions()",
            "    # For some reason, NumPy issues all kinds of warnings when using Python3.",
            "    # Ignoring them in tests should be ok, as all results are checked out.",
            "    # See https://github.com/pydata/numexpr/issues/183 for details.",
            "    np.seterr(divide='ignore', invalid='ignore', over='ignore', under='ignore')",
            "    return unittest.TextTestRunner(verbosity=verbosity).run(suite())",
            "",
            "",
            "test.__test__ = False",
            "",
            "",
            "def suite():",
            "    import unittest",
            "    import platform as pl",
            "",
            "    theSuite = unittest.TestSuite()",
            "    niter = 1",
            "",
            "    class TestExpressions(TestCase):",
            "        pass",
            "",
            "    def add_method(func):",
            "        def method(self):",
            "            return func()",
            "",
            "        setattr(TestExpressions, func.__name__,",
            "                method.__get__(None, TestExpressions))",
            "",
            "    for func in test_expressions():",
            "        add_method(func)",
            "",
            "    for n in range(niter):",
            "        theSuite.addTest(unittest.makeSuite(test_numexpr))",
            "        if 'sparc' not in platform.machine():",
            "            theSuite.addTest(unittest.makeSuite(test_numexpr2))",
            "        theSuite.addTest(unittest.makeSuite(test_evaluate))",
            "        theSuite.addTest(unittest.makeSuite(TestExpressions))",
            "        theSuite.addTest(unittest.makeSuite(test_int32_int64))",
            "        theSuite.addTest(unittest.makeSuite(test_uint32_int64))",
            "        theSuite.addTest(unittest.makeSuite(test_strings))",
            "        theSuite.addTest(",
            "            unittest.makeSuite(test_irregular_stride))",
            "        theSuite.addTest(unittest.makeSuite(test_zerodim))",
            "        theSuite.addTest(unittest.makeSuite(test_threading_config))",
            "",
            "        # multiprocessing module is not supported on Hurd/kFreeBSD",
            "        if (pl.system().lower() not in ('gnu', 'gnu/kfreebsd')):",
            "            theSuite.addTest(unittest.makeSuite(test_subprocess))",
            "",
            "        # I need to put this test after test_subprocess because",
            "        # if not, the test suite locks immediately before test_subproces.",
            "        # This only happens with Windows, so I suspect of a subtle bad",
            "        # interaction with threads and subprocess :-/",
            "        theSuite.addTest(unittest.makeSuite(test_threading))",
            "",
            "    return theSuite",
            "",
            "",
            "if __name__ == '__main__':",
            "    print_versions()",
            "    unittest.main(defaultTest='suite')",
            "#    suite = suite()",
            "#    unittest.TextTestRunner(verbosity=2).run(suite)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "376": [
                "test_evaluate",
                "test_re_evaluate_dict"
            ],
            "377": [
                "test_evaluate",
                "test_re_evaluate_dict"
            ],
            "403": [
                "test_evaluate",
                "test_validate_dict"
            ],
            "405": [
                "test_evaluate",
                "test_validate_dict"
            ],
            "505": [
                "test_evaluate",
                "test_illegal_value"
            ]
        },
        "addLocation": []
    }
}