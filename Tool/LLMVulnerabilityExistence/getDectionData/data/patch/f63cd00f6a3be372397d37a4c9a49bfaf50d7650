{
    "mage_ai/server/terminal_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from mage_ai.api.utils import authenticate_client_and_token"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from mage_ai.api.utils import ("
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+    authenticate_client_and_token,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+    has_at_least_editor_role,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+)"
            },
            "5": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from mage_ai.orchestration.db.models.oauth import Oauth2Application"
            },
            "6": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from mage_ai.settings import REQUIRE_USER_AUTHENTICATION"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from mage_ai.settings import ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+    is_disable_pipeline_edit_access,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+    REQUIRE_USER_AUTHENTICATION,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from tornado import gen"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import json"
            },
            "13": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import terminado"
            },
            "14": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import tornado.websocket"
            },
            "15": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import re"
            },
            "16": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "                     oauth_token.user"
            },
            "17": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 if valid:"
            },
            "18": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                     user = oauth_token.user"
            },
            "19": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "20": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    raise Exception('Invalid token')"
            },
            "21": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         self.term_name = term_name if term_name else 'tty'"
            },
            "23": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         if user:"
            },
            "24": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         self.terminal.clients.append(self)"
            },
            "25": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         self.__initiate_terminal(self.terminal)"
            },
            "26": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    @gen.coroutine"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    def on_message(self, raw_message):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        message = json.loads(raw_message)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        api_key = message.get('api_key')"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        token = message.get('token')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        command = message.get('command')"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        if REQUIRE_USER_AUTHENTICATION or is_disable_pipeline_edit_access():"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            valid = False"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            if api_key and token:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+                oauth_client = Oauth2Application.query.filter("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+                    Oauth2Application.client_id == api_key,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                ).first()"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                if oauth_client:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                    oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                    valid = valid and \\"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                        oauth_token and \\"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                        oauth_token.user and \\"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                        has_at_least_editor_role(oauth_token.user)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            if not valid or is_disable_pipeline_edit_access():"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                return self.send_json_message("
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+                    ['stdout', f'{command[1]}\\nUnauthorized access to the terminal.'])"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        super().on_message(json.dumps(command))"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     def __initiate_terminal(self, terminal):"
            },
            "55": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self.send_json_message([\"setup\", {}])"
            },
            "56": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         self._logger.info(\"TermSocket.open: Opened %s\", self.term_name)"
            }
        },
        "frontPatchFile": [
            "from mage_ai.api.utils import authenticate_client_and_token",
            "from mage_ai.orchestration.db.models.oauth import Oauth2Application",
            "from mage_ai.settings import REQUIRE_USER_AUTHENTICATION",
            "import terminado",
            "import tornado.websocket",
            "import re",
            "",
            "",
            "class MageTermManager(terminado.NamedTermManager):",
            "    def get_terminal(self, term_name: str, **kwargs):",
            "        assert term_name is not None",
            "",
            "        if term_name in self.terminals:",
            "            return self.terminals[term_name]",
            "",
            "        if self.max_terminals and len(self.terminals) >= self.max_terminals:",
            "            raise terminado.management.MaxTerminalsReached(self.max_terminals)",
            "",
            "        # Create new terminal",
            "        self.log.info(\"New terminal with specified name: %s\", term_name)",
            "        term = self.new_terminal(**kwargs)",
            "        term.term_name = term_name",
            "        self.terminals[term_name] = term",
            "        self.start_reading(term)",
            "        return term",
            "",
            "",
            "class MageUniqueTermManager(terminado.UniqueTermManager):",
            "    def get_terminal(self, url_component=None, **kwargs):",
            "        if self.max_terminals and len(self.ptys_by_fd) >= self.max_terminals:",
            "            raise terminado.management.MaxTerminalsReached(self.max_terminals)",
            "",
            "        term = self.new_terminal(**kwargs)",
            "        self.start_reading(term)",
            "        return term",
            "",
            "",
            "class TerminalWebsocketServer(terminado.TermSocket):",
            "    @property",
            "    def term_command(self):",
            "        return next(iter(self.term_manager.shell_command))",
            "",
            "    def check_origin(self, origin):",
            "        return True",
            "",
            "    def on_pty_read(self, text):",
            "        \"\"\"Data read from pty; send to frontend\"\"\"",
            "        updated_text = text",
            "        if self.term_command == 'cmd':",
            "            xterm_escape = re.compile(r'(?:\\x1B\\]0;).*\\x07')",
            "            updated_text = xterm_escape.sub('', text)",
            "        self.send_json_message([\"stdout\", updated_text])",
            "",
            "    def open(self, *args, **kwargs):",
            "        \"\"\"Websocket connection opened.",
            "",
            "        Call our terminal manager to get a terminal, and connect to it as a",
            "        client.",
            "        \"\"\"",
            "        # Jupyter has a mixin to ping websockets and keep connections through",
            "        # proxies alive. Call super() to allow that to set up:",
            "        tornado.websocket.WebSocketHandler.open(self, *args, **kwargs)",
            "        api_key = self.get_argument('api_key', None, True)",
            "        token = self.get_argument('token', None, True)",
            "",
            "        cwd = self.get_argument('cwd', None, True)",
            "        term_name = self.get_argument('term_name', None, True)",
            "",
            "        user = None",
            "        if REQUIRE_USER_AUTHENTICATION and api_key and token:",
            "            oauth_client = Oauth2Application.query.filter(",
            "                Oauth2Application.client_id == api_key,",
            "            ).first()",
            "            if oauth_client:",
            "                oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)",
            "                valid = valid and \\",
            "                    oauth_token and \\",
            "                    oauth_token.user",
            "                if valid:",
            "                    user = oauth_token.user",
            "                else:",
            "                    raise Exception('Invalid token')",
            "",
            "        self.term_name = term_name if term_name else 'tty'",
            "        if user:",
            "            self.term_name = f'{self.term_name}_{user.id}'",
            "",
            "        self._logger.info(\"TermSocket.open: %s\", self.term_name)",
            "",
            "        self.terminal = self.term_manager.get_terminal(self.term_name, cwd=cwd)",
            "        self.terminal.clients.append(self)",
            "        self.__initiate_terminal(self.terminal)",
            "",
            "    def __initiate_terminal(self, terminal):",
            "        self.send_json_message([\"setup\", {}])",
            "        self._logger.info(\"TermSocket.open: Opened %s\", self.term_name)",
            "        # Now drain the preopen buffer, if reconnect.",
            "        buffered = \"\"",
            "        preopen_buffer = terminal.read_buffer.copy()",
            "        while True:",
            "            if not preopen_buffer:",
            "                break",
            "            s = preopen_buffer.popleft()",
            "            buffered += s",
            "        if buffered:",
            "            self.on_pty_read(buffered)",
            "",
            "        # Turn enable-bracketed-paste off since it can mess up the output.",
            "        if self.term_command == 'bash':",
            "            terminal.ptyproc.write(",
            "                \"bind 'set enable-bracketed-paste off' # Mage terminal settings command\\r\")",
            "        terminal.read_buffer.clear()"
        ],
        "afterPatchFile": [
            "from mage_ai.api.utils import (",
            "    authenticate_client_and_token,",
            "    has_at_least_editor_role,",
            ")",
            "from mage_ai.orchestration.db.models.oauth import Oauth2Application",
            "from mage_ai.settings import (",
            "    is_disable_pipeline_edit_access,",
            "    REQUIRE_USER_AUTHENTICATION,",
            ")",
            "from tornado import gen",
            "import json",
            "import terminado",
            "import tornado.websocket",
            "import re",
            "",
            "",
            "class MageTermManager(terminado.NamedTermManager):",
            "    def get_terminal(self, term_name: str, **kwargs):",
            "        assert term_name is not None",
            "",
            "        if term_name in self.terminals:",
            "            return self.terminals[term_name]",
            "",
            "        if self.max_terminals and len(self.terminals) >= self.max_terminals:",
            "            raise terminado.management.MaxTerminalsReached(self.max_terminals)",
            "",
            "        # Create new terminal",
            "        self.log.info(\"New terminal with specified name: %s\", term_name)",
            "        term = self.new_terminal(**kwargs)",
            "        term.term_name = term_name",
            "        self.terminals[term_name] = term",
            "        self.start_reading(term)",
            "        return term",
            "",
            "",
            "class MageUniqueTermManager(terminado.UniqueTermManager):",
            "    def get_terminal(self, url_component=None, **kwargs):",
            "        if self.max_terminals and len(self.ptys_by_fd) >= self.max_terminals:",
            "            raise terminado.management.MaxTerminalsReached(self.max_terminals)",
            "",
            "        term = self.new_terminal(**kwargs)",
            "        self.start_reading(term)",
            "        return term",
            "",
            "",
            "class TerminalWebsocketServer(terminado.TermSocket):",
            "    @property",
            "    def term_command(self):",
            "        return next(iter(self.term_manager.shell_command))",
            "",
            "    def check_origin(self, origin):",
            "        return True",
            "",
            "    def on_pty_read(self, text):",
            "        \"\"\"Data read from pty; send to frontend\"\"\"",
            "        updated_text = text",
            "        if self.term_command == 'cmd':",
            "            xterm_escape = re.compile(r'(?:\\x1B\\]0;).*\\x07')",
            "            updated_text = xterm_escape.sub('', text)",
            "        self.send_json_message([\"stdout\", updated_text])",
            "",
            "    def open(self, *args, **kwargs):",
            "        \"\"\"Websocket connection opened.",
            "",
            "        Call our terminal manager to get a terminal, and connect to it as a",
            "        client.",
            "        \"\"\"",
            "        # Jupyter has a mixin to ping websockets and keep connections through",
            "        # proxies alive. Call super() to allow that to set up:",
            "        tornado.websocket.WebSocketHandler.open(self, *args, **kwargs)",
            "        api_key = self.get_argument('api_key', None, True)",
            "        token = self.get_argument('token', None, True)",
            "",
            "        cwd = self.get_argument('cwd', None, True)",
            "        term_name = self.get_argument('term_name', None, True)",
            "",
            "        user = None",
            "        if REQUIRE_USER_AUTHENTICATION and api_key and token:",
            "            oauth_client = Oauth2Application.query.filter(",
            "                Oauth2Application.client_id == api_key,",
            "            ).first()",
            "            if oauth_client:",
            "                oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)",
            "                valid = valid and \\",
            "                    oauth_token and \\",
            "                    oauth_token.user",
            "                if valid:",
            "                    user = oauth_token.user",
            "",
            "        self.term_name = term_name if term_name else 'tty'",
            "        if user:",
            "            self.term_name = f'{self.term_name}_{user.id}'",
            "",
            "        self._logger.info(\"TermSocket.open: %s\", self.term_name)",
            "",
            "        self.terminal = self.term_manager.get_terminal(self.term_name, cwd=cwd)",
            "        self.terminal.clients.append(self)",
            "        self.__initiate_terminal(self.terminal)",
            "",
            "    @gen.coroutine",
            "    def on_message(self, raw_message):",
            "        message = json.loads(raw_message)",
            "",
            "        api_key = message.get('api_key')",
            "        token = message.get('token')",
            "        command = message.get('command')",
            "",
            "        if REQUIRE_USER_AUTHENTICATION or is_disable_pipeline_edit_access():",
            "            valid = False",
            "",
            "            if api_key and token:",
            "                oauth_client = Oauth2Application.query.filter(",
            "                    Oauth2Application.client_id == api_key,",
            "                ).first()",
            "                if oauth_client:",
            "                    oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)",
            "                    valid = valid and \\",
            "                        oauth_token and \\",
            "                        oauth_token.user and \\",
            "                        has_at_least_editor_role(oauth_token.user)",
            "            if not valid or is_disable_pipeline_edit_access():",
            "                return self.send_json_message(",
            "                    ['stdout', f'{command[1]}\\nUnauthorized access to the terminal.'])",
            "",
            "        super().on_message(json.dumps(command))",
            "",
            "    def __initiate_terminal(self, terminal):",
            "        self.send_json_message([\"setup\", {}])",
            "        self._logger.info(\"TermSocket.open: Opened %s\", self.term_name)",
            "        # Now drain the preopen buffer, if reconnect.",
            "        buffered = \"\"",
            "        preopen_buffer = terminal.read_buffer.copy()",
            "        while True:",
            "            if not preopen_buffer:",
            "                break",
            "            s = preopen_buffer.popleft()",
            "            buffered += s",
            "        if buffered:",
            "            self.on_pty_read(buffered)",
            "",
            "        # Turn enable-bracketed-paste off since it can mess up the output.",
            "        if self.term_command == 'bash':",
            "            terminal.ptyproc.write(",
            "                \"bind 'set enable-bracketed-paste off' # Mage terminal settings command\\r\")",
            "        terminal.read_buffer.clear()"
        ],
        "action": [
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [],
            "3": [],
            "81": [
                "TerminalWebsocketServer",
                "open"
            ],
            "82": [
                "TerminalWebsocketServer",
                "open"
            ]
        },
        "addLocation": []
    }
}