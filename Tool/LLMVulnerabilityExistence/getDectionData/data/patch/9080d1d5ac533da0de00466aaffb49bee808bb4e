{
    "ecdsa/der.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     return int2byte(0x80|llen) + s"
            },
            "1": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " def read_length(string):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    if not string:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        raise UnexpectedDER(\"Empty string can't encode valid length value\")"
            },
            "5": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     num = string[0] if isinstance(string[0], integer_types) else ord(string[0])"
            },
            "6": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     if not (num & 0x80):"
            },
            "7": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         # short form"
            },
            "8": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         return (num & 0x7f), 1"
            },
            "9": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     # else long-form: b0&0x7f is number of additional base256 length bytes,"
            },
            "10": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     # big-endian"
            },
            "11": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     llen = num & 0x7f"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    if not llen:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        raise UnexpectedDER(\"Invalid length encoding, length byte is 0\")"
            },
            "14": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     if llen > len(string)-1:"
            },
            "15": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         raise UnexpectedDER(\"ran out of length bytes\")"
            },
            "16": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     return int(binascii.hexlify(string[1:1+llen]), 16), 1+llen"
            }
        },
        "frontPatchFile": [
            "from __future__ import division",
            "",
            "import binascii",
            "import base64",
            "from .six import int2byte, b, integer_types, text_type",
            "",
            "class UnexpectedDER(Exception):",
            "    pass",
            "",
            "def encode_constructed(tag, value):",
            "    return int2byte(0xa0+tag) + encode_length(len(value)) + value",
            "def encode_integer(r):",
            "    assert r >= 0 # can't support negative numbers yet",
            "    h = (\"%x\" % r).encode()",
            "    if len(h) % 2:",
            "        h = b(\"0\") + h",
            "    s = binascii.unhexlify(h)",
            "    num = s[0] if isinstance(s[0], integer_types) else ord(s[0])",
            "    if num <= 0x7f:",
            "        return b(\"\\x02\") + int2byte(len(s)) + s",
            "    else:",
            "        # DER integers are two's complement, so if the first byte is",
            "        # 0x80-0xff then we need an extra 0x00 byte to prevent it from",
            "        # looking negative.",
            "        return b(\"\\x02\") + int2byte(len(s)+1) + b(\"\\x00\") + s",
            "",
            "def encode_bitstring(s):",
            "    return b(\"\\x03\") + encode_length(len(s)) + s",
            "def encode_octet_string(s):",
            "    return b(\"\\x04\") + encode_length(len(s)) + s",
            "def encode_oid(first, second, *pieces):",
            "    assert first <= 2",
            "    assert second <= 39",
            "    encoded_pieces = [int2byte(40*first+second)] + [encode_number(p)",
            "                                                    for p in pieces]",
            "    body = b('').join(encoded_pieces)",
            "    return b('\\x06') + encode_length(len(body)) + body",
            "def encode_sequence(*encoded_pieces):",
            "    total_len = sum([len(p) for p in encoded_pieces])",
            "    return b('\\x30') + encode_length(total_len) + b('').join(encoded_pieces)",
            "def encode_number(n):",
            "    b128_digits = []",
            "    while n:",
            "        b128_digits.insert(0, (n & 0x7f) | 0x80)",
            "        n = n >> 7",
            "    if not b128_digits:",
            "        b128_digits.append(0)",
            "    b128_digits[-1] &= 0x7f",
            "    return b('').join([int2byte(d) for d in b128_digits])",
            "",
            "def remove_constructed(string):",
            "    s0 = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if (s0 & 0xe0) != 0xa0:",
            "        raise UnexpectedDER(\"wanted constructed tag (0xa0-0xbf), got 0x%02x\"",
            "                            % s0)",
            "    tag = s0 & 0x1f",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return tag, body, rest",
            "",
            "def remove_sequence(string):",
            "    if not string:",
            "        raise UnexpectedDER(\"Empty string does not encode a sequence\")",
            "    if not string.startswith(b(\"\\x30\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else \\",
            "                ord(string[0])",
            "        raise UnexpectedDER(\"wanted type 'sequence' (0x30), got 0x%02x\" % n)",
            "    length, lengthlength = read_length(string[1:])",
            "    if length > len(string) - 1 - lengthlength:",
            "        raise UnexpectedDER(\"Length longer than the provided buffer\")",
            "    endseq = 1+lengthlength+length",
            "    return string[1+lengthlength:endseq], string[endseq:]",
            "",
            "def remove_octet_string(string):",
            "    if not string.startswith(b(\"\\x04\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "        raise UnexpectedDER(\"wanted octetstring (0x04), got 0x%02x\" % n)",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return body, rest",
            "",
            "def remove_object(string):",
            "    if not string.startswith(b(\"\\x06\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "        raise UnexpectedDER(\"wanted object (0x06), got 0x%02x\" % n)",
            "    length, lengthlength = read_length(string[1:])",
            "    body = string[1+lengthlength:1+lengthlength+length]",
            "    rest = string[1+lengthlength+length:]",
            "    numbers = []",
            "    while body:",
            "        n, ll = read_number(body)",
            "        numbers.append(n)",
            "        body = body[ll:]",
            "    n0 = numbers.pop(0)",
            "    first = n0//40",
            "    second = n0-(40*first)",
            "    numbers.insert(0, first)",
            "    numbers.insert(1, second)",
            "    return tuple(numbers), rest",
            "",
            "def remove_integer(string):",
            "    if not string:",
            "        raise UnexpectedDER(\"Empty string is an invalid encoding of an \"",
            "                            \"integer\")",
            "    if not string.startswith(b(\"\\x02\")):",
            "        n = string[0] if isinstance(string[0], integer_types) \\",
            "                else ord(string[0])",
            "        raise UnexpectedDER(\"wanted type 'integer' (0x02), got 0x%02x\" % n)",
            "    length, llen = read_length(string[1:])",
            "    if length > len(string) - 1 - llen:",
            "        raise UnexpectedDER(\"Length longer than provided buffer\")",
            "    if length == 0:",
            "        raise UnexpectedDER(\"0-byte long encoding of integer\")",
            "    numberbytes = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    nbytes = numberbytes[0] if isinstance(numberbytes[0], integer_types) \\",
            "            else ord(numberbytes[0])",
            "    if not nbytes < 0x80:",
            "        raise UnexpectedDER(\"Negative integers are not supported\")",
            "    return int(binascii.hexlify(numberbytes), 16), rest",
            "",
            "def read_number(string):",
            "    number = 0",
            "    llen = 0",
            "    # base-128 big endian, with b7 set in all but the last byte",
            "    while True:",
            "        if llen > len(string):",
            "            raise UnexpectedDER(\"ran out of length bytes\")",
            "        number = number << 7",
            "        d = string[llen] if isinstance(string[llen], integer_types) else ord(string[llen])",
            "        number += (d & 0x7f)",
            "        llen += 1",
            "        if not d & 0x80:",
            "            break",
            "    return number, llen",
            "",
            "def encode_length(l):",
            "    assert l >= 0",
            "    if l < 0x80:",
            "        return int2byte(l)",
            "    s = (\"%x\" % l).encode()",
            "    if len(s)%2:",
            "        s = b(\"0\")+s",
            "    s = binascii.unhexlify(s)",
            "    llen = len(s)",
            "    return int2byte(0x80|llen) + s",
            "",
            "def read_length(string):",
            "    num = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if not (num & 0x80):",
            "        # short form",
            "        return (num & 0x7f), 1",
            "    # else long-form: b0&0x7f is number of additional base256 length bytes,",
            "    # big-endian",
            "    llen = num & 0x7f",
            "    if llen > len(string)-1:",
            "        raise UnexpectedDER(\"ran out of length bytes\")",
            "    return int(binascii.hexlify(string[1:1+llen]), 16), 1+llen",
            "",
            "def remove_bitstring(string):",
            "    num = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if not string.startswith(b(\"\\x03\")):",
            "        raise UnexpectedDER(\"wanted bitstring (0x03), got 0x%02x\" % num)",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return body, rest",
            "",
            "# SEQUENCE([1, STRING(secexp), cont[0], OBJECT(curvename), cont[1], BINTSTRING)",
            "",
            "",
            "# signatures: (from RFC3279)",
            "#  ansi-X9-62  OBJECT IDENTIFIER ::= {",
            "#       iso(1) member-body(2) us(840) 10045 }",
            "#",
            "#  id-ecSigType OBJECT IDENTIFIER  ::=  {",
            "#       ansi-X9-62 signatures(4) }",
            "#  ecdsa-with-SHA1  OBJECT IDENTIFIER ::= {",
            "#       id-ecSigType 1 }",
            "## so 1,2,840,10045,4,1",
            "## so 0x42, .. ..",
            "",
            "#  Ecdsa-Sig-Value  ::=  SEQUENCE  {",
            "#       r     INTEGER,",
            "#       s     INTEGER  }",
            "",
            "# id-public-key-type OBJECT IDENTIFIER  ::= { ansi-X9.62 2 }",
            "#",
            "# id-ecPublicKey OBJECT IDENTIFIER ::= { id-publicKeyType 1 }",
            "",
            "# I think the secp224r1 identifier is (t=06,l=05,v=2b81040021)",
            "#  secp224r1 OBJECT IDENTIFIER ::= {",
            "#  iso(1) identified-organization(3) certicom(132) curve(0) 33 }",
            "# and the secp384r1 is (t=06,l=05,v=2b81040022)",
            "#  secp384r1 OBJECT IDENTIFIER ::= {",
            "#  iso(1) identified-organization(3) certicom(132) curve(0) 34 }",
            "",
            "def unpem(pem):",
            "    if isinstance(pem, text_type):",
            "        pem = pem.encode()",
            "",
            "    d = b(\"\").join([l.strip() for l in pem.split(b(\"\\n\"))",
            "                    if l and not l.startswith(b(\"-----\"))])",
            "    return base64.b64decode(d)",
            "def topem(der, name):",
            "    b64 = base64.b64encode(der)",
            "    lines = [(\"-----BEGIN %s-----\\n\" % name).encode()]",
            "    lines.extend([b64[start:start+64]+b(\"\\n\")",
            "                  for start in range(0, len(b64), 64)])",
            "    lines.append((\"-----END %s-----\\n\" % name).encode())",
            "    return b(\"\").join(lines)"
        ],
        "afterPatchFile": [
            "from __future__ import division",
            "",
            "import binascii",
            "import base64",
            "from .six import int2byte, b, integer_types, text_type",
            "",
            "class UnexpectedDER(Exception):",
            "    pass",
            "",
            "def encode_constructed(tag, value):",
            "    return int2byte(0xa0+tag) + encode_length(len(value)) + value",
            "def encode_integer(r):",
            "    assert r >= 0 # can't support negative numbers yet",
            "    h = (\"%x\" % r).encode()",
            "    if len(h) % 2:",
            "        h = b(\"0\") + h",
            "    s = binascii.unhexlify(h)",
            "    num = s[0] if isinstance(s[0], integer_types) else ord(s[0])",
            "    if num <= 0x7f:",
            "        return b(\"\\x02\") + int2byte(len(s)) + s",
            "    else:",
            "        # DER integers are two's complement, so if the first byte is",
            "        # 0x80-0xff then we need an extra 0x00 byte to prevent it from",
            "        # looking negative.",
            "        return b(\"\\x02\") + int2byte(len(s)+1) + b(\"\\x00\") + s",
            "",
            "def encode_bitstring(s):",
            "    return b(\"\\x03\") + encode_length(len(s)) + s",
            "def encode_octet_string(s):",
            "    return b(\"\\x04\") + encode_length(len(s)) + s",
            "def encode_oid(first, second, *pieces):",
            "    assert first <= 2",
            "    assert second <= 39",
            "    encoded_pieces = [int2byte(40*first+second)] + [encode_number(p)",
            "                                                    for p in pieces]",
            "    body = b('').join(encoded_pieces)",
            "    return b('\\x06') + encode_length(len(body)) + body",
            "def encode_sequence(*encoded_pieces):",
            "    total_len = sum([len(p) for p in encoded_pieces])",
            "    return b('\\x30') + encode_length(total_len) + b('').join(encoded_pieces)",
            "def encode_number(n):",
            "    b128_digits = []",
            "    while n:",
            "        b128_digits.insert(0, (n & 0x7f) | 0x80)",
            "        n = n >> 7",
            "    if not b128_digits:",
            "        b128_digits.append(0)",
            "    b128_digits[-1] &= 0x7f",
            "    return b('').join([int2byte(d) for d in b128_digits])",
            "",
            "def remove_constructed(string):",
            "    s0 = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if (s0 & 0xe0) != 0xa0:",
            "        raise UnexpectedDER(\"wanted constructed tag (0xa0-0xbf), got 0x%02x\"",
            "                            % s0)",
            "    tag = s0 & 0x1f",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return tag, body, rest",
            "",
            "def remove_sequence(string):",
            "    if not string:",
            "        raise UnexpectedDER(\"Empty string does not encode a sequence\")",
            "    if not string.startswith(b(\"\\x30\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else \\",
            "                ord(string[0])",
            "        raise UnexpectedDER(\"wanted type 'sequence' (0x30), got 0x%02x\" % n)",
            "    length, lengthlength = read_length(string[1:])",
            "    if length > len(string) - 1 - lengthlength:",
            "        raise UnexpectedDER(\"Length longer than the provided buffer\")",
            "    endseq = 1+lengthlength+length",
            "    return string[1+lengthlength:endseq], string[endseq:]",
            "",
            "def remove_octet_string(string):",
            "    if not string.startswith(b(\"\\x04\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "        raise UnexpectedDER(\"wanted octetstring (0x04), got 0x%02x\" % n)",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return body, rest",
            "",
            "def remove_object(string):",
            "    if not string.startswith(b(\"\\x06\")):",
            "        n = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "        raise UnexpectedDER(\"wanted object (0x06), got 0x%02x\" % n)",
            "    length, lengthlength = read_length(string[1:])",
            "    body = string[1+lengthlength:1+lengthlength+length]",
            "    rest = string[1+lengthlength+length:]",
            "    numbers = []",
            "    while body:",
            "        n, ll = read_number(body)",
            "        numbers.append(n)",
            "        body = body[ll:]",
            "    n0 = numbers.pop(0)",
            "    first = n0//40",
            "    second = n0-(40*first)",
            "    numbers.insert(0, first)",
            "    numbers.insert(1, second)",
            "    return tuple(numbers), rest",
            "",
            "def remove_integer(string):",
            "    if not string:",
            "        raise UnexpectedDER(\"Empty string is an invalid encoding of an \"",
            "                            \"integer\")",
            "    if not string.startswith(b(\"\\x02\")):",
            "        n = string[0] if isinstance(string[0], integer_types) \\",
            "                else ord(string[0])",
            "        raise UnexpectedDER(\"wanted type 'integer' (0x02), got 0x%02x\" % n)",
            "    length, llen = read_length(string[1:])",
            "    if length > len(string) - 1 - llen:",
            "        raise UnexpectedDER(\"Length longer than provided buffer\")",
            "    if length == 0:",
            "        raise UnexpectedDER(\"0-byte long encoding of integer\")",
            "    numberbytes = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    nbytes = numberbytes[0] if isinstance(numberbytes[0], integer_types) \\",
            "            else ord(numberbytes[0])",
            "    if not nbytes < 0x80:",
            "        raise UnexpectedDER(\"Negative integers are not supported\")",
            "    return int(binascii.hexlify(numberbytes), 16), rest",
            "",
            "def read_number(string):",
            "    number = 0",
            "    llen = 0",
            "    # base-128 big endian, with b7 set in all but the last byte",
            "    while True:",
            "        if llen > len(string):",
            "            raise UnexpectedDER(\"ran out of length bytes\")",
            "        number = number << 7",
            "        d = string[llen] if isinstance(string[llen], integer_types) else ord(string[llen])",
            "        number += (d & 0x7f)",
            "        llen += 1",
            "        if not d & 0x80:",
            "            break",
            "    return number, llen",
            "",
            "def encode_length(l):",
            "    assert l >= 0",
            "    if l < 0x80:",
            "        return int2byte(l)",
            "    s = (\"%x\" % l).encode()",
            "    if len(s)%2:",
            "        s = b(\"0\")+s",
            "    s = binascii.unhexlify(s)",
            "    llen = len(s)",
            "    return int2byte(0x80|llen) + s",
            "",
            "def read_length(string):",
            "    if not string:",
            "        raise UnexpectedDER(\"Empty string can't encode valid length value\")",
            "    num = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if not (num & 0x80):",
            "        # short form",
            "        return (num & 0x7f), 1",
            "    # else long-form: b0&0x7f is number of additional base256 length bytes,",
            "    # big-endian",
            "    llen = num & 0x7f",
            "    if not llen:",
            "        raise UnexpectedDER(\"Invalid length encoding, length byte is 0\")",
            "    if llen > len(string)-1:",
            "        raise UnexpectedDER(\"ran out of length bytes\")",
            "    return int(binascii.hexlify(string[1:1+llen]), 16), 1+llen",
            "",
            "def remove_bitstring(string):",
            "    num = string[0] if isinstance(string[0], integer_types) else ord(string[0])",
            "    if not string.startswith(b(\"\\x03\")):",
            "        raise UnexpectedDER(\"wanted bitstring (0x03), got 0x%02x\" % num)",
            "    length, llen = read_length(string[1:])",
            "    body = string[1+llen:1+llen+length]",
            "    rest = string[1+llen+length:]",
            "    return body, rest",
            "",
            "# SEQUENCE([1, STRING(secexp), cont[0], OBJECT(curvename), cont[1], BINTSTRING)",
            "",
            "",
            "# signatures: (from RFC3279)",
            "#  ansi-X9-62  OBJECT IDENTIFIER ::= {",
            "#       iso(1) member-body(2) us(840) 10045 }",
            "#",
            "#  id-ecSigType OBJECT IDENTIFIER  ::=  {",
            "#       ansi-X9-62 signatures(4) }",
            "#  ecdsa-with-SHA1  OBJECT IDENTIFIER ::= {",
            "#       id-ecSigType 1 }",
            "## so 1,2,840,10045,4,1",
            "## so 0x42, .. ..",
            "",
            "#  Ecdsa-Sig-Value  ::=  SEQUENCE  {",
            "#       r     INTEGER,",
            "#       s     INTEGER  }",
            "",
            "# id-public-key-type OBJECT IDENTIFIER  ::= { ansi-X9.62 2 }",
            "#",
            "# id-ecPublicKey OBJECT IDENTIFIER ::= { id-publicKeyType 1 }",
            "",
            "# I think the secp224r1 identifier is (t=06,l=05,v=2b81040021)",
            "#  secp224r1 OBJECT IDENTIFIER ::= {",
            "#  iso(1) identified-organization(3) certicom(132) curve(0) 33 }",
            "# and the secp384r1 is (t=06,l=05,v=2b81040022)",
            "#  secp384r1 OBJECT IDENTIFIER ::= {",
            "#  iso(1) identified-organization(3) certicom(132) curve(0) 34 }",
            "",
            "def unpem(pem):",
            "    if isinstance(pem, text_type):",
            "        pem = pem.encode()",
            "",
            "    d = b(\"\").join([l.strip() for l in pem.split(b(\"\\n\"))",
            "                    if l and not l.startswith(b(\"-----\"))])",
            "    return base64.b64decode(d)",
            "def topem(der, name):",
            "    b64 = base64.b64encode(der)",
            "    lines = [(\"-----BEGIN %s-----\\n\" % name).encode()]",
            "    lines.extend([b64[start:start+64]+b(\"\\n\")",
            "                  for start in range(0, len(b64), 64)])",
            "    lines.append((\"-----END %s-----\\n\" % name).encode())",
            "    return b(\"\").join(lines)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "ecdsa/test_malformed_sigs.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " # few thousand slow test cases; execute the most interesting only"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " #for curve in curves:"
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-for curve in [NIST256p]:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+for curve in [NIST521p]:"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     #for hash_alg in [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"]:"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     for hash_alg in [\"sha256\"]:"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         key = SigningKey.generate(curve)"
            }
        },
        "frontPatchFile": [
            "from __future__ import with_statement, division",
            "",
            "import pytest",
            "import hashlib",
            "",
            "from six import b, binary_type",
            "from .keys import SigningKey, VerifyingKey",
            "from .keys import BadSignatureError",
            "from .util import sigencode_der, sigencode_string",
            "from .util import sigdecode_der, sigdecode_string",
            "from .curves import curves, NIST256p, NIST521p",
            "",
            "der_sigs = []",
            "example_data = b(\"some data to sign\")",
            "",
            "# Just NIST256p with SHA256 is 560 test cases, all curves with all hashes is",
            "# few thousand slow test cases; execute the most interesting only",
            "",
            "#for curve in curves:",
            "for curve in [NIST256p]:",
            "    #for hash_alg in [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"]:",
            "    for hash_alg in [\"sha256\"]:",
            "        key = SigningKey.generate(curve)",
            "        signature = key.sign(example_data, hashfunc=getattr(hashlib, hash_alg),",
            "                             sigencode=sigencode_der)",
            "        for pos in range(len(signature)):",
            "            for xor in (1<<i for i in range(8)):",
            "                der_sigs.append(pytest.param(",
            "                    key.verifying_key, hash_alg,",
            "                    signature, pos, xor,",
            "                    id=\"{0}-{1}-pos-{2}-xor-{3}\".format(",
            "                        curve.name, hash_alg, pos, xor)))",
            "",
            "",
            "@pytest.mark.parametrize(\"verifying_key,hash_alg,signature,pos,xor\", der_sigs)",
            "def test_fuzzed_der_signatures(verifying_key, hash_alg, signature, pos, xor):",
            "    # check if a malformed DER encoded signature causes the same exception",
            "    # to be raised irrespective of the type of error",
            "    sig = bytearray(signature)",
            "    sig[pos] ^= xor",
            "    sig = binary_type(sig)",
            "",
            "    try:",
            "        verifying_key.verify(sig, example_data, getattr(hashlib, hash_alg),",
            "                             sigdecode_der)",
            "        assert False",
            "    except BadSignatureError:",
            "        assert True",
            "",
            "",
            "####",
            "#",
            "# For string encoded signatures, only the length of string is important",
            "#",
            "####",
            "",
            "str_sigs = []",
            "",
            "#for curve in curves:",
            "for curve in [NIST256p]:",
            "    #for hash_alg in [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"]:",
            "    for hash_alg in [\"sha256\"]:",
            "        key = SigningKey.generate(curve)",
            "        signature = key.sign(example_data, hashfunc=getattr(hashlib, hash_alg),",
            "                             sigencode=sigencode_string)",
            "        for trunc in range(len(signature)):",
            "            str_sigs.append(pytest.param(",
            "                key.verifying_key, hash_alg,",
            "                signature, trunc,",
            "                id=\"{0}-{1}-trunc-{2}\".format(",
            "                    curve.name, hash_alg, trunc)))",
            "",
            "",
            "@pytest.mark.parametrize(\"verifying_key,hash_alg,signature,trunc\", str_sigs)",
            "def test_truncated_string_signatures(verifying_key, hash_alg, signature, trunc):",
            "    # check if a malformed string encoded signature causes the same exception",
            "    # to be raised irrespective of the type of error",
            "    sig = bytearray(signature)",
            "    sig = sig[:trunc]",
            "    sig = binary_type(sig)",
            "",
            "    try:",
            "        verifying_key.verify(sig, example_data, getattr(hashlib, hash_alg),",
            "                             sigdecode_string)",
            "        assert False",
            "    except BadSignatureError:",
            "        assert True"
        ],
        "afterPatchFile": [
            "from __future__ import with_statement, division",
            "",
            "import pytest",
            "import hashlib",
            "",
            "from six import b, binary_type",
            "from .keys import SigningKey, VerifyingKey",
            "from .keys import BadSignatureError",
            "from .util import sigencode_der, sigencode_string",
            "from .util import sigdecode_der, sigdecode_string",
            "from .curves import curves, NIST256p, NIST521p",
            "",
            "der_sigs = []",
            "example_data = b(\"some data to sign\")",
            "",
            "# Just NIST256p with SHA256 is 560 test cases, all curves with all hashes is",
            "# few thousand slow test cases; execute the most interesting only",
            "",
            "#for curve in curves:",
            "for curve in [NIST521p]:",
            "    #for hash_alg in [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"]:",
            "    for hash_alg in [\"sha256\"]:",
            "        key = SigningKey.generate(curve)",
            "        signature = key.sign(example_data, hashfunc=getattr(hashlib, hash_alg),",
            "                             sigencode=sigencode_der)",
            "        for pos in range(len(signature)):",
            "            for xor in (1<<i for i in range(8)):",
            "                der_sigs.append(pytest.param(",
            "                    key.verifying_key, hash_alg,",
            "                    signature, pos, xor,",
            "                    id=\"{0}-{1}-pos-{2}-xor-{3}\".format(",
            "                        curve.name, hash_alg, pos, xor)))",
            "",
            "",
            "@pytest.mark.parametrize(\"verifying_key,hash_alg,signature,pos,xor\", der_sigs)",
            "def test_fuzzed_der_signatures(verifying_key, hash_alg, signature, pos, xor):",
            "    # check if a malformed DER encoded signature causes the same exception",
            "    # to be raised irrespective of the type of error",
            "    sig = bytearray(signature)",
            "    sig[pos] ^= xor",
            "    sig = binary_type(sig)",
            "",
            "    try:",
            "        verifying_key.verify(sig, example_data, getattr(hashlib, hash_alg),",
            "                             sigdecode_der)",
            "        assert False",
            "    except BadSignatureError:",
            "        assert True",
            "",
            "",
            "####",
            "#",
            "# For string encoded signatures, only the length of string is important",
            "#",
            "####",
            "",
            "str_sigs = []",
            "",
            "#for curve in curves:",
            "for curve in [NIST256p]:",
            "    #for hash_alg in [\"md5\", \"sha1\", \"sha224\", \"sha256\", \"sha384\", \"sha512\"]:",
            "    for hash_alg in [\"sha256\"]:",
            "        key = SigningKey.generate(curve)",
            "        signature = key.sign(example_data, hashfunc=getattr(hashlib, hash_alg),",
            "                             sigencode=sigencode_string)",
            "        for trunc in range(len(signature)):",
            "            str_sigs.append(pytest.param(",
            "                key.verifying_key, hash_alg,",
            "                signature, trunc,",
            "                id=\"{0}-{1}-trunc-{2}\".format(",
            "                    curve.name, hash_alg, trunc)))",
            "",
            "",
            "@pytest.mark.parametrize(\"verifying_key,hash_alg,signature,trunc\", str_sigs)",
            "def test_truncated_string_signatures(verifying_key, hash_alg, signature, trunc):",
            "    # check if a malformed string encoded signature causes the same exception",
            "    # to be raised irrespective of the type of error",
            "    sig = bytearray(signature)",
            "    sig = sig[:trunc]",
            "    sig = binary_type(sig)",
            "",
            "    try:",
            "        verifying_key.verify(sig, example_data, getattr(hashlib, hash_alg),",
            "                             sigdecode_string)",
            "        assert False",
            "    except BadSignatureError:",
            "        assert True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": []
        },
        "addLocation": []
    }
}